import {
  e as e4
} from "./chunk-WHOZTSDQ.js";
import {
  m as m5
} from "./chunk-AQE4BJUM.js";
import {
  e as e3
} from "./chunk-UUGXVV4Y.js";
import {
  t
} from "./chunk-DCFV3RPD.js";
import {
  a as a3,
  l as l3
} from "./chunk-5RJLDLHE.js";
import {
  m as m4
} from "./chunk-H6FTFYRV.js";
import {
  d as d2,
  j as j3,
  s as s6,
  u as u2,
  y
} from "./chunk-7BUQKFTK.js";
import {
  e as e2
} from "./chunk-MULZ6YKT.js";
import {
  O,
  c,
  e
} from "./chunk-TE7YCJS2.js";
import {
  n2 as n
} from "./chunk-OP6LRQXD.js";
import "./chunk-NC6NRJ4L.js";
import "./chunk-IXG2DG4Y.js";
import {
  O as O3
} from "./chunk-N6DE36OW.js";
import "./chunk-BGHLEZHC.js";
import "./chunk-TTJN3FRZ.js";
import "./chunk-CZ5NAE7H.js";
import "./chunk-HOMBRYQA.js";
import "./chunk-BTHUW4N5.js";
import {
  j as j2,
  l as l2
} from "./chunk-V6JONRS6.js";
import "./chunk-MX6AIKIJ.js";
import {
  K,
  L as L2,
  k
} from "./chunk-NSP4EL24.js";
import "./chunk-KMSLUMO2.js";
import "./chunk-JZ3NYELE.js";
import "./chunk-UMUW6RKM.js";
import {
  n as n3
} from "./chunk-GDOCPZ6Q.js";
import "./chunk-MTGGGPTM.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-GGULOQ2O.js";
import "./chunk-RKF6WUZT.js";
import "./chunk-QX6KAF46.js";
import "./chunk-IUEM4OPB.js";
import "./chunk-JPOU6HGW.js";
import "./chunk-PS57JJSG.js";
import {
  o,
  u
} from "./chunk-D7ZFLOML.js";
import "./chunk-FV6ZNHFI.js";
import {
  A,
  S,
  m as m2,
  q,
  s as s3
} from "./chunk-ZJQPHR3K.js";
import "./chunk-MFP3CAUX.js";
import "./chunk-EE3PXWPN.js";
import "./chunk-5LHHC3GS.js";
import "./chunk-XL6LITTU.js";
import {
  O as O2,
  b as b3,
  d,
  i as i2
} from "./chunk-T46EFUYJ.js";
import {
  V
} from "./chunk-UQAF7QQZ.js";
import "./chunk-Y2UIZPKP.js";
import {
  C as C2
} from "./chunk-NQNWOZQX.js";
import {
  p
} from "./chunk-WMZMBTHZ.js";
import "./chunk-XJWC7NCV.js";
import "./chunk-4TWBUXAH.js";
import "./chunk-7SZWPZRB.js";
import {
  a as a2,
  f,
  h,
  j,
  l
} from "./chunk-LDV5WK2W.js";
import "./chunk-SDIBXPSJ.js";
import {
  m as m3
} from "./chunk-SDSNQWKE.js";
import {
  z
} from "./chunk-NHSKLNWT.js";
import {
  _,
  c2,
  h as h2
} from "./chunk-GR5Z7GPO.js";
import "./chunk-W5L4VHOE.js";
import {
  f as f2
} from "./chunk-BWSSIPNW.js";
import "./chunk-356T5UZN.js";
import {
  C,
  D,
  P,
  S as S2,
  W,
  Z,
  s as s5,
  w
} from "./chunk-MGG7YB43.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZX7V5AZS.js";
import "./chunk-Y65WZQIV.js";
import {
  s as s4
} from "./chunk-6CTJVQRL.js";
import "./chunk-BHG7PKE6.js";
import {
  b as b2,
  m,
  r as r2
} from "./chunk-VM5L7KHF.js";
import {
  a2 as a
} from "./chunk-A36F4B3C.js";
import "./chunk-YG5HLUHA.js";
import {
  r
} from "./chunk-JBQ4B7X4.js";
import "./chunk-WZSLBQN7.js";
import {
  n as n2
} from "./chunk-DL6FZ7ZH.js";
import "./chunk-IA5FLB5V.js";
import "./chunk-MWAZW5EU.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-UR4HHZKS.js";
import "./chunk-FSAXKL5E.js";
import "./chunk-SUMI43CH.js";
import "./chunk-5HRTFQ6H.js";
import "./chunk-6ACTD4UJ.js";
import {
  b,
  s as s2
} from "./chunk-RH5Q3AVL.js";
import {
  i2 as i,
  s
} from "./chunk-VNH2FDEQ.js";
import "./chunk-EX5MO5LF.js";
import {
  L
} from "./chunk-7DUTYOCL.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/3d/terrain/NeighborIndex.js
var T;
!function(T2) {
  T2[T2.NORTH = 0] = "NORTH", T2[T2.NORTH_EAST = 1] = "NORTH_EAST", T2[T2.EAST = 2] = "EAST", T2[T2.SOUTH_EAST = 3] = "SOUTH_EAST", T2[T2.SOUTH = 4] = "SOUTH", T2[T2.SOUTH_WEST = 5] = "SOUTH_WEST", T2[T2.WEST = 6] = "WEST", T2[T2.NORTH_WEST = 7] = "NORTH_WEST";
}(T || (T = {}));

// node_modules/@arcgis/core/views/3d/support/supportedSpatialReference.js
function o2(r6) {
  return i3(r6) || D(r6) || W(r6);
}
function i3(e7) {
  return C(e7) || w(e7);
}

// node_modules/@arcgis/core/views/3d/terrain/TilingScheme.js
var g = 12;
var _f = class _f {
  constructor(e7) {
    const t4 = _f.checkUnsupported(e7);
    if (null != t4) throw t4;
    const i4 = e7;
    this.spatialReference = i4.spatialReference, this._isWebMercator = this.spatialReference.isWebMercator, this._isGCS = P(this.spatialReference), this.origin = [i4.origin.x, i4.origin.y], this.pixelSize = i4.size[0], this.dpi = i4.dpi;
    const s10 = i4.lods.reduce((e8, t5) => (t5.level < e8.minLod.level && (e8.minLod = t5), e8.max = Math.max(e8.max, t5.level), e8), { minLod: i4.lods[0], max: -1 / 0 }), r6 = s10.minLod, l5 = 2 ** r6.level;
    let n6 = r6.resolution * l5, o3 = r6.scale * l5;
    this.levels = new Array(s10.max + 1);
    for (let a5 = 0; a5 < this.levels.length; a5++) this.levels[a5] = { resolution: n6, scale: o3, tileSize: [n6 * i4.size[0], n6 * i4.size[1]] }, n6 /= 2, o3 /= 2;
  }
  clone() {
    return new _f(this.toTileInfo());
  }
  toTileInfo() {
    return new j2({ dpi: this.dpi, origin: new _({ x: this.origin[0], y: this.origin[1], spatialReference: this.spatialReference }), size: [this.pixelSize, this.pixelSize], spatialReference: this.spatialReference, lods: this.levels.map((e7, t4) => new l2({ level: t4, scale: e7.scale, resolution: e7.resolution })) });
  }
  getExtent(e7, t4, i4, s10) {
    const r6 = this.levels[e7], l5 = r6.tileSize[0], n6 = r6.tileSize[1];
    s10[0] = this.origin[0] + i4 * l5, s10[2] = this.origin[0] + (i4 + 1) * l5, s10[3] = this.origin[1] - t4 * n6, s10[1] = this.origin[1] - (t4 + 1) * n6;
  }
  convertExtentToRadians(e7, i4) {
    this._isWebMercator ? (i4[0] = c2(e7[0]), i4[1] = h2(e7[1]), i4[2] = c2(e7[2]), i4[3] = h2(e7[3])) : this._isGCS && (i4[0] = s3(e7[0]), i4[1] = s3(e7[1]), i4[2] = s3(e7[2]), i4[3] = s3(e7[3]));
  }
  getExtentGeometry(e7, t4, i4, s10 = new z()) {
    return this.getExtent(e7, t4, i4, v), s10.spatialReference = this.spatialReference, s10.xmin = v[0], s10.ymin = v[1], s10.xmax = v[2], s10.ymax = v[3], s10.zmin = void 0, s10.zmax = void 0, s10;
  }
  ensureMaxLod(e7) {
    if (null == e7) return false;
    let t4 = false;
    for (; this.levels.length <= e7; ) {
      const { resolution: e8, scale: i4 } = this.levels[this.levels.length - 1], s10 = e8 / 2 * this.pixelSize;
      this.levels.push({ resolution: e8 / 2, scale: i4 / 2, tileSize: [s10, s10] }), t4 = true;
    }
    return t4;
  }
  capMaxLod(e7) {
    this.levels.length > e7 + 1 && (this.levels.length = e7 + 1);
  }
  getMaxLod() {
    return this.levels.length - 1;
  }
  scaleAtLevel(e7) {
    return this.levels[0].scale / 2 ** e7;
  }
  levelAtScale(e7) {
    const t4 = this.levels[0].scale;
    return e7 >= t4 ? 0 : Math.log(t4 / e7) * Math.LOG2E;
  }
  resolutionAtLevel(e7) {
    return this.levels[0].resolution / 2 ** e7;
  }
  compatibleWith(e7, t4 = 1 / 0) {
    if (_f.checkUnsupported(e7)) return false;
    const s10 = new _f(e7);
    if (!s10.spatialReference.equals(this.spatialReference)) return false;
    if (s10.pixelSize !== this.pixelSize) return false;
    const r6 = Math.min(this.levels.length - 1, s10.levels.length - 1, t4), l5 = this.levels[r6].resolution;
    let n6 = 0.5 * l5;
    if (!m2(s10.origin[0], this.origin[0], n6) || !m2(s10.origin[1], this.origin[1], n6)) return false;
    return n6 = 0.5 * l5 / 2 ** r6 / this.pixelSize * g, m2(l5, s10.levels[r6].resolution, n6);
  }
  rootTilesInExtent(e7, t4 = null, i4 = 1 / 0) {
    const s10 = new Array(), r6 = this.levels[0].tileSize;
    if (null == e7 || 0 === r6[0] || 0 === r6[1]) return s10;
    _f.computeRowColExtent(e7, r6, this.origin, v);
    let l5 = v[1], n6 = v[3], o3 = v[0], a5 = v[2];
    const h5 = a5 - o3, c5 = n6 - l5;
    if (h5 * c5 > i4) {
      const e8 = Math.floor(Math.sqrt(i4));
      c5 > e8 && (l5 = l5 + Math.floor(0.5 * c5) - Math.floor(0.5 * e8), n6 = l5 + e8), h5 > e8 && (o3 = o3 + Math.floor(0.5 * h5) - Math.floor(0.5 * e8), a5 = o3 + e8);
    }
    for (let m7 = l5; m7 < n6; m7++) for (let e8 = o3; e8 < a5; e8++) s10.push([0, m7, e8]);
    return null != t4 && (t4[0] = this.origin[0] + o3 * r6[0], t4[1] = this.origin[1] - n6 * r6[1], t4[2] = this.origin[0] + a5 * r6[0], t4[3] = this.origin[1] - l5 * r6[1]), s10;
  }
  static computeRowColExtent(e7, t4, i4, s10) {
    const r6 = 1e-3 * (e7[2] - e7[0] + (e7[3] - e7[1]));
    s10[0] = Math.max(0, Math.floor((e7[0] + r6 - i4[0]) / t4[0])), s10[2] = Math.max(0, Math.ceil((e7[2] - r6 - i4[0]) / t4[0])), s10[1] = Math.max(0, Math.floor((i4[1] - e7[3] + r6) / t4[1])), s10[3] = Math.max(0, Math.ceil((i4[1] - e7[1] - r6) / t4[1]));
  }
  static isPowerOfTwo(e7) {
    const t4 = e7.lods, i4 = t4[0].resolution * 2 ** t4[0].level;
    return !t4.some((e8) => !A(e8.resolution, i4 / 2 ** e8.level));
  }
  static hasGapInLevels(e7) {
    const t4 = e7.lods.map((e8) => e8.level);
    t4.sort((e8, t5) => e8 - t5);
    for (let i4 = 1; i4 < t4.length; i4++) if (t4[i4] !== t4[0] + i4) return true;
    return false;
  }
  static tileSizeSupported(e7) {
    const t4 = e7.size[1];
    return t4 === e7.size[0] && !(t4 & t4 - 1) && t4 >= 128 && t4 <= 512;
  }
  static hasOriginPerLODs(e7) {
    const t4 = e7.origin;
    return e7.lods.some((e8) => null != e8.origin && (e8.origin[0] !== t4.x || e8.origin[1] !== t4.y));
  }
  static getMissingTileInfoError() {
    return new s("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
  }
  static checkUnsupported(t4) {
    return null == t4 ? x() : t4.lods.length < 1 ? new s("tilingscheme:generic", "Tiling scheme must have at least one level") : _f.isPowerOfTwo(t4) ? _f.hasGapInLevels(t4) ? new s("tilingscheme:gaps", "Tiling scheme levels must not have gaps between min and max level") : _f.tileSizeSupported(t4) ? _f.hasOriginPerLODs(t4) ? new s("tilingscheme:multiple-origin", "Tiling scheme levels must not have their own origin") : null : new s("tilingscheme:tile-size", "Tiles must be square and size must be one of [128, 256, 512]") : new s("tilingscheme:power-of-two", "Tiling scheme must be power of two");
  }
  static fromExtent(e7, t4) {
    const i4 = e7[2] - e7[0], s10 = e7[3] - e7[1], l5 = Z(t4), o3 = 1.2 * Math.max(i4, s10), a5 = 256, h5 = o3 / a5, c5 = h5 * l5 * (96 / 0.0254), m7 = new _f(new j2({ size: [a5, a5], origin: new _({ x: e7[0] - 0.5 * (o3 - i4), y: e7[3] + 0.5 * (o3 - s10) }), lods: [new l2({ level: 0, resolution: h5, scale: c5 })], spatialReference: t4 }));
    return m7.ensureMaxLod(20), m7;
  }
  static makeWebMercatorAuxiliarySphere(e7) {
    const t4 = new _f(_f.WebMercatorAuxiliarySphereTileInfo);
    return t4.ensureMaxLod(e7), t4;
  }
  static makeGCSWithTileSize(e7, t4 = 256, i4 = 16) {
    const s10 = 256 / t4, r6 = new _f(new j2({ size: [t4, t4], origin: new _({ x: -180, y: 90, spatialReference: e7 }), spatialReference: e7, lods: [new l2({ level: 0, resolution: 0.703125 * s10, scale: 295497598570834e-6 * s10 })] }));
    return r6.ensureMaxLod(i4), r6;
  }
  get test() {
  }
};
_f.WebMercatorAuxiliarySphereTileInfo = new j2({ size: [256, 256], origin: new _({ x: -20037508342787e-6, y: 20037508342787e-6, spatialReference: f2.WebMercator }), spatialReference: f2.WebMercator, lods: [new l2({ level: 0, resolution: 156543.03392800014, scale: 591657527591555e-6 })] });
_f.WebMercatorAuxiliarySphere = _f.makeWebMercatorAuxiliarySphere(19);
var f3 = _f;
function x() {
  return new s("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
}
var v = u();

// node_modules/@arcgis/core/views/3d/terrain/TerrainConst.js
var s7 = 64;
var l4 = S(q / 10);
var m6 = u();
f3.WebMercatorAuxiliarySphere.getExtent(0, 0, 0, m6);
var c3 = u([-180, -90, 180, 90]);

// node_modules/@arcgis/core/chunks/terrainUtilsPlanar.js
function s8(t4, o3, l5, s10) {
  if (null == t4) return x();
  const a5 = t4.spatialReference;
  if (a5.isGeographic && !i3(a5)) return new s("tilingscheme:local-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in local scenes");
  const u4 = f3.checkUnsupported(t4);
  if (null != u4) return u4;
  if (null == l5) return new s("tilingscheme:extent-not-exist", "The layer does not provide a layer extent.");
  const p3 = c4(t4, l5);
  return p3 || (null == o3 || a5.equals(o3) || o3.isWGS84 && a5.isWebMercator ? null : new s("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the local scene"));
}
function c4(r6, n6) {
  const s10 = r6.lods, c5 = s10[0].resolution * 2 ** s10[0].level, a5 = [c5 * r6.size[0], c5 * r6.size[1]], u4 = [r6.origin.x, r6.origin.y], p3 = o(n6), f7 = u();
  f3.computeRowColExtent(p3, a5, u4, f7);
  const m7 = (f7[2] - f7[0]) * (f7[3] - f7[1]);
  if (m7 > s7) {
    const t4 = s10[0].scale * 2 ** s10[0].level;
    let o3 = Math.max((p3[3] - p3[1]) / r6.size[1], (p3[2] - p3[0]) / r6.size[0]) * t4 / c5;
    const n7 = Math.floor(Math.log(o3) / Math.log(10));
    return o3 = Math.ceil(o3 / 10 ** n7) * 10 ** n7, new s("tilingscheme:too-many-root-tiles", "Scale of level 0 of the tiling scheme (1:" + Math.floor(t4).toLocaleString() + ") is too large for the layer's extent. Suggested scale: 1:" + o3.toLocaleString() + ".", { level0Scale: t4, suggestedLevel0Scale: o3, requiredNumRootTiles: m7, allowedNumRootTiles: s7 });
  }
  return null;
}
var a4 = Object.freeze(Object.defineProperty({ __proto__: null, checkIfTileInfoSupportedForViewSR: s8 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/terrainUtilsSpherical.js
function n4(n6, r6, c5, o3) {
  if (null == n6) return x();
  const s10 = n6?.lods.length - 1, a5 = n6.spatialReference;
  if (a5.isWebMercator) {
    if (!f3.makeWebMercatorAuxiliarySphere(s10).compatibleWith(n6, o3)) return new s("tilingscheme:incompatible-global-web-mercator", "The tiling scheme is not compatible with the ArcGIS Online Web Mercator tiling scheme");
  } else {
    if (!o2(a5)) return new s("tilingscheme:global-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in global scenes");
    if (!f3.makeGCSWithTileSize(n6.spatialReference, n6.size[0], s10).compatibleWith(n6, o3)) return n6.spatialReference.isWGS84 ? new s("tilingscheme:incompatible-global-wgs84", "The tiling scheme is not compatible with the ArcGIS Online WGS84 tiling scheme") : new s("tilingscheme:incompatible-global", "The tiling scheme is not compatible with the ArcGIS Online tiling scheme");
  }
  return null == r6 || n6.spatialReference.equals(r6) ? null : new s("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the global scene");
}
var r3 = Object.freeze(Object.defineProperty({ __proto__: null, checkIfTileInfoSupportedForViewSR: n4 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/terrain/terrainUtils.js
var s9 = { [l3.Global]: r3, [l3.Local]: a4 };
function M(n6, t4, e7, r6, o3) {
  return s9[r6].checkIfTileInfoSupportedForViewSR(n6, e7, t4, o3);
}
function k2(t4, e7, o3) {
  const i4 = O2(t4);
  if (null != i4) {
    if (!V.isCollection(i4)) return { tileInfo: i4.tileInfo, fullExtent: i4.fullExtent };
    {
      const n6 = i4.find((n7) => null == M(n7.tileInfo, n7.fullExtent, e7, o3));
      if (n6) return { tileInfo: n6.tileInfo, fullExtent: n6.fullExtent };
    }
  }
  return { tileInfo: null, fullExtent: null };
}
var $ = [T.NORTH, T.EAST, T.SOUTH, T.WEST];
var nn = [T.NORTH_EAST, T.SOUTH_EAST, T.SOUTH_WEST, T.NORTH_WEST];

// node_modules/@arcgis/core/views/support/spatialReferenceSupport.js
function r5(r6, S4) {
  return null != r6 && (null == S4 || (S4 === l3.Local ? !r6.isGeographic || (r6.isWGS84 || r6.wkid === S2.CGCS2000) : r6.isWebMercator || r6.isWGS84 || r6.wkid === S2.CGCS2000 || r6.wkid === S2.GCSMARS2000 || r6.wkid === S2.GCSMARS2000_SPHERE || r6.wkid === S2.GCSMOON2000));
}

// node_modules/@arcgis/core/widgets/BasemapGallery/support/basemapCompatibilityUtils.js
async function f4(e7, t4 = {}) {
  const { basemap: i4, view: r6 } = e7;
  await i4.load(t4), y2(i4), await h3(i4, r6, t4), s2(t4);
}
async function u3(t4, r6 = {}) {
  const { basemap: n6, view: s10 } = t4;
  s2(r6);
  const l5 = n6.baseLayers.find((e7) => "unknown" === e7.type)?.loadError;
  if (null != l5) throw l5;
  if (!s10 || "spatialReferenceLocked" in s10 && !s10.spatialReferenceLocked) return;
  if (await n6.load(r6), s2(r6), 0 === n6.baseLayers.length) return;
  const o3 = n6.baseLayers.at(0);
  if (!d(o3)) return;
  if (n6.spatialReference) {
    if (s10.spatialReference.equals(n6.spatialReference)) return;
    w2();
  }
  await o3.load(r6), s2(r6);
  const p3 = (("supportedSpatialReferences" in o3 ? o3.supportedSpatialReferences : null) || ["tileInfo" in o3 ? o3.tileInfo?.spatialReference : null]).filter(L);
  0 !== p3.length && p3.every((e7) => !s10.spatialReference.equals(e7)) && w2();
}
function w2() {
  throw new s("basemap-compatibility:incompatible-spatial-reference", "Basemap spatial reference is not compatible with the view");
}
function y2(e7) {
  if (0 === e7.baseLayers.length && 0 === e7.referenceLayers.length) return;
  const t4 = e7.baseLayers.concat(e7.referenceLayers).toArray().filter((e8) => !i2(e8)).map((e8) => b4(e8));
  if (t4.length) throw t4[0];
}
function b4(e7) {
  return new s("basemap-compatibility:unsupported-basemap-layer-type", "Unsupported basemap layer type ${operationalLayerType}", { layer: e7, operationalLayerType: e7.operationalLayerType || "unknown" });
}
async function h3(e7, a5, i4) {
  if (0 === e7.baseLayers.length) return;
  const r6 = e7.baseLayers.at(0);
  if (b3(r6)) {
    try {
      await r6.load(i4);
    } catch (s10) {
      const e8 = "basemap-compatibility:unknown-error", a6 = "Unknown basemap compatibility error", { name: i5 = e8, message: r7 = a6, details: n6 } = s10;
      throw new s(i5, r7, n6);
    }
    g2(r6, a5);
  }
}
function g2(e7, a5) {
  const i4 = a5.state.viewingMode;
  if (!i4) return;
  let r6, n6;
  if ("wmts" === e7?.type) {
    const s10 = k2(e7, a5.spatialReference, i4);
    if (null == s10.tileInfo) throw new s("basemapgalleryitem:tiling-scheme-incompatible", "Basemap tiling scheme is incompatible with the view");
    r6 = s10.tileInfo, n6 = s10.fullExtent;
  } else r6 = e7.tileInfo, n6 = e7.fullExtent;
  if (null == r6) return;
  if (!r5(r6.spatialReference, i4)) throw new s(`basemapgalleryitem:spatial-reference-unsupported-${a3(i4)}`, `Basemap spatial reference is unsupported in ${a3(i4)} mode`);
  const f7 = "vector-tile" === e7?.type ? r6.getCompatibleForVTL(256) : null;
  if (i4 === l3.Global) {
    let a6 = M(r6, n6, null, i4);
    if (a6 && "vector-tile" === e7?.type && null != n6 && f7 && !M(f7, n6, null, i4) && (a6 = null), a6) {
      const e8 = r6.spatialReference.isWebMercator ? "web-mercator" : "wgs84";
      throw new s(`basemapgalleryitem:tiling-scheme-unsupported-${e8}-global`, "Basemap tiling scheme is unsupported in global mode", { error: a6 });
    }
  } else if (f3.checkUnsupported(r6)) throw new s("basemapgalleryitem:tiling-scheme-unsupported-local", "Basemap tiling scheme is unsupported in local mode");
  const u4 = a5.basemapTerrain?.tilingScheme;
  if (u4 && !u4.compatibleWith(r6) && ("vector-tile" !== e7?.type || !f7 || !u4.compatibleWith(f7))) throw new s("basemapgalleryitem:tiling-scheme-incompatible", "Basemap tiling scheme is incompatible with the view");
}

// node_modules/@arcgis/core/widgets/BasemapGallery/support/BasemapGalleryItem.js
var p2 = class extends n3.IdentifiableMixin(b2) {
  constructor(e7) {
    super(e7), this.compatibilityFunction = null, this.error = null, this.state = "loading", this.view = null;
  }
  initialize() {
    const e7 = () => this.refresh();
    this.addHandles([l(() => this.basemap?.loadStatus, e7), l(() => this.compatibilityFunction, e7), l(() => this.view && "basemapTerrain" in this.view && this.view.basemapTerrain?.tilingScheme, e7), l(() => this.view?.ready, e7), l(() => this.view?.spatialReference, e7)]), this.refresh();
  }
  destroy() {
    this._cancelRefresh(), this.basemap = null, this.compatibilityFunction = null, this.view = null;
  }
  get _spatialReferenceTask() {
    return d2(this.view, this.basemap);
  }
  set basemap(e7) {
    e7 && e7.load().catch(() => {
    }), this._set("basemap", e7);
  }
  get spatialReference() {
    return this._spatialReferenceTask.spatialReference;
  }
  refresh() {
    this._cancelRefresh(), this._set("state", "loading");
    const e7 = this.basemap?.loadStatus;
    if ("loaded" !== e7 && "failed" !== e7) return;
    if (!this.compatibilityFunction) return void ("loaded" === e7 ? (this._set("state", "ready"), this._set("error", null)) : (this._set("state", "error"), this._set("error", this.basemap.loadError)));
    const t4 = new AbortController(), { signal: s10 } = t4;
    this.compatibilityFunction(this, { signal: s10 }).then(() => j(() => !this._spatialReferenceTask.updating, s10)).then(() => {
      this._set("state", "ready"), this._set("error", null);
    }).catch((e8) => {
      b(e8) || (this._set("state", "error"), this._set("error", e8));
    }), this._refreshController = t4;
  }
  _cancelRefresh() {
    this._refreshController && (this._refreshController.abort(), this._refreshController = null);
  }
};
r([m({ readOnly: true })], p2.prototype, "_spatialReferenceTask", null), r([m()], p2.prototype, "basemap", null), r([m()], p2.prototype, "compatibilityFunction", void 0), r([m({ readOnly: true })], p2.prototype, "error", void 0), r([m({ readOnly: true })], p2.prototype, "spatialReference", null), r([m({ readOnly: true })], p2.prototype, "state", void 0), r([m()], p2.prototype, "view", void 0), p2 = r([a("esri.widgets.BasemapGallery.support.BasemapGalleryItem")], p2);
var h4 = p2;

// node_modules/@arcgis/core/widgets/BasemapGallery/support/PortalBasemapsSource.js
var d3 = V.ofType(O3);
var y3 = class extends p.LoadableMixin(m3.EsriPromiseMixin(m5)) {
  constructor(t4) {
    super(t4), this._lastPortalBasemapFetchController = null, this.basemaps = new d3(), this.filterFunction = null, this.portal = C2.getDefault(), this.query = null, this.updateBasemapsCallback = null, this.viewType = null;
  }
  initialize() {
    this.addHandles(l(() => [this.filterFunction, this.loadStatus, this.portal?.basemapGalleryGroupQuery, this.portal?.basemapGalleryGroupQuery3D, this.portal?.user, this.query, this.updateBasemapsCallback], () => this.refresh(), h));
  }
  destroy() {
    this.filterFunction = null, this.portal = null, this.basemaps.forEach((t4) => t4.destroy());
  }
  get state() {
    return "not-loaded" === this.loadStatus ? "not-loaded" : "loading" === this.loadStatus || this._lastPortalBasemapFetchController ? "loading" : "ready";
  }
  load(t4) {
    return this.addResolvingPromise(this.portal.load(t4)), Promise.resolve(this);
  }
  async refresh() {
    if ("loaded" !== this.loadStatus) return;
    this._lastPortalBasemapFetchController && (this._lastPortalBasemapFetchController.abort(), this._lastPortalBasemapFetchController = null);
    const t4 = this.portal, a5 = new AbortController();
    this._lastPortalBasemapFetchController = a5, this.notifyChange("state");
    try {
      const s10 = await t4.fetchBasemaps(this._toQueryString(this.query), { signal: a5.signal, include3d: "3d" === this.viewType || void 0 });
      await this._updateBasemaps(s10);
    } catch (s10) {
      if (b(s10)) throw s10;
      i.getLogger(this).warn(new s("basemap-source:fetch-basemaps-error", "Could not fetch basemaps from portal.", { error: s10 })), await this._updateBasemaps();
    }
    this._lastPortalBasemapFetchController = null, this.notifyChange("state");
  }
  _toQueryString(t4) {
    return t4 && "string" != typeof t4 ? Object.keys(t4).map((a5) => `${a5}:${t4[a5]}`).join(" AND ") : t4;
  }
  async _updateBasemaps(t4 = []) {
    let a5 = await this._filterBasemaps(t4);
    a5 = this.updateBasemapsCallback ? await this.updateBasemapsCallback(a5) : a5, this.basemaps.removeAll(), this.basemaps.addMany(a5);
  }
  async _filterBasemaps(t4) {
    if (!this.filterFunction) return t4;
    const a5 = t4.map(this.filterFunction), s10 = await Promise.all(a5);
    return t4.filter((t5, a6) => s10[a6]);
  }
};
r([m({ readOnly: true, type: d3 })], y3.prototype, "basemaps", void 0), r([m()], y3.prototype, "filterFunction", void 0), r([m({ type: C2 })], y3.prototype, "portal", void 0), r([m()], y3.prototype, "query", void 0), r([m({ readOnly: true })], y3.prototype, "state", null), r([m()], y3.prototype, "updateBasemapsCallback", void 0), r([m()], y3.prototype, "viewType", void 0), y3 = r([a("esri.widgets.BasemapGallery.support.PortalBasemapsSource")], y3);
var f5 = y3;

// node_modules/@arcgis/core/widgets/BasemapGallery/BasemapGalleryViewModel.js
var g3 = V.ofType(h4);
function _2(e7) {
  return e7 && "esri.portal.Portal" === e7.declaredClass;
}
function I(e7) {
  return e7 && !(e7 instanceof f5) && (!!e7.portal || !!e7.query);
}
function R(e7) {
  return e7 && "basemaps" in e7 && "state" in e7 && "refresh" in e7;
}
var E = class extends p {
  constructor(e7) {
    super(e7), this._loadingProjectionEngine = false, this.items = new g3(), this.source = new f5(), this.view = null;
  }
  initialize() {
    const e7 = () => this._recreateItems();
    this.addHandles([l(() => "ready" === this.state ? this.compatibilityFunction : null, () => this._updateItems()), a2(() => this.source?.basemaps, "change", e7, { onListenerAdd: e7 }), f(() => this.view, () => {
      this.source instanceof f5 && (this.source.viewType = this.view?.type);
    }, { once: true })]);
  }
  destroy() {
    const e7 = this.source.basemaps.find((e8) => e8 === this.activeBasemap);
    e7 && this.source.basemaps.remove(e7), this.source?.destroy();
  }
  get activeBasemap() {
    return this.view?.map?.basemap ?? null;
  }
  set activeBasemap(e7) {
    const t4 = this.view;
    if (!t4?.map) return;
    if (!e7 || !t4.ready) return t4.map.basemap = e7, void this._clearOverride("activeBasemap");
    const s10 = e7.spatialReference || this.items?.find((t5) => this.basemapEquals(e7, t5.basemap))?.spatialReference;
    if (s10 && "spatialReferenceLocked" in t4 && !t4.spatialReferenceLocked) {
      const i4 = t4.spatialReference;
      if (null != s10 && !s5(i4, s10) && !L2(t4.spatialReference, s10) && !k()) return this._override("activeBasemap", e7), this._loadingProjectionEngine = true, void K().then(() => {
        this._get("activeBasemap") === e7 && (t4.map.basemap = e7, t4.spatialReference = s10, this._clearOverride("activeBasemap"));
      }, () => {
      }).then(() => {
        this._loadingProjectionEngine = false;
      });
      t4.map.basemap = e7, this._clearOverride("activeBasemap"), null == s10 || s5(t4.spatialReference, s10) || (t4.spatialReference = s10);
    } else t4.map.basemap = e7, this._clearOverride("activeBasemap");
  }
  castActiveBasemap(e7) {
    return m4(e7);
  }
  get activeBasemapIndex() {
    const { state: e7, activeBasemap: t4 } = this;
    return "ready" !== e7 ? -1 : this._findBasemapIndex(t4);
  }
  get compatibilityFunction() {
    return "3d" === this.view?.type ? f4 : u3;
  }
  set compatibilityFunction(e7) {
    this._overrideIfSome("compatibilityFunction", e7);
  }
  castSource(e7) {
    return Array.isArray(e7) || V.isCollection(e7) ? new m5({ basemaps: Array.isArray(e7) ? new V(e7) : e7 }) : _2(e7) ? new f5({ portal: e7 }) : I(e7) ? new f5(e7) : R(e7) ? e7 : null;
  }
  get state() {
    return this.view?.ready && this.source ? e4(this.view) && !this.view.inGeographicLayout ? "unsupported" : this._loadingProjectionEngine ? "loading" : "ready" : "disabled";
  }
  basemapEquals(e7, t4) {
    return y(e7, t4);
  }
  refresh() {
    this._recreateItems();
  }
  load() {
    return this.loadSource();
  }
  loadSource(e7) {
    return this.addResolvingPromise(p.isLoadable(this.source) ? this.source.load(e7) : null), Promise.resolve(this);
  }
  _findBasemapIndex(e7) {
    const { items: t4 } = this, s10 = t4.findIndex((t5) => t5.basemap === e7);
    return -1 === s10 ? t4.findIndex((t5) => this.basemapEquals(t5.basemap, e7)) : s10;
  }
  _recreateItems() {
    const e7 = this.source?.basemaps ?? [], { view: t4, compatibilityFunction: s10 } = this, i4 = new Map(this.items.map((e8) => [e8.basemap, e8])), a5 = e7.map((e8) => {
      const a6 = i4.get(e8);
      return a6 ? (i4.delete(e8), a6) : new h4({ basemap: e8, compatibilityFunction: s10, view: t4 });
    });
    this.items.removeAll(), this.items.addMany(a5), i4.forEach((e8) => e8.destroy());
  }
  _updateItems() {
    for (const e7 of this.items) e7.compatibilityFunction = this.compatibilityFunction, e7.view = this.view;
  }
};
r([m()], E.prototype, "_loadingProjectionEngine", void 0), r([m({ type: O3 })], E.prototype, "activeBasemap", null), r([s4("activeBasemap")], E.prototype, "castActiveBasemap", null), r([m({ readOnly: true })], E.prototype, "activeBasemapIndex", null), r([m()], E.prototype, "compatibilityFunction", null), r([m({ readOnly: true, type: g3 })], E.prototype, "items", void 0), r([m()], E.prototype, "source", void 0), r([s4("source")], E.prototype, "castSource", null), r([m({ readOnly: true })], E.prototype, "state", null), r([m()], E.prototype, "view", void 0), E = r([a("esri.widgets.BasemapGallery.BasemapGalleryViewModel")], E);
var S3 = E;

// node_modules/@arcgis/core/widgets/BasemapGallery/css.js
var e6 = "esri-basemap-gallery";
var t3 = { base: e6, sourceLoading: `${e6}--source-loading`, loader: `${e6}__loader`, item: `${e6}__item`, itemContainer: `${e6}__item-container`, itemContent: `${e6}__item-content`, itemTitle: `${e6}__item-title`, itemTagsContainer: `${e6}__item-tags-container`, itemThumbnail: `${e6}__item-thumbnail`, selectedItem: `${e6}__item--selected`, itemError: `${e6}__item--error` };

// node_modules/@arcgis/core/widgets/BasemapGallery.js
var w3 = class extends O {
  constructor(e7, s10) {
    super(e7, s10), this.disabled = false, this.headingLevel = 2, this.messages = null, this.viewModel = new S3(), this._focusBasemapItemEnabled = false, r2(i.getLogger(this), "Basemap Gallery", "arcgis-basemap-gallery", { version: "4.32" });
  }
  initialize() {
    this.addHandles(f(() => this.source, () => this.viewModel.loadSource(), { sync: true, initial: true }));
  }
  loadDependencies() {
    return c({ scrim: () => import("./calcite-scrim-PIHGVRNS.js"), chip: () => import("./calcite-chip-FQYLVP2R.js") });
  }
  get activeBasemap() {
    return this.viewModel.activeBasemap;
  }
  set activeBasemap(e7) {
    this.viewModel.activeBasemap = e7;
  }
  get icon() {
    return "basemap";
  }
  set icon(e7) {
    this._overrideIfSome("icon", e7);
  }
  get label() {
    return this.messages?.widgetLabel ?? "";
  }
  set label(e7) {
    this._overrideIfSome("label", e7);
  }
  get source() {
    return this.viewModel.source;
  }
  set source(e7) {
    this.viewModel.source = e7;
  }
  get view() {
    return this.viewModel.view;
  }
  set view(e7) {
    this.viewModel.view = e7;
  }
  render() {
    const e7 = "loading" === this.source.state, s10 = this.disabled || "disabled" === this.viewModel.state, t4 = { [t3.sourceLoading]: e7, [e2.disabled]: s10 };
    return n("div", { class: this.classes(t3.base, e2.widget, e2.panel, t4), key: "container" }, this._getContext());
  }
  _getContext() {
    if ("unsupported" === this.viewModel.state) return n("div", { class: e2.empty, key: "empty-message" }, n(e3, { level: this.headingLevel }, this.messages.unsupported));
    if ("loading" === this.source.state) return n("div", { class: t3.loader, key: "loader" });
    const e7 = this.viewModel.items;
    return e7.length > 0 ? n("ul", { "aria-disabled": this.disabled, "aria-label": this.label, bind: this, class: t3.itemContainer, key: "item-container", onkeydown: this._handleKeyDown, role: "radiogroup" }, e7.map((e8, s10) => this._renderBasemapGalleryItem(e8, s10)).toArray()) : n("div", { class: e2.empty, key: "empty-message" }, n(e3, { level: this.headingLevel }, this.messages.noBasemaps));
  }
  _getRoundRobinIndex(e7, s10) {
    return (e7 + s10) % s10;
  }
  _handleKeyDown(e7) {
    const { key: s10 } = e7;
    if (!["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft"].includes(s10)) return;
    e7.preventDefault();
    const { items: t4, activeBasemapIndex: a5 } = this.viewModel, i4 = "ArrowUp" === s10 || "ArrowLeft" === s10 ? this._getRoundRobinIndex(Math.max(a5 - 1, -1), t4.length) : this._getRoundRobinIndex(a5 + 1, t4.length), r6 = t4.at(i4);
    "ready" === r6?.state && (this.viewModel.activeBasemap = r6.basemap), this._focusBasemapItemEnabled = true;
  }
  _focusBasemapItem(e7) {
    this._focusBasemapItemEnabled && 0 === e7.tabIndex && (e7.focus(), this._focusBasemapItemEnabled = false);
  }
  _handleClick(e7) {
    const s10 = e7.currentTarget["data-item"];
    "ready" === s10.state && (this.viewModel.activeBasemap = s10.basemap);
  }
  _renderBasemapGalleryItem(e7, t4) {
    const a5 = j3(e7.basemap) || n2("esri/themes/base/images/basemap-toggle-64.svg"), i4 = e7.basemap.title, r6 = e7.basemap.portalItem?.snippet, o3 = e7.error?.message || r6 || i4, { viewModel: { state: d4, activeBasemapIndex: p3 } } = this, m7 = this.disabled || "disabled" === d4, h5 = p3 === t4, g4 = h5 || -1 === p3 && 0 === t4 ? 0 : -1, v2 = "loading" === d4, b5 = { [t3.selectedItem]: h5, [t3.itemError]: "error" === e7.state }, w4 = `basemapgallery-item-${e7.uid}`;
    return n("li", { afterUpdate: this._focusBasemapItem, "aria-checked": h5.toString(), "aria-disabled": m7.toString(), "aria-labelledby": w4, bind: this, class: this.classes(t3.item, b5), "data-item": e7, key: e7.uid, onclick: this._handleClick, onkeydown: this._handleClick, role: "radio", tabIndex: g4, title: o3 }, n("img", { alt: "", class: t3.itemThumbnail, src: a5 }), n("div", { class: t3.itemContent, key: "content" }, n("div", { class: t3.itemTitle, key: "title" }, n("span", { id: w4 }, i4)), u2(e7.basemap) ? this._renderTags(e7.basemap) : null), "loading" === e7.state || h5 && v2 ? n("calcite-scrim", null, n("span", { "aria-hidden": "true", class: e2.loaderAnimation, key: "loader", role: "presentation" })) : null);
  }
  _renderTags(e7) {
    return n("div", { class: t3.itemTagsContainer, key: "tag" }, this._render3DTag(), s6(e7) ? this._renderBetaTag() : null);
  }
  _render3DTag() {
    const { messages: e7 } = this;
    return n("calcite-chip", { key: "tag-3d", label: e7.tag3D, scale: "s" }, this.messages.tag3D);
  }
  _renderBetaTag() {
    const { messages: e7 } = this;
    return n("calcite-chip", { appearance: "outline-fill", key: "tag-beta", label: e7.tagBeta, scale: "s" }, this.messages.tagBeta);
  }
};
r([m()], w3.prototype, "activeBasemap", null), r([m()], w3.prototype, "disabled", void 0), r([m()], w3.prototype, "headingLevel", void 0), r([m()], w3.prototype, "icon", null), r([m()], w3.prototype, "label", null), r([m(), e("esri/widgets/BasemapGallery/t9n/BasemapGallery")], w3.prototype, "messages", void 0), r([m()], w3.prototype, "source", null), r([m()], w3.prototype, "view", null), r([m()], w3.prototype, "viewModel", void 0), r([m()], w3.prototype, "_focusBasemapItemEnabled", void 0), r([t()], w3.prototype, "_handleClick", null), w3 = r([a("esri.widgets.BasemapGallery")], w3);
var f6 = w3;
export {
  f6 as default
};
//# sourceMappingURL=@arcgis_core_widgets_BasemapGallery.js.map
