import {
  h as h3
} from "./chunk-T2XVDW2J.js";
import {
  E,
  a as a4
} from "./chunk-SV35MYMN.js";
import {
  t
} from "./chunk-VVMAWXMO.js";
import {
  e as e2,
  i as i3,
  s as s2
} from "./chunk-3CFE5G42.js";
import {
  i as i2
} from "./chunk-GEXDBKAY.js";
import {
  a as a3,
  i,
  m as m5,
  s
} from "./chunk-ICVOVIUL.js";
import {
  R
} from "./chunk-RFM3ACHA.js";
import "./chunk-SP5E3FR4.js";
import {
  c
} from "./chunk-R4OUYMNP.js";
import "./chunk-U6CQ42B3.js";
import "./chunk-P5XPQUDN.js";
import "./chunk-QRQFF5JU.js";
import "./chunk-2H2JCT45.js";
import "./chunk-NMV57LDC.js";
import {
  h as h2
} from "./chunk-NZUIJLHR.js";
import "./chunk-2XBUTZI3.js";
import "./chunk-IAKXH7PU.js";
import "./chunk-3MVOHROR.js";
import "./chunk-RVXIJHL6.js";
import "./chunk-2JAL6FAS.js";
import "./chunk-TUSII7EA.js";
import "./chunk-YWGFBTRS.js";
import "./chunk-BHCIAS6L.js";
import "./chunk-TNKA4BMD.js";
import "./chunk-3SJIVSAT.js";
import "./chunk-HXR4TQII.js";
import "./chunk-FQ4JUVCN.js";
import "./chunk-3LL6ALVC.js";
import "./chunk-NZPABYQQ.js";
import "./chunk-CCHJ3WNU.js";
import "./chunk-HFUGSKPL.js";
import "./chunk-BUA5NESM.js";
import "./chunk-SHYE33QH.js";
import "./chunk-LTMF2W73.js";
import "./chunk-5Y3EUPZN.js";
import "./chunk-XBU3UEEJ.js";
import "./chunk-XFKS4JQP.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-TMFB3DKM.js";
import "./chunk-LBC3MAJX.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-XAXNVZUO.js";
import "./chunk-DIR2YFTR.js";
import "./chunk-ZSRASSN6.js";
import "./chunk-N5GLJRXG.js";
import "./chunk-77M4J56U.js";
import "./chunk-XLF2NMGX.js";
import "./chunk-X5GD6LFD.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-KSRBNZJ2.js";
import "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-ZAISHGSP.js";
import {
  d
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import {
  m as m4,
  u as u3
} from "./chunk-HNQNVI5C.js";
import {
  m as m3
} from "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import {
  P,
  m as m2
} from "./chunk-52HWRRRQ.js";
import {
  a as a2,
  e
} from "./chunk-VNTEV3V4.js";
import {
  x,
  y
} from "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import {
  u as u2
} from "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import {
  o
} from "./chunk-YIV2QKTZ.js";
import {
  f,
  h,
  l,
  w
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  u2 as u
} from "./chunk-GZ2P4SCJ.js";
import "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/geometry/support/rotate.js
function o2(n, e3, t2, s3) {
  const i4 = [];
  for (const o3 of n) {
    const n2 = o3.slice();
    i4.push(n2);
    const r3 = e3 * (o3[0] - s3.x) - t2 * (o3[1] - s3.y) + s3.x, a5 = t2 * (o3[0] - s3.x) + e3 * (o3[1] - s3.y) + s3.y;
    n2[0] = r3, n2[1] = a5;
  }
  return i4;
}
function r2(r3, a5, c2) {
  const { hasM: m6, hasZ: x2, spatialReference: f2 } = r3, p = a5 * Math.PI / 180, l2 = Math.cos(p), h4 = Math.sin(p);
  if ("xmin" in r3 && (c2 = c2 ?? r3.center, r3 = new P({ spatialReference: f2, rings: [[[r3.xmin, r3.ymin], [r3.xmin, r3.ymax], [r3.xmax, r3.ymax], [r3.xmax, r3.ymin], [r3.xmin, r3.ymin]]] })), "paths" in r3) {
    c2 = c2 ?? r3.extent.center;
    const n = [];
    for (const e3 of r3.paths) n.push(o2(e3, l2, h4, c2));
    return new y({ hasM: m6, hasZ: x2, spatialReference: f2, paths: n });
  }
  if ("rings" in r3) {
    c2 = c2 ?? r3.extent.center;
    const n = [];
    for (const e3 of r3.rings) {
      const t2 = a2(e3), s3 = o2(e3, l2, h4, c2);
      a2(s3) !== t2 && s3.reverse(), n.push(s3);
    }
    return new P({ hasM: m6, hasZ: x2, spatialReference: f2, rings: n });
  }
  if ("x" in r3) {
    c2 = c2 ?? r3;
    const n = new _({ x: l2 * (r3.x - c2.x) - h4 * (r3.y - c2.y) + c2.x, y: h4 * (r3.x - c2.x) + l2 * (r3.y - c2.y) + c2.y, spatialReference: f2 });
    return null != r3.z && (n.z = r3.z), null != r3.m && (n.m = r3.m), n;
  }
  return "points" in r3 ? (c2 = c2 ?? r3.extent.center, new m2({ hasM: m6, hasZ: x2, points: o2(r3.points, l2, h4, c2), spatialReference: f2 })) : null;
}

// node_modules/@arcgis/core/views/draw/support/Box.js
var E2 = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s3, this.type = "move-start";
  }
};
var z = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s3, this.type = "move";
  }
};
var B = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s3, this.type = "move-stop";
  }
};
var N = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate-start";
  }
};
var U = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate";
  }
};
var Y = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate-stop";
  }
};
var P2 = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s3, this.type = "scale-start";
  }
};
var A = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s3, this.type = "scale";
  }
};
var X = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s3, this.type = "scale-stop";
  }
};
var D = h3.transformGraphics;
var F = { centerIndicator: new u3({ style: "cross", size: D.center.size, color: D.center.color }), fill: { default: new m4({ color: D.fill.color, outline: { color: D.fill.outlineColor, join: "round", width: 1 } }), active: new m4({ color: D.fill.stagedColor, outline: { color: D.fill.outlineColor, join: "round", style: "dash", width: 1 } }) }, handles: { default: new u3({ style: "square", size: D.vertex.size, color: D.vertex.color, outline: { color: D.vertex.outlineColor, width: 1 } }), hover: new u3({ style: "square", size: D.vertex.hoverSize, color: D.vertex.hoverColor, outline: { color: D.vertex.hoverOutlineColor, width: 1 } }) }, rotator: { default: new u3({ style: "circle", size: D.vertex.size, color: D.vertex.color, outline: { color: D.vertex.outlineColor, width: 1 } }), hover: new u3({ style: "circle", size: D.vertex.hoverSize, color: D.vertex.hoverColor, outline: { color: D.vertex.hoverOutlineColor, width: 1 } }) }, rotatorLine: new m3({ color: D.line.color, width: 1 }) };
var V = class extends o.EventedAccessor {
  constructor(t2) {
    super(t2), this._activeHandleGraphic = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._centerGraphic = null, this._backgroundGraphic = null, this._vertexGraphics = [], this._rotateHandleGraphic = null, this._rotateGraphicOffset = 20, this._angleOfRotation = 0, this._rotateLineGraphic = null, this._startInfo = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this.tooltip = null, this.type = "box", this.callbacks = { onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onScaleStart() {
    }, onScale() {
    }, onScaleStop() {
    }, onRotateStart() {
    }, onRotate() {
    }, onRotateStop() {
    }, onGraphicClick() {
    } }, this.enableMovement = true, this.enableRotation = true, this.enableScaling = true, this.graphics = [], this.highlightName = null, this.highlightsEnabled = true, this.layer = null, this.preserveAspectRatio = false, this.showCenterGraphic = true, this.symbols = F, this.sketchOptions = new c(), this.view = null, this._getBounds = (() => {
      const t3 = u2();
      return (e3, i4) => {
        e3[0] = Number.POSITIVE_INFINITY, e3[1] = Number.POSITIVE_INFINITY, e3[2] = Number.NEGATIVE_INFINITY, e3[3] = Number.NEGATIVE_INFINITY;
        for (const s3 of i4) {
          if (!s3) continue;
          let i5, o3, r3, a5;
          if ("point" === s3.type) i5 = r3 = s3.x, o3 = a5 = s3.y;
          else if ("multipoint" === s3.type) {
            const e4 = e(s3);
            [i5, o3, r3, a5] = x(t3, [e4]);
          } else if ("extent" === s3.type) [i5, o3, r3, a5] = [s3.xmin, s3.ymin, s3.xmax, s3.ymax];
          else {
            const e4 = e(s3);
            [i5, o3, r3, a5] = x(t3, e4);
          }
          e3[0] = Math.min(i5, e3[0]), e3[1] = Math.min(o3, e3[1]), e3[2] = Math.max(r3, e3[2]), e3[3] = Math.max(a5, e3[3]);
        }
        return e3;
      };
    })();
  }
  initialize() {
    const t2 = this.view;
    this._highlightHelper = new a4({ view: t2 }), this._setup(), this.addHandles([f(() => t2?.ready, () => {
      const { layer: t3, view: e3 } = this;
      t(e3, t3);
    }, { once: true, initial: true }), l(() => this.preserveAspectRatio, () => {
      this._activeHandleGraphic && (this._scaleGraphic(this._activeHandleGraphic), this._updateGraphics(), this._updateTooltip(this._activeHandleGraphic));
    }), l(() => t2?.scale, () => {
      this._updateRotateGraphic(), this._updateRotateLineGraphic();
    }), l(() => this.graphics, () => this.refresh()), l(() => this.layer, (t3, e3) => {
      e3 && this._resetGraphics(e3), this.refresh();
    }), l(() => [this.highlightsEnabled, this.highlightName], () => {
      this._highlightHelper?.removeAll(), this._setUpHighlights();
    }), l(() => this.sketchOptions.tooltips.effectiveEnabled, (e3) => {
      this.tooltip = e3 ? R(() => ({ view: t2, options: this.sketchOptions.tooltips })) : u(this.tooltip);
    }, w), l(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), h), this.on("move-start", (t3) => this.callbacks?.onMoveStart?.(t3)), this.on("move", (t3) => this.callbacks?.onMove?.(t3)), this.on("move-stop", (t3) => this.callbacks?.onMoveStop?.(t3)), this.on("rotate-start", (t3) => this.callbacks?.onRotateStart?.(t3)), this.on("rotate", (t3) => this.callbacks?.onRotate?.(t3)), this.on("rotate-stop", (t3) => this.callbacks?.onRotateStop?.(t3)), this.on("scale-start", (t3) => this.callbacks?.onScaleStart?.(t3)), this.on("scale", (t3) => this.callbacks?.onScale?.(t3)), this.on("scale-stop", (t3) => this.callbacks?.onScaleStop?.(t3))]);
  }
  destroy() {
    this._reset(), this.tooltip = u(this.tooltip);
  }
  get state() {
    const t2 = this.view?.ready ?? false, e3 = this.graphics.length && this.layer;
    return t2 && e3 ? "active" : t2 ? "ready" : "disabled";
  }
  isUIGraphic(t2) {
    return this._vertexGraphics.includes(t2) || t2 === this._backgroundGraphic || t2 === this._centerGraphic || t2 === this._rotateHandleGraphic || t2 === this._rotateLineGraphic;
  }
  move(t2, e3) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o3 = i(s3, t2, e3, this.view);
        i4.geometry = o3;
      }
      this.refresh(), this.emit("move-stop", new B(this.graphics, null, t2, e3));
    }
  }
  scale(t2, e3) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o3 = s(s3, t2, e3);
        i4.geometry = o3;
      }
      this.refresh(), this.emit("scale-stop", new X(this.graphics, null, t2, e3));
    }
  }
  rotate(t2, e3) {
    if (this._mover && this.graphics.length) {
      if (!e3) {
        const t3 = this._vertexGraphics[1].geometry.x, i4 = this._vertexGraphics[3].geometry.y;
        e3 = new _(t3, i4, this.view.spatialReference);
      }
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o3 = r2(s3, t2, e3);
        i4.geometry = o3;
      }
      this.refresh(), this.emit("rotate-stop", new Y(this.graphics, null, t2));
    }
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphics = [];
  }
  _setup() {
    "active" === this.state && (this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._updateGraphics());
  }
  _reset() {
    this._highlightHelper?.removeAll(), this._resetGraphicStateVars(), this._resetGraphics(), this._updateTooltip(), this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetGraphicStateVars() {
    this._startInfo = null, this._activeHandleGraphic = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this._angleOfRotation = 0;
  }
  _resetGraphics(t2) {
    (t2 = t2 || this.layer) && (t2.removeMany(this._vertexGraphics), t2.remove(this._backgroundGraphic), t2.remove(this._centerGraphic), t2.remove(this._rotateHandleGraphic), t2.remove(this._rotateLineGraphic)), this._vertexGraphics.forEach((t3) => !t3.destroyed && t3.destroy()), !this._backgroundGraphic.destroyed && this._backgroundGraphic.destroy(), !this._centerGraphic.destroyed && this._centerGraphic.destroy(), !this._rotateHandleGraphic.destroyed && this._rotateHandleGraphic.destroy(), !this._rotateLineGraphic.destroyed && this._rotateLineGraphic.destroy(), this._vertexGraphics = [], this._backgroundGraphic = null, this._centerGraphic = null, this._rotateHandleGraphic = null, this._rotateLineGraphic = null;
  }
  _setupMover() {
    let t2 = [];
    this.enableScaling && (t2 = t2.concat(this._vertexGraphics)), this.enableRotation && t2.push(this._rotateHandleGraphic), this.enableMovement && (t2 = t2.concat(this.graphics, this._backgroundGraphic)), this.showCenterGraphic && t2.push(this._centerGraphic), this._mover = new E({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, view: this.view, graphics: t2, callbacks: { onGraphicClick: (t3) => this._onGraphicClickCallback(t3), onGraphicMoveStart: (t3) => this._onGraphicMoveStartCallback(t3), onGraphicMove: (t3) => this._onGraphicMoveCallback(t3), onGraphicMoveStop: (t3) => this._onGraphicMoveStopCallback(t3), onGraphicPointerOver: (t3) => this._onGraphicPointerOverCallback(t3), onGraphicPointerOut: (t3) => this._onGraphicPointerOutCallback(t3) } });
  }
  _getStartInfo(t2) {
    const [e3, i4, s3, o3] = this._getBoxBounds(u2()), r3 = Math.abs(s3 - e3), a5 = Math.abs(o3 - i4), h4 = (s3 + e3) / 2, c2 = (o3 + i4) / 2, { x: n, y: l2 } = t2.geometry;
    return { width: r3, height: a5, centerX: h4, centerY: c2, startX: n, startY: l2, graphicInfos: this._getGraphicInfos(), box: this._backgroundGraphic.geometry, rotate: this._rotateHandleGraphic.geometry };
  }
  _getGraphicInfos() {
    return this.graphics.map((t2) => this._getGraphicInfo(t2));
  }
  _getGraphicInfo(t2) {
    const e3 = t2.geometry, [i4, s3, o3, r3] = this._getBounds(u2(), [e3]);
    return { width: Math.abs(o3 - i4), height: Math.abs(r3 - s3), centerX: (o3 + i4) / 2, centerY: (r3 + s3) / 2, geometry: e3 };
  }
  _onGraphicClickCallback(t2) {
    t2.viewEvent.stopPropagation(), this.emit("graphic-click", t2), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(t2);
  }
  _onGraphicMoveStartCallback(t2) {
    const { _angleOfRotation: e3, _xScale: i4, _yScale: s3, _backgroundGraphic: o3, _vertexGraphics: r3, _rotateHandleGraphic: a5, symbols: h4 } = this, c2 = t2.graphic;
    this._resetGraphicStateVars(), this._hideGraphicsBeforeUpdate(), o3.symbol = h4.fill.active, this._startInfo = this._getStartInfo(c2), this._updateTooltip(c2, t2.viewEvent), c2 === a5 ? (this.view.cursor = "grabbing", this.emit("rotate-start", new N(this.graphics, c2, e3))) : r3.includes(c2) ? (this._activeHandleGraphic = c2, this.emit("scale-start", new P2(this.graphics, c2, i4, s3))) : this.emit("move-start", new E2(this.graphics, c2, t2.dx, t2.dy));
  }
  _onGraphicMoveCallback(t2) {
    const e3 = t2.graphic;
    if (this._startInfo) if (this._vertexGraphics.includes(e3)) this._scaleGraphic(e3), this._updateTooltip(e3, t2.viewEvent), this.emit("scale", new A(this.graphics, e3, this._xScale, this._yScale));
    else if (e3 === this._rotateHandleGraphic) this._rotateGraphic(e3), this._updateTooltip(e3, t2.viewEvent), this.emit("rotate", new U(this.graphics, e3, this._angleOfRotation));
    else {
      const { dx: i4, dy: s3 } = t2;
      this._totalDx += i4, this._totalDy += s3, this._moveGraphic(e3, i4, s3), this._updateTooltip(e3, t2.viewEvent), this.emit("move", new z(this.graphics, e3, i4, s3));
    }
  }
  _onGraphicMoveStopCallback(t2) {
    const e3 = t2.graphic;
    if (!this._startInfo) return void this.refresh();
    const { _angleOfRotation: i4, _totalDx: s3, _totalDy: o3, _xScale: r3, _yScale: a5, _vertexGraphics: h4, _rotateHandleGraphic: c2 } = this;
    this.refresh(), e3 === c2 ? (this.view.cursor = "pointer", this.emit("rotate-stop", new Y(this.graphics, e3, i4))) : h4.includes(e3) ? this.emit("scale-stop", new X(this.graphics, e3, r3, a5)) : this.emit("move-stop", new B(this.graphics, e3, s3, o3));
  }
  _onGraphicPointerOverCallback(t2) {
    const { _backgroundGraphic: e3, _vertexGraphics: i4, graphics: s3, _rotateHandleGraphic: o3, symbols: r3, view: a5 } = this, h4 = t2.graphic;
    if (this._hoveredGraphic = h4, h4 === o3) return o3.symbol = r3.rotator.hover, a5.cursor = "pointer", void this._updateTooltip(h4);
    if (s3.includes(h4) || h4 === e3) return void (a5.cursor = "move");
    if (!i4.includes(h4)) return void (a5.cursor = "pointer");
    this._updateTooltip(h4), t2.graphic.symbol = r3.handles.hover;
    const c2 = a5.rotation;
    let n, l2 = t2.index;
    switch (l2 < 8 && (c2 >= 0 && c2 < 45 ? l2 %= 8 : l2 = c2 >= 45 && c2 < 90 ? (l2 + 1) % 8 : c2 >= 90 && c2 < 135 ? (l2 + 2) % 8 : c2 >= 135 && c2 < 180 ? (l2 + 3) % 8 : c2 >= 180 && c2 < 225 ? (l2 + 4) % 8 : c2 >= 225 && c2 < 270 ? (l2 + 5) % 8 : c2 >= 270 && c2 < 315 ? (l2 + 6) % 8 : (l2 + 7) % 8), l2) {
      case 0:
      case 4:
        n = "nwse-resize";
        break;
      case 1:
      case 5:
        n = "ns-resize";
        break;
      case 2:
      case 6:
        n = "nesw-resize";
        break;
      case 3:
      case 7:
        n = "ew-resize";
        break;
      default:
        n = "pointer";
    }
    a5.cursor = n;
  }
  _onGraphicPointerOutCallback(t2) {
    const { _vertexGraphics: e3, _rotateHandleGraphic: i4, symbols: s3, view: o3 } = this;
    this._hoveredGraphic = null, t2.graphic === i4 ? i4.symbol = s3.rotator.default : e3.includes(t2.graphic) && (t2.graphic.symbol = s3.handles.default), o3.cursor = "default", this._updateTooltip();
  }
  _scaleGraphic(t2) {
    const { _startInfo: e3, _vertexGraphics: i4, preserveAspectRatio: s3, view: o3 } = this, { centerX: r3, centerY: a5, graphicInfos: h4, height: c2, startX: n, startY: l2, width: _2 } = e3, { resolution: d2, transform: m6 } = o3.state, u4 = i4.indexOf(t2);
    1 !== u4 && 5 !== u4 || this._updateX(t2, r3), 3 !== u4 && 7 !== u4 || this._updateY(t2, a5);
    const { x: g, y: y2 } = t2.geometry, v = m6[0] * g + m6[2] * y2 + m6[4], f2 = m6[1] * g + m6[3] * y2 + m6[5], G = h4?.map((t3) => t3.geometry) ?? [], S = G.every((t3) => "point" === t3.type);
    if ((0 === _2 || 0 === c2) && S) {
      const t3 = q((g - n) / d2), i5 = q((l2 - y2) / d2);
      for (let e4 = 0; e4 < G.length; e4++) this.graphics[e4].geometry = i(G[e4], t3, i5, o3, true);
      return this._centerGraphic.geometry = new _(g, y2, o3.spatialReference), void (this._backgroundGraphic.geometry = i(e3.box, t3, i5, o3, true));
    }
    if (s3) {
      const t3 = q(m6[0] * r3 + m6[2] * a5 + m6[4], 2), e4 = q(m6[1] * r3 + m6[3] * a5 + m6[5], 2), i5 = q(m6[0] * n + m6[2] * l2 + m6[4], 2), s4 = q(m6[1] * n + m6[3] * l2 + m6[5], 2);
      let o4 = a3(t3, e4, i5, s4, v, f2);
      0 !== o4 && Math.abs(o4) !== 1 / 0 || (o4 = 1), this._xScale = this._yScale = o4;
      for (const h5 of G) {
        const t4 = G.indexOf(h5);
        this.graphics[t4].geometry = s(h5, this._xScale, this._yScale, [r3, a5]);
      }
      this._updateBackgroundGraphic();
    } else {
      let t3 = g - n, i5 = l2 - y2;
      if (1 === u4 || 5 === u4 ? t3 = 0 : 3 !== u4 && 7 !== u4 || (i5 = 0), 0 === t3 && 0 === i5) return;
      const s4 = r3 + t3 / 2, h5 = a5 + i5 / 2;
      let m7 = (_2 + (n > r3 ? t3 : -1 * t3)) / _2, v2 = (c2 + (l2 < a5 ? i5 : -1 * i5)) / c2;
      1 !== u4 && 5 !== u4 && 0 !== m7 && Math.abs(m7) !== 1 / 0 || (m7 = 1), 3 !== u4 && 7 !== u4 && 0 !== v2 && Math.abs(v2) !== 1 / 0 || (v2 = 1), this._xScale = m7, this._yScale = v2;
      const f3 = (s4 - r3) / d2, x2 = (h5 - a5) / d2, S2 = s(e3.box, this._xScale, this._yScale);
      this._backgroundGraphic.geometry = i(S2, f3, x2, o3, true);
      const { centerX: k, centerY: R2 } = this._getGraphicInfo(this._backgroundGraphic), M = (k - r3) / d2, I = -1 * (R2 - a5) / d2;
      for (const e4 of G) {
        const t4 = G.indexOf(e4), i6 = s(e4, this._xScale, this._yScale, [r3, a5]);
        this.graphics[t4].geometry = i(i6, M, I, o3, true);
      }
      this._centerGraphic.geometry = new _(k, R2, o3.spatialReference);
    }
  }
  _rotateGraphic(t2) {
    const { centerX: e3, centerY: i4, startX: s3, startY: o3, box: r3, rotate: a5 } = this._startInfo, h4 = this.view.spatialReference, c2 = new _(s3, o3, h4), n = new _(e3, i4, h4), l2 = t2.geometry;
    this._angleOfRotation = m5(c2, l2, n);
    const _2 = this._startInfo.graphicInfos?.map((t3) => t3.geometry) ?? [];
    for (const p of _2) {
      const t3 = _2.indexOf(p), e4 = r2(p, this._angleOfRotation, n);
      this.graphics[t3].geometry = e4;
    }
    this._backgroundGraphic.geometry = r2(r3, this._angleOfRotation, n), this._rotateHandleGraphic.geometry = r2(a5, this._angleOfRotation, n);
  }
  _moveGraphic(t2, e3, i4) {
    if (this.graphics.includes(t2)) {
      const s3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i(s3, e3, i4, this.view);
      for (const o3 of this.graphics) o3 !== t2 && (o3.geometry = i(o3.geometry, e3, i4, this.view));
    } else if (t2 === this._centerGraphic) {
      const t3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i(t3, e3, i4, this.view);
    }
    if (t2 === this._backgroundGraphic || t2 === this._centerGraphic) for (const s3 of this.graphics) s3.geometry = i(s3.geometry, e3, i4, this.view);
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphics.length && this._highlightHelper?.add(this.graphics, this.highlightName);
  }
  _setupGraphics() {
    const { _graphicAttributes: t2, symbols: i4 } = this;
    this._centerGraphic = new d({ symbol: i4.centerIndicator, attributes: t2 }), this.showCenterGraphic && this.layer.add(this._centerGraphic), this._backgroundGraphic = new d({ symbol: i4.fill.default, attributes: t2 }), this.layer.add(this._backgroundGraphic), this._rotateLineGraphic = new d({ symbol: i4.rotatorLine, attributes: t2 }), this._rotateHandleGraphic = new d({ symbol: i4.rotator.default, attributes: t2 }), this.enableRotation && !this._hasExtentGraphic() && this.layer.addMany([this._rotateLineGraphic, this._rotateHandleGraphic]);
    for (let s3 = 0; s3 < 8; s3++) this._vertexGraphics.push(new d({ symbol: i4.handles.default, attributes: t2 }));
    this.enableScaling && this.layer.addMany(this._vertexGraphics);
  }
  _updateSymbolsForTheme() {
    const t2 = this.view.effectiveTheme.accentColor;
    this.symbols = { ...this.symbols, fill: { active: this.symbols.fill.active?.clone().set("outline.color", t2), default: this.symbols.fill.default?.clone().set("outline.color", t2) }, handles: { ...this.symbols.handles, default: this.symbols.handles.default.clone().set("outline.color", t2) }, rotator: { ...this.symbols.rotator, default: this.symbols.rotator.default.clone().set("outline.color", t2) }, rotatorLine: this.symbols.rotatorLine.clone().set("color", t2) };
    for (const e3 of this._vertexGraphics) e3.symbol = e3 === this._hoveredGraphic ? this.symbols.handles.hover : this.symbols.handles.default;
    this._backgroundGraphic.symbol = this.symbols.fill.default, this._rotateHandleGraphic.symbol = this._rotateHandleGraphic === this._hoveredGraphic ? this.symbols.rotator.hover : this.symbols.rotator.default, this._rotateLineGraphic.symbol = this.symbols.rotatorLine;
  }
  _updateGraphics() {
    this._updateBackgroundGraphic(), this._updateHandleGraphics(), this._updateCenterGraphic(), this._updateRotateGraphic(), this._updateRotateLineGraphic();
  }
  _hideGraphicsBeforeUpdate() {
    this._centerGraphic.visible = false, this._rotateHandleGraphic.visible = false, this._rotateLineGraphic.visible = false, this._vertexGraphics.forEach((t2) => t2.visible = false);
  }
  _updateHandleGraphics() {
    const t2 = this._getCoordinates(true);
    this._vertexGraphics.forEach((e3, i4) => {
      const [s3, o3] = t2[i4];
      this._updateXY(e3, s3, o3);
    });
  }
  _updateBackgroundGraphic() {
    const t2 = this._getCoordinates().map(([t3, e3]) => [t3, e3]);
    this._backgroundGraphic.geometry = new P({ rings: [t2], spatialReference: this.view.spatialReference });
  }
  _updateCenterGraphic() {
    const [t2, e3, i4, s3] = this._getBoxBounds(u2()), o3 = (i4 + t2) / 2, r3 = (s3 + e3) / 2;
    this._centerGraphic.geometry = new _(o3, r3, this.view.spatialReference);
  }
  _updateRotateGraphic() {
    if (!this._vertexGraphics.length) return;
    const { x: t2, y: e3 } = this._vertexGraphics[1].geometry, i4 = e3 + this.view.state.resolution * this._rotateGraphicOffset;
    this._rotateHandleGraphic.geometry = new _(t2, i4, this.view.spatialReference);
  }
  _updateRotateLineGraphic() {
    if (!this._vertexGraphics.length || !this._rotateHandleGraphic?.geometry) return;
    const t2 = this._vertexGraphics[1].geometry, e3 = this._rotateHandleGraphic.geometry;
    this._rotateLineGraphic.geometry = new y({ paths: [[[t2.x, t2.y], [e3.x, e3.y]]], spatialReference: this.view.spatialReference });
  }
  _updateXY(t2, e3, i4) {
    t2.geometry = new _(e3, i4, this.view.spatialReference);
  }
  _updateX(t2, e3) {
    const i4 = t2.geometry.y;
    t2.geometry = new _(e3, i4, this.view.spatialReference);
  }
  _updateY(t2, e3) {
    const i4 = t2.geometry.x;
    t2.geometry = new _(i4, e3, this.view.spatialReference);
  }
  _hasExtentGraphic() {
    return this.graphics.some((t2) => null != t2?.geometry && "extent" === t2.geometry.type);
  }
  _getBoxBounds(t2) {
    const e3 = this.graphics.map((t3) => t3.geometry);
    return this._getBounds(t2, e3);
  }
  _getCoordinates(t2) {
    const [e3, i4, s3, o3] = this._getBoxBounds(u2());
    if (t2) {
      const t3 = (e3 + s3) / 2, r3 = (o3 + i4) / 2;
      return [[e3, o3], [t3, o3], [s3, o3], [s3, r3], [s3, i4], [t3, i4], [e3, i4], [e3, r3]];
    }
    return [[e3, o3], [s3, o3], [s3, i4], [e3, i4]];
  }
  _updateTooltip(t2, e3) {
    if (null == this.tooltip) return;
    if (!t2) return void this.tooltip.clear();
    const { _backgroundGraphic: i4, graphics: s3, _vertexGraphics: o3, _rotateHandleGraphic: r3 } = this;
    t2 === r3 ? this._updateRotateTooltip() : o3.includes(t2) ? this._updateScaleTooltip() : (s3.includes(t2) || t2 === i4) && this._updateMoveTooltip(e3);
  }
  _updateRotateTooltip() {
    null != this.tooltip && (this.tooltip.info = new s2({ sketchOptions: this.sketchOptions, angle: -this._angleOfRotation }));
  }
  _updateScaleTooltip() {
    const { tooltip: t2, _xScale: e3, _yScale: i4, sketchOptions: s3, view: o3, automaticLengthMeasurementUtils: r3 } = this;
    if (null == t2) return;
    const a5 = this._getCoordinates(), h4 = e2({ topLeft: a5[0], topRight: a5[1], bottomRight: a5[2], bottomLeft: a5[3], spatialReference: o3.spatialReference, automaticLengthMeasurementUtils: r3 });
    if (null == h4) return;
    const { xSize: c2, ySize: n } = h4, l2 = Math.abs(e3), p = Math.abs(i4);
    t2.info = new i3({ sketchOptions: s3, xScale: l2, yScale: p, xSize: c2, ySize: n });
  }
  _updateMoveTooltip(t2) {
    const { tooltip: e3, sketchOptions: i4, view: s3, automaticLengthMeasurementUtils: r3 } = this;
    if (null == e3) return;
    const a5 = new i2({ sketchOptions: i4 });
    if (t2) {
      const { x: e4, y: i5 } = t2.origin, h4 = s3.toMap(t2), c2 = s3.toMap({ x: e4, y: i5 }), n = r3.autoDistanceBetweenPoints2D(c2, h4);
      a5.distance = null != n ? n : h2;
    }
    e3.info = a5;
  }
};
function q(t2, e3 = 2) {
  return Number.parseFloat(t2.toFixed(e3));
}
r([m()], V.prototype, "tooltip", void 0), r([m({ readOnly: true })], V.prototype, "type", void 0), r([m()], V.prototype, "callbacks", void 0), r([m()], V.prototype, "enableMovement", void 0), r([m()], V.prototype, "enableRotation", void 0), r([m()], V.prototype, "enableScaling", void 0), r([m()], V.prototype, "graphics", void 0), r([m()], V.prototype, "highlightName", void 0), r([m()], V.prototype, "highlightsEnabled", void 0), r([m()], V.prototype, "layer", void 0), r([m()], V.prototype, "preserveAspectRatio", void 0), r([m()], V.prototype, "showCenterGraphic", void 0), r([m({ readOnly: true })], V.prototype, "state", null), r([m()], V.prototype, "symbols", void 0), r([m({ type: c })], V.prototype, "sketchOptions", void 0), r([m({ constructOnly: true })], V.prototype, "view", void 0), r([m({ constructOnly: true })], V.prototype, "automaticLengthMeasurementUtils", void 0), V = r([a("esri.views.draw.support.Box")], V);
var J = V;
export {
  J as default
};
//# sourceMappingURL=Box-EFHYMP2E.js.map
