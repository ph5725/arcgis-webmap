import {
  y
} from "./chunk-7TPOIM4Y.js";
import "./chunk-LNFOAX5I.js";
import {
  Xe
} from "./chunk-KXFCAOWK.js";
import "./chunk-VGXBH5PT.js";
import "./chunk-ZUTXZ2PO.js";
import "./chunk-FSVG2RRX.js";
import "./chunk-L3O6KWVI.js";
import "./chunk-2SK5ARBZ.js";
import "./chunk-RNXMAHSA.js";
import "./chunk-VD4HSDHE.js";
import "./chunk-WBSGKMRV.js";
import "./chunk-SBFMUXL3.js";
import "./chunk-PZV6BOD6.js";
import "./chunk-DD7VYTDF.js";
import "./chunk-H7SHPX7W.js";
import "./chunk-WIICHW3C.js";
import "./chunk-T4BWGCN6.js";
import "./chunk-AC7GOP3F.js";
import "./chunk-XPKVLOAO.js";
import "./chunk-GESOBEYT.js";
import "./chunk-3IU6SQCC.js";
import "./chunk-E7YVYF37.js";
import "./chunk-E76L26GR.js";
import "./chunk-GG4VLKUY.js";
import "./chunk-IL45XPTT.js";
import "./chunk-6MFKAT6L.js";
import "./chunk-NOWX6W7R.js";
import "./chunk-OQ76WPLD.js";
import "./chunk-KSVHYEPS.js";
import "./chunk-YOMN3PFE.js";
import "./chunk-UTU6N7VJ.js";
import "./chunk-RV3SBM2C.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-KQINCOQL.js";
import {
  g
} from "./chunk-B6C7UPBZ.js";
import "./chunk-IUQBXXYO.js";
import "./chunk-7WKBQS4R.js";
import "./chunk-SJHAGLIM.js";
import "./chunk-Z6OMEWWC.js";
import "./chunk-MULCOUFY.js";
import "./chunk-VGIEH4HM.js";
import "./chunk-XLF2NMGX.js";
import "./chunk-X5GD6LFD.js";
import "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import "./chunk-OTCYHWWG.js";
import "./chunk-UDSZVLDS.js";
import "./chunk-UGXCZZ7N.js";
import "./chunk-OTSYE6UT.js";
import "./chunk-K5LVZUBF.js";
import "./chunk-J7LSFQNH.js";
import "./chunk-AGDHKBKD.js";
import "./chunk-OC2XWDW2.js";
import "./chunk-C3JHRSMA.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-HUVZEBBO.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-I6IIPG56.js";
import "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-YSCIEMYQ.js";
import {
  p as p2
} from "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import "./chunk-5GBXHGKW.js";
import {
  R
} from "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import "./chunk-KHRHKYU2.js";
import "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import {
  p
} from "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import {
  o
} from "./chunk-JUAPMINU.js";
import {
  f as f2
} from "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  f2 as f,
  h
} from "./chunk-ZWFY3WY5.js";
import {
  I
} from "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  a as a2,
  k
} from "./chunk-GZ2P4SCJ.js";
import {
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  has
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/graphics/sources/CSVSource.js
var c = class extends p {
  constructor(t) {
    super(t), this.type = "csv", this.refresh = k(async (t2) => {
      await this.load();
      const { extent: e, timeExtent: o2 } = await this._connection.invoke("refresh", t2);
      return e && (this.sourceJSON.extent = e), o2 && (this.sourceJSON.timeInfo.timeExtent = [o2.start, o2.end]), { dataChanged: true, updates: { extent: this.sourceJSON.extent, timeInfo: this.sourceJSON.timeInfo } };
    });
  }
  load(t) {
    const e = null != t ? t.signal : null;
    return this.addResolvingPromise(this._startWorker(e)), Promise.resolve(this);
  }
  destroy() {
    this._connection?.close(), this._connection = null;
  }
  async openPorts() {
    return await this.load(), this._connection.openPorts();
  }
  async queryFeatures(t, e = {}) {
    await this.load(e);
    const o2 = await this._connection.invoke("queryFeatures", t ? t.toJSON() : null, e);
    return g.fromJSON(o2);
  }
  async queryFeaturesJSON(t, e = {}) {
    return await this.load(e), this._connection.invoke("queryFeatures", t ? t.toJSON() : null, e);
  }
  async queryFeatureCount(t, e = {}) {
    return await this.load(e), this._connection.invoke("queryFeatureCount", t ? t.toJSON() : null, e);
  }
  async queryObjectIds(t, e = {}) {
    return await this.load(e), this._connection.invoke("queryObjectIds", t ? t.toJSON() : null, e);
  }
  async queryExtent(t, e = {}) {
    await this.load(e);
    const o2 = await this._connection.invoke("queryExtent", t ? t.toJSON() : null, e);
    return { count: o2.count, extent: z.fromJSON(o2.extent) };
  }
  async querySnapping(t, e = {}) {
    return await this.load(e), this._connection.invoke("querySnapping", t, e);
  }
  async queryAttributeBins(t, e = {}) {
    return await this.load(), this._connection.invoke("queryAttributeBins", t ? t.toJSON() : null, e);
  }
  async _startWorker(t) {
    this._connection = await p2("CSVSourceWorker", { strategy: has("feature-layers-workers") ? "dedicated" : "local", signal: t, registryTarget: this });
    const { url: e, delimiter: o2, fields: i, latitudeField: s2, longitudeField: n, spatialReference: a3, timeInfo: c2 } = this.loadOptions, u = await this._connection.invoke("load", { url: e, customParameters: this.customParameters, parsingOptions: { delimiter: o2, fields: i?.map((t2) => t2.toJSON()), latitudeField: s2, longitudeField: n, spatialReference: a3?.toJSON(), timeInfo: c2?.toJSON() } }, { signal: t });
    this.locationInfo = u.locationInfo, this.sourceJSON = u.layerDefinition, this.delimiter = u.delimiter;
  }
};
r([m()], c.prototype, "type", void 0), r([m()], c.prototype, "loadOptions", void 0), r([m()], c.prototype, "customParameters", void 0), r([m()], c.prototype, "locationInfo", void 0), r([m()], c.prototype, "sourceJSON", void 0), r([m()], c.prototype, "delimiter", void 0), c = r([a("esri.layers.graphics.sources.CSVSource")], c);

// node_modules/@arcgis/core/layers/CSVLayer.js
function h2(e, r2) {
  throw new s(r2, `CSVLayer (title: ${e.title}, id: ${e.id}) cannot be saved to a portal item`);
}
var m2 = class extends Xe {
  constructor(...e) {
    super(...e), this.geometryType = "point", this.capabilities = y(false, false), this.delimiter = null, this.editingEnabled = false, this.fields = null, this.latitudeField = null, this.locationType = "coordinates", this.longitudeField = null, this.operationalLayerType = "CSV", this.outFields = ["*"], this.path = null, this.spatialReference = f2.WGS84, this.source = null, this.type = "csv";
  }
  normalizeCtorArgs(e, t) {
    return "string" == typeof e ? { url: e, ...t } : e;
  }
  load(e) {
    const t = null != e ? e.signal : null, i = this.loadFromPortal({ supportedTypes: ["CSV"], supportsData: false }, e).catch(a2).then(async () => this.initLayerProperties(await this.createGraphicsSource(t)));
    return this.addResolvingPromise(i), Promise.resolve(this);
  }
  get isTable() {
    return this.loaded && null == this.geometryType;
  }
  readWebMapLabelsVisible(e, t) {
    return null != t.showLabels ? t.showLabels : !!t.layerDefinition?.drawingInfo?.labelingInfo;
  }
  set url(e) {
    if (!e) return void this._set("url", e);
    const t = I(e);
    this._set("url", t.path), t.query && (this.customParameters = { ...this.customParameters, ...t.query });
  }
  async createGraphicsSource(e) {
    const t = new c({ loadOptions: { delimiter: this.delimiter, fields: this.fields, latitudeField: this.latitudeField ?? void 0, longitudeField: this.longitudeField ?? void 0, spatialReference: this.spatialReference ?? void 0, timeInfo: this.timeInfo ?? void 0, url: this.url }, customParameters: this.customParameters ?? void 0 });
    return this._set("source", t), await t.load({ signal: e }), this.read({ locationInfo: t.locationInfo, columnDelimiter: t.delimiter }, { origin: "service", url: this.parsedUrl }), t;
  }
  queryFeatures(e, t) {
    return this.load().then(() => this.source.queryFeatures(R.from(e) || this.createQuery())).then((e2) => {
      if (e2?.features) for (const t2 of e2.features) t2.layer = t2.sourceLayer = this;
      return e2;
    });
  }
  async queryObjectIds(e, t) {
    return await this.load(), this.source.queryObjectIds(R.from(e) || this.createQuery());
  }
  queryFeatureCount(e, t) {
    return this.load().then(() => this.source.queryFeatureCount(R.from(e) || this.createQuery()));
  }
  queryExtent(e, t) {
    return this.load().then(() => this.source.queryExtent(R.from(e) || this.createQuery()));
  }
  read(e, t) {
    super.read(e, t), t && "service" === t.origin && this.revert(["latitudeField", "longitudeField"], "service");
  }
  write(e, t) {
    return super.write(e, { ...t, writeLayerSchema: true });
  }
  clone() {
    throw new s("csv-layer:clone", `CSVLayer (title: ${this.title}, id: ${this.id}) cannot be cloned`);
  }
  async save(e) {
    return h2(this, "csv-layer:save");
  }
  async saveAs(e, t) {
    return h2(this, "csv-layer:save-as");
  }
  async hasDataChanged() {
    try {
      const { dataChanged: e, updates: t } = await this.source.refresh(this.customParameters);
      return null != t && this.read(t, { origin: "service", url: this.parsedUrl, ignoreDefaults: true }), e;
    } catch {
    }
    return false;
  }
  _verifyFields() {
  }
  _verifySource() {
  }
  _hasMemorySource() {
    return false;
  }
};
r([m({ readOnly: true, json: { read: false, write: false } })], m2.prototype, "capabilities", void 0), r([m({ type: [",", " ", ";", "|", "	"], json: { read: { source: "columnDelimiter" }, write: { target: "columnDelimiter", ignoreOrigin: true } } })], m2.prototype, "delimiter", void 0), r([m({ readOnly: true, type: Boolean, json: { origins: { "web-scene": { read: false, write: false } } } })], m2.prototype, "editingEnabled", void 0), r([m({ json: { read: { source: "layerDefinition.fields" }, write: { target: "layerDefinition.fields" } } })], m2.prototype, "fields", void 0), r([m({ type: Boolean, readOnly: true })], m2.prototype, "isTable", null), r([o("web-map", "labelsVisible", ["layerDefinition.drawingInfo.labelingInfo", "showLabels"])], m2.prototype, "readWebMapLabelsVisible", null), r([m({ type: String, json: { read: { source: "locationInfo.latitudeFieldName" }, write: { target: "locationInfo.latitudeFieldName", ignoreOrigin: true } } })], m2.prototype, "latitudeField", void 0), r([m({ type: ["show", "hide"] })], m2.prototype, "listMode", void 0), r([m({ type: ["coordinates"], json: { read: { source: "locationInfo.locationType" }, write: { target: "locationInfo.locationType", ignoreOrigin: true, isRequired: true } } })], m2.prototype, "locationType", void 0), r([m({ type: String, json: { read: { source: "locationInfo.longitudeFieldName" }, write: { target: "locationInfo.longitudeFieldName", ignoreOrigin: true } } })], m2.prototype, "longitudeField", void 0), r([m({ type: ["CSV"] })], m2.prototype, "operationalLayerType", void 0), r([m()], m2.prototype, "outFields", void 0), r([m({ type: String, json: { origins: { "web-scene": { read: false, write: false } }, read: false, write: false } })], m2.prototype, "path", void 0), r([m({ json: { read: false }, cast: null, type: c, readOnly: true })], m2.prototype, "source", void 0), r([m({ json: { read: false }, value: "csv", readOnly: true })], m2.prototype, "type", void 0), r([m({ json: { read: f, write: { isRequired: true, ignoreOrigin: true, writer: h } } })], m2.prototype, "url", null), m2 = r([a("esri.layers.CSVLayer")], m2);
var f3 = m2;
export {
  f3 as default
};
//# sourceMappingURL=CSVLayer-SJXT7GS6.js.map
