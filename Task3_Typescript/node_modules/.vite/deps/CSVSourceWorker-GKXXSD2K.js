import {
  n as n4
} from "./chunk-PLYN6ARH.js";
import {
  u as u2
} from "./chunk-CVH52ZBN.js";
import {
  c
} from "./chunk-VZZR2ZMJ.js";
import {
  e as e2,
  n as n3
} from "./chunk-DBZ575A6.js";
import {
  f as f2
} from "./chunk-524UHFSB.js";
import "./chunk-H5N2AXWG.js";
import {
  L
} from "./chunk-P4YXQBLK.js";
import "./chunk-WUKLWX63.js";
import "./chunk-LHJOMFWG.js";
import "./chunk-APGIAJ3M.js";
import "./chunk-ES5H7VGK.js";
import "./chunk-JV7SG7ZY.js";
import "./chunk-NLQ5JBZ3.js";
import "./chunk-WQVEQTKW.js";
import "./chunk-DKS7UUDR.js";
import "./chunk-KDQWOWXR.js";
import {
  s as s3
} from "./chunk-JOVQBCRD.js";
import {
  a,
  u
} from "./chunk-7TPOIM4Y.js";
import "./chunk-LNFOAX5I.js";
import "./chunk-U3MD377S.js";
import {
  x
} from "./chunk-2B6XECE5.js";
import {
  t
} from "./chunk-QB5ST4HW.js";
import "./chunk-OIO6NR6X.js";
import "./chunk-F5BDMX7A.js";
import {
  e
} from "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-AAC6XSCN.js";
import "./chunk-Z7VYTTYM.js";
import "./chunk-BDWOUZQR.js";
import "./chunk-H34ENSPL.js";
import "./chunk-4ADC6HZF.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-LBC3MAJX.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-C3JHRSMA.js";
import {
  Z
} from "./chunk-JEYXDNAT.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import {
  V
} from "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import {
  ee,
  ne,
  p
} from "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import {
  n as n2
} from "./chunk-6QA2BVC5.js";
import "./chunk-QVKLS4LH.js";
import "./chunk-2KVNXQA7.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  d as d2
} from "./chunk-HPGYEHVI.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import {
  n
} from "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-O5TPFXRT.js";
import {
  d
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import {
  O,
  U,
  s as s2
} from "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import "./chunk-N3XLUQJI.js";
import "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H
} from "./chunk-ZWFY3WY5.js";
import {
  I,
  qt
} from "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  b
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/graphics/sources/csv/csv.js
var o = /^\s*"([\S\s]*)"\s*$/;
var l = /""/g;
var s4 = "\n";
var u3 = [",", " ", ";", "|", "	"];
function* c2(e3, t2, n5) {
  let r = 0;
  for (; r <= e3.length; ) {
    const i2 = e3.indexOf(t2, r), o2 = e3.slice(r, i2 > -1 ? i2 : void 0);
    r += o2.length + t2.length, n5 && !o2.trim() || (yield o2);
  }
}
function f3(e3) {
  const t2 = e3.includes("\r\n") ? "\r\n" : s4;
  return c2(e3, t2, true);
}
function a2(e3, t2) {
  return c2(e3, t2, false);
}
function d3(e3, t2, n5) {
  e3 = e3.trim(), t2 = t2?.trim();
  const r = [], o2 = Array.from(/* @__PURE__ */ new Set([n5?.delimiter, ...u3])).filter((e4) => null != e4);
  for (const i2 of o2) {
    const n6 = g(e3, i2).length, o3 = g(t2, i2).length ?? n6;
    n6 > 1 && r.push({ weight: Math.min(n6, o3), delimiter: i2 });
  }
  const l2 = r.sort(({ weight: e4 }, { weight: t3 }) => t3 - e4).map(({ delimiter: e4 }) => e4);
  for (const s5 of l2) {
    const t3 = m(e3, s5).names, r2 = n4(t3, n5?.longitudeField, n5?.latitudeField);
    if (r2.longitudeFieldName && r2.latitudeFieldName) return { delimiter: s5, locationInfo: r2 };
  }
  return { delimiter: l2[0], locationInfo: null };
}
function* p2(e3, t2, n5, r = () => /* @__PURE__ */ Object.create(null)) {
  const i2 = f3(e3);
  i2.next();
  let u4 = "", c3 = "", d4 = 0, p3 = r(), m2 = 0;
  e: for (const f4 of i2) {
    const e4 = a2(f4, n5);
    for (const i3 of e4) if (u4 += c3 + i3, c3 = "", d4 += h(i3), d4 % 2 == 0) {
      if (d4 > 0) {
        const e5 = o.exec(u4);
        if (!e5) {
          p3 = r(), m2 = 0, u4 = "", d4 = 0;
          continue e;
        }
        p3[t2[m2]] = e5[1].replaceAll(l, '"'), m2++;
      } else p3[t2[m2]] = u4, m2++;
      u4 = "", d4 = 0;
    } else c3 = n5;
    0 === d4 ? (yield p3, p3 = r(), m2 = 0) : c3 = s4;
  }
}
function m(e3, t2) {
  const r = g(e3, t2).filter((e4) => null != e4), i2 = r.map((e4) => p(e4));
  for (let n5 = i2.length - 1; n5 >= 0; n5--) i2[n5] || (i2.splice(n5, 1), r.splice(n5, 1));
  return { names: i2, aliases: r };
}
function g(e3, t2) {
  if (!e3?.length) return [];
  const n5 = [];
  let r = "", i2 = "", s5 = 0;
  const u4 = a2(e3, t2);
  for (const c3 of u4) if (r += i2 + c3, i2 = "", s5 += h(c3), s5 % 2 == 0) {
    if (s5 > 0) {
      const e4 = o.exec(r);
      e4 && n5.push(e4[1].replaceAll(l, '"'));
    } else n5.push(r);
    r = "", s5 = 0;
  } else i2 = t2;
  return n5;
}
function h(e3) {
  let t2 = 0, n5 = 0;
  for (n5 = e3.indexOf('"', n5); n5 >= 0; ) t2++, n5 = e3.indexOf('"', n5 + 1);
  return t2;
}
function N(e3, t2, n5, i2, o2) {
  const l2 = [], s5 = p2(e3, n5, t2), u4 = [];
  for (const r of s5) {
    if (10 === u4.length) break;
    u4.push(r);
  }
  for (let c3 = 0; c3 < n5.length; c3++) {
    const e4 = n5[c3], t3 = i2[c3];
    if (e4 === o2.longitudeFieldName || e4 === o2.latitudeFieldName) l2.push({ name: e4, type: "esriFieldTypeDouble", alias: t3 });
    else {
      let n6;
      switch (b2(u4.map((t4) => t4[e4]))) {
        case "integer":
          n6 = "esriFieldTypeInteger";
          break;
        case "double":
          n6 = "esriFieldTypeDouble";
          break;
        case "date":
          n6 = "esriFieldTypeDate";
          break;
        default:
          n6 = "esriFieldTypeString";
      }
      l2.push({ name: e4, type: n6, alias: t3, length: ne(n6) });
    }
  }
  return l2;
}
function b2(t2) {
  if (!t2.length) return "string";
  const n5 = /[^+\-.,0-9]/;
  return t2.map((t3) => {
    if ("" !== t3) {
      if (!n5.test(t3)) {
        let e3 = x2(t3);
        if (!isNaN(e3)) return /[.,]/.test(t3) || !Number.isInteger(e3) || e3 > 214783647 || e3 < -214783648 ? "double" : "integer";
        if (t3.includes("E")) {
          if (e3 = Number(t3), !Number.isNaN(e3)) return "double";
          if (t3.includes(",") && (t3 = t3.replace(",", "."), e3 = Number(t3), !Number.isNaN(e3))) return "double";
        }
      }
      return e2(t3) ? "date" : "string";
    }
  }).reduce((e3, t3) => void 0 === e3 ? t3 : void 0 === t3 ? e3 : e3 === t3 ? t3 : "string" === e3 || "string" === t3 ? "string" : "double" === e3 || "double" === t3 ? "double" : void 0);
}
var x2 = function() {
  const e3 = c(), n5 = new RegExp("^" + e3.regexp + "$"), r = new RegExp("[" + e3.group + "\\s\\xa0]", "g"), i2 = e3.factor;
  return (t2) => {
    const o2 = n5.exec(t2);
    if (e3.factor = i2, !o2) return NaN;
    let l2 = o2[1];
    if (!o2[1]) {
      if (!o2[2]) return NaN;
      l2 = o2[2], e3.factor *= -1;
    }
    return l2 = l2.replace(r, "").replace(e3.decimal, "."), +l2 * e3.factor;
  };
}();
function y(e3) {
  return JSON.parse(JSON.stringify(e3));
}

// node_modules/@arcgis/core/layers/graphics/sources/support/CSVSourceWorker.js
var k = u("esriGeometryPoint");
var P = ["csv"];
var R = [0, 0];
var V2 = class {
  constructor(e3, t2) {
    this.x = e3, this.y = t2;
  }
};
var A = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e3) => {
      const t2 = await this._fetch(e3);
      return this._createFeatures(t2);
    };
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = null;
  }
  async load(e3, t2 = {}) {
    this._loadOptions = e3;
    const [i2] = await Promise.all([this._fetch(t2.signal), this._checkProjection(e3?.parsingOptions?.spatialReference)]), n5 = G(i2, e3);
    this._locationInfo = n5.locationInfo, this._delimiter = n5.delimiter, this._queryEngine = this._createQueryEngine(n5);
    const r = await this._createFeatures(i2);
    this._queryEngine.featureStore.addMany(r);
    const { fullExtent: s5, timeExtent: o2 } = await this._queryEngine.fetchRecomputedExtents();
    if (n5.layerDefinition.extent = s5, o2) {
      const { start: e4, end: t3 } = o2;
      n5.layerDefinition.timeInfo.timeExtent = [e4, t3];
    }
    return n5;
  }
  async applyEdits() {
    throw new s("csv-layer:editing-not-supported", "applyEdits() is not supported on CSVLayer");
  }
  async queryFeatures(e3 = {}, t2 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e3, t2.signal);
  }
  async queryFeatureCount(e3 = {}, t2 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e3, t2.signal);
  }
  async queryObjectIds(e3 = {}, t2 = {}) {
    await this._waitSnapshotComplete();
    return (await this._queryEngine.executeQueryForIds(e3, t2.signal)).filter(n2);
  }
  async queryExtent(e3 = {}, t2 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e3, t2.signal);
  }
  async querySnapping(e3, t2 = {}) {
    return await this._waitSnapshotComplete(), u2(this._queryEngine, e3, t2.signal);
  }
  async queryAttributeBins(e3, t2 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeAttributeBinsQuery(e3, t2.signal);
  }
  async refresh(e3) {
    this._loadOptions.customParameters = e3, this._snapshotTask?.abort(), this._snapshotTask = d2(this._snapshotFeatures), this._snapshotTask.promise.then((e4) => {
      this._queryEngine.featureStore.clear(), e4 && this._queryEngine.featureStore.addMany(e4);
    }, (e4) => {
      this._queryEngine.featureStore.clear(), b(e4) || i.getLogger("esri.layers.CSVLayer").error(new s("csv-layer:refresh", "An error occurred during refresh", { error: e4 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: i2, timeExtent: o2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: i2, timeExtent: o2 };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t2) {
    const { url: i2, customParameters: r } = this._loadOptions;
    if (!i2) throw new s("csv-layer:invalid-source", "url not defined");
    const s5 = I(i2);
    return (await H(s5.path, { query: { ...s5.query, ...r }, responseType: "text", signal: t2 })).data;
  }
  _createQueryEngine(e3) {
    const { objectIdField: t2, fields: i2, extent: n5, timeInfo: r } = e3.layerDefinition, s5 = new f2({ geometryType: "esriGeometryPoint", hasM: false, hasZ: false }), o2 = { type: "object-id", fieldName: t2 };
    return new L({ fieldsIndex: Z.fromLayerJSON({ fields: i2, dateFieldsTimeReference: { timeZoneIANA: n } }), geometryType: "esriGeometryPoint", hasM: false, hasZ: false, timeInfo: r, featureIdInfo: o2, spatialReference: n5.spatialReference || { wkid: 4326 }, featureStore: s5 });
  }
  async _createFeatures(e3) {
    const { latitudeFieldName: t2, longitudeFieldName: n5 } = this._locationInfo, { objectIdField: r, fieldsIndex: s5, spatialReference: o2 } = this._queryEngine;
    let a3 = [];
    const f4 = [], g2 = s5.fields.filter((e4) => e4.name !== r).map((e4) => e4.name);
    let I2 = 0;
    const _ = {};
    for (const i2 of s5.fields) if ("esriFieldTypeOID" !== i2.type && "esriFieldTypeGlobalID" !== i2.type) {
      const e4 = ee(i2);
      void 0 !== e4 && (_[i2.name] = e4);
    }
    const F = p2(e3, g2, this._delimiter, a(_, r));
    for (const l2 of F) {
      const e4 = this._parseCoordinateValue(l2[t2]), o3 = this._parseCoordinateValue(l2[n5]);
      if (null != o3 && null != e4 && !isNaN(e4) && !isNaN(o3)) {
        l2[t2] = e4, l2[n5] = o3;
        for (const e5 in l2) if (e5 !== t2 && e5 !== n5) if (s5.isDateField(e5)) l2[e5] = n3(l2[e5]);
        else if (s5.isNumericField(e5)) {
          const t3 = x2(l2[e5]);
          isNaN(t3) ? l2[e5] = null : l2[e5] = t3;
        } else null != l2[e5] && (l2[e5] = y(l2[e5]));
        l2[r] = I2, I2++, a3.push(new V2(o3, e4)), f4.push(l2);
      }
    }
    if (!s2({ wkid: 4326 }, o2)) if (O(o2)) for (const i2 of a3) [i2.x, i2.y] = d(i2.x, i2.y, R);
    else a3 = V(t, a3, f.WGS84, o2, null, null);
    const T = [];
    for (let i2 = 0; i2 < a3.length; i2++) {
      const { x: e4, y: t3 } = a3[i2], n6 = f4[i2];
      n6[r] = i2 + 1, T.push(new s3(new e([], [e4, t3]), n6, null, n6[r]));
    }
    return T;
  }
  _parseCoordinateValue(e3) {
    if (null == e3 || "" === e3) return null;
    let t2 = x2(e3);
    return (isNaN(t2) || Math.abs(t2) > 181) && (t2 = parseFloat(e3)), t2;
  }
  async _checkProjection(e3) {
    try {
      await x(U, e3);
    } catch {
      throw new s("csv-layer:projection-not-supported", "Projection not supported");
    }
  }
};
function G(e3, t2) {
  const i2 = t2.parsingOptions || {}, r = { delimiter: i2.delimiter, layerDefinition: null, locationInfo: { latitudeFieldName: i2.latitudeField, longitudeFieldName: i2.longitudeField } }, s5 = r.layerDefinition = { name: qt(t2.url, P) || "csv", dateFieldsTimeReference: { timeZoneIANA: n }, drawingInfo: k, geometryType: "esriGeometryPoint", objectIdField: null, fields: [], timeInfo: i2.timeInfo, extent: { xmin: Number.POSITIVE_INFINITY, ymin: Number.POSITIVE_INFINITY, xmax: Number.NEGATIVE_INFINITY, ymax: Number.NEGATIVE_INFINITY, spatialReference: i2.spatialReference || { wkid: 4326 } } }, o2 = f3(e3), l2 = o2.next().value?.trim(), m2 = o2.next().value?.trim();
  if (!l2) throw new s("csv-layer:empty-csv", "CSV is empty", { csv: e3 });
  const { delimiter: c3, locationInfo: d4 } = d3(l2, m2, i2);
  if (!c3) throw new s("csv-layer:invalid-delimiter", "Unable to detect the delimiter from CSV", { firstLine: l2, secondLine: m2, parsingOptions: i2 });
  if (!d4) throw new s("csv-layer:location-fields-not-found", "Unable to identify latitude and longitude fields from the CSV file", { firstLine: l2, secondLine: m2, parsingOptions: i2 });
  r.locationInfo = d4, r.delimiter = c3;
  const { names: u4, aliases: f4 } = m(l2, c3), p3 = N(e3, r.delimiter, u4, f4, r.locationInfo);
  if (i2.fields?.length) {
    const e4 = new Z(i2.fields);
    for (const t3 of p3) {
      const i3 = e4.get(t3.name);
      i3 && Object.assign(t3, i3);
    }
  }
  if (!p3.some((e4) => "esriFieldTypeOID" === e4.type && (s5.objectIdField = e4.name, true))) {
    const e4 = { name: "__OBJECTID", alias: "__OBJECTID", type: "esriFieldTypeOID", editable: false, nullable: false };
    s5.objectIdField = e4.name, p3.unshift(e4);
  }
  s5.fields = p3;
  const y2 = new Z(s5.fields);
  if (r.locationInfo && (r.locationInfo.latitudeFieldName = y2.get(r.locationInfo.latitudeFieldName).name, r.locationInfo.longitudeFieldName = y2.get(r.locationInfo.longitudeFieldName).name), s5.timeInfo) {
    const e4 = s5.timeInfo;
    if (e4.startTimeField) {
      const t3 = y2.get(e4.startTimeField);
      t3 ? (e4.startTimeField = t3.name, t3.type = "esriFieldTypeDate") : e4.startTimeField = null;
    }
    if (e4.endTimeField) {
      const t3 = y2.get(e4.endTimeField);
      t3 ? (e4.endTimeField = t3.name, t3.type = "esriFieldTypeDate") : e4.endTimeField = null;
    }
    if (e4.trackIdField) {
      const t3 = y2.get(e4.trackIdField);
      e4.trackIdField = t3 ? t3.name : null;
    }
    e4.startTimeField || e4.endTimeField || (s5.timeInfo = null);
  }
  return r;
}
export {
  A as default
};
//# sourceMappingURL=CSVSourceWorker-GKXXSD2K.js.map
