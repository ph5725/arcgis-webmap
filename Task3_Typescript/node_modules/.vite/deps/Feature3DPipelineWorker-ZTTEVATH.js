import {
  s as s9
} from "./chunk-NFOAHFB6.js";
import {
  S
} from "./chunk-CSNPKNAQ.js";
import {
  B as B2
} from "./chunk-XLZA3DH7.js";
import {
  ue
} from "./chunk-4PEDH45I.js";
import {
  B,
  U,
  ct,
  rt
} from "./chunk-JSKJKRHP.js";
import {
  c as c3,
  i,
  s as s10
} from "./chunk-V4C53BKZ.js";
import "./chunk-67IMFEKD.js";
import "./chunk-PYKMDQYM.js";
import "./chunk-4TMVUEZQ.js";
import "./chunk-JOUWZB2W.js";
import "./chunk-NKOCAN7K.js";
import "./chunk-VOIQQS36.js";
import {
  L as L3
} from "./chunk-P4YXQBLK.js";
import "./chunk-WUKLWX63.js";
import "./chunk-LHJOMFWG.js";
import "./chunk-APGIAJ3M.js";
import {
  E,
  s as s8
} from "./chunk-JV7SG7ZY.js";
import {
  H,
  Q as Q2,
  W
} from "./chunk-RODRBIXX.js";
import {
  e as e8,
  o as o6
} from "./chunk-CWLDBABC.js";
import "./chunk-37WACOMS.js";
import "./chunk-SHXYOAIC.js";
import "./chunk-5DVJFLIL.js";
import "./chunk-VRSDJVZH.js";
import "./chunk-B7AMZ4LC.js";
import "./chunk-VLNFWLNQ.js";
import "./chunk-LXEAJGDN.js";
import "./chunk-F6DB34F6.js";
import "./chunk-TEFCZNLX.js";
import "./chunk-DAJMNP5A.js";
import "./chunk-PJ7AE5BM.js";
import "./chunk-EMBDDCJP.js";
import "./chunk-SMESMUA5.js";
import "./chunk-MDCTPMKN.js";
import {
  o as o7
} from "./chunk-KQMSRGRD.js";
import "./chunk-BQVMDMIB.js";
import "./chunk-XLYBLHTD.js";
import "./chunk-4TBDRMZ4.js";
import "./chunk-RS3I6DPK.js";
import "./chunk-756RU7RS.js";
import "./chunk-7UTSKTVG.js";
import "./chunk-56ZY2WLU.js";
import "./chunk-KCTSIZOP.js";
import "./chunk-HSRD3P5Q.js";
import "./chunk-5JV4N5AU.js";
import "./chunk-4XEYVSQH.js";
import "./chunk-XSPND757.js";
import "./chunk-QY6CN52R.js";
import "./chunk-VT5VIQO4.js";
import "./chunk-4D63UIH5.js";
import "./chunk-ENL2JUSP.js";
import "./chunk-U3CE4V5Z.js";
import "./chunk-7KQYSRGY.js";
import "./chunk-SJV3HVGJ.js";
import "./chunk-SWINDW7X.js";
import "./chunk-R2HTWJLS.js";
import "./chunk-2ZADANKQ.js";
import "./chunk-MI6QXJMY.js";
import "./chunk-3GCFO25G.js";
import "./chunk-VEXXJH4E.js";
import "./chunk-4TMSLZIY.js";
import "./chunk-4NFGT2KA.js";
import "./chunk-QPAG77FN.js";
import "./chunk-6FK2OY3E.js";
import "./chunk-US6IOLIT.js";
import "./chunk-6LQLTORF.js";
import "./chunk-FFB32VN7.js";
import "./chunk-WUNNTEK6.js";
import "./chunk-R2Q57RB2.js";
import "./chunk-PEF2Q5HH.js";
import "./chunk-A4KKV2O6.js";
import {
  n as n7
} from "./chunk-3MVOHROR.js";
import "./chunk-RVXIJHL6.js";
import "./chunk-QXKZRZ4D.js";
import "./chunk-ILO2YRRS.js";
import {
  t as t3
} from "./chunk-ZN7Z7TAB.js";
import "./chunk-3ECQNGV5.js";
import "./chunk-Q77BGVST.js";
import "./chunk-TTPBKTNJ.js";
import "./chunk-ZPAWXU2P.js";
import "./chunk-KQOOCDUQ.js";
import "./chunk-PP3UNFGS.js";
import "./chunk-FYCLQ3SU.js";
import "./chunk-BGR5EVZD.js";
import "./chunk-DQG3SJJO.js";
import "./chunk-LWV5GP6V.js";
import "./chunk-QNHQE3IL.js";
import "./chunk-6EOJZ6DP.js";
import "./chunk-DRLVYVHZ.js";
import {
  e as e7
} from "./chunk-UZRZVWLE.js";
import "./chunk-NLQ5JBZ3.js";
import "./chunk-WQVEQTKW.js";
import "./chunk-DKS7UUDR.js";
import {
  m as m4
} from "./chunk-KH55BE33.js";
import {
  b as b2,
  h as h3
} from "./chunk-WEBPKGFM.js";
import {
  a as a5
} from "./chunk-6DARBDBU.js";
import "./chunk-KDQWOWXR.js";
import {
  n as n3
} from "./chunk-JOVQBCRD.js";
import "./chunk-LNFOAX5I.js";
import "./chunk-U3MD377S.js";
import "./chunk-2B6XECE5.js";
import "./chunk-RTDWTAVK.js";
import "./chunk-QLJ6JQFC.js";
import "./chunk-ZAIOYQ5Z.js";
import "./chunk-QB5ST4HW.js";
import "./chunk-IMFGC5DS.js";
import {
  A,
  e as e5
} from "./chunk-LG4SF54U.js";
import "./chunk-TNKA4BMD.js";
import "./chunk-VKKELZ6R.js";
import {
  m as m5
} from "./chunk-DLD56RZZ.js";
import "./chunk-3SJIVSAT.js";
import "./chunk-HXR4TQII.js";
import {
  e as e6
} from "./chunk-67CCONUO.js";
import "./chunk-6DBRCIDV.js";
import "./chunk-YSRSL2SU.js";
import "./chunk-FQ4JUVCN.js";
import "./chunk-3LL6ALVC.js";
import {
  e as e4
} from "./chunk-NZPABYQQ.js";
import "./chunk-CCHJ3WNU.js";
import "./chunk-OIO6NR6X.js";
import "./chunk-F5BDMX7A.js";
import "./chunk-H5K53FMS.js";
import {
  e as e3
} from "./chunk-VNLFNBKT.js";
import {
  a as a3,
  n as n2,
  s as s5,
  t
} from "./chunk-KHEIHGIK.js";
import {
  u
} from "./chunk-AAC6XSCN.js";
import "./chunk-Z7VYTTYM.js";
import "./chunk-BDWOUZQR.js";
import "./chunk-H34ENSPL.js";
import "./chunk-4ADC6HZF.js";
import "./chunk-H6F6O2KE.js";
import "./chunk-AF3FX2UV.js";
import "./chunk-DRAQJS2F.js";
import "./chunk-BZYXFNL4.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-TMFB3DKM.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import {
  s as s4
} from "./chunk-NO2XQDLB.js";
import "./chunk-LBC3MAJX.js";
import {
  l as l3
} from "./chunk-H7XUEHGR.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-KQINCOQL.js";
import {
  o as o5
} from "./chunk-OTSYE6UT.js";
import "./chunk-AGDHKBKD.js";
import "./chunk-OC2XWDW2.js";
import "./chunk-C3JHRSMA.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-HUVZEBBO.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-I6IIPG56.js";
import {
  Z
} from "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import {
  a as a4,
  s as s7
} from "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import {
  R as R2
} from "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import "./chunk-6QTMK7BB.js";
import {
  O,
  Q
} from "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import {
  o as o3
} from "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-KHRHKYU2.js";
import "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import {
  d3 as d2,
  f as f4,
  j as j2,
  m as m3,
  n2 as n6
} from "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import {
  c as c2,
  t as t2
} from "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import {
  a2,
  p as p2,
  u as u2
} from "./chunk-FKFXOPPT.js";
import {
  l as l2
} from "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-QVKLS4LH.js";
import "./chunk-2KVNXQA7.js";
import "./chunk-XDCUZFJX.js";
import {
  f as f3,
  h as h2,
  n as n5,
  o as o4,
  s as s6
} from "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  d
} from "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import {
  _,
  n as n4,
  u as u3
} from "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import {
  R,
  c,
  o as o2,
  p
} from "./chunk-6GWORUT3.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import {
  o
} from "./chunk-YIV2QKTZ.js";
import {
  h,
  j,
  l
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import {
  f as f2
} from "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  b,
  e3 as e2,
  m as m2
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  n,
  r,
  s
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import {
  M
} from "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  L as L2,
  e,
  f2 as f,
  m,
  s as s3
} from "./chunk-GZ2P4SCJ.js";
import {
  s as s2
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  L,
  has
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/PipelineCommand.js
var e9 = class _e {
  constructor(e14, n13, t5) {
    this.renderCommandContext = e14, this.renderCommandBuffer = n13, this.pipelineStateCommands = t5;
  }
  append(e14) {
    this.appendRenderCommands(e14.renderCommandBuffer), this.appendPipelineStateCommands(e14.pipelineStateCommands);
  }
  appendRenderCommands(e14) {
    this.renderCommandBuffer.commands.push(...e14.commands), this.renderCommandBuffer.transferList.push(...e14.transferList);
  }
  appendPipelineStateCommand(e14) {
    this.pipelineStateCommands.push(e14);
  }
  appendPipelineStateCommands(e14) {
    for (const n13 of e14) this.appendPipelineStateCommand(n13);
  }
  async execute() {
    for (const e14 of this.pipelineStateCommands) e14();
    await this.renderCommandContext.dispatchRenderCommands(this.renderCommandBuffer);
  }
  static create(n13, t5 = []) {
    return new _e(n13, n13.createRenderCommandBuffer(), t5);
  }
};
function n8(e14) {
  if (0 === e14.length) return null;
  return e14.reduce((e15, n13) => (e15.append(n13), e15));
}

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/symbolization/factoryUtils.js
function t4() {
  return new f4({ material: new m3({ color: new l2("red") }) });
}
function n9() {
  return new n6();
}

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/featureData/processingUtils.js
function n10(r5) {
  const { featureCount: e14 } = r5;
  if (0 === e14) return new Uint32Array();
  const t5 = new Uint32Array(e14);
  return r5.getObjectIdsArray(t5), t5;
}
function a6(r5) {
  const { featureCount: e14 } = r5;
  if (0 === e14) return new Float64Array();
  const t5 = new Float64Array(3 * e14);
  return r5.getCoordinatesArray(t5), t5;
}
function c4(r5, t5) {
  const o9 = r5.length / 3, n13 = t5.viewSpatialReference, a10 = t5.renderSpatialReference, i3 = new Float64Array(3 * o9);
  if (!o3(r5, n13, 0, i3, a10, 0, o9)) throw new Error("Failed to project coordinates");
  return i3;
}
function f5(e14, n13) {
  const a10 = n13.viewSpatialReference, i3 = n13.renderSpatialReference, { extent: c9 } = e14, f8 = p(c9), u6 = n4();
  return n7([f8[0], f8[1], 0], a10, u6, i3), u6;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/symbolization/symbolizationUtils.js
function e10(e14) {
  const n13 = /* @__PURE__ */ new Map();
  for (const [t5, r5] of e14) n13.set(t5, { ...r5, indices: e5(r5.indices) });
  return n13;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/symbolization/IconSymbolLayerRenderer.js
var f6 = class {
  constructor(e14, t5) {
    this._context = null, this._symbolLayer = null, this._draped = false, this._loaded = false, this._loadingPromise = null, this._iconTextureID = null, this._materialId = null, this._context = t5, this._symbolLayer = e14;
  }
  get loaded() {
    return this._loaded;
  }
  load() {
    return null == this._loadingPromise && (this._loadingPromise = this._load()), this._loadingPromise;
  }
  _destroy() {
    this._iconTextureID = null;
  }
  async _load() {
    const e14 = this._context.renderCommandContext, t5 = await e14.createTexture(() => i("circle"));
    this._iconTextureID = t5;
    const r5 = { anchorPosition: s9.center, occlusionTest: true, hasSlicePlane: false, color: this._getFillColor(), outlineColor: this._getOutlineColor(), outlineSize: 1, distanceFieldBoundingBox: s10, textureId: t5, textureIsSignedDistanceField: true, sampleSignedDistanceFieldTexelCenter: c3("circle") };
    this._materialId = await e14.createMaterial({ type: "hud", parameters: r5 }), await e14.createDirectRenderer(this._materialId), this._loaded = true;
  }
  async createAddCommand(e14) {
    const { _materialId: t5, _context: r5 } = this, { renderCommandContext: i3 } = r5;
    if (null == t5) throw new Error("expected material not to be null");
    const n13 = await this._createGeometry(e14);
    if (null == n13) return r5.createPipelineCommand();
    const o9 = f5(e14, r5);
    return r5.createPipelineCommand(i3.addDirectRendererGeometry(e14.id, n13, o9));
  }
  async _createGeometry(e14) {
    const { _materialId: r5, _context: i3 } = this, { mainThreadDelegate: n13 } = i3, { featureCount: o9 } = e14;
    if (0 === o9 || null == r5) return null;
    const a10 = n10(e14), l7 = a6(e14), s15 = await n13.applyElevationAlignmentTo(l7), y = c4(s15, i3), p5 = new Float64Array([0, 0, 1]), _3 = new Float64Array([255, 255, 255, 255]), f8 = new Float64Array([24, 24]), g5 = new Float64Array([0, 0, 0, 1]), x2 = new Float64Array([0, 0]), b5 = new Float64Array([0]), w4 = new Uint32Array(o9);
    for (let t5 = 0; t5 < o9; ++t5) w4[t5] = t5;
    const I3 = new Uint32Array(o9);
    for (let t5 = 0; t5 < o9; ++t5) I3[t5] = 0;
    const P2 = new t3(y, w4, 3, true), A2 = new t3(p5, I3, 3, true), O2 = new t3(x2, I3, 2, true), D = new t3(_3, I3, 4, true), T3 = new t3(b5, I3, 1, true), j5 = new t3(f8, I3, 2, true), F = new t3(g5, I3, 4, true), U2 = [[e7.POSITION, P2], [e7.NORMAL, A2], [e7.UV0, O2], [e7.COLOR, D], [e7.ROTATION, T3], [e7.SIZE, j5], [e7.CENTEROFFSETANDDISTANCE, F]], v2 = new Uint8Array(o9);
    e14.getVisibilityArray(v2);
    return { attributes: e10(U2), objectAndLayerIdColor: void 0, transformation: e4(), materialId: r5, objectIds: a10, visibilities: v2 };
  }
  async createRemoveCommand(e14) {
    const { _materialId: t5, _context: r5 } = this, i3 = r5.renderCommandContext;
    return null == t5 ? r5.createPipelineCommand() : r5.createPipelineCommand(i3.removeDirectRendererGeometryBuffer(t5, e14));
  }
  async createUpdateVisibilityCommand(e14) {
    const { _materialId: t5, _context: r5 } = this, i3 = r5.renderCommandContext;
    if (null == t5) return r5.createPipelineCommand();
    const n13 = new Uint8Array(e14.featureCount);
    return e14.getVisibilityArray(n13), r5.createPipelineCommand(i3.updateVisibility(t5, e14.id, n13));
  }
  async createUpdateLayerViewOpacityCommand(e14) {
    const { _context: t5, _materialId: r5 } = this, i3 = t5.renderCommandContext;
    return null == r5 ? t5.createPipelineCommand() : t5.createPipelineCommand(i3.updateMaterial({ type: "hud", materialId: r5, parameters: { color: this._getFillColor(), outlineColor: this._getOutlineColor() } }));
  }
  async createUpdateElevationCommand(e14) {
    const { _materialId: t5, _context: r5 } = this, { renderCommandContext: i3 } = r5, { featureCount: n13, id: o9 } = e14;
    if (null == t5 || 0 === n13) return r5.createPipelineCommand();
    const a10 = await this._createGeometry(e14);
    if (null == a10) return r5.createPipelineCommand();
    const l7 = f5(e14, r5);
    return r5.createPipelineCommand(i3.updateDirectRendererGeometry(o9, a10, l7));
  }
  async createDestroyCommand() {
    const { _iconTextureID: e14, _context: t5 } = this, r5 = t5.renderCommandContext;
    let i3;
    return i3 = null != e14 ? await r5.releaseTexture(e14) : e9.create(r5), i3.appendPipelineStateCommand(() => this._destroy()), i3;
  }
  _getOutlineColor() {
    const t5 = this._getLayerOpacity(), r5 = this._symbolLayer, i3 = r5?.outline?.color;
    if (null != i3) {
      const r6 = l2.toUnitRGB(i3), n13 = i3.a * t5;
      return [r6[0], r6[1], r6[2], n13];
    }
    return [0, 0, 0, 0];
  }
  _getFillColor() {
    if (g(this._getPrimitive())) return w;
    const e14 = null == this._getPrimitive(), t5 = this._symbolLayer?.material?.color;
    return this._getCombinedOpacityAndColor(t5, { hasIntrinsicColor: e14 });
  }
  _getLayerOpacity() {
    return this._context.layerViewInfo.fullOpacity;
  }
  _getCombinedOpacity(e14, t5 = b3) {
    const r5 = this._draped ? 1 : this._getLayerOpacity();
    return e14 ? r5 * e14.a : t5.hasIntrinsicColor ? r5 : 0;
  }
  _getCombinedOpacityAndColor(t5, i3 = b3) {
    const n13 = this._getCombinedOpacity(t5, i3), a10 = null != t5 ? l2.toUnitRGB(t5) : _;
    return U(a10, n13);
  }
  _getPrimitive() {
    return x(this._symbolLayer);
  }
};
function g(e14) {
  return null != e14 && ("cross" === e14 || "x" === e14);
}
function x(e14) {
  return e14.resource?.href ? null : e14.resource?.primitive ?? j2;
}
var b3 = { hasIntrinsicColor: false };
var w = a4;

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/symbolization/Point3DSymbolRenderer.js
var e11 = class {
  constructor(e14, o9) {
    this._loaded = false, this._loadingPromise = null, this._context = null, this._symbol = null, this._symbolLayerRenderers = [], this._context = o9, this._symbol = e14;
  }
  _destroy() {
  }
  get loaded() {
    return this._loaded;
  }
  load() {
    return null == this._loadingPromise && (this._loadingPromise = this._load()), this._loadingPromise;
  }
  async _load() {
    const { _context: e14, _symbol: o9, _symbolLayerRenderers: t5 } = this, s15 = [];
    for (const a10 of o9.symbolLayers) {
      const o10 = e14.symbolRendererFactory.createSymbolRendererFromSymbolLayer(a10);
      null != o10 && (s15.push(o10.load()), t5.push(o10));
    }
    await Promise.all(s15), this._loaded = true;
  }
  async createDestroyCommand() {
    const { _context: e14, _symbolLayerRenderers: o9 } = this, t5 = [];
    for (const a10 of o9) t5.push(a10.createDestroyCommand());
    const s15 = e14.joinPipelineCommands(await Promise.all(t5));
    return s15.appendPipelineStateCommand(() => this._destroy()), s15;
  }
  async createAddCommand(e14) {
    const { _context: o9, _symbolLayerRenderers: t5 } = this, s15 = [];
    for (const a10 of t5) s15.push(a10.createAddCommand(e14));
    return o9.joinPipelineCommands(await Promise.all(s15));
  }
  async createRemoveCommand(e14) {
    const { _context: o9, _symbolLayerRenderers: t5 } = this, s15 = [];
    for (const a10 of t5) s15.push(a10.createRemoveCommand(e14));
    return o9.joinPipelineCommands(await Promise.all(s15));
  }
  async createUpdateVisibilityCommand(e14) {
    const { _context: o9, _symbolLayerRenderers: t5 } = this, s15 = [];
    for (const a10 of t5) s15.push(a10.createUpdateVisibilityCommand(e14));
    return o9.joinPipelineCommands(await Promise.all(s15));
  }
  async createUpdateLayerViewOpacityCommand(e14) {
    const { _context: o9, _symbolLayerRenderers: t5 } = this, s15 = [];
    for (const a10 of t5) s15.push(a10.createUpdateLayerViewOpacityCommand(e14));
    return o9.joinPipelineCommands(await Promise.all(s15));
  }
  async createUpdateElevationCommand(e14) {
    const { _context: o9, _symbolLayerRenderers: t5 } = this, s15 = [];
    for (const a10 of t5) s15.push(a10.createUpdateElevationCommand(e14));
    return o9.joinPipelineCommands(await Promise.all(s15));
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/symbolization/SimpleFeatureRenderer.js
var e12 = class {
  constructor(e14, t5) {
    this._symbol = null, this._featureData = /* @__PURE__ */ new Map(), this._loaded = false, this._loadingPromise = null, this._renderer = null, this._context = t5, this._renderer = e14;
  }
  async load() {
    return null == this._loadingPromise && (this._loadingPromise = this._load()), this._loadingPromise;
  }
  async _load() {
    const { _renderer: e14, _context: t5 } = this;
    this._symbol = t5.symbolRendererFactory.createSymbolRendererFromSymbol(e14.symbol), this._loaded = true;
  }
  get loaded() {
    return this._loaded;
  }
  async createAddCommand(e14) {
    const t5 = this._context, a10 = await this._provisionSymbol(), n13 = null == a10 ? t5.createPipelineCommand() : await a10.createAddCommand(e14);
    return n13.appendPipelineStateCommand(() => this._featureData.set(e14.id, e14)), n13;
  }
  async createRemoveCommand(e14) {
    const t5 = this._context, a10 = await this._provisionSymbol(), n13 = null == a10 ? t5.createPipelineCommand() : await a10.createRemoveCommand(e14);
    return n13.appendPipelineStateCommand(() => this._featureData.delete(e14)), n13;
  }
  async createUpdateVisibilityCommand(e14) {
    const t5 = this._context, a10 = await this._provisionSymbol();
    return null == a10 ? t5.createPipelineCommand() : await a10.createUpdateVisibilityCommand(e14);
  }
  async createUpdateLayerViewOpacityCommand(e14) {
    const t5 = this._context, a10 = await this._provisionSymbol();
    return null == a10 ? t5.createPipelineCommand() : await a10.createUpdateLayerViewOpacityCommand(e14);
  }
  async createUpdateElevationCommand() {
    const { _featureData: e14, _context: t5 } = this, a10 = await this._provisionSymbol();
    if (null == a10) return t5.createPipelineCommand();
    const n13 = [];
    for (const i3 of e14.values()) n13.push(a10.createUpdateElevationCommand(i3));
    const o9 = await Promise.all(n13);
    return t5.joinPipelineCommands(o9);
  }
  async createDestroyCommand() {
    const { _symbol: e14, _context: t5, _featureData: a10 } = this;
    if (!e14) return t5.createPipelineCommand();
    const n13 = [];
    for (const i3 of a10.keys()) n13.push(this.createRemoveCommand(i3));
    n13.push(e14.createDestroyCommand());
    const o9 = await Promise.all(n13);
    return t5.joinPipelineCommands(o9);
  }
  async _provisionSymbol() {
    const e14 = this._symbol;
    return e14 ? (e14.loaded || await e14.load(), e14) : null;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/symbolization/primitiveObjectUtils.js
function s11(t5, a10) {
  const s15 = (t6, n13, i3 = false) => ({ levels: t6.map((t7) => {
    const s16 = e10(n13(t7.tesselation));
    i3 && r2(s16);
    return { components: [{ attributes: s16, objectAndLayerIdColor: void 0, transformation: null, materialId: a10, visibilities: new Uint8Array([1]), objectIds: new Uint32Array([-1]) }], minScreenSpaceRadius: t7.minScreenSpaceRadius };
  }) });
  switch (t5) {
    case "cone":
      return s15(c5, (e14) => ct(1, 0.5, e14, false), true);
    case "sphere":
      return s15([{ tesselation: 0, minScreenSpaceRadius: 0 }, { tesselation: 1, minScreenSpaceRadius: 8 }, { tesselation: 2, minScreenSpaceRadius: 16 }, { tesselation: 3, minScreenSpaceRadius: 50 }, { tesselation: 4, minScreenSpaceRadius: 250 }], (e14) => rt(0.5, e14, true));
    case "cube":
    case "inverted-cone":
    case "cylinder":
    case "tetrahedron":
    case "diamond":
      throw new Error("not implemented");
    default:
      return;
  }
}
function r2(e14) {
  const t5 = e14, n13 = t5.get(e7.POSITION).data, i3 = t5.get(e7.NORMAL).data;
  if (i3) {
    const t6 = o8(e14, e7.NORMAL).data;
    for (let e15 = 0; e15 < i3.length; e15 += 3) {
      const n14 = i3[e15 + 1];
      t6[e15 + 1] = -i3[e15 + 2], t6[e15 + 2] = n14;
    }
  }
  if (n13) {
    const t6 = o8(e14, e7.POSITION).data;
    for (let e15 = 0; e15 < n13.length; e15 += 3) {
      const i4 = n13[e15 + 1];
      t6[e15 + 1] = -n13[e15 + 2], t6[e15 + 2] = i4;
    }
  }
}
function o8(e14, n13) {
  let i3 = e14.get(n13);
  return i3 && !i3.exclusive && (i3 = { ...i3, exclusive: true, data: e8(i3.data) }, e14.set(n13, i3)), i3;
}
var c5 = [{ tesselation: 6, minScreenSpaceRadius: 0 }, { tesselation: 18, minScreenSpaceRadius: 7 }, { tesselation: 64, minScreenSpaceRadius: 65 }];

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/symbolization/ObjectSymbolLayerRenderer.js
var w2 = class {
  constructor(e14, t5) {
    this._loaded = false, this._loadingPromise = null, this._primitiveMaterialId = null, this._lodRendererId = null, this._context = null, this._symbolLayer = null, this._primitive = null, this._context = t5, this._symbolLayer = e14;
  }
  _destroy() {
    this._lodRendererId = null, this._primitiveMaterialId = null;
  }
  get loaded() {
    return this._loaded;
  }
  get _isPrimitive() {
    return null != this._primitive;
  }
  load() {
    return null == this._loadingPromise && (this._loadingPromise = this._load()), this._loadingPromise;
  }
  async _load() {
    const e14 = this._context.renderCommandContext, t5 = { physicalBasedRenderingEnabled: true, slicePlaneEnabled: false, castShadows: true }, r5 = this._getLayerOpacity();
    let a10 = { usePBR: t5.physicalBasedRenderingEnabled, isSchematic: true, mrrFactors: o7, ambient: _, diffuse: _, hasSlicePlane: t5.slicePlaneEnabled, castShadows: t5.castShadows, layerOpacity: r5, offsetTransparentBackfaces: false, screenSizePerspective: {} };
    if (a10.externalColor = s7, a10.isInstanced = true, this._isPrimitive) {
      const e15 = new H();
      e15.layerOpacity = r5, a10 = { ...a10, cullFace: P(Q2(e15)) };
    }
    const n13 = await e14.createMaterial({ type: "default", parameters: a10 }), s15 = this._symbolLayer.resource;
    this._primitive = s15 && S(s15?.primitive) ? s15.primitive : d2;
    const l7 = s11(this._primitive, n13);
    this._lodRendererId = await e14.createLodRenderer(l7), this._primitiveMaterialId = n13, this._loaded = true;
  }
  async createDestroyCommand() {
    const { _lodRendererId: e14, _primitiveMaterialId: t5, _context: r5 } = this, i3 = r5.renderCommandContext, a10 = [];
    return null != e14 && a10.push(i3.destroyLodRenderer(e14)), null != t5 && a10.push(i3.destroyMaterial(t5)), new e9(i3, i3.mergeRenderCommandBuffers(a10), [() => this._destroy()]);
  }
  async createAddCommand(e14) {
    const t5 = this._context, { renderCommandContext: r5, mainThreadDelegate: i3 } = t5;
    if (null == this._lodRendererId) throw new Error("expected lod renderer id to not be null");
    const { featureCount: n13 } = e14;
    if (0 === n13) return t5.createPipelineCommand();
    const o9 = this._isPrimitive, s15 = this._primitive || d2, u6 = u2(c2(s15)), h6 = u3(p2(u6)), y = u3(t2(h6, { isPrimitive: o9, width: 100, depth: null, height: null })), b5 = new Float64Array(16 * n13), C = new Float64Array(16 * n13), g5 = a6(e14), x2 = await i3.applyElevationAlignmentTo(g5);
    for (let a10 = 0; a10 < n13; ++a10) {
      const e15 = a10, t6 = x2[3 * a10 + 0], r6 = x2[3 * a10 + 1], i4 = x2[3 * a10 + 2], n14 = this._computeGlobalTransform(t6, r6, i4, this._context.viewSpatialReference, T), o10 = this._computeLocalTransform(y, h6, j3);
      this._writeMatrixToTypedBuffer(b5, e15, o10), this._writeMatrixToTypedBuffer(C, e15, n14);
    }
    const v2 = n10(e14), w4 = new Uint8Array(n13);
    e14.getVisibilityArray(w4);
    const P2 = { featureIds: new Uint32Array(v2), visibility: w4, localTransforms: b5, globalTransforms: C };
    return t5.createPipelineCommand(r5.addLodInstances(this._lodRendererId, e14.id, P2));
  }
  async createRemoveCommand(e14) {
    const { _context: t5, _lodRendererId: r5 } = this, i3 = t5.renderCommandContext;
    return null == r5 ? t5.createPipelineCommand() : t5.createPipelineCommand(i3.removeLodInstances(r5, e14));
  }
  async createUpdateVisibilityCommand(e14) {
    const { _lodRendererId: t5, _context: r5 } = this, i3 = r5.renderCommandContext;
    if (null == t5) return r5.createPipelineCommand();
    const a10 = new Uint8Array(e14.featureCount);
    return e14.getVisibilityArray(a10), r5.createPipelineCommand(i3.updateVisibility(t5, e14.id, a10));
  }
  async createUpdateLayerViewOpacityCommand(e14) {
    const { _context: t5 } = this, r5 = t5.renderCommandContext, i3 = this._primitiveMaterialId;
    if (null == i3) return t5.createPipelineCommand();
    const a10 = this._getLayerOpacity();
    let n13 = { layerOpacity: a10 };
    if (this._isPrimitive) {
      const e15 = new H();
      e15.layerOpacity = a10, n13 = { ...n13, cullFace: P(Q2(e15)) };
    }
    return t5.createPipelineCommand(r5.updateMaterial({ type: "default", materialId: i3, parameters: n13 }));
  }
  async createUpdateElevationCommand(e14) {
    const { _context: t5, _lodRendererId: r5 } = this, { renderCommandContext: i3, mainThreadDelegate: a10 } = t5, { featureCount: n13, id: o9 } = e14;
    if (null == r5 || 0 === n13) return t5.createPipelineCommand();
    const s15 = new Float64Array(16 * n13), l7 = a6(e14), m9 = await a10.applyElevationAlignmentTo(l7);
    for (let d4 = 0; d4 < n13; ++d4) {
      const e15 = d4, t6 = m9[3 * d4 + 0], r6 = m9[3 * d4 + 1], i4 = m9[3 * d4 + 2], a11 = this._computeGlobalTransform(t6, r6, i4, this._context.viewSpatialReference, T);
      this._writeMatrixToTypedBuffer(s15, e15, a11);
    }
    return t5.createPipelineCommand(i3.updateLodInstancesData(r5, o9, s15));
  }
  _writeMatrixToTypedBuffer(e14, t5, r5) {
    let i3 = 16 * t5;
    for (let a10 = 0; a10 < 16; a10++) e14[i3++] = r5[a10];
  }
  _computeGlobalTransform(e14, t5, r5, i3, a10) {
    return I[0] = e14, I[1] = t5, I[2] = r5, m5(i3, I, a10, this._context.renderSpatialReference), a10;
  }
  _computeLocalTransform(t5, r5, i3) {
    return o4(i3), this._applyObjectScale(t5, r5, i3), i3;
  }
  _applyObjectScale(e14, r5, i3) {
    const a10 = B(e14, e14, r5, this._context.renderCoordsHelper.unitInMeters);
    1 === a10[0] && 1 === a10[1] && 1 === a10[2] || f3(i3, i3, a10);
  }
  _getLayerOpacity() {
    return this._context.layerViewInfo.fullOpacity;
  }
};
function P(e14) {
  return e14 ? e6.None : e6.Back;
}
var I = n4();
var j3 = e4();
var T = e4();

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/symbolization/UniqueValueFeatureRenderer.js
var s12 = class {
  constructor(t5, e14) {
    this._symbols = new Array(), this._featureDataPartitioning = /* @__PURE__ */ new Map(), this._loaded = false, this._loadingPromise = null, this._renderer = null, this._context = e14, this._renderer = t5;
  }
  async load() {
    return null == this._loadingPromise && (this._loadingPromise = this._load()), this._loadingPromise;
  }
  async _load() {
    this._symbols[0] = new f6(t4(), this._context), this._symbols[1] = new w2(n9(), this._context), this._loaded = true;
  }
  get loaded() {
    return this._loaded;
  }
  async createAddCommand(t5) {
    const e14 = this._context, n13 = this._partition(t5), a10 = await Promise.all(n13.map(async ({ index: t6, features: e15 }) => {
      const n14 = await this._provisionSymbol(t6);
      return await n14?.createAddCommand(e15);
    })), o9 = e14.joinPipelineCommands(a10);
    return o9.appendPipelineStateCommand(() => this._featureDataPartitioning.set(t5.id, n13)), o9;
  }
  async createRemoveCommand(e14) {
    const { _featureDataPartitioning: n13, _context: a10 } = this, o9 = a10.renderCommandContext, i3 = n13.get(e14);
    if (null == i3) return new e9(o9, o9.createRenderCommandBuffer(), []);
    const s15 = await Promise.all(i3.map(async ({ index: t5, features: e15 }) => {
      const n14 = this._getLoadedSymbol(t5);
      return await n14?.createRemoveCommand(e15.id);
    })), r5 = a10.joinPipelineCommands(s15);
    return r5.appendPipelineStateCommand(() => n13.delete(e14)), r5;
  }
  async createUpdateVisibilityCommand(e14) {
    const { _featureDataPartitioning: n13, _context: a10 } = this, o9 = a10.renderCommandContext, i3 = n13.get(e14.id);
    if (null == i3) return new e9(o9, o9.createRenderCommandBuffer(), []);
    const s15 = await Promise.all(i3.map(async ({ index: t5, features: e15 }) => {
      const n14 = this._getLoadedSymbol(t5);
      return await n14?.createUpdateVisibilityCommand(e15);
    }));
    return a10.joinPipelineCommands(s15);
  }
  async createUpdateLayerViewOpacityCommand(t5) {
    const e14 = this._context, n13 = [];
    for (let o9 = 0; o9 < this._symbols.length; ++o9) {
      const e15 = this._symbols[o9];
      null != e15 && e15.loaded && n13.push(e15.createUpdateLayerViewOpacityCommand(t5));
    }
    const a10 = await Promise.all(n13);
    return e14.joinPipelineCommands(a10);
  }
  async createUpdateElevationCommand() {
    const { _featureDataPartitioning: t5, _context: e14 } = this, n13 = [];
    for (const o9 of t5.values()) {
      const t6 = o9.map(async ({ index: t7, features: e15 }) => {
        const n14 = this._getLoadedSymbol(t7);
        return await n14?.createUpdateElevationCommand(e15);
      });
      n13.push(...t6);
    }
    const a10 = await Promise.all(n13);
    return e14.joinPipelineCommands(a10);
  }
  async createDestroyCommand() {
    const { _featureDataPartitioning: t5, _context: e14 } = this, n13 = [];
    for (const o9 of t5.keys()) n13.push(this.createRemoveCommand(o9));
    for (const o9 of this._symbols) n13.push(o9.createDestroyCommand());
    const a10 = await Promise.all(n13);
    return e14.joinPipelineCommands(a10);
  }
  async _provisionSymbol(t5) {
    if (null == t5) return null;
    const e14 = this._symbols[t5];
    return e14 ? (e14.loaded || await e14.load(), e14) : null;
  }
  _getLoadedSymbol(t5) {
    if (null == t5) return null;
    const e14 = this._symbols[t5];
    return null != e14 && e14.loaded ? e14 : null;
  }
  _partition(t5) {
    const n13 = n10(t5);
    if (null == n13) throw new Error("unable to fetch objectIds");
    const { featureCount: a10 } = t5, o9 = [[], []];
    for (let e14 = 0; e14 < a10; ++e14) {
      o9[n13[e14] % 2].push(e14);
    }
    return o9.map((e14, n14) => new r3(n14, t5.subset(new Uint32Array(e14)))).filter((t6) => t6.features.featureCount > 0);
  }
};
var r3 = class {
  constructor(t5, e14) {
    this.index = t5, this.features = e14;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/FeatureProcessingContext.js
var a7 = class {
  constructor(e14, r5, t5, o9, n13, i3, s15) {
    this.viewSpatialReference = e14, this.renderSpatialReference = r5, this.mainThreadDelegate = t5, this.renderCoordsHelper = o9, this.renderCommandContext = n13, this.layerInfo = i3, this.layerViewInfo = s15, this.symbolRendererFactory = new m6(this);
  }
  createPipelineCommand(e14 = this.renderCommandContext.createRenderCommandBuffer(), t5 = []) {
    return new e9(this.renderCommandContext, e14, t5);
  }
  joinPipelineCommands(e14) {
    if (0 === e14.length) return this.createPipelineCommand();
    return e14.filter((e15) => null != e15).reduce((e15, r5) => (e15.append(r5), e15));
  }
};
var m6 = class {
  constructor(e14) {
    this.context = e14;
  }
  createSymbolRendererFromJSON(r5) {
    const t5 = o5(r5 ?? l4) ?? void 0;
    if (!t5) throw new Error("Failed to create renderer");
    const o9 = t5.type;
    switch (o9) {
      case "simple":
        return new e12(t5, this.context);
      case "unique-value":
        return new s12(t5, this.context);
      default:
        return console.warn(`Unable to create symbolrenderer for renderer of ${o9}`), this.createSymbolRendererFromJSON(l4);
    }
  }
  createSymbolRendererFromSymbol(e14) {
    const r5 = e14?.type;
    switch (r5) {
      case "point-3d":
        return new e11(e14, this.context);
      case "picture-marker":
      case "simple-marker":
        return new f6(t4(), this.context);
      default:
        return console.warn(`Unable to create symbolrenderer for symbol of ${r5}`), null;
    }
  }
  createSymbolRendererFromSymbolLayer(e14) {
    const r5 = e14.type;
    return "icon" === r5 ? new f6(e14, this.context) : (console.warn(`Unable to create symbolrenderer for symbolLayer of ${r5}`), null);
  }
};
var l4 = { type: "simple" };

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/utils.js
function r4(t5 = "") {
  return `${t5}${e2()}`;
}
var c6 = new Float64Array(3);

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/featureData/FeatureDataSubset.js
var s13 = class _s {
  constructor(t5, s15) {
    this._parent = t5, this._subsetIndices = s15, this.id = r4(`featureDataSubset-${t5.id}-`);
  }
  get tileId() {
    return this._parent.tileId;
  }
  get extent() {
    return this._parent.extent;
  }
  get featureCount() {
    return this._subsetIndices.length;
  }
  get usedMemory() {
    return this._parent.usedMemory + s5 + this._subsetIndices.byteLength;
  }
  get isFullyEnabled() {
    for (const t5 of this._subsetIndices) if (!this._parent.getEnabled(t5)) return false;
    return true;
  }
  getObjectId(t5) {
    return this._parent.getObjectId(this._subsetIndices[t5]);
  }
  getAttribute(t5, e14) {
    return this._parent.getAttribute(this._subsetIndices[t5], e14);
  }
  getAttributeAsTimestamp(t5, e14) {
    return this._parent.getAttribute(this._subsetIndices[t5], e14);
  }
  getAttributes(t5) {
    return this._parent.getAttributes(this._subsetIndices[t5]);
  }
  getCoordinates(t5, e14, s15) {
    return this._parent.getCoordinates(this._subsetIndices[t5], e14, s15);
  }
  getOptimizedGeometry(t5) {
    return this._parent.getOptimizedGeometry(this._subsetIndices[t5]);
  }
  getCentroid(t5, e14) {
    return this._parent.getCentroid(this._subsetIndices[t5], e14);
  }
  getBounds(t5) {
    return this._parent.getBounds(this._subsetIndices[t5]);
  }
  getBoundingBox(t5) {
    return this._parent.getBoundingBox(this._subsetIndices[t5]);
  }
  getObjectIdsArray(t5, e14, s15) {
    return this._parent.getObjectIdsArray(t5, this._translatedIndices(e14), s15);
  }
  getCoordinatesArray(t5, e14, s15) {
    return this._parent.getCoordinatesArray(t5, this._translatedIndices(e14), s15);
  }
  objectIds(t5) {
    return this._parent.objectIds(this._translatedIndices(t5));
  }
  subset(t5) {
    const { _subsetIndices: e14 } = this, r5 = new Uint32Array(t5.length);
    for (let s15 = 0; s15 < r5.length; ++s15) r5[s15] = e14[t5[s15]];
    return new _s(this._parent, r5);
  }
  disableObjectIds(t5) {
    if (0 === t5.size) return;
    const { featureCount: e14 } = this, s15 = new Array();
    for (let r5 = 0; r5 < e14; ++r5) this.getEnabled(r5) && t5.has(this.getObjectId(r5)) && s15.push(r5);
    if (0 !== s15.length) for (const r5 of s15) this.setEnabled(r5, false);
  }
  setEnabled(t5, e14) {
    this._parent.setEnabled(this._subsetIndices[t5], e14);
  }
  getEnabled(t5) {
    return this._parent.getEnabled(this._subsetIndices[t5]);
  }
  enableAll() {
    const { _subsetIndices: t5, _parent: e14 } = this;
    for (const s15 of t5) e14.setEnabled(s15, true);
  }
  getVisibilityArray(t5, e14, s15) {
    return this._parent.getVisibilityArray(t5, this._translatedIndices(e14), s15);
  }
  enabledObjectIds(t5) {
    return this._parent.enabledObjectIds(this._translatedIndices(t5));
  }
  *_translatedIndices(t5) {
    const { _subsetIndices: e14 } = this;
    if (null != t5) for (const s15 of t5) yield e14[s15];
    else yield* e14;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/featureData/FeatureData.js
var s14 = class {
  constructor(t5) {
    this._tile = t5, this.id = r4(`featureData-${t5.id}-`), this._enabled = new Array(t5.featureCount).fill(true);
  }
  get tileId() {
    return this._tile.id;
  }
  get featureCount() {
    return this._tile.featureCount;
  }
  get usedMemory() {
    return s5 + t(this.id);
  }
  get extent() {
    return this._tile.descriptor.extent;
  }
  get isFullyEnabled() {
    return this._enabled.every((t5) => t5);
  }
  getObjectId(t5) {
    return this._tile.getObjectId(t5);
  }
  getAttribute(t5, e14) {
    return this._tile.getAttribute(t5, e14);
  }
  getAttributeAsTimestamp(t5, e14) {
    return this._tile.getAttribute(t5, e14);
  }
  getAttributes(t5) {
    return this._tile.getAttributes(t5);
  }
  getCoordinates(t5, e14, r5) {
    return this._tile.getCoordinates(t5, e14, r5);
  }
  getOptimizedGeometry(t5) {
    return this._tile.getOptimizedGeometry(t5);
  }
  getCentroid(t5, e14) {
    return this._tile.getCentroid(t5, e14);
  }
  getBounds(t5) {
    return this._tile.getBounds(t5);
  }
  getBoundingBox(t5) {
    return this._tile.getBoundingBox(t5);
  }
  getObjectIdsArray(t5, e14, r5) {
    return this._tile.getObjectIdsArray(t5, e14, r5);
  }
  getCoordinatesArray(t5, e14, r5) {
    return this._tile.getCoordinatesArray(t5, e14, r5);
  }
  objectIds(t5) {
    return this._tile.objectIds(t5);
  }
  subset(t5) {
    return new s13(this, t5);
  }
  disableObjectIds(t5) {
    if (0 === t5.size) return;
    const { _enabled: e14 } = this, r5 = new Array();
    for (const i3 of this._allFeatureIndices()) e14[i3] && t5.has(this.getObjectId(i3)) && r5.push(i3);
    if (0 !== r5.length) for (const i3 of r5) e14[i3] = false;
  }
  setEnabled(t5, e14) {
    this._enabled[t5] = e14;
  }
  getEnabled(t5) {
    return this._enabled[t5];
  }
  enableAll() {
    this._enabled.fill(true);
  }
  getVisibilityArray(t5, e14 = this._allFeatureIndices(), r5 = 0) {
    const { _enabled: i3 } = this;
    for (const s15 of e14) t5[r5++] = Number(i3[s15]);
    return r5;
  }
  *enabledObjectIds(t5 = this._allFeatureIndices()) {
    const { _enabled: e14 } = this;
    for (const r5 of t5) e14[r5] && (yield this.getObjectId(r5));
  }
  *_allFeatureIndices() {
    const { featureCount: t5 } = this;
    for (let e14 = 0; e14 < t5; ++e14) yield e14;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/Tile3DManager.js
var _2 = class extends b {
  constructor(t5) {
    super(t5), this.extent = null, this._tileHandles = new s4(), this._wanted = new s4(), this._updateRequested = false, this._synchronizationTask = null, this._requestedTiles = new Array();
  }
  destroy() {
    this._tileHandles.clear(), this._wanted.clear();
  }
  get updating() {
    return this._updateRequested || !(this._synchronizationTask?.finished ?? 1);
  }
  get _boundingRect() {
    const { extent: t5 } = this;
    return null == t5 ? null : o2(t5);
  }
  get _missingTiles() {
    const t5 = new Array(), e14 = this._wanted, s15 = this._tileHandles;
    for (const o9 of e14.values()) null == s15.get(o9.id)?.featureData && t5.push(o9);
    return t5;
  }
  onTileTreeChange({ tiles: t5 }) {
    this._requestedTiles = t5, this._scheduleTilesSync();
  }
  _scheduleTilesSync() {
    if (this._updateRequested) return;
    this._updateRequested = true;
    const t5 = this._synchronizationTask, e14 = d(async () => {
      try {
        await j(() => t5?.finished ?? true), await M(), this._updateRequested = false, await this._synchronizeTiles();
      } finally {
        this._synchronizationTask === e14 && (this._synchronizationTask = null);
      }
    });
    this._synchronizationTask = e14;
  }
  async _synchronizeTiles() {
    const t5 = this._requestedTiles, e14 = this._tileHandles, s15 = new Array();
    for (const u6 of t5) e14.has(u6.id) || s15.push(u6);
    const o9 = new Array();
    for (const u6 of e14.values()) {
      const { id: e15 } = u6;
      t5.every((t6) => t6.id !== e15) && o9.push(u6.descriptor);
    }
    const a10 = this._tileHandles, { _boundingRect: i3 } = this, r5 = null != i3 ? s15.filter((t6) => R(i3, t6.extent)) : s15, n13 = this._wanted, l7 = new Array();
    for (const { id: u6 } of o9) n13.delete(u6);
    for (const u6 of r5) n13.set(u6.id, u6);
    const c9 = this._missingTiles;
    for (const u6 of o9) {
      const { id: t6 } = u6;
      if (c9.some((t7) => w3(t7, u6) || w3(u6, t7))) continue;
      const e15 = a10.get(t6);
      null != e15 && l7.push(this._removeTile(e15));
    }
    for (const u6 of r5) l7.push(this._addTile(u6));
    const d4 = await Promise.allSettled(l7);
    for (const u6 of d4) "rejected" === u6.status && console.error(u6.reason);
  }
  forEachTile(t5) {
    for (const e14 of this._tileHandles.values()) {
      const s15 = e14.featureData;
      null != s15 && t5(s15);
    }
  }
  *loadedTiles() {
    for (const t5 of this._tileHandles.values()) {
      const e14 = t5.featureData;
      null != e14 && (yield e14);
    }
  }
  async _removeTile(s15) {
    s15.loadTask.abort(), this._tileHandles.delete(s15.id), this._validate();
    const { featureData: o9 } = s15;
    if (null != o9) {
      const s16 = { stack: [], error: void 0, hasError: false };
      try {
        n(s16, await this.tileLocks.lock([o9.tileId]), false);
        const e14 = await this.createRemoveCommand(o9.id);
        await e14?.execute();
      } catch (a10) {
        s16.error = a10, s16.hasError = true;
      } finally {
        s(s16);
      }
    }
  }
  async _addTile(t5) {
    const { _tileHandles: e14 } = this, s15 = e14.get(t5.id);
    if (null != s15) {
      if (!T2(s15) || s15.featureData.isFullyEnabled) return;
      return s15.featureData.enableAll(), void await this._onTileLoad(s15);
    }
    const o9 = new v(t5, d(async (e15) => {
      const s16 = await this.loadTile(t5, e15);
      return s3(e15), new s14(s16);
    }));
    this._tileHandles.set(o9.id, o9);
    try {
      await o9.loadTask.promise;
    } catch (a10) {
      return void f(a10);
    }
    g2(o9), await this._onTileLoad(o9);
  }
  async _onTileLoad(s15) {
    const o9 = { stack: [], error: void 0, hasError: false };
    try {
      const { _wanted: e14, _tileHandles: i3, _missingTiles: r5 } = this, n13 = s15.descriptor, l7 = new Array(), c9 = new Array(), d4 = new Array(), u6 = /* @__PURE__ */ new Set();
      for (const t5 of i3.values()) {
        if (t5 === s15) continue;
        const { descriptor: o10, id: a10 } = t5;
        if (e14.has(a10) || r5.some((t6) => w3(t6, o10) || w3(o10, t6))) {
          if (T2(t5)) {
            if (w3(n13, o10)) {
              const e15 = t5.featureData;
              for (const t6 of e15.objectIds()) u6.add(t6);
            }
            if (w3(o10, n13)) {
              const { featureData: e15 } = t5;
              c9.push(e15);
            }
          }
        } else {
          i3.delete(a10), t5.loadTask.abort();
          const { featureData: e15 } = t5;
          null != e15 && l7.push(e15);
        }
      }
      u6.size > 0 && (s15.featureData.disableObjectIds(u6), this._validateRemoval(s15.featureData, u6)), this._validate(), d4.push(s15.featureData);
      const h6 = [...d4, ...l7, ...c9].map((t5) => t5.tileId);
      n(o9, await this.tileLocks.lock(h6), false);
      if (0 !== c9.length) {
        const t5 = s15.featureData, e15 = new Set(t5.objectIds());
        for (const s16 of c9) s16.disableObjectIds(e15), this._validateRemoval(s16, e15);
      }
      const f8 = l7.map((t5) => this.createRemoveCommand(t5.id)), p5 = d4.map((t5) => this.createAddCommand(t5)), y = c9.map((t5) => this.createUpdateCommand(t5)), _3 = await Promise.all([...f8, ...p5, ...y]), v2 = n8(_3.filter(L));
      await v2?.execute();
    } catch (i3) {
      o9.error = i3, o9.hasError = true;
    } finally {
      s(o9);
    }
  }
  _validate() {
    if (!has("feature-pipeline-3d-test-validation")) return;
    const t5 = new Array();
    for (const e14 of this._tileHandles.values()) {
      if (!T2(e14)) continue;
      const { featureData: s15 } = e14;
      t5.push({ featureData: s15, objectIds: new Set(s15.enabledObjectIds()) });
    }
    for (let e14 = 0; e14 < t5.length; ++e14) {
      const { featureData: s15, objectIds: o9 } = t5[e14];
      for (let a10 = e14 + 1; a10 < t5.length; ++a10) {
        const { featureData: e15, objectIds: i3 } = t5[a10];
        for (const t6 of i3) if (o9.has(t6)) throw new Error(`${s15.id} and ${e15.id} both contain ${t6}.`);
      }
    }
  }
  _validateRemoval(t5, e14) {
    if (has("feature-pipeline-3d-test-validation")) {
      for (const s15 of t5.enabledObjectIds()) if (e14.has(s15)) throw new Error(`Failed to remove ${s15} from ${t5.id}!`);
    }
  }
};
function w3({ lij: [t5, e14, s15] }, { lij: [o9, a10, i3] }) {
  const r5 = o9 - t5;
  return r5 >= 0 && e14 === a10 >> r5 && s15 === i3 >> r5;
}
r([m2()], _2.prototype, "updating", null), r([m2({ constructOnly: true })], _2.prototype, "loadTile", void 0), r([m2({ constructOnly: true })], _2.prototype, "createAddCommand", void 0), r([m2({ constructOnly: true })], _2.prototype, "createRemoveCommand", void 0), r([m2({ constructOnly: true })], _2.prototype, "createUpdateCommand", void 0), r([m2({ constructOnly: true })], _2.prototype, "tileLocks", void 0), r([m2()], _2.prototype, "extent", void 0), r([m2()], _2.prototype, "_boundingRect", null), r([m2()], _2.prototype, "_missingTiles", null), r([m2()], _2.prototype, "_updateRequested", void 0), r([m2()], _2.prototype, "_synchronizationTask", void 0), _2 = r([a("esri.views.3d.layers.graphics.pipeline.Tile3DManager")], _2);
var v = class {
  constructor(t5, e14) {
    this.descriptor = t5, this.loadTask = e14;
  }
  get id() {
    return this.descriptor.id;
  }
  get featureData() {
    return this.loadTask.value;
  }
};
function T2(t5) {
  return null != t5.featureData;
}
function g2(t5) {
  if (!T2(t5)) throw new Error();
}

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/TileLocks.js
var e13 = class {
  constructor() {
    this._previousActions = /* @__PURE__ */ new Map();
  }
  async lock(e14) {
    const { _previousActions: i3 } = this, l7 = e14.map((o9) => i3.get(o9)).filter(L), c9 = Promise.allSettled(l7), a10 = L2(), n13 = e(() => a10.resolve()), m9 = a10.promise.finally(() => {
      for (const o9 of e14) i3.get(o9) === m9 && i3.delete(o9);
    });
    for (const o9 of e14) i3.set(o9, m9);
    return await c9, m(n13);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/featureSet/TiledFeatureStore.js
var u4 = class {
  constructor(t5, e14) {
    this._index = t5, this._view = e14;
  }
  get usedMemory() {
    return s5 + n2;
  }
  getObjectId() {
    return this._view.getObjectId(this._index);
  }
  getAttribute(t5) {
    return this._view.getAttribute(this._index, t5);
  }
  getAttributeAsTimestamp(t5) {
    return this._view.getAttributeAsTimestamp(this._index, t5);
  }
  getAttributes() {
    return this._view.getAttributes(this._index);
  }
  getOptimizedGeometry() {
    return this._view.getOptimizedGeometry(this._index);
  }
  getCentroid(t5) {
    return this._view.getCentroid(this._index, t5);
  }
  getBounds() {
    return this._view.getBounds(this._index);
  }
  getBoundingBox() {
    return this._view.getBoundingBox(this._index);
  }
  cloneWithGeometry(t5) {
    return new d3(this._index, this._view, t5);
  }
};
var d3 = class extends u4 {
  constructor(t5, e14, i3) {
    super(t5, e14), this._geometryOverride = i3;
  }
  getOptimizedGeometry() {
    return this._geometryOverride;
  }
  getCentroid(t5) {
    return n3(new e3(), this._geometryOverride, t5.hasZ, t5.hasM);
  }
};
var a8 = class {
  constructor(t5, e14) {
    this.featureData = t5, this.bounds = e14;
  }
};
var h4 = class {
  constructor() {
    this._tileBounds = /* @__PURE__ */ new Map(), this.events = new o(), this.featureAdapter = m7.shared;
  }
  get usedMemory() {
    return s5 + s5 * this._tileBounds.size;
  }
  addTile(t5) {
    const { featureCount: e14 } = t5;
    if (0 === e14) return;
    const i3 = new s8(9, (e15) => t5.getBounds(e15)), s15 = new Array();
    for (let r5 = 0; r5 < e14; ++r5) s15[r5] = r5;
    i3.load(s15), this._tileBounds.set(t5.id, new a8(t5, i3)), this.events.emit("changed");
  }
  removeTile(t5) {
    this._tileBounds.delete(t5), this.events.emit("changed");
  }
  clear() {
    this._tileBounds.clear(), this.events.emit("changed");
  }
  forEach(t5) {
    for (const { featureData: e14, bounds: i3 } of this._tileBounds.values()) i3.all((i4) => {
      e14.getEnabled(i4) && t5(new u4(i4, e14));
    });
  }
  forEachInBounds(t5, e14) {
    g3.minX = t5[0], g3.minY = t5[1], g3.maxX = t5[2], g3.maxY = t5[3];
    for (const { featureData: i3, bounds: r5 } of this._tileBounds.values()) r5.search(g3, (t6) => {
      i3.getEnabled(t6) && e14(new u4(t6, i3));
    });
  }
  forEachBounds(t5, e14) {
    for (const i3 of t5) e14(i3.getBoundingBox());
  }
  getFullExtent(t5) {
    let e14 = 1 / 0, i3 = 1 / 0, r5 = -1 / 0, s15 = -1 / 0;
    for (const { bounds: n13 } of this._tileBounds.values()) {
      const { minX: t6, minY: o9, maxX: u6, maxY: d4 } = n13.toJSON();
      e14 = Math.min(e14, t6), i3 = Math.min(i3, o9), r5 = Math.min(r5, u6), s15 = Math.min(s15, d4);
    }
    return { xmin: e14, ymin: i3, xmax: r5, ymax: s15, spatialReference: t5 };
  }
};
var _m = class _m {
  getObjectId(t5) {
    return t5.getObjectId();
  }
  getAttribute(t5, e14) {
    return t5.getAttribute(e14);
  }
  getAttributeAsTimestamp(t5, e14) {
    return t5.getAttributeAsTimestamp(e14);
  }
  getAttributes(t5) {
    return t5.getAttributes();
  }
  getGeometry(t5) {
    return t5.getOptimizedGeometry();
  }
  getCentroid(t5, e14) {
    return t5.getCentroid(e14);
  }
  cloneWithGeometry(t5, e14) {
    return t5.cloneWithGeometry(e14);
  }
};
_m.shared = new _m();
var m7 = _m;
var g3 = new E();

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/Tile.js
var n11 = class {
  constructor(n13, a10, r5) {
    this.descriptor = n13, this._pages = a10, this._pageSize = r5;
    const i3 = a3 + a10.reduce((e14, { usedMemory: t5 }) => e14 + t5, 0), d4 = 3 * n2;
    this.usedMemory = s5 + i3 + d4, this.featureCount = a10.reduce((e14, t5) => e14 + t5.featureCount, 0);
  }
  get id() {
    return this.descriptor.id;
  }
  getObjectId(e14) {
    const { pageIndex: t5, featurePageIndex: s15 } = this._translateIndex(e14);
    return this._pages[t5].getObjectId(s15);
  }
  getAttribute(e14, t5) {
    const { pageIndex: s15, featurePageIndex: n13 } = this._translateIndex(e14);
    return this._pages[s15].getAttribute(n13, t5);
  }
  getAttributeAsTimestamp(e14, t5) {
    const { pageIndex: s15, featurePageIndex: n13 } = this._translateIndex(e14);
    return this._pages[s15].getAttributeAsTimestamp(n13, t5);
  }
  getAttributes(e14) {
    const { pageIndex: t5, featurePageIndex: s15 } = this._translateIndex(e14);
    return this._pages[t5].getAttributes(s15);
  }
  getCoordinates(e14, t5, s15) {
    const { pageIndex: n13, featurePageIndex: a10 } = this._translateIndex(e14);
    this._pages[n13].getCoordinates(a10, t5, s15);
  }
  getOptimizedGeometry(e14) {
    const { pageIndex: t5, featurePageIndex: s15 } = this._translateIndex(e14);
    return this._pages[t5].getOptimizedGeometry(s15);
  }
  getCentroid(e14, t5) {
    const { pageIndex: s15, featurePageIndex: n13 } = this._translateIndex(e14);
    return this._pages[s15].getCentroid(n13, t5);
  }
  getBounds(e14) {
    const { pageIndex: t5, featurePageIndex: s15 } = this._translateIndex(e14);
    return this._pages[t5].getBounds(s15);
  }
  getBoundingBox(e14) {
    const { pageIndex: t5, featurePageIndex: s15 } = this._translateIndex(e14);
    return this._pages[t5].getBoundingBox(s15);
  }
  getObjectIdsArray(e14, t5 = this._allFeatureIndices(), s15 = 0) {
    let n13 = s15;
    for (const { page: a10, indices: r5 } of this._batchPageIndices(t5)) n13 = a10.getObjectIdsArray(e14, r5, n13);
    return n13;
  }
  getCoordinatesArray(e14, t5 = this._allFeatureIndices(), s15 = 0) {
    let n13 = s15;
    for (const { page: a10, indices: r5 } of this._batchPageIndices(t5)) n13 = a10.getCoordinatesArray(e14, r5, n13);
    return n13;
  }
  *objectIds(e14 = this._allFeatureIndices()) {
    for (const { page: t5, indices: s15 } of this._batchPageIndices(e14)) for (const e15 of t5.objectIds(s15)) yield e15;
  }
  *_allFeatureIndices() {
    const { featureCount: e14 } = this;
    for (let t5 = 0; t5 < e14; ++t5) yield t5;
  }
  _translateIndex(e14) {
    const { _pageSize: t5 } = this;
    return { pageIndex: Math.floor(e14 / t5), featurePageIndex: e14 % t5 };
  }
  *_batchPageIndices(e14) {
    const t5 = new Array();
    {
      let s16 = 0, n13 = new Array();
      for (const a10 of e14) {
        const { pageIndex: e15, featurePageIndex: r5 } = this._translateIndex(a10);
        s16 !== e15 && (0 !== n13.length && t5.push({ pageIndex: s16, indices: n13 }), s16 = e15, n13 = []), n13.push(r5);
      }
      0 !== n13.length && t5.push({ pageIndex: s16, indices: n13 });
    }
    const { _pages: s15 } = this;
    for (const { pageIndex: n13, indices: a10 } of t5) yield { page: s15[n13], indices: a10 };
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/featureSet/PBFPointFeatureSetView.js
var u5 = class {
  constructor(e14) {
    this._reader = new a5(new Uint8Array(e14), new DataView(e14)), this._index = g4(this._reader);
  }
  get featureCount() {
    return this._index.featureIndices.length;
  }
  get exceededTransferLimit() {
    return this._index.exceededTransferLimit;
  }
  get usedMemory() {
    return this._reader.usedMemory;
  }
  getObjectId(e14) {
    return this.getAttribute(e14, this._index.objectIdFieldName);
  }
  getAttribute(e14, t5) {
    const { _index: { fieldsIndex: r5, attributeIndices: s15 } } = this, n13 = r5.get(t5)?.index;
    if (null == n13) return;
    const o9 = s15[e14 * r5.fields.length + n13], i3 = this._reader;
    return i3.move(o9), m8(i3);
  }
  getAttributeAsTimestamp(e14, t5) {
    const r5 = this.getAttribute(e14, t5);
    return "string" == typeof r5 ? new Date(r5).getTime() : "number" == typeof r5 || null == r5 ? r5 : null;
  }
  getAttributes(e14) {
    const { _index: { fieldsIndex: t5, attributeIndices: r5 } } = this, s15 = e14 * t5.fields.length, n13 = this._reader, o9 = {};
    for (const i3 of t5.fields) {
      const e15 = r5[s15 + i3.index];
      n13.move(e15), o9[i3.name] = m8(n13);
    }
    return o9;
  }
  getCoordinates(e14, t5, r5 = 0) {
    const s15 = this._reader, { transform: n13, featureIndices: o9 } = this._index, { scale: i3, translate: a10 } = n13;
    s15.move(o9[e14]), this._readCoordinates(i3, a10, t5, r5);
  }
  getOptimizedGeometry(e14) {
    const t5 = n4();
    return this.getCoordinates(e14, t5), new e3([], t5);
  }
  getCentroid(e14, { hasZ: t5, hasM: r5 }) {
    this.getCoordinates(e14, p3);
    const [s15, n13, o9] = p3, a10 = [s15, n13];
    return t5 && (a10[3] = o9), r5 && (a10[t5 ? 4 : 3] = 0), new e3([], a10);
  }
  getBounds(e14) {
    this.getCoordinates(e14, p3);
    const [t5, r5] = p3, n13 = new E();
    return n13.minX = t5, n13.minY = r5, n13.maxX = t5, n13.maxY = r5, n13;
  }
  getBoundingBox(e14) {
    this.getCoordinates(e14, p3);
    const [t5, r5, s15] = p3;
    return a2(t5, r5, s15, t5, r5, s15);
  }
  getObjectIdsArray(e14, t5 = this._allFeatureIndices(), r5 = 0) {
    const s15 = this._reader, { objectIdFieldName: n13, attributeIndices: o9, fieldsIndex: i3 } = this._index, a10 = i3.get(n13).index, d4 = i3.fields.length;
    for (const c9 of t5) {
      const t6 = o9[c9 * d4 + a10];
      s15.move(t6), e14[r5++] = m8(s15);
    }
    return r5;
  }
  getCoordinatesArray(e14, t5 = this._allFeatureIndices(), r5 = 0) {
    const s15 = this._reader, { transform: n13, featureIndices: o9 } = this._index, { scale: i3, translate: a10 } = n13;
    for (const d4 of t5) {
      const t6 = o9[d4];
      s15.move(t6), r5 = this._readCoordinates(i3, a10, e14, r5);
    }
    return r5;
  }
  *objectIds(e14 = this._allFeatureIndices()) {
    const t5 = this._reader, { objectIdFieldName: r5, attributeIndices: s15, fieldsIndex: n13 } = this._index, o9 = n13.get(r5).index, i3 = n13.fields.length;
    for (const a10 of e14) {
      const e15 = s15[a10 * i3 + o9];
      t5.move(e15), yield m8(t5);
    }
  }
  *_allFeatureIndices() {
    const { featureCount: e14 } = this;
    for (let t5 = 0; t5 < e14; ++t5) yield t5;
  }
  _readCoordinates([e14, t5, r5], [s15, n13, o9], i3, a10) {
    const d4 = 2, c9 = 3, u6 = this._reader, g5 = u6.getLength(), l7 = u6.pos() + g5;
    for (; u6.pos() < l7 && u6.next(); ) switch (u6.tag()) {
      case d4: {
        const d5 = u6.getLength(), g6 = u6.pos() + d5;
        for (; u6.pos() < g6 && u6.next(); ) if (u6.tag() === c9) u6.getUInt32(), i3[a10++] = s15 + e14 * u6.getSInt64(), i3[a10++] = n13 + t5 * u6.getSInt64(), i3[a10++] = o9 + r5 * u6.getSInt64();
        else u6.skip();
        break;
      }
      default:
        u6.skip();
    }
    return a10;
  }
};
function g4(e14) {
  const t5 = 2;
  for (; e14.next(); ) {
    if (e14.tag() === t5) return l5(e14.getMessage());
    e14.skip();
  }
  h5();
}
function l5(e14) {
  const t5 = 1;
  for (; e14.next(); ) {
    if (e14.tag() === t5) return f7(e14.getMessage());
    e14.skip();
  }
  h5();
}
function f7(e14) {
  const t5 = 9, r5 = 12, s15 = 13, n13 = 15, i3 = 7, u6 = 0, g5 = 10, l7 = 1, f8 = 1;
  let m9, p5, x2 = false, I3 = false, b5 = 0;
  const _3 = new Array(), w4 = new Array(), y = new Array();
  for (; e14.next(); ) switch (e14.tag()) {
    case f8:
      p5 = e14.getString();
      break;
    case i3:
      e14.getEnum() !== u6 && h5();
      break;
    case t5:
      x2 = e14.getBool() ?? false;
      break;
    case r5:
      m9 = u(e14.processMessage(h3));
      break;
    case s15: {
      const t6 = e14.processMessage(b2);
      t6.index = b5++, _3.push(t6);
      break;
    }
    case n13: {
      w4.push(e14.pos());
      const t6 = e14.getUInt32(), r6 = e14.pos() + t6;
      for (; e14.pos() < r6 && e14.next(); ) if (e14.tag() === l7) y.push(e14.pos()), e14.skip();
      else e14.skip();
      break;
    }
    case g5:
      I3 = e14.getBool() ?? false;
      break;
    default:
      e14.skip();
  }
  const j5 = new Z(_3);
  return null != m9 && I3 && null != p5 && j5.has(p5) || h5(), { transform: m9, exceededTransferLimit: x2, fieldsIndex: j5, objectIdFieldName: p5, featureIndices: w4, attributeIndices: y };
}
function h5() {
  const t5 = new s2("pbf-parsing-failed", "Error while parsing PBF", new Error());
  throw console.error(t5), t5;
}
function m8(e14) {
  const t5 = 1, r5 = 2, s15 = 3, n13 = 4, o9 = 5, i3 = 6, a10 = 7, d4 = 8, c9 = 9, u6 = e14.getLength(), g5 = e14.pos() + u6;
  for (; e14.pos() < g5 && e14.next(); ) switch (e14.tag()) {
    case t5:
      return e14.getString();
    case r5:
      return e14.getFloat();
    case s15:
      return e14.getDouble();
    case n13:
      return e14.getSInt32();
    case o9:
      return e14.getUInt32();
    case i3:
      return e14.getInt64();
    case a10:
      return e14.getUInt64();
    case d4:
      return e14.getSInt64();
    case c9:
      return e14.getBool();
    default:
      return e14.skip(), null;
  }
  return null;
}
var p3 = n4();

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/fetching/Tile3DFetcher.js
var i2 = 8e3;
var a9 = 4;
var n12 = 4;
var c7 = class {
  constructor(e14, t5, r5, o9, s15) {
    this.spatialReference = e14, this.url = r5, this.objectIdField = o9, this.capabilities = s15;
    const { supportsMaxRecordCountFactor: n13, maxRecordCount: c9 } = this.capabilities.query, u6 = n13 ? a9 : 1, p5 = (c9 ?? i2) * u6;
    this._pageSize = Math.min(i2, p5);
    const l7 = t5.clone();
    l7.cacheHint = true, l7.resultType = "tile", l7.outSpatialReference = e14, l7.returnGeometry = true, l7.returnZ = true, l7.maxRecordCountFactor = u6, l7.num = this._pageSize, l7.outFields = [o9], this._baseQuery = l7;
  }
  async fetch(r5, s15) {
    const { spatialReference: i3, _pageSize: a10 } = this, c9 = c(r5.extent, i3), u6 = this._baseQuery.clone();
    u6.geometry = c9;
    const p5 = new Array();
    let l7 = 0, h6 = false, m9 = 1;
    for (; !h6; ) {
      const t5 = [];
      for (let e14 = 0; e14 < m9; ++e14) t5.push(this._fetchPage(u6, l7++, s15));
      const r6 = await Promise.all(t5);
      s3(s15);
      for (const e14 of r6) {
        const t6 = 0 !== e14.featureCount;
        h6 ||= !e14.exceededTransferLimit || !t6, t6 && p5.push(e14);
      }
      m9 = Math.min(m9 + 1, n12);
    }
    return new n11(r5, p5, a10);
  }
  async _fetchPage(t5, o9, i3) {
    const a10 = t5.clone();
    a10.start = o9 * this._pageSize;
    const n13 = (await m4(this.url, a10, { signal: i3 })).data;
    return s3(i3), new u5(n13);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/rendering/RenderCommandContext.js
var l6 = class {
  constructor(e14, r5) {
    this._mainThreadDelegate = r5, this._bufferWriters = /* @__PURE__ */ new Map(), this.globalViewingMode = e14 === l3.Global;
  }
  createRenderCommandBuffer(e14 = [], r5 = []) {
    return { commands: e14, transferList: r5 };
  }
  mergeRenderCommandBuffers(e14) {
    const r5 = this.createRenderCommandBuffer();
    for (const t5 of e14) null != t5 && (r5.commands.push(...t5.commands), r5.transferList.push(...t5.transferList));
    return r5;
  }
  async createTexture(e14) {
    const { data: r5, parameters: t5 } = e14();
    return await this._mainThreadDelegate.createTexture(r5, t5);
  }
  async releaseTexture(e14) {
    const r5 = this._destroyTexture(e14);
    return new e9(this, r5, []);
  }
  _destroyTexture(e14) {
    return { commands: [{ id: "destroy-texture", textureId: e14 }], transferList: [] };
  }
  async createMaterial(e14) {
    const { type: r5, parameters: t5 } = e14, n13 = r4("material");
    let a10, i3;
    switch (r5) {
      case "default":
        a10 = new W(e14.parameters, { spherical: this.globalViewingMode }), i3 = { type: r5, materialId: n13, parameters: e14.parameters };
        break;
      case "hud":
        a10 = new ue(t5, this.globalViewingMode), i3 = { type: r5, materialId: n13, parameters: e14.parameters };
    }
    return this._bufferWriters.set(n13, a10.createBufferWriter()), await this._mainThreadDelegate.createMaterial(i3), n13;
  }
  destroyMaterial(e14) {
    return { commands: [{ id: "destroy-material", materialId: e14 }], transferList: [] };
  }
  updateMaterial(e14) {
    return { commands: [{ ...e14, id: "update-material" }], transferList: [] };
  }
  async createDirectRenderer(e14) {
    return await this._mainThreadDelegate.createDirectRenderer(e14), e14;
  }
  async destroyDirectRenderer(e14) {
    await this._mainThreadDelegate.destroyDirectRenderer(e14);
  }
  addDirectRendererGeometry(e14, r5, t5) {
    const { materialId: n13 } = r5;
    if (null == this._bufferWriters.get(n13)) throw new Error(`no bufferwriter found for material ${n13}`);
    const { renderGeometryBuffer: a10, renderGeometryBufferItems: i3 } = this.createRenderGeometryBuffer(r5, t5);
    return this.addDirectRendererGeometryBuffer(n13, e14, a10, i3, t5);
  }
  updateDirectRendererGeometry(e14, r5, t5) {
    const { materialId: n13 } = r5;
    if (null == this._bufferWriters.get(n13)) throw new Error(`no bufferwriter found for material ${n13}`);
    const { renderGeometryBuffer: a10, renderGeometryBufferItems: i3 } = this.createRenderGeometryBuffer(r5, t5);
    return this.updateDirectRendererGeometryBuffer(n13, e14, a10, i3, t5);
  }
  addDirectRendererGeometryBuffer(e14, r5, t5, n13, a10) {
    const { objectIds: i3, visibilities: s15 } = n13;
    return { commands: [{ id: "add-direct-renderer-geometry-buffer", rendererId: e14, groupId: r5, renderGeometryBuffer: t5, renderGeometryBufferItems: n13, localOrigin: a10 }], transferList: [t5.data, i3.buffer, s15.buffer] };
  }
  updateDirectRendererGeometryBuffer(e14, r5, t5, n13, a10) {
    const { objectIds: i3, visibilities: s15 } = n13;
    return { commands: [{ id: "update-direct-renderer-geometry-buffer", rendererId: e14, groupId: r5, renderGeometryBuffer: t5, renderGeometryBufferItems: n13, localOrigin: a10 }], transferList: [t5.data, i3.buffer, s15.buffer] };
  }
  removeDirectRendererGeometryBuffer(e14, r5) {
    return { commands: [{ id: "remove-direct-renderer-geometry-buffer", rendererId: e14, groupId: r5 }], transferList: [] };
  }
  async createLodRenderer(e14) {
    const r5 = r4("lod-renderer"), t5 = /* @__PURE__ */ new Set(), n13 = { levels: e14.levels.map((e15) => ({ components: e15.components.map((e16) => {
      const r6 = e16.attributes.get(e7.POSITION);
      if (!r6 || 0 === r6.indices.length) throw new Error("positions attribute expected");
      const n14 = 3, i3 = A(r6.indices.length / n14), s15 = new o6(i3, n14, r6);
      if (null == this._bufferWriters.get(e16.materialId)) throw new Error("writer not found");
      const { renderGeometryBuffer: o9 } = this.createRenderGeometryBuffer(e16, null);
      t5.add(o9.data);
      return { materialId: e16.materialId, renderGeometryBuffer: o9, boundingInfo: { bbMax: s15.bbMax, bbMin: s15.bbMin } };
    }), minScreenSpaceRadius: e15.minScreenSpaceRadius })) };
    return await this._mainThreadDelegate.createLodRenderer(r5, n13, Array.from(t5)), r5;
  }
  destroyLodRenderer(e14) {
    return { commands: [{ id: "destroy-lod-renderer", rendererId: e14 }], transferList: [] };
  }
  addLodInstances(e14, r5, t5) {
    return { commands: [{ id: "add-lod-instances", rendererId: e14, groupId: r5, data: t5 }], transferList: [t5.featureIds.buffer, t5.globalTransforms.buffer, t5.localTransforms.buffer, t5.visibility.buffer] };
  }
  removeLodInstances(e14, r5) {
    return { commands: [{ id: "remove-lod-instances", rendererId: e14, groupId: r5 }], transferList: [] };
  }
  updateLodInstancesData(e14, r5, t5) {
    return { commands: [{ id: "update-lod-instance-data", rendererId: e14, groupId: r5, globalTransforms: t5 }], transferList: [t5.buffer] };
  }
  updateVisibility(e14, r5, t5) {
    return { commands: [{ id: "update-visibility", rendererId: e14, groupId: r5, visibility: t5 }], transferList: [t5.buffer] };
  }
  async dispatchRenderCommands(e14) {
    0 !== e14.commands.length && await this._mainThreadDelegate.executeRenderCommands(e14);
  }
  createRenderGeometryBuffer(n13, a10) {
    const { materialId: i3, visibilities: s15, objectIds: o9 } = n13, d4 = this._bufferWriters.get(i3);
    if (null == d4) throw new Error("no registered bufferWriter for material found");
    let m9 = null;
    if (n13.transformation && a10) n5(c8, n13.transformation), c8[12] -= a10[0], c8[13] -= a10[1], c8[14] -= a10[2], m9 = c8;
    else {
      if (a10) throw new Error("not implemented");
      n13.transformation && (m9 = n13.transformation);
    }
    let f8 = null;
    m9 && (h2(b4, c8), s6(b4, b4), f8 = b4);
    const u6 = n13.attributes, l7 = d4.elementCount(u6), y = d4.vertexBufferLayout.stride / 4;
    l7 > Math.floor(p4 / y) && console.warn("geometry with very large number of elements encountered");
    const g5 = d4.vertexBufferLayout.createBuffer(l7), h6 = 0, I3 = d4.write(m9, f8, u6, n13.objectAndLayerIdColor, g5, h6);
    if (null == I3) throw new Error("Bufferwriter.write does not provide item information.");
    if (s15.length !== I3.numItems || o9.length !== I3.numItems) throw new Error("Unexpected mismatch between number of RenderGeometryBufferItems and provided objectIds/visibility flags.");
    return { renderGeometryBuffer: { data: g5.buffer, elementCount: l7 }, renderGeometryBufferItems: { objectIds: o9, visibilities: s15, ranges: { numVertices: I3.numVerticesPerItem, numItems: I3.numItems } } };
  }
};
var c8 = e4();
var b4 = e4();
var p4 = 16777216 / 4;

// node_modules/@arcgis/core/views/3d/layers/graphics/pipeline/Feature3DPipelineWorker.js
var R3 = class extends o.EventedAccessor {
  constructor() {
    super(...arguments), this.remoteClient = null, this._featureStore = new h4(), this._tileLocks = new e13(), this._tileManager = null, this._renderer = null, this._fetcher = null, this._queryEngine = null, this._defaultQueryJSON = null, this._mainThreadDelegate = null, this._viewSpatialReference = null, this._renderCommandContext = null, this._context = null;
  }
  get updating() {
    return this._tileManager.updating;
  }
  destroy() {
    this._featureStore.clear(), this._tileManager?.destroy();
  }
  async setup({ viewSpatialReference: e14, renderSpatialReference: t5, viewingMode: r5, layerInfo: a10, layerViewInfo: n13 }) {
    const s15 = f2.fromJSON(e14);
    this._viewSpatialReference = s15;
    const l7 = f2.fromJSON(t5);
    this._fetcher = new c7(this._viewSpatialReference, R2.fromJSON(a10.baseQuery), a10.url, a10.objectIdField, a10.capabilities), this._queryEngine = new L3({ hasZ: true, hasM: false, geometryType: "esriGeometryPoint", featureIdInfo: { type: "object-id", fieldName: a10.objectIdField }, fieldsIndex: a10.fieldIndex, availableFields: [a10.objectIdField], spatialReference: e14, featureStore: this._featureStore, timeInfo: a10.timeInfo }), this._mainThreadDelegate = { createTexture: async (e15, t6) => {
      const r6 = { data: e15, parameters: t6 };
      return await this.remoteClient.invoke("createTexture", r6, { transferList: [e15.buffer] });
    }, releaseTexture: async (e15) => {
      const t6 = { uid: e15 };
      await this.remoteClient.invoke("releaseTexture", t6);
    }, createMaterial: async (e15) => {
      const t6 = { materialJSON: e15 };
      await this.remoteClient.invoke("createMaterial", t6);
    }, destroyMaterial: async (e15) => {
      const t6 = { materialId: e15 };
      await this.remoteClient.invoke("destroyMaterial", t6);
    }, createDirectRenderer: async (e15) => {
      const t6 = { materialId: e15 };
      await this.remoteClient.invoke("createDirectRenderer", t6);
    }, destroyDirectRenderer: async (e15) => {
      const t6 = { materialId: e15 };
      await this.remoteClient.invoke("destroyDirectRenderer", t6);
    }, createLodRenderer: async (e15, t6, r6) => {
      const a11 = { rendererId: e15, lodRenderGeometry: t6 };
      await this.remoteClient.invoke("createLoDRenderer", a11, { transferList: r6 });
    }, destroyLodRenderer: async (e15) => {
      const t6 = { rendererId: e15 };
      await this.remoteClient.invoke("destroyLoDRenderer", t6);
    }, executeRenderCommands: async (e15) => {
      const t6 = { commands: e15.commands };
      await this.remoteClient.invoke("dispatchRenderCommands", t6, { transferList: e15.transferList });
    }, applyElevationAlignmentTo: async (e15) => {
      const t6 = { mapPoints: e15 };
      return await this.remoteClient.invoke("applyElevationAlignment", t6, { transferList: [e15.buffer] });
    } };
    const f8 = B2.create(r5, l7), C = new l6(r5, this._mainThreadDelegate);
    this._renderCommandContext = C;
    const w4 = new a7(s15, l7, this._mainThreadDelegate, f8, C, a10, n13);
    this._context = w4, this._renderer = w4.symbolRendererFactory.createSymbolRendererFromJSON(a10.renderer), this._defaultQueryJSON = new R2({ outSpatialReference: s15 }).toJSON();
    let R4 = null;
    if (null != a10.fullExtent) {
      const e15 = z.fromJSON(a10.fullExtent);
      await Q(e15.spatialReference, s15), R4 = O(e15, s15);
    }
    return this._tileManager = new _2({ loadTile: (e15, t6) => this._fetcher.fetch(e15, t6), createAddCommand: (e15, t6) => this._createAddFeatureDataCommand(e15, t6), createRemoveCommand: (e15) => this._createRemoveFeatureDataCommand(e15), createUpdateCommand: (e15, t6) => this._createUpdateFeatureDataVisibilityCommand(e15, t6), tileLocks: this._tileLocks, extent: R4 }), this.addHandles(l(() => this.updating, (e15) => {
      this.emit("notify-updating", { updating: e15 });
    }), h), null != this._renderer && await this._renderer.load(), j4;
  }
  async executeQuery(e14, t5) {
    return { result: await this._queryEngine.executeQuery(this._ensureQuery(e14), t5) };
  }
  async executeQueryForIds(e14, t5) {
    const r5 = await this._queryEngine.executeQueryForIdSet(this._ensureQuery(e14), t5);
    return { result: Array.from(r5) };
  }
  async executeQueryForCount(e14, t5) {
    return { result: await this._queryEngine.executeQueryForCount(this._ensureQuery(e14), t5) };
  }
  async executeQueryForExtent(e14, t5) {
    return { result: await this._queryEngine.executeQueryForExtent(this._ensureQuery(e14), t5) };
  }
  async executeQueryForLatestObservations(e14, t5) {
    return { result: await this._queryEngine.executeQueryForLatestObservations(this._ensureQuery(e14), t5) };
  }
  onTileTreeChange(e14) {
    return this._tileManager.onTileTreeChange(e14), Promise.resolve(j4);
  }
  async onElevationChange(e14) {
    return j4;
  }
  async onLayerViewOpacityChange(e14) {
    const { _context: t5, _renderer: r5 } = this;
    if (t5.layerViewInfo.fullOpacity = e14, null == r5) return j4;
    const a10 = await r5.createUpdateLayerViewOpacityCommand(e14);
    return await a10.execute(), j4;
  }
  async onRendererChange(r5) {
    const { _context: a10 } = this, n13 = a10.symbolRendererFactory.createSymbolRendererFromJSON(r5);
    await n13.load();
    const i3 = this._renderer;
    this._renderer = n13;
    const o9 = [...this._tileManager.loadedTiles()], s15 = o9.map((e14) => e14.tileId);
    {
      const r6 = { stack: [], error: void 0, hasError: false };
      try {
        n(r6, await this._tileLocks.lock(s15), false);
        const t5 = o9.flatMap((e14) => [i3.createRemoveCommand(e14.id), n13.createAddCommand(e14)]), l8 = await Promise.all(t5), c9 = a10.joinPipelineCommands(l8);
        await c9.execute();
      } catch (c9) {
        r6.error = c9, r6.hasError = true;
      } finally {
        s(r6);
      }
    }
    const l7 = await i3.createDestroyCommand();
    return await l7.execute(), j4;
  }
  async _createAddFeatureDataCommand(e14, t5) {
    const r5 = this._featureStore, a10 = this._renderer;
    let i3;
    return i3 = null != a10 ? await a10.createAddCommand(e14) : e9.create(this._renderCommandContext), s3(t5), i3.appendPipelineStateCommand(() => {
      r5.addTile(e14);
    }), i3;
  }
  async _createRemoveFeatureDataCommand(e14) {
    const t5 = this._featureStore, r5 = this._renderer;
    let a10;
    return a10 = null != r5 ? await r5.createRemoveCommand(e14) : e9.create(this._renderCommandContext), a10.appendPipelineStateCommand(() => {
      t5.removeTile(e14);
    }), a10;
  }
  async _createUpdateFeatureDataVisibilityCommand(e14, t5) {
    const r5 = this._renderer;
    let a10;
    return a10 = null != r5 ? await r5.createUpdateVisibilityCommand(e14) : e9.create(this._renderCommandContext), s3(t5), a10;
  }
  _ensureQuery(e14) {
    return e14 ?? this._defaultQueryJSON;
  }
};
r([m2()], R3.prototype, "updating", null), R3 = r([a("esri.views.3d.layers.graphics.pipeline.Feature3DPipelineWorker")], R3);
var S2 = R3;
var j4 = { result: void 0 };
export {
  S2 as default
};
//# sourceMappingURL=Feature3DPipelineWorker-ZTTEVATH.js.map
