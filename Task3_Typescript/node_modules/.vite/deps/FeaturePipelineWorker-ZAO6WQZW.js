import {
  e as e8,
  u as u10
} from "./chunk-3D5Q5QVJ.js";
import {
  r as r6,
  y as y2
} from "./chunk-2VE6IZP4.js";
import "./chunk-EGNOBZZN.js";
import {
  t as t6
} from "./chunk-3JKD2XXM.js";
import {
  a as a8,
  i as i7,
  l as l3,
  n as n4,
  p as p2,
  r2 as r7,
  r3 as r8,
  s as s10,
  u as u9,
  v,
  x as x2
} from "./chunk-TUPNUSND.js";
import {
  d as d3
} from "./chunk-VZRBHAHT.js";
import "./chunk-73JRZP7E.js";
import "./chunk-I7SMTGBD.js";
import "./chunk-TAPCW5Z5.js";
import "./chunk-ORKTLG2L.js";
import "./chunk-IVCVGY7Y.js";
import {
  i as i6,
  s as s9,
  u as u8
} from "./chunk-ZGHXSTOV.js";
import {
  r as r5
} from "./chunk-2N7QR24C.js";
import {
  _ as _2,
  e as e5,
  i as i5,
  r as r4,
  s as s8,
  t as t5
} from "./chunk-L5FOMWCW.js";
import "./chunk-5WTH3GBK.js";
import {
  a as a6
} from "./chunk-N6WKHIKW.js";
import {
  $
} from "./chunk-CEAX7R6A.js";
import "./chunk-7U7T3Q43.js";
import "./chunk-TQBLAIQG.js";
import "./chunk-DBZ575A6.js";
import {
  e as e4
} from "./chunk-H5N2AXWG.js";
import {
  L as L3
} from "./chunk-P4YXQBLK.js";
import "./chunk-WUKLWX63.js";
import "./chunk-LHJOMFWG.js";
import "./chunk-APGIAJ3M.js";
import "./chunk-NLQ5JBZ3.js";
import "./chunk-WQVEQTKW.js";
import {
  Mt,
  R as R2,
  T,
  X,
  at,
  b as b3,
  gt,
  lt,
  mt,
  st,
  tt,
  wt
} from "./chunk-DKS7UUDR.js";
import {
  S,
  c as c3,
  m as m4
} from "./chunk-KH55BE33.js";
import {
  b as b4,
  h
} from "./chunk-WEBPKGFM.js";
import {
  a as a5
} from "./chunk-6DARBDBU.js";
import "./chunk-KDQWOWXR.js";
import {
  s as s5
} from "./chunk-JOVQBCRD.js";
import "./chunk-7TPOIM4Y.js";
import "./chunk-LNFOAX5I.js";
import {
  e as e3
} from "./chunk-PBLU5SUP.js";
import "./chunk-U3MD377S.js";
import {
  j as j2,
  x
} from "./chunk-2B6XECE5.js";
import "./chunk-GYAK76KG.js";
import "./chunk-ZAIOYQ5Z.js";
import "./chunk-XZOH57EG.js";
import "./chunk-QB5ST4HW.js";
import {
  _
} from "./chunk-RD652CDC.js";
import "./chunk-OIO6NR6X.js";
import "./chunk-F5BDMX7A.js";
import "./chunk-WKCCXG3E.js";
import "./chunk-ZWJOMK2U.js";
import "./chunk-Y2ZAHGIO.js";
import "./chunk-ZCE5HP23.js";
import "./chunk-Y2QTREQA.js";
import "./chunk-OV7XVIQP.js";
import "./chunk-JQSXFLSD.js";
import "./chunk-H5K53FMS.js";
import {
  e as e2
} from "./chunk-VNLFNBKT.js";
import {
  s as s4
} from "./chunk-KHEIHGIK.js";
import {
  a as a2,
  i as i4,
  s as s3,
  u as u5
} from "./chunk-AAC6XSCN.js";
import "./chunk-Z7VYTTYM.js";
import {
  e as e7,
  r as r9
} from "./chunk-MQW6TXNA.js";
import "./chunk-YBXGYFQH.js";
import {
  h as h2
} from "./chunk-NFDUQVJM.js";
import {
  i as i8
} from "./chunk-2W7OT7Z4.js";
import "./chunk-3PPDORWL.js";
import "./chunk-YIXK32VF.js";
import {
  e as e6
} from "./chunk-2NTKYBCL.js";
import "./chunk-BDWOUZQR.js";
import "./chunk-H34ENSPL.js";
import "./chunk-4ADC6HZF.js";
import "./chunk-AF3FX2UV.js";
import "./chunk-BZYXFNL4.js";
import {
  n as n3
} from "./chunk-VNTS5E5O.js";
import {
  P as P2
} from "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-NO2XQDLB.js";
import "./chunk-LBC3MAJX.js";
import {
  j
} from "./chunk-3ZORAHSR.js";
import "./chunk-SZN55B2M.js";
import "./chunk-NMP7ZOVG.js";
import "./chunk-YHYQP7QX.js";
import {
  a as a7
} from "./chunk-RP7FUW55.js";
import "./chunk-MPV4X4LZ.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-IL45XPTT.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-KQINCOQL.js";
import {
  c as c2
} from "./chunk-K5LVZUBF.js";
import {
  s as s7
} from "./chunk-OC2XWDW2.js";
import "./chunk-C3JHRSMA.js";
import {
  a as a4,
  s as s6,
  y
} from "./chunk-G5DA3EEG.js";
import {
  d as d2
} from "./chunk-I6IIPG56.js";
import {
  Z as Z2
} from "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import {
  O,
  c as c4
} from "./chunk-GOWWJ2HE.js";
import {
  R as R3,
  a as a3
} from "./chunk-7ZMGKXLG.js";
import {
  p
} from "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import {
  u as u7
} from "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-KHRHKYU2.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import {
  u as u6
} from "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-VCRP2PLV.js";
import {
  r as r3
} from "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-QVKLS4LH.js";
import "./chunk-2KVNXQA7.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import {
  u as u4
} from "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import {
  P
} from "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import {
  I,
  R,
  U,
  c,
  e,
  m as m3
} from "./chunk-6GWORUT3.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import {
  n as n2
} from "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import {
  o
} from "./chunk-YIV2QKTZ.js";
import {
  l
} from "./chunk-A3VAC24F.js";
import {
  M,
  r as r2
} from "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import {
  f as f2
} from "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import {
  Z,
  l as l2
} from "./chunk-OXSERRAR.js";
import {
  t as t4
} from "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  b as b2,
  i2 as i3,
  m,
  u3
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import {
  t as t3
} from "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H,
  g2 as g
} from "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import {
  u
} from "./chunk-S7IJH524.js";
import {
  A,
  L as L2,
  b,
  d,
  f2 as f,
  k,
  m2,
  n,
  s as s2,
  t as t2,
  u2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2,
  s
} from "./chunk-XWG6QGFK.js";
import {
  i
} from "./chunk-GWNLQRNM.js";
import {
  L,
  has,
  t
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/2d/layers/features/PipelineConnectionHandlers.js
var t7 = class {
  constructor(e15) {
    this._client = e15, this.layerView = this._client.createInvokeProxy(""), this.container = this._client.createInvokeProxy("container"), this._eventLog = this._client.createInvokeProxy("eventLog");
  }
  onEvent(t20) {
    O(this._eventLog.onEvent(t20));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MultiTileMeshData.js
var r10 = 1;
var i9 = 2;
var n5 = 4;
var h3 = 8;
var o2 = 16;
var c5 = 32;
var a9 = 64;
var l4 = 128;
function f3(e15) {
  switch (e15) {
    case r10:
    case h3:
    case c5:
      return -1;
    case i9:
    case a9:
      return 0;
    case n5:
    case o2:
    case l4:
      return 1;
  }
}
function u11(e15) {
  switch (e15) {
    case r10:
    case i9:
    case n5:
      return -1;
    case h3:
    case o2:
      return 0;
    case c5:
    case a9:
    case l4:
      return 1;
  }
}
var _3 = r10 | h3 | c5;
var d4 = n5 | o2 | l4;
var m5 = r10 | i9 | n5;
var p3 = c5 | a9 | l4;
var g2 = class {
  constructor(e15, t20, r17, i20, n12 = 0) {
    this.tileKey = e15, this._bufferingEnabled = t20, this._sizeHint = n12, this._meshes = { self: new n4(this.id, this._sizeHint), neighbors: new Array() }, this._currentRecordOverlaps = 0, this._currentEntityOverlaps = 0;
    const h7 = i20 ? 1 : 0;
    this._copyBufferedDataIntoSelf = r17 && this._bufferingEnabled && e15.level === h7;
  }
  get id() {
    return this.tileKey.id;
  }
  vertexStart() {
    return this._meshes.self.vertexStart() ?? 0;
  }
  vertexCount() {
    return this._meshes.self.vertexCount();
  }
  indexCount() {
    return this._meshes.self.indexCount();
  }
  indexEnsureSize(e15) {
    this._meshes.self.indexEnsureSize(e15);
  }
  entityStart(e15, t20 = e15) {
    this._currentEntityOverlaps = 0, this._meshes.self.entityStart(e15, t20);
  }
  entityRecordCount() {
    return this._meshes.self.entityRecordCount();
  }
  entityEnd() {
    if (this._meshes.self.entityEnd(), this._bufferingEnabled) {
      if (this._copyBufferedDataIntoSelf) return;
      for (let e15 = 0; e15 < 8; e15++) {
        const t20 = 1 << e15;
        !!(this._currentEntityOverlaps & t20) && this._meshes.neighbors[e15].entityEnd();
      }
    }
  }
  recordStart(e15, t20, s21) {
    this._currentRecordOverlaps = 0, this._meshes.self.recordStart(e15, t20, s21);
  }
  recordEnd(e15 = 0) {
    const t20 = this._meshes.self.recordEnd(this._currentRecordOverlaps);
    return t20 && 0 !== this._currentRecordOverlaps ? (this._copyIntoNeighbors(), this._currentEntityOverlaps |= this._currentRecordOverlaps, true) : t20;
  }
  recordBounds(e15, t20, s21, r17) {
    this._bufferingEnabled && this._addOverlap(e15, t20, s21, r17);
  }
  recordCount() {
    return this._meshes.self.recordCount();
  }
  metricStart(e15) {
    this._meshes.self.metricStart(e15);
  }
  metricBoxWrite(e15) {
    this._meshes.self.metricBoxWrite(e15);
  }
  metricEnd() {
    this._meshes.self.metricEnd();
  }
  vertexWrite(e15) {
    this._meshes.self.vertexWrite(e15);
  }
  vertexWriteF32(e15) {
    this._meshes.self.vertexWriteF32(e15);
  }
  vertexWriteRegion(e15) {
    this._meshes.self.vertexWriteRegion(e15);
  }
  indexWrite(e15) {
    this._meshes.self.indexWrite(e15);
  }
  serialize(t20) {
    const s21 = { message: [], transferList: [] }, r17 = this._meshes.self.serialize();
    return s21.message.push({ tileId: this.tileKey.id, ...r17.message }), s21.transferList.push(...r17.transferList), this._meshes.neighbors.forEach((r18, i20) => {
      const n12 = r18.serialize(), h7 = 1 << i20, o14 = f3(h7), c10 = u11(h7), a16 = new e6(this.tileKey).getNormalizedNeighbor(o14, c10, t20);
      s21.message.push({ tileId: a16.id, ...n12.message }), s21.transferList.push(...n12.transferList);
    }), s21;
  }
  _addOverlap(e15, s21, r17, i20) {
    const n12 = Math.min(a7 / 2, r17), h7 = Math.min(a7 / 2, i20), o14 = 255 ^ ((e15 < 0 + n12 ? d4 : e15 >= a7 - n12 ? _3 : d4 | _3) | (s21 < 0 + h7 ? p3 : s21 >= a7 - h7 ? m5 : p3 | m5));
    this._currentRecordOverlaps |= o14;
  }
  _copyIntoNeighbors() {
    for (let e15 = 0; e15 < 8; e15++) {
      const r17 = 1 << e15;
      if (!!(this._currentRecordOverlaps & r17)) {
        if (this._copyBufferedDataIntoSelf) {
          const e16 = -f3(r17) * a7, s21 = -u11(r17) * a7;
          if (0 !== s21) continue;
          this._meshes.self.copyLast(e16, s21);
          continue;
        }
        if (!this._meshes.neighbors[e15]) {
          const t20 = Math.floor(this._sizeHint / 16);
          this._meshes.neighbors[e15] = new n4(r17, t20);
        }
        const i20 = this._meshes.neighbors[e15], n12 = -f3(r17) * a7, h7 = -u11(r17) * a7;
        i20.copyLastFrom(this._meshes.self, n12, h7);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/MeshFactory.js
var s11 = class {
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var t8 = class _t {
  constructor() {
    this._defaultResult = null, this._backgroundFillResult = null;
  }
  static async from(e15, s21) {
    const l13 = new _t();
    return l13.setDefault(await e15.createMeshWriters(s21.meshes)), l13;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(t20) {
    this._defaultResult = t20;
  }
  getBackgroundFill() {
    return this._backgroundFillResult;
  }
  setBackgroundFill(t20) {
    this._backgroundFillResult = t20;
  }
  hasArcadeDependency(t20) {
    return this._defaultResult?.some((e15) => e15.hasArcadeDependency(t20)) ?? false;
  }
  match(t20, e15, s21) {
    const l13 = this.doMatch(t20, e15) || this.getDefault();
    if (l13 && l13.length > 0) {
      const t21 = this.getBackgroundFill();
      if (t21) return [...t21, ...l13];
    }
    return l13;
  }
  getSortKey(t20, e15) {
    return 0;
  }
  doMatch(t20, e15) {
    return null;
  }
  async fetchResources(t20, e15) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/DictionaryMatcher.js
var e9 = class _e extends t8 {
  static async fromDictionaryRenderer(r17, o14) {
    const n12 = await s7.from(o14.dictionaryInfo, o14.userConfig, o14.fieldMap);
    return new _e(r17, n12);
  }
  constructor(t20, r17) {
    super(), this._context = t20, this._evaluator = r17, this._controlStringToPromise = /* @__PURE__ */ new Map(), this._controlStringToGroup = /* @__PURE__ */ new Map();
  }
  async fetchResources(t20, r17) {
    const e15 = r17.getCursor(), o14 = /* @__PURE__ */ new Set();
    for (; e15.next(); ) {
      const t21 = this._evaluateControlString(e15);
      t21 && o14.add(t21);
    }
    const n12 = Array.from(o14.values()).map((r18) => this._ensureGroup(t20, r18));
    await Promise.all(n12);
  }
  match(t20, r17) {
    const e15 = this._evaluateControlString(t20);
    return e15 ? this._controlStringToGroup.get(e15) : null;
  }
  _evaluateControlString(t20) {
    const r17 = t20.readLegacyFeatureWorldSpace();
    return this._evaluator.evaluate(r17, 0, t20.fields, null);
  }
  _ensureGroup(t20, r17) {
    let e15 = this._controlStringToPromise.get(r17);
    return null == e15 && (e15 = this._fetchGroup(t20, r17), this._controlStringToPromise.set(r17, e15)), e15;
  }
  async _fetchGroup(t20, r17) {
    const e15 = await t20.fetchDictionaryResourceImmediate({ type: "dictionary-request", controlString: r17 });
    if (!e15) return;
    const o14 = await this._context.createMeshWriters(e15.meshes);
    this._controlStringToGroup.set(r17, o14);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/IntervalMatcher.js
var t9 = class _t extends t8 {
  constructor(e15, t20) {
    super(), this._intervals = [], this._isMaxInclusive = t20, this._field = e15;
  }
  static async fromIntervalSchema(e15, s21) {
    const r17 = await e15.storage.createComputedField(s21), a16 = new _t(r17, s21.isMaxInclusive);
    await Promise.all(s21.intervals.map(async (t20) => {
      const s22 = await e15.createMeshWriters(t20.meshes);
      a16.add(t20, s22);
    }));
    const i20 = await e15.createMeshWriters(s21.defaultSymbol);
    a16.setDefault(i20);
    const n12 = await e15.createMeshWriters(s21.backgroundFill);
    return a16.setBackgroundFill(n12), a16;
  }
  add(e15, t20) {
    this._intervals.push({ interval: e15, result: t20 }), this._intervals.sort((e16, t21) => e16.interval.min - t21.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  hasArcadeDependency(e15) {
    return this._field?.hasArcadeDependency(e15) || this._intervals.some((t20) => t20.result.some((t21) => t21.hasArcadeDependency(e15)));
  }
  doMatch(e15, t20) {
    const s21 = this._field?.read(e15, t20);
    if (null == s21 || isNaN(s21) || s21 === 1 / 0 || s21 === -1 / 0) return null;
    for (let r17 = 0; r17 < this._intervals.length; r17++) {
      const { interval: e16, result: t21 } = this._intervals[r17], a16 = s21 >= e16.min, i20 = this._isMaxInclusive ? s21 <= e16.max : s21 < e16.max;
      if (a16 && i20) return t21;
    }
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/LabelMatcher.js
var s12 = class _s extends t8 {
  static async fromLabelSchema(e15, a16) {
    const r17 = a16.classes.map(async (s21) => {
      const a17 = await e15.createMeshWriters(s21.meshes);
      return { minScale: s21.minScale, maxScale: s21.maxScale, meshes: a17, expression: null, where: await e15.storage.createWhereClause(s21.where) };
    }), t20 = await Promise.all(r17);
    return new _s(t20);
  }
  constructor(e15) {
    super(), this._labels = e15;
  }
  match(e15, s21, a16) {
    if (!this._labels.length) return null;
    const r17 = this._getLabels(s21.$view.scale), t20 = [];
    for (const l13 of r17) l13.where && !l13.where(e15, a16) || t20.push(...l13.meshes);
    return t20;
  }
  hasArcadeDependency(e15) {
    return this._labels.some((s21) => s21.meshes.some((s22) => s22.hasArcadeDependency(e15)));
  }
  _getLabels(e15) {
    return this._labels.filter((s21) => this._validForTileScale(s21, e15));
  }
  _validForTileScale(e15, s21) {
    const a16 = s21 - s21 / 4, r17 = s21 + s21 / 2;
    return (!e15.minScale || e15.minScale >= a16) && (!e15.maxScale || e15.maxScale <= r17);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MapMatcher.js
var t10 = class _t extends t8 {
  constructor(e15, t20) {
    super(), this._defaultSymbolSortKey = 0, this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fields = e15, this._separator = t20 || "";
  }
  static async fromMatcherSchema(e15, s21) {
    const l13 = s21.expression ? [e15.storage.createComputedField({ expression: s21.expression })] : [s21.field ? e15.storage.createComputedField({ field: s21.field }) : null, s21.field2 ? e15.storage.createComputedField({ field: s21.field2 }) : null, s21.field3 ? e15.storage.createComputedField({ field: s21.field3 }) : null], r17 = (await Promise.all(l13)).filter((e16) => !!e16), i20 = new _t(r17, s21.fieldDelimiter), a16 = await e15.createMeshWriters(s21.defaultSymbol);
    i20.setDefault(a16);
    const u16 = await e15.createMeshWriters(s21.backgroundFill);
    return i20.setBackgroundFill(u16), await Promise.all(s21.map.map(async (t20, s22) => {
      const l14 = await e15.createMeshWriters(t20.symbol);
      "<Null>" === t20.value ? i20.setNullResult(l14) : i20.add(t20.value, l14, s22 + 1);
    })), i20;
  }
  setNullResult(e15) {
    this._nullResult = e15;
  }
  getSortKey(e15, t20) {
    const s21 = this._getValueFromFields(e15, t20);
    if (null == s21 || "" === s21 || "<Null>" === s21) return 0;
    const l13 = this._resultsMap.get(s21.toString());
    return l13 ? l13.sortKey : this._defaultSymbolSortKey;
  }
  add(e15, t20, s21) {
    this._resultsMap.set(e15.toString(), { meshWriters: t20, sortKey: s21 }), this._defaultSymbolSortKey = Math.max(this._defaultSymbolSortKey, s21 + 1);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  hasArcadeDependency(e15) {
    return this._fields.some((t20) => t20.hasArcadeDependency(e15)) || [...this._resultsMap.values()].some((t20) => t20.meshWriters.some((t21) => t21.hasArcadeDependency(e15))) || this._nullResult?.some((t20) => t20.hasArcadeDependency(e15)) || false;
  }
  doMatch(e15, t20) {
    const s21 = this._getValueFromFields(e15, t20);
    if (null !== this._nullResult && (null == s21 || "" === s21 || "<Null>" === s21)) return this._nullResult;
    if (null == s21) return null;
    const l13 = s21.toString();
    return this._resultsMap.get(l13)?.meshWriters;
  }
  _getValueFromFields(e15, t20) {
    const s21 = [];
    for (const l13 of this._fields) {
      const r17 = l13.read(e15, t20);
      null == r17 || "" === r17 ? s21.push("<Null>") : s21.push(r17);
    }
    return s21.join(this._separator);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/createMatcher.js
async function i10(e15, t20) {
  switch (t20.type) {
    case "simple":
    case "heatmap":
    case "dot-density":
    case "pie-chart":
      return t8.from(e15, t20);
    case "interval":
      return t9.fromIntervalSchema(e15, t20);
    case "dictionary":
      return e9.fromDictionaryRenderer(e15, t20);
    case "label":
      return s12.fromLabelSchema(e15, t20);
    case "map":
      return t10.fromMatcherSchema(e15, t20);
    case "subtype":
      return h4.fromSubtypes(e15, t20);
    case "cluster":
      return o3.fromClusterSchema(e15, t20);
    case "track":
      return u12.fromTrackSchema(e15, t20);
    default:
      throw new Error("Impl");
  }
}
var h4 = class _h extends t8 {
  constructor(e15, t20) {
    super(), this._subMatchers = e15, this._subtypeField = t20;
  }
  static async fromSubtypes(e15, t20) {
    const r17 = /* @__PURE__ */ new Map(), a16 = [];
    for (const s21 in t20.renderers) {
      const c10 = parseInt(s21, 10), n12 = i10(e15, t20.renderers[s21]).then((e16) => r17.set(c10, e16));
      a16.push(n12);
    }
    return await Promise.all(a16), new _h(r17, t20.subtypeField);
  }
  match(e15, t20, r17) {
    const a16 = e15.readAttribute(this._subtypeField), s21 = this._subMatchers.get(a16);
    return s21 ? s21.match(e15, t20, r17) : null;
  }
  hasArcadeDependency(e15) {
    for (const t20 of this._subMatchers.values()) if (t20.hasArcadeDependency(e15)) return true;
    return false;
  }
};
var o3 = class _o extends t8 {
  static async fromClusterSchema(e15, t20) {
    const [r17, a16] = await Promise.all([i10(e15, t20.feature), i10(e15, t20.cluster)]);
    return new _o(r17, a16);
  }
  constructor(e15, t20) {
    super(), this._featureMatcher = e15, this._clusterMatcher = t20;
  }
  match(e15, t20, r17) {
    return 1 === e15.readAttribute("cluster_count") ? this._featureMatcher.match(e15, t20, r17) : this._clusterMatcher.match(e15, t20, r17);
  }
  hasArcadeDependency(e15) {
    return this._featureMatcher.hasArcadeDependency(e15) || this._clusterMatcher.hasArcadeDependency(e15);
  }
};
var u12 = class _u extends t8 {
  static async fromTrackSchema(e15, t20) {
    const [r17, a16, s21] = await Promise.all([i10(e15, t20.previousObservation), i10(e15, t20.latestObservation), i10(e15, t20.trackLine)]);
    return new _u(r17, a16, s21);
  }
  constructor(e15, t20, r17) {
    super(), this._previousObservationMatcher = e15, this._latestObservationMatcher = t20, this._trackLineMatcher = r17;
  }
  match(r17, a16, s21) {
    switch (r17.readAttribute(r4)) {
      case s8.TrackLine:
        return this._trackLineMatcher.match(r17, a16, s21);
      case s8.LatestObservation:
        return this._latestObservationMatcher.match(r17, a16, s21);
      case s8.PreviousObservation:
        return this._previousObservationMatcher.match(r17, a16, s21);
    }
    return null;
  }
  hasArcadeDependency(e15) {
    return this._trackLineMatcher.hasArcadeDependency(e15) || this._latestObservationMatcher.hasArcadeDependency(e15) || this._previousObservationMatcher.hasArcadeDependency(e15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/FeatureMeshFactory.js
var s13 = class _s extends s11 {
  static async create(e15, o14) {
    const r17 = await i10(e15, o14.symbology), c10 = o14.labels ? await i10(e15, o14.labels) : null;
    return new _s(r17, c10);
  }
  constructor(e15, t20) {
    super(), this._symbology = e15, this._labels = t20;
  }
  destroy() {
  }
  async enqueueMatcherRequests(e15, t20) {
    await Promise.all([this._symbology.fetchResources(e15, t20), this._labels?.fetchResources(e15, t20)]);
  }
  enqueueWriterRequests(e15, t20, s21, o14) {
    const r17 = this._symbology.match(t20, s21, o14);
    if (r17) {
      for (const o15 of r17) o15.enqueueRequest(e15, t20, s21);
      if (this._labels) {
        const r18 = this._labels.match(t20, s21, o14);
        if (!r18) return;
        for (const o15 of r18) o15.enqueueRequest(e15, t20, s21);
      }
    }
  }
  write(e15, t20, s21, o14, r17, c10) {
    const a16 = this._symbology.match(s21, o14, r17);
    if (!a16) return;
    for (const n12 of a16) n12.write(e15, t20, s21, o14, c10);
    if (e15.entityRecordCount() >= 1 && this._labels) {
      const n12 = this._labels.match(s21, o14, r17);
      if (!n12) return;
      for (const r18 of n12) r18.setReferences(a16), r18.write(e15, t20, s21, o14, c10);
    }
  }
  getSortKey(e15, t20) {
    return this._symbology.getSortKey(e15, t20);
  }
  hasArcadeDependency(e15) {
    return !(!this._symbology.hasArcadeDependency(e15) && !this._labels?.hasArcadeDependency(e15));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MatcherContext.js
var s14 = class {
  constructor(s21, t20, r17, e15, i20) {
    this.storage = s21, this.proxy = t20, this.viewParams = r17, this.registry = e15, this.fieldsMap = i20;
  }
  async createMeshWriters(s21) {
    const t20 = s21.map((s22) => this.registry.createMeshWriter(this.storage, this.proxy, this.viewParams, s22, this.fieldsMap));
    return Promise.all(t20);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/ProcessorTileMessageQueue.js
var e10 = class {
  constructor(e15) {
    this._outstandingMessages = [], this._queue = new _({ concurrency: e15.concurrency, process: (s21) => e15.process(s21) });
  }
  async push(s21) {
    if (s21.end) return await Promise.all(this._outstandingMessages), await this._queue.push(s21), void (this._outstandingMessages = []);
    const e15 = this._queue.push(s21);
    return this._outstandingMessages.push(e15), e15;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/ComputedAggregateField.js
var s15 = class _s {
  static async create(i20, e15) {
    if ("count" === e15.statisticType) {
      const i21 = new r6(1);
      return new _s(e15.name, e15.alias, e15.type, e15.statisticType, i21);
    }
    const a16 = await i20.createComputedField({ expression: e15.onStatisticExpression?.expression, field: e15.onStatisticField });
    return new _s(e15.name, e15.alias, e15.type, e15.statisticType, a16);
  }
  constructor(t20, s21, i20, e15, a16) {
    this.name = t20, this.alias = s21, this.type = i20, this.statisticType = e15, this.computed = a16;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AProcessorStrategy.js
var t11 = class {
  constructor(t20) {
    this.subscription = t20, this.handledChunks = /* @__PURE__ */ new Set();
  }
  destroy() {
  }
};
var e11 = class {
  constructor(t20, e15, s21) {
    this._source = t20, this._attributeStore = e15, this._sqlOptions = s21, this._sendStates = /* @__PURE__ */ new Map();
  }
  destroy() {
  }
  get enablePixelBuffering() {
    return true;
  }
  get isAggregate() {
    return false;
  }
  onSubscribe(t20) {
    const e15 = this.createState(t20);
    this._sendStates.set(t20.key.id, e15), this.updateChunks();
  }
  onUnsubscribe(t20) {
    this._sendStates.get(t20.key.id)?.destroy(), this._sendStates.delete(t20.key.id);
  }
  get hasSubscribers() {
    return this._sendStates.size > 0;
  }
  requiresInvalidation() {
    return false;
  }
  invalidate() {
    const t20 = Array.from(this._sendStates.values());
    this._sendStates.clear();
    for (const e15 of t20) e15.destroy(), this.onSubscribe(e15.subscription);
  }
  invalidateAttributeData(t20) {
  }
  hasArcadeDependency(t20) {
    return false;
  }
  getFeatureObjectIdsForAggregate(t20) {
    throw new Error("InternalError: AggregateId lookup not supported");
  }
  getDisplayIds(t20) {
    return this.displayMap(t20, (t21) => t21, (t21) => t21);
  }
  getDisplayAndObjectIds(t20) {
    return this.displayMap(t20, (t21) => t21, (t21, e15, s21) => [t21, s21]);
  }
  afterUpdateChunks() {
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AAggregateStrategy.js
var i11 = class extends e11 {
  constructor(r17, t20, s21, n12, i20) {
    super(r17, t20, i20), this.spatialReference = s21, this.aggregateFields = n12, this._arcadeDependencies = /* @__PURE__ */ new Set(), this.events = new o(), this.featureAdapter = e4;
    for (const e15 of n12) d2(this._arcadeDependencies, e15.computed);
  }
  get aggregateQueryEngine() {
    return this._aggregateQueryEngine || (this._aggregateQueryEngine = new L3({ featureStore: this, fieldsIndex: this._metadata.fieldsIndex, geometryType: this._metadata.geometryType, featureIdInfo: this._metadata.featureIdInfo, spatialReference: this.spatialReference })), this._aggregateQueryEngine;
  }
  get isAggregate() {
    return true;
  }
  removeChunks(e15) {
  }
  hasArcadeDependency(e15) {
    return this._arcadeDependencies.has(e15);
  }
  forEach(e15) {
    return this.forEachAggregateWorldSpace(e15);
  }
  forEachInBounds(e15, r17) {
  }
  forEachBounds(e15, a16) {
    const s21 = u6();
    for (const r17 of e15) {
      const e16 = Mt(s21, r17.geometry, false, false);
      e16 && a16(e16);
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceMessage.js
var e12 = class {
  constructor(e15, i20, t20, s21, r17) {
    this.subscription = e15, this.reader = i20, this.clear = t20, this.end = s21, this.debugInfo = r17, this.type = "append";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e15, i20, t20) {
    return { type: "append", clear: this.clear, id: this.id, append: e15, end: this.end, debugInfo: this.debugInfo, subscriptionVesrion: this.subscription.version, version: i20, attributeEpoch: t20 };
  }
};
var i12 = class {
  constructor(e15, i20, t20, s21, r17) {
    this.subscription = e15, this.reader = i20, this.remove = t20, this.end = s21, this.debugInfo = r17, this.type = "update";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e15, i20, t20) {
    return { type: "update", id: this.id, modify: e15, debugInfo: this.debugInfo, remove: this.remove, version: i20, subscriptionVesrion: this.subscription.version, end: this.end, attributeEpoch: t20 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/BinningStrategy.js
var g3 = class extends t11 {
  constructor(e15, t20) {
    super(e15), this.bins = /* @__PURE__ */ new Map(), this.featureCache = /* @__PURE__ */ new Map(), this.done = false, this._store = t20;
  }
  reset() {
    this.destroy(), this.done = false;
  }
  destroy() {
    const e15 = this.subscription.tile.key.level;
    for (const t20 of this.featureCache.keys()) this._store.releaseDisplayIdForObjectId(`${t20}.${e15}`);
    this.bins.clear(), this.featureCache.clear(), this.handledChunks.clear();
  }
  get tile() {
    return this.subscription.tile;
  }
  *featuresWorldSpace() {
    for (const e15 of this.featureCache.values()) {
      const t20 = e15.clone();
      t20.geometry && wt(t20.geometry, t20.geometry, false, false, this.subscription.tile.transform), yield t20;
    }
  }
};
var y3 = class _y extends i11 {
  static async create(t20, s21, a16, i20, n12, l13) {
    const d11 = new l3({ spatialReference: s21 }), c10 = await Promise.all(t20.fields.map(async (e15) => s15.create(d11, e15))), p6 = t20.featureFilter ? await p2.create({ geometryType: a16.metadata.geometryType, hasM: false, hasZ: false, timeInfo: a16.metadata.timeInfo, fieldsIndex: a16.metadata.fieldsIndex, spatialReference: s21, filterJSON: t20.featureFilter }) : null;
    return "geohash" === t20.index.type && await x(s21, f2.WGS84), new _y(t20, p6, n12, c10, s21, a16, i20, l13);
  }
  constructor(e15, t20, s21, a16, r17, o14, n12, l13) {
    super(o14, n12, r17, a16, l13), this._schema = e15, this._featureFilter = t20, this._arcadeContextInfo = s21, this._metadata = i7.createFeature({ geometryType: "esriGeometryPolygon", featureIdInfo: { type: "object-id", fieldName: "aggregateId" }, fieldsIndex: new Z2(e15.fields).toJSON(), globalIdField: null, spatialReference: o14.metadata.spatialReference, outSpatialReference: o14.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  createState(e15) {
    return new g3(e15, this._attributeStore);
  }
  async *applyOverrideUpdate(e15) {
    for (const t20 of this._sendStates.values()) {
      t20.reset();
      const e16 = new e12(t20.subscription, u9.empty(this._source.metadata), true, false, {});
      yield e16;
    }
  }
  displayMap(e15, t20, s21) {
    const a16 = new Map(e15.map((e16) => [t20(e16), e16])), r17 = [];
    for (const i20 of this._sendStates.values()) for (const e16 of i20.featuresWorldSpace()) {
      const { objectId: t21, displayId: i21 } = e16, o14 = a16.get(t21);
      if (null != o14) {
        const e17 = s21(i21, o14, t21);
        r17.push(e17), a16.delete(t21);
      }
    }
    return r17;
  }
  getDisplayFeatures(e15) {
    const s21 = new Set(e15), a16 = /* @__PURE__ */ new Set(), r17 = [];
    for (const i20 of this._sendStates.values()) for (const e16 of i20.featuresWorldSpace()) s21.has(e16.displayId) && !a16.has(e16.objectId) && (e16.geometry && r17.push({ ...st(e16, this._metadata.geometryType, false, false), displayId: e16.displayId }), a16.add(e16.objectId));
    return { features: [], aggregates: r17, tracks: [] };
  }
  getFeatureObjectIdsForAggregate(e15) {
    for (const t20 of this._sendStates.values()) for (const s21 of t20.bins.values()) if (s21.id === e15) return Array.from(s21.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    for (const e15 of this._sendStates.values()) yield* this._update(e15, this._source);
  }
  forEachAggregateWorldSpace(e15) {
    const t20 = /* @__PURE__ */ new Set();
    for (const s21 of this._sendStates.values()) for (const a16 of s21.featuresWorldSpace()) t20.has(a16.objectId) || (e15(a16), t20.add(a16.objectId));
  }
  _createIndexOptions(e15) {
    switch (this._schema.index.type) {
      case "geohash":
        return { type: "geohash", fields: this.aggregateFields, featureFilter: this._featureFilter, geohashLevel: this._schema.index.fixBinLevel, spatialReference: this.spatialReference, arcadeContextInfo: this._arcadeContextInfo, scale: e15.scale, sqlOptions: this._sqlOptions };
      case "grid": {
        const t20 = this._schema.index.fixedBinLevel, s21 = null != t20 ? e15.tileInfoView.getLODInfoAt(t20).scale : e15.scale;
        return { type: "grid", fields: this.aggregateFields, cellSize: this._schema.index.size, featureFilter: this._featureFilter, spatialReference: this.spatialReference, arcadeContextInfo: this._arcadeContextInfo, scale: s21, sqlOptions: this._sqlOptions };
      }
    }
  }
  async *_update(e15, t20) {
    const { handledChunks: s21, subscription: r17, bins: i20, featureCache: o14 } = e15, n12 = r17.tile;
    if (e15.done) return;
    for (const a16 of t20.chunks()) {
      if (s21.has(a16.chunkId)) continue;
      s21.add(a16.chunkId);
      const t21 = a16.queryInfo;
      if ("tileId" in t21) {
        const e16 = new e6(t21.tileId);
        if (e16.level !== n12.level || e16.world !== n12.key.world) continue;
      }
      a16.getAggregateIndex(this._createIndexOptions(e15.tile)).putBounded(i20, e15.tile.extent, e15.tile.resolution);
    }
    const l13 = [], d11 = r17.tile.transform, u16 = r17.tile.key.level;
    for (const c10 of i20.values()) {
      let e16 = o14.get(c10.id);
      if (e16) e16.attributes = c10.getAttributes();
      else {
        const t21 = c10.getGeometry(this.spatialReference, d11);
        e16 = new s5(t21, c10.getAttributes(), null, c10.id), t21 || (e16.centroid = c10.getGeometricCentroid(this.spatialReference, d11)), e16.displayId = this._attributeStore.createDisplayIdForObjectId(`${e16.objectId}.${u16}`), o14.set(c10.id, e16);
      }
      l13.push(e16);
    }
    this.events.emit("changed"), e15.done = !t20.updateTracking.updating;
    const f6 = u9.fromOptimizedFeatures(l13, this._metadata, d11), p6 = f6.getCursor(), g6 = e15.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo);
    for (; p6.next(); ) this._attributeStore.setAttributeData(p6.getDisplayId(), p6, g6, this._sqlOptions);
    const y8 = new i12(e15.subscription, f6, [], e15.done, {});
    yield y8;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateCell.js
var t12 = class {
  constructor(t20) {
    this._statistics = t20;
  }
  get statistics() {
    return this._statistics;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AccumulatedStatistics.js
var e13 = Math.PI / 180;
var s16 = class _s {
  static create(t20) {
    return new _s(t20.map((t21) => i13(t21)));
  }
  constructor(t20) {
    this._statistics = t20;
  }
  values() {
    return this._statistics.values();
  }
  insert(t20, e15) {
    for (const s21 of this._statistics) s21.insert(t20, e15);
  }
  merge(t20) {
    for (let e15 = 0; e15 < this._statistics.length; e15++) {
      const s21 = this._statistics[e15], i20 = t20._statistics[e15];
      if (s21.field.name !== i20.field.name) throw new Error("InternalError: Tried to merge incompatible statistics");
      s21.merge(i20);
    }
  }
  clone() {
    return new _s(this._statistics.map((t20) => t20.clone()));
  }
};
function i13(t20) {
  switch (t20.statisticType) {
    case "min":
      return new r11(t20);
    case "max":
      return new u13(t20);
    case "avg":
      return new c6(t20);
    case "avg_angle":
      return new h5(t20);
    case "sum":
    case "count":
      return new a10(t20);
    case "mode":
      return new o4(t20);
  }
}
var n6 = class {
  constructor(t20) {
    this.field = t20;
  }
  insert(e15, s21) {
    if (!this.field.computed) return;
    const i20 = this.field.computed.read(e15, s21);
    r7(i20) || this._insertValue(i20);
  }
};
var r11 = class _r extends n6 {
  constructor() {
    super(...arguments), this.type = "min", this.value = Number.MAX_VALUE;
  }
  _insertValue(t20) {
    this.value = Math.min(this.value, t20);
  }
  merge(t20) {
    this.value = Math.min(this.value, t20.value);
  }
  clone() {
    const t20 = new _r(this.field);
    return t20.value = this.value, t20;
  }
};
var u13 = class _u extends n6 {
  constructor() {
    super(...arguments), this.type = "max", this.value = Number.MIN_VALUE;
  }
  _insertValue(t20) {
    this.value = Math.max(this.value, t20);
  }
  merge(t20) {
    this.value = Math.max(this.value, t20.value);
  }
  clone() {
    const t20 = new _u(this.field);
    return t20.value = this.value, t20;
  }
};
var a10 = class _a extends n6 {
  constructor() {
    super(...arguments), this.type = "sum", this.value = 0;
  }
  _insertValue(t20) {
    this.value += t20;
  }
  merge(t20) {
    this.value += t20.value;
  }
  clone() {
    const t20 = new _a(this.field);
    return t20.value = this.value, t20;
  }
};
var c6 = class _c extends n6 {
  constructor() {
    super(...arguments), this.type = "avg", this._total = 0, this._count = 0;
  }
  get value() {
    return this._total / this._count;
  }
  _insertValue(t20) {
    this._total += t20, this._count += 1;
  }
  merge(t20) {
    this._total += t20._total, this._count += t20._count;
  }
  clone() {
    const t20 = new _c(this.field);
    return t20._total = this._total, t20._count = this._count, t20;
  }
};
var h5 = class _h extends n6 {
  constructor() {
    super(...arguments), this.type = "avg_angle", this._x = 0, this._y = 0, this._count = 0;
  }
  get value() {
    const t20 = this._x / this._count, e15 = this._y / this._count, s21 = 180 / Math.PI;
    return Math.atan2(e15, t20) * s21;
  }
  _insertValue(t20) {
    this._x = this._x + Math.cos(t20 * e13), this._y = this._y + Math.sin(t20 * e13), this._count += 1;
  }
  merge(t20) {
    this._x += t20._x, this._y += t20._y, this._count += t20._count;
  }
  clone() {
    const t20 = new _h(this.field);
    return t20._x = this._x, t20._y = this._y, t20._count = this._count, t20;
  }
};
var o4 = class _o extends n6 {
  constructor() {
    super(...arguments), this._frequencies = /* @__PURE__ */ new Map();
  }
  get value() {
    let t20, e15 = 0;
    for (const [s21, i20] of this._frequencies.entries()) i20 > e15 && (e15 = i20, t20 = s21);
    return t20;
  }
  _insertValue(t20) {
    const e15 = this._frequencies.get(t20);
    null != e15 ? this._frequencies.set(t20, e15 + 1) : this._frequencies.set(t20, 1);
  }
  merge(t20) {
    for (const [e15, s21] of t20._frequencies.entries()) {
      const t21 = this._frequencies.get(e15);
      null != t21 ? this._frequencies.set(e15, t21 + s21) : this._frequencies.set(e15, s21);
    }
  }
  clone() {
    const t20 = new _o(this.field);
    return t20._frequencies = new Map(this._frequencies), t20;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridCell.js
var l5 = class _l extends t12 {
  static createId(t20, e15) {
    return `${t20}.${e15}`;
  }
  static create(t20, e15, r17, i20) {
    return new _l(t20, e15, s16.create(r17), i20);
  }
  constructor(t20, e15, r17, i20) {
    super(r17), this.gridX = t20, this.gridY = e15, this._worldUnitsPerCell = i20, this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._objectIds = /* @__PURE__ */ new Set();
  }
  get id() {
    return _l.createId(this.gridX, this.gridY);
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  get firstObjectId() {
    return this._objectIds.values().next().value;
  }
  get centroidXWorld() {
    return this._xWorldTotal / this._count;
  }
  get centroidYWorld() {
    return this._yWorldTotal / this._count;
  }
  clone() {
    const t20 = new _l(this.gridX, this.gridY, this._statistics.clone(), this._worldUnitsPerCell);
    return t20._count = this._count, t20._xWorldTotal = this._xWorldTotal, t20._yWorldTotal = this._yWorldTotal, t20._firstFeatureAttributes = this._firstFeatureAttributes, t20._objectIds = new Set(this._objectIds), t20;
  }
  insert(t20, e15, r17, i20) {
    0 === this._count ? this._firstFeatureAttributes = t20.readAttributes() : this._firstFeatureAttributes = null, this._count += 1, this._xWorldTotal += r17, this._yWorldTotal += i20, this._statistics.insert(t20, e15), this._objectIds.add(t20.getObjectId());
  }
  merge(t20) {
    if (0 !== t20._count) {
      this._count += t20._count, this._firstFeatureAttributes = t20._firstFeatureAttributes, this._xWorldTotal += t20._xWorldTotal, this._yWorldTotal += t20._yWorldTotal, this._statistics.merge(t20._statistics);
      for (const e15 of t20._objectIds.values()) this._objectIds.add(e15);
    }
  }
  getCentroidX(e15) {
    return null == e15 ? this.centroidXWorld : b3(e15, this.centroidXWorld);
  }
  getCentroidY(t20) {
    return null == t20 ? this.centroidYWorld : T(t20, this.centroidYWorld);
  }
  getGeometry(t20, e15) {
    const s21 = this.gridX * this._worldUnitsPerCell, o14 = this.gridY * this._worldUnitsPerCell, l13 = new e2([4], [s21, o14, s21 + this._worldUnitsPerCell, o14, s21 + this._worldUnitsPerCell, o14 + this._worldUnitsPerCell, s21, o14 + this._worldUnitsPerCell]);
    if (null != e15) {
      const t21 = new e2();
      return gt(t21, l13, false, false, "esriGeometryPolygon", e15);
    }
    return l13;
  }
  getCentroid(t20) {
    const e15 = new e2([], [this.centroidXWorld, this.centroidYWorld]);
    if (null != t20) {
      const s21 = new e2();
      return gt(s21, e15, false, false, "esriGeometryPoint", t20);
    }
    return e15;
  }
  getGeometricCentroid(t20, e15) {
    const s21 = this.gridX * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, o14 = this.gridY * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, l13 = new e2([], [s21, o14]);
    if (null != e15) {
      const t21 = new e2();
      return gt(t21, l13, false, false, "esriGeometryPoint", e15);
    }
    return l13;
  }
  getAttributes() {
    const t20 = { aggregateId: this.id };
    for (const e15 of this._statistics.values()) t20[e15.field.name] = e15.value;
    return null != this._firstFeatureAttributes ? { ...t20, ...this._firstFeatureAttributes } : t20;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateSpatialIndex.js
var r12 = class {
  constructor(t20) {
    this._options = t20;
  }
  insert(t20, r17) {
    const o14 = t20.getCursor(), { arcadeContextInfo: s21, scale: i20 } = this._options, n12 = e7(i20, s21);
    for (; o14.next(); ) this._insertFeature(o14, n12, this._options.sqlOptions, r17);
  }
  _insertFeature(e15, r17, o14, s21) {
    const { featureFilter: i20 } = this._options;
    if (null !== i20 && !i20.check(e15, o14)) return;
    let n12 = 0, c10 = 0;
    if ("esriGeometryPoint" === e15.geometryType) n12 = e15.readXWorldSpace(), c10 = e15.readYWorldSpace();
    else {
      if (s21) {
        const r19 = e15.readCentroidForDisplay();
        if (null == r19) return;
        const [o15, s22] = r19.coords;
        if (o15 < 0 || o15 > a7 || s22 < 0 || s22 > a7) return;
      }
      const r18 = e15.readCentroidWorldSpace();
      if (null == r18) return;
      n12 = r18.coords[0], c10 = r18.coords[1];
    }
    this._insert(e15, n12, c10, r17);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridSpatialIndex.js
var l6 = 96;
function o5(i20, s21) {
  return Z(i20) * l2 * l6 / s21;
}
var n7 = class extends r12 {
  constructor(t20) {
    super(t20), this._cells = /* @__PURE__ */ new Map(), this._pixelsPerMapUnit = o5(t20.spatialReference, t20.scale);
  }
  put(t20) {
    for (const e15 of this._cells.values()) {
      const i20 = t20.get(e15.id);
      i20 ? i20.merge(e15) : t20.set(e15.id, e15.clone());
    }
  }
  putBounded(t20, e15, i20) {
    const s21 = [e15.xmin, e15.ymin, e15.xmax, e15.ymax], [l13, o14, n12, r17] = s21, c10 = Math.floor(l13 * this._pixelsPerMapUnit / this._options.cellSize), p6 = Math.floor(o14 * this._pixelsPerMapUnit / this._options.cellSize), a16 = Math.ceil(n12 * this._pixelsPerMapUnit / this._options.cellSize), h7 = Math.ceil(r17 * this._pixelsPerMapUnit / this._options.cellSize);
    for (let _5 = p6; _5 <= h7; _5++) for (let e16 = c10; e16 <= a16; e16++) {
      const i21 = `${e16}.${_5}`, s22 = this._cells.get(i21);
      if (!s22) continue;
      const l14 = t20.get(s22.id);
      l14 ? s22 && !t20.has(s22.id) && l14.merge(s22) : t20.set(s22.id, s22.clone());
    }
  }
  _insert(t20, e15, i20, s21) {
    const l13 = e15 * this._pixelsPerMapUnit, o14 = i20 * this._pixelsPerMapUnit, n12 = Math.floor(l13 / this._options.cellSize), r17 = Math.floor(o14 / this._options.cellSize);
    this._getCellOrCreate(n12, r17).insert(t20, s21, e15, i20);
  }
  _getCellOrCreate(t20, e15) {
    const i20 = l5.createId(t20, e15);
    let l13 = this._cells.get(i20);
    if (!l13) {
      const o14 = 1 * this._options.cellSize / this._pixelsPerMapUnit;
      l13 = l5.create(t20, e15, this._options.fields, o14), this._cells.set(i20, l13);
    }
    return l13;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/support/WithDisplayId.js
var s17 = class {
  constructor(s21, t20) {
    this.inner = s21, this.displayId = t20;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/ClusterStrategy.js
var m6 = 128;
var y4 = class extends t11 {
  constructor(e15) {
    super(e15), this.didSend = false, this.done = false;
  }
};
var S2 = class {
  constructor(e15, t20, s21, i20, r17) {
    this._level = e15, this._scale = t20, this._indexOptions = s21, this._clusterRadius = i20, this._store = r17, this._cells = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._statistics = /* @__PURE__ */ new Map(), this._clusters = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._clearClusters();
  }
  _clearClusters() {
    for (const e15 of this._clusters.values()) this._store.releaseDisplayIdForObjectId(e15.inner.id);
    this._clusters.clear();
  }
  *aggregatesWorldSpace() {
    for (const e15 of this._clusters.values()) {
      const s21 = e15.inner.getCentroid(null), i20 = new s5(s21, e15.inner.getAttributes(), null, e15.inner.id, e15.displayId);
      yield i20;
    }
  }
  clusters() {
    return this._clusters.values();
  }
  updateChunks(e15, t20) {
    let s21 = false;
    for (const a16 of e15) {
      const e16 = a16.queryInfo;
      if ("tileId" in e16) {
        if (new e6(e16.tileId).level !== this._level) continue;
      }
      if (!this._handledChunks.has(a16.normalizedChunkId)) {
        this._handledChunks.add(a16.normalizedChunkId), s21 = true;
        a16.getAggregateIndex({ ...this._indexOptions, scale: this._scale }).put(this._cells);
      }
    }
    const i20 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 }, r17 = o5(this._indexOptions.spatialReference, this._scale), n12 = this._indexOptions.cellSize;
    for (const { subscription: a16 } of t20) {
      const e16 = a16.tile.bounds, t21 = Math.floor(e16[0] * r17 / n12), s22 = Math.floor(e16[1] * r17 / n12), l13 = Math.ceil(e16[2] * r17 / n12), o14 = Math.ceil(e16[3] * r17 / n12);
      i20.xMin = Math.min(i20.xMin, t21), i20.yMin = Math.min(i20.yMin, s22), i20.xMax = Math.max(i20.xMax, l13), i20.yMax = Math.max(i20.yMax, o14);
    }
    return null != this._lastCellBounds && i20.xMin === this._lastCellBounds.xMin && i20.yMin === this._lastCellBounds.yMin && i20.yMin === this._lastCellBounds.yMin && i20.yMax === this._lastCellBounds.yMax || (s21 = true, this._lastCellBounds = i20), s21 && this._clusterCells(i20), s21;
  }
  async updateStatistics(e15) {
    let t20 = false;
    for (const s21 of this._clusters.values()) s21.inner.count > 1 && (t20 = this._updateAggregateStatistics(this._statistics, s21.inner) || t20);
    if (t20) {
      const t21 = Array.from(this._statistics.entries()).map(([e16, t22]) => ({ fieldName: e16, minValue: t22.minValue, maxValue: t22.maxValue }));
      await e15.container.updateStatistics(this._level, t21);
    }
  }
  createAggregateFeatures(e15, i20) {
    const n12 = e15.subscription, a16 = [], l13 = n12.tile.transform;
    for (const o14 of this._clusters.values()) {
      let e16 = o14.inner.getCentroidX(l13);
      const i21 = o14.inner.getCentroidY(l13), d11 = n12.tile.lod, u16 = d11.wrap ? d11.worldSize[0] : null, c10 = 1 === o14.inner.count ? o14.inner.firstObjectId : o14.inner.id, h7 = o14.displayId;
      if (null != u16) if (1 === u16) {
        const n13 = new e2([], [e16, i21]), l14 = new s5(n13, o14.inner.getAttributes(), null, c10, h7);
        l14.geometry.coords[0] -= a7, a16.push(l14);
        const d12 = new e2([], [e16, i21]), u17 = new s5(d12, o14.inner.getAttributes(), null, c10, h7);
        u17.geometry.coords[0] += a7, a16.push(u17);
      } else e16 > a7 + a7 / 2 ? e16 -= u16 * a7 : e16 < -256 && (e16 += u16 * a7);
      if (e16 < a7 + m6 && e16 >= -128 && i21 < a7 + m6 && i21 >= -128) {
        const r17 = new e2([], [e16, i21]), n13 = new s5(r17, o14.inner.getAttributes(), null, c10, h7);
        a16.push(n13);
      }
    }
    return u9.fromOptimizedFeatures(a16, i20, n12.tile.transform);
  }
  _clusterCells(e15) {
    let t20 = Array.from(this._cells.values());
    t20 = t20.sort((e16, t21) => t21.count - e16.count);
    const s21 = [];
    for (const a16 of this._clusters.values()) s21.push(a16.inner.id);
    this._clusters.clear();
    const i20 = this._clusterRadius * (1 / o5(this._indexOptions.spatialReference, this._scale)), r17 = 1 + this._clusterRadius / this._indexOptions.cellSize, n12 = /* @__PURE__ */ new Set();
    for (const l13 of t20) {
      if (n12.has(l13.id)) continue;
      if (l13.gridX < e15.xMin || l13.gridX > e15.xMax || l13.gridY < e15.yMin || l13.gridY > e15.yMax) continue;
      const t21 = this._store.createDisplayIdForObjectId(l13.id), s22 = new s17(l13.clone(), t21);
      n12.add(l13.id), this._clusters.set(l13.id, s22);
      const o14 = l13.centroidXWorld, d11 = l13.centroidYWorld;
      for (let e16 = l13.gridY - r17; e16 <= l13.gridY + r17; e16++) for (let t22 = l13.gridX - r17; t22 <= l13.gridX + r17; t22++) {
        if (e16 === l13.gridY && t22 === l13.gridX) continue;
        const r18 = this._cells.get(l5.createId(t22, e16));
        if (!r18 || n12.has(r18.id)) continue;
        const u16 = Math.abs(r18.centroidXWorld - o14), c10 = Math.abs(r18.centroidYWorld - d11);
        u16 < i20 && c10 < i20 && (s22.inner.merge(r18), n12.add(r18.id));
      }
    }
    for (const a16 of s21) this._store.releaseDisplayIdForObjectId(a16);
  }
  _updateAggregateStatistics(e15, t20) {
    let s21 = false;
    for (const i20 of t20.statistics.values()) {
      if ("esriFieldTypeString" === i20.field.type) continue;
      const t21 = i20.value, r17 = i20.field, n12 = e15.get(r17.name);
      if (n12) {
        const { minValue: e16, maxValue: i21 } = n12, r18 = Math.min(n12.minValue, t21), a16 = Math.max(n12.maxValue, t21);
        e16 === r18 && i21 === a16 || (n12.minValue = r18, n12.maxValue = a16, s21 = true);
      } else e15.set(r17.name, { minValue: t21, maxValue: t21 }), s21 = true;
    }
    return s21;
  }
};
var x3 = class _x extends i11 {
  static async create(e15, t20, s21, i20, r17, a16, l13) {
    const o14 = new l3({ spatialReference: s21 }), d11 = { type: "grid", fields: await Promise.all(t20.fields.map(async (e16) => s15.create(o14, e16))), spatialReference: s21, featureFilter: t20.featureFilter ? await p2.create({ geometryType: i20.metadata.geometryType, hasM: false, hasZ: false, timeInfo: i20.metadata.timeInfo, fieldsIndex: i20.metadata.fieldsIndex, spatialReference: s21, filterJSON: t20.featureFilter }) : null, cellSize: t20.clusterRadius / 4, arcadeContextInfo: a16, sqlOptions: l13 };
    return new _x(e15, t20.clusterRadius, d11, t20.fields, i20, r17, l13);
  }
  constructor(e15, t20, s21, r17, n12, a16, l13) {
    super(n12, a16, s21.spatialReference, s21.fields, l13), this._connection = e15, this._clusterRadius = t20, this._indexOptions = s21, this._cellsPerScale = /* @__PURE__ */ new Map(), this._metadata = i7.createFeature({ geometryType: "esriGeometryPoint", featureIdInfo: { type: "object-id", fieldName: "aggregateId" }, fieldsIndex: new Z2([...r17, ...this._source.metadata.fieldsIndex.fields, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }]).toJSON(), globalIdField: null, spatialReference: n12.metadata.spatialReference, outSpatialReference: n12.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  get enablePixelBuffering() {
    return false;
  }
  invalidate() {
    super.invalidate();
    for (const e15 of this._cellsPerScale.values()) e15.destroy();
    this._cellsPerScale.clear();
  }
  onSubscribe(e15) {
    super.onSubscribe(e15), this._requiredLevel = e15.tile.level, this._requiredScale = e15.tile.scale;
  }
  createState(e15) {
    return new y4(e15);
  }
  async *applyOverrideUpdate(e15) {
    for (const t20 of this._cellsPerScale.values()) t20.destroy();
    this._cellsPerScale.clear();
    for (const t20 of this._sendStates.values()) t20.done = false;
  }
  displayMap(e15, t20, s21) {
    const i20 = new Map(e15.map((e16) => [t20(e16), e16])), r17 = [], n12 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const a16 of n12.clusters()) {
      const e16 = i20.get(a16.inner.id);
      if (null == e16) {
        if (1 === a16.inner.count) {
          const { firstObjectId: e17 } = a16.inner, t21 = e17 ? i20.get(e17) : null;
          if (null != t21) {
            const n13 = s21(a16.displayId, t21, e17);
            r17.push(n13), i20.delete(e17);
          }
        }
      } else {
        const t21 = s21(a16.displayId, e16, a16.inner.id);
        r17.push(t21), i20.delete(a16.inner.id);
      }
    }
    return r17;
  }
  getDisplayFeatures(t20) {
    const s21 = new Set(t20), i20 = /* @__PURE__ */ new Set(), r17 = [], n12 = [], a16 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const l13 of a16.aggregatesWorldSpace()) if (s21.has(l13.displayId) && !i20.has(l13.displayId)) {
      const t21 = st(l13, this._metadata.geometryType, false, false);
      if (i20.add(l13.displayId), 1 === t21.attributes.cluster_count) {
        r17.push({ ...t21, displayId: l13.displayId });
        continue;
      }
      n12.push({ ...t21, displayId: l13.displayId });
    }
    return { features: r17, aggregates: n12, tracks: [] };
  }
  getFeatureObjectIdsForAggregate(e15) {
    const t20 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s21 of t20.clusters()) if (s21.inner.id === e15) return Array.from(s21.inner.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    const e15 = this._source.chunks();
    if (!e15.length) return;
    const t20 = this._getClusterState(this._requiredLevel, this._requiredScale), s21 = Array.from(this._sendStates.values()).filter((e16) => e16.subscription.tile.level === this._requiredLevel);
    if (t20.updateChunks(e15, s21) || !this._source.updateTracking.updating) for (const n12 of s21) n12.subscription.tile.level === this._requiredLevel && (n12.didSend = false, n12.done = false);
    const i20 = Array.from(this._sendStates.values()).filter((e16) => e16.done).map((e16) => e16.subscription.tile.key), r17 = new Set(i20);
    for (const n12 of this._sendStates.values()) {
      if (this._source.updateTracking.updating) {
        if (i20.some((e16) => e16.containsChild(n12.subscription.tile.key))) continue;
        if (n12.subscription.tile.key.getChildKeys().every((e16) => r17.has(e16))) continue;
      }
      n12.didSend || n12.subscription.tile.level !== this._requiredLevel || (n12.didSend = true, yield* this._update(n12, t20, this._source));
    }
    await t20.updateStatistics(this._connection);
  }
  forEachAggregateWorldSpace(e15) {
    if (null == this._requiredLevel || null == this._requiredScale) return;
    const t20 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s21 of t20.aggregatesWorldSpace()) e15(s21);
  }
  _getClusterState(e15, t20) {
    if (null == e15 || null == t20) throw new Error("InternalError: Level and scale must be defined");
    let s21 = this._cellsPerScale.get(t20);
    return s21 || (s21 = new S2(e15, t20, this._indexOptions, this._clusterRadius, this._attributeStore), this._cellsPerScale.set(t20, s21)), s21;
  }
  async *_update(e15, t20, s21) {
    if (e15.done) return;
    const i20 = t20.createAggregateFeatures(e15, this._metadata);
    this.events.emit("changed"), e15.done = !s21.updateTracking.updating;
    const r17 = i20.getCursor(), n12 = e15.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.arcadeContextInfo);
    for (; r17.next(); ) this._attributeStore.setAttributeData(r17.getDisplayId(), r17, n12, this._sqlOptions);
    const a16 = new e12(e15.subscription, i20, true, e15.done, {});
    yield a16;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSpatialIndex.js
var t13 = class _t {
  static fromReader(o14) {
    const e15 = [], r17 = o14.copy(), a16 = u6();
    for (; r17.next(); ) {
      r17.getBounds(a16) && e15.push(r17.getIndex());
    }
    const i20 = i8(9, (n12) => (r17.setIndex(n12), { minX: r17.getBoundsXMin(), minY: r17.getBoundsYMin(), maxX: r17.getBoundsXMax(), maxY: r17.getBoundsYMax() }));
    return i20.load(e15), new _t(i20);
  }
  constructor(n12) {
    this._index = n12;
  }
  search(n12) {
    const s21 = { minX: n12[0], minY: n12[1], maxX: n12[2], maxY: n12[3] };
    return this._index.search(s21);
  }
};

// node_modules/@arcgis/core/geohash/geohashUtils.js
var g4 = n3();
var x4 = n3();
var b5 = 64;
function v2(t20, o14, r17, i20) {
  const a16 = [t20.xmin, t20.ymin, t20.xmax, t20.ymax], u16 = P.fromExtent(c(a16, i20)), h7 = j2(u16, i20, f2.WGS84, { densificationStep: o14 * b5 });
  if (!h7) return null;
  const m11 = X(new e2(), h7, false, false), p6 = m11.coords.filter((t21, o15) => !(o15 % 2)), g6 = m11.coords.filter((t21, o15) => o15 % 2), x6 = Math.min(...p6), y8 = Math.min(...g6), d11 = Math.max(...p6), j4 = Math.max(...g6), M3 = G(x6, y8, r17, f2.WGS84), S4 = G(d11, j4, r17, f2.WGS84);
  return M3 && S4 ? { bounds: a16, geohashBounds: { xLL: M3[0], yLL: M3[1], xTR: S4[0], yTR: S4[1] }, level: r17 } : null;
}
function G(o14, r17, n12, s21) {
  if (s21.isWebMercator) {
    const e15 = M(o14 / t4.radius), s22 = e15 - 360 * Math.floor((e15 + 180) / 360), c11 = [0, 0];
    return B(c11, 0, M(Math.PI / 2 - 2 * Math.atan(Math.exp(-r17 / t4.radius))), s22, n12), c11;
  }
  const c10 = j2({ x: o14, y: r17 }, s21, f2.WGS84);
  if (!c10) return null;
  const f6 = [0, 0];
  return B(f6, 0, c10.y, c10.x, n12), f6;
}
function w(t20, o14) {
  let r17 = -90, n12 = 90, e15 = -180, s21 = 180;
  for (let i20 = 0; i20 < o14; i20++) {
    const o15 = Math.ceil((i20 + 1) / 2), c10 = Math.floor((i20 + 1) / 2), f6 = 1 - i20 % 2, l13 = 30 - (3 * o15 + 2 * c10), a16 = 30 - (2 * o15 + 3 * c10), u16 = 3 * f6 + 2 * (1 - f6), h7 = 2 * f6 + 3 * (1 - f6), m11 = 3 * f6 + 7 * (1 - f6) << a16, p6 = (7 * f6 + 3 * (1 - f6) << l13 & t20.geohashX) >> l13, g6 = (m11 & t20.geohashY) >> a16;
    for (let t21 = u16 - 1; t21 >= 0; t21--) {
      const o16 = (e15 + s21) / 2, r18 = p6 & 1 << t21 ? 1 : 0;
      e15 = (1 - r18) * e15 + r18 * o16, s21 = (1 - r18) * o16 + r18 * s21;
    }
    for (let t21 = h7 - 1; t21 >= 0; t21--) {
      const o16 = (r17 + n12) / 2, e16 = g6 & 1 << t21 ? 1 : 0;
      r17 = (1 - e16) * r17 + e16 * o16, n12 = (1 - e16) * o16 + e16 * n12;
    }
  }
  return [e15, r17, s21, n12];
}
function B(t20, o14, r17, n12, e15) {
  e15 % 2 && (e15 += 1);
  let s21 = 0, i20 = 0, c10 = -90, f6 = 90, l13 = -180, a16 = 180;
  for (let u16 = 0; u16 < e15 / 2; u16++) {
    for (let t21 = 0; t21 < 5; t21++) {
      const o15 = (l13 + a16) / 2, r18 = n12 > o15 ? 1 : 0;
      s21 |= r18 << 29 - (t21 + 5 * u16), l13 = (1 - r18) * l13 + r18 * o15, a16 = (1 - r18) * o15 + r18 * a16;
    }
    for (let t21 = 0; t21 < 5; t21++) {
      const o15 = (c10 + f6) / 2, n13 = r17 > o15 ? 1 : 0;
      i20 |= n13 << 29 - (t21 + 5 * u16), c10 = (1 - n13) * c10 + n13 * o15, f6 = (1 - n13) * o15 + n13 * f6;
    }
  }
  t20[2 * o14] = s21, t20[2 * o14 + 1] = i20;
}

// node_modules/@arcgis/core/geohash/GeohashCell.js
var l7 = class _l extends t12 {
  static create(t20, e15, o14, s21) {
    const r17 = s16.create(t20), i20 = new Array(32);
    for (let h7 = 0; h7 < i20.length; h7++) i20[h7] = null;
    return new _l(r17, e15, o14, s21, i20);
  }
  constructor(t20, e15, o14, s21, r17) {
    super(t20), this.xNode = e15, this.yNode = o14, this.depth = s21, this.children = r17, this._objectIds = /* @__PURE__ */ new Set(), this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._xGeohashTotal = 0, this._yGeohashTotal = 0, this.next = null;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  clone() {
    const t20 = new _l(this._statistics.clone(), this.xNode, this.yNode, this.depth, this.children);
    return t20._count = this._count, t20._xWorldTotal = this._xWorldTotal, t20._yWorldTotal = this._yWorldTotal, t20._xGeohashTotal = this._xGeohashTotal, t20._yGeohashTotal = this._yGeohashTotal, t20.next = this.next, t20._objectIds = new Set(this._objectIds), t20;
  }
  insert(t20, e15, o14, s21, r17, i20) {
    this._count += 1, this._xWorldTotal += e15, this._yWorldTotal += o14, this._xGeohashTotal += s21, this._yGeohashTotal += r17, this._statistics.insert(t20, i20), this._objectIds.add(t20.getObjectId());
  }
  merge(t20) {
    if (0 !== t20._count) {
      this._count += t20._count, this._xWorldTotal += t20._xWorldTotal, this._yWorldTotal += t20._yWorldTotal, this._xGeohashTotal += t20._xWorldTotal, this._yGeohashTotal += t20._yWorldTotal, this._statistics.merge(t20._statistics);
      for (const e15 of t20._objectIds.values()) this._objectIds.add(e15);
    }
  }
  getCentroid(t20) {
    throw new Error("getCentroid not supported for GeohashNode");
  }
  getGeometry(t20, r17) {
    const a16 = this._getLngLatBounds(), [n12, l13, d11, c10] = a16, _5 = j2({ rings: [[[n12, l13], [n12, c10], [d11, c10], [d11, l13], [n12, l13]]] }, f2.WGS84, t20), u16 = X(new e2(), _5, false, false);
    if (null != r17) {
      return gt(new e2(), u16, false, false, "esriGeometryPolygon", r17, false, false);
    }
    return u16;
  }
  getGeometricCentroid(t20, o14) {
    const a16 = this._getLngLatBounds(), [n12, l13, d11, c10] = a16, _5 = j2({ x: (n12 + d11) / 2, y: (l13 + c10) / 2 }, f2.WGS84, t20), u16 = R2(new e2(), _5);
    if (null != o14) {
      return gt(new e2(), u16, false, false, "esriGeometryPoint", o14, false, false);
    }
    return u16;
  }
  getAttributes() {
    const t20 = { aggregateId: this.id };
    for (const e15 of this._statistics.values()) t20[e15.field.name] = e15.value;
    return t20.aggregateCount = this._count, t20;
  }
  find(t20, e15, o14, s21, r17, i20) {
    if (s21 >= o14) return this;
    const h7 = 1 - s21 % 2, a16 = 3 * h7 + 2 * (1 - h7), n12 = 2 * h7 + 3 * (1 - h7), l13 = 30 - r17 - a16, d11 = 30 - i20 - n12, c10 = ((t20 & 7 * h7 + 3 * (1 - h7) << l13) >> l13) + ((e15 & 3 * h7 + 7 * (1 - h7) << d11) >> d11) * (8 * h7 + 4 * (1 - h7)), _5 = this.children[c10];
    return null == _5 ? null : _5.find(t20, e15, o14, s21 + 1, r17 + a16, i20 + n12);
  }
  _getLngLatBounds() {
    const e15 = this.depth, o14 = Math.ceil(e15 / 2), s21 = Math.floor(e15 / 2), r17 = 30 - (3 * o14 + 2 * s21), i20 = 30 - (2 * o14 + 3 * s21), h7 = this.xNode << r17, a16 = this.yNode << i20;
    return w({ geohashX: h7, geohashY: a16 }, this.depth);
  }
};

// node_modules/@arcgis/core/geohash/GeohashTree.js
var e14 = class {
  constructor(e15) {
    this._fields = e15, this._size = 0, this._depth = 0, this._root = l7.create(this._fields, 0, 0, 0);
  }
  destroy() {
  }
  get size() {
    return this._size;
  }
  get depth() {
    return this._depth;
  }
  find(t20, e15, s21) {
    return this._root.find(t20, e15, s21, 0, 0, 0);
  }
  insert(e15, s21, i20, n12, o14, h7, r17) {
    let l13 = this._root, d11 = 0, c10 = 0, a16 = 0;
    for (; null !== l13; ) {
      if (l13.insert(e15, s21, i20, n12, o14, r17), d11 >= h7) return;
      const f6 = Math.ceil((d11 + 1) / 2), u16 = Math.floor((d11 + 1) / 2), x6 = 1 - d11 % 2, _5 = 30 - (3 * f6 + 2 * u16), p6 = 30 - (2 * f6 + 3 * u16), M3 = (n12 & 7 * x6 + 3 * (1 - x6) << _5) >> _5, m11 = (o14 & 3 * x6 + 7 * (1 - x6) << p6) >> p6, g6 = M3 + m11 * (8 * x6 + 4 * (1 - x6));
      c10 = c10 << 3 * x6 + 2 * (1 - x6) | M3, a16 = a16 << 2 * x6 + 3 * (1 - x6) | m11, null == l13.children[g6] && (l13.children[g6] = l7.create(this._fields, c10, a16, d11 + 1), this._depth = Math.max(this._depth, d11 + 1), this._size += 1), d11 += 1, l13 = l13.children[g6];
    }
  }
  putBins(t20, e15) {
    for (const s21 of this.getNodes(e15)) {
      const e16 = t20.get(s21.id);
      e16 ? e16.merge(s21) : t20.set(s21.id, s21.clone());
    }
  }
  getNodes(t20) {
    const e15 = [], { geohashBounds: s21, level: i20 } = t20;
    let n12 = this._root;
    for (; null !== n12; ) {
      const t21 = n12.depth, o14 = n12.xNode, h7 = n12.yNode;
      if (t21 >= i20) {
        e15.push(n12), n12 = n12.next;
        continue;
      }
      const r17 = Math.ceil((t21 + 1) / 2), l13 = Math.floor((t21 + 1) / 2), d11 = 1 - t21 % 2, c10 = 30 - (3 * r17 + 2 * l13), a16 = 30 - (2 * r17 + 3 * l13), f6 = ~((1 << c10) - 1), u16 = ~((1 << a16) - 1), x6 = (s21.xLL & f6) >> c10, _5 = (s21.yLL & u16) >> a16, p6 = (s21.xTR & f6) >> c10, M3 = (s21.yTR & u16) >> a16, m11 = o14 << 3 * d11 + 2 * (1 - d11), g6 = h7 << 2 * d11 + 3 * (1 - d11), y8 = m11 + 8 * d11 + 4 * (1 - d11), z2 = g6 + 4 * d11 + 8 * (1 - d11), L4 = Math.max(m11, x6), N2 = Math.max(g6, _5), B2 = Math.min(y8, p6), R4 = Math.min(z2, M3);
      let T2 = null, j4 = null;
      for (let e16 = N2; e16 <= R4; e16++) for (let t22 = L4; t22 <= B2; t22++) {
        const s22 = t22 - m11 + (e16 - g6) * (8 * d11 + 4 * (1 - d11)), i21 = n12.children[s22];
        i21 && (T2 || (T2 = i21, T2.next = n12.next), j4 && (j4.next = i21), j4 = i21, i21.next = n12.next);
      }
      n12 = T2 || n12.next;
    }
    return e15;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GeohashSpatialIndex.js
var r13 = class extends r12 {
  constructor(t20) {
    super(t20), this._tree = new e14(this._options.fields);
  }
  put(e15) {
    throw new Error("Geohash tree does not support put");
  }
  putBounded(e15, s21, o14) {
    const { geohashLevel: r17, spatialReference: h7 } = this._options, i20 = v2(s21, o14, r17, h7);
    null != i20 && this._tree.putBins(e15, i20);
  }
  _insert(e15, t20, o14, r17) {
    const { geohashLevel: h7, spatialReference: i20 } = this._options, n12 = G(t20, o14, h7, i20);
    n12 && this._tree.insert(e15, t20, o14, n12[0], n12[1], h7, r17);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderIndirect.js
var d5 = class _d extends v {
  static from(r17, e15) {
    if (r17 instanceof this) {
      const t20 = new Set(e15), s21 = r17._indices.filter((r18) => t20.has(r18));
      return new _d(r17._reader, s21);
    }
    return new _d(r17.copy(), e15);
  }
  constructor(r17, e15) {
    super(r17.metadata), this._currentIndex = -1, this._displayTransform = null, this._reader = r17, this._indices = e15;
  }
  setTransformForDisplay(r17) {
    const t20 = this._reader.getInTransform();
    if (null == t20) return void (this._displayTransform = u5(r17));
    const s21 = u5(t20), a16 = u5(r17), [i20, d11] = s21.scale, [n12, o14] = s21.translate, [h7, u16] = a16.scale, [_5, l13] = a16.translate, c10 = i20 / h7, y8 = d11 / u16, p6 = (n12 - _5) / h7, m11 = (o14 - l13) / u16;
    this._displayTransform = { originPosition: "lowerLeft", scale: [1 / c10, 1 / y8, 1, 1], translate: [-p6 / c10, -m11 / y8, 0, 0] };
  }
  getInTransform() {
    return this._reader.getInTransform();
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r17 = new _d(this._reader.copy(), this._indices);
    return r17._currentIndex = this._currentIndex, r17._displayTransform = this._displayTransform, r17._processorAttributes = this._processorAttributes, r17;
  }
  get contextTimeZone() {
    return this._reader.contextTimeZone;
  }
  set contextTimeZone(r17) {
    this._reader.contextTimeZone = r17;
  }
  get usedMemory() {
    return s4 + this._reader.usedMemory;
  }
  setProcessorAttributes(r17) {
    this._processorAttributes = Object.assign(this._processorAttributes ?? {}, r17);
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); ) ;
    return this._currentIndex < this._indices.length;
  }
  readXForDisplay() {
    return this._displayTransform ? i4(this._displayTransform, this._reader.readXForDisplay()) : this._reader.readXForDisplay();
  }
  readYForDisplay() {
    return this._displayTransform ? a2(this._displayTransform, this._reader.readYForDisplay()) : this._reader.readYForDisplay();
  }
  readGeometryForDisplay() {
    return this._displayTransform ? this._reader.readGeometryForDisplayTransformed(this._displayTransform) : this._reader.readGeometryForDisplay();
  }
  readCentroidForDisplay() {
    const r17 = this._reader.readCentroidForDisplay()?.clone();
    if (r17) {
      const [e15, a16] = r17.coords;
      this._displayTransform ? (r17.coords[0] = i4(this._displayTransform, e15), r17.coords[1] = a2(this._displayTransform, a16)) : (r17.coords[0] = e15, r17.coords[1] = a16);
    }
    return r17;
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  readAttribute(r17, e15 = false) {
    const t20 = this._reader.readAttribute(r17, e15);
    return null == t20 && this._processorAttributes ? this._processorAttributes[r17] : t20;
  }
  readAttributes() {
    return { ...this._processorAttributes ?? {}, ...this._reader.readAttributes() };
  }
  joinAttributes(r17) {
    return this._reader.joinAttributes(r17);
  }
  getBounds(r17) {
    return this._reader.getBounds(r17);
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(r17) {
    return this._reader.setDisplayId(r17);
  }
  setIndex(r17) {
    return this._reader.setIndex(r17);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readXWorldSpace() {
    return this._reader.readXWorldSpace();
  }
  readYWorldSpace() {
    return this._reader.readYWorldSpace();
  }
  _readX() {
    return this._reader.readXForDisplay();
  }
  _readY() {
    return this._reader.readYForDisplay();
  }
  _readServerCentroid() {
    return this._reader._readServerCentroid();
  }
  readLegacyFeatureForDisplay() {
    const r17 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (r17 && { x: r17.coords[0], y: r17.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const r17 = this.readGeometryForDisplay();
    return lt(r17, this.geometryType, false, false);
  }
  readGeometryArea() {
    return this._displayTransform ? this._reader.readGeometryForDisplayTransformed(this._displayTransform)?.area() ?? 0 : this._reader.readGeometryArea();
  }
  readGeometryWorldSpace() {
    return this._reader.readGeometryWorldSpace();
  }
  _readGeometry() {
    return this._reader._readGeometry();
  }
  _readAttribute(r17, e15) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(r17) {
    return this._reader.field(r17);
  }
  hasField(r17) {
    return this._reader.hasField(r17);
  }
  setField(r17, e15) {
    return this._reader.setField(r17, e15);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(r17 = false) {
    return this._reader.castToText(r17);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/ASourceChunk.js
var i14 = class {
  size() {
    return this.reader.getSize();
  }
  get fields() {
    return this.reader.fields;
  }
  invalidate() {
    this._aggregateIndex = null, this._aggregateIndexHash = null, this._spatialIndex = null;
  }
  registerOverrides(e15) {
    this.reader.registerOverrides(e15), this.invalidate();
  }
  queryFeaturesInBounds(e15) {
    const t20 = this._getSpatialIndex().search(e15);
    return d5.from(this.reader, t20);
  }
  getAggregateIndex(e15) {
    const a16 = JSON.stringify(e15);
    if (a16 !== this._aggregateIndexHash) {
      switch (this._aggregateIndexHash = a16, e15.type) {
        case "grid":
          this._aggregateIndex = new n7(e15);
          break;
        case "geohash":
          this._aggregateIndex = new r13(e15);
      }
      this._aggregateIndex.insert(this.reader, this.isTiled);
    }
    return this._aggregateIndex;
  }
  _getSpatialIndex() {
    return this._spatialIndex || (this._spatialIndex = t13.fromReader(this.reader)), this._spatialIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/Overrides.js
var s18 = 1e4;
var r14 = 1e3;
var i15 = class {
  constructor() {
    this.modified = [], this.removed = [];
  }
  modify(e15) {
    this.modified.push(e15);
  }
  remove(e15) {
    this.removed.push(e15);
  }
  get isEmpty() {
    return 0 === this.modified.length && 0 === this.removed.length;
  }
};
var o7 = class _o extends i14 {
  constructor(e15) {
    super(), this._reader = e15, this.chunkId = "override", this.normalizedChunkId = "override";
  }
  static fromFeatures(e15, s21) {
    const r17 = u9.fromOptimizedFeatures(e15, s21);
    return new _o(r17);
  }
  get reader() {
    return this._reader;
  }
  get queryInfo() {
    return {};
  }
  get first() {
    return false;
  }
  get end() {
    return false;
  }
  get isTiled() {
    return false;
  }
  getTileReader(e15) {
    if (!this._reader.getSize()) return null;
    const t20 = this.queryFeaturesInBounds(e15.bounds);
    return t20.setTransformForDisplay(e15.transform), t20;
  }
};
var n8 = class {
  constructor(e15, t20) {
    this.inner = e15, this.isWeak = t20, this.lastWeak = null;
  }
  get isStrong() {
    return !this.isWeak;
  }
};
var a11 = class {
  constructor() {
    this._overrides = /* @__PURE__ */ new Map(), this._update = new i15(), this._lastCleanup = 0;
  }
  hasOverride(e15) {
    return this._overrides.has(e15);
  }
  onChunkInsert(e15) {
    if (this._overrides.size) {
      const t20 = e15.reader.getCursor();
      for (; t20.next(); ) {
        const e16 = t20.getObjectId(), s21 = this._overrides.get(e16);
        if (s21?.lastWeak && (s21.lastWeak = null), s21?.isWeak) {
          const e17 = t20.readOptimizedFeatureWorldSpace();
          s21.inner = e17, this._update.modify(e17), this.invalidate();
        }
      }
    }
    e15.registerOverrides(this);
  }
  apply(e15, t20) {
    const { updateWeak: s21, removeWeak: r17, update: i20, remove: o14, release: a16 } = e15.commands;
    this.invalidate();
    for (const d11 of s21) {
      const e16 = new n8(d11, true), t21 = this._overrides.get(d11.objectId);
      t21?.isStrong ? t21.lastWeak = e16 : (this._overrides.set(d11.objectId, e16), this._update.modify(d11));
    }
    for (const d11 of i20) {
      const e16 = new n8(d11, false), t21 = this._overrides.get(d11.objectId);
      e16.lastWeak = t21?.isWeak ? t21 : t21?.lastWeak ?? null, this._overrides.set(d11.objectId, e16), this._update.modify(d11);
    }
    for (const d11 of r17) {
      const e16 = new n8(null, true), t21 = this._overrides.get(d11);
      t21?.isStrong ? t21.lastWeak = e16 : (this._overrides.set(d11, e16), this._update.remove(d11));
    }
    for (const d11 of o14) {
      const e16 = new n8(null, false), t21 = this._overrides.get(d11);
      e16.lastWeak = t21?.isWeak ? t21 : t21?.lastWeak ?? null, this._overrides.set(d11, e16), this._update.remove(d11);
    }
    if (a16.length) {
      const e16 = /* @__PURE__ */ new Set();
      for (const t21 of a16) {
        const s22 = this._overrides.get(t21);
        s22?.lastWeak ? (this._overrides.set(t21, s22.lastWeak), null == s22.lastWeak.inner ? this._update.remove(t21) : this._update.modify(s22.lastWeak.inner)) : s22 && !s22.isWeak && (this._overrides.delete(t21), e16.add(t21));
      }
      t20.forEachUnsafe((t21) => {
        const s22 = t21.getObjectId();
        e16.has(s22) && (this._update.modify(t21.readOptimizedFeatureWorldSpace()), e16.delete(s22));
      });
      for (const t21 of e16.values()) this._update.remove(t21);
    }
  }
  clearWeakOverrides() {
    for (const [e15, t20] of this._overrides.entries()) t20.isWeak && this._overrides.delete(e15);
    this.invalidate();
  }
  cleanup(e15) {
    if (this._overrides.size < s18) return;
    const t20 = performance.now();
    if (t20 - this._lastCleanup < r14) return;
    this._lastCleanup = t20;
    const i20 = this._getWeakDeletions();
    if (!(i20.size < s18)) {
      for (const t21 of e15) {
        const e16 = t21.reader.withoutOverrides().getCursor();
        for (; e16.next(); ) {
          const t22 = e16.getObjectId();
          i20.delete(t22);
        }
      }
      for (const e16 of i20) this._overrides.delete(e16);
      i20.size && this.invalidate();
    }
  }
  takeOverrideUpdate() {
    const e15 = this._update;
    return e15.isEmpty ? null : (this._update = new i15(), e15);
  }
  asChunk(e15) {
    if (!this._chunk) {
      const t20 = [];
      for (const e16 of this._overrides.values()) null != e16.inner && t20.push(e16.inner);
      this._chunk = o7.fromFeatures(t20, e15);
    }
    return this._chunk;
  }
  invalidate() {
    this._chunk = null;
  }
  putWeakObjectIdsFromGlobalIds(e15, t20, s21) {
    for (const [r17, i20] of this._overrides.entries()) if (i20.isWeak && null != i20.inner) {
      const o14 = i20.inner.attributes[s21];
      o14 && t20.has(o14) && !e15.has(o14) && e15.set(o14, r17);
    } else if (null != i20.lastWeak && null != i20.lastWeak.inner) {
      const o14 = i20.lastWeak.inner.attributes[s21];
      o14 && t20.has(o14) && !e15.has(o14) && e15.set(o14, r17);
    }
  }
  _getWeakDeletions() {
    const e15 = /* @__PURE__ */ new Set();
    for (const [t20, s21] of this._overrides.entries()) s21.isWeak && null == s21.inner && e15.add(t20);
    return e15;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/FeatureUpdateStrategy.js
var d6 = class extends t11 {
};
var i16 = class extends e11 {
  constructor(e15, t20, s21, r17) {
    super(e15, t20, r17), this._arcadeContextInfo = s21, this.handledChunks = /* @__PURE__ */ new Set(), this.handledChunksForIdCreation = /* @__PURE__ */ new Set(), this.handledChunksForAttributeData = /* @__PURE__ */ new Set(), this._streamLayerDeferredObjectIdsToRemove = [];
  }
  destroy() {
    super.destroy();
    for (const e15 of this._source.chunks()) this._cleanupChunkIds(e15);
  }
  invalidateAttributeData(e15) {
    this.handledChunksForAttributeData.clear(), this._arcadeContextInfo = e15, null != this._evalOptions && (this._evalOptions = e7(this._evalOptions.$view.scale, e15));
  }
  onSubscribe(e15) {
    super.onSubscribe(e15), this._evalOptions = e15.tile.createArcadeEvaluationOptions(this._arcadeContextInfo);
  }
  createState(e15) {
    return new d6(e15);
  }
  get aggregateQueryEngine() {
    return null;
  }
  displayMap(e15, t20, s21) {
    const r17 = new Map(e15.map((e16) => [t20(e16), e16])), o14 = [];
    for (const a16 of this._source.chunks()) {
      const e16 = a16.reader.getCursor();
      for (; e16.next(); ) {
        const t21 = e16.getObjectId(), a17 = e16.getDisplayId(), n12 = r17.get(t21);
        if (null != n12) {
          const e17 = s21(a17, n12, t21);
          o14.push(e17), r17.delete(t21);
        }
      }
    }
    return o14;
  }
  getDisplayFeatures(e15) {
    const t20 = new Set(e15), s21 = /* @__PURE__ */ new Set(), r17 = [];
    for (const o14 of this._source.chunks()) {
      const e16 = o14.reader.getCursor();
      for (; e16.next(); ) {
        const o15 = e16.getObjectId(), a16 = e16.getDisplayId();
        t20.has(a16) && !s21.has(o15) && (r17.push({ ...e16.readLegacyFeatureWorldSpace(), displayId: a16 }), s21.add(o15));
      }
    }
    return { features: r17, aggregates: [], tracks: [] };
  }
  async *applyOverrideUpdate(e15) {
    const t20 = [];
    for (const s21 of e15.modified) {
      const e16 = this._attributeStore.createDisplayIdForObjectId(s21.objectId);
      s21.displayId = e16, t20.push(e16);
    }
    const r17 = u9.fromOptimizedFeatures(e15.modified, this._source.metadata).getCursor();
    for (; r17.next(); ) this._attributeStore.setAttributeData(r17.getDisplayId(), r17, this._evalOptions, this._sqlOptions);
    const a16 = [];
    for (const s21 of e15.removed) {
      const e16 = this._attributeStore.getDisplayIdForObjectId(s21);
      null != e16 && a16.push(e16);
    }
    has("esri-2d-update-debug") && console.debug("FeatureUpdateStrategy.applyLocalEdit", { message: e15, modifiedDisplayIds: t20, removedDisplayIds: a16 });
    const d11 = o7.fromFeatures(e15.modified, this._source.metadata);
    this.handledChunks.add(d11.chunkId), this.handledChunksForAttributeData.add(d11.chunkId), this.handledChunksForIdCreation.add(d11.chunkId);
    for (const o14 of this._sendStates.values()) o14.handledChunks.add(d11.chunkId), yield new i12(o14.subscription, null, t20, false, d11.queryInfo);
    for (const o14 of this._sendStates.values()) {
      const e16 = d11.getTileReader(o14.subscription.tile);
      yield new i12(o14.subscription, e16, a16, false, d11.queryInfo);
    }
    for (const s21 of e15.removed) this._attributeStore.releaseDisplayIdForObjectId(s21);
  }
  async *updateChunks() {
    if (this._source.chunks().length) {
      await this._updateAttributeData();
      for (const e15 of this._sendStates.values()) yield* this._update(e15);
    }
  }
  removeChunks(e15) {
    for (const t20 of e15) this.handledChunks.delete(t20.chunkId), this.handledChunksForAttributeData.delete(t20.chunkId), this._cleanupChunkIds(t20);
  }
  afterUpdateChunks() {
    for (const e15 of this._streamLayerDeferredObjectIdsToRemove) this._attributeStore.releaseDisplayIdForObjectId(e15);
    this._streamLayerDeferredObjectIdsToRemove = [];
  }
  _cleanupChunkIds(e15) {
    if (this.handledChunksForIdCreation.has(e15.chunkId)) {
      const t20 = e15.reader.getCursor();
      for (; t20.next(); ) {
        const e16 = t20.getObjectId();
        this._source.isStream ? this._streamLayerDeferredObjectIdsToRemove.push(e16) : this._attributeStore.releaseDisplayIdForObjectId(e16);
      }
      this.handledChunksForIdCreation.delete(e15.chunkId);
    }
  }
  async _updateAttributeData() {
    for (const e15 of this._source.chunks()) {
      const { chunkId: t20, reader: s21 } = e15;
      if (!this.handledChunksForIdCreation.has(t20)) {
        this.handledChunksForIdCreation.add(t20);
        const e16 = s21.getCursor();
        for (; e16.next(); ) {
          const t21 = this._attributeStore.createDisplayIdForObjectId(e16.getObjectId());
          e16.setDisplayId(t21);
        }
      }
    }
    for (const e15 of this._source.chunks()) if (!this.handledChunksForAttributeData.has(e15.chunkId)) {
      this.handledChunksForAttributeData.add(e15.chunkId);
      const t20 = e15.reader.getCursor();
      for (; t20.next(); ) {
        const e16 = t20.getDisplayId();
        this._attributeStore.setAttributeData(e16, t20, this._evalOptions, this._sqlOptions);
      }
    }
  }
  *_update(e15) {
    const { subscription: t20, handledChunks: s21 } = e15;
    for (const o14 of this._source.chunks()) {
      const { chunkId: a16 } = o14;
      if (s21.has(a16)) continue;
      s21.add(a16);
      const n12 = o14.getTileReader(t20.tile);
      n12 && (yield new e12(e15.subscription, n12, false, o14.end, o14.queryInfo));
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/TrackStrategy.js
var G2;
var P3 = () => i2.getLogger("esri.views.2d.layers.features.processor.TrackStrategy");
var z = 32;
var M2 = class {
  constructor(t20, e15, s21, r17, i20) {
    this.chunkIndex = t20, this.featureIndex = e15, this.objectId = s21, this.displayId = r17, this.time = i20;
  }
};
var W = class {
  static getOid(t20) {
    return t5 + t20;
  }
  constructor(t20, e15, s21, r17, i20, a16, o14, n12) {
    this._schema = t20, this.trackId = e15, this.objectId = s21, this.displayId = r17, this._fields = i20, this._spatialReference = a16, this._metadata = o14, this._isStream = n12, this._maxDisplayDuration = this._schema.maxDisplayDuration > 0 ? this._schema.maxDisplayDuration : 1 / 0, this._maxDisplayObservationsPerTrack = this._schema.maxDisplayObservationsPerTrack >= 1 ? this._schema.maxDisplayObservationsPerTrack : 1 / 0, this._observationRecords = [], this._nextObservationRecords = [], this._trackLinePath = [], this._bounds = [], this._trackLineGeometry = new e2();
  }
  get _trackLineAttributes() {
    const t20 = { ...this._latestObservationFeature?.attributes ?? {}, aggregateId: this.objectId, [r4]: s8.TrackLine };
    if (null != this._statistics) for (const e15 of this._statistics.values()) t20[e15.field.name] = e15.value;
    return t20;
  }
  get _startTimeField() {
    return this._metadata.timeInfo?.startTimeField;
  }
  get length() {
    return this._observationRecords.length;
  }
  *observations() {
    yield* this._observationRecords;
  }
  *previousObservations() {
    for (let t20 = 0; t20 < this._observationRecords.length - 1; t20++) yield this._observationRecords[t20];
  }
  stageObservation(t20, e15) {
    this._nextObservationRecords.push(new M2(t20, e15.getIndex(), e15.getObjectId(), e15.getDisplayId(), null != this._startTimeField ? e15.readAttributeAsTimestamp(this._startTimeField) : null));
  }
  commitObservations(t20, e15) {
    const r17 = new Set(this._nextObservationRecords.map((t21) => t21.objectId)), i20 = this._observationRecords.filter((t21) => !r17.has(t21.objectId)).map((t21) => t21.objectId);
    let a16, o14;
    switch (this._observationRecords = [], this._trackLinePath = [], this._isStream || null == this._startTimeField || this._nextObservationRecords.sort((t21, e16) => {
      const s21 = t21.time, r18 = e16.time;
      return null != s21 && null != r18 ? s21 - r18 : 0;
    }), this._schema.timeField) {
      case "startTimeField":
        a16 = this._metadata.timeInfo?.startTimeField;
        break;
      case "endTimeField":
        a16 = this._metadata.timeInfo?.endTimeField;
        break;
      case "timeReceived":
        a16 = this._isStream ? i5 : null;
    }
    o14 = this._isStream ? e15?.end ?? Date.now() : e15?.end ?? -1 / 0;
    const n12 = t20.map((t21) => t21.reader.getCursor());
    let l13;
    for (let c10 = this._nextObservationRecords.length - 1; c10 >= 0 && !(this._observationRecords.length >= this._maxDisplayObservationsPerTrack); c10--) {
      const t21 = this._nextObservationRecords[c10], e16 = n12[t21.chunkIndex];
      n(e16), e16.setIndex(t21.featureIndex);
      const r18 = null != a16 ? e16.readAttributeAsTimestamp(a16) : null;
      (null != r18 ? o14 - r18 : 0) >= this._maxDisplayDuration || (this._commitObservation(t21, e16), l13 ??= t21);
    }
    if (null != l13) {
      const { chunkIndex: t21, featureIndex: e16, objectId: r18, displayId: i21 } = l13, a17 = n12[t21];
      n(a17), a17.setIndex(e16);
      const o15 = new s5(a17.readGeometryWorldSpace(), { ...a17.readAttributes(), [r4]: s8.LatestObservation }, null, r18, i21);
      this._latestObservationFeature = o15;
    } else this._latestObservationFeature = null;
    return this._trackLineGeometry = E(this._trackLineGeometry, this._trackLinePath, this._spatialReference), this._bounds = X2(this._trackLineGeometry), this._nextObservationRecords = [], i20;
  }
  updateStatistics(t20, e15) {
    this._statistics = s16.create(this._fields);
    const r17 = t20.map((t21) => t21.reader.getCursor());
    for (const { chunkIndex: i20, featureIndex: a16 } of this._observationRecords) {
      const t21 = r17[i20];
      n(t21), t21.setIndex(a16), this._statistics.insert(t21, e15);
    }
  }
  overlapsTile(t20) {
    for (const e15 of this._bounds) if (U(e15, t20.bounds, z)) return true;
    return false;
  }
  getLatestObservationFeatureForTile(t20) {
    if (null == this._latestObservationFeature) return null;
    const { objectId: e15, displayId: s21, geometry: r17, attributes: i20 } = this._latestObservationFeature, a16 = new e2();
    gt(a16, r17, false, false, this._metadata.geometryType, t20.subscription.tile.transform);
    const o14 = e(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    N(a16, (t21, e16) => m3(o14, [t21, e16]));
    if (!R(o14, e(0, 0, a7, a7))) return null;
    return new s5(a16, i20, null, e15, s21);
  }
  getTrackLineFeatureForTile(t20) {
    const e15 = new e2();
    gt(e15, this._trackLineGeometry, false, false, "esriGeometryPolyline", t20.subscription.tile.transform);
    return new s5(e15, this._trackLineAttributes, null, this.objectId, this.displayId);
  }
  getTrackLineOptimizedFeature() {
    return new s5(this._trackLineGeometry, this._trackLineAttributes, null, this.objectId, this.displayId);
  }
  getTrackLineDisplayFeature() {
    const { _trackLineGeometry: t20, _trackLineAttributes: e15, displayId: s21 } = this;
    return { geometry: lt(t20, "esriGeometryPolyline", false, false), attributes: e15, displayId: s21 };
  }
  _commitObservation(t20, e15) {
    const s21 = e15.readCentroidWorldSpace();
    let r17 = s21?.coords[0], i20 = s21?.coords[1];
    null == s21 && (r17 = e15.readXWorldSpace(), i20 = e15.readYWorldSpace()), null != r17 && null != i20 && (this._observationRecords.unshift(t20), this._trackLinePath.unshift([r17, i20]));
  }
};
var U2 = class extends t11 {
  constructor(t20) {
    super(t20), this.done = false;
  }
};
var q = class _q extends i11 {
  static async create(t20, e15, s21, a16, o14, n12) {
    const l13 = new l3({ spatialReference: e15 }), c10 = await Promise.all(t20.fields.map(async (t21) => s15.create(l13, t21))), d11 = t20.featureFilter ? await p2.create({ geometryType: s21.metadata.geometryType, hasM: false, hasZ: false, timeInfo: s21.metadata.timeInfo, fieldsIndex: s21.metadata.fieldsIndex, spatialReference: e15, filterJSON: t20.featureFilter }) : null;
    return e15.isWrappable || s9() || await Promise.all([import("./apiConverter-OEQWXNM7.js"), import("./jsonConverter-2YR5GDYW.js"), i6()]).then(([t21, e16, s22]) => {
      G2 = { fromGeometryToGXGeometry: e16.fromGeometryToGXGeometry, toGeometry: e16.toGeometry, fromSpatialReference: t21.fromSpatialReference };
    }), new _q(t20, s21, a16, e15, c10, d11, o14, n12);
  }
  constructor(t20, e15, s21, r17, i20, a16, o14, n12) {
    super(e15, s21, r17, i20, n12), this._schema = t20, this._featureFilter = a16, this._arcadeContextInfo = o14, this._tracks = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._metadata = e15.metadata.weakCloneWithAdditionalFields([{ name: r4, alias: "trackPart", type: "esriFieldTypeSmallInteger" }]), this._trackLineMetadata = i7.createFeature({ geometryType: "esriGeometryPolyline", featureIdInfo: { type: "object-id", fieldName: "aggregateId" }, fieldsIndex: { fields: [...this._source.metadata.fieldsIndex.fields, ...this.aggregateFields, { name: r4, alias: "trackPart", type: "esriFieldTypeSmallInteger" }, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }], timeZoneByFieldName: null }, globalIdField: null, spatialReference: e15.metadata.spatialReference, outSpatialReference: e15.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: e15.metadata.timeInfo, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  get _isStream() {
    return this._source.isStream;
  }
  get enablePixelBuffering() {
    return true;
  }
  get isAggregate() {
    return false;
  }
  requiresInvalidation() {
    const t20 = new Set(this._source.chunks().map((t21) => t21.chunkId));
    for (const e15 of t20) if (!this._handledChunks.has(e15)) return true;
    for (const e15 of this._handledChunks) if (!t20.has(e15)) return true;
    return false;
  }
  invalidate() {
    this._handledChunks.clear(), super.invalidate();
  }
  createState(t20) {
    return new U2(t20);
  }
  async *applyOverrideUpdate(t20) {
    P3().error("Applying override to tracks is not supported");
  }
  displayMap(t20, e15, s21) {
    const r17 = new Map(t20.map((t21) => [e15(t21), t21])), i20 = [];
    for (const a16 of this._tracks.values()) {
      const t21 = r17.get(a16.objectId);
      if (null == t21) for (const e16 of a16.observations()) {
        const t22 = r17.get(e16.objectId);
        if (null != t22) {
          const a17 = s21(e16.displayId, t22, e16.objectId);
          i20.push(a17), r17.delete(e16.objectId);
        }
      }
      else {
        const e16 = s21(a16.displayId, t21, a16.objectId);
        i20.push(e16), r17.delete(a16.objectId);
      }
    }
    return i20;
  }
  getDisplayFeatures(t20) {
    const e15 = new Set(t20), s21 = [], r17 = [], i20 = this._source.chunks().map((t21) => t21.reader.getCursor());
    for (const a16 of this._tracks.values()) {
      e15.has(a16.displayId) && r17.push(a16.getTrackLineDisplayFeature());
      for (const { displayId: t21, chunkIndex: r18, featureIndex: o14 } of a16.observations()) if (e15.has(t21)) {
        const e16 = i20[r18];
        e16.setIndex(o14), s21.push({ displayId: t21, attributes: {}, ...e16.readLegacyFeatureWorldSpace() });
      }
    }
    return { features: s21, aggregates: [], tracks: r17 };
  }
  getFeatureObjectIdsForAggregate(t20) {
    for (const e15 of this._tracks.values()) if (e15.objectId === t20) return Array.from(e15.observations(), (t21) => t21.objectId);
    return [];
  }
  async *updateChunks() {
    0 === this._handledChunks.size && this._rebuildTracks();
    for (const t20 of this._sendStates.values()) yield* this._update(t20);
  }
  forEachAggregateWorldSpace(t20) {
    for (const e15 of this._tracks.values()) t20(e15.getTrackLineOptimizedFeature());
  }
  _rebuildTracks() {
    const t20 = this._source.chunks();
    if (!t20.length) return;
    const e15 = this._metadata.timeInfo?.trackIdField;
    if (null == e15) return;
    const s21 = /* @__PURE__ */ new Set();
    for (let r17 = 0; r17 < t20.length; r17++) {
      const i20 = t20[r17];
      this._handledChunks.add(i20.chunkId);
      const a16 = i20.reader.getCursor();
      for (; a16.next(); ) {
        const t21 = a16.readAttribute(e15), i21 = a16.getObjectId();
        if (null != t21 && null != i21 && (null === this._featureFilter || this._featureFilter.check(a16, this._sqlOptions))) {
          if (a16.getDisplayId() || a16.setDisplayId(this._attributeStore.createDisplayIdForObjectId(i21)), !this._tracks.has(t21)) {
            const e16 = W.getOid(t21), s22 = this._attributeStore.createDisplayIdForObjectId(e16), r18 = new W(this._schema, t21, e16, s22, this.aggregateFields, this.spatialReference, this._source.metadata, this._isStream);
            this._tracks.set(t21, r18);
          }
          this._tracks.get(t21).stageObservation(r17, a16), s21.add(t21);
        }
      }
    }
    for (const r17 of this._tracks.values()) if (s21.has(r17.trackId)) {
      const e16 = r17.commitObservations(t20, this._featureFilter?.timeExtent);
      for (const t21 of e16) this._attributeStore.releaseDisplayIdForObjectId(t21);
      r17.updateStatistics(t20, e7(1, this._arcadeContextInfo));
    } else this._removeTrack(r17);
  }
  _removeTrack(t20) {
    this._tracks.delete(t20.trackId), this._attributeStore.releaseDisplayIdForObjectId(t20.objectId);
    for (const { objectId: e15 } of t20.observations()) this._attributeStore.releaseDisplayIdForObjectId(e15);
  }
  *_update(e15) {
    if (e15.done) return;
    e15.done = !this._source.updateTracking.updating;
    const s21 = [], r17 = [];
    for (const t20 of this._tracks.values()) if (t20.length > 0) {
      if (this._schema.showLatestObservation) {
        const r18 = t20.getLatestObservationFeatureForTile(e15);
        null != r18 && s21.push(r18);
      }
      this._schema.showTrackLine && t20.overlapsTile(e15.subscription.tile) && r17.push(t20.getTrackLineFeatureForTile(e15));
    }
    const i20 = u9.fromOptimizedFeatures(s21, this._metadata, e15.subscription.tile.transform), a16 = u9.fromOptimizedFeatures(r17, this._trackLineMetadata, e15.subscription.tile.transform);
    let o14 = [];
    if (this._schema.showPreviousObservations) {
      const s22 = this._source.chunks().map(() => []);
      for (const t20 of this._tracks.values()) for (const { chunkIndex: e16, featureIndex: r18 } of t20.previousObservations()) s22[e16].push(r18);
      o14 = this._source.chunks().map((t20, r18) => {
        const i21 = t20.getTileReader(e15.subscription.tile);
        if (null == i21) return null;
        const a17 = d5.from(i21, s22[r18]);
        return a17.setProcessorAttributes({ [r4]: s8.PreviousObservation }), "esriGeometryPoint" !== a17.geometryType && null != a17.getInTransform() || a17.setTransformForDisplay(e15.subscription.tile.transform), a17;
      }).filter(L);
    }
    this.events.emit("changed");
    const n12 = e15.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo), l13 = a16.getCursor();
    for (; l13.next(); ) this._attributeStore.setAttributeData(l13.getDisplayId(), l13, n12, this._sqlOptions);
    for (const t20 of o14) {
      const e16 = t20.getCursor();
      for (; e16.next(); ) this._attributeStore.setAttributeData(e16.getDisplayId(), e16, n12, this._sqlOptions);
    }
    const c10 = i20.getCursor();
    for (; c10.next(); ) this._attributeStore.setAttributeData(c10.getDisplayId(), c10, n12, this._sqlOptions);
    yield new e12(e15.subscription, a16, false, false, {});
    for (const t20 of o14) yield new e12(e15.subscription, t20, false, false, {});
    yield new e12(e15.subscription, i20, false, e15.done, {});
  }
};
function E(t20, e15, s21) {
  if (e15.length < 2) return tt(t20, [e15], false, false);
  if (s21.isWrappable) {
    let r18 = false;
    for (let t21 = 1; t21 < e15.length; t21++) {
      const i21 = e15[t21][0], a16 = P2(i21, e15[t21 - 1][0], s21);
      i21 !== a16 && (e15[t21][0] = a16, r18 = true);
    }
    if (r18) {
      const r19 = a6({ paths: [e15], spatialReference: s21 });
      if (null != r19) return tt(t20, r19.paths, false, false);
    }
    return tt(t20, [e15], false, false);
  }
  const r17 = G2.fromGeometryToGXGeometry({ hasM: false, hasZ: false, paths: [e15] }), i20 = G2.fromSpatialReference(s21);
  if (null != i20) {
    const e16 = u8(r17, 1e6, i20, e3.geodesic);
    if (null != e16) {
      const s22 = G2.toGeometry(e16, i20);
      if (null != s22 && "paths" in s22) return tt(t20, s22.paths, false, false);
    }
  }
  return tt(t20, [e15], false, false);
}
function N(t20, e15) {
  const s21 = 2, { coords: r17, lengths: i20 } = t20;
  if (!i20.length) return void e15(r17[0], r17[1]);
  let a16 = 0;
  for (let o14 = 0; o14 < i20.length; o14++) {
    const t21 = i20[o14];
    let n12 = 0, l13 = 0;
    for (let i21 = 0; i21 < t21; i21++) n12 += r17[s21 * (i21 + a16)], l13 += r17[s21 * (i21 + a16) + 1], e15(n12, l13);
    a16 += t21;
  }
}
function X2(t20) {
  const { lengths: e15, coords: s21 } = t20, r17 = 2;
  if (!e15.length) return [I()];
  const i20 = [];
  let a16 = 0;
  for (let o14 = 0; o14 < e15.length; o14++) {
    const t21 = e15[o14], n12 = I();
    i20.push(n12);
    for (let e16 = 0; e16 < t21; e16++) {
      const t22 = s21[r17 * (e16 + a16)], i21 = s21[r17 * (e16 + a16) + 1];
      m3(n12, [t22, i21]);
    }
    a16 += t21;
  }
  return i20;
}

// node_modules/@arcgis/core/views/2d/layers/features/Processor.js
var w2 = class {
  constructor(e15, t20) {
    this._connection = e15, this._source = t20, this._version = 1, this._registry = new y2(), this._proxy = new s10({ fetch: (e16, t21) => this._connection.layerView.fetch(e16, t21), fetchDictionary: (e16, t21) => this._connection.layerView.fetchDictionary(e16, t21) }), this._attributeStore = new x2({ isLocal: false, update: (e16) => O(this._connection.container.updateAttributeView(e16)) });
  }
  destroy() {
    this._proxy.destroy(), this._strategy?.destroy(), this._attributeStore.destroy();
  }
  get aggregateQueryEngine() {
    return this._strategy?.aggregateQueryEngine;
  }
  get version() {
    return this._version;
  }
  getDisplayFeatures(e15) {
    return this._strategy ? this._strategy.getDisplayFeatures(e15) : { features: [], aggregates: [], tracks: [] };
  }
  getDisplayIds(e15) {
    const t20 = {};
    return this._strategy ? (this._strategy.displayMap(e15, (e16) => e16, (e16, s21, r17) => {
      t20[r17] = e16;
    }), t20) : t20;
  }
  getFeatureObjectIdsForAggregate(e15) {
    return this._strategy ? this._strategy.getFeatureObjectIdsForAggregate(e15) : [];
  }
  onSubscribe(e15) {
    this._strategy?.onSubscribe(e15);
  }
  onUnsubscribe(e15) {
    this._strategy?.onUnsubscribe(e15);
  }
  requiresInvalidation() {
    return this._strategy?.requiresInvalidation() ?? false;
  }
  async update(e15, s21, r17, i20, o14) {
    const c10 = e15.processor, u16 = i(this._schema?.storage, c10.storage), p6 = i(this._schema?.mesh.properties, c10.mesh.properties), y8 = i(this._schema?.mesh.factory, c10.mesh.factory), d11 = i(this._schema?.mesh.strategy, c10.mesh.strategy), _5 = S3(this._schema?.expressionProperties, c10.expressionProperties), l13 = _5.some((e16) => this._attributeStore.hasArcadeDependency(e16)), m11 = _5.some((e16) => this._factory?.hasArcadeDependency(e16) ?? false), f6 = _5.some((e16) => this._strategy?.hasArcadeDependency(e16)) || this._strategy?.isAggregate && l13, w3 = m11 || f6, I3 = p6 || y8 || d11;
    if (!(u16 || I3 || (m11 || l13 || f6)) && !i20) return false;
    has("esri-2d-update-debug") && console.debug(`Version[${this._version}] SymbolProcessor.update`, { changes: y(this._schema, c10), schema: c10 }), this._schema = c10;
    const x6 = f2.fromJSON(this._source.service.outSpatialReference), v3 = new l3({ fields: this._source.metadata.fieldsIndex, spatialReference: x6 }), M3 = { currentUser: c10.mesh.properties.currentUser };
    if ((u16 || I3 || l13) && (await this._attributeStore.update(c10.storage, v3, this._source.metadata, s21), this._strategy?.invalidateAttributeData(j3(c10))), !i20 && !I3 && !w3) return false;
    (d11 || p6 || w3) && await this._updateStrategy(c10.mesh.strategy, x6, o14, j3(c10), M3), this._updateSortKey(v3, "sortKey" in c10.mesh.properties ? c10.mesh.properties.sortKey : null);
    const k2 = "dictionary" === c10.mesh.factory.symbology.type ? c10.mesh.factory.symbology.fieldMap : null, U3 = new s14(v3, this._proxy, r17, this._registry, k2);
    return (y8 || "dictionary" === c10.mesh.factory.symbology.type) && (this._factory = await s13.create(U3, c10.mesh.factory)), this._version = s21, true;
  }
  async applyOverrideUpdate(e15) {
    if (!this._strategy) return;
    const t20 = this._strategy.applyOverrideUpdate(e15);
    for await (const r17 of t20) try {
      await this._process(r17);
    } catch (s21) {
    }
  }
  async updateChunks() {
    await this._doUpdateChunks(), this._strategy?.afterUpdateChunks();
  }
  async removeChunks(e15) {
    this._strategy?.removeChunks(e15), this._attributeStore.incrementDisplayIdGeneration();
  }
  updateHighlight({ highlights: e15 }) {
    if (!this._strategy || !this._strategy.hasSubscribers) return void this._attributeStore.setHighlight(e15.map(({ objectId: e16, highlightFlags: t21 }) => ({ objectId: e16, highlightFlags: t21, displayId: -1 })), e15);
    const t20 = this._strategy.displayMap(e15, ({ objectId: e16 }) => e16, (e16, { highlightFlags: t21 }, s21) => ({ objectId: s21, displayId: e16, highlightFlags: t21 }));
    this._attributeStore.setHighlight(t20, e15);
  }
  invalidate() {
    this._strategy && this._strategy.invalidate();
  }
  async _doUpdateChunks() {
    if (!this._strategy) return;
    const e15 = this._strategy.updateChunks(), t20 = [], r17 = /* @__PURE__ */ new Map();
    for await (const a16 of e15) {
      let e16 = r17.get(a16.id);
      null == e16 && (e16 = new e10({ concurrency: 16, process: (e17) => this._process(e17) }), r17.set(a16.id, e16));
      const i20 = e16.push(a16).catch((e17) => f(e17));
      t20.push(i20);
    }
    try {
      await Promise.all(t20);
    } catch (i20) {
    }
    has("esri-2d-update-debug") && console.log("SendUpdates"), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.log("SendUpdates.await");
  }
  async _updateStrategy(e15, t20, s21, r17, i20) {
    switch (this._strategy?.destroy(), e15.type) {
      case "feature":
        this._strategy = new i16(this._source, this._attributeStore, r17, i20);
        break;
      case "binning":
        this._strategy = await y3.create(e15, t20, this._source, this._attributeStore, r17, i20);
        break;
      case "cluster":
        this._strategy = await x3.create(this._connection, e15, t20, this._source, this._attributeStore, r17, i20);
        break;
      case "track":
        this._strategy = await q.create(e15, t20, this._source, this._attributeStore, r17, i20);
    }
    for (const a16 of s21) this._strategy.onSubscribe(a16);
  }
  async _updateSortKey(t20, s21) {
    if (this._sortInfo = u2(this._sortInfo?.computed), null != s21) {
      const e15 = s21.byRenderer ? null : await t20.createComputedField(s21);
      this._sortInfo = { ...s21, computed: e15 };
    }
  }
  async _process(e15) {
    const t20 = e15.subscription;
    if (has("esri-2d-update-debug")) {
      const s22 = t20.tile;
      console.debug(`Version[${this._version}] Tile[${s22.key.id}, end=${e15.end}] Processor._process`);
    }
    const s21 = { currentUser: this._schema?.mesh.properties.currentUser };
    await this._fetchResources(e15, s21), s2(t20.signal);
    const i20 = await this._write(e15, t20.tile.createArcadeEvaluationOptions(j3(this._schema)), s21), a16 = t20.tile.tileInfoView.getLODInfoAt(t20.tile.key);
    s2(t20.signal);
    const { message: o14, transferList: n12 } = i20.serialize(a16), c10 = { objectIdMap: null, inner: e15.createMessage(o14, this._version, this._attributeStore.epoch) };
    if (this._schema?.mesh.properties.returnMeshObjectId) {
      c10.objectIdMap = {};
      const t21 = e15.reader?.getCursor();
      if (t21) for (; t21.next(); ) c10.objectIdMap[t21.getDisplayId()] = t21.getObjectId();
    }
    if (s2(t20.signal), await this._connection.container.onMessage(c10, { signal: t20.signal, transferList: n12 }), this._attributeStore.sendUpdates(), has("esri-2d-update-debug")) {
      const s22 = t20.tile;
      console.debug(`Version[${this._version}] Tile[${s22.key.id}, end=${e15.end}] Processor._process.await`);
    }
  }
  async _fetchResources(e15, t20) {
    await this._fetchMatcherResources(e15), await this._fetchWriterResources(e15, t20);
  }
  async _fetchMatcherResources(e15) {
    if (e15.reader) return this._factory.enqueueMatcherRequests(this._proxy, e15.reader);
  }
  async _fetchWriterResources(e15, t20) {
    if (!e15.reader) return;
    const s21 = e15.reader.getCursor(), r17 = e15.subscription.tile.createArcadeEvaluationOptions(j3(this._schema));
    for (; s21.next(); ) this._factory.enqueueWriterRequests(this._proxy, s21, r17, t20);
    await this._proxy.fetchEnqueuedResources();
  }
  async _write(e15, t20, s21) {
    const a16 = e15.subscription.tile, o14 = e15.reader?.getCursor(), n12 = o14?.getSize() ?? 0, h7 = a16.tileInfoView.tileInfo.isWrappable, u16 = a16.tileInfoView.tileInfo.spatialReference.isWGS84, p6 = new g2(a16.key, this._strategy.enablePixelBuffering, h7, u16, n12);
    if (!o14) return p6;
    const g6 = a16.createArcadeEvaluationOptions(j3(this._schema));
    let y8 = 0;
    for (; o14.next(); ) {
      ++y8 % 1e3 || (await A(0), s2(e15.subscription));
      const n13 = this._getSortKeyValue(o14, t20);
      p6.entityStart(o14.getDisplayId(), n13), this._factory.write(p6, this._proxy, o14, g6, s21, a16.level), p6.entityEnd();
    }
    return p6;
  }
  _getSortKeyValue(e15, t20) {
    if (!this._sortInfo) return 0;
    const { computed: s21, order: r17, byRenderer: i20 } = this._sortInfo, a16 = i20 ? this._factory.getSortKey(e15, t20) : s21?.read(e15, t20);
    return null == a16 || isNaN(a16) ? 0 : a16 * ("asc" === r17 ? -1 : 1);
  }
};
function S3(e15, t20) {
  const s21 = [];
  return e15?.timeExtent?.start === t20.timeExtent?.start && e15?.timeExtent?.end === t20.timeExtent?.end || s21.push("timeProperties"), s21;
}
function j3(e15) {
  const { timeZone: t20 } = e15?.mesh.properties ?? {}, { timeExtent: s21 } = e15?.expressionProperties ?? {};
  return { timeZone: t20, timeExtent: s21 };
}

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreStatistics.js
var t14 = class _t {
  static from(e15) {
    let n12 = 0, r17 = 0, o14 = 0;
    return e15.forEach((t20) => {
      const e16 = t20._readGeometry();
      e16 && (r17 += e16.isPoint ? 1 : e16.lengths.reduce((t21, e17) => t21 + e17, 0), o14 += e16.isPoint ? 1 : e16.lengths.length, n12 += 1);
    }), new _t(n12, r17, o14);
  }
  constructor(t20, e15, n12) {
    this.featureCount = t20, this.vertexCount = e15, this.ringCount = n12;
  }
  toJSON() {
    return { featureCount: this.featureCount, ringCount: this.featureCount, vertexCount: this.featureCount };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceQueryInfo.js
var o8 = 4;
function n9(e15) {
  switch (e15.type) {
    case "object-id":
    case "unique-id-simple":
      return `${e15.fieldName} ASC`;
    case "unique-id-composite":
      return `${e15.fieldNames.join(",")} ASC`;
  }
}
function u14(e15, a16, i20) {
  const o14 = n9(i20.featureIdInfo), u16 = e15.source, l13 = { returnCentroid: !(null !== u16 && "object" == typeof u16 && "path" in u16 && g(u16.path)) && "esriGeometryPolygon" === i20.serviceGeometryType, returnGeometry: true, timeReferenceUnknownClient: i20.timeReferenceUnknownClient ?? void 0, outSpatialReference: f2.fromJSON(e15.outSpatialReference), orderByFields: "memory" === e15.type ? [] : [o14], where: a16.mutable.dataFilter.definitionExpression ?? "1=1", outFields: a16.mutable.availableFields, multipatchOption: "esriGeometryMultiPatch" === i20.serviceGeometryType ? "xyFootprint" : null };
  if ("feature" === a16.type) {
    const { gdbVersion: e16, historicMoment: t20, timeExtent: r17 } = a16.mutable.dataFilter;
    return { ...l13, gdbVersion: e16, historicMoment: t20 ? new Date(t20) : null, timeExtent: r17 ? u7.fromJSON(r17) : null, outFields: a16.mutable.availableFields };
  }
  return l13;
}
var l8 = class _l {
  static fromSchema(e15, t20, r17) {
    const a16 = "feature" === t20.type ? t20.mutable.dataFilter.queryScaleRanges : [], i20 = t20.mutable.displayFilterInfo;
    return new _l(u14(e15, t20, r17), i20, a16, r17.subtypeField, t20.mutable.dataFilter.customParameters, r17.geometryType, e15.queryMetadata);
  }
  constructor(e15, t20, r17, a16, i20, s21, o14) {
    this._queryParams = e15, this._displayFilter = t20, this._queryScaleRanges = r17, this._subtypeField = a16, this._customParameters = i20, this._geometryType = s21, this._queryMetadata = o14;
  }
  get pageSize() {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support paged queries");
    const e15 = this._queryMetadata.supportsMaxRecordCountFactor ? o8 : null, t20 = (this._queryMetadata.maxRecordCount ?? 8e3) * (e15 ?? 1);
    return Math.min(8e3, t20);
  }
  get objectIdsQueryPageSize() {
    return this._queryMetadata?.maxRecordCount ?? 2e3;
  }
  updateHistoricMoment(e15) {
    this._queryParams.historicMoment = e15;
  }
  updateFields(e15) {
    this._queryParams.outFields = e15;
  }
  createPatchFieldsQuery(e15, t20, r17) {
    if (!t20.getSize()) return null;
    const a16 = e15.clone();
    if ("*" === this._queryParams.outFields[0]) {
      if ("*" === (a16.outFields ?? [])[0]) return null;
      a16.outFields = this._queryParams.outFields;
    } else {
      const e16 = new Set(this._queryParams.outFields), r18 = [];
      for (const a17 of e16) t20.hasField(a17) || r18.push(a17);
      if (0 === r18.length) return null;
      a16.outFields = r18;
    }
    a16.returnGeometry = false, a16.returnCentroid = false, a16.quantizationParameters = null, a16.cacheHint = true;
    const i20 = { inner: a16, customParameters: this._customParameters };
    if (has("esri-tiles-debug") && null != r17) {
      const e16 = r17.chunkId.toString().replaceAll("/", ".");
      i20.customParameters = i20.customParameters ? { ...i20.customParameters, chunkId: e16 } : { chunkId: e16 };
    }
    return i20;
  }
  createQuery(e15 = {}) {
    if (!this._queryParams) throw new Error("InternalError: queryInfo should be defined");
    return { inner: new R3({ ...this._queryParams, ...e15 }), customParameters: this._customParameters };
  }
  createTileQuery(t20, r17) {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support tile queries");
    const i20 = this.createQuery(r17), s21 = i20.inner;
    if (this._queryScaleRanges.length) {
      const r18 = this._queryScaleRanges.filter((e15) => (!e15.minScale || e15.minScale >= t20.maxScale) && (!e15.maxScale || e15.maxScale <= t20.minScale)).map((e15) => e15.subtypeCode);
      if (r18.length) {
        const t21 = `${this._subtypeField} IN (${r18})`;
        s21.where = r3(s21.where, t21);
      }
    }
    if (this._displayFilter && (s21.where = r3(s21.where, c2(this._displayFilter, t20.minScale, t20.maxScale))), s21.quantizationParameters = r17.quantizationParameters ?? t20.getQuantizationParameters(), s21.resultType = "tile", s21.geometry = t20.extent, this._queryMetadata.supportsQuantization ? "esriGeometryPolyline" === this._geometryType && (s21.maxAllowableOffset = t20.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== this._geometryType && "esriGeometryPolygon" !== this._geometryType || (s21.maxAllowableOffset = t20.resolution, "esriGeometryPolyline" === this._geometryType && (s21.maxAllowableOffset *= has("feature-polyline-generalization-factor"))), s21.defaultSpatialReferenceEnabled = this._queryMetadata.supportsDefaultSpatialReference, s21.compactGeometryEnabled = this._queryMetadata.supportsCompactGeometry, this._queryMetadata.supportsMaxRecordCountFactor && (s21.maxRecordCountFactor = o8), has("esri-tiles-debug")) {
      const e15 = t20.id.replaceAll("/", ".");
      i20.customParameters = i20.customParameters ? { ...i20.customParameters, tileId: e15 } : { tileId: e15 };
    }
    return i20;
  }
  createPagedTileQuery(e15, t20) {
    const r17 = this.pageSize;
    return this.createTileQuery(e15, { start: r17 * t20, num: r17, returnExceededLimitFeatures: true });
  }
  createPagedQuery(e15, t20) {
    const r17 = this.pageSize;
    return this.createQuery({ start: r17 * e15, num: r17, returnExceededLimitFeatures: true, maxRecordCountFactor: o8, quantizationParameters: t20, cacheHint: true });
  }
  createObjectIdsQuery(e15) {
    return this.createQuery({ objectIds: e15, outFields: ["*"] });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamMessenger.js
var a12 = 2500;
var o9 = class extends b2 {
  constructor(e15) {
    super(), this._connection = e15, this._enabledEventTypes = /* @__PURE__ */ new Set(), this._updateInfo = { websocket: 0, client: 0 }, this._lastTime = performance.now(), this._queuedCommands = [], this.addHandles([l(() => this._strategy?.connectionStatus ?? "disconnected", (e16) => {
      this._layerView.setProperty({ propertyName: "pipelineConnectionStatus", value: e16 });
    }, { initial: true }), l(() => this._strategy?.errorString || null, (e16) => this._layerView.setProperty({ propertyName: "pipelineErrorString", value: e16 }), { initial: true })]);
  }
  destroy() {
    this._strategy = null, this.removeAllHandles();
  }
  get _layerView() {
    return this._connection.layerView;
  }
  set strategy(e15) {
    null == this._strategy && this._resetUpdateInfo(performance.now());
    const t20 = "event-handles";
    this.removeHandles(t20), null != e15 && (this.addHandles([e15.events.on("data-received", (e16) => this._onFeature(e16)), e15.events.on("message-received", (e16) => this._onWebSocketMessage(e16)), e15.events.on("features-updated", (e16) => this._onUpdate(e16)), e15.events.on("tick", () => this._onTick())], t20), this._queuedCommands.forEach((t21) => t21(e15)), this._queuedCommands = []), this._strategy = e15;
  }
  updateCustomParameters(e15) {
    null != e15 && this._callOrEnqueue((t20) => t20.updateCustomParameters(e15));
  }
  sendMessageToSocket(e15) {
    this._callOrEnqueue((t20) => t20.sendMessageToSocket(e15));
  }
  sendMessageToClient(e15) {
    this._callOrEnqueue((t20) => t20.sendMessageToClient(e15));
  }
  enableEvent(e15, t20) {
    t20 ? this._enabledEventTypes.add(e15) : this._enabledEventTypes.delete(e15);
  }
  disconnect() {
    this._strategy?.disconnect();
  }
  connect() {
    this._strategy?.connect();
  }
  clear() {
    this._strategy?.clear();
  }
  _onWebSocketMessage(e15) {
    this._enabledEventTypes.has("message-received") && this._layerView.emitEvent({ name: "message-received", event: e15 });
  }
  _onFeature(e15) {
    this._updateInfo.websocket++, this._enabledEventTypes.has("data-received") && this._layerView.emitEvent({ name: "data-received", event: { attributes: e15.attributes, centroid: e15.centroid, geometry: e15.geometry } });
  }
  _onUpdate(e15) {
    this._updateInfo.client += e15;
  }
  _onTick() {
    const e15 = performance.now(), t20 = e15 - this._lastTime;
    if (t20 > a12) {
      const s21 = Math.round(this._updateInfo.client / (t20 / 1e3)), n12 = Math.round(this._updateInfo.websocket / (t20 / 1e3));
      this._resetUpdateInfo(e15), this._layerView.emitEvent({ name: "update-rate", event: { client: s21, websocket: n12 } });
    }
  }
  _resetUpdateInfo(e15) {
    this._lastTime = e15, this._updateInfo.client = 0, this._updateInfo.websocket = 0;
  }
  _callOrEnqueue(e15) {
    null != this._strategy ? e15(this._strategy) : this._queuedCommands.push(e15);
  }
};
r([m()], o9.prototype, "_strategy", void 0), o9 = r([a("esri.views.2d.layers.features.sources.StreamMessenger")], o9);

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/FeatureSnapshotSourceChunk.js
var t15 = class extends i14 {
  constructor(e15, t20, r17, s21) {
    super(), this._reader = e15, this._queryJSON = t20, this._page = r17, this._end = s21, this.chunkId = `${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = this.chunkId;
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get queryInfo() {
    return { type: "snapshot", chunkId: this.chunkId, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e15) {
    const t20 = this.queryFeaturesInBounds(e15.bounds);
    return t20.setTransformForDisplay(e15.transform), t20;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/snapshotUtils.js
async function o10(e15, n12, o14, a16 = {}) {
  const s21 = (await Promise.allSettled(o14.map((r17) => t16(e15, n12, r17, a16)))).filter((r17) => "rejected" === r17.status).map((r17) => r17.reason);
  if (s21.length) throw new s("featurelayer-query", "Encountered errors when downloading data", { errors: s21 });
}
async function t16(r17, o14, t20, a16 = {}) {
  const s21 = `${r17.chunkPrefix ?? ""}${t20.num}`, u16 = await r17.fetch(t20.query, a16, { chunkId: s21 }), i20 = new t15(u16, t20.query.inner.toJSON(), t20.num, false);
  i20.chunkId = i20.normalizedChunkId = s21, s2(a16), o14.insert(i20);
}

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureCache.js
var o11 = 8e3;
var h6 = class {
  constructor(h7, a16, c10, n12) {
    this.store = h7, this.queryInfo = a16, this._options = c10, this._fetch = n12, this._nextBatch = /* @__PURE__ */ new Set(), this._fetchFeatures = k(async () => {
      if (0 === this._nextBatch.size || this._options.signal?.aborted) return;
      const r17 = Array.from(this._nextBatch);
      this._nextBatch.clear(), r17.length > o11 && i2.getLogger("esri.views.2d.layers.FeatureLayerView2D").warn(new s("highlight-too-many-features", `highlight is limited to ${o11} features on large layers configured with a display filter to avoid performance issues`));
      const h8 = this.queryInfo.objectIdsQueryPageSize, a17 = Math.ceil(o11 / h8), c11 = Math.min(a17, Math.ceil(r17.length / h8)), n13 = Array.from({ length: c11 }, (t20, e15) => {
        const s21 = e15 * h8, i20 = Math.min(s21 + h8, r17.length);
        return { num: e15, query: this.queryInfo.createObjectIdsQuery(r17.slice(s21, i20)) };
      });
      try {
        await o10({ chunkPrefix: "cache." + n2(), fetch: this._fetch }, this.store, n13, this._options);
      } catch (f6) {
      }
    });
  }
  prepareCacheUpdate(t20, e15) {
    if (e15) for (const r17 of e15) this._nextBatch.delete(r17);
    for (const r17 of t20) this._nextBatch.add(r17);
  }
  applyCacheUpdate() {
    return 0 === this._nextBatch.size || this._options.signal?.aborted ? null : this._fetchFeatures().catch(() => {
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ALoadStrategy.js
var r15 = class {
  constructor(r17) {
    this._store = r17, this._controller = new AbortController();
  }
  destroy() {
    this._controller.abort();
  }
  get _options() {
    return { signal: this._controller.signal };
  }
  unsafeSetQueryHistoricMoment(r17) {
    throw new Error("InternalError: LoadStrategy does not support query info");
  }
  async queryByObjectId(r17) {
    throw new Error("InternalError: LoadStrategy does not support fetching");
  }
  async addParquetFile(r17) {
    throw new Error("InternalError: LoadStrategy does not support loading blobs");
  }
  prepareCacheUpdate(r17, t20) {
  }
  applyCacheUpdate() {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n10 = 268435455;
var o12 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.idFieldIndices = [], this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
};
function a13(a16, i20, c10, f6 = false) {
  const d11 = 9, u16 = 12, p6 = 13, g6 = 15, l13 = a16.asUnsafe(), h7 = l13.pos(), y8 = new o12();
  let m11 = 0, w3 = 0;
  const k2 = 1, x6 = 2, I3 = 4, b6 = 3;
  let A2 = null, L4 = false;
  const F = [];
  for (; l13.next(); ) switch (l13.tag()) {
    case u16:
      A2 = l13.processMessage(h);
      break;
    case d11:
      if (y8.exceededTransferLimit = l13.getBool(), y8.exceededTransferLimit) {
        y8.offsets.geometry = f6 ? new Float64Array(8e3) : new Int32Array(8e3), y8.centroid = f6 ? new Float64Array(16e3) : new Int32Array(16e3);
        for (let e15 = 0; e15 < y8.centroid.length; e15++) y8.centroid[e15] = n10;
      }
      break;
    case p6: {
      const e15 = l13.processMessage(b4);
      e15.index = m11++, F.push(e15);
      break;
    }
    case g6: {
      const e15 = l13.getLength(), t20 = l13.pos() + e15;
      if (!y8.exceededTransferLimit) {
        const e16 = y8.offsets.geometry, t21 = y8.centroid;
        e16.push(0), t21.push(n10), t21.push(n10);
      }
      !L4 && y8.exceededTransferLimit && (L4 = true, y8.offsets.attributes = f6 ? new Float64Array(8e3 * m11) : new Uint32Array(8e3 * m11));
      let s21 = w3 * m11;
      for (; l13.pos() < t20 && l13.next(); ) switch (l13.tag()) {
        case k2: {
          if (L4) y8.offsets.attributes[s21++] = l13.pos();
          else {
            y8.offsets.attributes.push(l13.pos());
          }
          const e16 = l13.getLength();
          l13.skipLen(e16);
          break;
        }
        case x6:
          if (i20) {
            const e16 = l13.getLength(), t21 = l13.pos() + e16;
            for (; l13.pos() < t21 && l13.next(); ) switch (l13.tag()) {
              case b6: {
                l13.getUInt32();
                const e17 = l13.getSInt64(), t22 = l13.getSInt64();
                y8.centroid[2 * w3] = e17, y8.centroid[2 * w3 + 1] = t22;
                break;
              }
              default:
                l13.skip();
            }
          } else {
            y8.offsets.geometry[w3] = l13.pos();
            const e16 = l13.getLength();
            y8.vertexCount += e16, l13.skipLen(e16);
          }
          break;
        case I3: {
          const e16 = l13.getLength(), t21 = l13.pos() + e16;
          for (; l13.pos() < t21 && l13.next(); ) switch (l13.tag()) {
            case b6: {
              l13.getUInt32();
              const e17 = l13.getSInt64(), t22 = l13.getSInt64();
              y8.centroid[2 * w3] = e17, y8.centroid[2 * w3 + 1] = t22;
              break;
            }
            default:
              l13.skip();
          }
          break;
        }
        default:
          l13.skip();
      }
      w3++, y8.hasFeatures = true;
      break;
    }
    default:
      l13.skip();
  }
  y8.fields = new Z2(F), y8.featureCount = w3, y8.fieldCount = m11;
  const C = e8(c10);
  return y8.idFieldIndices = Array.from(C, (e15) => y8.fields.get(e15)?.index), y8.transform = A2, y8.displayIds = new Uint32Array(y8.featureCount), y8.groupIds = new Uint16Array(y8.featureCount), l13.move(h7), y8;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var d7 = true;
var u15 = 268435455;
var c7 = 128;
var l9 = 128e3;
var g5 = { small: { delta: new Int32Array(c7), decoded: new Int32Array(c7) }, small64: { delta: new Float64Array(0), decoded: new Float64Array(0) }, large: { delta: new Int32Array(l9), decoded: new Int32Array(l9) }, large64: { delta: new Float64Array(0), decoded: new Float64Array(0) } };
function _4(e15, t20) {
  return t20 ? e15 <= g5.small64.delta.length ? g5.small64 : (e15 <= g5.large64.delta.length || (g5.large64.delta = new Float64Array(Math.round(1.25 * e15)), g5.large64.decoded = new Float64Array(Math.round(1.25 * e15))), g5.large64) : e15 <= g5.small.delta.length ? g5.small : (e15 <= g5.large.delta.length || (g5.large.delta = new Int32Array(Math.round(1.25 * e15)), g5.large.decoded = new Int32Array(Math.round(1.25 * e15))), g5.large);
}
function f4(r17) {
  try {
    const e15 = 2, t20 = new a5(new Uint8Array(r17), new DataView(r17));
    for (; t20.next(); ) {
      if (t20.tag() === e15) return I2(t20.getMessage());
      t20.skip();
    }
  } catch (s21) {
    const r18 = new s("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: s21 });
    i2.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r18);
  }
  return null;
}
function I2(e15) {
  const t20 = 1;
  for (; e15.next(); ) {
    if (e15.tag() === t20) return e15.getMessage();
    e15.skip();
  }
  return null;
}
function y5(e15) {
  const t20 = 1, r17 = 2, s21 = 3, n12 = 4, a16 = 5, i20 = 6, h7 = 7, o14 = 8, d11 = 9, u16 = e15.getLength(), c10 = e15.pos() + u16;
  for (; e15.pos() < c10 && e15.next(); ) switch (e15.tag()) {
    case t20:
      return e15.getString();
    case r17:
      return e15.getFloat();
    case s21:
      return e15.getDouble();
    case n12:
      return e15.getSInt32();
    case a16:
      return e15.getUInt32();
    case i20:
      return e15.getInt64();
    case h7:
      return e15.getUInt64();
    case o14:
      return e15.getSInt64();
    case d11:
      return e15.getBool();
    default:
      return e15.skip(), null;
  }
  return null;
}
function m7(e15, t20, r17, s21, n12, a16) {
  return 0.5 * Math.abs(e15 * s21 + r17 * a16 + n12 * t20 - e15 * a16 - r17 * t20 - n12 * s21);
}
function p4(e15, t20, r17, s21, n12) {
  if (!e15) return false;
  return 0 === t20 * n12 - s21 * r17 && t20 * s21 + r17 * n12 > 0;
}
var x5 = class _x extends v {
  static fromBuffer(e15, t20, r17 = false) {
    const s21 = t20.geometryType, n12 = f4(e15), a16 = a13(n12, "esriGeometryPoint" === s21, t20.featureIdInfo, r17);
    return new _x(n12, a16, t20, r17);
  }
  constructor(e15, t20, r17, s21) {
    super(r17), this._use64Bit = s21, this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0 }, this._parseCaches = new Array(), this._geometryType = r17.geometryType, this._reader = e15, this._header = t20, this._hasNext = t20.hasFeatures, this._isPoints = "esriGeometryPoint" === r17.geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getInTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e15) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._featureIndex = e15;
  }
  getAttributeHash() {
    let e15 = "";
    for (const t20 of this._header.fields.fields) e15 += this._readAttributeAtIndex(t20.index) + ".";
    return e15;
  }
  getObjectId() {
    if (1 === this._header.idFieldIndices.length) return this._readAttributeAtIndex(this._header.idFieldIndices[0]);
    const e15 = this._header.idFieldIndices.map((e16) => this._readAttributeAtIndex(e16));
    return JSON.stringify(e15);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e15) {
    this._header.displayIds[this._featureIndex] = e15;
  }
  readGeometryArea() {
    return this._cache.area || this._readGeometry(true), this._cache.area;
  }
  copy() {
    const e15 = this._reader.clone(), t20 = new _x(e15, this._header, this.metadata, this._use64Bit);
    return this.copyInto(t20), t20;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0; ++this._featureIndex < this._size && !this._getExists(); ) ;
    return this._featureIndex < this._size;
  }
  get usedMemory() {
    return s4 + (this._cache.geometry?.usedMemory ?? 0);
  }
  _readX() {
    return this._header.centroid[2 * this._featureIndex];
  }
  _readY() {
    return this._header.centroid[2 * this._featureIndex + 1];
  }
  _readServerCentroid() {
    const e15 = this._header.centroid[2 * this._featureIndex], t20 = this._header.centroid[2 * this._featureIndex + 1];
    return e15 === u15 ? null : new e2([], [e15, t20]);
  }
  _readGeometry(e15 = false) {
    if (void 0 === this._cache.geometry) {
      let r17 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === u15) return null;
        const e16 = this._header.centroid[2 * this._featureIndex], t20 = this._header.centroid[2 * this._featureIndex + 1];
        r17 = new e2([], [e16, t20]);
      } else {
        const s21 = this._header.offsets.geometry[this._featureIndex], n12 = this._reader;
        if (0 === s21) return null;
        n12.move(s21);
        try {
          r17 = e15 ? this._parseGeometryForDisplay(n12) : this._parseGeometry(n12);
        } catch (t20) {
          return null;
        }
      }
      return 0 === r17?.coords.length && (r17 = null), this._cache.geometry = r17, r17;
    }
    return this._cache.geometry;
  }
  _readAttribute(e15, t20) {
    const r17 = this._header.fields.get(e15);
    if (null == r17) return;
    const s21 = this._readAttributeAtIndex(r17.index), n12 = this._header.fields.isDateField(r17.name);
    return t20 ? null == s21 ? s21 : n12 ? new Date(s21) : s21 : s21;
  }
  _readAttributes() {
    const e15 = {};
    for (const t20 of this._header.fields.fields) e15[t20.name] = this._readAttributeAtIndex(t20.index);
    return e15;
  }
  copyInto(e15) {
    super.copyInto(e15), e15._featureIndex = this._featureIndex, e15._featureOffset = this._featureOffset, e15._hasNext = this._hasNext, e15._parseCaches = this._parseCaches;
  }
  _readAttributeAtIndex(e15) {
    let t20 = this._parseCaches[e15];
    if (t20 || (t20 = new a8(this.getSize()), this._parseCaches[e15] = t20), t20.has(this._featureIndex)) return t20.get(this._featureIndex);
    const r17 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e15], s21 = this._reader;
    s21.move(r17);
    const n12 = y5(s21);
    return t20.set(this._featureIndex, n12), n12;
  }
  _readGeometryDeltaDecoded(e15 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t20 = this._readGeometry(e15);
      if (!t20) return this._cache.unquantGeometry = void 0, null;
      if (!this.getInTransform()) return this._cache.unquantGeometry = t20, t20;
      const r17 = _4(t20.coords.length, this._use64Bit).decoded, s21 = t20.clone(r17), n12 = s21.coords;
      let a16 = 0;
      for (const e16 of s21.lengths) {
        for (let t21 = 1; t21 < e16; t21++) {
          const e17 = 2 * (a16 + t21), r18 = 2 * (a16 + t21 - 1);
          n12[e17] += n12[r18], n12[e17 + 1] += n12[r18 + 1];
        }
        a16 += e16;
      }
      return this._cache.unquantGeometry = s21, s21;
    }
    return this._cache.unquantGeometry;
  }
  _parseGeometry(e15) {
    const t20 = 2, r17 = 3, s21 = e15.asUnsafe(), n12 = s21.getLength(), i20 = s21.pos() + n12, h7 = [], o14 = [];
    for (; s21.pos() < i20 && s21.next(); ) switch (s21.tag()) {
      case t20: {
        const e16 = s21.getUInt32(), t21 = s21.pos() + e16;
        for (; s21.pos() < t21; ) o14.push(s21.getUInt32());
        break;
      }
      case r17: {
        const e16 = s21.getUInt32(), t21 = s21.pos() + e16;
        for (h7.push(s21.getSInt64()), h7.push(s21.getSInt64()), this.hasZ && s21.getSInt64(), this.hasM && s21.getSInt64(); s21.pos() < t21; ) h7.push(s21.getSInt64()), h7.push(s21.getSInt64()), this.hasZ && s21.getSInt64(), this.hasM && s21.getSInt64();
        break;
      }
      default:
        s21.skip();
    }
    return new e2(o14, h7);
  }
  _parseGeometryForDisplay(e15) {
    const t20 = 2, s21 = 3, n12 = e15.asUnsafe(), i20 = n12.getLength(), h7 = n12.pos() + i20, o14 = [], u16 = [];
    let c10 = 0, l13 = 0, g6 = null, f6 = 0;
    const I3 = "esriGeometryPolygon" === this.geometryType, y8 = "esriGeometryPolyline" === this.geometryType, x6 = I3 || y8;
    for (; n12.pos() < h7 && n12.next(); ) switch (n12.tag()) {
      case t20: {
        const e16 = n12.getUInt32(), t21 = n12.pos() + e16;
        for (; n12.pos() < t21; ) {
          const e17 = n12.getUInt32();
          o14.push(e17), c10 += e17;
        }
        g6 = _4(2 * c10, this._use64Bit).delta;
        break;
      }
      case s21: {
        n12.getUInt32();
        const e16 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
        n(g6);
        for (const t21 of o14) if (l13 + e16 * t21 > g6.length) for (let e17 = 0; e17 < t21; e17++) n12.getSInt64(), n12.getSInt64(), this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64();
        else if (I3 && d7) {
          const e17 = this.getAreaSimplificationThreshold(t21, this._header.vertexCount);
          let r17 = 2, s22 = 1;
          const a16 = false;
          let i21 = n12.getSInt64(), h8 = n12.getSInt64();
          g6[l13++] = i21, g6[l13++] = h8, this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64();
          let o15 = n12.getSInt64(), d11 = n12.getSInt64();
          for (this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64(); r17 < t21; ) {
            let t22 = n12.getSInt64(), a17 = n12.getSInt64();
            this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64();
            const u17 = i21 + o15, c11 = h8 + d11;
            m7(i21, h8, u17, c11, u17 + t22, c11 + a17) >= e17 ? (f6 += -0.5 * (u17 - i21) * (c11 + h8), s22 > 1 && p4(x6, g6[l13 - 2], g6[l13 - 1], o15, d11) ? (g6[l13 - 2] += o15, g6[l13 - 1] += d11) : (g6[l13++] = o15, g6[l13++] = d11, s22++), i21 = u17, h8 = c11) : (t22 += o15, a17 += d11), o15 = t22, d11 = a17, r17++;
          }
          s22 < 3 || a16 ? l13 -= 2 * s22 : (f6 += -0.5 * (i21 + o15 - i21) * (h8 + d11 + h8), p4(x6, g6[l13 - 2], g6[l13 - 1], o15, d11) ? (g6[l13 - 2] += o15, g6[l13 - 1] += d11, u16.push(s22)) : (g6[l13++] = o15, g6[l13++] = d11, u16.push(++s22)));
        } else {
          let e17 = 0, r17 = n12.getSInt64(), s22 = n12.getSInt64();
          this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64(), g6[l13++] = r17, g6[l13++] = s22, e17 += 1;
          for (let a16 = 1; a16 < t21; a16++) {
            const t22 = n12.getSInt64(), i21 = n12.getSInt64(), h8 = r17 + t22, o15 = s22 + i21;
            f6 += -0.5 * (h8 - r17) * (o15 + s22), this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64(), a16 > 2 && p4(x6, g6[l13 - 2], g6[l13 - 1], t22, i21) ? (g6[l13 - 2] += t22, g6[l13 - 1] += i21) : (g6[l13++] = t22, g6[l13++] = i21, e17 += 1), r17 = h8, s22 = o15;
          }
          u16.push(e17);
        }
        break;
      }
      default:
        n12.skip();
    }
    return this._cache.area = f6, u16.length ? new e2(u16, g6) : null != g6 ? this._createDeltaQuantizedExtrudedGeometry(g6[0], g6[1]) : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/queryAdapters.js
var c8 = class {
  constructor(t20, e15) {
    this.service = t20, this._metadata = e15;
  }
  destroy() {
  }
};
function m8(t20, e15) {
  switch (t20.type) {
    case "memory":
      return new f5(t20, e15);
    case "ogc":
      return new y6(t20, e15);
    case "feature-service":
      return t20.queryMetadata.supportsFormatPBF && has("featurelayer-pbf") ? new l10(t20, e15) : new d8(t20, e15);
  }
}
async function p5(e15) {
  const r17 = new c4();
  return await r17.open(e15, {}), r17;
}
var f5 = class extends c8 {
  constructor(t20, e15) {
    super(t20, e15), this._portsOpen = p5(t20.source).then((t21) => this.client = t21);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(t20, e15) {
    await this._portsOpen;
    const r17 = await this.client.invoke("queryFeatures", t20.toJSON(), e15);
    return u9.fromFeatureSet(r17, this._metadata);
  }
};
var l10 = class extends c8 {
  async executeQuery(t20, e15) {
    const { data: r17 } = await m4(this.service.source, t20, e15), a16 = !t20.quantizationParameters;
    return x5.fromBuffer(r17, this._metadata, a16);
  }
};
var d8 = class extends c8 {
  async executeQuery(t20, s21) {
    const { source: i20, queryMetadata: u16 } = this.service;
    if (null != t20.quantizationParameters && !u16.supportsQuantization) {
      const u17 = t20.clone(), c11 = s3(u17.quantizationParameters);
      u17.quantizationParameters = null;
      const { data: m11 } = await c3(i20, u17, this._metadata.spatialReference, s21), p6 = at(m11, this._metadata.featureIdInfo);
      return mt(c11, p6), u9.fromOptimizedFeatureSet(p6, this._metadata);
    }
    const { data: c10 } = await c3(i20, t20, this._metadata.spatialReference, s21);
    return "esriGeometryPoint" === this._metadata.geometryType && (c10.features = c10.features?.filter((t21) => {
      if (null != t21.geometry) {
        const e15 = t21.geometry;
        return Number.isFinite(e15.x) && Number.isFinite(e15.y);
      }
      return true;
    })), u9.fromFeatureSet(c10, this._metadata);
  }
};
var y6 = class extends c8 {
  async executeQuery(t20, r17) {
    if (t20.quantizationParameters && !this.service.queryMetadata.supportsQuantization) {
      const i21 = t20.clone(), o14 = s3(i21.quantizationParameters);
      i21.quantizationParameters = null;
      const u16 = await $(this.service.source, t20, r17);
      return mt(o14, u16), u9.fromOptimizedFeatureSet(u16, this._metadata);
    }
    const i20 = await $(this.service.source, t20, r17);
    return u9.fromOptimizedFeatureSet(i20, this._metadata);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/AFetchLoadStrategy.js
var i17 = class extends r15 {
  constructor(e15, t20, s21, n12, u16) {
    super(s21), this._serviceInfo = e15, this._queryInfo = t20, this._metadata = n12, this._connection = u16, this._queue = new _({ concurrency: 32, process: async (e16) => {
      const t21 = { signal: e16.options?.signal, query: e16.query.customParameters, useRequestQueue: true };
      return this._adapter.executeQuery(e16.query.inner, t21);
    } }), this._adapter = m8(e15, n12);
  }
  unsafeSetQueryHistoricMoment(e15) {
    this._queryInfo.updateHistoricMoment(e15);
  }
  async updateFields(t20) {
    this._queryInfo.updateFields(t20);
    const r17 = Array.from(this._store.chunks()).map(async (e15) => {
      const t21 = R3.fromJSON(e15.queryInfo.queryJSON);
      if (t21) try {
        return await this._tryUpdateFields(e15.reader, t21, { chunkId: e15.chunkId }), null;
      } catch (r18) {
        return r18;
      }
    }), n12 = (await Promise.all(r17)).filter((e15) => e15);
    if (n12.length) throw new s("featurelayer-query", "Encountered errors when downloading fields", { errors: n12 });
  }
  async queryByObjectId(e15) {
    if (0 === e15.length) return u9.empty(this._metadata);
    const t20 = this._queryInfo.createQuery({ objectIds: e15 });
    return this._fetch(t20, null, null);
  }
  async _fetch(e15, t20, r17) {
    const s21 = await this._enqueue(e15, t20);
    return await this._tryUpdateFields(s21, e15.inner, r17), s21;
  }
  async _tryUpdateFields(r17, s21, n12) {
    const o14 = this._queryInfo.createPatchFieldsQuery(s21, r17, n12);
    if (!o14) return;
    const u16 = await this._enqueue(o14, this._options);
    u16.getSize() === r17.getSize() ? r17.joinAttributes(u16) : i2.getLogger("esri.views.2d.layers.features.sources.strategies.AFetchLoadStrategy").error(new s("featurelayer-query", `Failed to join features. Expected a count of ${r17.getSize()} features, but got ${u16.getSize()}`, { query: o14.inner.toJSON(), debugInfo: n12 }));
  }
  async _enqueue(e15, t20) {
    return this._connection.onEvent({ type: "fetchStart" }), this._queue.push({ query: e15, options: t20 }).finally(() => {
      this._connection.onEvent({ type: "fetchEnd", done: 0 === this._queue.length });
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ATileLoadStrategy.js
var s19 = class extends i17 {
  constructor(t20, s21, h7, r17, d11) {
    super(t20, s21, h7, r17, d11), this._chunksById = /* @__PURE__ */ new Map(), this._featureCache = new h6(h7, s21, this._options, this._fetch.bind(this));
  }
  prepareCacheUpdate(e15, t20) {
    return this._featureCache.prepareCacheUpdate(e15, t20);
  }
  applyCacheUpdate() {
    return this._featureCache.applyCacheUpdate();
  }
  unload(e15) {
    this._removeChunks(e15.tile);
  }
  _addChunk(e15) {
    const t20 = e15.tile.id;
    this._chunksById.has(t20) || this._chunksById.set(t20, []);
    const s21 = e15.size();
    (s21 || e15.first || e15.end) && (has("esri-2d-update-debug") && console.debug(`Chunk[${e15.chunkId}] ATileLoadStrategy.addChunk [count=${s21}]`), this._chunksById.get(t20).push(e15), this._store.insert(e15));
  }
  _removeChunks(e15) {
    const t20 = this._chunksById.get(e15.key.id) ?? [];
    for (const s21 of t20) has("esri-2d-update-debug") && console.debug(`Tile[${e15.key.id}] Chunk[${s21.chunkId}] ATileLoadStrategy.removeChunk`), this._store.remove(s21);
    this._chunksById.delete(e15.key.id);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/DrillDownTileSourceChunk.js
var i18 = class extends i14 {
  constructor(e15, i20, t20, r17, s21, h7) {
    super(), this._reader = e15, this._queryJSON = i20, this._tile = t20, this._sourceTile = r17, this._sourceTileDepth = s21, this._end = h7, this.chunkId = `${this._tile.key.id}.${this._sourceTile?.key.id}${this._end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._sourceTile?.key.normalizedId}${this._end ? "e" : ""}`;
  }
  get queryInfo() {
    return { type: "drill-down-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, sourceTileDepth: this._sourceTileDepth, sourceTileId: this._sourceTile?.key.id, size: this.size(), end: this.end };
  }
  get first() {
    return 0 === this._sourceTileDepth;
  }
  get reader() {
    return this._reader;
  }
  get end() {
    return this._end;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e15) {
    return this._tile.key.id === e15.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/DrillDownTileLoadStrategy.js
var l11 = class {
  constructor(e15, o14) {
    this.subscription = e15, this._tileIdToResult = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._handles = t2([m2(e15.signal, () => this._controller.abort()), m2(o14, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get(t20) {
    return this._tileIdToResult.get(t20);
  }
  set(t20, e15) {
    this._tileIdToResult.set(t20, e15);
  }
  get options() {
    return { signal: this._controller.signal };
  }
};
var a14 = class extends s19 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t20 of this._loadStates.values()) t20.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { supportsDisplayFilter: true, willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t20) {
    this._loadStates.has(t20.key.id) || this._loadStates.set(t20.key.id, new l11(t20, this._options));
    const s21 = this._loadStates.get(t20.key.id);
    let o14;
    try {
      for await (const o15 of this._fetchChunkInfos(s21, t20.tile, 0)) {
        const { queryJSON: t21, reader: i20, sourceTile: l13, sourceTileDepth: a17, tile: n12 } = o15, h7 = new i18(i20, t21, n12, l13, a17, false);
        s2(s21.options), this._addChunk(h7);
      }
    } catch (n12) {
      o14 = n12;
    }
    const a16 = new i18(u9.empty(this._metadata), null, t20.tile, null, -1, true);
    if (this._addChunk(a16), o14) throw o14;
  }
  unload(t20) {
    super.unload(t20), this._loadStates.get(t20.key.id)?.destroy(), this._loadStates.delete(t20.key.id);
  }
  async *_fetchChunkInfos(t20, e15, s21) {
    let o14 = t20.get(e15.id);
    const r17 = !!o14;
    if (o14 || (o14 = await this._fetchChunkInfo(t20, e15, s21), t20.set(e15.id, o14)), o14.reader.exceededTransferLimit && s21 < has("featurelayer-query-max-depth")) for (const i20 of e15.createChildTiles()) yield* this._fetchChunkInfos(t20, i20, s21 + 1);
    else r17 || (yield o14);
  }
  async _fetchChunkInfo(t20, e15, s21) {
    const o14 = t20.subscription.tile.getQuantizationParameters(), r17 = this._queryInfo.createTileQuery(e15, { returnExceededLimitFeatures: false, quantizationParameters: o14 });
    return { reader: await this._fetch(r17, t20.options, { chunkId: e15.id }), queryJSON: r17.inner.toJSON(), tile: t20.subscription.tile, sourceTile: e15, sourceTileDepth: s21 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/PagedTileSourceChunk.js
var t17 = class extends i14 {
  constructor(e15, t20, i20, r17, s21) {
    super(), this._reader = e15, this._queryJSON = t20, this._tile = i20, this._page = r17, this._end = s21, this.chunkId = `${this._tile.key.id}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._page}${this.end ? "e" : ""}`;
  }
  get queryInfo() {
    return { type: "paged-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get page() {
    return this._page;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e15) {
    return this._tile.key.id === e15.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/PagedTileLoadStrategy.js
var l12 = class {
  constructor(e15, o14) {
    this.subscription = e15, this._pages = /* @__PURE__ */ new Set(), this._controller = new AbortController(), this._done = false, this._handles = t2([m2(e15.signal, () => this._controller.abort()), m2(o14, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get pageStart() {
    let t20 = -1;
    for (const e15 of this._pages.values()) t20 = Math.max(t20, e15);
    return t20 + 1;
  }
  get done() {
    return this._done;
  }
  get options() {
    return { signal: this._controller.signal };
  }
  add(t20, e15) {
    this._pages.add(t20), this._done = this._done || e15;
  }
};
var c9 = class extends s19 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t20 of this._loadStates.values()) t20.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { supportsDisplayFilter: true, willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t20) {
    const o14 = u(this._loadStates, t20.key.id, () => new l12(t20, this._options));
    for await (const e15 of this._fetchPages(o14)) this._addChunk(e15);
  }
  unload(t20) {
    super.unload(t20), this._loadStates.get(t20.key.id)?.destroy(), this._loadStates.delete(t20.key.id);
  }
  async *_fetchPages(t20) {
    let e15;
    try {
      for await (const e16 of this._concurrentPageStream(t20)) s2(t20.options), 0 !== e16.size() && (yield e16);
    } catch (r17) {
      e15 = r17;
    }
    if (e15 && b(e15) || (yield new t17(u9.empty(this._metadata), null, t20.subscription.tile, -1, true)), e15) throw e15;
  }
  async *_concurrentPageStream(t20) {
    const e15 = has("featurelayer-query-tile-concurrency"), o14 = this._pageStreamAll(t20), s21 = [];
    let r17 = false, a16 = 1;
    for (; !r17; ) {
      const t21 = [];
      for (; !r17 && s21.length < a16; ) {
        const e16 = o14.next();
        if (!e16.value) {
          r17 = true;
          break;
        }
        const a17 = e16.value;
        a17.then((t22) => {
          t22.reader.exceededTransferLimit || (r17 = true);
        }).catch((t22) => {
          r17 = true;
        }).finally(() => {
          s21.splice(s21.indexOf(a17), 1);
        }), s21.push(a17), t21.push(a17);
      }
      for (const e16 of t21) yield e16;
      s21.length && await Promise.race(s21), a16 < e15 && (a16 += 1);
    }
  }
  *_pageStreamAll(t20) {
    const e15 = Math.ceil(has("featurelayer-query-tile-max-features") / this._queryInfo.pageSize);
    for (let o14 = 0; o14 < e15; o14++) yield this._downloadPage(o14, t20);
  }
  async _downloadPage(t20, e15) {
    s2(e15.options);
    const s21 = e15.subscription.tile, r17 = this._queryInfo.createPagedTileQuery(s21, t20), a16 = await this._fetch(r17, e15.options, { chunkId: `${s21.id}-${t20}` });
    return s2(e15.options), new t17(a16, r17.inner.toJSON(), s21, t20, false);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderParquet.js
var n11 = class _n extends v {
  constructor(t20, r17, n12, s21, i20, d11 = new Uint32Array(s21.size())) {
    super(t20), this._fields = r17, this._geometryInfo = n12, this._inner = s21, this._chunkId = i20, this._displayIds = d11, this._index = -1, this.usedMemory = s4, this._size = this._inner.size();
    const o14 = t20.featureIdInfo;
    "object-id" === o14.type && (this._objectIdFieldIndex = this._fields.get(o14.fieldName)?.index), this._chunkId > 65535 && console.error("Exceeded max allowed parquet reader size");
  }
  destroy() {
    super.destroy(), this._inner.free();
  }
  get fields() {
    return this._fields;
  }
  get geometryType() {
    return this._geometryInfo.geometryType;
  }
  get hasFeatures() {
    return true;
  }
  get hasNext() {
    throw new Error("Method not implemented.");
  }
  get exceededTransferLimit() {
    return false;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  getInTransform() {
    return null;
  }
  getSize() {
    return this._size;
  }
  getCursor() {
    return this.copy();
  }
  getAttributeHash() {
    let e15 = "";
    for (const t20 of this.fields.fields) e15 += this._readAttribute(t20.name, false) + ".";
    return e15;
  }
  getObjectId() {
    return null != this._objectIdFieldIndex ? this._inner.readAttribute(this._index, this._objectIdFieldIndex) : this._index << 16 | this._chunkId;
  }
  getDisplayId() {
    return this._displayIds[this._index];
  }
  setDisplayId(e15) {
    this._displayIds[this._index] = e15;
  }
  setIndex(e15) {
    this._index = e15;
  }
  getBoundsXMin() {
    return this._inner.boundsXMin(this._index);
  }
  getBoundsYMin() {
    return this._inner.boundsYMin(this._index);
  }
  getBoundsXMax() {
    return this._inner.boundsXMax(this._index);
  }
  getBoundsYMax() {
    return this._inner.boundsYMax(this._index);
  }
  setBoundsXMin(e15) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsYMin(e15) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsXMax(e15) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsYMax(e15) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  getIndex() {
    return this._index;
  }
  next() {
    for (; ++this._index < this._size && !this._getExists(); ) ;
    return this._index < this._size;
  }
  readGeometryArea() {
    return this.readGeometryForDisplay()?.area() ?? 0;
  }
  copy() {
    const e15 = new _n(this.metadata, this._fields, this._geometryInfo, this._inner, this._chunkId, this._displayIds);
    return this.copyInto(e15), e15;
  }
  copyInto(e15) {
    super.copyInto(e15), e15._index = this._index;
  }
  readGeometryForDisplayTransformed(e15) {
    const [r17, n12] = e15.translate, [s21, i20] = e15.scale, d11 = this._inner.readGeometryTransformed(this._index, r17, n12, s21, i20);
    return d11 ? new e2(d11.readLengthsUnsafe(), d11.readCoordsUnsafe()) : null;
  }
  _readGeometry(e15) {
    const r17 = this._inner.readCoords(this._index), n12 = this._inner.readLengths(this._index);
    return r17 && n12 ? new e2(n12, r17) : null;
  }
  _readX() {
    return this._readGeometry()?.coords[0];
  }
  _readY() {
    return this._readGeometry()?.coords[1];
  }
  _readServerCentroid() {
    return null;
  }
  _readAttribute(e15, t20) {
    const r17 = this.fields.get(e15);
    if (!r17) return;
    if (null == r17.index) return this.getObjectId();
    const n12 = this._inner.readAttribute(this._index, r17.index);
    if (null == n12) return n12;
    const s21 = this.fields.isDateField(r17.name);
    return t20 ? null == n12 ? n12 : s21 ? new Date(n12) : n12 : n12;
  }
  _readAttributes() {
    const e15 = {};
    for (const t20 of this._fields.fields) null != t20.index ? this._inner.hasField(t20.index) && (e15[t20.name] = this._readAttribute(t20.name, false)) : e15.__OBJECTID = this.getObjectId();
    return e15;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ParquetLoadStrategy.js
var d9 = class extends r15 {
  constructor(e15, t20, i20, s21) {
    super(s21), this._service = e15, this._metadata = t20, this._schema = i20, this._chunkId = 0, this._files = [], this._availableFields = new Set(i20.mutable.availableFields);
    const { geometryInfo: a16 } = this._service;
    if ("location" === a16.encoding.type) this._availableFields.add(a16.encoding.latitudeFieldName), this._availableFields.add(a16.encoding.longitudeFieldName);
    else if (null != a16.encoding.multiscale && a16.encoding.multiscale.levels.length >= 1) {
      const e16 = a16.encoding.multiscale.levels[0];
      this._availableFields.add(e16.column);
    } else this._availableFields.add(a16.encoding.primaryFieldName);
  }
  destroy() {
    for (const e15 of this._files) e15.destroy();
  }
  get about() {
    return { supportsDisplayFilter: false, willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  async updateFields(e15) {
    await this._promise;
    const s21 = new Set(e15), a16 = i3(s21, this._availableFields);
    this._availableFields = u3(a16, this._availableFields), a16.size && await Promise.all(this._files.map((e16) => {
      const t20 = Array.from(a16).map((t21) => e16.metadata.getFieldIndex(t21));
      return e16.inner.updateChunks(new Uint16Array(t20));
    }));
  }
  async load(e15) {
    return null == this._promise && (this._promise = this._download().then(() => {
      this._loadHigherResGeometry();
    })), this._promise;
  }
  unload(e15) {
  }
  async addParquetFile(e15) {
    this._insert(e15);
  }
  async _loadHigherResGeometry() {
    const { geometryInfo: e15 } = this._service;
    if ("wkb" === e15.encoding.type) {
      if (!(null != e15.encoding.multiscale && e15.encoding.multiscale.levels.length >= 1)) return;
      await this.updateFields([e15.encoding.primaryFieldName]);
    }
    const t20 = Array.from(this._store.chunks());
    this._store.clear();
    for (const i20 of t20) this._store.insert(i20);
    this._store.refresh();
  }
  async _insert(t20) {
    const i20 = await u10.create(t20, { geometryInfo: this._service.geometryInfo, outSpatialReference: this._service.outSpatialReference, getCustomParameters: () => this._schema.mutable.dataFilter.customParameters }), { geometryInfo: r17 } = this._service;
    s2(this._options);
    const { fields: o14, timeZoneByFieldName: d11 } = this._service.metadata.fieldsIndex, m11 = o14.map((e15) => ({ ...e15, index: i20.metadata.getFieldIndex(e15.name) })), c10 = Z2.fromJSON({ fields: m11, timeZoneByFieldName: d11 }), h7 = new Uint16Array(Array.from(this._availableFields.values()).map((e15) => c10.get(e15)?.index).filter((e15) => null != e15));
    await i20.inner.readChunksWithCallback(h7, (e15) => {
      const t21 = this._chunkId++, i21 = new n11(this._metadata, c10, r17, e15, t21), s21 = new t15(i21, null, t21, false);
      this._store.insert(s21);
    }), this._files.push(i20);
  }
  async _download() {
    try {
      await Promise.all(this._service.source.urls.map((e16) => this._insert(e16)));
      const e15 = new t15(u9.empty(this._metadata), null, -1, true);
      this._store.insert(e15);
    } catch (e15) {
      throw console.error(e15), e15;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/SnapshotLoadStrategy.js
var i19 = class extends i17 {
  constructor(e15, t20, r17, o14, s21, a16) {
    super(e15, t20, r17, s21, a16), this._snapshotInfo = o14;
  }
  get about() {
    return { supportsDisplayFilter: false, willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  load(e15) {
    return null == this._promise && (this._promise = this._download()), this._promise;
  }
  unload(e15) {
  }
  async _download() {
    const e15 = this._snapshotInfo.initialTolerance, t20 = e15 ? new a3({ mode: "view", originPosition: "upper-left", tolerance: e15 }) : null;
    await this._downloadStreaming(t20), null != t20 && await this._downloadRefresh();
  }
  async _downloadStreaming(t20) {
    try {
      for await (const e15 of this._fetchPages(t20)) this._store.insert(e15);
    } catch (r17) {
      throw new s("featurelayer-query", "Encountered error when downloading data", { error: r17 });
    }
  }
  async _downloadRefresh() {
    try {
      const e15 = [];
      for await (const t20 of this._fetchPages(null)) e15.push(t20);
      this._store.clear();
      for (const t20 of e15) this._store.insert(t20);
      this._store.refresh();
    } catch (t20) {
      throw new s("featurelayer-query", "Encountered error when downloading data", { error: t20 });
    }
  }
  async *_fetchPages(e15) {
    let r17;
    try {
      for await (const t20 of this._concurrentPageStream(e15)) 0 !== t20.size() && (yield t20);
    } catch (o14) {
      r17 = o14;
    }
    if (r17 && b(r17) || (yield new t15(u9.empty(this._metadata), null, -1, true)), r17) throw r17;
  }
  async *_concurrentPageStream(e15) {
    const t20 = has("featurelayer-snapshot-concurrency"), r17 = this._pageStreamAll(e15), o14 = [];
    let s21 = false, a16 = 1;
    for (; !s21; ) {
      const e16 = [];
      for (; !s21 && o14.length < a16; ) {
        const t21 = r17.next();
        if (!t21.value) {
          s21 = true;
          break;
        }
        const a17 = t21.value;
        a17.then((e17) => {
          e17.reader.exceededTransferLimit || (s21 = true);
        }).catch((e17) => {
          s21 = true;
        }).finally(() => {
          o14.splice(o14.indexOf(a17), 1);
        }), o14.push(a17), e16.push(a17);
      }
      for (const t21 of e16) yield t21;
      o14.length && await Promise.race(o14), a16 < t20 && (a16 += 1);
    }
  }
  *_pageStreamAll(e15) {
    const t20 = Math.ceil(this._snapshotInfo.maxFeatureCount / this._queryInfo.pageSize);
    for (let r17 = 0; r17 < t20; r17++) yield this._downloadPage(r17, e15);
  }
  async _downloadPage(e15, t20) {
    s2(this._options);
    const o14 = this._queryInfo.createPagedQuery(e15, t20), s21 = await this._fetch(o14, this._options, { chunkId: e15.toString() }), n12 = new t15(s21, o14.inner.toJSON(), e15, false);
    return s2(this._options), n12;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var d10 = 1e3;
var a15 = class {
  constructor(t20, s21, r17, o14, d11 = 128) {
    if (this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = r17, this._purgeOptions = o14, this.store = t20, "unique-id-composite" === s21.type) throw new s("stream-layer", "composite uniqueIds are not supported");
    this.idField = s21.fieldName, this.purgeInterval = d11, this._useGeneratedIds = this.idField === _2;
  }
  removeById(t20) {
    this._removed.push(t20);
  }
  removeByTrackId(t20) {
    const e15 = this._trackIdToObservations.get(t20);
    if (e15) for (const s21 of e15.entries) this._removed.push(s21);
  }
  add(e15) {
    if (this._useGeneratedIds) {
      const t20 = this._nextId();
      e15.attributes[this.idField] = t20, e15.objectId = t20;
    } else e15.objectId = e15.attributes[this.idField];
    const i20 = e15.objectId;
    if (this._addOrUpdated.set(i20, e15), this._maxAge = Math.max(this._maxAge, e15.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField) return null == this._trackIdLessObservations && (this._trackIdLessObservations = new t6(1e5)), void this._trackIdLessObservations.enqueue(i20);
    const r17 = e15.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(r17)) {
      const e16 = null != this._purgeOptions?.maxObservations ? this._purgeOptions.maxObservations : d10, i21 = r2(e16, 0, d10);
      this._trackIdToObservations.set(r17, new t6(i21));
    }
    const o14 = this._trackIdToObservations.get(r17), a16 = o14?.enqueue(i20);
    null != a16 && (this._addOrUpdated.has(a16) ? this._addOrUpdated.delete(a16) : this._removed.push(a16));
  }
  checkForUpdates() {
    const t20 = this._getToAdd(), e15 = this._getToRemove(), s21 = performance.now(), i20 = s21 - this._lastPurge, d11 = Date.now();
    i20 >= this.purgeInterval && (this._purge(s21), this._lastPurge = s21);
    const a16 = [];
    if (null != e15) for (const r17 of e15) {
      const t21 = this.store.removeById(r17);
      null != t21 && a16.push(t21);
    }
    const n12 = [];
    if (null != t20) {
      const i21 = new Set(e15 ?? []);
      for (const e16 of t20) i21.has(e16.objectId) || (e16.attributes[e5] = s21, e16.attributes[i5] = d11, this.store.add(e16), n12.push(e16));
    }
    return !(!n12.length && !a16?.length) && (this.store.update(n12, a16), true);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size) return null;
    const t20 = new Array(this._addOrUpdated.size);
    let e15 = 0;
    return this._addOrUpdated.forEach((s21) => t20[e15++] = s21), this._addOrUpdated.clear(), t20;
  }
  _getToRemove() {
    const t20 = this._removed;
    return this._removed.length ? (this._removed = [], t20) : null;
  }
  _nextId() {
    const t20 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t20;
  }
  _purge(t20) {
    const e15 = this._purgeOptions;
    null != e15 && (this._purgeSomeByDisplayCount(e15), this._purgeByAge(e15), this._purgeByAgeReceived(t20, e15), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t20) {
    if (!t20.displayCount) return;
    let e15 = this.store.size;
    if (e15 > t20.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s21 of this._trackIdToObservations.values()) if (e15 > t20.displayCount && s21.size) {
          const t21 = s21.dequeue();
          this._removed.push(t21), e15--;
        }
      }
      if (null != this._trackIdLessObservations) {
        let s21 = e15 - t20.displayCount;
        for (; s21-- > 0; ) {
          const t21 = this._trackIdLessObservations.dequeue();
          null != t21 && this._removed.push(t21);
        }
      }
    }
  }
  _purgeByAge(t20) {
    const e15 = this._timeInfo?.startTimeField;
    if (!t20.age || !e15) return;
    const s21 = 60 * t20.age * 1e3, i20 = this._maxAge - s21;
    this.store.forEach((t21) => {
      t21.attributes[e15] < i20 && this._removed.push(t21.objectId);
    });
  }
  _purgeByAgeReceived(t20, e15) {
    if (!e15.ageReceived) return;
    const s21 = t20 - 60 * e15.ageReceived * 1e3;
    this.store.forEach((t21) => {
      t21.attributes[e5] < s21 && this._removed.push(t21.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t20, e15) => {
      0 === t20.size && this._trackIdToObservations.delete(e15);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s20 = class extends b2 {
  constructor(r17) {
    super(r17);
  }
  get connectionStatus() {
    return this.connection?.connectionStatus;
  }
  get errorString() {
    return this.connection?.errorString;
  }
};
r([m()], s20.prototype, "connection", void 0), r([m()], s20.prototype, "connectionStatus", null), r([m()], s20.prototype, "errorString", null), s20 = r([a("esri.views.2d.layers.features.sources.StreamConnectionState")], s20);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamFeatureStore.js
var t18 = class {
  constructor(e15, t20) {
    this._metadata = e15, this._onUpdate = t20, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._objectIdToFeature.size;
  }
  get reader() {
    return u9.fromFeatures([...this._objectIdToFeature.values()], this._metadata);
  }
  add(e15) {
    this._objectIdToFeature.set(e15.objectId, e15);
  }
  forEach(e15) {
    this._objectIdToFeature.forEach(e15);
  }
  removeById(e15) {
    const t20 = this._objectIdToFeature.get(e15);
    return t20 ? (this._objectIdToFeature.delete(e15), t20) : null;
  }
  clear() {
    this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  update(e15, t20) {
    this._onUpdate(e15?.length ?? 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/StreamSourceChunk.js
var r16 = class extends i14 {
  constructor(e15) {
    super(), this._reader = e15, this.chunkId = "stream-chunk", this.normalizedChunkId = "stream-chunk";
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return true;
  }
  get end() {
    return true;
  }
  get queryInfo() {
    return { type: "stream", chunkId: this.chunkId, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e15) {
    const r17 = this.queryFeaturesInBounds(e15.bounds);
    return r17.setTransformForDisplay(e15.transform), r17;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/StreamLoadStrategy.js
var m9 = class extends r15 {
  constructor(t20, s21, o14, c10, h7) {
    super(o14), this._service = t20, this._dataFilter = s21, this._streamOptions = c10, this._metadata = h7, this._connectionState = new s20(), this._forceRefresh = false, this.events = new o();
    const { timeInfo: m11 } = this._metadata, { purgeOptions: d11 } = s21;
    this._stagingStore = new t18(this._metadata.weakCloneWithAdditionalFields([{ name: i5, alias: "timeReceived", type: "esriFieldTypeDate" }]), (e15) => this.events.emit("features-updated", e15)), this._manager = new a15(this._stagingStore, h7.featureIdInfo, m11, d11), this.connect();
  }
  destroy() {
    super.destroy(), this.disconnect();
  }
  get about() {
    return { supportsDisplayFilter: false, willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    return this._connectionState?.errorString;
  }
  async refresh() {
    const e15 = null != this._chunk;
    return this._manager.checkForUpdates() || !e15 || this._forceRefresh ? (this._chunk && this._store.remove(this._chunk), this._forceRefresh = false, this._chunk = new r16(this._stagingStore.reader), this._store.insert(this._chunk), this.events.emit("tick"), true) : (this.events.emit("tick"), false);
  }
  async updateFields(e15) {
    throw new Error("Updating available fields not supported for StreamLayer");
  }
  async load(e15) {
  }
  unload(e15) {
  }
  disconnect() {
    this._connection = u2(this._connection), this._connectionState.connection = null, this._handlesGroup?.remove();
  }
  connect() {
    if (null != this._connection) return;
    const { geometryType: e15, spatialReference: s21 } = this._metadata, { maxReconnectionAttempts: n12, maxReconnectionInterval: i20, geometryDefinition: r17, definitionExpression: a16, customParameters: c10 } = this._dataFilter;
    this._connection = r5(this._service.source, s21, this._streamOptions.outSR, e15, a16, r17, n12, i20, c10), this._handlesGroup = t2([this._connection.on("data-received", (e16) => this._onFeature(e16)), this._connection.on("message-received", (e16) => this._onWebSocketMessage(e16))]), this._connectionState.connection = this._connection;
  }
  clear() {
    this._manager.checkForUpdates(), this._stagingStore.clear(), this._forceRefresh = true;
  }
  updateCustomParameters(e15) {
    this._connection?.updateCustomParameters(e15);
  }
  sendMessageToSocket(e15) {
    this._connection?.sendMessageToSocket(e15);
  }
  sendMessageToClient(e15) {
    this._connection?.sendMessageToClient(e15);
  }
  _onWebSocketMessage(e15) {
    if ("type" in e15) switch (e15.type) {
      case "delete":
        if (e15.objectIds) for (const t20 of e15.objectIds) this._manager.removeById(t20);
        if (e15.trackIds) for (const t20 of e15.trackIds) this._manager.removeByTrackId(t20);
        break;
      case "clear":
        this.clear();
    }
    this.events.emit("message-received", e15);
  }
  _onFeature(e15) {
    try {
      this._manager.add(e15), this.events.emit("data-received", e15);
    } catch (t20) {
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/SourceChunkStore.js
var o13 = class {
  constructor(s21) {
    this._metadata = s21, this._chunks = /* @__PURE__ */ new Map(), this._chunksToRemove = [], this._overrides = new a11(), this.events = new o(), this.featureAdapter = new r8();
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (const e15 of this._chunks.values()) this._chunksToRemove.push(e15);
    this._chunks.clear(), this._overrides.clearWeakOverrides();
  }
  *chunks() {
    this._overrides && (yield this._overrides.asChunk(this._metadata)), yield* this._chunks.values();
  }
  insert(e15) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e15.chunkId}] SourceChunkStore.insert`), this._overrides.onChunkInsert(e15), this._chunks.set(e15.chunkId, e15), this.events.emit("changed");
  }
  remove(e15) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e15.chunkId}] SourceChunkStore.remove`), this._chunks.delete(e15.chunkId), this._chunksToRemove.push(e15);
  }
  cleanup() {
    const e15 = this._chunksToRemove;
    return this._chunksToRemove = [], this._overrides.cleanup(this._chunks.values()), e15;
  }
  applyOverride(e15) {
    this._overrides.apply(e15, this), this.events.emit("changed");
    for (const s21 of this._chunks.values()) s21.invalidate();
  }
  takeOverrideUpdate() {
    return this._overrides.takeOverrideUpdate();
  }
  refresh() {
    this.events.emit("refresh");
  }
  forEach(e15) {
    const s21 = /* @__PURE__ */ new Set();
    for (const t20 of this.chunks()) {
      const r17 = t20.reader.getCursor();
      for (; r17.next(); ) {
        const t21 = r17.getObjectId();
        s21.has(t21) || (e15(r17.copy()), s21.add(t21));
      }
    }
  }
  forEachUnsafe(e15) {
    const s21 = /* @__PURE__ */ new Set();
    for (const t20 of this.chunks()) {
      const r17 = t20.reader.getCursor();
      for (; r17.next(); ) {
        const t21 = r17.getObjectId();
        s21.has(t21) || (e15(r17), s21.add(t21));
      }
    }
  }
  mapObjectIdsFromGlobalIds(e15, s21) {
    const t20 = /* @__PURE__ */ new Map(), r17 = new Set(e15);
    return this._overrides.putWeakObjectIdsFromGlobalIds(t20, r17, s21), this._forEachUnsafeIgnoreOverrides((e16) => {
      const o14 = e16.readAttribute(s21);
      if (o14 && r17.has(o14) && !t20.has(o14)) {
        const s22 = e16.getObjectId();
        t20.set(o14, s22);
      }
    }), t20;
  }
  forEachInBounds(e15, s21) {
    const t20 = /* @__PURE__ */ new Set();
    for (const r17 of this.chunks()) {
      const o14 = r17.queryFeaturesInBounds(e15);
      for (; o14.next(); ) {
        const e16 = o14.getObjectId();
        t20.has(e16) || (s21(o14.copy()), t20.add(e16));
      }
    }
  }
  forEachBounds(e15, t20) {
    const r17 = u6();
    for (const s21 of e15) {
      s21.getBounds(r17) && t20(r17);
    }
  }
  _forEachUnsafeIgnoreOverrides(e15) {
    const s21 = /* @__PURE__ */ new Set();
    for (const t20 of this._chunks.values()) {
      const r17 = t20.reader.withoutOverrides().getCursor();
      for (; r17.next(); ) {
        const t21 = r17.getObjectId();
        s21.has(t21) || (e15(r17), s21.add(t21));
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSource.js
var E2 = class {
  constructor(e15, t20, s21, r17, a16) {
    this.service = e15, this._aggregateAdapter = t20, this._subscriptions = s21, this._connection = r17, this._cachedObjectIds = a16, this._updateTracking = new d3({ debugName: "FeatureSource" }), this._didInvalidateData = false, this._metadata = i7.createFeature(e15.metadata), this._store = new o13(this._metadata);
  }
  destroy() {
    this._strategy?.destroy(), this._store.destroy(), this._streamMessenger?.destroy(), "memory" === this.service.type && this.service.source.map((e15) => e15.close());
  }
  get metadata() {
    if (!this._metadata) throw new Error("InternalError: Metadata not defined. Was update called?");
    return this._metadata;
  }
  get store() {
    return this._store;
  }
  get streamMessenger() {
    return null == this._streamMessenger && this._initStreamMessenger(), this._streamMessenger;
  }
  get statistics() {
    return t14.from(this._store);
  }
  get updateTracking() {
    return this._updateTracking;
  }
  get queryEngine() {
    if (!this._queryEngine) {
      if (!this._schema) return null;
      const { dataFilter: e15 } = this._schema.mutable, t20 = this._schema.mutable.availableFields, s21 = this._metadata;
      this._queryEngine = new L3({ featureStore: this._store, fieldsIndex: s21.fieldsIndex, geometryType: s21.geometryType, featureIdInfo: s21.featureIdInfo, hasM: false, hasZ: false, spatialReference: this.service.outSpatialReference, aggregateAdapter: this._aggregateAdapter, timeInfo: s21.timeInfo, definitionExpression: e15.definitionExpression, availableFields: t20 });
    }
    return this._queryEngine;
  }
  get isStream() {
    return "stream" === this._schema.type;
  }
  get hasDisplayFilter() {
    return !!this._schema && ("displayFilterInfo" in this._schema.mutable && null != this._schema.mutable.displayFilterInfo);
  }
  chunks() {
    return Array.from(this._store.chunks());
  }
  prepareCacheUpdate(e15, t20) {
    const s21 = /* @__PURE__ */ new Set(), r17 = /* @__PURE__ */ new Set();
    for (const a16 of e15) this._cachedObjectIds.has(a16) || (this._cachedObjectIds.add(a16), s21.add(a16));
    for (const a16 of t20) this._cachedObjectIds.delete(a16), r17.add(a16);
    this.hasDisplayFilter && this._strategy.prepareCacheUpdate(s21, r17);
  }
  async applyCacheUpdate() {
    this.hasDisplayFilter && await this._updateTracking.addPromise(this._strategy.applyCacheUpdate());
  }
  cleanup() {
    return this._store.cleanup();
  }
  onSubscribe(e15) {
    this._connection.onEvent({ type: "subscribe", tile: e15.tile.id });
    const t20 = this._strategy?.load(e15);
    t20 && (t20.then(() => this._connection.onEvent({ type: "loaded", tile: e15.tile.id })).catch((t21) => this._connection.onEvent({ type: "error", tile: e15.tile.id, error: t21 })), this._updateTracking.addPromise(t20));
  }
  onResume(e15) {
    this._updateTracking.addPromise(d(this._strategy?.load(e15)));
  }
  onUnsubscribe(e15) {
    this._connection.onEvent({ type: "unsubscribe", tile: e15.tile.id }), this._strategy?.unload(e15);
  }
  applyOverride(e15) {
    this._didInvalidateData = true, this._store.applyOverride(e15);
  }
  takeOverrideUpdate() {
    return this._store.takeOverrideUpdate();
  }
  async update(e15, t20) {
    const s21 = e15.source, n12 = y(this._schema?.mutable, s21.mutable);
    if (!n12) return false;
    if (has("esri-2d-update-debug") && console.debug(`Version[${t20}] FeatureSource.update`, { changes: n12 }), this._schema = s21, this._queryEngine?.destroy(), this._queryEngine = null, "feature-service" === this.service.type && null != this.service.queryMetadata.lastEditDate && (this._lastEditDate = this.service.queryMetadata.lastEditDate), null == this._streamMessenger && "stream" === this._schema.type && this._initStreamMessenger(), a4(n12, "sourceRefreshVersion") && this._strategy?.refresh) return this._strategy.refresh();
    if (("feature" === s21.type || "parquet" === s21.type) && a4(n12, "availableFields")) {
      if (await this._queryLastEditDateChanged() || this._didInvalidateData) this._didInvalidateData = false, await this._updateStrategy(t20);
      else {
        this._connection.onEvent({ type: "updateFieldsStart" });
        try {
          await this._strategy.updateFields(s21.mutable.availableFields), this._connection.onEvent({ type: "updateFieldsEnd" });
        } catch (o14) {
          this._connection.onEvent({ type: "updateFieldsError", error: o14 });
        }
      }
      return false;
    }
    return !!(s6(n12, "dataFilter") || s6(n12, "sourceRefreshVersion") || this._strategy.about.supportsDisplayFilter && s6(n12, "displayFilterInfo")) && (await this._updateStrategy(t20), true);
  }
  async addParquetFile(e15) {
    this._strategy.addParquetFile(e15);
  }
  unsafeSetQueryHistoricMoment(e15) {
    "feature" === this._schema.type && (this._schema.mutable.dataFilter.historicMoment = e15, this._strategy.unsafeSetQueryHistoricMoment(new Date(e15)));
  }
  _initStreamMessenger() {
    null == this._streamMessenger && (this._streamMessenger = new o9(this._connection));
  }
  async normalizeOverrides(e15) {
    const t20 = { historicMoment: e15.historicMoment, commands: { updateWeak: e15.commands.updateWeak.map(s5.fromJSON), removeWeak: e15.commands.removeWeak, update: e15.commands.update.map(s5.fromJSON), remove: e15.commands.remove, release: e15.commands.release } }, s21 = e15.commands.updateByIdWeak, r17 = await this._queryOptimizedFeatures(s21);
    return t20.commands.updateWeak.push(...r17), t20;
  }
  async _queryOptimizedFeatures(e15) {
    if (0 === e15.length) return [];
    const t20 = [], s21 = (await this._strategy.queryByObjectId(e15)).getCursor();
    for (; s21.next(); ) t20.push(s21.readOptimizedFeatureWorldSpace());
    return t20;
  }
  getObjectIdsFromGlobalIds(e15) {
    const t20 = this.metadata.globalIdField;
    if (null == t20) throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");
    const s21 = this._store.mapObjectIdsFromGlobalIds(e15, t20).values();
    return Array.from(s21);
  }
  async _queryLastEditDateChanged() {
    if (null == this._lastEditDate) return false;
    const t20 = this.service.source, s21 = { ...t20.query, f: "json" }, r17 = (await H(t20.path, { query: s21, responseType: "json" })).data.editingInfo.lastEditDate;
    return r17 !== this._lastEditDate && (this._lastEditDate = r17, true);
  }
  async _createStrategy() {
    const e15 = "isSourceHosted" in this.service && this.service.isSourceHosted, t20 = Array.isArray(this.service.source), s21 = this.service.source && "collection" in this.service.source, r17 = e15 || t20 || s21;
    if ("stream" === this._schema.type) {
      const e16 = new m9(this.service, this._schema.mutable.dataFilter, this._store, { outSR: this.service.outSpatialReference }, this.metadata);
      return this._streamMessenger.strategy = e16, e16;
    }
    if ("parquet" === this._schema.type) {
      const e16 = this.service;
      return new d9(e16, this._metadata, this._schema, this._store);
    }
    const a16 = this.service, i20 = l8.fromSchema(a16, this._schema, this._metadata), n12 = await this._supportSnapshotMode(a16, i20);
    return n12 ? new i19(a16, i20, this._store, n12, this.metadata, this._connection) : r17 ? new c9(a16, i20, this._store, this.metadata, this._connection) : new a14(a16, i20, this._store, this.metadata, this._connection);
  }
  async _updateStrategy(e15) {
    const t20 = await this._createStrategy();
    this._connection.onEvent({ type: "updateStrategyStart", about: t20.about });
    const r17 = !!this._strategy;
    this._store.clear(), this._strategy?.destroy(), this._strategy = t20, has("esri-2d-update-debug") && console.debug(`Version[${e15}] FeatureSource.updateStrategy`, { strategy: t20 });
    const a16 = Array.from(this._subscriptions.values());
    if (!a16.length) return void this._connection.onEvent({ type: "updateStrategyEnd" });
    const i20 = Promise.all(a16.map((e16) => this._strategy.load(e16).then(() => this._connection.onEvent({ type: "loaded", tile: e16.tile.id })).catch((t21) => this._connection.onEvent({ type: "error", tile: e16.tile.id, error: t21 }))));
    this._updateTracking.addPromise(i20), this._strategy.prepareCacheUpdate(this._cachedObjectIds);
    try {
      r17 && await i20;
    } catch (n12) {
      f(n12);
    }
    this._connection.onEvent({ type: "updateStrategyEnd" }), has("esri-2d-update-debug") && console.debug(`Version[${e15}] FeatureSource.updateStrategyEnd`, { strategy: t20 });
  }
  async _supportSnapshotMode(e15, t20) {
    const { queryMetadata: s21 } = e15, r17 = s21.snapshotInfo;
    if (!r17) return null;
    return await this._executeExceedsLimitQuery(e15, t20, r17) ? null : r17;
  }
  async _executeExceedsLimitQuery(e15, t20, s21) {
    if (!s21.supportsExceedsLimit) return this._executeExceedsLimitFallbackQuery(e15, t20, s21);
    try {
      const r17 = e15.source, a16 = t20.createQuery();
      a16.inner.orderByFields = [], a16.inner.returnGeometry = false;
      const i20 = new p();
      i20.statisticType = "exceedslimit", i20.maxPointCount = s21.maxFeatureCount, i20.maxRecordCount = s21.maxFeatureCount, i20.outStatisticFieldName = "exceedslimit", s21.maxVertexCount && (i20.maxVertexCount = s21.maxVertexCount), a16.inner.outStatistics = [i20], a16.inner.cacheHint = true;
      const n12 = await c3(r17, a16.inner, void 0, { query: a16.customParameters }), o14 = n12.data.features[0]?.attributes.exceedslimit;
      return !(0 === o14);
    } catch (r17) {
      return true;
    }
  }
  async _executeExceedsLimitFallbackQuery(e15, t20, s21) {
    if (s21.maxVertexCount) return true;
    const r17 = e15.source, a16 = t20.createQuery();
    a16.inner.orderByFields = [], a16.inner.returnGeometry = false, a16.inner.cacheHint = true;
    try {
      return (await S(r17, a16.inner, { query: a16.customParameters })).data.count > s21.maxFeatureCount;
    } catch (i20) {
      return true;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureTileSubscription.js
var t19 = class {
  constructor(t20, r17) {
    this.tile = t20, this.version = r17, this._abortController = new AbortController();
  }
  get key() {
    return this.tile.key;
  }
  get signal() {
    return this._abortController.signal;
  }
  abort() {
    this._abortController.abort();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorker.js
var m10 = class {
  constructor(e15) {
    this.inner = e15, this.resolver = L2();
  }
};
var y7 = class {
  constructor() {
    this._aggregateAdapter = { getFeatureObjectIds: (e15) => this._processor.getFeatureObjectIdsForAggregate(e15) }, this._subscriptions = /* @__PURE__ */ new Map(), this._cachedObjectIds = /* @__PURE__ */ new Set(), this._updateRequested = false, this._didSourceRefresh = false, this._updateSubscriptionRequests = [], this._updateHighlightRequests = [];
  }
  destroy() {
    this._subscriptions.clear(), this._processor?.destroy(), this._source?.destroy(), this._handles?.remove(), this._updateOverridesRequest = null, this._tileInfoView = null;
  }
  onAttach(e15) {
    has("esri-2d-update-debug") && console.debug("Pipeline.onAttach");
    const s21 = this._connection, i20 = j.fromJSON(e15.tileInfoJSON);
    this._tileInfoView = new h2(i20), this._source = new E2(e15.service, this._aggregateAdapter, this._subscriptions, s21, this._cachedObjectIds), this._processor = new w2(s21, this._source), this._handles = t2([this._source.store.events.on("changed", () => this._requestUpdate()), this._source.store.events.on("refresh", () => this._requestRefresh()), l(() => this._source.updateTracking.updating, () => {
      this._requestUpdate(), d(this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true }));
    })]);
  }
  onDetach() {
    has("esri-2d-update-debug") && console.debug("Pipeline.onDetach"), this.destroy();
  }
  set remoteClient(e15) {
    this._connection = new t7(e15);
  }
  get features() {
    const t20 = this._source?.queryEngine;
    if (!t20) throw new s("no-queryEngine", "No query engine defined");
    return t20;
  }
  get aggregates() {
    const t20 = this._processor?.aggregateQueryEngine;
    if (!t20) throw new s("no-queryEngine", "No aggregate query engine defined");
    return t20;
  }
  get processor() {
    return this._processor;
  }
  get streamMessenger() {
    return this._source.streamMessenger;
  }
  getDisplayFeatures(e15) {
    return this._processor.getDisplayFeatures(e15);
  }
  getDisplayIds(e15) {
    return this._processor.getDisplayIds(e15);
  }
  getObjectIdsFromGlobalIds(e15) {
    return this._source.getObjectIdsFromGlobalIds(e15);
  }
  async updateSchema(e15, t20) {
    return has("esri-2d-update-debug") && this._updateSchemaRequest && console.error("InternalError: Schema already updating"), this._updateSchemaRequest = new m10({ schema: e15, version: t20 }), this._requestUpdate(), this._updateSchemaRequest.resolver.promise;
  }
  updateSubscriptions(e15) {
    const t20 = new m10(e15);
    return this._updateSubscriptionRequests.push(t20), this._requestUpdate(), t20.resolver.promise;
  }
  updateHighlight(e15) {
    const t20 = new m10(e15);
    return this._updateHighlightRequests.push(t20), this._requestUpdate(), t20.resolver.promise;
  }
  async addParquetFile(e15) {
    return this._source.addParquetFile(e15);
  }
  async onOverride(t20) {
    if (null != this._updateOverridesRequest) throw new s("featurelayer", "InternalError - Already processing an edit");
    this._updateOverridesRequest = new m10(t20);
    const s21 = this._updateOverridesRequest.resolver.promise;
    return this._requestUpdate(), s21;
  }
  queryStatistics() {
    return this._source.statistics.toJSON();
  }
  async queryVisibleFeatures(e15, t20) {
    return this.features.executeQuery(e15, t20);
  }
  async queryHeatmapStatistics(e15) {
    const t20 = Math.round(u4(e15.radius));
    let s21 = Number.POSITIVE_INFINITY, i20 = Number.NEGATIVE_INFINITY;
    const r17 = "string" == typeof e15.fieldOffset, o14 = e15.fieldOffset ?? 0, n12 = Array.from(this._subscriptions.values()), u16 = this._source.chunks(), d11 = t20 ** 2, c10 = 3 / (Math.PI * d11), h7 = 2 * t20, l13 = Math.ceil(a7 / h7);
    for (const a16 of n12) {
      const t21 = a16.tile, n13 = new Float64Array(l13 * l13);
      for (const s22 of u16) {
        const i21 = s22.getTileReader(t21);
        if (!i21) continue;
        const u17 = i21.getCursor();
        for (; u17.next(); ) {
          let t22 = 1;
          if (null != e15.field) {
            const s24 = u17.readAttribute(e15.field);
            t22 = r17 ? -1 * +s24 : +s24 + o14;
          }
          const s23 = u17.readXForDisplay() / h7, i22 = u17.readYForDisplay() / h7, a17 = Math.floor(s23), p6 = Math.floor(i22);
          if (a17 < 0 || p6 < 0 || a17 >= l13 || p6 >= l13) continue;
          const g6 = ((0.5 + a17 - s23) * h7) ** 2 + ((0.5 + p6 - i22) * h7) ** 2;
          if (g6 > d11) continue;
          const _5 = t22 * (c10 * (1 - g6 / d11) ** 2);
          n13[p6 + a17 * l13] += _5;
        }
      }
      for (let e16 = 0; e16 < n13.length; e16++) s21 = Math.min(s21, n13[e16]), i20 = Math.max(i20, n13[e16]);
    }
    return { max: i20, min: s21 };
  }
  async getSampleFeatures(e15) {
    const t20 = this._source.chunks();
    if (t20.reduce((e16, t21) => e16 + t21.size(), 0) <= e15.minFeatureCount) {
      if (!this._source.updateTracking.updating) {
        const e16 = [];
        return this._source.store.forEachUnsafe((t21) => e16.push(t21.readLegacyFeatureWorldSpace())), e16;
      }
      return null;
    }
    const s21 = /* @__PURE__ */ new Set(), i20 = [], r17 = t20.map((e16) => e16.reader.getCursor()), o14 = new t(), u16 = 3 * e15.sampleSize;
    for (let n12 = 0; n12 < u16 && i20.length < e15.sampleSize; n12++) {
      const e16 = r17[o14.getIntRange(0, t20.length - 1)];
      if (0 === e16.getSize()) continue;
      const n13 = o14.getIntRange(0, e16.getSize() - 1);
      e16.setIndex(n13);
      const u17 = e16.getObjectId();
      s21.has(u17) || (s21.add(u17), i20.push(e16.readLegacyFeatureWorldSpace()));
    }
    return i20.length >= e15.sampleSize ? i20 : null;
  }
  _requestUpdate() {
    this._updateRequested || (this._updateRequested = true, t3(() => this._scheduleNextUpdate()));
  }
  _requestRefresh() {
    this._didSourceRefresh = true, this._requestUpdate();
  }
  _scheduleNextUpdate() {
    this._updateRequested && (this._ongoingUpdate || (this._ongoingUpdate = O(this._doUpdate()).finally(() => {
      this._ongoingUpdate = null, this._scheduleNextUpdate();
    }), this._updateRequested = false));
  }
  _subscribe(e15) {
    const t20 = e15.tileId;
    if (this._subscriptions.has(t20)) return;
    has("esri-2d-update-debug") && console.debug(`Tile[${t20}] Pipeline.subscribe`);
    const s21 = new r9(this._tileInfoView, t20), i20 = new t19(s21, e15.version);
    this._subscriptions.set(t20, i20), this._source.onSubscribe(i20), this._processor.onSubscribe(i20);
  }
  _unsubscribe(e15) {
    const t20 = this._subscriptions.get(e15);
    t20 && (has("esri-2d-update-debug") && console.debug(`Tile[${e15}] Pipeline.unsubscribe`), t20.abort(), this._source.onUnsubscribe(t20), this._processor.onUnsubscribe(t20), this._subscriptions.delete(t20.key.id));
  }
  async _doUpdate() {
    if (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateStart"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true }), this._updateSubscriptionRequests.length) {
      const e16 = this._updateSubscriptionRequests;
      this._updateSubscriptionRequests = [];
      for (const t21 of e16) this._doUpdateSubscriptions(t21.inner), t21.resolver.resolve();
    }
    if (this._updateHighlightRequests.length) {
      const e16 = this._updateHighlightRequests, t21 = /* @__PURE__ */ new Set(), s22 = /* @__PURE__ */ new Set();
      for (const i20 of e16) for (const { objectId: e17, highlightFlags: r18 } of i20.inner.highlights) r18 ? (t21.add(e17), s22.delete(e17)) : (s22.add(e17), t21.delete(e17));
      this._source.prepareCacheUpdate(t21, s22);
    }
    const e15 = this._updateSchemaRequest;
    this._updateSchemaRequest = null;
    let t20 = false;
    if (null != e15) {
      const { schema: s22, version: i20 } = e15.inner;
      t20 = await this._doUpdateSchema(s22, i20);
    }
    this._processor.requiresInvalidation() && (t20 = true), this._didSourceRefresh && (t20 = true, this._didSourceRefresh = false), t20 && (this._processor.invalidate(), await this._connection.container.updateRenderState(this._processor.version));
    const s21 = this._updateOverridesRequest;
    if (this._updateOverridesRequest = null, null != s21) {
      has("esri-2d-update-debug") && console.debug("Pipeline.applyOverride", s21.inner), null != s21.inner.historicMoment && this._source.unsafeSetQueryHistoricMoment(s21.inner.historicMoment);
      const e16 = await this._source.normalizeOverrides(s21.inner);
      this._source.applyOverride(e16), has("esri-2d-update-debug") && console.debug("Pipeline.endOverride", s21.inner);
    }
    if (await this._source.applyCacheUpdate(), this._updateHighlightRequests.length) {
      const e16 = this._updateHighlightRequests;
      this._updateHighlightRequests = [];
      for (const t21 of e16) this._processor.updateHighlight(t21.inner), t21.resolver.resolve();
    }
    const r17 = this._source.cleanup();
    this._processor.removeChunks(r17);
    try {
      const e16 = this._source.takeOverrideUpdate();
      if (null != e16 && this._subscriptions.size) {
        has("esri-2d-update-debug") && console.debug("Pipeline.applyOverrideChangesStart"), await this._connection.container.lockForOverrides();
        try {
          await this._processor.applyOverrideUpdate(e16);
        } catch (o14) {
          has("esri-2d-update-debug") && console.debug("InternalError", o14);
        }
        await this._connection.container.unlockForOverrides(), has("esri-2d-update-debug") && console.debug("Pipeline.applyOverrideChangesEnd");
      }
      this._subscriptions.size && (has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksStart"), await this._processor.updateChunks(), has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksEnd"));
    } catch (o14) {
      f(o14);
    }
    null != s21 && s21.resolver.resolve(), null != e15 && e15.resolver.resolve(), null == e15 && t20 && await this._connection.container.trySwapRenderState(), this._updateRequested ? (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=true]"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true })) : (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: this._updateRequested }));
  }
  async _doUpdateSchema(e15, t20) {
    has("esri-2d-update-debug") && console.debug(`Version[${t20}] Pipeline.updateStart`, { schema: e15 });
    const s21 = { tileInfo: this._tileInfoView?.tileInfo }, i20 = await this._source.update(e15, t20), r17 = Array.from(this._subscriptions.values()), o14 = this._processor.update(e15, t20, s21, i20, r17);
    return has("esri-2d-update-debug") && console.debug(`Version[${t20}] Pipeline.updateEnd`), o14;
  }
  _doUpdateSubscriptions(e15) {
    has("esri-2d-update-debug") && console.debug("Pipeline.updateSubscriptions", e15);
    for (const t20 of e15.subscribe) this._subscribe(t20);
    for (const t20 of e15.unsubscribe) this._unsubscribe(t20);
  }
};
export {
  y7 as default
};
//# sourceMappingURL=FeaturePipelineWorker-ZAO6WQZW.js.map
