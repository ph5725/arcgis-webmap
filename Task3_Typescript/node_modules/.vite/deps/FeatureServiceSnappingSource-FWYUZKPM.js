import {
  i as i2,
  o as o3
} from "./chunk-MGOMMN56.js";
import "./chunk-AT62KISP.js";
import "./chunk-24K5NVHX.js";
import "./chunk-KCZYWZT4.js";
import "./chunk-EOS5YLWS.js";
import {
  t as t2
} from "./chunk-P5XPQUDN.js";
import "./chunk-WYLBCBQH.js";
import {
  b as b2
} from "./chunk-LYH5EAFA.js";
import "./chunk-ENM5QFON.js";
import "./chunk-2H2JCT45.js";
import {
  W,
  gs,
  ts
} from "./chunk-MI6QXJMY.js";
import "./chunk-3GCFO25G.js";
import {
  r as r3
} from "./chunk-IAKXH7PU.js";
import {
  e as e4
} from "./chunk-RVXIJHL6.js";
import {
  y as y3
} from "./chunk-2JAL6FAS.js";
import "./chunk-BGR5EVZD.js";
import {
  h as h3
} from "./chunk-HHJDK6FG.js";
import "./chunk-RTDWTAVK.js";
import "./chunk-QLJ6JQFC.js";
import "./chunk-3LL6ALVC.js";
import "./chunk-NZPABYQQ.js";
import "./chunk-CCHJ3WNU.js";
import "./chunk-BUA5NESM.js";
import "./chunk-SHYE33QH.js";
import "./chunk-LTMF2W73.js";
import {
  h as h4
} from "./chunk-YIXK32VF.js";
import {
  E
} from "./chunk-H34ENSPL.js";
import "./chunk-DRAQJS2F.js";
import "./chunk-VNTS5E5O.js";
import {
  o as o2
} from "./chunk-TMFB3DKM.js";
import "./chunk-LBC3MAJX.js";
import {
  j,
  l as l2
} from "./chunk-3ZORAHSR.js";
import {
  t
} from "./chunk-SZN55B2M.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-UG6RJXJ2.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-6WL2SHX6.js";
import "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-KHRHKYU2.js";
import {
  d as d3
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import {
  i2 as i,
  j2,
  m2,
  u,
  y as y2
} from "./chunk-LYSDGL5S.js";
import {
  g
} from "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import {
  m as m3
} from "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import {
  l as l3
} from "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import {
  r as r2
} from "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  d as d2
} from "./chunk-HPGYEHVI.js";
import {
  p
} from "./chunk-YBJ5GVXQ.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import {
  n
} from "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import {
  y
} from "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import {
  P
} from "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import {
  c as c2,
  e as e3
} from "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  U,
  a as a2,
  h as h2,
  l,
  w
} from "./chunk-A3VAC24F.js";
import {
  o
} from "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  b,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  c,
  d,
  e,
  e2,
  k,
  s
} from "./chunk-GZ2P4SCJ.js";
import "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  L,
  h
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/tileUtils.js
function a3(s2, o4) {
  return ts(o4.extent, c3), gs(c3, o2(n2, s2.x, s2.y, 0));
}
var c3 = W();
var n2 = n();

// node_modules/@arcgis/core/views/2d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles2D.js
var p2 = class extends b {
  get tiles() {
    const e5 = this.tilesCoveringView, t3 = null != this.pointOfInterest ? this.pointOfInterest : this.view.center;
    return e5.sort((e6, i3) => a3(t3, e6) - a3(t3, i3)), e5;
  }
  _scaleEnabled() {
    return r3(this.view.scale, this.layer.minScale || 0, this.layer.maxScale || 0);
  }
  get tilesCoveringView() {
    if (!this.view.ready || !this.view.featuresTilingScheme || !this.view.state || null == this.tileInfo) return [];
    if (!this._scaleEnabled) return [];
    const { spans: e5, lodInfo: t3 } = this.view.featuresTilingScheme.getTileCoverage(this.view.state, 0), { level: i3 } = t3, r4 = [];
    for (const { row: o4, colFrom: s2, colTo: n4 } of e5) for (let e6 = s2; e6 <= n4; e6++) {
      const s3 = t3.normalizeCol(e6), n5 = new t(null, i3, o4, s3);
      this.tileInfo.updateTileInfo(n5), r4.push(n5);
    }
    return r4;
  }
  get tileInfo() {
    return this.view.featuresTilingScheme?.tileInfo ?? null;
  }
  get tileSize() {
    return null != this.tileInfo ? this.tileInfo.size[0] : 256;
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles(l(() => this.view?.state?.viewpoint, () => this.notifyChange("tilesCoveringView"), U));
  }
};
r([m({ readOnly: true })], p2.prototype, "tiles", null), r([m({ readOnly: true })], p2.prototype, "_scaleEnabled", null), r([m({ readOnly: true })], p2.prototype, "tilesCoveringView", null), r([m({ readOnly: true })], p2.prototype, "tileInfo", null), r([m({ readOnly: true })], p2.prototype, "tileSize", null), r([m({ constructOnly: true })], p2.prototype, "view", void 0), r([m({ constructOnly: true })], p2.prototype, "layer", void 0), r([m()], p2.prototype, "pointOfInterest", void 0), p2 = r([a("esri.views.2d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")], p2);

// node_modules/@arcgis/core/views/3d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles3D.js
var a4 = class extends b {
  get _sortedTilesCoveringView() {
    const e5 = (this.view.featureTiles?.tiles?.toArray() ?? []).map(c4), t3 = this._effectivePointOfInterest;
    return null != t3 && e5.sort((e6, r4) => a3(t3, e6) - a3(t3, r4)), e5;
  }
  get tileInfo() {
    return this.view.featureTiles?.tilingScheme?.toTileInfo() ?? null;
  }
  get tileSize() {
    return this.view.featureTiles?.tileSize ?? 256;
  }
  get _effectivePointOfInterest() {
    const e5 = this.pointOfInterest;
    return null != e5 ? e5 : this.view.pointsOfInterest?.focus.location;
  }
  constructor(e5) {
    super(e5), this.tiles = [], this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles([l(() => this.view.featureTiles, (e5) => {
      this.removeHandles(u2), e5 && this.addHandles(e5.addClient(), u2);
    }, h2), l(() => this._sortedTilesCoveringView, (e5) => this._set("tiles", e5), { initial: true, equals: (e5, t3) => h(e5, t3, (e6, t4) => e6.id === t4.id) })]);
  }
};
function c4({ lij: [e5, t3, r4], extent: i3 }) {
  return new t(`${e5}/${t3}/${r4}`, e5, t3, r4, i3);
}
r([m({ readOnly: true })], a4.prototype, "tiles", void 0), r([m({ readOnly: true })], a4.prototype, "_sortedTilesCoveringView", null), r([m({ readOnly: true })], a4.prototype, "tileInfo", null), r([m({ readOnly: true })], a4.prototype, "tileSize", null), r([m({ constructOnly: true })], a4.prototype, "view", void 0), r([m()], a4.prototype, "pointOfInterest", void 0), r([m()], a4.prototype, "_effectivePointOfInterest", null), a4 = r([a("esri.views.3d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")], a4);
var u2 = "feature-tiles";

// node_modules/@arcgis/core/views/support/TileTreeDebugger.js
var u3 = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]];
var d4 = class extends b {
  constructor(e5) {
    super(e5), this.updating = false, this.enablePolygons = true, this.enableLabels = true, this._polygons = /* @__PURE__ */ new Map(), this._labels = /* @__PURE__ */ new Map(), this._symbols = u3.map((e6) => new m3({ color: [e6[0], e6[1], e6[2], 0.6], outline: { color: "black", width: 1 } })), this._enabled = true;
  }
  initialize() {
    this.update();
  }
  destroy() {
    this._enabled = false, this.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e5) {
    this._enabled !== e5 && (this._enabled = e5, this.update());
  }
  update() {
    if (!this._enabled) return void this.clear();
    const e5 = (e6) => {
      if (null != e6.label) return e6.label;
      let s2 = e6.lij.toString();
      return null != e6.loadPriority && (s2 += ` (${e6.loadPriority})`), e6.measures && (s2 += `[${e6.measures.lodLevel}]`), s2;
    }, t3 = this.getTiles(), i3 = new Array(), a6 = new Set((this._labels.size, this._labels.keys()));
    t3.forEach((m5, u5) => {
      const d5 = m5.lij.toString();
      a6.delete(d5);
      const g2 = m5.measures?.lodLevel ?? m5.level, f = m5.geometry;
      if (this.enablePolygons && !this._polygons.has(d5)) {
        const e6 = new d3({ geometry: f, symbol: this._symbols[g2 % this._symbols.length] });
        this._polygons.set(d5, e6), i3.push(e6);
      }
      if (this.enableLabels) {
        const a7 = e5(m5), g3 = u5 / (t3.length - 1), w2 = o(0, 200, g3), _2 = o(20, 6, g3) / 0.75, j3 = null != m5.loadPriority && m5.loadPriority >= t3.length, v = new l3([w2, j3 ? 0 : w2, j3 ? 0 : w2]), S = "3d" === this.view.type ? () => new j2({ verticalOffset: new i({ screenLength: 40 / 0.75 }), callout: new u({ color: new l3("white"), border: new m2({ color: new l3("black") }) }), symbolLayers: new V([new y2({ text: a7, halo: { color: "white", size: 1 / 0.75 }, material: { color: v }, size: _2 })]) }) : () => new g({ text: a7, haloColor: "white", haloSize: 1 / 0.75, color: v, size: _2 }), L2 = this._labels.get(d5);
        if (L2) {
          const e6 = S();
          null != L2.symbol && JSON.stringify(e6) === JSON.stringify(L2.symbol) || (L2.symbol = e6);
        } else {
          const e6 = new d3({ geometry: f.extent.center, symbol: S() });
          this._labels.set(d5, e6), i3.push(e6);
        }
      }
    });
    const m4 = new Array();
    a6.forEach((e6) => {
      const s2 = this._polygons.get(e6);
      null != s2 && (m4.push(s2), this._polygons.delete(e6));
      const o4 = this._labels.get(e6);
      null != o4 && (m4.push(o4), this._labels.delete(e6));
    }), this.view.graphics.removeMany(m4), this.view.graphics.addMany(i3);
  }
  clear() {
    this.view.graphics.removeMany(Array.from(this._polygons.values())), this.view.graphics.removeMany(Array.from(this._labels.values())), this._polygons.clear(), this._labels.clear();
  }
};
r([m({ constructOnly: true })], d4.prototype, "view", void 0), r([m({ readOnly: true })], d4.prototype, "updating", void 0), r([m()], d4.prototype, "enabled", null), d4 = r([a("esri.views.support.TileTreeDebugger")], d4);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/WorkerTileTreeDebugger.js
var n3 = class extends d4 {
  constructor(e5) {
    super(e5);
  }
  initialize() {
    const e5 = setInterval(() => this._fetchDebugInfo(), 2e3);
    this.addHandles(e(() => clearInterval(e5)));
  }
  getTiles() {
    if (!this._debugInfo) return [];
    const e5 = /* @__PURE__ */ new Map(), t3 = /* @__PURE__ */ new Map();
    this._debugInfo.storedTiles.forEach((t4) => {
      e5.set(t4.data.id, t4.featureCount);
    }), this._debugInfo.pendingTiles.forEach((r5) => {
      e5.set(r5.data.id, r5.featureCount), t3.set(r5.data.id, r5.state);
    });
    const r4 = (r5) => {
      const o5 = t3.get(r5), s2 = e5.get(r5) ?? "?";
      return o5 ? `${o5}:${s2}
${r5}` : `store:${s2}
${r5}`;
    }, o4 = /* @__PURE__ */ new Map();
    return this._debugInfo.storedTiles.forEach((e6) => {
      o4.set(e6.data.id, e6.data);
    }), this._debugInfo.pendingTiles.forEach((e6) => {
      o4.set(e6.data.id, e6.data);
    }), Array.from(o4.values()).map((e6) => ({ lij: [e6.level, e6.row, e6.col], level: e6.level, geometry: P.fromExtent(c2(e6.extent, this.view.spatialReference)), label: r4(e6.id) }));
  }
  _fetchDebugInfo() {
    this.handle.getDebugInfo(null).then((e5) => {
      this._debugInfo = e5, this.update();
    });
  }
};
r([m({ constructOnly: true })], n3.prototype, "handle", void 0), n3 = r([a("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")], n3);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorkerHandle.js
var u4 = class extends b {
  get updating() {
    return this._updatingHandles.updating || this._workerHandleUpdating;
  }
  constructor(e5) {
    super(e5), this._updatingHandles = new h4(), this._suspendController = null, this.schedule = null, this.hasZ = false, this.elevationAlignPointsInFeatures = async (e6) => {
      const t3 = [];
      for (const { points: o4 } of e6.pointsInFeatures) for (const { z: e7 } of o4) t3.push(e7);
      return { elevations: t3, drapedObjectIds: /* @__PURE__ */ new Set(), failedObjectIds: /* @__PURE__ */ new Set() };
    }, this.queryForSymbologySnapping = async () => ({ candidates: [], sourceCandidateIndices: [] }), this.availability = 0, this._workerHandleUpdating = true, this.updateOutFields = k(async (e6, t3) => {
      await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateOutFields", [...e6], t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
    });
  }
  destroy() {
    this._suspendController = e2(this._suspendController), this._workerHandle.destroy(), this._updatingHandles.destroy();
  }
  initialize() {
    this._workerHandle = new y4(this.schedule, { alignElevation: async (e5, { signal: t3 }) => ({ result: await this.elevationAlignPointsInFeatures(e5.query, t3) }), getSymbologyCandidates: async (e5, { signal: t3 }) => ({ result: await this.queryForSymbologySnapping(e5, t3) }) }), this.addHandles([this._workerHandle.on("notify-updating", ({ updating: e5 }) => this._workerHandleUpdating = e5), this._workerHandle.on("notify-availability", ({ availability: e5 }) => this._set("availability", e5))]);
  }
  async setup(e5, t3) {
    const o4 = c5(e5.layer);
    if (null == o4) return;
    const i3 = { configuration: h5(e5.configuration), serviceInfo: o4, spatialReference: e5.spatialReference.toJSON(), hasZ: this.hasZ, elevationInfo: e5.layer.elevationInfo?.toJSON() };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setup", i3, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async configure(e5, t3) {
    const o4 = h5(e5);
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("configure", o4, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async refresh(e5) {
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh", {}, e5)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, e5));
  }
  async fetchCandidates(e5, t3) {
    const { point: o4, filter: i3, coordinateHelper: n4 } = e5, a6 = { ...e5, point: e4(o4[0], o4[1], o4[2], n4.spatialReference.toJSON()), filter: i3?.toJSON() };
    return this._workerHandle.invoke(a6, t3);
  }
  async updateTiles(e5, t3) {
    const o4 = { tiles: e5.tiles, tileInfo: null != e5.tileInfo ? e5.tileInfo.toJSON() : null, tileSize: e5.tileSize };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles", o4, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async handleEdits({ historicMoment: e5, addedFeatures: t3, deletedFeatures: i3, updatedFeatures: n4 }, a6) {
    const s2 = { historicMoment: e5, addedFeatures: t3?.map(({ objectId: e6 }) => e6).filter(L) ?? [], deletedFeatures: i3?.map(({ objectId: e6, globalId: t4 }) => ({ objectId: e6, globalId: t4 })) ?? [], updatedFeatures: n4?.map(({ objectId: e6 }) => e6).filter(L) ?? [] };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("handleEdits", s2, a6)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, a6));
  }
  async setHistoricMoment(e5, t3) {
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setHistoricMoment", { moment: e5 }, t3));
  }
  getDebugInfo(e5) {
    return this._workerHandle.invokeMethod("getDebugInfo", {}, e5);
  }
  async notifyElevationSourceChange() {
    await this._workerHandle.invokeMethod("notifyElevationSourceChange", {});
  }
  async notifySymbologyChange() {
    await this._workerHandle.invokeMethod("notifySymbologyChange", {});
  }
  async setSymbologySnappingSupported(e5) {
    await this._workerHandle.invokeMethod("setSymbologySnappingSupported", e5);
  }
  async setSuspended(e5) {
    this._suspendController?.abort(), this._suspendController = new AbortController(), await this._workerHandle.invokeMethod("setSuspended", e5, this._suspendController.signal);
  }
};
function h5(e5) {
  return { filter: null != e5.filter ? e5.filter.toJSON() : null, customParameters: e5.customParameters, viewType: e5.viewType };
}
function c5(e5) {
  return "multipatch" === e5.geometryType || "mesh" === e5.geometryType ? null : { url: e5.parsedUrl?.path ?? "", fieldsIndex: e5.fieldsIndex.toJSON(), geometryType: y.toJSON(e5.geometryType), capabilities: e5.capabilities, objectIdField: e5.objectIdField, globalIdField: e5.globalIdField, spatialReference: e5.spatialReference.toJSON(), timeInfo: e5.timeInfo?.toJSON() };
}
r([m({ constructOnly: true })], u4.prototype, "schedule", void 0), r([m({ constructOnly: true })], u4.prototype, "hasZ", void 0), r([m({ constructOnly: true })], u4.prototype, "elevationAlignPointsInFeatures", void 0), r([m({ constructOnly: true })], u4.prototype, "queryForSymbologySnapping", void 0), r([m({ readOnly: true })], u4.prototype, "updating", null), r([m({ readOnly: true })], u4.prototype, "availability", void 0), r([m()], u4.prototype, "_workerHandleUpdating", void 0), u4 = r([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")], u4);
var y4 = class extends h3 {
  constructor(e5, t3) {
    super("FeatureServiceSnappingSourceWorker", "fetchCandidates", {}, e5, { strategy: "dedicated", client: t3 });
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTilesSimple.js
var a5 = class extends b {
  get tiles() {
    return [new t("0/0/0", 0, 0, 0, e3(-1e8, -1e8, 1e8, 1e8))];
  }
  get tileInfo() {
    return new j({ origin: new _({ x: -1e8, y: 1e8, spatialReference: this.layer.spatialReference }), size: [512, 512], lods: [new l2({ level: 0, scale: 1, resolution: 390625 })], spatialReference: this.layer.spatialReference });
  }
  get tileSize() {
    return this.tileInfo.size[0];
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null;
  }
};
r([m({ readOnly: true })], a5.prototype, "tiles", null), r([m({ readOnly: true })], a5.prototype, "tileInfo", null), r([m({ readOnly: true })], a5.prototype, "tileSize", null), r([m({ constructOnly: true })], a5.prototype, "layer", void 0), r([m()], a5.prototype, "pointOfInterest", void 0), a5 = r([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")], a5);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureServiceSnappingSource.js
var O = class extends b {
  get _updateTilesParameters() {
    return { tiles: this._tilesOfInterest.tiles, tileInfo: this._tilesOfInterest.tileInfo, tileSize: this._tilesOfInterest.tileSize };
  }
  get _layerView() {
    return this.view?.allLayerViews.find((e5) => e5.layer === this._layer);
  }
  get _isSuspended() {
    if (p(this._layer)) {
      if (!this.layerSource.sublayerSources.some((e5) => e5.enabled && e5.layer.visible)) return true;
    }
    return !!this.view && (false !== this._layerView?.suspended || !this.layerSource.enabled);
  }
  get updating() {
    return this._workerHandle?.updating || this._updatingHandles.updating;
  }
  get _outFields() {
    const { view: e5, _layerView: t3, layerSource: r4 } = this, { layer: i3 } = r4, { fieldsIndex: s2, timeInfo: o4, floorInfo: a6, subtypeField: n4 } = i3, l4 = t3 && "filter" in t3 ? t3.filter : null, d5 = l4?.where && "1=1" !== l4.where ? this._getOrLoadWhereFields(l4.where, s2) : [];
    if (l4?.timeExtent && o4) {
      const { startField: e6, endField: t4 } = o4, r5 = s2.get(e6)?.name ?? e6, i4 = s2.get(t4)?.name ?? t4;
      r5 && d5.push(r5), i4 && d5.push(i4);
    }
    if (e5?.map && b2(e5.map) && e5.map.utilityNetworks?.find((e6) => e6.isUtilityLayer(i3))) {
      const e6 = i3.fieldsIndex.get("assetGroup")?.name, t4 = i3.fieldsIndex.get("assetType")?.name;
      e6 && t4 && (d5.push(e6), d5.push(t4));
    }
    if (i3 && a6?.floorField && e5?.floors?.length) {
      const e6 = s2.get(a6.floorField)?.name ?? a6.floorField;
      e6 && d5.push(e6);
    }
    if (n4) {
      const e6 = s2.get(n4)?.name ?? n4;
      e6 && d5.push(e6);
    }
    return new Set(d5);
  }
  get configuration() {
    const { view: e5 } = this, { apiKey: t3, customParameters: r4 } = this._layer, i3 = null != e5 ? e5.type : "2d", s2 = this._layer.createQuery();
    return this._layerView && "effectiveDisplayFilter" in this._layerView && (s2.where = r2(s2.where, this._layerView.effectiveDisplayFilter?.where)), { filter: s2, customParameters: t3 ? { ...r4, token: t3 } : r4, viewType: i3 };
  }
  get availability() {
    return this._workerHandle?.availability ?? 0;
  }
  get _layer() {
    return this.layerSource.layer;
  }
  constructor(e5) {
    super(e5), this._updatingHandles = new h4(), this._workerHandle = null, this._debug = null, this._memoizedMakeGetGroundElevation = t2(i2);
  }
  initialize() {
    let e5;
    const t3 = this.view;
    if (null == t3 || t3.destroyed) this._tilesOfInterest = new a5({ layer: this._layer }), e5 = this._workerHandle = new u4();
    else switch (t3.type) {
      case "2d":
        this._tilesOfInterest = new p2({ view: t3, layer: this._layer }), e5 = this._workerHandle = new u4();
        break;
      case "3d": {
        const { resourceController: r4 } = t3, i3 = this._layer;
        this._tilesOfInterest = new a4({ view: t3 }), e5 = this._workerHandle = new u4({ schedule: (e6) => r4.immediate.schedule(e6), hasZ: this._layer.hasZ && (this._layer.returnZ ?? true), elevationAlignPointsInFeatures: async (e6, r5) => {
          const s2 = await t3.whenLayerView(i3);
          return s(r5), s2.elevationAlignPointsInFeatures(e6, r5);
        }, queryForSymbologySnapping: async (e6, r5) => {
          const s2 = await t3.whenLayerView(i3);
          return s(r5), s2.queryForSymbologySnapping(e6, r5);
        } }), this.addHandles([t3.elevationProvider.on("elevation-change", ({ context: t4 }) => {
          const { elevationInfo: r5 } = i3;
          y3(t4, r5) && d(e5.notifyElevationSourceChange());
        }), l(() => i3.elevationInfo, () => d(e5.notifyElevationSourceChange()), h2), l(() => this._layerView?.layer?.renderer, () => d(e5.notifySymbologyChange()), h2), l(() => this._layerView?.symbologySnappingSupported ?? false, (t4) => d(e5.setSymbologySnappingSupported(t4)), h2), a2(() => this._layerView?.layer, ["edits", "apply-edits", "graphic-update"], () => e5.notifySymbologyChange())]);
        break;
      }
    }
    this.addHandles([c(e5)]), d(e5.setup({ layer: this._layer, spatialReference: this.spatialReference, configuration: this.configuration }, null)), this._updatingHandles.add(() => this._updateTilesParameters, () => d(e5.updateTiles(this._updateTilesParameters, null)), h2), this.addHandles([l(() => this.configuration, (t4) => d(e5.configure(t4, null)), U), l(() => this._layer.historicMoment, (t4) => d(e5.setHistoricMoment(t4)), w), l(() => this._outFields, (t4) => d(e5.updateOutFields(t4)), h2), l(() => this._isSuspended, (t4) => d(e5.setSuspended(t4)), w)]), null != t3 && this.addHandles(l(() => E.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES, (r4) => {
      r4 && !this._debug ? (this._debug = new n3({ view: t3, handle: e5 }), this.addHandles(c(this._debug), "debug")) : !r4 && this._debug && this.removeHandles("debug");
    }, h2)), this.addHandles([this.layerSource.layer.on("edits", (t4) => d(e5.handleEdits(t4, null))), this.layerSource.layer.on("apply-edits", (e6) => this._updatingHandles.addPromise(e6.result))]);
  }
  destroy() {
    this._updatingHandles.destroy(), this._tilesOfInterest.destroy();
  }
  refresh() {
    this._workerHandle?.refresh(null);
  }
  async fetchCandidates(e5, t3) {
    const { coordinateHelper: r4, point: i3 } = e5;
    this._tilesOfInterest.pointOfInterest = r4.arrayToPoint(i3);
    const s2 = this._memoizedMakeGetGroundElevation(this.view, r4.spatialReference);
    return (await this._workerHandle.fetchCandidates({ ...e5 }, t3)).candidates.map((e6) => o3(e6, s2));
  }
  getDebugInfo(e5) {
    return this._workerHandle.getDebugInfo(e5);
  }
  _getOrLoadWhereFields(e5, t3) {
    const { _whereModule: i3 } = this;
    if (!this._loadWhereModuleTask && !i3) {
      const e6 = d2(async () => {
        const e7 = await import("./WhereClause-B6KTXMIJ.js");
        return this._whereModule = e7.default, this._whereModule;
      });
      return this._loadWhereModuleTask = e6, this._updatingHandles.addPromise(e6.promise), [];
    }
    if (!i3) return [];
    try {
      return i3.create(e5, { fieldsIndex: t3 }).fieldNames;
    } catch (s2) {
      return [];
    }
  }
};
r([m({ constructOnly: true })], O.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], O.prototype, "layerSource", void 0), r([m({ constructOnly: true })], O.prototype, "view", void 0), r([m()], O.prototype, "_tilesOfInterest", void 0), r([m({ readOnly: true })], O.prototype, "_updateTilesParameters", null), r([m()], O.prototype, "_layerView", null), r([m()], O.prototype, "_isSuspended", null), r([m({ readOnly: true })], O.prototype, "updating", null), r([m()], O.prototype, "_outFields", null), r([m({ readOnly: true })], O.prototype, "configuration", null), r([m({ readOnly: true })], O.prototype, "availability", null), r([m()], O.prototype, "_loadWhereModuleTask", void 0), r([m()], O.prototype, "_whereModule", void 0), O = r([a("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")], O);
export {
  O as FeatureServiceSnappingSource
};
//# sourceMappingURL=FeatureServiceSnappingSource-FWYUZKPM.js.map
