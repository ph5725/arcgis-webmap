import {
  i as i3,
  n,
  r as r2
} from "./chunk-ALW6457W.js";
import {
  u as u3
} from "./chunk-CVH52ZBN.js";
import {
  f as f6
} from "./chunk-524UHFSB.js";
import "./chunk-H5N2AXWG.js";
import {
  L as L2
} from "./chunk-P4YXQBLK.js";
import "./chunk-WUKLWX63.js";
import "./chunk-LHJOMFWG.js";
import "./chunk-APGIAJ3M.js";
import {
  o as o4
} from "./chunk-ES5H7VGK.js";
import "./chunk-JV7SG7ZY.js";
import {
  E
} from "./chunk-TUSII7EA.js";
import "./chunk-NLQ5JBZ3.js";
import "./chunk-WQVEQTKW.js";
import {
  Mt,
  at,
  ht
} from "./chunk-DKS7UUDR.js";
import {
  O,
  S,
  c as c3,
  f as f5
} from "./chunk-KH55BE33.js";
import {
  a as a3
} from "./chunk-WEBPKGFM.js";
import "./chunk-6DARBDBU.js";
import "./chunk-KDQWOWXR.js";
import "./chunk-JOVQBCRD.js";
import "./chunk-LNFOAX5I.js";
import "./chunk-U3MD377S.js";
import "./chunk-2B6XECE5.js";
import "./chunk-ZAIOYQ5Z.js";
import "./chunk-QB5ST4HW.js";
import "./chunk-OIO6NR6X.js";
import "./chunk-F5BDMX7A.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-AAC6XSCN.js";
import "./chunk-Z7VYTTYM.js";
import {
  h as h2
} from "./chunk-YIXK32VF.js";
import "./chunk-BDWOUZQR.js";
import "./chunk-H34ENSPL.js";
import "./chunk-4ADC6HZF.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-LBC3MAJX.js";
import {
  j as j2
} from "./chunk-3ZORAHSR.js";
import {
  t
} from "./chunk-SZN55B2M.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-KQINCOQL.js";
import {
  c as c2
} from "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import "./chunk-C3JHRSMA.js";
import "./chunk-JEYXDNAT.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import {
  R as R2
} from "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-QVKLS4LH.js";
import "./chunk-2KVNXQA7.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  b as b2,
  d
} from "./chunk-HPGYEHVI.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import {
  f as f4
} from "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import {
  R,
  c,
  l as l2,
  o as o3,
  u as u2
} from "./chunk-6GWORUT3.js";
import "./chunk-XHYOFJ4U.js";
import {
  e as e2
} from "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import {
  o as o2
} from "./chunk-YIV2QKTZ.js";
import {
  U,
  f as f2,
  j,
  l
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import {
  f as f3
} from "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  b,
  e2 as e,
  f,
  i2,
  m,
  o4 as o,
  u3 as u
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  g2 as g
} from "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  L,
  a as a2,
  s
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  h
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var r3 = class {
  constructor(t3, e3) {
    this.data = t3, this.resolution = e3, this.state = { type: i4.CREATED }, this.alive = true;
  }
  process(t3) {
    switch (this.state.type) {
      case i4.CREATED:
        return this.state = this._gotoFetchCount(this.state, t3), this.state.task.promise.then(t3.resume, t3.resume);
      case i4.FETCH_COUNT:
        break;
      case i4.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t3), this.state.task.promise.then(t3.resume, t3.resume);
      case i4.FETCH_FEATURES:
        break;
      case i4.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t3);
      case i4.DONE:
    }
    return null;
  }
  get debugInfo() {
    return { data: this.data, featureCount: this._featureCount, state: this._stateToString };
  }
  get _featureCount() {
    switch (this.state.type) {
      case i4.CREATED:
      case i4.FETCH_COUNT:
        return 0;
      case i4.FETCHED_COUNT:
        return this.state.featureCount;
      case i4.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case i4.FETCHED_FEATURES:
        return this.state.features.length;
      case i4.DONE:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case i4.CREATED:
        return "created";
      case i4.FETCH_COUNT:
        return "fetch-count";
      case i4.FETCHED_COUNT:
        return "fetched-count";
      case i4.FETCH_FEATURES:
        return "fetch-features";
      case i4.FETCHED_FEATURES:
        return "fetched-features";
      case i4.DONE:
        return "done";
    }
  }
  _gotoFetchCount(s2, a4) {
    return { type: i4.FETCH_COUNT, previous: s2, task: d(async (t3) => {
      const s3 = await b2(a4.fetchCount(this, t3));
      this.state.type === i4.FETCH_COUNT && (this.state = u4(this.state, s3.ok ? s3.value : 1 / 0));
    }) };
  }
  _gotoFetchFeatures(s2, a4) {
    return { type: i4.FETCH_FEATURES, previous: s2, task: d(async (t3) => {
      const E3 = await b2(a4.fetchFeatures(this, s2.featureCount, t3));
      this.state.type === i4.FETCH_FEATURES && (this.state = T(this.state, E3.ok ? E3.value : []));
    }) };
  }
  _goToDone(t3, e3) {
    return e3.finish(this, t3.features), { type: i4.DONE, previous: t3 };
  }
  reset() {
    const t3 = this.state;
    switch (this.state = { type: i4.CREATED }, t3.type) {
      case i4.CREATED:
      case i4.FETCHED_COUNT:
      case i4.FETCHED_FEATURES:
      case i4.DONE:
        break;
      case i4.FETCH_COUNT:
      case i4.FETCH_FEATURES:
        t3.task.abort();
    }
  }
  intersects(t3) {
    return null == t3 || !this.data.extent || (o3(t3, n2), R(this.data.extent, n2));
  }
};
function u4(t3, e3) {
  return { type: i4.FETCHED_COUNT, featureCount: e3, previous: t3 };
}
function T(t3, e3) {
  return { type: i4.FETCHED_FEATURES, previous: t3, features: e3 };
}
var i4;
!function(t3) {
  t3[t3.CREATED = 0] = "CREATED", t3[t3.FETCH_COUNT = 1] = "FETCH_COUNT", t3[t3.FETCHED_COUNT = 2] = "FETCHED_COUNT", t3[t3.FETCH_FEATURES = 3] = "FETCH_FEATURES", t3[t3.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t3[t3.DONE = 5] = "DONE";
}(i4 || (i4 = {}));
var n2 = u2();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var j3 = class extends b {
  get _minimumVerticesPerFeature() {
    switch (this.store?.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  get _mandatoryOutFields() {
    const e3 = /* @__PURE__ */ new Set();
    return this.objectIdField && e3.add(this.objectIdField), this.globalIdField && e3.add(this.globalIdField), e3;
  }
  set outFields(e3) {
    const t3 = this._get("outFields"), i5 = u(e3, this._mandatoryOutFields);
    f(i5, t3) || (this._set("outFields", i5), o(i5, t3) || this.refresh());
  }
  get outFields() {
    return this._get("outFields") ?? this._mandatoryOutFields;
  }
  set filter(e3) {
    const t3 = this._get("filter"), i5 = this._filterProperties(e3);
    JSON.stringify(t3) !== JSON.stringify(i5) && this._set("filter", i5);
  }
  set customParameters(e3) {
    const t3 = this._get("customParameters");
    JSON.stringify(t3) !== JSON.stringify(e3) && this._set("customParameters", e3);
  }
  get _configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e3) {
    const t3 = this._get("tileInfo");
    t3 !== e3 && (null != e3 && null != t3 && JSON.stringify(e3) === JSON.stringify(t3) || (this._set("tileInfo", e3), this.store.tileInfo = e3));
  }
  set tileSize(e3) {
    this._get("tileSize") !== e3 && this._set("tileSize", e3);
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e3) {
    super(e3), this.suspended = true, this._historicMoment = null, this.tilesOfInterest = [], this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._updatingHandles = new h2();
  }
  initialize() {
    this._initializeFetchExtent(), this._updatingHandles.add(() => this._configuration, () => this.refresh()), this._updatingHandles.add(() => this.tilesOfInterest, () => {
      this._updatePriorities(), this._process();
    }, { sync: true, initial: true, equals: (e3, t3) => h(e3, t3, ({ id: e4 }, { id: t4 }) => e4 === t4) }), this.addHandles(f2(() => !this.suspended, () => this._process()));
  }
  _updatePriorities() {
    this.store.setPriorityOrderByKey(this.tilesOfInterest.map((e3) => e3.id ?? "") ?? []);
  }
  destroy() {
    this._pendingTiles.forEach((e3) => this._deletePendingTile(e3)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._updatingHandles.destroy();
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e3) => this._deletePendingTile(e3)), this._process();
  }
  async handleEdits(e3) {
    if (e3.historicMoment && (this._historicMoment = e3.historicMoment), !e3.addedFeatures.length && !e3.updatedFeatures.length && !e3.deletedFeatures.length) return;
    for (const s2 of this._pendingTiles.values()) s2.reset();
    const t3 = { ...e3, deletedFeatures: e3.deletedFeatures.map(({ objectId: e4, globalId: t4 }) => e4 && -1 !== e4 ? e4 : this._lookupObjectIdByGlobalId(t4)) }, i5 = d(async (e4) => {
      try {
        await this.store.processEdits(t3, (e5, t4) => this._queryFeaturesById(e5, t4), e4), this._processPendingTiles();
      } catch (i6) {
        a2(i6), i.getLogger(this).warn("Failed to apply edits", i6);
      }
    });
    this.addHandles(i5), await this._updatingHandles.addPromise(i5.promise);
  }
  setHistoricMoment(e3) {
    e3?.getTime() !== this._historicMoment?.getTime() && (this._historicMoment = e3, this.refresh());
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !g(this.url)) return;
    const e3 = d(async (e4) => {
      try {
        const t3 = await O(this.url, new R2({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: this.capabilities.query.supportsCacheHint ?? void 0 }), { query: this._configuration.customParameters, signal: e4 });
        this.store.extent = z.fromJSON(t3.data?.extent);
      } catch (t3) {
        a2(t3), i.getLogger(this).warn("Failed to fetch data extent", t3);
      }
    });
    this._updatingHandles.addPromise(e3.promise.then(() => this._process())), this.addHandles(e3);
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this._pendingTiles.values()).map((e3) => e3.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const e3 of this._pendingTiles.values()) e3.alive = false;
  }
  _createPendingTiles() {
    if (this.suspended) return;
    const e3 = this._collectMissingTilesInfo();
    if (this._setAvailability(null == e3 ? 1 : e3.coveredArea / e3.fullArea), null != e3) for (const { data: t3, resolution: i5 } of e3.missingTiles) {
      const e4 = this._pendingTiles.get(t3.id);
      e4 ? (e4.resolution = i5, e4.alive = true) : this._createPendingTile(t3, i5);
    }
  }
  _collectMissingTilesInfo() {
    let e3 = null;
    for (const t3 of this.tilesOfInterest) {
      const i5 = this.store.process(t3, (e4, t4) => this._verifyTileComplexity(e4, t4), this.outFields);
      null == e3 ? e3 = i5 : e3.prepend(i5);
    }
    return e3;
  }
  _deletePendingTiles() {
    for (const e3 of this._pendingTiles.values()) e3.alive || this._deletePendingTile(e3);
  }
  _processPendingTiles() {
    const e3 = { fetchCount: (e4, t3) => this._fetchCount(e4, t3), fetchFeatures: (e4, t3, i5) => this._fetchFeatures(e4, t3, i5), finish: (e4, t3) => this._finishPendingTile(e4, t3), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e3)) for (const t3 of this._pendingTiles.values()) this._verifyTileComplexity(this.store.getFeatureCount(t3.data), t3.resolution) && this._updatingHandles.addPromise(t3.process(e3));
  }
  _verifyTileComplexity(e3, t3) {
    return this._verifyVertexComplexity(e3) && this._verifyFeatureDensity(e3, t3);
  }
  _verifyVertexComplexity(e3) {
    return e3 * this._minimumVerticesPerFeature < w;
  }
  _verifyFeatureDensity(e3, t3) {
    if (null == this.tileInfo) return false;
    const i5 = this.tileSize * t3;
    return e3 * (q / (i5 * i5)) < M;
  }
  _ensureFetchAllCounts(e3) {
    let t3 = true;
    for (const i5 of this._pendingTiles.values()) i5.state.type < i4.FETCHED_COUNT && this._updatingHandles.addPromise(i5.process(e3)), i5.state.type <= i4.FETCH_COUNT && (t3 = false);
    return t3;
  }
  _finishPendingTile(e3, t3) {
    this.store.add(e3.data, t3), this._deletePendingTile(e3), this._updateAvailability();
  }
  _updateAvailability() {
    const e3 = this._collectMissingTilesInfo();
    this._setAvailability(null == e3 ? 1 : e3.coveredArea / e3.fullArea);
  }
  _setAvailability(e3) {
    this._set("availability", e3);
  }
  _createPendingTile(e3, t3) {
    const i5 = new r3(e3, t3);
    return this._pendingTiles.set(e3.id, i5), i5;
  }
  _deletePendingTile(e3) {
    e3.reset(), this._pendingTiles.delete(e3.data.id);
  }
  async _fetchCount(e3, t3) {
    return this.store.fetchCount(e3.data, this.url, this._createCountQuery(e3), { query: this.customParameters, timeout: x, signal: t3 });
  }
  async _fetchFeatures(e3, t3, i5) {
    let s2 = 0;
    const r4 = [];
    let o5 = 0, n3 = t3;
    for (; ; ) {
      const a4 = this._createFeaturesQuery(e3), l3 = this._setPagingParameters(a4, s2, n3), { features: u5, exceededTransferLimit: d2 } = await this._queryFeatures(a4, i5);
      l3 && (s2 += a4.num), o5 += u5.length;
      for (const e4 of u5) r4.push(e4);
      if (n3 = t3 - o5, !l3 || !d2 || n3 <= 0) return r4;
    }
  }
  _filterProperties(e3) {
    return null == e3 ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e3.where || "1=1", timeExtent: e3.timeExtent, gdbVersion: e3.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e3) {
    const t3 = this.globalIdField, i5 = this.objectIdField;
    if (null == t3) throw new Error("Expected globalIdField to be defined");
    let s2 = null;
    const r4 = e3 ? e2(e3) : e3;
    if (this.store.featureStore.forEach((e4) => {
      r4 === e2(e4.attributes[t3]) && (s2 = e4.objectId ?? e4.attributes[i5]);
    }), null == s2) throw new Error(`Expected to find a feature with globalId ${e3}`);
    return s2;
  }
  _queryFeaturesById(e3, t3) {
    const i5 = this._createFeaturesQuery();
    return i5.objectIds = e3, this._queryFeatures(i5, t3);
  }
  _queryFeatures(e3, t3) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e3, t3) : this._queryFeaturesJSON(e3, t3);
  }
  async _queryFeaturesPBF(e3, t3) {
    const { sourceSpatialReference: i5 } = this, { data: s2 } = await f5(this.url, e3, new a3({ sourceSpatialReference: i5 }), { query: this._configuration.customParameters, timeout: x, signal: t3 });
    return ht(s2);
  }
  async _queryFeaturesJSON(e3, t3) {
    const { sourceSpatialReference: i5 } = this, { data: s2 } = await c3(this.url, e3, i5, { query: this._configuration.customParameters, timeout: x, signal: t3 });
    return at(s2, { type: "object-id", fieldName: this.objectIdField });
  }
  _createCountQuery(e3) {
    const t3 = this._createBaseQuery(e3);
    return this.capabilities.query.supportsCacheHint && (t3.cacheHint = true), t3;
  }
  _createFeaturesQuery(e3 = null) {
    const t3 = this._createBaseQuery(e3), i5 = null != e3?.data ? this.store.getAttributesForTile(e3?.data?.id) : null, s2 = u(i2(this.outFields, i5 ?? /* @__PURE__ */ new Set()), this._mandatoryOutFields);
    return t3.outFields = Array.from(s2), t3.returnGeometry = true, null != e3 && (this.capabilities.query.supportsResultType ? t3.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t3.cacheHint = true)), t3;
  }
  _createBaseQuery(e3) {
    const t3 = new R2({ returnZ: this.hasZ, returnM: false, historicMoment: this._historicMoment, geometry: null != this.tileInfo && null != e3 ? c(e3.data.extent, this.tileInfo.spatialReference) : void 0 }), i5 = this._configuration.filter;
    return null != i5 && (t3.where = i5.where, t3.gdbVersion = i5.gdbVersion, t3.timeExtent = i5.timeExtent), t3.outSpatialReference = this.spatialReference, t3;
  }
  _setPagingParameters(e3, t3, i5) {
    if (!this.capabilities.query.supportsPagination) return false;
    const { supportsMaxRecordCountFactor: s2, supportsCacheHint: r4, tileMaxRecordCount: o5, maxRecordCount: n3, supportsResultType: a4 } = this.capabilities.query, l3 = s2 ? R2.MAX_MAX_RECORD_COUNT_FACTOR : 1, u5 = l3 * ((a4 || r4) && o5 ? o5 : n3 || C);
    return e3.start = t3, s2 ? (e3.maxRecordCountFactor = Math.min(l3, Math.ceil(i5 / u5)), e3.num = Math.min(i5, e3.maxRecordCountFactor * u5)) : e3.num = Math.min(i5, u5), true;
  }
};
r([m({ constructOnly: true })], j3.prototype, "url", void 0), r([m({ constructOnly: true })], j3.prototype, "objectIdField", void 0), r([m({ constructOnly: true })], j3.prototype, "globalIdField", void 0), r([m({ constructOnly: true })], j3.prototype, "capabilities", void 0), r([m({ constructOnly: true })], j3.prototype, "sourceSpatialReference", void 0), r([m({ constructOnly: true })], j3.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], j3.prototype, "store", void 0), r([m({ readOnly: true })], j3.prototype, "_minimumVerticesPerFeature", null), r([m()], j3.prototype, "_mandatoryOutFields", null), r([m()], j3.prototype, "outFields", null), r([m()], j3.prototype, "suspended", void 0), r([m()], j3.prototype, "_historicMoment", void 0), r([m()], j3.prototype, "filter", null), r([m()], j3.prototype, "customParameters", null), r([m({ readOnly: true })], j3.prototype, "_configuration", null), r([m()], j3.prototype, "tileInfo", null), r([m()], j3.prototype, "tileSize", null), r([m()], j3.prototype, "tilesOfInterest", void 0), r([m({ readOnly: true })], j3.prototype, "updating", null), r([m({ readOnly: true })], j3.prototype, "availability", void 0), r([m()], j3.prototype, "hasZ", null), j3 = r([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], j3);
var C = 2e3;
var x = 6e5;
var w = 1e6;
var q = 25;
var M = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t2 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._priorities = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._store.size;
  }
  setPriorityOrderByKey(t3) {
    this._priorities.clear();
    for (let r4 = t3.length - 1; r4 >= 0; r4--) this._priorities.set(t3[r4], t3.length - r4);
  }
  hasLowerPriority(t3) {
    const r4 = this._priorities.get(t3);
    if (null == r4) return true;
    for (const [e3] of this._store) {
      const t4 = this._priorities.get(e3);
      if (null == t4 || t4 < r4) return true;
    }
    return false;
  }
  someFromLowestToHighestPriority(t3) {
    const { _priorities: r4 } = this;
    for (const [e3, s2] of this._store) if (!r4.has(e3) && t3(s2, e3)) return true;
    for (const [e3] of r4) {
      const r5 = this._store.get(e3);
      if (r5 && t3(r5, e3)) return true;
    }
    return false;
  }
  set(t3, r4) {
    this._store.set(t3, r4);
  }
  delete(t3) {
    return this._store.delete(t3);
  }
  get(t3) {
    return this._store.get(t3);
  }
  has(t3) {
    return this._store.has(t3);
  }
  clear() {
    this._store.clear();
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var g2 = class extends b {
  setPriorityOrderByKey(e3) {
    this._tiles.setPriorityOrderByKey(e3);
  }
  get _memoryLimitExceeded() {
    return this.featureStore.usedMemory >= this.maximumByteSize;
  }
  constructor(e3) {
    super(e3), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * E.MEGABYTES, this._tileBounds = new o4(), this._tiles = new t2(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = u2();
  }
  add(e3, t3) {
    for (const i5 of t3) this._referenceFeature(i5.objectId);
    const s2 = this.featureStore.upsertMany(t3), r4 = s2.map((e4) => new Set(Object.keys(e4.attributes))).reduce((e4, t4) => e(e4, t4), new Set(Object.keys(s2[0]?.attributes ?? []))), o5 = this._memoryLimitExceeded;
    this._addTileStorage(e3, new Set(s2.map((e4) => e4.objectId)), r4), o5 && this._applyCacheMemoryLimits();
  }
  _applyCacheMemoryLimits() {
    if (!this._memoryLimitExceeded) return;
    const { _tiles: e3, featureStore: t3, maximumByteSize: s2 } = this;
    e3.someFromLowestToHighestPriority((e4) => !this._memoryLimitExceeded || t3.usedMemory - this._estimateRemoveTileMemoryReduction(e4) < s2 || (this._removeTileStorage(e4), false));
  }
  _estimateRemoveTileMemoryReduction(e3) {
    let t3 = 0;
    for (const s2 of e3.objectIds) {
      if (1 === this._refCounts.get(s2)) {
        const e4 = this.featureStore.getFeature(s2);
        e4 && (t3 += this.featureStore.estimateFeatureUsedMemory?.(e4) ?? 0);
      }
    }
    return t3;
  }
  getAttributesForTile(e3) {
    return e3 ? this._tiles.get(e3)?.attributeKeys : null;
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e3, t3, s2) {
    return this._processEditsDelete(e3.deletedFeatures.concat(e3.updatedFeatures)), this._processEditsRefetch(e3.addedFeatures.concat(e3.updatedFeatures), t3, s2);
  }
  _addTileStorage(e3, t3, s2) {
    const i5 = e3.id;
    this._tiles.set(i5, new v(e3, t3, s2)), this._tileBounds.set(i5, e3.extent), this._tileFeatureCounts.set(i5, t3.size);
  }
  _remove({ id: e3 }) {
    const t3 = this._tiles.get(e3);
    t3 && this._removeTileStorage(t3);
  }
  _removeTileStorage(e3) {
    const t3 = [];
    for (const i5 of e3.objectIds) this._unreferenceFeature(i5) === w2.REMOVED && t3.push(i5);
    this.featureStore.removeManyById(t3);
    const s2 = e3.data.id;
    this._tiles.delete(s2), this._tileBounds.delete(s2);
  }
  _processEditsDelete(e3) {
    this.featureStore.removeManyById(e3);
    for (const t3 of this._tiles.values()) {
      for (const s2 of e3) t3.objectIds.delete(s2);
      this._tileFeatureCounts.set(t3.data.id, t3.objectIds.size);
    }
    for (const t3 of e3) this._refCounts.delete(t3);
  }
  async _processEditsRefetch(e3, t3, s2) {
    if (!e3.length) return;
    const i5 = (await t3(e3, s2)).features, { hasZ: r4, hasM: o5 } = this.featureStore;
    for (const n3 of i5) {
      const e4 = Mt(this._tmpBoundingRect, n3.geometry, r4, o5);
      null != e4 && this._tileBounds.forEachInBounds(e4, (e5) => {
        const t4 = this._tiles.get(e5);
        this.featureStore.add(n3);
        const s3 = n3.objectId;
        t4.objectIds.has(s3) || (t4.objectIds.add(s3), this._referenceFeature(s3), this._tileFeatureCounts.set(t4.data.id, t4.objectIds.size));
      });
    }
  }
  process(e3, t3 = () => true, s2) {
    if (null == this.tileInfo || !e3.extent || null != this.extent && !R(o3(this.extent, this._tmpBoundingRect), e3.extent)) return new S2(e3);
    if (this._memoryLimitExceeded && !this._tiles.hasLowerPriority(e3.id ?? "")) return new S2(e3);
    const i5 = this.getAttributesForTile(e3.id);
    if (o(s2, i5)) return new S2(e3);
    const o5 = this._createTileTree(e3, this.tileInfo);
    return this._simplify(o5, t3, null, 0, 1), this._collectMissingTiles(e3, o5, this.tileInfo, s2);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({ data: e3 }) => ({ data: e3, featureCount: this._tileFeatureCounts.get(e3.id) || 0 }));
  }
  getFeatureCount(e3) {
    return this._tileFeatureCounts.get(e3.id) ?? 0;
  }
  async fetchCount(e3, t3, s2, i5) {
    const r4 = this._tileFeatureCounts.get(e3.id);
    if (null != r4) return r4;
    const o5 = await S(t3, s2, i5);
    return this._tileFeatureCounts.set(e3.id, o5.data.count), o5.data.count;
  }
  _createTileTree(e3, t3) {
    const s2 = new C2(e3.level, e3.row, e3.col);
    return t3.updateTileInfo(s2, j2.ExtrapolateOptions.POWER_OF_TWO), this._tileBounds.forEachInBounds(e3.extent, (i5) => {
      const r4 = this._tiles.get(i5)?.data;
      r4 && y(e3, r4) && this._populateChildren(s2, r4, t3, this._tileFeatureCounts.get(r4.id) || 0);
    }), s2;
  }
  _populateChildren(e3, t3, s2, i5) {
    const r4 = t3.level - e3.level - 1;
    if (r4 < 0) return void (e3.isLeaf = true);
    const o5 = t3.row >> r4, n3 = t3.col >> r4, l3 = e3.row << 1, u5 = n3 - (e3.col << 1) + (o5 - l3 << 1), c4 = e3.children[u5];
    if (null != c4) this._populateChildren(c4, t3, s2, i5);
    else {
      const r5 = new C2(e3.level + 1, o5, n3);
      s2.updateTileInfo(r5, j2.ExtrapolateOptions.POWER_OF_TWO), e3.children[u5] = r5, this._populateChildren(r5, t3, s2, i5);
    }
  }
  _simplify(e3, t3, s2, i5, r4) {
    const o5 = r4 * r4;
    if (e3.isLeaf) return t3(this.getFeatureCount(e3), r4) ? 0 : (this._remove(e3), null != s2 && (s2.children[i5] = null), o5);
    const n3 = r4 / 2, l3 = n3 * n3;
    let u5 = 0;
    for (let c4 = 0; c4 < e3.children.length; c4++) {
      const s3 = e3.children[c4];
      u5 += null != s3 ? this._simplify(s3, t3, e3, c4, n3) : l3;
    }
    return 0 === u5 ? this._mergeChildren(e3) : 1 - u5 / o5 < T2 && (this._purge(e3), null != s2 && (s2.children[i5] = null), u5 = o5), u5;
  }
  _mergeChildren(e3) {
    const t3 = /* @__PURE__ */ new Set();
    let s2;
    this._forEachLeaf(e3, (e4) => {
      const r4 = this._tiles.get(e4.id);
      if (r4) {
        s2 = s2 ? e(s2, r4.attributeKeys) : new Set(r4.attributeKeys);
        for (const e5 of r4.objectIds) t3.has(e5) || (t3.add(e5), this._referenceFeature(e5));
        this._remove(e4);
      }
    }), this._addTileStorage(e3, t3, s2 ?? /* @__PURE__ */ new Set()), e3.isLeaf = true, e3.children[0] = e3.children[1] = e3.children[2] = e3.children[3] = null, this._tileFeatureCounts.set(e3.id, t3.size);
  }
  _forEachLeaf(e3, t3) {
    for (const s2 of e3.children) null != s2 && (s2.isLeaf ? t3(s2) : this._forEachLeaf(s2, t3));
  }
  _purge(e3) {
    if (null != e3) if (e3.isLeaf) this._remove(e3);
    else for (let t3 = 0; t3 < e3.children.length; t3++) {
      const s2 = e3.children[t3];
      this._purge(s2), e3.children[t3] = null;
    }
  }
  _collectMissingTiles(e3, t3, s2, i5) {
    const r4 = new E2(s2, e3, this.extent);
    return this._collectMissingTilesRecurse(t3, r4, 1, i5), r4.info;
  }
  _collectMissingTilesRecurse(e3, t3, s2, i5) {
    const o5 = this.getAttributesForTile(e3.id), n3 = o5 && !o(i5, o5);
    if (n3 && t3.addMissing(e3.level, e3.row, e3.col, s2), e3.isLeaf) return;
    if (!e3.hasChildren) return void (n3 || t3.addMissing(e3.level, e3.row, e3.col, s2));
    const l3 = s2 / 2;
    for (let r4 = 0; r4 < e3.children.length; r4++) {
      const s3 = e3.children[r4];
      null == s3 ? t3.addMissing(e3.level + 1, (e3.row << 1) + ((2 & r4) >> 1), (e3.col << 1) + (1 & r4), l3) : this._collectMissingTilesRecurse(s3, t3, l3, i5);
    }
  }
  _referenceFeature(e3) {
    const t3 = (this._refCounts.get(e3) || 0) + 1;
    return this._refCounts.set(e3, t3), 1 === t3 ? w2.ADDED : w2.UNCHANGED;
  }
  _unreferenceFeature(e3) {
    const t3 = (this._refCounts.get(e3) || 0) - 1;
    return 0 === t3 ? (this._refCounts.delete(e3), w2.REMOVED) : (t3 > 0 && this._refCounts.set(e3, t3), w2.UNCHANGED);
  }
  get test() {
  }
};
function y(e3, t3) {
  if (!e3 || !t3) return false;
  if (e3.level === t3.level) return e3.row === t3.row && e3.col === t3.col;
  const s2 = e3.level < t3.level, i5 = s2 ? e3 : t3, r4 = s2 ? t3 : e3, o5 = 1 << r4.level - i5.level;
  return Math.floor(r4.row / o5) === i5.row && Math.floor(r4.col / o5) === i5.col;
}
r([m({ constructOnly: true })], g2.prototype, "featureStore", void 0), r([m()], g2.prototype, "tileInfo", void 0), r([m()], g2.prototype, "extent", void 0), r([m()], g2.prototype, "maximumByteSize", void 0), g2 = r([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], g2);
var v = class {
  constructor(e3, t3, s2) {
    this.data = e3, this.objectIds = t3, this.attributeKeys = s2;
  }
};
var C2 = class {
  constructor(e3, t3, s2) {
    this.level = e3, this.row = t3, this.col = s2, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (null != this.children[0] || null != this.children[1] || null != this.children[2] || null != this.children[3]);
  }
};
var S2 = class {
  constructor(e3, t3 = []) {
    this.missingTiles = t3, this.fullArea = 0, this.coveredArea = 0, this.fullArea = l2(e3.extent), this.coveredArea = this.fullArea;
  }
  prepend(e3) {
    this.missingTiles = e3.missingTiles.concat(this.missingTiles), this.coveredArea += e3.coveredArea, this.fullArea += e3.fullArea;
  }
};
var E2 = class {
  constructor(e3, t3, s2) {
    this._tileInfo = e3, this._extent = null, this.info = new S2(t3), null != s2 && (this._extent = o3(s2));
  }
  addMissing(e3, t3, s2, i5) {
    const r4 = new t(null, e3, t3, s2);
    this._tileInfo.updateTileInfo(r4, j2.ExtrapolateOptions.POWER_OF_TWO), null == r4.extent || null != this._extent && !R(this._extent, r4.extent) || (this.info.missingTiles.push({ data: r4, resolution: i5 }), this.info.coveredArea -= l2(r4.extent));
  }
};
var T2 = 0.18751;
var w2;
!function(e3) {
  e3[e3.ADDED = 0] = "ADDED", e3[e3.REMOVED = 1] = "REMOVED", e3[e3.UNCHANGED = 2] = "UNCHANGED";
}(w2 || (w2 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var w3 = class extends o2.EventedAccessor {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = L(), this._elevationAligner = i3(), this._elevationFilter = r2(), this._symbologyCandidatesFetcher = n(), this._updatingHandles = new h2(), this._alignPointsInFeatures = async (e3, t3) => {
      const i5 = { query: e3 }, s2 = await this.remoteClient.invoke("alignElevation", i5, { signal: t3 });
      return s(t3), s2;
    }, this._getSymbologyCandidates = async (e3, t3) => {
      const i5 = { candidates: e3, spatialReference: this._spatialReference.toJSON() }, s2 = await this.remoteClient.invoke("getSymbologyCandidates", i5, { signal: t3 });
      return s(t3), s2;
    };
  }
  get updating() {
    return this._isInitializing || this._updatingHandles.updating || this._featureFetcher.updating;
  }
  destroy() {
    this._featureFetcher?.destroy(), this._queryEngine?.destroy(), this._featureStore?.clear();
  }
  async setup(e3) {
    if (this.destroyed) return { result: {} };
    const { geometryType: t3, objectIdField: i5, timeInfo: r4, fieldsIndex: n3 } = e3.serviceInfo, { hasZ: o5 } = e3, l3 = f3.fromJSON(e3.spatialReference);
    this._spatialReference = l3, this._featureStore = new f6({ ...e3.serviceInfo, hasZ: o5, hasM: false }), this._featureStore.estimateFeatureUsedMemory = (e4) => e4.usedMemory, this._queryEngine = new L2({ spatialReference: e3.spatialReference, featureStore: this._featureStore, geometryType: t3, fieldsIndex: n3, hasZ: o5, hasM: false, featureIdInfo: { type: "object-id", fieldName: i5 }, timeInfo: r4 }), this._featureFetcher = new j3({ store: new g2({ featureStore: this._featureStore }), url: e3.serviceInfo.url, objectIdField: e3.serviceInfo.objectIdField, globalIdField: e3.serviceInfo.globalIdField, capabilities: e3.serviceInfo.capabilities, spatialReference: l3, sourceSpatialReference: f3.fromJSON(e3.serviceInfo.spatialReference), customParameters: e3.configuration.customParameters });
    const u5 = "3d" === e3.configuration.viewType;
    return this._elevationAligner = i3(u5, { elevationInfo: null != e3.elevationInfo ? c2.fromJSON(e3.elevationInfo) : null, alignPointsInFeatures: this._alignPointsInFeatures }), this._elevationFilter = r2(u5), this.addHandles([l(() => this._featureFetcher.availability, (e4) => this.emit("notify-availability", { availability: e4 }), U), l(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e3.configuration);
  }
  async configure(e3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e3), C3;
  }
  async setSuspended(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t3), this._featureFetcher.suspended = e3, C3;
  }
  async updateOutFields(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t3), this._featureFetcher.outFields = new Set(e3 ?? []), C3;
  }
  async fetchCandidates(e3, t3) {
    await this._whenSetup.promise, s(t3);
    const i5 = b3(e3, this._featureStore.hasZ), s2 = t3?.signal, a4 = await u3(this._queryEngine, i5, s2);
    s(s2);
    const n3 = await this._elevationAligner.alignCandidates(a4.candidates, f3.fromJSON(e3.point.spatialReference) ?? f3.WGS84, s2);
    s(s2);
    const o5 = await this._symbologyCandidatesFetcher.fetch(n3, s2);
    s(s2);
    const l3 = 0 === o5.length ? n3 : n3.concat(o5);
    return { result: { candidates: this._elevationFilter.filter(i5, l3) } };
  }
  async updateTiles(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t3), this._featureFetcher.tileSize = e3.tileSize, this._featureFetcher.tilesOfInterest = e3.tiles, this._featureFetcher.tileInfo = null != e3.tileInfo ? j2.fromJSON(e3.tileInfo) : null, C3;
  }
  async refresh(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t3), this._featureFetcher.refresh(), C3;
  }
  async whenNotUpdating(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t3), await j(() => !this.updating, t3), s(t3), C3;
  }
  async getDebugInfo(e3, t3) {
    return s(t3), { result: this._featureFetcher.debugInfo };
  }
  async handleEdits(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t3), await this._updatingHandles.addPromise(this._featureFetcher.handleEdits(e3)), s(t3), C3;
  }
  async setHistoricMoment(e3, t3) {
    return this._featureFetcher.setHistoricMoment(e3.moment), C3;
  }
  async notifyElevationSourceChange(e3, t3) {
    return this._elevationAligner.notifyElevationSourceChange(), C3;
  }
  async notifySymbologyChange(e3, t3) {
    return this._symbologyCandidatesFetcher.notifySymbologyChange(), C3;
  }
  async setSymbologySnappingSupported(e3) {
    return this._symbologyCandidatesFetcher = n(e3, this._getSymbologyCandidates), C3;
  }
  _updateFeatureFetcherConfiguration(e3) {
    this._featureFetcher.filter = null != e3.filter ? R2.fromJSON(e3.filter) : null, this._featureFetcher.customParameters = e3.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
r([m({ readOnly: true })], w3.prototype, "updating", null), r([m()], w3.prototype, "_isInitializing", void 0), w3 = r([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], w3);
var j4 = w3;
function b3(e3, t3) {
  const i5 = !!t3 || void 0;
  if (!e3.filter) return { ...e3, query: { where: "1=1", returnZ: i5 } };
  const { distance: r4, units: s2, spatialRel: a4, where: n3, timeExtent: o5, objectIds: l3 } = e3.filter, u5 = { geometry: e3.filter.geometry ? f4(e3.filter.geometry) : void 0, distance: r4, units: s2, spatialRel: a4, timeExtent: o5, objectIds: l3, returnZ: i5, where: n3 ?? "1=1" };
  return { ...e3, query: u5 };
}
var C3 = { result: {} };
export {
  j4 as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-ZXRNUSPZ.js.map
