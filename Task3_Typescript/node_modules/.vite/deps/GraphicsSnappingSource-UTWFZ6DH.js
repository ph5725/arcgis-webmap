import {
  i as i2,
  o
} from "./chunk-MGOMMN56.js";
import "./chunk-AT62KISP.js";
import "./chunk-24K5NVHX.js";
import "./chunk-KCZYWZT4.js";
import "./chunk-EOS5YLWS.js";
import {
  t
} from "./chunk-P5XPQUDN.js";
import "./chunk-WYLBCBQH.js";
import {
  E,
  y as y3
} from "./chunk-LYH5EAFA.js";
import "./chunk-ENM5QFON.js";
import "./chunk-2H2JCT45.js";
import {
  i,
  n,
  r as r2
} from "./chunk-ALW6457W.js";
import {
  u
} from "./chunk-CVH52ZBN.js";
import {
  a as a3
} from "./chunk-N6WKHIKW.js";
import {
  f
} from "./chunk-524UHFSB.js";
import "./chunk-H5N2AXWG.js";
import {
  L as L2
} from "./chunk-P4YXQBLK.js";
import "./chunk-WUKLWX63.js";
import "./chunk-LHJOMFWG.js";
import "./chunk-APGIAJ3M.js";
import "./chunk-ES5H7VGK.js";
import "./chunk-JV7SG7ZY.js";
import "./chunk-RVXIJHL6.js";
import {
  y as y2
} from "./chunk-2JAL6FAS.js";
import "./chunk-BGR5EVZD.js";
import "./chunk-NLQ5JBZ3.js";
import "./chunk-WQVEQTKW.js";
import {
  ut
} from "./chunk-DKS7UUDR.js";
import "./chunk-KDQWOWXR.js";
import {
  s as s2
} from "./chunk-JOVQBCRD.js";
import "./chunk-LNFOAX5I.js";
import "./chunk-U3MD377S.js";
import "./chunk-2B6XECE5.js";
import "./chunk-RTDWTAVK.js";
import "./chunk-QLJ6JQFC.js";
import "./chunk-QB5ST4HW.js";
import "./chunk-3LL6ALVC.js";
import "./chunk-NZPABYQQ.js";
import "./chunk-CCHJ3WNU.js";
import "./chunk-OIO6NR6X.js";
import "./chunk-F5BDMX7A.js";
import {
  A
} from "./chunk-OFHPFWHF.js";
import "./chunk-MZJEBIXX.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-AAC6XSCN.js";
import "./chunk-Z7VYTTYM.js";
import "./chunk-BUA5NESM.js";
import "./chunk-SHYE33QH.js";
import "./chunk-LTMF2W73.js";
import {
  h as h3
} from "./chunk-YIXK32VF.js";
import {
  g as g2
} from "./chunk-BDWOUZQR.js";
import "./chunk-H34ENSPL.js";
import "./chunk-4ADC6HZF.js";
import "./chunk-DRAQJS2F.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-TMFB3DKM.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-LBC3MAJX.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-UG6RJXJ2.js";
import "./chunk-C3JHRSMA.js";
import {
  Z
} from "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-6WL2SHX6.js";
import "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import {
  L,
  O,
  Q
} from "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-KHRHKYU2.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-QVKLS4LH.js";
import "./chunk-2KVNXQA7.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  d
} from "./chunk-HPGYEHVI.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import {
  y
} from "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import {
  P
} from "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  a as a2,
  h as h2,
  l
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  b,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  g,
  h,
  s
} from "./chunk-GZ2P4SCJ.js";
import "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  S
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var z = "graphics-collections";
var O2 = class extends b {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e = this.view;
    return null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type;
    if (!o2 || "map-notes" === t2.type) return i();
    const r3 = async (o3, r4) => (await h(e.whenLayerView(t2), r4)).elevationAlignPointsInFeatures(o3, r4);
    return i(o2, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: r3 });
  }
  get _snappingElevationFilter() {
    const { view: e } = this, t2 = null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
    return r2(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type, r3 = this._extrudedPolygonSymbolsCount > 0;
    return o2 && "map-notes" !== t2.type && r3 ? n(r3, async (o3, r4) => {
      const s3 = await e.whenLayerView(t2);
      return s(r4), s3.queryForSymbologySnapping({ candidates: o3, spatialReference: e.spatialReference }, r4);
    }) : n();
  }
  constructor(e) {
    super(e), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h3(), this._memoizedMakeGetGroundElevation = t(i2);
  }
  destroy() {
    for (const e of this._pendingAdds) e.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e) => this._destroySource(e)), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add(() => this.getGraphicsLayers(), (e2) => {
      this._updatingHandles.removeHandles(z);
      for (const t3 of e2) this._addMany(t3.graphics.toArray()), this.addHandles([t3.on("graphic-update", (e3) => this._onGraphicUpdate(e3)), this._updatingHandles.addOnCollectionChange(() => t3.graphics, (e3) => this._onGraphicsChanged(e3))], z);
    }, h2);
    const { view: e } = this, { layer: t2 } = this.layerSource;
    null != e && "3d" === e.type && "map-notes" !== t2.type && e.elevationProvider && this.addHandles([e.elevationProvider.on("elevation-change", ({ context: e2 }) => {
      y2(e2, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), l(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), h2), a2(() => t2, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  async fetchCandidates(e, t2) {
    const { point: o2, coordinateHelper: { spatialReference: r3 } } = e, s3 = await g(this._mapSources((o3) => this._fetchCandidatesForSource(o3, e, t2)));
    s(t2);
    const a4 = this._memoizedMakeGetGroundElevation(this.view, r3), p = s3.flat().map((e2) => o(e2, a4));
    return E(o2, p), p;
  }
  async _fetchCandidatesForSource(e, t2, o2) {
    const r3 = y3({ parameters: t2, mode: this.view?.type ?? "2d" }), s3 = await u(e.queryEngine, r3, o2);
    s(o2);
    const n2 = await this._snappingElevationAligner.alignCandidates(s3.candidates, t2.coordinateHelper.spatialReference, o2);
    s(o2);
    const a4 = await this._symbologySnappingFetcher.fetch(n2, o2);
    s(o2);
    const p = 0 === a4.length ? n2 : [...n2, ...a4];
    return this._snappingElevationFilter.filter(r3, p);
  }
  refresh() {
  }
  _onGraphicUpdate(e) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e.graphic))) switch (e.property) {
      case "geometry":
      case "visible":
        this._remove(e.graphic), this._addMany([e.graphic]);
    }
  }
  _onGraphicsChanged(e) {
    for (const t2 of e.removed) this._remove(t2);
    this._addMany(e.added);
  }
  _addMany(e) {
    const t2 = [], o2 = /* @__PURE__ */ new Map();
    for (const r3 of e) null != r3.geometry && (this._needsInitializeProjection(r3.geometry.spatialReference) ? (t2.push(r3.geometry.spatialReference), o2.set(r3.uid, r3)) : this._add(r3));
    this._createPendingAdd(t2, o2);
  }
  _createPendingAdd(e, t2) {
    if (!e.length) return;
    const s3 = d(async (o2) => {
      await Q(e.map((e2) => ({ source: e2, dest: this.spatialReference })), { signal: o2 }), this._markLoadedSpatialReferences(e);
      for (const e2 of t2.values()) this._add(e2);
    });
    this._updatingHandles.addPromise(s3.promise);
    const i3 = { task: s3, graphics: t2 }, n2 = () => S(this._pendingAdds, i3);
    s3.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e) {
    for (const t2 of e) {
      null != t2.wkid && this._loadedWkids.add(t2.wkid);
      const e2 = t2.wkt2 || t2.wkt;
      e2 && this._loadedWkts.add(e2);
    }
  }
  _add(e) {
    if (null == e.geometry || !e.visible) return;
    let t2 = e.geometry;
    if ("mesh" === t2.type) return;
    "extent" === t2.type && (t2 = P.fromExtent(t2));
    const o2 = this._ensureSource(t2.type);
    if (null == o2) return;
    const r3 = this._createOptimizedFeature(e.uid, t2);
    null != r3 && (o2.featureStore.add(r3), A(e.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e) {
    if (null != e.wkid && this._loadedWkids.has(e.wkid)) return false;
    const t2 = e.wkt2 || e.wkt;
    return (!t2 || !this._loadedWkts.has(t2)) && !L(e, this.spatialReference);
  }
  _createOptimizedFeature(e, t2) {
    const o2 = O(a3(t2), this.spatialReference);
    if (!o2) return null;
    const r3 = this._ensureGeometryHasZ(o2), s3 = ut(r3, this._hasZ, false);
    return new s2(s3, { [Z2]: e }, null, e);
  }
  _ensureGeometryHasZ(e) {
    if (!this._hasZ) return e;
    const t2 = (e2) => {
      for (; e2.length < 3; ) e2.push(0);
    }, o2 = e.clone();
    switch (o2.hasZ = true, o2.type) {
      case "point":
        o2.z = o2.z ?? 0;
        break;
      case "multipoint":
        o2.points.forEach(t2);
        break;
      case "polyline":
        o2.paths.forEach((e2) => e2.forEach(t2));
        break;
      case "polygon":
        o2.rings.forEach((e2) => e2.forEach(t2));
    }
    return o2;
  }
  _ensureSource(e) {
    const t2 = this._sources[e];
    if (null != t2) return t2;
    const o2 = this._createSource(e);
    return this._sources[e] = o2, o2;
  }
  _createSource(e) {
    const t2 = y.toJSON(e), o2 = this._hasZ, r3 = new f({ geometryType: t2, hasZ: o2, hasM: false });
    return { featureStore: r3, queryEngine: new L2({ featureStore: r3, fieldsIndex: Z.fromLayerJSON({ fields: [{ name: Z2, type: "esriFieldTypeOID", alias: Z2 }] }), geometryType: t2, hasM: false, hasZ: o2, featureIdInfo: { type: "object-id", fieldName: Z2 }, spatialReference: this.spatialReference, priority: g2.SNAPPING, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e };
  }
  _remove(e) {
    this._mapSources((t2) => this._removeFromSource(t2, e));
    for (const t2 of this._pendingAdds) t2.graphics.delete(e.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e, t2) {
    const o2 = t2.uid;
    e.featureStore.has(o2) && (e.featureStore.removeById(t2.uid), A(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e) {
    e.queryEngine.destroy(), this._sources[e.type] = null;
  }
  _mapSources(e) {
    const { point: t2, polygon: o2, polyline: r3, multipoint: s3 } = this._sources, i3 = [];
    return null != t2 && i3.push(e(t2)), null != o2 && i3.push(e(o2)), null != r3 && i3.push(e(r3)), null != s3 && i3.push(e(s3)), i3;
  }
};
r([m()], O2.prototype, "getGraphicsLayers", void 0), r([m({ constructOnly: true })], O2.prototype, "layerSource", void 0), r([m({ constructOnly: true })], O2.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], O2.prototype, "view", void 0), r([m({ readOnly: true })], O2.prototype, "updating", null), r([m({ readOnly: true })], O2.prototype, "availability", void 0), r([m()], O2.prototype, "_hasZ", null), r([m()], O2.prototype, "_snappingElevationAligner", null), r([m()], O2.prototype, "_snappingElevationFilter", null), r([m()], O2.prototype, "_symbologySnappingFetcher", null), r([m()], O2.prototype, "_extrudedPolygonSymbolsCount", void 0), O2 = r([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], O2);
var Z2 = "OBJECTID";
export {
  O2 as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-UTWFZ6DH.js.map
