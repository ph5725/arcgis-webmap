import {
  c as c7,
  f as f8,
  o as o4,
  p as p7
} from "./chunk-UVPBJRCN.js";
import {
  B as B2,
  D,
  E,
  N,
  c as c6,
  h as h3,
  i2 as i5,
  j as j3,
  l as l8,
  p as p5,
  p2 as p6,
  q as q2,
  te,
  u as u4,
  y as y2
} from "./chunk-TZWHWOLK.js";
import {
  $,
  V,
  a as a7,
  b as b2,
  c as c5,
  d as d3,
  f as f6,
  f2 as f7,
  h as h2,
  m as m4,
  m2 as m6,
  n as n3,
  o as o3,
  p as p3,
  p2 as p4,
  t as t4,
  v as v2,
  v2 as v3
} from "./chunk-623AYJP2.js";
import {
  A as A2,
  B,
  P as P2,
  P2 as P3,
  _ as _2,
  a as a6,
  c as c3,
  i as i4,
  j as j2,
  l as l6,
  m2 as m5,
  n,
  n2
} from "./chunk-U5MPARPW.js";
import {
  c as c4,
  l3 as l7
} from "./chunk-NXHGFG67.js";
import "./chunk-3NJEC7QC.js";
import "./chunk-WQVEQTKW.js";
import {
  i as i3,
  s as s5
} from "./chunk-F2RPYCFO.js";
import {
  s as s6
} from "./chunk-YB2E6SEN.js";
import "./chunk-KH55BE33.js";
import "./chunk-WEBPKGFM.js";
import "./chunk-6DARBDBU.js";
import "./chunk-KDQWOWXR.js";
import "./chunk-JOVQBCRD.js";
import "./chunk-ZAIOYQ5Z.js";
import {
  t as t2
} from "./chunk-TRH7YR3L.js";
import "./chunk-56LGCTGZ.js";
import {
  u as u3
} from "./chunk-PVI3IOCA.js";
import "./chunk-OFHPFWHF.js";
import "./chunk-MZJEBIXX.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-76QJRCNC.js";
import {
  R as R2
} from "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import {
  t as t3
} from "./chunk-DD7VYTDF.js";
import {
  l as l5
} from "./chunk-H7SHPX7W.js";
import {
  c as c2
} from "./chunk-6MFKAT6L.js";
import "./chunk-NOWX6W7R.js";
import {
  p as p2
} from "./chunk-OQ76WPLD.js";
import {
  e
} from "./chunk-KSVHYEPS.js";
import "./chunk-KQINCOQL.js";
import {
  g
} from "./chunk-B6C7UPBZ.js";
import {
  f as f3
} from "./chunk-IUQBXXYO.js";
import {
  A
} from "./chunk-MULCOUFY.js";
import {
  j
} from "./chunk-VGIEH4HM.js";
import {
  p
} from "./chunk-XLF2NMGX.js";
import {
  t
} from "./chunk-X5GD6LFD.js";
import {
  b2 as b,
  d,
  l as l4,
  w,
  y
} from "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import "./chunk-UGXCZZ7N.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-VLPG2W66.js";
import {
  f as f5
} from "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import {
  Z
} from "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import {
  R
} from "./chunk-7ZMGKXLG.js";
import {
  s as s4
} from "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import {
  m as m3
} from "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import {
  f as f4,
  s as s3,
  u as u2
} from "./chunk-SYPTUUSZ.js";
import {
  h
} from "./chunk-L7EN54WK.js";
import {
  u
} from "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import {
  d as d2
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import {
  q
} from "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import {
  r as r3
} from "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import {
  f as f2,
  v
} from "./chunk-N3A2BVTW.js";
import {
  l as l3
} from "./chunk-IGYEHOTB.js";
import {
  a as a5
} from "./chunk-TVM3SZJR.js";
import {
  P
} from "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  l as l2
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import {
  o
} from "./chunk-JUAPMINU.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import {
  r as r2
} from "./chunk-YFPGM5UE.js";
import {
  _e,
  be,
  c,
  he
} from "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  m as m2,
  s2
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a3
} from "./chunk-JUAD7TJ6.js";
import {
  a as a2,
  i as i2,
  m,
  x
} from "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  o as o2
} from "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H
} from "./chunk-ZWFY3WY5.js";
import {
  I
} from "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  a as a4,
  k
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import {
  a
} from "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionSchema.js
var e2 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c8 = /* @__PURE__ */ new Set(["u1", "u2", "u4", "u8", "s8", "u16", "s16"]);
var m7 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var f9 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function p8(e3) {
  return f9.has(e3.type);
}
function g2(n10, t8) {
  if (!n10 || !t8) return a(n10 || t8);
  const r4 = a(n10);
  if (r4.functionDefinition && t8.rasterFunctionDefinition) {
    const e3 = t8.rasterFunctionDefinition;
    (e3.thumbnail || e3.thumbnailEx) && (e3.thumbnail = e3.thumbnailEx = void 0), d4(r4.functionDefinition.arguments, t8), r4.rasterFunctionDefinition = r4.functionDefinition.toJSON();
  } else if ("none" !== t8.functionName?.toLowerCase()) {
    b3(r4.functionArguments).Raster = t8;
  }
  return r4;
}
function d4(e3, n10) {
  for (const t8 in e3) "raster" === t8.toLowerCase() && ("RasterFunctionVariable" === e3[t8].type ? (e3[t8] = n10.rasterFunctionDefinition, e3[t8].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e3[t8].type && d4(e3[t8].arguments, n10));
}
function h4(n10) {
  const t8 = a(e2[n10.functionName + "Function"]), o5 = n10.functionArguments;
  for (const e3 in o5) "raster" === e3.toLowerCase() ? (t8.arguments[e3] = h4(o5[e3]), t8.arguments[e3].type = "RasterFunctionTemplate") : "colormap" === e3.toLowerCase() ? (t8.arguments[e3].value = V2(o5[e3]), t8.arguments.ColorSchemeType.value = 0) : t8.arguments[e3].value = o5[e3];
  return t8;
}
function y3(e3, n10) {
  switch (n10 = n10 || {}, e3.type) {
    case "raster-stretch":
      return S2(e3, n10);
    case "class-breaks":
      return w2(e3, n10);
    case "unique-value":
      return F(e3, n10);
    case "raster-colormap":
      return N2(e3, n10);
    case "vector-field":
      return T(e3, n10);
    case "raster-shaded-relief":
      return v4(e3, n10);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b3(e3) {
  const n10 = e3?.Raster ?? e3?.raster;
  return n10 && "esri.layers.support.RasterFunction" === n10.declaredClass ? b3(n10.functionArguments) : e3;
}
var R3 = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function T(e3, t8) {
  const r4 = new N();
  r4.functionName = "VectorFieldRenderer";
  const { dataType: o5, bandNames: a13 } = t8, i8 = "vector-uv" === o5;
  let s9, u10;
  if (a13 && 2 === a13.length) {
    const e4 = a13.map((e5) => e5.toLowerCase());
    s9 = e4.indexOf("magnitude"), u10 = e4.indexOf("direction");
  }
  -1 !== s9 && null !== s9 || (s9 = 0, u10 = 1);
  const c18 = "arithmetic" === e3.rotationType ? 1 : 2, f11 = "flow-from" === e3.flowRepresentation ? 0 : 1, p19 = e3.visualVariables ? e3.visualVariables.find((e4) => "Magnitude" === e4.field) : new f5(), g3 = { magnitudeBandID: s9, directionBandID: u10, isUVComponents: i8, referenceSystem: c18, massFlowAngleRepresentation: f11, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: m7[e3.style.toLowerCase().replace("-", "_")], minimumMagnitude: p19.minDataValue, maximumMagnitude: p19.maxDataValue, minimumSymbolSize: p19.minSize, maximumSymbolSize: p19.maxSize };
  r4.functionArguments = g3;
  const d7 = h4(r4);
  return t8.convertToRFT ? N.fromJSON({ rasterFunctionDefinition: d7 }) : r4;
}
function v4(e3, t8) {
  const r4 = t8.convertToRFT;
  if ("elevation" !== t8.dataType && ("generic" !== t8.dataType || 1 !== t8.bandCount || "s16" !== t8.pixelType && "s32" !== t8.pixelType && "f32" !== t8.pixelType && "f64" !== t8.pixelType)) return new N();
  const i8 = new N();
  i8.functionName = "Hillshade";
  const s9 = "traditional" === e3.hillshadeType ? 0 : 1, u10 = "none" === e3.scalingType ? 1 : 3, l13 = { HillshadeType: s9, SlopeType: u10, ZFactor: e3.zFactor };
  return 0 === s9 && (l13.Azimuth = e3.azimuth, l13.Altitude = e3.altitude), 3 === u10 && (l13.PSPower = e3.pixelSizePower, l13.PSZFactor = e3.pixelSizeFactor), i8.functionArguments = l13, i8.variableName = "Raster", e3.colorRamp && (i8.functionName = "ShadedRelief", r4 ? l13.ColorRamp = A2(e3.colorRamp) : l13.Colormap = B(e3.colorRamp)), r4 ? new N({ rasterFunctionDefinition: h4(i8) }) : i8;
}
function S2(e3, t8) {
  const r4 = t8.convertToRFT, s9 = new N();
  s9.functionName = "Stretch";
  const l13 = R3[n2.toJSON(e3.stretchType)], c18 = "u8", m11 = e3.customStatistics?.map((e4) => [e4.min, e4.max, e4.avg ?? 0, e4.stddev ?? 1]), f11 = { StretchType: l13, Statistics: m11, DRA: e3.dynamicRangeAdjustment, UseGamma: e3.useGamma, Gamma: e3.gamma, ComputeGamma: e3.computeGamma };
  if (null != e3.outputMin && (f11.Min = e3.outputMin), null != e3.outputMax && (f11.Max = e3.outputMax), l13 === R3.standardDeviation ? (f11.NumberOfStandardDeviations = e3.numberOfStandardDeviations, s9.outputPixelType = c18) : l13 === R3.percentClip ? (f11.MinPercent = e3.minPercent, f11.MaxPercent = e3.maxPercent, s9.outputPixelType = c18) : l13 === R3.minMax ? s9.outputPixelType = c18 : l13 === R3.sigmoid && (f11.SigmoidStrengthLevel = e3.sigmoidStrengthLevel), s9.functionArguments = f11, s9.variableName = "Raster", e3.colorRamp) {
    const u10 = e3.colorRamp, l14 = new N();
    if (r4) l14.functionArguments = { ColorRamp: A2(u10) };
    else {
      const n10 = c3(u10, true);
      if (n10) l14.functionArguments = { colorRampName: n10 };
      else if (!t8.convertColorRampToColormap || "algorithmic" !== u10.type && "multipart" !== u10.type) {
        const n11 = e3.colorRamp.toJSON();
        "algorithmic" === n11.type ? n11.algorithm = n11.algorithm || "esriCIELabAlgorithm" : "multipart" === n11.type && n11.colorRamps?.length && n11.colorRamps.forEach((e4) => e4.algorithm = e4.algorithm || "esriCIELabAlgorithm"), l14.functionArguments = { colorRamp: n11 };
      } else l14.functionArguments = { Colormap: B(u10) };
    }
    return l14.variableName = "Raster", l14.functionName = "Colormap", l14.functionArguments.Raster = s9, r4 ? new N({ rasterFunctionDefinition: h4(l14) }) : l14;
  }
  return r4 ? new N({ rasterFunctionDefinition: h4(s9) }) : s9;
}
function w2(e3, t8) {
  const r4 = [], o5 = [], a13 = [], i8 = [], s9 = 1e-4, { pixelType: u10, rasterAttributeTable: l13 } = t8, c18 = null == l13 ? null : l13.features, m11 = C(l13);
  if (m11 && c18 && Array.isArray(c18) && e3.classBreakInfos) {
    e3.classBreakInfos.forEach((n10, t9) => {
      const r6 = n10.symbol?.color;
      let o7;
      r6?.a && null != n10.minValue && null != n10.maxValue && c18.forEach((a14) => {
        null != n10.minValue && null != n10.maxValue && (o7 = a14.attributes[e3.field], (o7 >= n10.minValue && o7 < n10.maxValue || t9 === e3.classBreakInfos.length - 1 && o7 >= n10.minValue) && i8.push([a14.attributes[m11], r6.r, r6.g, r6.b]));
      });
    });
    const r5 = u10 ? x2(i8, u10) : i8, o6 = new N();
    return o6.functionName = "Colormap", o6.functionArguments = {}, o6.functionArguments.Colormap = r5, o6.variableName = "Raster", t8.convertToRFT ? new N({ rasterFunctionDefinition: h4(o6) }) : o6;
  }
  e3.classBreakInfos.forEach((e4, n10) => {
    if (null == e4.minValue || null == e4.maxValue) return;
    const t9 = e4.symbol && e4.symbol.color;
    t9?.a ? (0 === n10 ? r4.push(e4.minValue, e4.maxValue + s9) : r4.push(e4.minValue + s9, e4.maxValue + s9), o5.push(n10), i8.push([n10, t9.r, t9.g, t9.b])) : a13.push(e4.minValue, e4.maxValue);
  });
  const f11 = u10 ? x2(i8, u10) : i8, p19 = new N();
  p19.functionName = "Remap", p19.functionArguments = { InputRanges: r4, OutputValues: o5, NoDataRanges: a13 }, p19.variableName = "Raster";
  const g3 = new N();
  return g3.functionName = "Colormap", g3.functionArguments = { Colormap: f11, Raster: p19 }, t8.convertToRFT ? new N({ rasterFunctionDefinition: h4(g3) }) : g3;
}
function x2(e3, n10) {
  const r4 = c8.has(n10) ? u3(n10) : null;
  return r4 && e3.push([Math.floor(r4[0] - 1), 0, 0, 0], [Math.ceil(r4[1] + 1), 0, 0, 0]), e3;
}
function C(e3) {
  if (null == e3) return;
  const { fields: n10 } = e3, t8 = n10?.find((e4) => e4?.name && "value" === e4.name.toLowerCase());
  return t8?.name;
}
function F(e3, t8) {
  const r4 = [], { pixelType: o5, rasterAttributeTable: a13 } = t8, i8 = null == a13 ? null : a13.features, s9 = C(a13), u10 = e3.defaultSymbol?.color?.toRgb(), l13 = e3.uniqueValueInfos;
  if (l13) if (i8) {
    if (s9) {
      const n10 = /* @__PURE__ */ new Map();
      l13.forEach((e4) => {
        const t10 = e4.value, r5 = A3(e4);
        null != t10 && r5?.a && n10.set(String(t10), r5.toRgb());
      });
      const t9 = e3.field;
      t9 && i8.forEach(({ attributes: e4 }) => {
        const o6 = String(e4[t9]), a14 = e4[s9], i9 = n10.get(o6);
        i9 ? r4.push([a14, ...i9]) : u10 && r4.push([a14, ...u10]);
      });
    }
  } else for (let n10 = 0; n10 < l13.length; n10++) {
    const e4 = l13[n10], t9 = A3(e4), o6 = +e4.value;
    if (t9?.a) {
      if (isNaN(o6)) return null;
      r4.push([o6, t9.r, t9.g, t9.b]);
    }
  }
  const c18 = o5 ? x2(r4, o5) : r4, m11 = new N();
  return m11.functionName = "Colormap", m11.functionArguments = {}, m11.functionArguments.Colormap = c18, m11.variableName = "Raster", t8.convertToRFT ? new N({ rasterFunctionDefinition: h4(m11) }) : m11;
}
function A3(e3) {
  return "polygon-3d" === e3.symbol?.type ? e3.symbol.symbolLayers?.find((e4) => "fill" === e4.type)?.material?.color : e3.symbol?.color;
}
function N2(e3, t8) {
  const r4 = e3.extractColormap();
  if (!r4 || 0 === r4.length) return null;
  const { pixelType: o5 } = t8, a13 = o5 ? x2(r4, o5) : r4, i8 = new N();
  return i8.functionName = "Colormap", i8.functionArguments = {}, i8.functionArguments.Colormap = a13, t8.convertToRFT ? new N({ rasterFunctionDefinition: h4(i8) }) : i8;
}
function V2(e3) {
  const n10 = [], t8 = [];
  return e3.forEach((e4) => {
    n10.push(e4[0]), t8.push(P2([...e4.slice(1), 255]));
  }), { type: "RasterColormap", values: n10, colors: t8 };
}

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var d5 = class extends l {
  constructor() {
    super(...arguments), this.layer = null, this.requestRawData = false, this.compression = void 0, this.lercVersion = 2;
  }
  get adjustAspectRatio() {
    return this.layer.adjustAspectRatio;
  }
  writeAdjustAspectRatio(e3, t8, r4) {
    this.layer.version < 10.3 || (t8[r4] = e3);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  get compressionQuality() {
    return this.layer.compressionQuality;
  }
  writeCompressionQuality(e3, t8, r4) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e3 && (t8[r4] = e3);
  }
  get compressionTolerance() {
    return this.layer.compressionTolerance;
  }
  writeCompressionTolerance(e3, t8, r4) {
    "lerc" === this.format && null != e3 && (t8[r4] = e3);
  }
  get format() {
    return this.requestRawData || "vector-field" === this.layer.renderer?.type ? "lerc" : this.layer.format;
  }
  get interpolation() {
    return this.layer.interpolation;
  }
  get noData() {
    return this.layer.noData;
  }
  get noDataInterpretation() {
    return this.layer.noDataInterpretation;
  }
  get pixelType() {
    const { layer: e3 } = this;
    return e3.pixelType !== e3.serviceRasterInfo.pixelType ? e3.pixelType : void 0;
  }
  writeLercVersion(e3, t8, r4) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t8[r4] = e3);
  }
  get version() {
    const e3 = this.layer;
    return e3.commitProperty("bandIds"), e3.commitProperty("format"), e3.commitProperty("compressionQuality"), e3.commitProperty("compressionTolerance"), e3.commitProperty("interpolation"), e3.commitProperty("noData"), e3.commitProperty("noDataInterpretation"), e3.commitProperty("mosaicRule"), e3.commitProperty("rasterFunction"), e3.commitProperty("adjustAspectRatio"), e3.commitProperty("pixelFilter"), e3.commitProperty("pixelType"), e3.commitProperty("definitionExpression"), e3.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e3) {
    this._set("version", e3);
  }
  get mosaicRule() {
    const e3 = this.layer;
    let t8 = e3.mosaicRule;
    const r4 = e3.definitionExpression;
    return t8 ? r4 && r4 !== t8.where && (t8 = t8.clone(), t8.where = r4) : r4 && (t8 = new y2({ where: r4 })), t8;
  }
  get rasterFunction() {
    const e3 = this.layer;
    let { rasterFunction: t8 } = e3;
    const r4 = e3.pixelFilter, o5 = !e3.format || e3.format.includes("jpg") || e3.format.includes("png");
    this.requestRawData || (t8 = this._addResampleRasterFunction(t8));
    const i8 = e3.multidimensionalSubset?.areaOfInterest;
    return i8 && (t8 = f10(t8, i8)), this.requestRawData || !o5 || r4 || "vector-field" === e3.renderer?.type || (t8 = this.combineRendererWithRenderingRule(t8)), t8;
  }
  combineRendererWithRenderingRule(e3) {
    const t8 = this.layer, { rasterInfo: r4, renderer: o5 } = t8;
    if (e3 = e3 || t8.rasterFunction, !o5 || !p8(o5)) return e3;
    return g2(y3(o5, { rasterAttributeTable: r4.attributeTable, pixelType: r4.pixelType, dataType: r4.dataType, bandNames: r4.bandInfos.map(({ name: e4 }) => e4), convertColorRampToColormap: t8.version < 10.6, convertToRFT: !!e3?.rasterFunctionDefinition, bandCount: r4.bandCount }), e3);
  }
  _addResampleRasterFunction(e3) {
    if (!("vector-field" === this.layer.renderer?.type) || "Resample" === e3?.functionName) return e3;
    const t8 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r4 = this.layer.serviceRasterInfo.pixelSize;
    let o5 = new N({ functionName: "Resample", functionArguments: { ResamplingType: t8, InputCellSize: r4 } });
    return o5 = e3?.rasterFunctionDefinition ? new N({ rasterFunctionDefinition: h4(o5) }) : o5, g2(o5, e3);
  }
};
function f10(e3, t8) {
  const r4 = new N({ functionName: "Clip", functionArguments: { ClippingGeometry: t8.toJSON(), ClippingType: 1 } });
  return g2(r4, e3);
}
r([m2()], d5.prototype, "layer", void 0), r([m2()], d5.prototype, "requestRawData", void 0), r([m2({ json: { write: true } })], d5.prototype, "adjustAspectRatio", null), r([r2("adjustAspectRatio")], d5.prototype, "writeAdjustAspectRatio", null), r([m2({ json: { write: true } })], d5.prototype, "bandIds", null), r([m2({ json: { write: true } })], d5.prototype, "compression", void 0), r([m2({ json: { write: true } })], d5.prototype, "compressionQuality", null), r([r2("compressionQuality")], d5.prototype, "writeCompressionQuality", null), r([m2({ json: { write: true } })], d5.prototype, "compressionTolerance", null), r([r2("compressionTolerance")], d5.prototype, "writeCompressionTolerance", null), r([m2({ json: { write: true } })], d5.prototype, "format", null), r([m2({ type: String, json: { read: { reader: a6.read }, write: { writer: a6.write } } })], d5.prototype, "interpolation", null), r([m2({ json: { write: true } })], d5.prototype, "noData", null), r([m2({ type: String, json: { read: { reader: i4.read }, write: { writer: i4.write } } })], d5.prototype, "noDataInterpretation", null), r([m2({ type: n.apiValues, json: { read: n.read, write: n.write } })], d5.prototype, "pixelType", null), r([m2({ json: { write: true } })], d5.prototype, "lercVersion", void 0), r([r2("lercVersion")], d5.prototype, "writeLercVersion", null), r([m2({ type: Number })], d5.prototype, "version", null), r([m2({ json: { write: true } })], d5.prototype, "mosaicRule", null), r([m2({ json: { write: true, name: "renderingRule" } })], d5.prototype, "rasterFunction", null), d5 = r([a3("esri.layers.support.ExportImageServiceParameters")], d5);

// node_modules/@arcgis/core/rest/support/FindImagesParameters.js
var i6 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.fromGeometry = null, this.toGeometry = null, this.objectIds = null, this.where = null, this.maxCount = null;
  }
};
r([m2({ type: _, json: { read: true } })], i6.prototype, "fromGeometry", void 0), r([m2({ type: _, json: { read: true, write: true } })], i6.prototype, "toGeometry", void 0), r([m2({ json: { write: true } })], i6.prototype, "objectIds", void 0), r([m2({ type: String, json: { write: true } })], i6.prototype, "where", void 0), r([m2({ type: Number, json: { write: true } })], i6.prototype, "maxCount", void 0), i6 = r([a3("esri.rest.support.FindImagesParameters")], i6);

// node_modules/@arcgis/core/rest/support/CameraInfoMixin.js
var s7 = (s9) => {
  let e3 = class extends s9 {
    constructor() {
      super(...arguments), this.make = null, this.model = null, this.focalLength = null, this.pixelSize = null, this.rows = null, this.cols = null;
    }
  };
  return r([m2({ json: { write: true } })], e3.prototype, "make", void 0), r([m2({ json: { write: true } })], e3.prototype, "model", void 0), r([m2({ json: { write: true } })], e3.prototype, "focalLength", void 0), r([m2({ json: { write: true } })], e3.prototype, "pixelSize", void 0), r([m2({ json: { write: true } })], e3.prototype, "rows", void 0), r([m2({ json: { write: true } })], e3.prototype, "cols", void 0), e3 = r([a3("esri.rest.support.CameraInfoMixin")], e3), e3;
};

// node_modules/@arcgis/core/rest/support/ImageInspectionInfo.js
var n4 = class extends s7(l) {
  constructor() {
    super(...arguments), this.id = null, this.referenceUri = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.perspectiveCenter = null, this.orientation = null;
  }
  writeAcquisitionDate(t8, o5) {
    o5.acquisitionDate = t8?.getTime();
  }
};
r([m2({ json: { write: true } })], n4.prototype, "id", void 0), r([m2({ json: { name: "uri", write: true } })], n4.prototype, "referenceUri", void 0), r([m2({ type: Date, json: { write: true } })], n4.prototype, "acquisitionDate", void 0), r([r2("acquisitionDate")], n4.prototype, "writeAcquisitionDate", null), r([m2({ json: { write: true } })], n4.prototype, "cameraID", void 0), r([m2({ type: _, json: { write: true } })], n4.prototype, "center", void 0), r([m2({ type: _, json: { write: true } })], n4.prototype, "perspectiveCenter", void 0), r([m2({ json: { write: true } })], n4.prototype, "orientation", void 0), n4 = r([a3("esri.rest.support.ImageInspectionInfo")], n4);
var c9 = n4;

// node_modules/@arcgis/core/rest/support/FindImagesResult.js
var p9 = class extends l {
  constructor() {
    super(...arguments), this.images = null;
  }
};
r([m2({ type: [c9], json: { write: true } })], p9.prototype, "images", void 0), p9 = r([a3("esri.rest.support.FindImagesResult")], p9);

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n5;
var l9 = n5 = class extends l {
  constructor(e3) {
    super(e3), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n5(a({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
r([m2({ type: [String], json: { name: "angleName", write: true } })], l9.prototype, "angleNames", void 0), r([m2({ type: _, json: { write: true } })], l9.prototype, "point", void 0), r([m2({ type: f, json: { write: true } })], l9.prototype, "spatialReference", void 0), r([m2({ type: x, json: { write: true } })], l9.prototype, "rasterId", void 0), l9 = n5 = r([a3("esri.rest.support.ImageAngleParameters")], l9);

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p10 = class extends l {
  constructor(r4) {
    super(r4), this.north = null, this.up = null, this.spatialReference = null;
  }
};
r([m2({ type: Number, json: { write: true } })], p10.prototype, "north", void 0), r([m2({ type: Number, json: { write: true } })], p10.prototype, "up", void 0), r([m2({ type: f, json: { write: true } })], p10.prototype, "spatialReference", void 0), p10 = r([a3("esri.rest.support.ImageAngleResult")], p10);

// node_modules/@arcgis/core/rest/support/imageMeasureUtils.js
var u5 = new o2({ esriMensurationPoint: "point", esriMensurationCentroid: "centroid", esriMensurationDistanceAndAngle: "distance-and-angle", esriMensurationAreaAndPerimeter: "area-and-perimeter", esriMensurationHeightFromBaseAndTop: "base-and-top", esriMensurationHeightFromBaseAndTopShadow: "base-and-top-shadow", esriMensurationHeightFromTopAndTopShadow: "top-and-top-shadow", esriMensurationPoint3D: "point-3D", esriMensurationCentroid3D: "centroid-3D", esriMensurationDistanceAndAngle3D: "distance-and-angle-3D", esriMensurationAreaAndPerimeter3D: "area-and-perimeter-3D" });
var p11 = class extends l {
  constructor() {
    super(...arguments), this.value = null, this.displayValue = null, this.uncertainty = null;
  }
};
r([m2({ type: Number, json: { read: true, write: true } })], p11.prototype, "value", void 0), r([m2({ type: String, json: { read: true, write: true } })], p11.prototype, "displayValue", void 0), r([m2({ type: Number, json: { read: true, write: true } })], p11.prototype, "uncertainty", void 0), p11 = r([a3("esri.rest.support.imageMeasureUtils.BaseImageMeasureResultValue")], p11);
var d6 = class extends p11 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m2({ type: String, json: { read: he.read, write: he.write } })], d6.prototype, "unit", void 0), d6 = r([a3("esri.rest.support.imageMeasureUtils.ImageMeasureResultLengthValue")], d6);
var l10 = class extends p11 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m2({ type: String, json: { read: _e.read, write: _e.write } })], l10.prototype, "unit", void 0), l10 = r([a3("esri.rest.support.imageMeasureUtils.ImageMeasureResultAreaValue")], l10);
var c10 = class extends p11 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m2({ type: String, json: { read: be.read, write: be.write } })], c10.prototype, "unit", void 0), c10 = r([a3("esri.rest.support.imageMeasureUtils.ImageMeasureResultAngleValue")], c10);

// node_modules/@arcgis/core/rest/support/BaseImageMeasureParameters.js
var a8 = class extends l {
  constructor(r4) {
    super(r4), this.type = null, this.measureOperation = null, this.mosaicRule = null, this.pixelSize = null, this.raster = void 0;
  }
};
r([m2()], a8.prototype, "type", void 0), r([m2({ type: u5.apiValues, json: { read: u5.read, write: u5.write } })], a8.prototype, "measureOperation", void 0), r([m2({ type: y2, json: { write: true } })], a8.prototype, "mosaicRule", void 0), r([m2({ type: _, json: { write: true } })], a8.prototype, "pixelSize", void 0), r([m2({ json: { write: true } })], a8.prototype, "raster", void 0), a8 = r([a3("esri.rest.support.BaseImageMeasureParameters")], a8);

// node_modules/@arcgis/core/rest/support/ImageAreaParameters.js
var u6;
var y4 = u6 = class extends a8 {
  constructor() {
    super(...arguments), this.type = "area-perimeter", this.geometry = null, this.is3D = false, this.linearUnit = "meters", this.areaUnit = "square-meters";
  }
  writeGeometry(e3, r4, t8) {
    null != e3 && (r4.geometryType = v(e3), r4[t8] = e3.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "area-and-perimeter-3D" : "area-and-perimeter";
  }
  clone() {
    return new u6(a({ geometry: this.geometry, is3D: this.is3D, linearUnit: this.linearUnit, areaUnit: this.areaUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m2({ types: l3, json: { name: "fromGeometry", read: true, write: true } })], y4.prototype, "geometry", void 0), r([r2("geometry")], y4.prototype, "writeGeometry", null), r([m2({ type: u5.apiValues, json: { write: u5.write } })], y4.prototype, "measureOperation", null), r([m2({ json: { read: true } })], y4.prototype, "is3D", void 0), r([m2({ type: String, json: { read: he.read, write: he.write } })], y4.prototype, "linearUnit", void 0), r([m2({ type: String, json: { read: _e.read, write: _e.write } })], y4.prototype, "areaUnit", void 0), y4 = u6 = r([a3("esri.rest.support.ImageAreaParameters")], y4);

// node_modules/@arcgis/core/rest/support/BaseImageMeasureResult.js
var t5 = class extends l {
  constructor(r4) {
    super(r4), this.name = null, this.sensorName = null;
  }
};
r([m2({ type: String, json: { read: true, write: true } })], t5.prototype, "name", void 0), r([m2({ type: String, json: { read: true, write: true } })], t5.prototype, "sensorName", void 0), t5 = r([a3("esri.rest.support.BaseImageMeasureResult")], t5);

// node_modules/@arcgis/core/rest/support/ImageAreaResult.js
var a9 = class extends t5 {
  constructor() {
    super(...arguments), this.area = null, this.perimeter = null;
  }
};
r([m2({ type: l10, json: { read: true, write: true } })], a9.prototype, "area", void 0), r([m2({ type: d6, json: { read: true, write: true } })], a9.prototype, "perimeter", void 0), a9 = r([a3("esri.rest.support.ImageAreaResult")], a9);

// node_modules/@arcgis/core/rest/support/ImageBoundaryParameters.js
var a10 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.outSpatialReference = null;
  }
};
r([m2({ type: f, json: { name: "outSR", write: true } })], a10.prototype, "outSpatialReference", void 0), a10 = r([a3("esri.rest.support.ImageBoundaryParameters")], a10);

// node_modules/@arcgis/core/rest/support/ImageBoundaryResult.js
var c11 = class extends l {
  constructor() {
    super(...arguments), this.area = null, this.geometry = null;
  }
  readGeometry(r4, o5) {
    return null == r4 ? null : r4.rings ? P.fromJSON(r4) : z.fromJSON(r4);
  }
};
r([m2({ type: Number, json: { write: true } })], c11.prototype, "area", void 0), r([m2({ types: l3, json: { name: "shape", write: true } })], c11.prototype, "geometry", void 0), r([o("geometry")], c11.prototype, "readGeometry", null), c11 = r([a3("esri.rest.support.ImageBoundaryResult")], c11);

// node_modules/@arcgis/core/rest/support/ImageDistanceParameters.js
var u7;
var y5 = u7 = class extends a8 {
  constructor() {
    super(...arguments), this.type = "distance-angle", this.fromGeometry = null, this.toGeometry = null, this.is3D = false, this.linearUnit = "meters", this.angularUnit = "degrees";
  }
  writeFromGeometry(e3, r4, t8) {
    null != e3 && (r4.geometryType = v(e3), r4[t8] = e3.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "distance-and-angle-3D" : "distance-and-angle";
  }
  clone() {
    return new u7(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, is3D: this.is3D, linearUnit: this.linearUnit, angularUnit: this.angularUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m2({ type: _, json: { read: true, write: true } })], y5.prototype, "fromGeometry", void 0), r([r2("fromGeometry")], y5.prototype, "writeFromGeometry", null), r([m2({ type: _, json: { read: true, write: true } })], y5.prototype, "toGeometry", void 0), r([m2({ type: u5.apiValues, json: { write: u5.write } })], y5.prototype, "measureOperation", null), r([m2({ json: { read: true } })], y5.prototype, "is3D", void 0), r([m2({ type: String, json: { read: he.read, write: he.write } })], y5.prototype, "linearUnit", void 0), r([m2({ type: String, json: { read: be.read, write: be.write } })], y5.prototype, "angularUnit", void 0), y5 = u7 = r([a3("esri.rest.support.ImageDistanceParameters")], y5);

// node_modules/@arcgis/core/rest/support/ImageDistanceResult.js
var a11 = class extends t5 {
  constructor() {
    super(...arguments), this.distance = null, this.azimuthAngle = null, this.elevationAngle = null;
  }
};
r([m2({ type: d6, json: { read: true, write: true } })], a11.prototype, "distance", void 0), r([m2({ type: c10, json: { read: true, write: true } })], a11.prototype, "azimuthAngle", void 0), r([m2({ type: c10, json: { read: true, write: true } })], a11.prototype, "elevationAngle", void 0), a11 = r([a3("esri.rest.support.ImageDistanceResult")], a11);

// node_modules/@arcgis/core/rest/support/ImageGPSInfoParameters.js
var j4 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.geometry = null, this.objectIds = null, this.spatialRelationship = "intersects", this.timeExtent = null, this.where = null;
  }
  writeGeometry(o5, t8, r4) {
    null != o5 && (t8.geometryType = v(o5), t8[r4] = JSON.stringify(o5.toJSON()));
  }
};
r([m2({ types: l3, json: { read: f2, write: true } })], j4.prototype, "geometry", void 0), r([r2("geometry")], j4.prototype, "writeGeometry", null), r([m2({ json: { write: true } })], j4.prototype, "objectIds", void 0), r([r3(s4, { ignoreUnknown: false, name: "spatialRel" })], j4.prototype, "spatialRelationship", void 0), r([m2({ type: u, json: { name: "time", write: true } })], j4.prototype, "timeExtent", void 0), r([m2({ type: String, json: { write: true } })], j4.prototype, "where", void 0), j4 = r([a3("esri.rest.support.ImageGPSInfoParameters")], j4);

// node_modules/@arcgis/core/rest/support/CameraInfo.js
var p12 = class extends s7(l) {
  constructor() {
    super(...arguments), this.id = null;
  }
};
r([m2({ json: { write: true } })], p12.prototype, "id", void 0), p12 = r([a3("esri.rest.support.CameraInfo")], p12);
var c12 = p12;

// node_modules/@arcgis/core/rest/support/ImageGPSInfo.js
var p13 = class extends l {
  constructor() {
    super(...arguments), this.id = null, this.name = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.gps = null, this.orientation = null;
  }
  writeAcquisitionDate(o5, t8) {
    t8.acquisitionDate = o5?.getTime();
  }
};
r([m2({ json: { write: true } })], p13.prototype, "id", void 0), r([m2({ json: { write: true } })], p13.prototype, "name", void 0), r([m2({ type: Date, json: { write: true } })], p13.prototype, "acquisitionDate", void 0), r([r2("acquisitionDate")], p13.prototype, "writeAcquisitionDate", null), r([m2({ json: { write: true } })], p13.prototype, "cameraID", void 0), r([m2({ type: _, json: { write: true } })], p13.prototype, "center", void 0), r([m2({ json: { write: true } })], p13.prototype, "gps", void 0), r([m2({ json: { write: true } })], p13.prototype, "orientation", void 0), p13 = r([a3("esri.rest.support.ImageGPSInfo")], p13);
var n6 = p13;

// node_modules/@arcgis/core/rest/support/ImageGPSInfoResult.js
var m8 = class extends l {
  constructor() {
    super(...arguments), this.images = null, this.cameras = null;
  }
};
r([m2({ type: [n6], json: { write: true } })], m8.prototype, "images", void 0), r([m2({ type: [c12], json: { write: true } })], m8.prototype, "cameras", void 0), m8 = r([a3("esri.rest.support.ImageGPSInfoResult")], m8);

// node_modules/@arcgis/core/rest/support/ImageHeightParameters.js
var y6;
var l11 = y6 = class extends a8 {
  constructor() {
    super(...arguments), this.type = "height", this.fromGeometry = null, this.toGeometry = null, this.operationType = "base-and-top", this.linearUnit = "meters";
  }
  writeFromGeometry(e3, r4, t8) {
    null != e3 && (r4.geometryType = v(e3), r4[t8] = e3.toJSON());
  }
  get measureOperation() {
    return this.operationType;
  }
  clone() {
    return new y6(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, operationType: this.operationType, linearUnit: this.linearUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m2({ type: _, json: { read: true } })], l11.prototype, "fromGeometry", void 0), r([r2("fromGeometry")], l11.prototype, "writeFromGeometry", null), r([m2({ type: _, json: { read: true, write: true } })], l11.prototype, "toGeometry", void 0), r([m2({ type: u5.apiValues, json: { write: u5.write } })], l11.prototype, "measureOperation", null), r([m2({ json: { read: true } })], l11.prototype, "operationType", void 0), r([m2({ type: String, json: { read: he.read, write: he.write } })], l11.prototype, "linearUnit", void 0), l11 = y6 = r([a3("esri.rest.support.ImageHeightParameters")], l11);

// node_modules/@arcgis/core/rest/support/ImageHeightResult.js
var p14 = class extends t5 {
  constructor() {
    super(...arguments), this.height = null;
  }
};
r([m2({ type: d6, json: { read: true, write: true } })], p14.prototype, "height", void 0), p14 = r([a3("esri.rest.support.ImageHeightResult")], p14);

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var c13;
var y7 = c13 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterFunctions = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(t8, e3, r4) {
    null != t8 && (e3.geometryType = v(t8), e3[r4] = JSON.stringify(t8.toJSON()));
  }
  set mosaicRule(t8) {
    let e3 = t8;
    e3?.mosaicMethod && (e3 = y2.fromJSON({ ...e3.toJSON(), mosaicMethod: e3.mosaicMethod, mosaicOperation: e3.mosaicOperation })), this._set("mosaicRule", e3);
  }
  writeMosaicRule(t8, e3, r4) {
    null != t8 && (e3[r4] = JSON.stringify(t8.toJSON()));
  }
  set rasterFunction(t8) {
    let e3 = t8;
    e3?.rasterFunction && (e3 = N.fromJSON({ ...e3.toJSON(), rasterFunction: e3.rasterFunction, rasterFunctionArguments: e3.rasterFunctionArguments })), this._set("rasterFunction", e3);
  }
  writeRasterFunction(t8, e3, r4) {
    null != t8 && (e3[r4] = JSON.stringify(t8.toJSON())), t8.rasterFunctionDefinition && (e3[r4] = JSON.stringify(t8.rasterFunctionDefinition));
  }
  writeRasterFunctions(t8, e3, r4) {
    null != t8 && (e3[r4] = JSON.stringify(t8.map((t9) => t9.rasterFunctionDefinition || t9.toJSON())));
  }
  writePixelSize(t8, e3, r4) {
    null != t8 && (e3[r4] = JSON.stringify(t8));
  }
  writeTimeExtent(t8, e3, r4) {
    if (null != t8) {
      const o5 = null != t8.start ? t8.start.getTime() : null, i8 = null != t8.end ? t8.end.getTime() : null;
      e3[r4] = null != o5 ? null != i8 ? `${o5},${i8}` : `${o5}` : null;
    }
  }
  clone() {
    return new c13(a({ geometry: this.geometry, mosaicRule: this.mosaicRule, rasterFunction: this.rasterFunction, rasterFunctions: this.rasterFunctions, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
r([m2({ types: l3, json: { write: true } })], y7.prototype, "geometry", void 0), r([r2("geometry")], y7.prototype, "writeGeometry", null), r([m2({ type: y2, json: { write: true } })], y7.prototype, "mosaicRule", null), r([r2("mosaicRule")], y7.prototype, "writeMosaicRule", null), r([m2({ type: N, json: { write: true, name: "renderingRule" } })], y7.prototype, "rasterFunction", null), r([r2("rasterFunction")], y7.prototype, "writeRasterFunction", null), r([m2({ type: [N], json: { write: true, name: "renderingRules" } })], y7.prototype, "rasterFunctions", void 0), r([r2("rasterFunctions")], y7.prototype, "writeRasterFunctions", null), r([m2({ type: _, json: { write: true } })], y7.prototype, "pixelSize", void 0), r([r2("pixelSize")], y7.prototype, "writePixelSize", null), r([m2({ type: Boolean, json: { write: true } })], y7.prototype, "returnGeometry", void 0), r([m2({ type: Boolean, json: { write: true } })], y7.prototype, "returnCatalogItems", void 0), r([m2({ type: Boolean, json: { write: true } })], y7.prototype, "returnPixelValues", void 0), r([m2({ type: Number, json: { write: true } })], y7.prototype, "maxItemCount", void 0), r([m2({ type: u, json: { write: { target: "time" } } })], y7.prototype, "timeExtent", void 0), r([r2("timeExtent")], y7.prototype, "writeTimeExtent", null), r([m2({ json: { write: true } })], y7.prototype, "raster", void 0), r([m2({ json: { write: true } })], y7.prototype, "viewId", void 0), r([m2({ type: Boolean, json: { write: true } })], y7.prototype, "processAsMultidimensional", void 0), y7 = c13 = r([a3("esri.rest.support.ImageIdentifyParameters")], y7);

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p15 = class extends l {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
r([m2({ json: { write: true } })], p15.prototype, "catalogItemVisibilities", void 0), r([m2({ type: g, json: { write: true } })], p15.prototype, "catalogItems", void 0), r([m2({ type: _, json: { write: true } })], p15.prototype, "location", void 0), r([m2({ json: { write: true } })], p15.prototype, "name", void 0), r([m2({ json: { write: true } })], p15.prototype, "objectId", void 0), r([m2({ json: { write: true } })], p15.prototype, "processedValues", void 0), r([m2({ json: { write: true } })], p15.prototype, "properties", void 0), r([m2({ json: { write: true } })], p15.prototype, "value", void 0), p15 = r([a3("esri.rest.support.ImageIdentifyResult")], p15);

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m9;
var c14 = m9 = class extends l {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r4, e3, o5) {
    e3.geometries = { geometryType: "esriGeometryPoint", geometries: r4.map((r5) => r5.toJSON()) };
  }
  clone() {
    return new m9({ geometries: this.geometries?.map((r4) => r4.clone()) ?? [], rasterId: this.rasterId });
  }
};
r([m2({ type: [_], json: { write: true } })], c14.prototype, "geometries", void 0), r([r2("geometries")], c14.prototype, "writeGeometry", null), r([m2({ type: x, json: { write: true } })], c14.prototype, "rasterId", void 0), c14 = m9 = r([a3("esri.rest.support.ImagePixelLocationParameters")], c14);

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t6 = class extends l {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
r([m2({ json: { write: true } })], t6.prototype, "geometries", void 0), t6 = r([a3("esri.rest.support.ImagePixelLocationResult")], t6);

// node_modules/@arcgis/core/rest/support/ImagePointParameters.js
var c15;
var u8 = c15 = class extends a8 {
  constructor() {
    super(...arguments), this.type = "point", this.geometry = null, this.is3D = false;
  }
  writeGeometry(e3, r4, t8) {
    null != e3 && (r4.geometryType = v(e3), r4[t8] = e3.toJSON());
  }
  get measureOperation() {
    const { is3D: e3, geometry: r4 } = this;
    return "point" === r4.type ? e3 ? "point-3D" : "point" : e3 ? "centroid-3D" : "centroid";
  }
  clone() {
    return new c15(a({ geometry: this.geometry, is3D: this.is3D, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m2({ types: l3, json: { name: "fromGeometry", read: f2 } })], u8.prototype, "geometry", void 0), r([r2("geometry")], u8.prototype, "writeGeometry", null), r([m2({ type: u5.apiValues, json: { read: u5.read, write: u5.write } })], u8.prototype, "measureOperation", null), r([m2({ json: { read: true } })], u8.prototype, "is3D", void 0), u8 = c15 = r([a3("esri.rest.support.ImagePointParameters")], u8);

// node_modules/@arcgis/core/rest/support/ImagePointResult.js
var p16 = class extends t5 {
  constructor() {
    super(...arguments), this.point = null;
  }
};
r([m2({ type: _, json: { name: "point.value", read: true, write: true } })], p16.prototype, "point", void 0), p16 = r([a3("esri.rest.support.ImagePointResult")], p16);

// node_modules/@arcgis/core/rest/support/ImageToMapMultirayParameters.js
var l12 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.geometries = [], this.rasterIds = null, this.outSpatialReference = null;
  }
  writeGeometries(e3, r4, o5) {
    r4.geometries = e3?.length ? { geometryType: v(e3[0]), geometries: e3.map((e4) => ({ ...e4.toJSON(), spatialReference: void 0 })) } : null;
  }
};
r([m2({ types: [l3] })], l12.prototype, "geometries", void 0), r([r2("geometries")], l12.prototype, "writeGeometries", null), r([m2({ type: [x], json: { write: true } })], l12.prototype, "rasterIds", void 0), r([m2({ type: f, json: { name: "outSR", write: true } })], l12.prototype, "outSpatialReference", void 0), l12 = r([a3("esri.rest.support.ImageToMapMultirayParameters")], l12);

// node_modules/@arcgis/core/rest/support/ImageToMapParameters.js
var c16 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.outSpatialReference = null, this.depthOffset = 0, this.adjust = false;
  }
  writeGeometry(o5, e3, t8) {
    null != o5 && (e3.geometryType = v(o5), e3[t8] = { ...o5.toJSON(), spatialReference: void 0 });
  }
};
r([m2({ types: l3, json: { read: f2, write: true } })], c16.prototype, "geometry", void 0), r([r2("geometry")], c16.prototype, "writeGeometry", null), r([m2({ json: { write: true } })], c16.prototype, "rasterId", void 0), r([m2({ type: f, json: { name: "outSR", write: true } })], c16.prototype, "outSpatialReference", void 0), r([m2({ json: { name: "options.DOff", write: true } })], c16.prototype, "depthOffset", void 0), r([m2({ json: { name: "options.Adjust", write: true } })], c16.prototype, "adjust", void 0), c16 = r([a3("esri.rest.support.ImageToMapParameters")], c16);

// node_modules/@arcgis/core/rest/support/ImageUrlParameters.js
var p17 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.referenceUri = null, this.rasterId = null;
  }
};
r([m2({ type: String, json: { name: "uri", write: true } })], p17.prototype, "referenceUri", void 0), r([m2({ type: Number, json: { write: true } })], p17.prototype, "rasterId", void 0), p17 = r([a3("esri.rest.support.ImageUrlParameters")], p17);

// node_modules/@arcgis/core/rest/support/ImageUrlResult.js
var t7 = class extends l {
  constructor() {
    super(...arguments), this.url = null;
  }
};
r([m2({ json: { name: "imageURL", write: true } })], t7.prototype, "url", void 0), t7 = r([a3("esri.rest.support.ImageUrlResult")], t7);

// node_modules/@arcgis/core/rest/support/ImageVolumeParameters.js
var n7 = new o2({ 0: "constant", 1: "plane", 2: "minimum", 3: "maximum", 4: "average" }, { useNumericKeys: true });
var u9 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.geometries = [], this.mosaicRule = null, this.pixelSize = null, this.constantZ = null, this.baseType = "plane";
  }
  writeGeometries(e3, o5, r4) {
    e3?.length && (o5.geometryType = v(e3[0]), o5.geometries = e3.map((e4) => e4.toJSON()));
  }
};
r([m2({ types: [l3] })], u9.prototype, "geometries", void 0), r([r2("geometries")], u9.prototype, "writeGeometries", null), r([m2({ type: y2, json: { write: true } })], u9.prototype, "mosaicRule", void 0), r([m2({ type: _, json: { write: true } })], u9.prototype, "pixelSize", void 0), r([m2({ json: { write: true } })], u9.prototype, "constantZ", void 0), r([m2({ type: n7.apiValues, json: { read: n7.read, write: n7.write } })], u9.prototype, "baseType", void 0), u9 = r([a3("esri.rest.support.ImageVolumeParameters")], u9);

// node_modules/@arcgis/core/rest/support/ImageVolume.js
var s8 = class extends l {
  constructor() {
    super(...arguments), this.area = null, this.cut = null, this.fill = null, this.maxZ = null, this.minZ = null, this.meanZ = null, this.cutCellCount = null, this.fillCellCount = null;
  }
};
r([m2({ json: { write: true } })], s8.prototype, "area", void 0), r([m2({ json: { write: true } })], s8.prototype, "cut", void 0), r([m2({ json: { write: true } })], s8.prototype, "fill", void 0), r([m2({ json: { name: "maxz", write: true } })], s8.prototype, "maxZ", void 0), r([m2({ json: { name: "minz", write: true } })], s8.prototype, "minZ", void 0), r([m2({ json: { name: "meanz", write: true } })], s8.prototype, "meanZ", void 0), r([m2({ json: { write: true } })], s8.prototype, "cutCellCount", void 0), r([m2({ json: { write: true } })], s8.prototype, "fillCellCount", void 0), s8 = r([a3("esri.rest.support.ImageVolume")], s8);
var i7 = s8;

// node_modules/@arcgis/core/rest/support/ImageVolumeResult.js
var p18 = class extends l {
  constructor() {
    super(...arguments), this.volumes = [];
  }
};
r([m2({ type: [i7], json: { write: true } })], p18.prototype, "volumes", void 0), p18 = r([a3("esri.rest.support.ImageVolumeResult")], p18);

// node_modules/@arcgis/core/rest/support/MapToImageParameters.js
var a12 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.visibleOnly = false;
  }
  writeGeometry(r4, o5, e3) {
    null != r4 && (o5.geometryType = v(r4), o5[e3] = JSON.stringify(r4));
  }
};
r([m2({ types: l3, json: { read: f2, write: true } })], a12.prototype, "geometry", void 0), r([r2("geometry")], a12.prototype, "writeGeometry", null), r([m2({ json: { write: true } })], a12.prototype, "rasterId", void 0), r([m2({ json: { name: "options.VisibleOnly", write: true } })], a12.prototype, "visibleOnly", void 0), a12 = r([a3("esri.rest.support.MapToImageParameters")], a12);

// node_modules/@arcgis/core/rest/support/MeasureAreaFromImageResult.js
var n8 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null, this.area = null, this.center = null;
  }
  readCenter(e3, r4) {
    return e3.spatialReference || (e3 = { ...e3, spatialReference: r4.Shape.spatialReference }), _.fromJSON(e3);
  }
};
r([m2({ types: l3, json: { name: "Shape", read: f2, write: true } })], n8.prototype, "geometry", void 0), r([m2({ json: { name: "Length", write: true } })], n8.prototype, "length", void 0), r([m2({ json: { name: "Area", write: true } })], n8.prototype, "area", void 0), r([m2({ type: _, json: { name: "Center", write: true } })], n8.prototype, "center", void 0), r([o("center")], n8.prototype, "readCenter", null), n8 = r([a3("esri.rest.support.MeasureAreaFromImageResult")], n8);

// node_modules/@arcgis/core/rest/support/MeasureFromImageParameters.js
var c17;
var y8 = c17 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = void 0;
  }
  writeGeometry(r4, e3, o5) {
    null != r4 && (e3.geometryType = v(r4), e3[o5] = { ...r4.toJSON(), spatialReference: void 0 });
  }
  clone() {
    const r4 = a({ geometry: this.geometry, rasterId: this.rasterId });
    return new c17(r4);
  }
};
r([m2({ types: l3, json: { name: "fromGeometry", read: f2, write: true } })], y8.prototype, "geometry", void 0), r([r2("geometry")], y8.prototype, "writeGeometry", null), r([m2({ json: { write: true } })], y8.prototype, "rasterId", void 0), y8 = c17 = r([a3("esri.rest.support.MeasureFromImageParameters")], y8);

// node_modules/@arcgis/core/rest/support/MeasureLengthFromImageResult.js
var m10 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null;
  }
};
r([m2({ types: l3, json: { name: "Shape", read: f2, write: true } })], m10.prototype, "geometry", void 0), r([m2({ json: { name: "Length", write: true } })], m10.prototype, "length", void 0), m10 = r([a3("esri.rest.support.MeasureLengthFromImageResult")], m10);

// node_modules/@arcgis/core/rest/imageService.js
function B3(t8) {
  const e3 = t8?.time;
  if (e3 && (null != e3.start || null != e3.end)) {
    const r4 = [];
    null != e3.start && r4.push(e3.start), null == e3.end || r4.includes(e3.end) || r4.push(e3.end), t8.time = r4.join(",");
  }
}
async function D2(t8, r4, o5) {
  r4 = m(j3, r4);
  const s9 = f4(t8), p19 = r4.geometry ? [r4.geometry] : [], u10 = await R2(p19), c18 = r4.toJSON();
  B3(c18);
  const f11 = u10?.[0];
  null != f11 && (c18.geometry = st(f11));
  const l13 = u2({ ...s9.query, f: "json", ...c18 });
  return s3(l13, o5);
}
async function k2(r4, o5, a13) {
  const s9 = (o5 = m(u9, o5)).toJSON();
  s9.geometries = JSON.stringify(s9.geometries);
  const p19 = f4(r4), u10 = u2({ ...p19.query, f: "json", ...s9 }), c18 = s3(u10, a13), { data: f11 } = await H(`${p19.path}/calculateVolume`, c18);
  return p18.fromJSON({ volumes: f11.results });
}
async function z2(o5, a13, s9) {
  const p19 = (a13 = m(l9, a13)).toJSON();
  null != p19.angleName && (p19.angleName = p19.angleName.join(",")), a13?.point?.spatialReference?.imageCoordinateSystem && (p19.point.spatialReference = nt(a13.point.spatialReference)), a13?.spatialReference?.imageCoordinateSystem && (p19.spatialReference = mt(a13.spatialReference));
  const u10 = f4(o5), l13 = u2({ ...u10.query, f: "json", ...p19 }), g3 = s3(l13, s9), { data: y9 } = await H(`${u10.path}/computeAngles`, g3);
  return y9.spatialReference = y9.spatialReference ? null != y9.spatialReference.geodataXform ? new f({ wkid: 0, imageCoordinateSystem: y9.spatialReference }) : f.fromJSON(y9.spatialReference) : null, "NaN" === y9.north && (y9.north = null), "NaN" === y9.up && (y9.up = null), new p10(y9);
}
async function E2(r4, o5, a13) {
  const s9 = (o5 = m(c14, o5)).toJSON(), { geometries: p19 } = o5;
  if (p19) for (let t8 = 0; t8 < p19.length; t8++) p19[t8].spatialReference?.imageCoordinateSystem && (s9.geometries.geometries[t8].spatialReference = nt(p19[t8].spatialReference));
  const u10 = f4(r4), c18 = u2({ ...u10.query, f: "json", ...s9 }), f11 = s3(c18, a13), { data: l13 } = await H(`${u10.path}/computePixelLocation`, f11);
  return t6.fromJSON(l13);
}
async function X(e3, r4, o5) {
  const a13 = await D2(e3, r4, o5), s9 = f4(e3), { data: m11 } = await H(`${s9.path}/computeStatisticsHistograms`, a13), { statistics: i8 } = m11;
  return i8?.length && i8.forEach((t8) => {
    t8.avg = t8.mean, t8.stddev = t8.standardDeviation;
  }), { statistics: i8, histograms: m11.histograms };
}
async function K(e3, r4, o5) {
  const a13 = await D2(e3, r4, o5), s9 = f4(e3), { data: m11 } = await H(`${s9.path}/computeHistograms`, a13);
  return { histograms: m11.histograms };
}
async function Q(r4, o5, s9) {
  const p19 = (o5 = m(h3, o5)).toJSON();
  B3(p19), p19.outFields?.length && (p19.outFields = p19.outFields.join(","));
  const u10 = await R2(o5.geometry), c18 = u10?.[0];
  null != c18 && (p19.geometry = st(c18));
  const f11 = f4(r4), l13 = u2({ ...f11.query, f: "json", ...p19 }), g3 = s3(l13, s9), { data: y9 } = await H(`${f11.path}/getSamples`, g3), j5 = y9.samples.map((t8) => {
    const e3 = "NaN" === t8.value || "" === t8.value ? null : t8.value.split(" ").map((t9) => Number(t9));
    return { ...t8, pixelValue: e3 };
  });
  return p6.fromJSON({ samples: j5 });
}
async function W(r4, o5, s9) {
  o5 = m(y7, o5);
  const p19 = f4(r4), u10 = o5.geometry ? [o5.geometry] : [];
  return R2(u10).then((e3) => {
    const r5 = o5.toJSON(), a13 = e3?.[0];
    null != a13 && (r5.geometry = JSON.stringify(st(a13)));
    const n10 = u2({ ...p19.query, f: "json", ...r5 }), u11 = s3(n10, s9);
    return H(p19.path + "/identify", u11);
  }).then((t8) => p15.fromJSON(t8.data));
}
async function Y(t8, r4, o5) {
  r4 = m(l11, r4);
  const a13 = await et(t8, r4, [r4.fromGeometry, r4.toGeometry], o5);
  return p14.fromJSON(a13);
}
async function Z2(t8, r4, o5) {
  r4 = m(y4, r4);
  const a13 = await et(t8, r4, [r4.geometry], o5);
  return a9.fromJSON(a13);
}
async function _3(t8, r4, o5) {
  r4 = m(u8, r4);
  const a13 = await et(t8, r4, [r4.geometry], o5);
  return p16.fromJSON(a13);
}
async function tt(t8, r4, o5) {
  r4 = m(y5, r4);
  const a13 = await et(t8, r4, [r4.fromGeometry, r4.toGeometry], o5);
  return a11.fromJSON(a13);
}
async function et(e3, r4, o5, s9) {
  const p19 = f4(e3), u10 = await R2(o5), c18 = r4.toJSON();
  null != u10[0] && (c18.fromGeometry = JSON.stringify(st(u10[0]))), null != u10[1] && (c18.toGeometry = JSON.stringify(st(u10[1])));
  const f11 = u2({ ...p19.query, f: "json", ...c18 }), l13 = s3(f11, s9), { data: g3 } = await H(p19.path + "/measure", l13);
  return g3;
}
async function rt(t8, e3, r4) {
  const o5 = await at(t8, e3, r4);
  return m10.fromJSON(o5);
}
async function ot(t8, e3, r4) {
  const o5 = await at(t8, e3, r4);
  return n8.fromJSON(o5);
}
async function at(r4, o5, a13) {
  o5 = m(y8, o5);
  const s9 = f4(r4), p19 = o5.toJSON(), u10 = u2({ ...s9.query, f: "json", ...p19 }), c18 = s3(u10, a13), { data: f11 } = await H(s9.path + "/measureFromImage", c18);
  return f11;
}
function st(t8) {
  const e3 = t8.toJSON();
  return t8.spatialReference?.imageCoordinateSystem && (e3.spatialReference = nt(t8.spatialReference)), e3;
}
function nt(t8) {
  const { imageCoordinateSystem: e3 } = t8;
  if (e3) {
    const { id: t9, referenceServiceName: r4 } = e3;
    return null != t9 ? r4 ? { icsid: t9, icsns: r4 } : { icsid: t9 } : { ics: e3 };
  }
  return t8.toJSON();
}
function mt(t8, e3) {
  if (!t8.imageCoordinateSystem) return c(t8);
  const r4 = nt(t8), { icsid: o5, icsns: a13 } = r4;
  return null == o5 || null != a13 && !e3?.toLowerCase().includes("/" + a13.toLowerCase() + "/") ? JSON.stringify(r4) : `0:${o5}`;
}
async function it(r4, o5, a13) {
  o5 = m(a10, o5);
  const s9 = f4(r4), p19 = o5.toJSON();
  o5.outSpatialReference && (p19.outSR = mt(o5.outSpatialReference));
  const u10 = u2({ ...s9.query, f: "json", ...p19 }), c18 = s3(u10, a13), { data: f11 } = await H(s9.path + "/queryBoundary", c18);
  return c11.fromJSON(f11);
}
async function pt(r4, o5, s9) {
  const p19 = (o5 = m(j4, o5)).toJSON();
  B3(p19), p19.objectIds?.length && (p19.objectIds = p19.objectIds.join(",")), p19.geometry || p19.objectIds || p19.time || p19.where || (p19.where = "1=1");
  const u10 = await R2(o5.geometry), c18 = u10?.[0];
  null != c18 && (p19.geometry = st(c18));
  const f11 = c18?.spatialReference ?? o5.geometry?.spatialReference;
  f11 && (p19.inSR = mt(f11));
  const l13 = f4(r4), g3 = u2({ ...l13.query, f: "json", ...p19 }), y9 = s3(g3, s9), { data: j5 } = await H(`${l13.path}/queryGPSInfo`, y9);
  return m8.fromJSON(j5);
}
async function ut(r4, a13, s9) {
  const p19 = (a13 = m(c16, a13)).toJSON();
  a13.geometry.spatialReference.imageCoordinateSystem && (p19.geometry = st(a13.geometry)), a13.depthOffset && a13.adjust || delete p19.options;
  const u10 = f4(r4), c18 = u2({ ...u10.query, f: "json", ...p19 }), f11 = s3(c18, s9), { data: l13 } = await H(`${u10.path}/imageToMap`, f11);
  return f2(l13);
}
async function ct(r4, a13, s9) {
  const p19 = (a13 = m(l12, a13)).toJSON();
  a13.rasterIds?.length && (p19.rasterIds = a13.rasterIds.join(","));
  const u10 = f4(r4), c18 = u2({ ...u10.query, f: "json", ...p19 }), f11 = s3(c18, s9), { data: l13 } = await H(`${u10.path}/imageToMapMultiray`, f11);
  return f2(l13);
}
async function ft(r4, s9, p19) {
  const u10 = (s9 = m(a12, s9)).toJSON(), c18 = await R2(s9.geometry), f11 = c18?.[0];
  null != f11 && (u10.geometry = st(f11)), s9.visibleOnly || delete u10.options;
  const l13 = f11?.spatialReference ?? s9.geometry?.spatialReference;
  l13 && (u10.inSR = mt(l13));
  const g3 = f4(r4), y9 = u2({ ...g3.query, f: "json", ...u10 }), j5 = s3(y9, p19), { data: d7 } = await H(`${g3.path}/mapToImage`, j5);
  return f2(d7);
}
async function lt(r4, o5, a13) {
  const s9 = (o5 = m(p17, o5)).toJSON(), p19 = f4(r4), u10 = u2({ ...p19.query, f: "json", ...s9 }), c18 = s3(u10, a13), { data: f11 } = await H(`${p19.path}/getImageUrl`, c18);
  return t7.fromJSON(f11);
}
async function gt(r4, o5, s9) {
  const c18 = (o5 = m(i6, o5)).toJSON(), f11 = await R2([o5.fromGeometry, o5.toGeometry]);
  null != f11[0] && (c18.fromGeometry = st(f11[0]), f11[0].spatialReference && (c18.inSR = mt(f11[0].spatialReference))), null != f11[1] && (c18.toGeometry = st(f11[1])), o5.objectIds?.length && (c18.objectIds = c18.objectIds.join(","));
  const l13 = f4(r4), g3 = u2({ ...l13.query, f: "json", ...c18 }), y9 = s3(g3, s9), { data: j5 } = await H(`${l13.path}/find`, y9);
  return p9.fromJSON(j5);
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n9(n10, m11, p19) {
  const f11 = f4(n10), u10 = u2({ ...f11?.query, f: "json" }), h5 = s3(u10, p19), d7 = `${f11?.path}/${m11}/info`, c18 = H(`${d7}`, h5), g3 = H(`${d7}/keyProperties`, h5), x3 = await Promise.allSettled([c18, g3]), y9 = "fulfilled" === x3[0].status ? x3[0].value.data : null, v5 = "fulfilled" === x3[1].status ? x3[1].value.data : null;
  let P4 = null;
  y9.statistics?.length && (P4 = y9.statistics.map((e3) => ({ min: e3[0], max: e3[1], avg: e3[2], stddev: e3[3] })));
  const S3 = z.fromJSON(y9.extent), j5 = Math.ceil(S3.width / y9.pixelSizeX - 0.1), w3 = Math.ceil(S3.height / y9.pixelSizeY - 0.1), b4 = S3.spatialReference, k3 = new _({ x: y9.pixelSizeX, y: y9.pixelSizeY, spatialReference: b4 }), z3 = y9.histograms?.length ? y9.histograms : null, L = new l6({ origin: y9.origin, blockWidth: y9.blockWidth, blockHeight: y9.blockHeight, firstPyramidLevel: y9.firstPyramidLevel, maximumPyramidLevel: y9.maxPyramidLevel });
  return new m5({ width: j5, height: w3, bandCount: y9.bandCount, extent: S3, spatialReference: b4, pixelSize: k3, pixelType: y9.pixelType.toLowerCase(), statistics: P4, histograms: z3, keyProperties: v5, storageInfo: L });
}

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var Je = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var Be = i2(a2, { min: 0, max: 255 });
function Le(e3) {
  const t8 = JSON.stringify(e3), i8 = t8.includes('"rasterFunctionDefinition":{'), r4 = i8 ? t8.match(/"type":"(.*?FunctionArguments")/gi) : t8.match(/"rasterFunction":"(.*?")/gi), s9 = r4?.map((e4) => i8 ? e4.slice(8, -18) : e4.slice(18, -1));
  return s9 ? s9.join("/") : null;
}
var ze = (m11) => {
  let h5 = class extends m11 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._serviceSupportsMosaicRule = null, this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new d5({ layer: this }));
    }
    readServiceSupportsMosaicRule(e3, t8) {
      return this._isMosaicRuleSupported(t8);
    }
    get _rasterFunctionNamesIndex() {
      const e3 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || null != this.rasterFunctionInfos && this.rasterFunctionInfos.length < 1 || null != this.rasterFunctionInfos && this.rasterFunctionInfos.forEach((t8) => {
        e3.set(t8.name.toLowerCase().replaceAll(/ /gi, "_"), t8.name);
      }), e3;
    }
    readBandIds(e3, t8) {
      if (Array.isArray(e3) && e3.length > 0 && e3.every((e4) => "number" == typeof e4)) return e3;
    }
    readCapabilities(e3, t8) {
      return this._readCapabilities(t8);
    }
    writeCompressionQuality(e3, t8, i8) {
      null != e3 && "lerc" !== this.format && (t8[i8] = e3);
    }
    writeCompressionTolerance(e3, t8, i8) {
      "lerc" === this.format && null != e3 && (t8[i8] = e3);
    }
    readDefaultMosaicRule(e3, t8) {
      return this._serviceSupportsMosaicRule ? y2.fromJSON(t8) : null;
    }
    get fieldsIndex() {
      return this.fields ? new Z(this.fields) : null;
    }
    set format(e3) {
      e3 && Je.has(e3.toLowerCase()) && this._set("format", e3.toLowerCase());
    }
    readFormat(e3, t8) {
      return "esriImageServiceDataTypeVector-UV" === t8.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t8.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e3, t8) {
      return null != t8.minLOD && null != t8.maxLOD ? e3 : 0;
    }
    readMaxScale(e3, t8) {
      return null != t8.minLOD && null != t8.maxLOD ? e3 : 0;
    }
    set mosaicRule(e3) {
      let t8 = e3;
      t8?.mosaicMethod && (t8 = y2.fromJSON({ ...t8.toJSON(), mosaicMethod: t8.mosaicMethod, mosaicOperation: t8.mosaicOperation })), this._set("mosaicRule", t8);
    }
    readMosaicRule(e3, t8) {
      const i8 = e3 || t8.mosaicRule;
      return i8 ? y2.fromJSON(i8) : this._isMosaicRuleSupported(t8) ? y2.fromJSON(t8) : null;
    }
    writeMosaicRule(e3, t8, i8) {
      const { mosaicRule: r4 } = this;
      this._isValidCustomizedMosaicRule(r4) && (t8[i8] = r4.toJSON());
    }
    writeNoData(e3, t8, i8) {
      null != e3 && "number" == typeof e3 && (t8[i8] = Be(e3));
    }
    readObjectIdField(e3, t8) {
      if (!e3) {
        const i8 = t8.fields.find((e4) => "esriFieldTypeOID" === e4.type || "oid" === e4.type);
        e3 = i8?.name;
      }
      return e3;
    }
    get parsedUrl() {
      return I(this.url);
    }
    readSourceType(e3, t8) {
      return this._isMosaicDataset(t8) ? "mosaic-dataset" : "raster-dataset";
    }
    get renderer() {
      const { activePresetRendererName: e3, presetRenderers: t8 } = this;
      if (e3) {
        const i8 = t8?.find(({ name: t9 }) => t9 === e3);
        return i8?.renderer.clone();
      }
      return this.internalRenderer;
    }
    set renderer(e3) {
      this.activePresetRendererName = null, this.internalRenderer = e3;
    }
    set internalRenderer(e3) {
      this.loaded && (e3 = this._configRenderer(e3)), this._set("internalRenderer", e3);
    }
    readRenderer(e3, t8, i8) {
      const r4 = t8?.layerDefinition?.drawingInfo?.renderer, s9 = c6(r4, i8);
      return null == s9 ? null : ("vector-field" === s9.type && t8.symbolTileSize && !r4.symbolTileSize && (s9.symbolTileSize = t8.symbolTileSize), p8(s9) || i.getLogger(this).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), s9);
    }
    writeRenderer(e3, t8, i8) {
      t8.layerDefinition = t8.layerDefinition || {}, t8.layerDefinition.drawingInfo = t8.layerDefinition.drawingInfo || {}, t8.layerDefinition.drawingInfo.renderer = e3.toJSON(), "vector-field" === e3.type && (t8.symbolTileSize = e3.symbolTileSize);
    }
    get rasterFields() {
      const e3 = this.fields?.map((e4) => e4.clone()) ?? [];
      e3.push(o3()), "mosaic-dataset" === this.sourceType && this.fields?.length && e3.push(m4()), this.version >= 10.4 && null != this.rasterFunctionInfos && this.rasterFunctionInfos.some(({ name: e4 }) => "none" === e4.toLowerCase()) && e3.push(c5()), null != this.rasterFunctionInfos && this.rasterFunctionInfos.filter(({ name: e4 }) => "none" !== e4.toLowerCase()).forEach(({ name: t9 }) => e3.push(f6(t9)));
      const { rasterInfo: t8 } = this;
      if (this._isVectorDataSet()) {
        const i9 = t8?.multidimensionalInfo?.variables[0].unit?.trim(), r4 = d3(i9), s9 = $();
        e3.push(r4, s9);
      }
      if (t8?.multidimensionalInfo && "raster-dataset" === this.sourceType) {
        const i9 = p4(t8.multidimensionalInfo);
        e3.push(...i9);
      }
      const i8 = t8?.attributeTable;
      if (null != i8) {
        const t9 = v2(i8);
        e3.push(...t9);
      }
      return e3;
    }
    set rasterFunction(e3) {
      let t8 = e3;
      t8?.rasterFunction && (t8 = N.fromJSON({ ...t8.toJSON(), rasterFunction: t8.rasterFunction, rasterFunctionArguments: t8.rasterFunctionArguments })), this._set("rasterFunction", t8);
    }
    readRasterFunction(e3, t8) {
      const i8 = t8.rasterFunctionInfos;
      return t8.renderingRule || i8?.length && "None" !== i8[0].name ? this._isRFTJson(t8.renderingRule) ? N.fromJSON({ rasterFunctionDefinition: t8.renderingRule }) : N.fromJSON(t8.renderingRule || { rasterFunctionInfos: t8.rasterFunctionInfos }) : null;
    }
    readSpatialReference(e3, t8) {
      const i8 = e3 || t8.extent.spatialReference;
      return i8 ? f.fromJSON(i8) : null;
    }
    writePixelType(e3, t8, i8) {
      null != this.serviceRasterInfo && this.pixelType === this.serviceRasterInfo.pixelType || (t8[i8] = n.toJSON(e3));
    }
    readVersion(e3, t8) {
      let i8 = t8.currentVersion;
      return i8 || (i8 = t8.hasOwnProperty("fields") || t8.hasOwnProperty("timeInfo") ? 10 : 9.3), i8;
    }
    applyFilter(e3) {
      let t8 = e3;
      return this.pixelFilter && (t8 = this._clonePixelData(e3), this.pixelFilter(t8)), t8;
    }
    async applyRenderer(e3, t8) {
      let i8 = e3;
      const { renderer: r4, symbolizer: s9, pixelFilter: n10 } = this;
      if (!this._isPicture() && r4 && s9 && !n10) {
        await this._updateSymbolizer(s9, r4);
        const { bandIds: n11 } = this;
        i8 = await this._symbolize({ pixelData: e3, bandIds: n11, symbolizer: s9 }, t8);
      }
      return i8;
    }
    destroy() {
      this._shutdownJobHandler();
    }
    async calculateVolume(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsCalculateVolume) throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return e3 = a(e3), this.mosaicRule && null == e3.mosaicRule && (e3.mosaicRule = this.mosaicRule), k2(this.url, e3, this._getRequestOptions(t8));
    }
    async computeAngles(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsComputeAngles) throw new s("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return z2(this.url, e3, this._getRequestOptions(t8));
    }
    async computePixelSpaceLocations(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsComputePixelLocation) throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return E2(this.url, e3, this._getRequestOptions(t8));
    }
    async computeHistograms(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsComputeHistograms) throw new s("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      return e3 = a(e3), this._applyMosaicAndRenderingRules(e3), K(this.url, e3, this._getRequestOptions(t8));
    }
    async computeStatisticsHistograms(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsComputeStatisticsHistograms) throw new s("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      return e3 = a(e3), this._applyMosaicAndRenderingRules(e3), X(this.url, e3, this._getRequestOptions(t8));
    }
    async measureHeight(e3, t8) {
      const i8 = await this._fetchCapabilities(t8?.signal);
      if (!("base-and-top" === e3.operationType ? i8.mensuration.supportsHeightFromBaseAndTop : "base-and-top-shadow" === e3.operationType ? i8.mensuration.supportsHeightFromBaseAndTopShadow : i8.mensuration.supportsHeightFromTopAndTopShadow)) throw new s("imagery-layer:measure-height", "this operation is not supported on the input image service");
      return e3 = a(e3), this._applyMosaicRule(e3), Y(this.url, e3, this._getRequestOptions(t8));
    }
    async measureAreaAndPerimeter(e3, t8) {
      const i8 = await this._fetchCapabilities(t8?.signal);
      if (!(i8.mensuration.supportsAreaAndPerimeter && (!e3.is3D || i8.mensuration.supports3D))) throw new s("imagery-layer:measure-area-and-perimeter", "this operation is not supported on the input image service");
      return e3 = a(e3), this._applyMosaicRule(e3), Z2(this.url, e3, this._getRequestOptions(t8));
    }
    async measureDistanceAndAngle(e3, t8) {
      const i8 = await this._fetchCapabilities(t8?.signal);
      if (!(i8.mensuration.supportsDistanceAndAngle && (!e3.is3D || i8.mensuration.supports3D))) throw new s("imagery-layer:measure-distance-and-angle", "this operation is not supported on the input image service");
      return e3 = a(e3), this._applyMosaicRule(e3), tt(this.url, e3, this._getRequestOptions(t8));
    }
    async measurePointOrCentroid(e3, t8) {
      const i8 = await this._fetchCapabilities(t8?.signal);
      if (!(i8.mensuration.supportsPointOrCentroid && (!e3.is3D || i8.mensuration.supports3D))) throw new s("imagery-layer:measure-point-or-centroid", "this operation is not supported on the input image service");
      return e3 = a(e3), this._applyMosaicRule(e3), _3(this.url, e3, this._getRequestOptions(t8));
    }
    async measureLengthFromImage(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-length-from-image", "this operation is not supported on the input image service");
      if ("polyline" !== e3.geometry.type) throw new s("imagery-layer:measure-length-from-image", "this input geometry must be a polyline");
      return rt(this.url, e3, this._getRequestOptions(t8));
    }
    async measureAreaFromImage(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-area-from-image", "this operation is not supported on the input image service");
      if ("polygon" !== e3.geometry.type) throw new s("imagery-layer:measure-area-from-image", "this input geometry must be a polygon");
      return ot(this.url, e3, this._getRequestOptions(t8));
    }
    getField(e3) {
      const { fieldsIndex: t8 } = this;
      return null != t8 ? t8.get(e3) : void 0;
    }
    getFieldDomain(e3, t8) {
      const i8 = this.getField(e3);
      return i8 ? i8.domain : null;
    }
    fetchImage(e3, t8, i8, n10 = {}) {
      if (s2(i.getLogger(this), "`ImageryLayer.fetchImage` is deprecated in favor of 'ImageryLayer.fetchPixels'.", { replacement: "ImageryLayer.fetchPixels", version: "4.33", warnOnce: true }), null == e3 || null == t8 || null == i8) throw new s("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
      return this.internalFetchImage(e3, t8, i8, n10);
    }
    async internalFetchImage(e3, t8, i8, r4 = {}) {
      this._updateCurrentRasterInfo();
      const s9 = this.getExportImageServiceParameters(e3, t8, i8, r4.timeExtent);
      if (null == s9) {
        if (r4.requestAsImageElement && this._canRequestImageElement(this.format)) {
          const e4 = document.createElement("canvas");
          if (e4.width = t8, e4.height = i8, r4.returnImageBitmap) {
            return { imageBitmap: await t2(e4, `${ze2(this.parsedUrl)}/exportImage`, r4.signal) };
          }
          return { imageOrCanvasElement: e4 };
        }
        const { bandIds: s10, rasterInfo: n11 } = this, a14 = (s10?.length || n11.bandCount) ?? 0, o6 = t8 * i8, l13 = n11.pixelType, u10 = [];
        for (let e4 = 0; e4 < a14; e4++) u10.push(c4.createEmptyBand(l13, o6));
        return { pixelData: { pixelBlock: new c4({ width: t8, height: i8, pixels: u10, mask: new Uint8Array(o6), pixelType: l13 }), extent: e3 } };
      }
      const n10 = !!r4.requestAsImageElement && !this.pixelFilter, a13 = n10 && !!r4.returnImageBitmap, o5 = { imageServiceParameters: s9, imageProps: { extent: e3, width: t8, height: i8, format: this.format }, requestAsImageElement: n10, returnImageBitmap: a13, signal: r4.signal };
      return this._requestArrayBuffer(o5);
    }
    async fetchPixels(e3, t8, i8, r4 = {}) {
      await this._initJobHandler(), r4.applyRendering && this._updateCurrentRasterInfo();
      const s9 = r4.applyRendering ? void 0 : new d5({ layer: this, requestRawData: true, interpolation: r4.interpolation ?? "nearest", bandIds: r4.bandIds ?? [] }), n10 = this.getExportImageServiceParameters(e3, t8, i8, r4.timeExtent, s9);
      if (null == n10) return { extent: e3, pixelBlock: null };
      delete n10.pixelType, delete n10.bandIds, delete n10.compressionQuality;
      const a13 = { imageServiceParameters: n10, imageProps: { extent: e3, width: t8, height: i8, format: this.format }, requestAsImageElement: false, returnImageBitmap: false, signal: r4.signal }, { pixelData: o5 } = await this._requestArrayBuffer(a13);
      return o5 ?? { extent: e3, pixelBlock: null };
    }
    fetchKeyProperties(e3) {
      return H(ze2(this.parsedUrl) + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e3?.rasterFunction : null }) }).then((e4) => e4.data);
    }
    fetchRasterAttributeTable(e3) {
      return this.version < 10.1 ? Promise.reject(new s("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : H(ze2(this.parsedUrl) + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e3?.rasterFunction : null }) }).then((e4) => g.fromJSON(e4.data));
    }
    getCatalogItemRasterInfo(e3, t8) {
      const i8 = { ...t8, query: this._getQueryParams() };
      return n9(ze2(this.parsedUrl), e3, i8);
    }
    async getCatalogItemICSInfo(e3, t8) {
      const { data: r4 } = await H(ze2(this.parsedUrl) + "/" + e3 + "/info/ics", { query: this._getQueryParams(), ...t8 }), s9 = r4?.ics;
      if (!s9) return;
      let n10 = null;
      try {
        n10 = (await H(ze2(this.parsedUrl) + "/" + e3 + "/info", { query: this._getQueryParams(), ...t8 })).data.extent;
      } catch {
      }
      if (!n10?.spatialReference) return { ics: s9, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const a13 = this.version >= 10.7 ? H(ze2(this.parsedUrl) + "/" + e3 + "/info/icstopixel", { query: this._getQueryParams(), ...t8 }).then((e4) => e4.data).catch(() => ({})) : {}, o5 = n10.spatialReference, l13 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [n10] }), inSR: c(o5), outSR: "0:" + e3 }, u10 = H(ze2(this.parsedUrl) + "/project", { query: this._getQueryParams(l13), ...t8 }).then((e4) => e4.data).catch(() => ({})), p19 = 5, m12 = (n10.xmin + n10.xmax) / 2, c18 = (n10.ymax - n10.ymin) / (p19 + 1), h6 = n10.ymin + c18, d7 = [];
      for (let i8 = 0; i8 < p19; i8++) d7.push({ x: m12, y: h6 + c18 * i8 });
      const f11 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: d7 }), inSR: c(o5), outSR: "0:" + e3 }, y9 = H(ze2(this.parsedUrl) + "/project", { query: this._getQueryParams(f11), ...t8 }).then((e4) => e4.data).catch(() => ({})), R4 = await Promise.all([a13, u10, y9]);
      let w3 = R4[0].ipxf;
      if (null == w3) {
        const e4 = s9.geodataXform?.xf_0;
        "topup" === e4?.name?.toLowerCase() && 6 === e4?.coefficients?.length && (w3 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e4.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const b4 = z.fromJSON(R4[1]?.geometries?.[0]);
      b4 && (b4.spatialReference = new f({ wkid: 0, imageCoordinateSystem: s9 }));
      const S3 = R4[2].geometries ? R4[2].geometries.filter((e4) => null != e4?.x && null != e4.y && "NaN" !== e4.x && "NaN" !== e4.y) : [], x3 = S3.length;
      if (x3 < 3) return { ics: s9, icsToPixelTransform: w3, icsExtent: b4, northDirection: null };
      let _4 = 0, F2 = 0, D3 = 0, T2 = 0;
      for (let i8 = 0; i8 < x3; i8++) _4 += S3[i8].x, F2 += S3[i8].y, D3 += S3[i8].x * S3[i8].x, T2 += S3[i8].x * S3[i8].y;
      const O = (x3 * T2 - _4 * F2) / (x3 * D3 - _4 * _4);
      let C3 = 0;
      const M = S3[p19 - 1].x > S3[0].x, P4 = S3[p19 - 1].y > S3[0].y;
      return O === 1 / 0 ? C3 = P4 ? 90 : 270 : 0 === O ? C3 = M ? 0 : 180 : O > 0 ? C3 = M ? 180 * Math.atan(O) / Math.PI : 180 * Math.atan(O) / Math.PI + 180 : O < 0 && (C3 = P4 ? 180 + 180 * Math.atan(O) / Math.PI : 360 + 180 * Math.atan(O) / Math.PI), { ics: s9, icsToPixelTransform: w3, icsExtent: b4, northDirection: C3 };
    }
    async generateRasterInfo(e3, t8) {
      e3 = m(N, e3);
      const i8 = { ...t8, query: this._getQueryParams() };
      if (!e3 || "none" === e3.functionName?.toLowerCase() || this._isVectorFieldResampleFunction(e3)) return this.serviceRasterInfo ?? f8(ze2(this.parsedUrl), this.sourceJSON, i8);
      const r4 = Le(e3);
      if (!r4) throw new s("imagery-layer:generate-raster-info", "the rendering rule is not supported");
      if (this._functionRasterInfos[r4]) return this._functionRasterInfos[r4];
      const n10 = p7(ze2(this.parsedUrl), e3, i8);
      this._functionRasterInfos[r4] = n10;
      try {
        return await n10;
      } catch (a13) {
        throw this._functionRasterInfos[r4] = null, a13;
      }
    }
    getExportImageServiceParameters(e3, t8, i8, r4, s9) {
      e3 = e3.clone().shiftCentralMeridian();
      const n10 = mt(e3.spatialReference, ze2(this.parsedUrl));
      s9 ??= this.exportImageServiceParameters;
      const a13 = s9.toJSON(), { bandIds: o5, noData: l13 } = a13;
      let { renderingRule: u10 } = a13;
      const p19 = this.rasterFunction?.rasterFunctionDefinition, m12 = this.renderer?.type, c18 = !m12 || "raster-stretch" === m12 || "raster-colormap" === m12 || "unique-value" === m12 || "class-breaks" === m12 || "raster-shaded-relief" === m12;
      if (o5?.length && this._hasRasterFunction(this.rasterFunction) && !p19 && c18) {
        const e4 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: o5 } };
        if ("Stretch" === u10.rasterFunction) e4.rasterFunctionArguments.Raster = u10.rasterFunctionArguments.Raster, u10.rasterFunctionArguments.Raster = e4;
        else if ("Colormap" === u10.rasterFunction) {
          const t9 = u10.rasterFunctionArguments.Raster;
          "Stretch" === t9?.rasterFunction ? (e4.rasterFunctionArguments.Raster = t9.rasterFunctionArguments.Raster, t9.rasterFunctionArguments.Raster = e4) : (e4.rasterFunctionArguments.Raster = t9, u10.rasterFunctionArguments.Raster = e4);
        } else e4.rasterFunctionArguments.Raster = u10, u10 = e4;
        a13.bandIds = void 0;
      } else a13.bandIds = o5?.join(",");
      Array.isArray(l13) && l13.length > 0 && (a13.noData = l13.join(","));
      const h6 = this._processMultidimensionalIntersection(null, r4, s9.mosaicRule);
      if (h6.isOutSide) return null;
      a13.mosaicRule = null != h6.mosaicRule ? JSON.stringify(h6.mosaicRule) : null, r4 = h6.timeExtent, a13.renderingRule = this._getRenderingRuleString(N.fromJSON(u10));
      const d7 = {};
      if (null != r4) {
        const { start: e4, end: t9 } = r4.toJSON();
        e4 && t9 && e4 === t9 ? d7.time = "" + e4 : null == e4 && null == t9 || (d7.time = `${e4 ?? "null"},${t9 ?? "null"}`);
      }
      return { bbox: e3.xmin + "," + e3.ymin + "," + e3.xmax + "," + e3.ymax, bboxSR: n10, imageSR: n10, size: t8 + "," + i8, ...a13, ...d7 };
    }
    async getSamples(e3, t8) {
      const i8 = await this._fetchCapabilities(t8?.signal);
      if (!i8?.operations.supportsGetSamples) throw new s("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e3 = a(e3);
      const { raster: r4 } = this;
      return r4 && null == e3.raster && (e3.raster = r4), Q(this.url, e3, this._getRequestOptions(t8));
    }
    async identify(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsIdentify) throw new s("imagery-layer:identify", "identify operation is not supported on the input image service");
      e3 = a(e3), this.version < 10.91 && "extent" === e3.geometry?.type && (e3.geometry = P.fromExtent(e3.geometry));
      const i8 = this._processMultidimensionalIntersection(e3.geometry, e3.timeExtent, e3.mosaicRule || this.mosaicRule);
      if (i8.isOutSide) throw new s("imagery-layer:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      e3.timeExtent = i8.timeExtent, e3.mosaicRule = i8.mosaicRule;
      const { raster: r4, rasterFunction: a13 } = this;
      return a13 && null == e3.rasterFunction && (e3.rasterFunction = a13), r4 && null == e3.raster && (e3.raster = r4), W(this.url, e3, this._getRequestOptions(t8));
    }
    async imageToMap(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsImageToMap) throw new s("imagery-layer:image-to-map", "imageToMap operation is not supported on the input image service");
      return ut(ze2(this.parsedUrl), e3, this._getRequestOptions(t8));
    }
    async imageToMapMultiray(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsImageToMapMultiray) throw new s("imagery-layer:image-to-map-multiray", "imageToMapMultiray operation is not supported on the input image service");
      return ct(ze2(this.parsedUrl), e3, this._getRequestOptions(t8));
    }
    async mapToImage(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsMapToImage) throw new s("imagery-layer:map-to-image", "mapToImage operation is not supported on the input image service");
      return ft(ze2(this.parsedUrl), e3, this._getRequestOptions(t8));
    }
    async findImages(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsFindImages) throw new s("imagery-layer:find-images", "findImages operation is not supported on the input image service");
      return gt(ze2(this.parsedUrl), e3, this._getRequestOptions(t8));
    }
    async getImageUrl(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsGetImageUrl) throw new s("imagery-layer:get-image-url", "getImageUrl operation is not supported on the input image service");
      return lt(ze2(this.parsedUrl), e3, this._getRequestOptions(t8));
    }
    createQuery() {
      return new R({ outFields: ["*"], returnGeometry: true, where: this.definitionExpression || "1=1" });
    }
    async queryBoundary(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsQueryBoundary) throw new s("imagery-layer:query-boundary", "queryBoundary operation is not supported on the input image service");
      return e3 = e3 ?? { outSpatialReference: this.spatialReference }, it(ze2(this.parsedUrl), e3, this._getRequestOptions(t8));
    }
    async queryRasters(e3, t8) {
      return { query: e3, requestOptions: t8 } = await this._prepareForQuery(e3, t8), s6(this.url, e3, t8);
    }
    async queryObjectIds(e3, t8) {
      return { query: e3, requestOptions: t8 } = await this._prepareForQuery(e3, t8), i3(this.url, e3, t8);
    }
    async queryGPSInfo(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsQueryGPSInfo) throw new s("imagery-layer:query-gps-info", "queryGPSInfo operation is not supported on the input image service");
      return e3 = e3 ?? { where: "1=1" }, pt(ze2(this.parsedUrl), e3, this._getRequestOptions(t8));
    }
    async queryRasterCount(e3, t8) {
      return { query: e3, requestOptions: t8 } = await this._prepareForQuery(e3, t8), s5(this.url, e3, t8);
    }
    async queryVisibleRasters(e3, t8) {
      if (!e3) throw new s("imagery-layer: query-visible-rasters", "missing query parameter");
      await this.load();
      const { pixelSize: i8, returnDomainValues: r4, returnTopmostRaster: n10, showNoDataRecords: a13 } = t8 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let o5 = false, l13 = null, u10 = null;
      const p19 = t4.servicePixelValue.toLowerCase(), m12 = this._rasterFunctionNamesIndex;
      if (null != e3.outFields && (o5 = e3.outFields.some((e4) => !e4.toLowerCase().startsWith(p19)), this.version >= 10.4)) {
        const t9 = e3.outFields.filter((e4) => e4.toLowerCase().startsWith(p19) && e4.length > p19.length).map((e4) => {
          const t10 = e4.slice(p19.length + 1);
          return [this._updateRenderingRulesFunctionName(t10, m12), t10];
        });
        l13 = t9.map((e4) => new N({ functionName: e4[0] })), u10 = t9.map((e4) => e4[1]);
        const { rasterFunction: i9 } = this;
        0 === l13.length ? i9?.functionName ? (l13.push(i9), u10.push(i9.functionName)) : l13 = null : i9?.functionName && !l13.some((e4) => e4.functionName === i9.functionName) && (l13.push(i9), u10.push(i9.functionName));
      }
      const c18 = null == e3.outSpatialReference || e3.outSpatialReference.equals(this.spatialReference), { multidimensionalSubset: h6 } = this;
      let d7 = e3.timeExtent || this.timeExtent;
      if (h6) {
        const { isOutside: t9, intersection: i9 } = m6(h6, { geometry: e3.geometry, timeExtent: e3.timeExtent, multidimensionalDefinition: this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition });
        if (t9) throw new s("imagery-layer:query-visible-rasters", "the request cannot be fulfilled when falling outside of the multidimensional subset");
        null != i9?.timeExtent && (d7 = i9.timeExtent);
      }
      const f11 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, d7);
      let y9 = e3.geometry;
      this.version < 10.91 && "extent" === y9?.type && (y9 = P.fromExtent(y9));
      const g3 = this._getQueryParams({ geometry: y9, timeExtent: d7, mosaicRule: f11, rasterFunction: this.version < 10.4 ? this.rasterFunction : null, rasterFunctions: l13, pixelSize: i8, returnCatalogItems: o5, returnGeometry: c18, raster: this.raster, maxItemCount: n10 ? 1 : null });
      delete g3.f;
      const I2 = new y7(g3);
      try {
        await this._generateRasterInfo(this.rasterFunction);
        const i9 = await W(this.url, I2, { signal: t8?.signal, query: { ...this.customParameters } }), s9 = e3.outFields, n11 = null != i9.value && i9.value.toLowerCase().includes("nodata"), l14 = o5 && !c18 && i9?.catalogItems?.features.length && (a13 || !n11), p20 = this.multidimensionalInfo && "raster-dataset" === this.sourceType ? f7({ rasterInfo: this.rasterInfo, multidimensionalDefinition: f11?.multidimensionalDefinition, timeExtent: d7, multidimensionalSubset: this.multidimensionalSubset }) : null;
        if (!l14) return this._processVisibleRastersResponse(i9, { returnDomainValues: r4, templateRRFunctionNames: u10, showNoDataRecords: a13, templateFields: s9, effectiveMultidimensionalDefinition: p20 });
        const m13 = this.objectIdField || "ObjectId", h7 = i9.catalogItems?.features ?? [], y10 = h7.map((e4) => e4.attributes?.[m13]), g4 = new R({ objectIds: y10, returnGeometry: true, outSpatialReference: e3.outSpatialReference, outFields: [m13] }), R4 = await this.queryRasters(g4);
        return R4?.features?.length && R4.features.forEach((t9) => {
          h7.forEach((i10) => {
            i10.attributes[m13] === t9.attributes[m13] && t9.geometry && (i10.geometry = t9.geometry.clone(), null != e3.outSpatialReference && (i10.geometry.spatialReference = e3.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(i9, { returnDomainValues: r4, templateRRFunctionNames: u10, showNoDataRecords: a13, templateFields: s9, effectiveMultidimensionalDefinition: p20 });
      } catch {
        throw new s("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e3, t8) {
      const r4 = H(ze2(this.parsedUrl) + "/statistics", { query: this._getQueryParams({ variable: e3 }), signal: t8 }).then((e4) => e4.data?.statistics), s9 = H(ze2(this.parsedUrl) + "/histograms", { query: this._getQueryParams({ variable: e3 }), signal: t8 }).then((e4) => e4.data?.histograms), n10 = await Promise.all([r4, s9]);
      return n10[0] && n10[0].forEach((e4) => {
        e4.avg = e4.mean, e4.stddev = e4.standardDeviation;
      }), { statistics: n10[0] || null, histograms: n10[1] || null };
    }
    getMultidimensionalSubsetVariables(e3) {
      const t8 = e3 ?? this.serviceRasterInfo.multidimensionalInfo;
      return v3(this.multidimensionalSubset, t8);
    }
    async _fetchService(e3) {
      await this._fetchServiceInfo(e3), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
      const t8 = this.sourceJSON, i8 = null != this.serviceRasterInfo ? Promise.resolve(this.serviceRasterInfo) : f8(ze2(this.parsedUrl), t8, { signal: e3, query: this._getQueryParams() }).then((e4) => (this._set("serviceRasterInfo", e4), this._set("multidimensionalInfo", e4.multidimensionalInfo), c7(e4, t8), e4)), r4 = this._hasRasterFunction(this.rasterFunction) ? this._generateRasterInfo(this.rasterFunction, { signal: e3 }) : null, s9 = this._getRasterFunctionInfos();
      return Promise.all([i8, r4, s9]).then((e4) => {
        e4[1] ? this._set("rasterInfo", e4[1]) : this._set("rasterInfo", e4[0]), e4[2] && this._set("rasterFunctionInfos", e4[2]), this.internalRenderer && !this._isSupportedRenderer(this.internalRenderer) && (this._set("internalRenderer", null), i.getLogger(this).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("internalRenderer", this._configRenderer(this.renderer)), this.addHandles([l2(() => this.rasterFunction, (e5) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this._generateRasterInfo(e5).then((e6) => {
            e6 && (this.rasterInfo = e6);
          });
        })]);
        const { serviceRasterInfo: t9 } = this;
        null != t9.multidimensionalInfo && this._updateMultidimensionalDefinition(t9);
      });
    }
    _combineMosaicRuleWithTimeExtent(e3, t8) {
      const i8 = this.timeInfo, { multidimensionalInfo: r4 } = this.serviceRasterInfo;
      if (null == e3 || null == r4 || null == t8 || null == i8?.startField) return e3;
      const { startField: s9 } = i8, n10 = r4.variables.some((e4) => e4.dimensions.some((e5) => e5.name === s9)) ? s9 : "StdTime";
      if (e3 = e3.clone(), "mosaic-dataset" === this.sourceType) return e3.multidimensionalDefinition = e3.multidimensionalDefinition?.filter((e4) => e4.dimensionName !== n10), this._cleanupMultidimensionalDefinition(e3);
      e3.multidimensionalDefinition = e3.multidimensionalDefinition || [];
      const a13 = e3.multidimensionalDefinition.filter((e4) => e4.dimensionName === n10), o5 = null != t8.start ? t8.start.getTime() : null, l13 = null != t8.end ? t8.end.getTime() : null, u10 = null == o5 || null == l13 || o5 === l13, p19 = u10 ? [o5 || l13] : [[o5, l13]], m12 = this.version >= 10.8;
      if (a13.length) a13.forEach((e4) => {
        e4.dimensionName === n10 && (m12 ? (e4.dimensionName = null, e4.isSlice = false, e4.values = []) : (e4.isSlice = u10, e4.values = p19));
      });
      else if (!m12) {
        const t9 = e3.multidimensionalDefinition.filter((e4) => null != e4.variableName && null == e4.dimensionName);
        t9.length ? t9.forEach((e4) => {
          e4.dimensionName = n10, e4.isSlice = u10, e4.values = p19;
        }) : e3.multidimensionalDefinition.push(new p3({ variableName: "", dimensionName: n10, isSlice: u10, values: p19 }));
      }
      return this._cleanupMultidimensionalDefinition(e3);
    }
    _cleanupMultidimensionalDefinition(e3) {
      return null == e3 ? null : (e3.multidimensionalDefinition && (e3.multidimensionalDefinition = e3.multidimensionalDefinition.filter((e4) => !(!e4.variableName && !e4.dimensionName)), 0 === e3.multidimensionalDefinition.length && (e3.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e3.multidimensionalDefinition ? null : e3);
    }
    async _prepareForQuery(e3, t8) {
      if (!(await this._fetchCapabilities(t8?.signal)).operations.supportsQuery) throw new s("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e3 = null != e3 ? m(R, e3) : this.createQuery(), t8 = this._getRequestOptions(t8), this.raster && (t8.query = { ...t8.query, raster: this.raster }), { query: e3, requestOptions: t8 };
    }
    _isSupportedRenderer(e3) {
      const { rasterInfo: t8, rasterFunction: i8 } = this;
      return "unique-value" === e3.type && this._hasRasterFunction(i8) && 1 === t8?.bandCount && ["u8", "s8"].includes(t8.pixelType) || null != t8 && null != e3 && E(t8).includes(e3.type);
    }
    async _fetchCapabilities(e3) {
      return this.capabilities || await this._fetchServiceInfo(e3), this.capabilities;
    }
    async _fetchServiceInfo(e3) {
      let t8 = this.sourceJSON;
      if (!t8) {
        const { data: r4, ssl: s9 } = await H(ze2(this.parsedUrl), { query: this._getQueryParams(), signal: e3 });
        t8 = r4, this.sourceJSON = t8, s9 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (t8.capabilities?.toLowerCase().split(",").map((e4) => e4.trim()).indexOf("tilesonly") > -1) throw new s("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t8, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e3) {
      return e3.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e3.serviceSourceType : e3.fields?.length > 0;
    }
    _isMosaicRuleSupported(e3) {
      if (!e3) return false;
      const t8 = this._isMosaicDataset(e3), i8 = e3.currentVersion >= 10.71 && e3.hasMultidimensions && !(e3.fields?.length > 1);
      return t8 || i8;
    }
    _isVectorFieldResampleFunction(e3) {
      if (null == e3) return false;
      const { functionName: t8, functionArguments: i8 } = e3, r4 = "resample" === t8?.toLowerCase(), s9 = i8?.ResampleType || i8?.resampleType;
      return r4 && (7 === s9 || 10 === s9);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e3) {
      const t8 = this._isPicture(), { rasterInfo: i8 } = this;
      if (!t8 && !this.pixelFilter || this._isVectorDataSet()) {
        const t9 = this.mosaicRule?.multidimensionalDefinition?.[0].variableName, r4 = q2({ variableName: t9, rasterFunctionName: this.rasterFunction?.functionName, presetRenderers: this.presetRenderers });
        if (!this.bandIds && i8.bandCount >= 3) {
          const e4 = r4?.bandIds ?? D(i8);
          !e4 || 3 === i8.bandCount && 0 === e4[0] && 1 === e4[1] && 2 === e4[2] || (this.bandIds = e4);
        }
        e3 || (e3 = r4?.renderer ?? B2(i8, { bandIds: this.bandIds, variableName: this.rasterFunction ? null : t9 }));
        const s9 = te(e3.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = s9, this.symbolizer.rasterInfo = i8) : this.symbolizer = new _2({ rendererJSON: s9, rasterInfo: i8 }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e3;
    }
    _clonePixelData(e3) {
      return null == e3 ? e3 : { extent: e3.extent && e3.extent.clone(), pixelBlock: null != e3.pixelBlock ? e3.pixelBlock.clone() : null };
    }
    _getQueryParams(e3) {
      null != e3?.renderingRule && "string" != typeof e3.renderingRule && (e3.renderingRule = this._getRenderingRuleString(e3.renderingRule));
      const { raster: t8, viewId: i8 } = this;
      return { raster: t8, viewId: i8, f: "json", ...e3, ...this.customParameters };
    }
    _getRequestOptions(e3) {
      return { ...e3, query: { ...e3?.query, ...this.customParameters } };
    }
    _decodePixelBlock(e3, t8, i8) {
      return this._rasterJobHandler ? this._rasterJobHandler.decode({ data: e3, options: t8 }) : j2(e3, t8, i8);
    }
    async _getRasterFunctionInfos(e3) {
      const t8 = this.sourceJSON.rasterFunctionInfos;
      if (this.loaded) return t8;
      if (t8 && this.version >= 10.3) {
        if (1 === t8.length && "none" === t8[0].name.toLowerCase()) return t8;
        const r4 = await H(ze2(this.parsedUrl) + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e3 });
        return r4.data?.rasterFunctionInfos;
      }
      return null;
    }
    _canRequestImageElement(e3) {
      return !this.pixelFilter && (!e3 || e3.includes("png"));
    }
    async _requestArrayBuffer(e3) {
      const { imageProps: t8, requestAsImageElement: r4, returnImageBitmap: n10, signal: a13 } = e3;
      if (r4 && this._canRequestImageElement(t8.format)) {
        const r5 = `${ze2(this.parsedUrl)}/exportImage`, { data: s9 } = await H(r5, { responseType: n10 ? "blob" : "image", query: this._getQueryParams({ f: "image", ...this.refreshParameters, ...e3.imageServiceParameters }), signal: a13 });
        if (s9 instanceof Blob) {
          return { imageBitmap: await t2(s9, r5, a13), params: t8 };
        }
        return { imageOrCanvasElement: s9, params: t8 };
      }
      const o5 = this._initJobHandler(), l13 = H(ze2(this.parsedUrl) + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e3.imageServiceParameters }), signal: a13 }), u10 = (await Promise.all([l13, o5]))[0].data, p19 = t8.format || "jpgpng";
      let m12 = p19;
      if ("bsq" !== m12 && "bip" !== m12 && (m12 = P3(u10)), !m12) throw new s("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(u10)));
      const c18 = { signal: a13 }, h6 = "gif" === p19 || "bmp" === p19 || p19.includes("png") && ("png" === m12 || "jpg" === m12) ? j2(u10, { useCanvas: true, ...t8 }, c18) : this._decodePixelBlock(u10, { width: t8.width, height: t8.height, planes: null, pixelType: null, noDataValue: null, format: p19 }, c18);
      return { pixelData: { pixelBlock: await h6, extent: t8.extent }, params: t8 };
    }
    _generateRasterInfo(e3, t8) {
      return this.generateRasterInfo(e3, t8).catch(() => null);
    }
    _isValidCustomizedMosaicRule(e3) {
      return e3 && JSON.stringify(e3.toJSON()) !== JSON.stringify(this.defaultMosaicRule?.toJSON());
    }
    _updateMultidimensionalDefinition(e3) {
      if (this._isValidCustomizedMosaicRule(this.mosaicRule)) return;
      let t8 = h2(e3, { multidimensionalSubset: this.multidimensionalSubset });
      if (null != t8 && t8.length > 0) {
        this.mosaicRule = this.mosaicRule || new y2();
        const e4 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.rasterFunction && "none" !== this.rasterFunction.functionName?.toLowerCase() && t8.forEach((e5) => e5.variableName = ""), t8 = t8.filter(({ variableName: e5, dimensionName: t9 }) => e5 && "*" !== e5 || t9), !e4?.length && t8.length && (this.mosaicRule.multidimensionalDefinition = t8);
      }
    }
    _processVisibleRastersResponse(e3, i8) {
      i8 = i8 || {};
      const r4 = e3.value, { templateRRFunctionNames: s9, showNoDataRecords: n10, returnDomainValues: a13, templateFields: o5 } = i8, l13 = e3.processedValues;
      let u10 = e3.catalogItems?.features, p19 = e3.properties?.Values?.map((e4) => e4.replaceAll(/ /gi, ", ")) || [];
      const m12 = this.objectIdField || "ObjectId", c18 = "string" == typeof r4 && r4.toLowerCase().includes("nodata"), h6 = [];
      if (r4 && !u10 && (!c18 || n10)) {
        const e4 = {};
        e4[m12] = 0;
        p19 = [r4], u10 = [new d2({ geometry: this.fullExtent, attributes: e4 })], this.multidimensionalInfo && "raster-dataset" === this.sourceType && V(this.rasterFields, e4, i8.effectiveMultidimensionalDefinition);
      }
      if (!u10) return [];
      this._updateResponseFieldNames(u10, o5), c18 && !n10 && (u10 = []);
      const { itemPixelValue: d7, servicePixelValue: f11 } = t4, y9 = this.rasterFields.some((e4) => e4.name === d7);
      for (let t8 = 0; t8 < u10.length; t8++) {
        const e4 = u10[t8];
        if (null != r4) {
          const i9 = p19[t8], a14 = this.rasterFunction && l13 && l13.length > 0 && s9 && s9.length > 0 && s9.includes(this.rasterFunction.functionName) ? l13[s9.indexOf(this.rasterFunction.functionName)] : r4;
          if ("nodata" === i9.toLowerCase() && !n10) continue;
          y9 && (e4.attributes[d7] = i9), e4.attributes[f11] = a14, this._updateFeatureWithMagDirValues(e4, i9);
          const o6 = this.fields && this.fields.length > 0;
          let u11 = this.rasterFunction && null != this.serviceRasterInfo.attributeTable ? o6 ? i9 : r4 : a14;
          this.rasterFunction || (u11 = o6 ? i9 : r4), this._updateFeatureWithRasterAttributeTableValues(e4, u11);
        }
        if (e4.sourceLayer = e4.layer = this, a13 && this._updateFeatureWithDomainValues(e4), s9 && l13 && s9.length === l13.length) for (let t9 = 0; t9 < s9.length; t9++) {
          const i9 = `${t4.servicePixelValue}.${s9[t9]}`;
          e4.attributes[i9] = l13[t9];
        }
        h6.push(u10[t8]);
      }
      return h6;
    }
    _processMultidimensionalIntersection(e3, t8, i8) {
      const { multidimensionalSubset: r4 } = this;
      if (!r4) return { isOutSide: false, timeExtent: t8, mosaicRule: i8 = this._combineMosaicRuleWithTimeExtent(i8, t8) };
      if (r4) {
        const { isOutside: i9, intersection: s9 } = m6(r4, { geometry: e3, timeExtent: t8 });
        if (i9) return { isOutSide: true, timeExtent: null, mosaicRule: null };
        null != s9?.timeExtent && (t8 = s9.timeExtent);
      }
      if (i8 = this._combineMosaicRuleWithTimeExtent(i8, t8), i8?.multidimensionalDefinition) {
        const { isOutside: e4 } = m6(r4, { multidimensionalDefinition: i8.multidimensionalDefinition });
        if (e4) return { isOutSide: true, timeExtent: null, mosaicRule: null };
      }
      return { isOutSide: false, timeExtent: t8, mosaicRule: i8 };
    }
    _updateFeatureWithRasterAttributeTableValues(e3, t8) {
      const i8 = this.rasterInfo.attributeTable || this.serviceRasterInfo.attributeTable;
      if (null == i8) return;
      const { features: r4, fields: s9 } = i8, n10 = s9.map((e4) => e4.name).find((e4) => "value" === e4.toLowerCase());
      if (!n10) return;
      const a13 = r4.filter((e4) => e4.attributes[n10] === (null != t8 ? parseInt(t8, 10) : null));
      a13 && a13[0] && s9.forEach((t9) => {
        const i9 = n3 + t9.name;
        e3.attributes[i9] = a13[0].attributes[t9.name];
      });
    }
    _updateFeatureWithMagDirValues(e3, t8) {
      if (!this._isVectorDataSet()) return;
      const i8 = t8.split(/,\s*/).map((e4) => parseFloat(e4)), r4 = i8.map((e4) => [e4]), s9 = i8.map((e4) => ({ minValue: e4, maxValue: e4, noDataValue: null })), n10 = new c4({ height: 1, width: 1, pixelType: "f32", pixels: r4, statistics: s9 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n10, extent: new z(0, 0, 0, 0, this.spatialReference) });
      const a13 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n10.pixels[0][0], n10.pixels[1][0]] : l7([n10.pixels[0][0], n10.pixels[1][0]]);
      e3.attributes[t4.magnitude] = a13[0], e3.attributes[t4.direction] = a13[1];
    }
    _updateFeatureWithDomainValues(e3) {
      const t8 = this.fields && this.fields.filter((e4) => e4.domain && "coded-value" === e4.domain.type);
      null != t8 && t8.forEach((t9) => {
        const i8 = e3.attributes[t9.name];
        if (null != i8) {
          const r4 = t9.domain.codedValues.find((e4) => e4.code === i8);
          r4 && (e3.attributes[t9.name] = r4.name);
        }
      });
    }
    _updateResponseFieldNames(e3, t8) {
      if (!t8 || t8.length < 1) return;
      const i8 = this.fieldsIndex;
      null != i8 && e3.forEach((e4) => {
        if (e4?.attributes) for (const r4 of t8) {
          const t9 = i8.get(r4)?.name;
          t9 && t9 !== r4 && (e4.attributes[r4] = e4.attributes[t9], delete e4.attributes[t9]);
        }
      });
    }
    _getRenderingRuleString(e3) {
      if (e3) {
        let t8 = e3.toJSON();
        return t8 = t8.rasterFunctionDefinition ?? t8, (t8.thumbnail || t8.thumbnailEx) && (t8.thumbnail = t8.thumbnailEx = null), JSON.stringify(t8);
      }
      return null;
    }
    _hasRasterFunction(e3) {
      return null != e3?.functionName && "none" !== e3.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e3, t8) {
      if (!e3 || e3.length < 1) return;
      if ("Raw" === e3) return e3.replace("Raw", "None");
      const i8 = e3.toLowerCase().replaceAll(/ /gi, "_");
      return t8.has(i8) ? t8.get(i8) : e3;
    }
    _isRFTJson(e3) {
      return e3?.name && e3.arguments && e3.function && e3.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _applyMosaicAndRenderingRules(e3) {
      const { raster: t8, mosaicRule: i8, rasterFunction: r4 } = this;
      r4 && null == e3.rasterFunction && (e3.rasterFunction = r4), i8 && null == e3.mosaicRule && (e3.mosaicRule = i8), t8 && null == e3.raster && (e3.raster = t8);
    }
    async _updateCurrentRasterInfo(e3) {
      if (this.renderer || this.symbolizer) {
        const t8 = await this._generateRasterInfo(this.rasterFunction, { signal: e3 });
        t8 && (this.rasterInfo = t8);
      }
    }
    _applyMosaicRule(e3) {
      const { raster: t8, mosaicRule: i8 } = this;
      i8 && null == e3.mosaicRule && (e3.mosaicRule = i8), t8 && null == e3.raster && (e3.raster = t8);
    }
    _readCapabilities(e3) {
      const t8 = e3.capabilities ? e3.capabilities.toLowerCase().split(",").map((e4) => e4.trim()) : ["image", "catalog"], { currentVersion: i8, maxRecordCount: r4 } = e3, s9 = t8.includes("image"), n10 = "esriImageServiceDataTypeElevation" === e3.serviceDataType, a13 = !(!e3.spatialReference && !e3.extent?.spatialReference), o5 = t8.includes("edit"), l13 = t8.includes("mensuration") && a13, u10 = null == e3.mensurationCapabilities ? [] : e3.mensurationCapabilities.toLowerCase().split(",").map((e4) => e4.trim()), p19 = l13 && u10.includes("basic"), m12 = this._isMosaicDataset(e3) && t8.includes("catalog"), c18 = t8.includes("download"), h6 = i8 >= 10.7 && n10 || i8 >= 11.4 && (n10 || l13 && u10.includes("3d")), d7 = m12 && e3.fields && e3.fields.length > 0, f11 = d7 && e3.supportsAdvancedQueries ? e3.advancedQueryCapabilities : void 0;
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: s9, supportsExportImage: s9, supportsIdentify: s9, supportsImageToMap: i8 >= 11.2 && m12, supportsImageToMapMultiray: i8 >= 11.2 && m12, supportsMapToImage: i8 >= 11.2 && m12, supportsFindImages: i8 >= 11.2 && m12, supportsGetImageUrl: i8 >= 11.3 && c18, supportsMeasure: l13, supportsMeasureFromImage: i8 >= 11.2, supportsDownload: c18, supportsQuery: d7, supportsGetSamples: i8 >= 10.2 && s9, supportsProject: i8 >= 10.3 && s9, supportsComputeStatisticsHistograms: i8 >= 10.4 && s9, supportsQueryBoundary: i8 >= 10.6 && s9, supportsCalculateVolume: h6, supportsComputePixelLocation: i8 >= 10.7 && m12, supportsComputeAngles: i8 >= 10.91, supportsQueryGPSInfo: i8 >= 11.2 && m12, supportsAdd: o5, supportsDelete: o5, supportsEditing: o5, supportsUpdate: o5, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryBins: false, supportsQueryTopFeatures: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: r4, maxRecordCountFactor: void 0, maxUniqueIDCount: void 0, supportsStatistics: !!f11?.supportsStatistics, supportsOrderBy: !!f11?.supportsOrderBy, supportsDistinct: !!f11?.supportsDistinct, supportsPagination: !!f11?.supportsPagination, supportsPaginationOnAggregatedQueries: !!f11?.supportsPaginationOnAggregatedQueries, supportsStandardizedQueriesOnly: !!f11?.useStandardizedQueries, supportsPercentileStatistics: !!f11?.supportsPercentileStatistics, supportsCentroid: !!f11?.supportsReturningGeometryCentroid, supportsCurrentUser: false, supportsDistance: !!f11?.supportsQueryWithDistance, supportsExtent: !!f11?.supportsReturningQueryExtent, supportsGeometryProperties: !!f11?.supportsReturningGeometryProperties, supportsHavingClause: !!f11?.supportsHavingClause, supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsReturnMesh: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: f11?.supportsSqlExpression ?? !!f11, supportsTopFeaturesQuery: false, supportsQueryByAnonymous: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!f11?.supportsDefaultSR, supportsFullTextSearch: false, supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0, supportsTrueCurve: false }, mensuration: { supportsDistanceAndAngle: p19, supportsAreaAndPerimeter: p19, supportsPointOrCentroid: p19, supportsHeightFromBaseAndTop: l13 && u10.includes("base-top height"), supportsHeightFromBaseAndTopShadow: l13 && u10.includes("base-top shadow height"), supportsHeightFromTopAndTopShadow: l13 && u10.includes("top-top shadow height"), supports3D: l13 && u10.includes("3d") } };
    }
  };
  function ze2(e3) {
    return e3?.path ?? "";
  }
  return r([m2({ clonable: false })], h5.prototype, "_functionRasterInfos", void 0), r([m2({ readOnly: true })], h5.prototype, "_serviceSupportsMosaicRule", void 0), r([o("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], h5.prototype, "readServiceSupportsMosaicRule", null), r([m2({ readOnly: true })], h5.prototype, "_rasterFunctionNamesIndex", null), r([m2()], h5.prototype, "adjustAspectRatio", void 0), r([m2({ type: [x], json: { write: true } })], h5.prototype, "bandIds", void 0), r([o("bandIds")], h5.prototype, "readBandIds", null), r([m2({ readOnly: true, json: { read: false } })], h5.prototype, "capabilities", void 0), r([o("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], h5.prototype, "readCapabilities", null), r([m2({ type: Number })], h5.prototype, "compressionQuality", void 0), r([r2("compressionQuality")], h5.prototype, "writeCompressionQuality", null), r([m2({ type: Number })], h5.prototype, "compressionTolerance", void 0), r([r2("compressionTolerance")], h5.prototype, "writeCompressionTolerance", null), r([m2({ json: { read: { source: "copyrightText" } } })], h5.prototype, "copyright", void 0), r([m2({ readOnly: true, dependsOn: ["_serviceSupportsMosaicRule"] })], h5.prototype, "defaultMosaicRule", void 0), r([o("defaultMosaicRule", ["defaultMosaicMethod"])], h5.prototype, "readDefaultMosaicRule", null), r([m2({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], h5.prototype, "definitionExpression", void 0), r([m2({ readOnly: true, constructOnly: true })], h5.prototype, "exportImageServiceParameters", void 0), r([m2()], h5.prototype, "rasterInfo", void 0), r([m2({ readOnly: true, type: [m3] })], h5.prototype, "fields", void 0), r([m2({ readOnly: true })], h5.prototype, "fieldsIndex", null), r([m2({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff", "bip", "bsq"], json: { write: true } })], h5.prototype, "format", null), r([o("service", "format", ["serviceDataType"])], h5.prototype, "readFormat", null), r([m2({ type: z })], h5.prototype, "fullExtent", void 0), r([m2({ readOnly: true })], h5.prototype, "hasMultidimensions", void 0), r([m2({ json: { read: { source: "maxImageHeight" } } })], h5.prototype, "imageMaxHeight", void 0), r([m2({ json: { read: { source: "maxImageWidth" } } })], h5.prototype, "imageMaxWidth", void 0), r([m2({ type: String, json: { type: a6.jsonValues, read: a6.read, write: a6.write } })], h5.prototype, "interpolation", void 0), r([m2()], h5.prototype, "minScale", void 0), r([o("service", "minScale")], h5.prototype, "readMinScale", null), r([m2()], h5.prototype, "maxScale", void 0), r([o("service", "maxScale")], h5.prototype, "readMaxScale", null), r([m2({ type: y2 })], h5.prototype, "mosaicRule", null), r([o("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], h5.prototype, "readMosaicRule", null), r([r2("mosaicRule")], h5.prototype, "writeMosaicRule", null), r([m2()], h5.prototype, "multidimensionalInfo", void 0), r([m2({ type: u4, json: { write: true } })], h5.prototype, "multidimensionalSubset", void 0), r([m2({ json: { type: x } })], h5.prototype, "noData", void 0), r([r2("noData")], h5.prototype, "writeNoData", null), r([m2({ type: String, json: { type: i4.jsonValues, read: i4.read, write: i4.write } })], h5.prototype, "noDataInterpretation", void 0), r([m2({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], h5.prototype, "objectIdField", void 0), r([o("objectIdField")], h5.prototype, "readObjectIdField", null), r([m2({ readOnly: true })], h5.prototype, "geometryType", void 0), r([m2({})], h5.prototype, "typeIdField", void 0), r([m2({})], h5.prototype, "types", void 0), r([m2({ readOnly: true })], h5.prototype, "parsedUrl", null), r([m2({ type: Function })], h5.prototype, "pixelFilter", void 0), r([m2()], h5.prototype, "raster", void 0), r([m2({ readOnly: true })], h5.prototype, "sourceType", void 0), r([o("sourceType", ["serviceSourceType", "fields"])], h5.prototype, "readSourceType", null), r([m2()], h5.prototype, "viewId", void 0), r([m2()], h5.prototype, "renderer", null), r([m2({ types: l8, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: p5, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e3) => ({ enabled: e3 && "vector-field" !== e3.type && "flow" !== e3.type }) } } } } })], h5.prototype, "internalRenderer", null), r([o("internalRenderer")], h5.prototype, "readRenderer", null), r([r2("internalRenderer")], h5.prototype, "writeRenderer", null), r([m2({ clonable: false })], h5.prototype, "symbolizer", void 0), r([m2(w)], h5.prototype, "opacity", void 0), r([m2({ readOnly: true })], h5.prototype, "rasterFields", null), r([m2({ constructOnly: true })], h5.prototype, "rasterFunctionInfos", void 0), r([m2({ type: N, json: { name: "renderingRule" } })], h5.prototype, "rasterFunction", null), r([o("rasterFunction", ["renderingRule", "rasterFunctionInfos"])], h5.prototype, "readRasterFunction", null), r([m2({ readOnly: true })], h5.prototype, "serviceDataType", void 0), r([m2({ readOnly: true, type: f })], h5.prototype, "spatialReference", void 0), r([o("spatialReference", ["spatialReference", "extent"])], h5.prototype, "readSpatialReference", null), r([m2({ type: n.apiValues, json: { read: n.read, type: n.jsonValues } })], h5.prototype, "pixelType", void 0), r([r2("pixelType")], h5.prototype, "writePixelType", null), r([m2({ constructOnly: true, type: m5 })], h5.prototype, "serviceRasterInfo", void 0), r([m2()], h5.prototype, "sourceJSON", void 0), r([m2(y)], h5.prototype, "url", void 0), r([m2({ readOnly: true })], h5.prototype, "version", void 0), r([o("version", ["currentVersion", "fields", "timeInfo"])], h5.prototype, "readVersion", null), h5 = r([a3("esri.layers.mixins.ArcGISImageService")], h5), h5;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var C2 = class extends p(c2(t(b(j(o4(ze(i5(f3(e(l5(S(a5.ClonableMixin(h))))))))))))) {
  constructor(...e3) {
    super(...e3), this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery", this._debouncedSaveOperations = k(async (e4, r4, t8) => {
      const { save: o5, saveAs: s9 } = await import("./imageryUtils-JYE6ZWUM.js");
      switch (e4) {
        case A.SAVE:
          return o5(this, r4);
        case A.SAVE_AS:
          return s9(this, t8, r4);
      }
    });
  }
  normalizeCtorArgs(e3, r4) {
    return "string" == typeof e3 ? { url: e3, ...r4 } : e3;
  }
  load(e3) {
    const r4 = null != e3 ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e3).catch(a4).then(() => this._fetchService(r4))), Promise.resolve(this);
  }
  get legendEnabled() {
    return !this._isPreviewLayer && (this._get("legendEnabled") ?? true);
  }
  set legendEnabled(e3) {
    this._set("legendEnabled", e3);
  }
  get listMode() {
    return this._isPreviewLayer ? "hide" : this._get("listMode");
  }
  set listMode(e3) {
    this._set("listMode", e3);
  }
  writeOperationalLayerType(e3, r4, t8) {
    const o5 = "vector-field" === this.renderer?.type;
    r4[t8] = o5 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get _isPreviewLayer() {
    return !(!this.raster || !this.url?.toLowerCase().includes("/rasterrendering/imageserver"));
  }
  createPopupTemplate(e3) {
    const { rasterFields: r4 } = this, t8 = /* @__PURE__ */ new Set(), o5 = t4.itemPixelValue.toLowerCase(), s9 = "raster-dataset" === this.sourceType, i8 = a7.toLowerCase(), a13 = `${t4.servicePixelValue.toLowerCase()}.`;
    for (const l13 of r4) {
      const e4 = l13.name.toLowerCase();
      e4 === o5 || e4.startsWith(a13) || s9 && e4.startsWith(i8) || t8.add(l13.name);
    }
    const p19 = p2({ fields: r4, title: this.title }, { ...e3, visibleFieldNames: t8 }), { rasterInfo: n10 } = this;
    return p19?.fieldInfos && n10 && b2(p19.fieldInfos, n10), p19;
  }
  queryFeatures(e3, r4) {
    return this.queryRasters(e3, r4).then((e4) => {
      if (e4?.features) for (const r5 of e4.features) r5.layer = r5.sourceLayer = this;
      return e4;
    });
  }
  queryFeatureCount(e3, r4) {
    return this.queryRasterCount(e3, r4);
  }
  redraw() {
    this.emit("redraw");
  }
  async save(e3) {
    return this._debouncedSaveOperations(A.SAVE, e3);
  }
  async saveAs(e3, r4) {
    return this._debouncedSaveOperations(A.SAVE_AS, r4, e3);
  }
  serviceSupportsSpatialReference(e3) {
    return t3(this, e3);
  }
  write(e3, r4) {
    if (!this._isPreviewLayer) return super.write(e3, r4);
    if (r4?.messages) {
      const e4 = `${r4.origin}/${r4.layerContainerType || "operational-layers"}`;
      r4.messages.push(new s("layer:unsupported", `Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e4}'`, { layer: this }));
    }
    return null;
  }
};
r([m2(d)], C2.prototype, "legendEnabled", null), r([m2({ type: ["show", "hide"] })], C2.prototype, "listMode", null), r([m2({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], C2.prototype, "isReference", void 0), r([m2({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], C2.prototype, "operationalLayerType", void 0), r([r2("web-map", "operationalLayerType")], C2.prototype, "writeOperationalLayerType", null), r([m2(l4)], C2.prototype, "popupEnabled", void 0), r([m2({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], C2.prototype, "popupTemplate", void 0), r([m2({ readOnly: true })], C2.prototype, "defaultPopupTemplate", null), r([m2({ readOnly: true, json: { read: false } })], C2.prototype, "type", void 0), r([m2({ readOnly: true })], C2.prototype, "_isPreviewLayer", null), C2 = r([a3("esri.layers.ImageryLayer")], C2);
var E3 = C2;
export {
  E3 as default
};
//# sourceMappingURL=ImageryLayer-SAK6TJA2.js.map
