import {
  m as m6,
  n as n3
} from "./chunk-5726E5A7.js";
import {
  $ as $2,
  X,
  e as e3,
  i as i4,
  m as m5,
  n as n2,
  o as o3,
  t as t5,
  u as u2
} from "./chunk-QK4VRPQW.js";
import "./chunk-23ZUIA4B.js";
import {
  T as T2,
  w
} from "./chunk-MEHT6AJM.js";
import "./chunk-N6VYJNA5.js";
import "./chunk-Z5EDZREM.js";
import {
  c as c4,
  f as f3,
  o as o2
} from "./chunk-UVPBJRCN.js";
import {
  N,
  i2 as i3
} from "./chunk-TZWHWOLK.js";
import {
  $,
  N as N2,
  b as b2,
  c as c3,
  d as d2,
  o,
  p as p3,
  p2 as p4,
  t as t2,
  v
} from "./chunk-623AYJP2.js";
import {
  C2 as C,
  G,
  H,
  N as N3,
  P2 as P,
  U,
  W,
  e as e2,
  g as g2,
  h as h2,
  k as k3,
  l as l4,
  m2 as m4,
  p as p5,
  r as r2,
  r2 as r3,
  t as t3
} from "./chunk-U5MPARPW.js";
import {
  B,
  I as I2,
  R,
  c as c2
} from "./chunk-NXHGFG67.js";
import {
  r as r4,
  t as t4
} from "./chunk-3NJEC7QC.js";
import {
  T
} from "./chunk-L3WYZ6BH.js";
import "./chunk-TUSII7EA.js";
import "./chunk-WQVEQTKW.js";
import "./chunk-56LGCTGZ.js";
import "./chunk-RD652CDC.js";
import {
  i as i2
} from "./chunk-PVI3IOCA.js";
import "./chunk-OFHPFWHF.js";
import "./chunk-MZJEBIXX.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-76QJRCNC.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-NO2XQDLB.js";
import "./chunk-LBC3MAJX.js";
import {
  j as j2
} from "./chunk-3ZORAHSR.js";
import "./chunk-SZN55B2M.js";
import {
  l as l3
} from "./chunk-H7SHPX7W.js";
import {
  c
} from "./chunk-6MFKAT6L.js";
import "./chunk-NOWX6W7R.js";
import {
  p as p2
} from "./chunk-OQ76WPLD.js";
import {
  e
} from "./chunk-KSVHYEPS.js";
import {
  g
} from "./chunk-B6C7UPBZ.js";
import {
  f as f2
} from "./chunk-IUQBXXYO.js";
import {
  A
} from "./chunk-MULCOUFY.js";
import {
  j
} from "./chunk-VGIEH4HM.js";
import {
  p
} from "./chunk-XLF2NMGX.js";
import {
  t
} from "./chunk-X5GD6LFD.js";
import {
  b2 as b,
  d
} from "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import "./chunk-UGXCZZ7N.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import {
  m as m3
} from "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import {
  h
} from "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import {
  q
} from "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import {
  l as l2
} from "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import {
  a as a3
} from "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  l
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import {
  k as k2
} from "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import {
  s as s2
} from "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  m as m2
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import {
  m
} from "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import {
  I
} from "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  a as a2,
  k,
  n,
  u3 as u,
  y
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  L,
  has
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/covJSONParser.js
function i5(e4) {
  return ["x", "e", "east", "long", "longitude"].includes(e4.toLowerCase());
}
function r5(e4) {
  return ["y", "n", "west", "lat", "latitude"].includes(e4.toLowerCase());
}
function o4(e4) {
  const { axes: l5 } = e4.domain, s3 = Object.keys(l5), a4 = [], o5 = [];
  let u6 = -1, m10 = -1, c7 = [];
  for (let t7 = 0; t7 < s3.length; t7++) {
    const e5 = s3[t7];
    i5(e5) ? u6 = t7 : r5(e5) && (m10 = t7);
    const n5 = l5[e5], d7 = [];
    if ("values" in n5) {
      n5.values.forEach((e7) => d7.push("string" == typeof e7 ? new Date(e7).getTime() : e7));
      const e6 = d7[1] - d7[0];
      a4.push([d7[0] - 0.5 * e6, d7[d7.length - 1] + 0.5 * e6]), o5.push(e6);
    } else {
      const { start: e6, stop: t8, num: l6 } = n5, s4 = (t8 - e6) / (l6 - 1);
      a4.push([e6 - 0.5 * s4, t8 + 0.5 * s4]), o5.push(s4);
      for (let n6 = 0; n6 < l6; n6++) d7.push(e6 + s4 * n6);
    }
    c7.push({ name: e5, values: d7, extent: [d7[0], d7[d7.length - 1]] });
  }
  u6 > -1 && -1 === m10 ? m10 = 0 === u6 ? 1 : 0 : m10 > -1 && -1 === u6 ? u6 = 0 === m10 ? 1 : 0 : -1 === m10 && -1 === u6 && (u6 = 0, m10 = 1), c7 = c7.filter((e5, t7) => !(t7 === u6 || t7 === m10));
  const { referencing: d6 } = e4.domain, f6 = d6.find((e5) => e5.coordinates.includes(s3[u6])).system.id, p8 = f6?.slice(f6.lastIndexOf("/") + 1), h5 = null == p8 || "CRS84" === p8 ? 4326 : Number(p8), g5 = new f({ wkid: h5 }), [b5, y3] = a4[u6], [x2, j3] = a4[m10], v4 = new z({ xmin: b5, xmax: y3, ymin: x2, ymax: j3, spatialReference: g5 });
  return { width: Math.round(v4.width / o5[u6]), height: Math.round(v4.height / o5[m10]), extent: v4, dimensions: c7 };
}
function u3(e4) {
  const t7 = s2()?.language;
  return t7 ? e4[t7] ?? Object.values(e4)[0] : Object.values(e4)[0];
}
function m7() {
  return Math.round(255 * Math.random());
}
function c5(t7) {
  const n5 = {}, { parameters: l5 } = t7;
  if (!l5) return n5;
  for (const [s3, a4] of Object.entries(l5)) {
    const { type: t8, description: l6, unit: i6, categoryEncoding: r7, observedProperty: o5 } = a4;
    if ("Parameter" === t8 && (n5[s3] = {}, l6 && (n5[s3].description = u3(l6)), i6 && (n5[s3].unit = i6.label ? u3(i6.label) : null, n5[s3].symbol = i6.symbol?.value), r7)) {
      const t9 = Object.entries(r7).map((e4, t10) => ({ OID: t10, Value: Number(e4[1]), ClassName: e4[0].slice(e4[0].lastIndexOf("/") + 1), Count: 1 }));
      let l7 = false;
      o5?.categories?.length && (o5.categories.forEach((n6) => {
        if (!n6.id) return;
        const s4 = n6.id.slice(n6.id.lastIndexOf("/") + 1), a6 = t9.find((e4) => e4.ClassName === s4);
        if (!a6) return;
        const i7 = n6.label ? u3(n6.label) : null;
        if (a6.Label = i7, n6.preferredColor) {
          const t10 = l2.fromHex(n6.preferredColor);
          t10 && (l7 = true, a6.Red = t10.r, a6.Green = t10.g, a6.Blue = t10.b);
        }
      }), l7 && t9.forEach((e4) => {
        null == e4.Red && (e4.Red = m7(), e4.Green = m7(), e4.Blue = m7());
      }));
      const a5 = { objectIdFieldName: "", fields: [{ name: "OID", type: "esriFieldTypeOID", alias: "OID", domain: null }, { name: "Value", type: "esriFieldTypeInteger", alias: "Value", domain: null }, { name: "Count", type: "esriFieldTypeDouble", alias: "Count", domain: null }, { name: "ClassName", type: "esriFieldTypeString", alias: "ClassName", domain: null, length: 50 }, { name: "Label", type: "esriFieldTypeString", alias: "Label", domain: null, length: 50 }], features: t9.map((e4) => ({ attributes: e4 })) };
      l7 && a5.fields.push({ name: "Red", type: "esriFieldTypeInteger", alias: "Red", domain: null }, { name: "Green", type: "esriFieldTypeInteger", alias: "Green", domain: null }, { name: "Blue", type: "esriFieldTypeInteger", alias: "Blue", domain: null }), n5[s3].attributeTable = a5;
    }
  }
  return n5;
}
function d3(e4) {
  let t7 = Number.MAX_VALUE, n5 = -Number.MAX_VALUE;
  for (let l5 = 0; l5 < e4.length; l5++) {
    const s3 = e4[l5];
    null != s3 && (s3 < t7 && (t7 = s3), s3 > n5 && (n5 = s3));
  }
  return i2(t7, n5);
}
function f4(e4, t7, n5) {
  const l5 = e4.map((e5, n6) => ({ name: e5, count: t7[n6] })).sort((e5, t8) => e5.name > t8.name ? -1 : 1), s3 = (a4 = 1, (e5) => a4 *= e5.count);
  var a4;
  const i6 = [...l5.slice(1), { name: "", count: 1 }].reverse().map(s3).reverse();
  let r7 = 0;
  for (let o5 = e4.length - 1; o5 >= 0; o5--) {
    r7 += i6[l5.findIndex(({ name: t8 }) => t8 === e4[o5])] * (n5 % t7[o5]), n5 = Math.floor(n5 / t7[o5]);
  }
  return r7;
}
function p6(e4) {
  const { width: t7, height: n5, extent: l5, dimensions: a4 } = o4(e4), { ranges: i6 } = e4, r7 = Object.keys(i6).sort((e5, t8) => e5 < t8 ? -1 : 1), u6 = [];
  for (let s3 = 0; s3 < r7.length; s3++) {
    const e5 = r7[s3];
    a4?.length && u6.push({ name: e5, dimensions: a4 });
  }
  const m10 = c5(e4);
  u6.forEach((e5) => m10[e5.name] && Object.assign(e5, m10[e5.name]));
  const p8 = u6.length ? { variables: u6 } : void 0, h5 = [];
  for (let o5 = 0; o5 < r7.length; o5++) {
    const e5 = r7[o5], { values: l6, dataType: u7, axisNames: m11, shape: c7 } = i6[e5], p9 = c7.length > 2 ? o5 * c7.slice(0, -2).reduce((e6, t8) => e6 * t8) : 0, g6 = m11.slice(0, -2), b5 = c7.slice(0, -2), y3 = "float" === u7 ? "f32" : d3(l6), x2 = t7 * n5, j3 = l6.length / x2;
    for (let i7 = 0; i7 < j3; i7++) {
      const e6 = c2.createEmptyBand(y3, x2), r8 = new Uint8Array(x2).fill(255);
      let u8 = false;
      const m12 = i7 * x2;
      for (let t8 = 0; t8 < x2; t8++) {
        const n6 = l6[m12 + t8];
        null == n6 ? (r8[t8] = 0, u8 = true) : e6[t8] = n6;
      }
      if (0 === o5 || a4?.length) {
        const l7 = new c2({ width: t7, height: n5, mask: u8 ? r8 : null, pixels: [e6], pixelType: y3 });
        if (l7.updateStatistics(), a4?.length) {
          h5[f4(g6, b5, i7) + p9] = l7;
        } else h5.push(l7);
      } else {
        const t8 = h5[i7];
        t8.pixels.push(e6), u8 ? t8.mask && (t8.mask = c2.combineBandMasks([t8.mask, r8])) : t8.mask = u8 ? r8 : null;
      }
    }
  }
  const g5 = Object.values(m10).find((e5) => e5.attributeTable)?.attributeTable;
  return { extent: l5, pixelBlocks: h5, multidimensionalInfo: p8, attributeTable: g5, bandNames: p8 ? void 0 : r7 };
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var f5 = class extends $2 {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY", this.source = null;
  }
  get url() {
    return "";
  }
  fetchRawTile(t7, e4, s3, i6 = {}) {
    if (!this._pixelBlockTiles) {
      const { rasterInfo: r8 } = this, [o5, a4] = r8.storageInfo.tileInfo.size, { sliceId: l5 } = i6, { pixelBlocks: n5 } = this.source, m10 = { pixelBlock: null == l5 ? n5[0] : n5[l5], useBilinear: "thematic" !== r8.dataType, tileSize: { width: o5, height: a4 }, level: t7, row: e4, col: s3 }, c7 = this.rasterJobHandler ? this.rasterJobHandler.clipTile(m10, i6) : R(m10);
      return Promise.resolve(c7);
    }
    const r7 = this._pixelBlockTiles.get(`${t7}/${e4}/${s3}`);
    return Promise.resolve(r7);
  }
  async _open(t7) {
    const e4 = this.source, { pixelBlocks: s3, attributeTable: i6, statistics: r7, histograms: l5, name: m10, nativeExtent: c7, transform: p8 } = e4, u6 = s3[0], { width: h5, height: d6, pixelType: f6 } = u6, g5 = e4.extent ?? new z({ xmin: -0.5, ymin: 0.5, xmax: h5 - 0.5, ymax: d6 - 0.5, spatialReference: new f({ wkid: 3857 }) }), x2 = e4.isPseudoSpatialReference ?? !e4.extent, y3 = { x: g5.width / h5, y: g5.height / d6 }, b5 = { ...e4.keyProperties };
    i6 && (b5.DataType = "Thematic");
    const v4 = new m4({ width: h5, height: d6, pixelType: f6, extent: g5, nativeExtent: c7, attributeTable: i6, transform: p8, pixelSize: y3, spatialReference: g5.spatialReference, bandCount: u6.pixels.length, keyProperties: b5, multidimensionalInfo: e4.multidimensionalInfo, statistics: r7, isPseudoSpatialReference: x2, histograms: l5 });
    this.ioConfig.skipMapInfo && this.updateImageSpaceRasterInfo(v4), this.createRemoteDatasetStorageInfo(v4, 512, 512), this._set("rasterInfo", v4), this.updateTileInfo(), v4.multidimensionalInfo ? await this._buildMDimStats(e4.pixelBlocks, v4.multidimensionalInfo) : await this._buildInMemoryRaster(u6, { width: 512, height: 512 }, t7), v4.multidimensionalInfo || (this.source = null), this.datasetName = m10;
  }
  async _buildInMemoryRaster(t7, i6, r7) {
    const { rasterInfo: o5 } = this, a4 = o5.storageInfo.maximumPyramidLevel ?? 0, l5 = "thematic" !== o5.dataType, n5 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t7, tileSize: i6, maximumPyramidLevel: a4, useBilinear: l5 }, r7) : Promise.resolve(I2(t7, i6, a4, l5)), m10 = null != o5.statistics, c7 = null != o5.histograms, p8 = this.ioConfig.skipStatistics || m10 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t7 }, r7) : Promise.resolve(p5(t7)), d6 = await y([n5, p8]);
    if (!d6[0].value && d6[1].value) throw new s("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = d6[0].value, m10 || (o5.statistics = d6[1].value?.statistics), c7 || (o5.histograms = d6[1].value?.histograms);
  }
  async _buildMDimStats(t7, e4, s3) {
    for (let i6 = 0; i6 < e4.variables.length; i6++) {
      const r7 = e4.variables[i6];
      if (r7.statistics) continue;
      const o5 = r7.dimensions.map((t8) => new p3({ variableName: r7.name, dimensionName: t8.name, values: [t8.values?.[0] ?? t8.extent?.[0]], isSlice: true })), a4 = N2(o5, e4), n5 = null == a4 ? null : t7[a4];
      if (null == n5) continue;
      const m10 = this.rasterJobHandler ? await this.rasterJobHandler.computeStatisticsHistograms({ pixelBlock: n5 }, s3) : h2(n5);
      r7.statistics = m10.statistics, r7.histograms || (r7.histograms = m10.histograms);
    }
  }
};
r([m2({ type: String, json: { write: true } })], f5.prototype, "datasetFormat", void 0), r([m2()], f5.prototype, "source", void 0), r([m2()], f5.prototype, "url", null), f5 = r([a("esri.layers.support.rasterDatasets.InMemoryRaster")], f5);
var g3 = f5;

// node_modules/@arcgis/core/layers/support/rasterDatasets/CovJSONRaster.js
var m8 = class extends $2 {
  constructor() {
    super(...arguments), this.datasetFormat = "CovJSON";
  }
  fetchRawTile(e4, t7, r7, s3 = {}) {
    return this._inMemoryRaster.fetchRawTile(e4, t7, r7, s3);
  }
  async _open(e4) {
    const { extent: t7, pixelBlocks: r7, multidimensionalInfo: s3, attributeTable: a4, bandNames: o5 } = await this._fetchData(e4), { statistics: i6, histograms: n5 } = h2(r7[0]), m10 = o5?.map((e5) => ({ BandName: e5 })), h5 = { DataType: a4 ? "Thematic" : s3 ? "Scientific" : "Generic", BandProperties: m10 }, d6 = new g3({ source: { extent: t7, pixelBlocks: r7, attributeTable: a4 ? g.fromJSON(a4) : null, multidimensionalInfo: s3, statistics: i6, histograms: n5, keyProperties: h5, isPseudoSpatialReference: false } });
    await d6.open(), this._inMemoryRaster = d6;
    const u6 = this.source ? "" : this.url.slice(this.url.lastIndexOf("/") + 1);
    this._set("datasetName", u6.slice(0, u6.indexOf("."))), this._set("rasterInfo", d6.rasterInfo);
  }
  async _fetchData(e4) {
    const r7 = this.source ?? (await this.request(this.url, { signal: e4?.signal })).data, s3 = "imagery-tile-layer:open-coverage-json";
    if ("coverage" !== r7.type?.toLowerCase() || "grid" !== r7.domain?.domainType?.toLowerCase()) throw new s(s3, "Only coverage with Grid domain type is supported");
    if (!r7.ranges) throw new s(s3, "Missing ranges in the grid coverage data");
    if (!r7.domain.referencing?.length) throw new s(s3, "Missing domain referencing in the grid coverage data");
    const a4 = Object.values(r7.ranges);
    for (let n5 = 0; n5 < a4.length; n5++) {
      const { axisNames: e5, shape: r8, type: c7, values: l5 } = a4[n5];
      if (!("ndarray" === c7.toLowerCase() && l5?.length && e5?.length && r8?.length)) throw new s(s3, "Only ranges with valid NdArray, axisNames, shape, and inline values are supported");
      if (!(i5(e5[e5.length - 1]) && r5(e5[e5.length - 2]))) throw new s(s3, "Only row-major ordered pixel values are supported. X axis must be the last axis.");
    }
    return p6(r7);
  }
};
r([m2({ type: String, json: { write: true } })], m8.prototype, "datasetFormat", void 0), r([m2({ constructOnly: true })], m8.prototype, "source", void 0), m8 = r([a("esri.layers.support.rasterDatasets.CovJSONRaster")], m8);
var h3 = m8;

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function u4(e4, t7) {
  if (!e4 || !t7) return null;
  const n5 = [];
  for (let r7 = 0; r7 < e4.length; r7++) n5.push(e4[r7]), n5.push(t7[r7]);
  return n5;
}
function c6(e4) {
  const t7 = e3(e4, "GeodataXform"), n5 = d4(o3(t7, "SpatialReference/WKID") || t5(t7, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== t7.getAttribute("xsi:type")) return { spatialReference: n5, transform: null };
  const r7 = o3(t7, "PolynomialOrder") ?? 1, a4 = u2(t7, "CoeffX/Double"), c7 = u2(t7, "CoeffY/Double"), m10 = u2(t7, "InverseCoeffX/Double"), p8 = u2(t7, "InverseCoeffY/Double"), S5 = u4(a4, c7), C2 = u4(m10, p8);
  return { spatialReference: n5, transform: S5 && C2 && S5.length && C2.length ? new m6({ spatialReference: n5, polynomialOrder: r7, forwardCoefficients: S5, inverseCoefficients: C2 }) : null };
}
function m9(e4) {
  const t7 = o3(e4, "NoDataValue"), n5 = e3(e4, "Histograms/HistItem"), r7 = o3(n5, "HistMin"), o5 = o3(n5, "HistMax"), f6 = o3(n5, "BucketCount"), u6 = t5(n5, "HistCounts")?.split("|").map((e5) => Number(e5));
  let c7, m10, d6, p8;
  n2(e4, "Metadata/MDI").forEach((e5) => {
    const t8 = Number(e5.textContent ?? e5.nodeValue);
    switch (e5.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c7 = t8;
        break;
      case "STATISTICS_MAXIMUM":
        m10 = t8;
        break;
      case "STATISTICS_MEAN":
        d6 = t8;
        break;
      case "STATISTICS_STDDEV":
        p8 = t8;
    }
  });
  const S5 = o3(e4, "Metadata/SourceBandIndex");
  return { noDataValue: t7, histogram: u6?.length && null != r7 && null != o5 ? { min: r7, max: o5, size: f6 || u6.length, counts: u6 } : null, sourceBandIndex: S5, statistics: null != c7 && null != m10 ? { min: c7, max: m10, avg: d6, stddev: p8 } : null };
}
function d4(e4) {
  if (!e4) return null;
  let r7 = Number(e4);
  if (!isNaN(r7) && 0 !== r7) return new f({ wkid: r7 });
  if (e4 = String(e4).trim(), k2(e4)) return new f({ wkt2: e4 });
  const s3 = e4.toUpperCase();
  if (s3.startsWith("COMPD_CS")) {
    if (!s3.includes("VERTCS") || !s3.includes("GEOGCS") && !s3.startsWith("PROJCS")) return null;
    const n5 = s3.indexOf("VERTCS"), a4 = s3.indexOf("PROJCS"), i6 = a4 > -1 ? a4 : s3.indexOf("GEOGCS");
    if (-1 === i6) return null;
    const l5 = e4.slice(i6, e4.lastIndexOf("]", n5) + 1).trim(), o5 = e4.slice(n5, e4.lastIndexOf("]")).trim();
    r7 = p7(l5);
    const f6 = new f(r7 ? { wkid: r7 } : { wkt: l5 }), u6 = p7(o5);
    return u6 && (f6.vcsWkid = u6), f6;
  }
  return s3.startsWith("GEOGCS") || s3.startsWith("PROJCS") ? (r7 = p7(e4), new f(0 !== r7 ? { wkid: r7 } : { wkt: e4 })) : null;
}
function p7(e4) {
  const t7 = e4.replaceAll("]", "[").replaceAll('"', "").split("[").map((e5) => e5.trim()).filter((e5) => "" !== e5), n5 = t7[t7.length - 1].split(","), r7 = n5[0]?.toLowerCase();
  if (("epsg" === r7 || "esri" === r7) && e4.endsWith('"]]')) {
    const e5 = Number(n5[1]);
    if (!isNaN(e5) && 0 !== e5) return e5;
  }
  return 0;
}
function S2(t7) {
  if ("pamdataset" !== t7?.documentElement.tagName?.toLowerCase()) return {};
  const n5 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  t7.documentElement.childNodes.forEach((e4) => {
    if (1 === e4.nodeType) {
      if (i4(e4, "SRS")) {
        if (!n5.spatialReference) {
          const t8 = t5(e4);
          n5.spatialReference = d4(t8);
        }
      } else if (i4(e4, "Metadata")) if ("xml:ESRI" === e4.getAttribute("domain")) {
        const { spatialReference: t8, transform: r7 } = c6(e4);
        n5.transform = r7, n5.spatialReference || (n5.spatialReference = t8);
      } else {
        n2(e4, "MDI").forEach((e5) => n5.metadata[e5.getAttribute("key")] = t5(e5));
      }
      else if (i4(e4, "PAMRasterBand")) {
        const t8 = m9(e4);
        null != t8.sourceBandIndex && null == n5.rasterBands[t8.sourceBandIndex] ? n5.rasterBands[t8.sourceBandIndex] = t8 : n5.rasterBands.push(t8);
      }
    }
  });
  const i6 = n5.rasterBands;
  if (i6.length) {
    const t8 = !!i6[0].statistics;
    n5.statistics = t8 ? i6.map((e4) => e4.statistics).filter(L) : null;
    const r7 = !!i6[0].histogram;
    n5.histograms = r7 ? i6.map((e4) => e4.histogram).filter(L) : null;
  }
  return n5;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var h4 = class extends $2 {
  fetchRawTile(t7, s3, e4, r7 = {}) {
    return this._inMemoryRaster.fetchRawTile(t7, s3, e4, r7);
  }
  async _open(t7) {
    const s3 = await this._fetchData(t7);
    let { spatialReference: e4, statistics: r7, histograms: a4, transform: o5 } = await this._fetchAuxiliaryData(t7);
    const l5 = !e4;
    l5 && (e4 = new f({ wkid: 3857 })), a4?.length && null == r7 && (r7 = g2(a4));
    const { width: p8, height: c7 } = s3;
    let u6 = new z({ xmin: -0.5, ymin: 0.5 - c7, xmax: p8 - 0.5, ymax: 0.5, spatialReference: e4 });
    const h5 = o5 ? o5.forwardTransform(u6) : u6;
    let d6 = true;
    if (o5) {
      const t8 = o5.forwardCoefficients;
      d6 = t8 && 0 === t8[1] && 0 === t8[2], d6 && (o5 = null, u6 = h5);
    }
    const w3 = new g3({ source: { extent: h5, nativeExtent: u6, transform: o5, pixelBlocks: [s3], statistics: r7, histograms: a4, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: l5 }, ioConfig: { sampling: "closest", skipStatistics: true } });
    this.ioConfig.skipMapInfo && (w3.ioConfig.skipMapInfo = true), await w3.open(), w3.source = null, this._set("rasterInfo", w3.rasterInfo), this._inMemoryRaster = w3;
  }
  async _fetchData(t7) {
    const { data: e4 } = await this.request(this.url, { responseType: "array-buffer", signal: t7?.signal }), r7 = P(e4).toUpperCase();
    if ("JPG" !== r7 && "PNG" !== r7 && "GIF" !== r7 && "BMP" !== r7) throw new s("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", r7);
    const a4 = r7.toLowerCase(), o5 = "gif" === a4 || "bmp" === a4 || !has("ios"), i6 = await this.decodePixelBlock(e4, { format: a4, useCanvas: o5, hasNoZlibMask: true });
    if (null == i6) throw new s("image-aux-raster:open", "the data cannot be decoded");
    return i6;
  }
  async _fetchAuxiliaryData(t7) {
    const s3 = t7?.signal, { skipExtensions: a4 = [], skipMapInfo: o5 } = this.ioConfig, i6 = o5 || a4.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: s3 }), n5 = this.datasetFormat, l5 = "JPG" === n5 ? "jgw" : "PNG" === n5 ? "pgw" : "BMP" === n5 ? "bpw" : null, m10 = l5 && a4.includes(l5) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + l5, { responseType: "text", signal: s3 }), c7 = await y([i6, m10]);
    if (s3?.aborted) throw u();
    const f6 = S2(c7[0].value?.data);
    if (!f6.transform) {
      const t8 = c7[1].value ? c7[1].value.data.split("\n").slice(0, 6).map((t9) => Number(t9)) : null;
      f6.transform = 6 === t8?.length ? new m6({ forwardCoefficients: [t8[4], t8[5], t8[0], -t8[1], t8[2], -t8[3]] }) : null;
    }
    return f6;
  }
};
r([m2({ type: String, json: { write: true } })], h4.prototype, "datasetFormat", void 0), h4 = r([a("esri.layers.support.rasterDatasets.ImageAuxRaster")], h4);
var d5 = h4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var g4 = class extends $2 {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer", this.tileType = null;
  }
  async fetchRawTile(e4, t7, i6, s3 = {}) {
    const { storageInfo: r7, extent: a4 } = this.rasterInfo, { transposeInfo: l5 } = r7, n5 = null != l5 && !!s3.transposedVariableName;
    if (this._slices && !n5 && null == s3.sliceId) return null;
    const o5 = n5 ? 0 : r7.maximumPyramidLevel - e4 + this._levelOffset, c7 = `${this.url}/tile/${o5}/${t7}/${i6}`, m10 = this._slices ? n5 ? { variable: s3.transposedVariableName } : { sliceId: s3.sliceId || 0 } : null;
    let u6, h5;
    if (r7.isBsqTile) {
      const e5 = (s3.bandIds?.length ? s3.bandIds : [0, 1, 2]).map((e6) => this.request(c7, { query: { ...m10, bandId: e6 }, responseType: "array-buffer", signal: s3.signal })), t8 = await Promise.all(e5), i7 = t8.map((e6) => e6.data.byteLength).reduce((e6, t9) => e6 + t9), r8 = new Uint8Array(i7);
      h5 = [];
      let a5 = 0;
      for (const { data: s4 } of t8) h5.push(a5), r8.set(new Uint8Array(s4), a5), a5 += s4.byteLength;
      u6 = r8.buffer;
    } else {
      u6 = (await this.request(c7, { query: m10, responseType: "array-buffer", signal: s3.signal })).data;
    }
    if (!u6) return null;
    const f6 = n5 ? l5.tileSize : r7.tileInfo.size, d6 = await this.decodePixelBlock(u6, { width: f6[0], height: f6[1], planes: h5?.length, offsets: h5, pixelType: null, isPoint: "Elevation" === this.tileType, returnInterleaved: n5, noDataValue: this.rasterInfo.noDataValue });
    if (null == d6) return null;
    const y3 = r7.blockBoundary[e4];
    if ("jpg" !== r7.compression || i6 > y3.minCol && i6 < y3.maxCol && t7 > y3.minRow && t7 < y3.maxRow) return d6;
    const { origin: x2, blockWidth: g5, blockHeight: v4 } = r7, { x: S5, y: I5 } = this.getPyramidPixelSize(e4), w3 = Math.round((a4.xmin - x2.x) / S5) % g5, b5 = Math.round((a4.xmax - x2.x) / S5) % g5 || g5, T3 = Math.round((x2.y - a4.ymax) / I5) % v4, j3 = Math.round((x2.y - a4.ymin) / I5) % v4 || v4, M = i6 === y3.minCol ? w3 : 0, _2 = t7 === y3.minRow ? T3 : 0, O = i6 === y3.maxCol ? b5 : g5, R2 = t7 === y3.maxRow ? j3 : v4;
    return B(d6, { x: M, y: _2 }, { width: O - M, height: R2 - _2 }), d6;
  }
  getSliceIndex(e4) {
    if (!this._slices || null == e4 || 0 === e4.length) return null;
    const t7 = e4;
    for (let i6 = 0; i6 < this._slices.length; i6++) {
      const e5 = this._slices[i6].multidimensionalDefinition;
      if (e5.length === t7.length && !e5.some((e6) => {
        const i7 = t7.find((t8) => e6.variableName === t8.variableName && t8.dimensionName === e6.dimensionName);
        if (!i7) return true;
        return (Array.isArray(e6.values[0]) ? `${e6.values[0][0]}-${e6.values[0][1]}` : e6.values[0]) !== (Array.isArray(i7.values[0]) ? `${i7.values[0][0]}-${i7.values[0][1]}` : i7.values[0]);
      })) return i6;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e4, t7) {
    const i6 = this.request(this.url + "/statistics", { query: { variable: e4, f: "json" }, signal: t7 }).then((e5) => e5.data?.statistics), s3 = this.request(this.url + "/histograms", { query: { variable: e4, f: "json" }, signal: t7 }).then((e5) => e5.data?.histograms), r7 = await Promise.all([i6, s3]);
    return r7[0] && r7[0].forEach((e5) => {
      e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
    }), r7[1]?.[0]?.counts?.length || (r7[1] = null), { statistics: r7[0] || null, histograms: r7[1] || null };
  }
  async computeBestPyramidLevelForLocation(e4, t7 = {}) {
    if (!this._tilemapCache) return 0;
    let i6 = this.identifyPixelLocation(e4, 0, t7.datumTransformation);
    if (null === i6) return null;
    let s3 = 0;
    const { maximumPyramidLevel: r7 } = this.rasterInfo.storageInfo;
    let a4 = r7 - s3 + this._levelOffset;
    const l5 = i6.srcLocation;
    for (; a4 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(a4, i6.row, i6.col, t7)) break;
      } catch {
      }
      if (a4--, s3++, i6 = this.identifyPixelLocation(l5, s3, t7.datumTransformation), null === i6) return null;
    }
    return -1 === a4 || null == i6 ? null : s3;
  }
  async _open(e4) {
    const r7 = e4?.signal, a4 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: r7 });
    a4.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const l5 = a4.data;
    if (this.sourceJSON = l5, !l5) throw new s("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!l5.tileInfo) throw new s("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const n5 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = l5.cacheType, null == this.tileType && (n5.includes(l5.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === l5.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = l5.name?.slice(l5.name.indexOf("/") + 1) ?? "";
    const o5 = await this._fetchRasterInfo({ signal: r7 });
    if (null == o5) throw new s("image-server-raster:open", "cannot initialize image service");
    c4(o5, l5);
    const c7 = "Map" === this.tileType ? v2(l5.tileInfo, l5) : j2.fromJSON(l5.tileInfo);
    n(c7);
    const [f6, p8] = this._computeMinMaxLOD(o5, c7), { extent: d6, pixelSize: x2 } = o5, g5 = 0.5 / o5.width * x2.x, I5 = Math.max(x2.x, x2.y), { lods: w3 } = c7;
    ("Map" !== this.tileType && 0 !== l5.maxScale || Math.abs(x2.x - x2.y) > g5 || !w3.some((e5) => Math.abs(e5.resolution - I5) < g5)) && (x2.x = x2.y = f6.resolution, o5.width = Math.ceil((d6.xmax - d6.xmin) / x2.x - 0.1), o5.height = Math.ceil((d6.ymax - d6.ymin) / x2.y - 0.1));
    const b5 = f6.level - p8.level, [T3, j3] = c7.size, M = [], _2 = [];
    w3.forEach((e5, t7) => {
      e5.level >= p8.level && e5.level <= f6.level && M.push({ x: e5.resolution, y: e5.resolution }), t7 < w3.length - 1 && _2.push(Math.round(10 * e5.resolution / w3[t7 + 1].resolution) / 10);
    }), M.sort((e5, t7) => e5.x - t7.x);
    const O = this.computeBlockBoundary(d6, T3, j3, c7.origin, M, b5), R2 = M.length > 1 ? M.slice(1) : null;
    let L2;
    l5.transposeInfo && (L2 = { tileSize: [l5.transposeInfo.rows, l5.transposeInfo.cols], packetSize: o5.keyProperties?._yxs.PacketSize ?? 0 });
    const z2 = _2.length <= 1 || _2.length >= 3 && _2.slice(0, -1).every((e5) => e5 === _2[0]) ? _2[0] ?? 2 : Math.round(10 / (p8.resolution / f6.resolution) ** (-1 / b5)) / 10;
    if (o5.storageInfo = new l4({ blockWidth: c7.size[0], blockHeight: c7.size[1], pyramidBlockWidth: c7.size[0], pyramidBlockHeight: c7.size[1], pyramidResolutions: R2, pyramidScalingFactor: z2, compression: c7.format, origin: c7.origin, firstPyramidLevel: 1, maximumPyramidLevel: b5, tileInfo: c7, isBsqTile: !!l5.bsq, transposeInfo: L2, blockBoundary: O }), S3(o5), this._set("rasterInfo", o5), l5.capabilities.toLowerCase().includes("tilemap")) {
      const e5 = { tileInfo: o5.storageInfo.tileInfo, parsedUrl: I(this.url), url: this.url, tileServers: [] };
      this._tilemapCache = new T({ layer: e5 });
    }
  }
  async _fetchRasterInfo(e4) {
    const t7 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e5 = t7.fullExtent || t7.extent, i7 = Math.ceil((e5.xmax - e5.xmin) / t7.pixelSizeX - 0.1), s4 = Math.ceil((e5.ymax - e5.ymin) / t7.pixelSizeY - 0.1), r8 = f.fromJSON(t7.spatialReference || e5.spatialReference), a5 = new _({ x: t7.pixelSizeX, y: t7.pixelSizeY, spatialReference: r8 });
      return new m4({ width: i7, height: s4, bandCount: 3, extent: z.fromJSON(e5), spatialReference: r8, pixelSize: a5, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i6 } = e4, s3 = f3(this.url, this.sourceJSON, { signal: i6, query: this.ioConfig.customFetchParameters }), r7 = t7.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i6 }).then((e5) => e5.data?.slices).catch(() => null) : null, a4 = await Promise.all([s3, r7]);
    return this._slices = a4[1], a4[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e4 } = this;
    e4.minScale && e4.minScale < 0 && (e4.minScale = 0), e4.maxScale && e4.maxScale < 0 && (e4.maxScale = 0);
  }
  _computeMinMaxLOD(e4, t7) {
    const { pixelSize: i6 } = e4, s3 = 0.5 / e4.width * i6.x, { lods: r7 } = t7, a4 = t7.lodAt(Math.max.apply(null, r7.map((e5) => e5.level))), l5 = t7.lodAt(Math.min.apply(null, r7.map((e5) => e5.level))), { tileType: n5 } = this;
    if ("Map" === n5) return this._levelOffset = r7[0].level, [a4, l5];
    if ("Raster" === n5) {
      return [r7.find((e5) => e5.resolution === i6.x) ?? a4, l5];
    }
    const { minScale: o5, maxScale: c7 } = this.sourceJSON;
    let m10 = a4;
    c7 > 0 && (m10 = r7.find((e5) => Math.abs(e5.scale - c7) < s3), m10 || (m10 = r7.filter((e5) => e5.scale > c7).sort((e5, t8) => e5.scale > t8.scale ? 1 : -1)[0] ?? a4));
    let u6 = l5;
    return o5 > 0 && (u6 = r7.find((e5) => Math.abs(e5.scale - o5) < s3) ?? l5, this._levelOffset = u6.level - l5.level), [m10, u6];
  }
};
function v2(e4, t7) {
  if (!e4) return null;
  const { minScale: i6, maxScale: s3, minLOD: r7, maxLOD: a4 } = t7;
  if (null != r7 && null != a4) return j2.fromJSON({ ...e4, lods: e4.lods.filter(({ level: e5 }) => null != e5 && e5 >= r7 && e5 <= a4) });
  if (0 !== i6 && 0 !== s3) {
    const t8 = (e5) => Math.round(1e4 * e5) / 1e4, r8 = i6 ? t8(i6) : 1 / 0, a5 = s3 ? t8(s3) : -1 / 0;
    return j2.fromJSON({ ...e4, lods: e4.lods.filter((e5) => {
      const i7 = t8(e5.scale);
      return i7 <= r8 && i7 >= a5;
    }) });
  }
  return j2.fromJSON(e4);
}
function S3(e4) {
  const { extent: t7, spatialReference: i6 } = e4;
  t7.xmin > -1 && t7.xmax > 181 && i6?.wkid && i6.isGeographic && (e4.nativeExtent = e4.extent, e4.transform = new n3(), e4.extent = e4.transform.forwardTransform(t7));
}
r([m2({ type: String, json: { write: true } })], g4.prototype, "datasetFormat", void 0), r([m2()], g4.prototype, "tileType", void 0), g4 = r([a("esri.layers.support.rasterDatasets.ImageServerRaster")], g4);
var I3 = g4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var y2 = /* @__PURE__ */ new Map();
y2.set("Int8", "s8"), y2.set("UInt8", "u8"), y2.set("Int16", "s16"), y2.set("UInt16", "u16"), y2.set("Int32", "s32"), y2.set("UInt32", "u32"), y2.set("Float32", "f32"), y2.set("Float64", "f32"), y2.set("Double64", "f32");
var x = /* @__PURE__ */ new Map();
x.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), x.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), x.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), x.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" });
var w2 = class extends $2 {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async fetchRawTile(t7, e4, r7, s3 = {}) {
    const { blockWidth: o5, blockHeight: a4, blockBoundary: i6 } = this.rasterInfo.storageInfo, l5 = i6[t7];
    if (!l5 || l5.maxRow < e4 || l5.maxCol < r7 || l5.minRow > e4 || l5.minCol > r7) return null;
    const { bandCount: f6, pixelType: c7 } = this.rasterInfo, { ranges: p8, actualTileWidth: m10, actualTileHeight: h5 } = this._getTileLocation(t7, e4, r7);
    if (!p8 || 0 === p8.length) return null;
    if (0 === p8[0].from && 0 === p8[0].to) {
      const t8 = new Uint8Array(o5 * a4);
      return new c2({ width: o5, height: a4, pixels: void 0, mask: t8, validPixelCount: 0 });
    }
    const { bandIds: u6 } = this.ioConfig, g5 = this._getBandSegmentCount(), d6 = [];
    let y3 = 0;
    for (y3 = 0; y3 < g5; y3++) u6 && !u6.includes(y3) || d6.push(this.request(this._files.data, { range: { from: p8[y3].from, to: p8[y3].to }, responseType: "array-buffer", signal: s3.signal }));
    const w3 = await Promise.all(d6), I5 = w3.map((t8) => t8.data.byteLength).reduce((t8, e5) => t8 + e5), b5 = new Uint8Array(I5), R2 = [];
    let A2 = 0;
    for (y3 = 0; y3 < g5; y3++) R2.push(A2), b5.set(new Uint8Array(w3[y3].data), A2), A2 += w3[y3].data.byteLength;
    const F = x.get(this.rasterInfo.storageInfo.compression).decoderFormat, _2 = await this.decodePixelBlock(b5.buffer, { width: o5, height: a4, format: F, planes: u6?.length || f6, offsets: R2, pixelType: c7 });
    if (null == _2) return null;
    let { noDataValue: S5 } = this.rasterInfo;
    if (null != S5 && "lerc" !== F && !_2.mask && (S5 = S5[0], null != S5)) {
      const t8 = _2.width * _2.height, e5 = new Uint8Array(t8);
      if (Math.abs(S5) > 1e24) for (y3 = 0; y3 < t8; y3++) Math.abs((_2.pixels[0][y3] - S5) / S5) > 1e-6 && (e5[y3] = 1);
      else for (y3 = 0; y3 < t8; y3++) _2.pixels[0][y3] !== S5 && (e5[y3] = 1);
      _2.mask = e5;
    }
    let k6 = 0, M = 0;
    if (m10 !== o5 || h5 !== a4) {
      let t8 = _2.mask;
      if (t8) for (y3 = 0; y3 < a4; y3++) if (M = y3 * o5, y3 < h5) for (k6 = m10; k6 < o5; k6++) t8[M + k6] = 0;
      else for (k6 = 0; k6 < o5; k6++) t8[M + k6] = 0;
      else for (t8 = new Uint8Array(o5 * a4), _2.mask = t8, y3 = 0; y3 < h5; y3++) for (M = y3 * o5, k6 = 0; k6 < m10; k6++) t8[M + k6] = 1;
    }
    return _2;
  }
  async _open(t7) {
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e4 = t7 ? t7.signal : null, r7 = await this.request(this.url, { responseType: "xml", signal: e4 }), { rasterInfo: s3, files: o5 } = this._parseHeader(r7.data), { skipMapInfo: a4, skipExtensions: i6 = [] } = this.ioConfig;
    if (!i6.includes("aux.xml") && !a4) {
      const e5 = await this._fetchAuxiliaryData(t7);
      null != e5 && (s3.statistics = e5.statistics ?? s3.statistics, s3.histograms = e5.histograms, e5.histograms && null == s3.statistics && (s3.statistics = g2(e5.histograms)));
    }
    a4 && this.updateImageSpaceRasterInfo(s3), this._set("rasterInfo", s3), this._files = o5;
    const n5 = await this.request(o5.index, { responseType: "array-buffer", signal: e4 });
    this._storageIndex = I4(n5.data);
    const { blockWidth: l5, blockHeight: f6 } = this.rasterInfo.storageInfo, c7 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: p8, height: m10 } = this.rasterInfo, h5 = [], u6 = this._getBandSegmentCount();
    let g5 = 0, y3 = -1;
    for (; g5 < this._storageIndex.length; ) {
      y3++;
      const t8 = Math.ceil(p8 / l5 / c7 ** y3) - 1, e5 = Math.ceil(m10 / f6 / c7 ** y3) - 1;
      g5 += (t8 + 1) * (e5 + 1) * u6 * 4, h5.push({ maxRow: e5, maxCol: t8, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = h5, y3 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = y3), this.updateTileInfo();
  }
  _getBandSegmentCount() {
    return x.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t7, e4, r7) {
    const { blockWidth: s3, blockHeight: o5, pyramidScalingFactor: a4 } = this.rasterInfo.storageInfo, { width: i6, height: n5 } = this.rasterInfo, l5 = this._getBandSegmentCount();
    let f6, c7, p8, m10 = 0, h5 = 0;
    for (p8 = 0; p8 < t7; p8++) h5 = a4 ** p8, f6 = Math.ceil(i6 / s3 / h5), c7 = Math.ceil(n5 / o5 / h5), m10 += f6 * c7;
    h5 = a4 ** t7, f6 = Math.ceil(i6 / s3 / h5), c7 = Math.ceil(n5 / o5 / h5), m10 += e4 * f6 + r7, m10 *= 4 * l5;
    const u6 = this._storageIndex.subarray(m10, m10 + 4 * l5);
    let g5 = 0, d6 = 0;
    const y3 = [];
    for (let x2 = 0; x2 < l5; x2++) g5 = u6[4 * x2] * 2 ** 32 + u6[4 * x2 + 1], d6 = g5 + u6[4 * x2 + 2] * 2 ** 32 + u6[4 * x2 + 3], y3.push({ from: g5, to: d6 });
    return { ranges: y3, actualTileWidth: r7 < f6 - 1 ? s3 : Math.ceil(i6 / h5) - s3 * (f6 - 1), actualTileHeight: e4 < c7 - 1 ? o5 : Math.ceil(n5 / h5) - o5 * (c7 - 1) };
  }
  _parseHeader(t7) {
    const r7 = e3(t7, "MRF_META/Raster");
    if (!r7) throw new s("mrf:open", "not a valid MRF format");
    const s3 = e3(r7, "Size"), n5 = parseInt(s3.getAttribute("x"), 10), c7 = parseInt(s3.getAttribute("y"), 10), m10 = parseInt(s3.getAttribute("c"), 10), g5 = (t5(r7, "Compression") || "none").toLowerCase();
    if (!x.has(g5)) throw new s("mrf:open", "currently does not support compression " + g5);
    const d6 = t5(r7, "DataType") || "UInt8", w3 = y2.get(d6);
    if (null == w3) throw new s("mrf:open", "currently does not support pixel type " + d6);
    const I5 = e3(r7, "PageSize"), b5 = parseInt(I5.getAttribute("x"), 10), R2 = parseInt(I5.getAttribute("y"), 10), A2 = e3(r7, "DataValues");
    let F, _2;
    A2 && (_2 = A2.getAttribute("NoData"), null != _2 && (F = _2.trim().split(" ").map((t8) => parseFloat(t8))));
    if (e3(t7, "MRF_META/CachedSource")) throw new s("mrf:open", "currently does not support MRF referencing other data files");
    const S5 = e3(t7, "MRF_META/GeoTags"), k6 = e3(S5, "BoundingBox");
    let M, j3 = false;
    if (null != k6) {
      const t8 = parseFloat(k6.getAttribute("minx")), e4 = parseFloat(k6.getAttribute("miny")), r8 = parseFloat(k6.getAttribute("maxx")), s4 = parseFloat(k6.getAttribute("maxy")), a4 = t5(S5, "Projection") || "";
      let n6 = f.WGS84;
      if ("LOCAL_CS[]" !== a4) if (a4.toLowerCase().startsWith("epsg:")) {
        const t9 = Number(a4.slice(5));
        isNaN(t9) || 0 === t9 || (n6 = new f({ wkid: t9 }));
      } else n6 = d4(a4) ?? f.WGS84;
      else j3 = true, n6 = new f({ wkid: 3857 });
      M = new z(t8, e4, r8, s4), M.spatialReference = n6;
    } else j3 = true, M = new z({ xmin: -0.5, ymin: 0.5 - c7, xmax: n5 - 0.5, ymax: 0.5, spatialReference: new f({ wkid: 3857 }) });
    const C2 = e3(t7, "MRF_META/Rsets"), T3 = parseInt(C2?.getAttribute("scale") || "2", 10), L2 = M.spatialReference, U2 = new l4({ origin: new _({ x: M.xmin, y: M.ymax, spatialReference: L2 }), blockWidth: b5, blockHeight: R2, pyramidBlockWidth: b5, pyramidBlockHeight: R2, compression: g5, pyramidScalingFactor: T3 }), B2 = new _({ x: M.width / n5, y: M.height / c7, spatialReference: L2 }), E2 = new m4({ width: n5, height: c7, extent: M, isPseudoSpatialReference: j3, spatialReference: L2, bandCount: m10, pixelType: w3, pixelSize: B2, noDataValue: F, storageInfo: U2 }), P2 = t5(t7, "datafile"), W3 = t5(t7, "IndexFile");
    return { rasterInfo: E2, files: { mrf: this.url, index: W3 || this.url.replace(".mrf", ".idx"), data: P2 || this.url.replace(".mrf", x.get(g5).blobExtension) } };
  }
  async _fetchAuxiliaryData(t7) {
    try {
      const { data: e4 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t7?.signal });
      return S2(e4);
    } catch {
      return null;
    }
  }
};
function I4(t7) {
  if (t7.byteLength % 16 > 0) throw new Error("invalid array buffer must be multiples of 16");
  let e4, r7, s3, o5, a4, i6;
  if (r3) {
    for (r7 = new Uint8Array(t7), o5 = new ArrayBuffer(t7.byteLength), s3 = new Uint8Array(o5), a4 = 0; a4 < t7.byteLength / 4; a4++) for (i6 = 0; i6 < 4; i6++) s3[4 * a4 + i6] = r7[4 * a4 + 3 - i6];
    e4 = new Uint32Array(o5);
  } else e4 = new Uint32Array(t7);
  return e4;
}
r([m2()], w2.prototype, "_files", void 0), r([m2()], w2.prototype, "_storageIndex", void 0), r([m2({ type: String, json: { write: true } })], w2.prototype, "datasetFormat", void 0), w2 = r([a("esri.layers.support.rasterDatasets.MRFRaster")], w2);
var b3 = w2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t6(e4) {
  const t7 = e4.fields, r7 = e4.records, n5 = t7.some((e5) => "oid" === e5.name.toLowerCase()) ? "OBJECTID" : "OID", i6 = [{ name: n5, type: "esriFieldTypeOID", alias: "OID" }].concat(t7.map((e5) => ({ name: e5.name, type: "esriFieldType" + e5.typeName, alias: e5.name }))), a4 = i6.map((e5) => e5.name), s3 = [];
  let o5 = 0, l5 = 0;
  return r7.forEach((e5) => {
    const t8 = {};
    for (t8[n5] = o5++, l5 = 1; l5 < a4.length; l5++) t8[a4[l5]] = e5[l5 - 1];
    s3.push({ attributes: t8 });
  }), { displayFieldName: "", fields: i6, features: s3 };
}
var r6 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r7) {
    const n5 = new DataView(r7), i6 = 3 & n5.getUint8(0);
    if (3 !== i6) return { header: { version: i6 }, recordSet: null };
    const a4 = n5.getUint32(4, true), s3 = n5.getUint16(8, true), o5 = n5.getUint16(10, true), l5 = { version: i6, recordCount: a4, headerByteCount: s3, recordByteCount: o5 };
    let p8 = 32;
    const d6 = [], g5 = [];
    let h5;
    if (3 === i6) {
      for (; 13 !== n5.getUint8(p8); ) h5 = String.fromCharCode(n5.getUint8(p8 + 11)).trim(), d6.push({ name: r2(new Uint8Array(r7, p8, 11)), type: h5, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(h5)], length: n5.getUint8(p8 + 16) }), p8 += 32;
      if (p8 += 1, d6.length > 0) for (; g5.length < a4 && r7.byteLength - p8 > o5; ) {
        const t7 = [];
        32 === n5.getUint8(p8) ? (p8 += 1, d6.forEach((n6) => {
          if ("C" === n6.type) t7.push(r2(new Uint8Array(r7, p8, n6.length)).trim());
          else if ("N" === n6.type) t7.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r7, p8, n6.length)).trim(), 10));
          else if ("F" === n6.type) t7.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r7, p8, n6.length)).trim()));
          else if ("D" === n6.type) {
            const e4 = String.fromCharCode.apply(null, new Uint8Array(r7, p8, n6.length)).trim();
            t7.push(new Date(parseInt(e4.slice(0, 4), 10), parseInt(e4.slice(4, 6), 10) - 1, parseInt(e4.slice(6, 8), 10)));
          }
          p8 += n6.length;
        }), g5.push(t7)) : p8 += o5;
      }
    }
    return { header: l5, fields: d6, records: g5, recordSet: t6({ fields: d6, records: g5 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var S4 = (e4, t7) => e4.get(t7)?.values;
var b4 = (e4, t7) => e4.get(t7)?.values?.[0];
var k4 = class extends $2 {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this._chunkSize = 10485760, this.datasetFormat = "TIFF";
  }
  async fetchRawTile(e4, t7, i6, r7 = {}) {
    if (!this._headerInfo?.isSupported || this.isBlockOutside(e4, t7, i6)) return null;
    const s3 = await this._fetchRawTiffTile(e4, t7, i6, false, r7);
    if (null != s3 && this._headerInfo.hasMaskBand) {
      const a4 = await this._fetchRawTiffTile(e4, t7, i6, true, r7);
      null != a4 && a4.pixels[0] instanceof Uint8Array && (s3.mask = a4.pixels[0]);
    }
    return s3;
  }
  async _open(e4) {
    const r7 = e4 ? e4.signal : null, { data: s3 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: r7 });
    if (!s3) throw new s("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1, this.url.lastIndexOf("."));
    const { littleEndian: a4, firstIFDPos: n5, isBigTiff: o5 } = W(s3), f6 = [], l5 = { fileChunk: s3, posIFD: n5, fileOffset: 0 };
    await this._readIFDs(f6, l5, a4, o5 ? 8 : 4, r7);
    const { imageInfo: u6, rasterInfo: c7 } = E(f6), h5 = C(f6), p8 = G(f6);
    if (this._headerInfo = { littleEndian: a4, isBigTiff: o5, ifds: f6, pyramidIFDs: h5, maskIFDs: p8, ...u6 }, this._set("rasterInfo", c7), !u6.isSupported) throw new s("tiffraster:open", "this tiff is not supported: " + u6.message);
    if (!u6.tileWidth) throw new s("tiffraster:open", "none-tiled tiff is not optimized for access, convert to COG and retry.");
    c7.isPseudoSpatialReference && i.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");
    const g5 = f6[0].get("PREDICTOR")?.values?.[0], x2 = f6[0].get("SAMPLEFORMAT")?.values?.[0];
    if (3 === x2 && 2 === g5) throw new s("tiffraster:open", "unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");
    const { skipMapInfo: w3, skipExtensions: I5 = [] } = this.ioConfig;
    if (!I5.includes("aux.xml") && !w3) {
      const t7 = await this._fetchAuxiliaryMetaData(e4);
      null != t7 && D(t7, c7);
    }
    I5.includes("vat.dbf") || 1 !== c7.bandCount || "u8" !== c7.pixelType || w3 || (c7.attributeTable = await this._fetchAuxiliaryTable(e4), null != c7.attributeTable && (c7.keyProperties.DataType = "thematic")), w3 && this.updateImageSpaceRasterInfo(c7), this.updateTileInfo();
  }
  async _validateOrFetchHeaderBuffer(e4, t7) {
    let { fileChunk: i6, fileOffset: r7, posIFD: s3 } = e4;
    if (s3 + 8 >= i6.byteLength || s3 < 0) {
      r7 = s3 + r7;
      i6 = (await this.request(this.url, { range: { from: r7, to: r7 + this._bufferSize }, responseType: "array-buffer", signal: t7 })).data, s3 = 0;
    }
    return { fileChunk: i6, fileOffset: r7, posIFD: s3 };
  }
  async _readIFDs(e4, i6, r7, s3 = 4, a4) {
    if (!i6.posIFD) return null;
    i6 = await this._validateOrFetchHeaderBuffer(i6, a4);
    const n5 = await this._readIFD(i6, r7, e2, s3, a4);
    if (!n5?.ifd) throw new s("tiffraster:open", "cannot parse tiff header. failed to open url " + this.url);
    if (e4.push(n5.ifd), !n5.nextIFD) return null;
    i6.posIFD = n5.nextIFD - i6.fileOffset, await this._readIFDs(e4, i6, r7, s3, a4);
  }
  async _readIFD(e4, t7, i6 = e2, r7 = 4, s3) {
    let { fileChunk: a4, posIFD: n5, fileOffset: o5 } = e4;
    if (!e4.fileChunk) return null;
    const f6 = H(a4, t7, n5, o5, i6, r7);
    if (f6.success) {
      const e5 = [];
      if (f6.ifd?.forEach((t8) => {
        t8.values || e5.push(t8);
      }), e5.length > 0 && await this._fillOffsets(e5, t7, f6.nextIFD, s3), f6.ifd?.has("GEOKEYDIRECTORY")) {
        const e6 = f6.ifd.get("GEOKEYDIRECTORY"), i7 = e6?.values;
        if (i7 && i7.length > 4) {
          const r8 = i7[0] + "." + i7[1] + "." + i7[2];
          n5 = e6.valueOffset + 6 - o5;
          const f7 = await this._validateOrFetchHeaderBuffer({ fileChunk: a4, posIFD: n5, fileOffset: o5 }, s3), l5 = await this._readIFD(f7, t7, t3, 2, s3);
          e6.data = l5?.ifd, e6.data && e6.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [r8] });
        }
      }
      return f6;
    }
    if (f6.requiredBufferSize) {
      return a4 = (await this.request(this.url, { range: { from: o5, to: o5 + n5 + f6.requiredBufferSize + 8 }, responseType: "array-buffer", signal: s3 })).data, a4.byteLength < n5 + f6.requiredBufferSize ? null : (e4.fileChunk = a4, e4.fileOffset = o5, this._readIFD(e4, t7, i6, r7, s3));
    }
    return null;
  }
  async _fillOffsets(e4, t7, i6, r7) {
    const s3 = e4.filter((e5) => null != e5.offlineOffsetSize);
    if (0 === s3.length) return;
    const a4 = s3.map((e5) => e5.offlineOffsetSize), n5 = Math.min.apply(null, a4.map((e5) => e5[0])), o5 = Math.max.apply(null, a4.map((e5) => e5[0] + e5[1]));
    let f6 = 1 === a4.length || o5 - n5 <= this._bufferSize;
    if (!f6 && a4.length > 1) {
      a4.sort((e5, t8) => e5[0] - t8[0]);
      f6 = a4.reduce((e5, t8) => e5 === t8[0] ? t8[0] + t8[1] : 0, a4[0][0]) === o5;
    }
    if (f6) {
      const e5 = await this._fetchOffsets(n5, Math.max(o5, n5 + this._bufferSize), r7);
      return void s3.forEach((i7) => N3(e5, t7, i7, n5));
    }
    const l5 = s3.map(async (e5) => {
      const i7 = e5.offlineOffsetSize, s4 = await this._fetchOffsets(i7[0], i7[1] + i7[0], r7);
      N3(s4, t7, e5, i7[0]);
    });
    await Promise.all(l5);
  }
  async _fetchOffsets(e4, t7, i6) {
    const r7 = [], s3 = this._chunkSize, a4 = Math.ceil((t7 - e4) / s3);
    let n5 = e4;
    for (let l5 = 0; l5 < a4; l5++) r7.push(this.request(this.url, { range: { from: n5, to: l5 === a4 - 1 ? t7 : n5 + s3 - 1 }, responseType: "array-buffer", signal: i6 })), n5 += s3;
    const o5 = await Promise.all(r7);
    if (1 === a4) return o5[0].data;
    const f6 = new Uint8Array(t7 - e4 + 1);
    for (let l5 = 0; l5 < a4; l5++) f6.set(new Uint8Array(o5[l5].data), l5 * s3);
    return f6.buffer;
  }
  async _fetchRawTiffTile(e4, t7, i6, r7, s3 = {}) {
    const a4 = this._getTileLocation(e4, t7, i6, r7);
    if (!a4) return null;
    const { ranges: n5, actualTileWidth: o5, actualTileHeight: f6, ifd: l5 } = a4, u6 = n5.map((e5) => this.request(this.url, { range: e5, responseType: "array-buffer", signal: s3.signal })), c7 = await Promise.all(u6), h5 = c7.map((e5) => e5.data.byteLength).reduce((e5, t8) => e5 + t8), p8 = 1 === c7.length ? c7[0].data : new ArrayBuffer(h5), d6 = [0], m10 = [0];
    if (c7.length > 1) {
      const e5 = new Uint8Array(p8);
      for (let t8 = 0, i7 = 0; t8 < c7.length; t8++) {
        const r8 = c7[t8].data;
        e5.set(new Uint8Array(r8), i7), d6[t8] = i7, i7 += r8.byteLength, m10[t8] = r8.byteLength;
      }
    }
    const { blockWidth: y3, blockHeight: g5 } = this.getBlockWidthHeight(e4), x2 = await this.decodePixelBlock(p8, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: l5, offsets: d6, sizes: m10 }, width: y3, height: g5, planes: null, pixelType: null });
    if (null == x2) return null;
    let w3, I5, T3;
    if (o5 !== y3 || f6 !== g5) {
      let e5 = x2.mask;
      if (e5) for (w3 = 0; w3 < g5; w3++) if (T3 = w3 * y3, w3 < f6) for (I5 = o5; I5 < y3; I5++) e5[T3 + I5] = 0;
      else for (I5 = 0; I5 < y3; I5++) e5[T3 + I5] = 0;
      else for (e5 = new Uint8Array(y3 * g5), x2.mask = e5, w3 = 0; w3 < f6; w3++) for (T3 = w3 * y3, I5 = 0; I5 < o5; I5++) e5[T3 + I5] = 1;
    }
    return x2;
  }
  _getTileLocation(e4, t7, i6, r7 = false) {
    const { firstPyramidLevel: s3, blockBoundary: a4 } = this.rasterInfo.storageInfo, n5 = 0 === e4 ? 0 : e4 - (s3 - 1), { _headerInfo: o5 } = this;
    if (!o5) return null;
    const f6 = r7 ? o5.maskIFDs[n5] : 0 === n5 ? o5?.ifds[0] : o5?.pyramidIFDs[n5 - 1];
    if (!f6) return null;
    const l5 = k3(f6, o5), u6 = S4(f6, "TILEOFFSETS");
    if (void 0 === u6) return null;
    const c7 = S4(f6, "TILEBYTECOUNTS"), { minRow: h5, minCol: p8, maxRow: d6, maxCol: m10 } = a4[n5];
    if (t7 > d6 || i6 > m10 || t7 < h5 || i6 < p8) return null;
    const y3 = b4(f6, "IMAGEWIDTH"), g5 = b4(f6, "IMAGELENGTH"), x2 = b4(f6, "TILEWIDTH"), I5 = b4(f6, "TILELENGTH"), T3 = [];
    if (l5) {
      const { bandCount: e5 } = this.rasterInfo;
      for (let r8 = 0; r8 < e5; r8++) {
        const e6 = r8 * (d6 + 1) * (m10 + 1) + t7 * (m10 + 1) + i6;
        T3[r8] = { from: u6[e6], to: u6[e6] + c7[e6] - 1 };
      }
    } else {
      const e5 = t7 * (m10 + 1) + i6;
      T3.push({ from: u6[e5], to: u6[e5] + c7[e5] - 1 });
    }
    for (let w3 = 0; w3 < T3.length; w3++) if (null == T3[w3].from || !T3[w3].to || T3[w3].to < 0) return null;
    return { ranges: T3, ifd: f6, actualTileWidth: i6 === m10 && y3 % x2 || x2, actualTileHeight: t7 === d6 && g5 % I5 || I5 };
  }
  async _fetchAuxiliaryMetaData(e4) {
    try {
      const { data: t7 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e4?.signal });
      return S2(t7);
    } catch {
      return null;
    }
  }
  async _fetchAuxiliaryTable(e4) {
    try {
      const { data: t7 } = await this.request(this.url + ".vat.dbf", { responseType: "array-buffer", signal: e4?.signal }), i6 = r6.parse(t7);
      return i6?.recordSet ? g.fromJSON(i6.recordSet) : null;
    } catch {
      return null;
    }
  }
};
function E(e4) {
  const t7 = U(e4), { width: i6, height: r7, tileWidth: s3, tileHeight: u6, planes: c7, pixelType: h5, compression: d6, firstPyramidLevel: m10, maximumPyramidLevel: y3, pyramidBlockWidth: g5, pyramidBlockHeight: x2, pyramidResolutions: w3, tileBoundary: T3, affine: R2, metadata: _2 } = t7, F = t7.extent.spatialReference?.wkt || t7.extent.spatialReference?.wkid;
  let k6 = d4(F), E2 = !!t7.isPseudoGeographic;
  null == k6 && (E2 = true, k6 = new f({ wkid: 3857 }));
  const D2 = new z({ ...t7.extent, spatialReference: k6 }), v4 = new _(D2 ? { x: D2.xmin, y: D2.ymax, spatialReference: k6 } : { x: 0, y: 0 }), P2 = new l4({ blockWidth: s3, blockHeight: u6, pyramidBlockWidth: g5, pyramidBlockHeight: x2, compression: d6, origin: v4, firstPyramidLevel: m10, maximumPyramidLevel: y3, pyramidResolutions: w3, blockBoundary: T3 }), B2 = new _({ x: (D2.xmax - D2.xmin) / i6, y: (D2.ymax - D2.ymin) / r7, spatialReference: k6 }), C2 = _2 ? { BandProperties: _2.bandProperties, DataType: _2.dataType } : {};
  let L2 = null;
  const z2 = b4(e4[0], "PHOTOMETRICINTERPRETATION"), j3 = S4(e4[0], "COLORMAP");
  if (z2 <= 3 && j3?.length > 3 && j3.length % 3 == 0) {
    L2 = [];
    const e5 = j3.length / 3;
    for (let t8 = 0; t8 < e5; t8++) L2.push([t8, j3[t8] >>> 8, j3[t8 + e5] >>> 8, j3[t8 + 2 * e5] >>> 8]);
  }
  const A2 = new m4({ width: i6, height: r7, bandCount: c7, pixelType: h5, pixelSize: B2, storageInfo: P2, spatialReference: k6, isPseudoSpatialReference: E2, keyProperties: C2, extent: D2, colormap: L2, statistics: _2 ? _2.statistics : null });
  if (R2?.length && (A2.nativeExtent = new z({ xmin: -0.5, ymin: 0.5 - r7, xmax: i6 - 0.5, ymax: 0.5, spatialReference: k6 }), A2.transform = new m6({ polynomialOrder: 1, forwardCoefficients: [R2[2] + R2[0] / 2, R2[5] - R2[3] / 2, R2[0], R2[3], -R2[1], -R2[4]] }), A2.extent = A2.transform.forwardTransform(A2.nativeExtent), A2.pixelSize = new _({ x: (D2.xmax - D2.xmin) / i6, y: (D2.ymax - D2.ymin) / r7, spatialReference: k6 }), P2.origin.x = -0.5, P2.origin.y = 0.5), w3) {
    const { x: e5, y: t8 } = A2.pixelSize;
    w3.forEach((i7) => {
      i7.x *= e5, i7.y *= t8;
    });
  }
  return { imageInfo: t7, rasterInfo: A2 };
}
function D(e4, t7) {
  if (t7.statistics = e4.statistics ?? t7.statistics, t7.histograms = e4.histograms, e4.histograms && null == t7.statistics && (t7.statistics = g2(e4.histograms)), e4.transform && null == t7.transform) {
    t7.transform = e4.transform, t7.nativeExtent = t7.extent;
    const i6 = t7.transform.forwardTransform(t7.nativeExtent);
    t7.pixelSize = new _({ x: (i6.xmax - i6.xmin) / t7.width, y: (i6.ymax - i6.ymin) / t7.height, spatialReference: t7.spatialReference }), t7.extent = i6;
  }
  t7.isPseudoSpatialReference && e4.spatialReference && (t7.spatialReference = e4.spatialReference, t7.extent.spatialReference = t7.nativeExtent.spatialReference = t7.storageInfo.origin.spatialReference = t7.spatialReference);
}
r([m2()], k4.prototype, "_files", void 0), r([m2()], k4.prototype, "_headerInfo", void 0), r([m2()], k4.prototype, "_bufferSize", void 0), r([m2()], k4.prototype, "_chunkSize", void 0), r([m2({ type: String, json: { write: true } })], k4.prototype, "datasetFormat", void 0), k4 = r([a("esri.layers.support.rasterDatasets.TIFFRaster")], k4);
var v3 = k4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var n4 = /* @__PURE__ */ new Map();
n4.set("MRF", { desc: "Meta Raster Format", constructor: b3 }), n4.set("TIFF", { desc: "GeoTIFF", constructor: v3 }), n4.set("RasterTileServer", { desc: "Raster Tile Server", constructor: I3 }), n4.set("JPG", { desc: "JPG Raster Format", constructor: d5 }), n4.set("PNG", { desc: "PNG Raster Format", constructor: d5 }), n4.set("GIF", { desc: "GIF Raster Format", constructor: d5 }), n4.set("BMP", { desc: "BMP Raster Format", constructor: d5 }), n4.set("CovJSON", { desc: "COVJSON Raster Format", constructor: h3 }), n4.set("MEMORY", { desc: "In Memory Raster Format", constructor: g3 });
var u5 = class {
  static get supportedFormats() {
    const t7 = /* @__PURE__ */ new Set();
    return n4.forEach((r7, e4) => t7.add(e4)), t7;
  }
  static async open(r7) {
    const { url: e4, ioConfig: s3, source: o5, sourceJSON: a4 } = r7;
    let c7 = r7.datasetFormat ?? s3?.datasetFormat;
    null == c7 && (e4.includes(".") ? c7 = e4.slice(e4.lastIndexOf(".") + 1).toUpperCase() : "coverage" === o5?.type?.toLowerCase() ? c7 = "CovJSON" : o5?.extent && o5.pixelblocks && (c7 = "MEMORY")), "OVR" === c7 || "TIF" === c7 ? c7 = "TIFF" : "JPG" === c7 || "JPEG" === c7 || "JFIF" === c7 ? c7 = "JPG" : "COVJSON" === c7 && (c7 = "CovJSON"), e4.toLowerCase().includes("/imageserver") && !e4.toLowerCase().includes("/wcsserver") && (c7 = "RasterTileServer");
    const u6 = { url: e4, source: o5, sourceJSON: a4, datasetFormat: c7, ioConfig: s3 ?? { bandIds: null, sampling: null } };
    if (Object.keys(u6).forEach((t7) => {
      null == u6[t7] && delete u6[t7];
    }), c7) {
      if (!this.supportedFormats.has(c7)) throw new s("rasterfactory:open", "not a supported format " + c7);
      if ("CRF" === c7) throw new s("rasterfactory:open", `cannot open raster: ${e4}`);
      const s4 = new (0, n4.get(c7).constructor)(u6);
      return await s4.open({ signal: r7.signal }), s4;
    }
    const i6 = Array.from(n4.keys()).filter((t7) => "CovJSON" !== t7 && "Memory" !== t7);
    let l5 = 0;
    const m10 = () => {
      if (c7 = i6[l5++], !c7) return null;
      if ("CRF" === c7) return null;
      const t7 = new (0, n4.get(c7).constructor)(u6);
      return t7.open({ signal: r7.signal }).then(() => t7).catch(() => m10());
    };
    return m10();
  }
  static register(t7, r7, e4) {
    n4.has(t7.toUpperCase()) || n4.set(t7.toUpperCase(), { desc: r7, constructor: e4 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var W2 = class extends p(t(b(j(o2(e(X(i3(c(l3(f2(S(a3.ClonableMixin(h))))))))))))) {
  constructor(...e4) {
    super(...e4), this._primaryRasters = [], this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.fields = null, this.source = void 0, this._debouncedSaveOperations = k(async (e5, t7, r7) => {
      const { save: s3, saveAs: i6 } = await import("./imageryUtils-JYE6ZWUM.js");
      switch (e5) {
        case A.SAVE:
          return s3(this, t7);
        case A.SAVE_AS:
          return i6(this, r7, t7);
      }
    });
  }
  normalizeCtorArgs(e4, t7) {
    return "string" == typeof e4 ? { url: e4, ...t7 } : e4;
  }
  load(e4) {
    const t7 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e4).catch(a2).then(() => this._openRaster(t7))), Promise.resolve(this);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    const e4 = [o("Pixel Value"), c3("Raw Pixel Value")], t7 = this.raster?.rasterInfo ?? this.serviceRasterInfo, r7 = t7?.attributeTable;
    if (r7) {
      const t8 = v(r7);
      e4.push(...t8);
    }
    const s3 = t7?.dataType, i6 = t7?.multidimensionalInfo;
    if (("vector-magdir" === s3 || "vector-uv" === s3) && null != i6) {
      const t8 = i6.variables[0].unit?.trim(), r8 = d2(t8), s4 = $();
      e4.push(r8, s4);
    }
    if (i6) {
      const t8 = p4(i6);
      e4.push(...t8);
    }
    return e4;
  }
  createPopupTemplate(e4) {
    const { rasterFields: t7 } = this, r7 = e4?.visibleFieldNames ?? new Set(t7.map(({ name: e5 }) => e5).filter((e5) => e5 !== t2.rawServicePixelValue)), s3 = p2({ fields: t7, title: this.title }, { ...e4, visibleFieldNames: r7 }), { rasterInfo: i6 } = this.raster;
    return s3?.fieldInfos && i6 && b2(s3.fieldInfos, i6), s3;
  }
  async generateRasterInfo(e4, t7) {
    if (e4 = m(N, e4), await this.load(), !e4 || "none" === e4.functionName?.toLowerCase()) return this.serviceRasterInfo;
    try {
      const { rasterInfo: r7 } = await this._openFunctionRaster(e4, t7);
      return r7;
    } catch (r7) {
      if (r7 instanceof s) throw r7;
      throw new s("imagery-tile-layer", "the given raster function is not supported");
    }
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, t7) {
    return this._debouncedSaveOperations(A.SAVE_AS, t7, e4);
  }
  write(e4, t7) {
    const r7 = this._primaryRasters[0] ?? this.raster;
    if (this.loaded ? "RasterTileServer" === r7.datasetFormat && ("Raster" === r7.tileType || "Map" === r7.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url)) return super.write(e4, t7);
    if (t7?.messages) {
      const e5 = `${t7.origin}/${t7.layerContainerType || "operational-layers"}`;
      t7.messages.push(new s("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e5}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e4) {
    let t7 = false;
    if (this.raster) await this._openFromRaster(this.raster, e4), t7 = r4(this.raster), !t7 && this.rasterFunction && (this._primaryRasters = [this.raster], await this._initializeWithFunctionRaster(this.rasterFunction));
    else {
      const { url: t8, rasterFunction: r8, source: i6 } = this;
      if (!t8 && !i6) throw new s("imagery-tile-layer:open", "missing url or source parameter");
      i6 ? await this._openFromSource(i6, e4) : r8 ? await this._openFromUrlWithRasterFunction(t8, r8, e4) : await this._openFromUrl(t8, e4);
    }
    const r7 = this.raster.rasterInfo;
    if (!r7) throw new s("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this._set("serviceRasterInfo", t7 ? r7 : this._primaryRasters[0].rasterInfo), this._set("spatialReference", r7.spatialReference), this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e5 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e5, { origin: "service" });
    } else this.read({ tileInfo: this.serviceRasterInfo?.storageInfo.tileInfo.toJSON() }, { origin: "service" });
    this.title || (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.addHandles(l(() => this.customParameters, (e5) => {
      this.raster && (this.raster.ioConfig.customFetchParameters = e5);
    }));
  }
  async _openFromRaster(e4, t7) {
    e4.rasterInfo || await e4.open({ signal: t7 }), this._primaryRasters = t4(e4), this.url || (this.url = this._primaryRasters[0].url);
  }
  async _openFromUrlWithRasterFunction(e4, t7, r7) {
    const i6 = [e4];
    t7 && w(t7.toJSON(), i6);
    const o5 = await Promise.all(i6.map((e5) => u5.open({ url: e5, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: r7 }))), a4 = o5.findIndex((e5) => null == e5);
    if (a4 > -1) throw new s("imagery-tile-layer:open", `cannot open raster: ${i6[a4]}`);
    return this._primaryRasters = o5, this._initializeWithFunctionRaster(t7);
  }
  async _openFromUrl(e4, t7) {
    const r7 = await u5.open({ url: e4, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t7 });
    if (null == r7) throw new s("imagery-tile-layer:open", `cannot open raster: ${e4}`);
    this._primaryRasters = [r7], this.raster = r7;
  }
  async _openFromSource(e4, t7) {
    const r7 = "the tiled imagery data source is not supported", i6 = "coverage" === e4.type?.toLowerCase() ? "CovJSON" : e4.extent && e4.pixelBlock ? "MEMORY" : null;
    if (!i6) throw new s("imagery-tile-layer:open", r7);
    "MEMORY" === i6 && (e4 = { ...e4, pixelBlock: void 0, pixelBlocks: [e4.pixelBlock] });
    const o5 = await u5.open({ url: "", source: e4, datasetFormat: i6, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t7 });
    if (null == o5) throw new s("imagery-tile-layer:open", r7);
    this._primaryRasters = [o5], this.rasterFunction ? await this._initializeWithFunctionRaster(this.rasterFunction) : this.raster = o5;
  }
  async _openFunctionRaster(e4, t7) {
    const r7 = { raster: this._primaryRasters[0] };
    this._primaryRasters.length > 1 && this._primaryRasters.forEach((e5) => r7[e5.url] = e5);
    const s3 = T2(e4.functionDefinition?.toJSON() ?? e4.toJSON(), r7), i6 = new m5({ rasterFunction: s3 });
    return await i6.open(t7), i6;
  }
  async _initializeWithFunctionRaster(e4, t7) {
    try {
      this.raster = await this._openFunctionRaster(e4, t7);
    } catch (r7) {
      r7 instanceof s && i.getLogger(this).error("imagery-tile-layer:open", r7.message), i.getLogger(this).warn("imagery-tile-layer:open", "the raster function cannot be applied and is removed"), this._set("rasterFunction", null), this.raster = this._primaryRasters[0];
    }
  }
};
r([m2({ clonable: false })], W2.prototype, "_primaryRasters", void 0), r([m2(d)], W2.prototype, "legendEnabled", void 0), r([m2({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], W2.prototype, "isReference", void 0), r([m2({ type: ["show", "hide"] })], W2.prototype, "listMode", void 0), r([m2({ json: { read: true, write: true } })], W2.prototype, "blendMode", void 0), r([m2({ type: N, json: { name: "renderingRule", write: true } })], W2.prototype, "rasterFunction", void 0), r([m2()], W2.prototype, "sourceJSON", void 0), r([m2({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], W2.prototype, "version", void 0), r([m2({ readOnly: true, json: { read: false } })], W2.prototype, "type", void 0), r([m2({ type: ["ArcGISTiledImageServiceLayer"] })], W2.prototype, "operationalLayerType", void 0), r([m2({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e4, t7) => !t7.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e4, t7, r7) {
  t7[r7] = !e4;
} } } })], W2.prototype, "popupEnabled", void 0), r([m2({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], W2.prototype, "popupTemplate", void 0), r([m2({ readOnly: true })], W2.prototype, "defaultPopupTemplate", null), r([m2({ readOnly: true, type: [m3] })], W2.prototype, "fields", void 0), r([m2({ readOnly: true, type: [m3] })], W2.prototype, "rasterFields", null), r([m2({ constructOnly: true })], W2.prototype, "source", void 0), W2 = r([a("esri.layers.ImageryTileLayer")], W2);
var k5 = W2;
export {
  k5 as default
};
//# sourceMappingURL=ImageryTileLayer-XEBOBWOQ.js.map
