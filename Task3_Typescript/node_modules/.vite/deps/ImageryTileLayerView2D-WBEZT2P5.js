import {
  d as d2,
  f as f2,
  h as h5
} from "./chunk-XJ2T6IH5.js";
import {
  c as c2,
  l as l3,
  m as m3,
  s as s2
} from "./chunk-2IBYGDQY.js";
import {
  i as i6
} from "./chunk-5FFOLNHT.js";
import {
  i as i5
} from "./chunk-CEMHA5WX.js";
import {
  S as S3
} from "./chunk-YR4BEFGH.js";
import {
  u as u3
} from "./chunk-EEB2RHCK.js";
import {
  i as i4
} from "./chunk-MGE3DVJJ.js";
import {
  D as D2,
  z as z2
} from "./chunk-A4YQJHJZ.js";
import {
  At,
  B as B2,
  Bt,
  C as C3,
  C2 as C4,
  Ce,
  Ct,
  Ge,
  Gt,
  Ht,
  It,
  J,
  Jt,
  K,
  Lt,
  P as P2,
  Pt,
  Qt,
  Rn,
  Rt,
  Te,
  Tt,
  U as U2,
  Ue,
  Ut,
  W,
  We,
  Wt,
  X as X2,
  Xe,
  Xt,
  Y,
  Ye,
  Yt,
  Z,
  Zt,
  _ as _2,
  _2 as _3,
  _t,
  an,
  ce,
  cn,
  f,
  fn,
  g as g3,
  he,
  hn,
  ie,
  j as j2,
  jt,
  ln,
  m as m2,
  ne,
  oe,
  pn,
  q,
  qe,
  qt,
  re,
  rt,
  se,
  sn,
  st,
  t as t4,
  ue,
  un,
  ut,
  v,
  w,
  xe as xe2,
  xt,
  ye,
  yn,
  ze,
  zt
} from "./chunk-JSDQVIZI.js";
import {
  r as r7
} from "./chunk-GEY3MNEN.js";
import {
  e as e3
} from "./chunk-QARUBZM2.js";
import {
  R
} from "./chunk-YEQJ7SMN.js";
import "./chunk-F6HYAIOQ.js";
import "./chunk-733XT7D4.js";
import "./chunk-O3AUTEBE.js";
import "./chunk-73JRZP7E.js";
import {
  t as t3
} from "./chunk-I7SMTGBD.js";
import "./chunk-TAPCW5Z5.js";
import "./chunk-JOUWZB2W.js";
import "./chunk-CF5GNPLI.js";
import "./chunk-5WTH3GBK.js";
import {
  a as a3,
  g,
  i as i3,
  u as u2
} from "./chunk-23ZUIA4B.js";
import {
  x
} from "./chunk-N6VYJNA5.js";
import {
  C as C2,
  O,
  ee,
  me,
  xe
} from "./chunk-Z5EDZREM.js";
import {
  V,
  n as n2,
  o2,
  t
} from "./chunk-623AYJP2.js";
import {
  S,
  c,
  o as o3
} from "./chunk-NXHGFG67.js";
import {
  r as r4
} from "./chunk-3NJEC7QC.js";
import "./chunk-A4KKV2O6.js";
import {
  p
} from "./chunk-WEJSS4SJ.js";
import "./chunk-IAKXH7PU.js";
import "./chunk-DRLVYVHZ.js";
import "./chunk-DKS7UUDR.js";
import "./chunk-KDQWOWXR.js";
import "./chunk-JOVQBCRD.js";
import "./chunk-GYAK76KG.js";
import "./chunk-NHBIV3BK.js";
import "./chunk-KB5I2WHB.js";
import "./chunk-P3YYANTX.js";
import "./chunk-Y2ZAHGIO.js";
import {
  l as l2
} from "./chunk-PVI3IOCA.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-GKCEBA6Q.js";
import "./chunk-VWMPQK5V.js";
import {
  e as e2,
  o2 as o4
} from "./chunk-IGBV77N3.js";
import "./chunk-5Y3EUPZN.js";
import {
  mt
} from "./chunk-55AFRDJF.js";
import "./chunk-F5C72MOD.js";
import {
  p as p2,
  r as r6
} from "./chunk-YBXGYFQH.js";
import {
  h as h4
} from "./chunk-NFDUQVJM.js";
import {
  E
} from "./chunk-3PPDORWL.js";
import {
  h as h3
} from "./chunk-YIXK32VF.js";
import {
  t as t2
} from "./chunk-CHTPXQAG.js";
import "./chunk-2NTKYBCL.js";
import {
  g as g2
} from "./chunk-BDWOUZQR.js";
import "./chunk-H34ENSPL.js";
import {
  S as S2,
  a as a2
} from "./chunk-H6F6O2KE.js";
import "./chunk-AF3FX2UV.js";
import {
  M,
  b as b3,
  h as h2,
  i as i2,
  o,
  r as r3
} from "./chunk-DRAQJS2F.js";
import {
  A,
  B,
  C,
  D,
  L,
  P,
  X
} from "./chunk-BZYXFNL4.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-TMFB3DKM.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-NO2XQDLB.js";
import "./chunk-LBC3MAJX.js";
import {
  j
} from "./chunk-3ZORAHSR.js";
import "./chunk-SZN55B2M.js";
import "./chunk-NMP7ZOVG.js";
import "./chunk-YHYQP7QX.js";
import {
  a as a4
} from "./chunk-RP7FUW55.js";
import {
  r as r5
} from "./chunk-MPV4X4LZ.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-6WL2SHX6.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-VUGQF5TL.js";
import "./chunk-ZAISHGSP.js";
import "./chunk-KHRHKYU2.js";
import {
  d
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import {
  u
} from "./chunk-6GWORUT3.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  U,
  h,
  l
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  b as b2,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  e,
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  b,
  k,
  n,
  r2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  has
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterBitmap.js
var m4 = { bandCount: 3, minOutput: 0, maxOutput: 1, minCutOff: [0, 0, 0], maxCutOff: [255, 255, 255], factor: [1 / 255, 1 / 255, 1 / 255], useGamma: false, gamma: [1, 1, 1], gammaCorrection: [1, 1, 1], colormap: null, colormapOffset: null, stretchType: "none", type: "stretch" };
var c3 = class extends e3 {
  constructor(t10 = null, e5 = null, s6 = null) {
    super(), this._textureInvalidated = true, this._colormapTextureInvalidated = true, this._rasterTexture = null, this._maskTexture = null, this._rasterTextureBandIds = null, this._transformGridTexture = null, this._colormapTexture = null, this._colormap = null, this._supportsBilinearTexture = true, this._processedTexture = null, this.functionTextures = [], this.projected = false, this.stencilRef = 0, this.coordScale = [1, 1], this._processed = false, this._symbolizerParameters = null, this.height = null, this.isRendereredSource = false, this.pixelRatio = 1, this.resolution = 0, this.rotation = 0, this._source = null, this._mask = null, this.rawPixelData = null, this._suspended = false, this._bandIds = null, this._interpolation = null, this._transformGrid = null, this.width = null, this.x = 0, this.y = 0, this.source = t10, this.transformGrid = e5, this.interpolation = s6;
  }
  destroy() {
    this._disposeTextures();
  }
  get processedTexture() {
    return this._processedTexture;
  }
  set processedTexture(t10) {
    this._processedTexture !== t10 && (this._disposeTextures(true), this._processedTexture = t10);
  }
  get rasterTexture() {
    return this._rasterTexture;
  }
  set rasterTexture(t10) {
    this._rasterTexture !== t10 && (this._rasterTexture?.dispose(), this._rasterTexture = t10), null == t10 && (this.projected = false);
  }
  get processed() {
    return this._processed;
  }
  set processed(e5) {
    this._processed = e5, e5 || (this.processedTexture = r2(this.processedTexture), this.invalidateTexture());
  }
  get symbolizerParameters() {
    return this._symbolizerParameters || m4;
  }
  set symbolizerParameters(t10) {
    this._symbolizerParameters !== t10 && (this._symbolizerParameters = t10, this._colormapTextureInvalidated = true);
  }
  get source() {
    return this._source;
  }
  set source(e5) {
    this._source !== e5 && (this._source = e5, this._rasterTexture && (this._rasterTexture = r2(this._rasterTexture), this._rasterTextureBandIds = null), this.projected = false, this.invalidateTexture());
  }
  get mask() {
    return this._mask;
  }
  set mask(e5) {
    this._mask !== e5 && (this._mask = e5, this._maskTexture = r2(this._maskTexture));
  }
  get suspended() {
    return this._suspended;
  }
  set suspended(t10) {
    this._suspended && !t10 && this.stage && (this.ready(), this.requestRender()), this._suspended = t10;
  }
  get bandIds() {
    return this._bandIds;
  }
  set bandIds(t10) {
    this._bandIds = t10, this._isBandIdsChanged(t10) && (this.projected = false, this.invalidateTexture());
  }
  get interpolation() {
    return this._interpolation || "nearest";
  }
  set interpolation(t10) {
    this._interpolation = t10, this._rasterTexture && this._rasterTexture.setSamplingMode("bilinear" === this._getTextureSamplingMethod(t10 || "nearest") ? L.LINEAR : L.NEAREST);
  }
  get transformGrid() {
    return this._transformGrid;
  }
  set transformGrid(e5) {
    this._transformGrid !== e5 && (this._transformGrid = e5, this._transformGridTexture = r2(this._transformGridTexture));
  }
  invalidateTexture() {
    this._textureInvalidated || (this._textureInvalidated = true, this.requestRender());
  }
  getRasterTextureSize(t10 = false) {
    const e5 = t10 || this.projected;
    return [e5 ? this.width : this.source?.width || this.width, e5 ? this.height : this.source?.height || this.height];
  }
  getRasterCellSize() {
    const t10 = this.rawPixelData?.srcPixelSize, { projected: e5, resolution: s6 } = this;
    return t10 && !e5 ? [t10.x, t10.y] : [s6, s6];
  }
  _createTransforms() {
    return { displayViewScreenMat3: e2() };
  }
  setTransform(t10) {
    const h16 = o(this.transforms.displayViewScreenMat3), [u5, n7] = t10.toScreenNoRotation([0, 0], [this.x, this.y]), l7 = this.resolution / this.pixelRatio / t10.resolution, d6 = l7 * this.width, _6 = l7 * this.height, x6 = Math.PI * this.rotation / 180;
    M(h16, h16, r5(u5, n7)), M(h16, h16, r5(d6 / 2, _6 / 2)), h2(h16, h16, -x6), M(h16, h16, r5(-d6 / 2, -_6 / 2)), b3(h16, h16, r5(d6, _6)), i2(this.transforms.displayViewScreenMat3, t10.displayViewMat3, h16);
  }
  getTextures({ forProcessing: t10 = false, useProcessedTexture: e5 = false } = {}) {
    const s6 = e5 ? this._processedTexture ?? this._rasterTexture : this._rasterTexture, r17 = [], i11 = [];
    return s6 ? (this._transformGridTexture && !this.projected && (i11.push(this._transformGridTexture), r17.push("u_transformGrid")), i11.push(s6), r17.push("u_image"), !this._colormapTexture || !e5 && t10 || (i11.push(this._colormapTexture), r17.push("u_colormap")), this._maskTexture && (i11.push(this._maskTexture), r17.push("u_mask")), { names: r17, textures: i11 }) : { names: r17, textures: i11 };
  }
  onAttach() {
    this.invalidateTexture();
  }
  onDetach() {
    this.invalidateTexture();
  }
  updateTexture({ context: t10 }) {
    if (!this.stage) return void this._disposeTextures();
    const e5 = this._isValidSource(this.source);
    e5 && this._colormapTextureInvalidated && (this._colormapTextureInvalidated = false, this._updateColormapTexture(t10)), this._textureInvalidated && (this._textureInvalidated = false, this._createOrDestroyRasterTexture(t10), this._rasterTexture && (e5 ? (this.transformGrid && !this._transformGridTexture && (this._transformGridTexture = m3(t10, this.transformGrid)), this._mask && !this._maskTexture && (this._maskTexture = c2(t10, this._mask, [this.width, this.height]))) : this._rasterTexture.setData(null)), this.suspended || (this.ready(), this.requestRender()));
  }
  updateProcessedTexture() {
    const { functionTextures: t10 } = this;
    0 !== t10.length && (this.processedTexture = t10.shift(), t10.forEach((t11) => t11?.dispose()), t10.length = 0, this.processed = !!this.processedTexture);
  }
  _createOrDestroyRasterTexture(e5) {
    const s6 = this.source?.extractBands(this.bandIds);
    if (!this._isValidSource(s6)) return void (this._rasterTexture && (this._rasterTexture = r2(this._rasterTexture), this._rasterTextureBandIds = null));
    const r17 = !this._isBandIdsChanged(this.bandIds);
    if (this._rasterTexture) {
      if (r17) return;
      this._rasterTexture = r2(this._rasterTexture), this._rasterTextureBandIds = null;
    }
    this._supportsBilinearTexture = !!e5.capabilities.textureFloatLinear;
    const i11 = this._getTextureSamplingMethod(this.interpolation), a12 = this.isRendereredSource;
    this._rasterTexture = s2(e5, s6, i11, a12), this.projected = false, this._processed = false, this._rasterTextureBandIds = this.bandIds ? [...this.bandIds] : null;
  }
  _isBandIdsChanged(t10) {
    const e5 = this._rasterTextureBandIds;
    return !(null == e5 && null == t10 || e5 && t10 && e5.join("") === t10.join(""));
  }
  _isValidSource(t10) {
    return null != t10 && t10.pixels?.length > 0;
  }
  _getTextureSamplingMethod(t10) {
    const { type: e5 } = this.symbolizerParameters, s6 = "lut" === e5 && !this.symbolizerParameters.isClassBreaks || "hillshade" === e5 || "stretch" === e5 && 1 === this.symbolizerParameters.bandCount;
    return !this._supportsBilinearTexture || s6 || "bilinear" !== t10 && "cubic" !== t10 ? "nearest" : "bilinear";
  }
  _updateColormapTexture(e5) {
    const s6 = this._colormap, r17 = this.symbolizerParameters.colormap;
    return r17 ? s6 ? r17.length !== s6.length || r17.some((t10, e6) => t10 !== s6[e6]) ? (this._colormapTexture && (this._colormapTexture = r2(this._colormapTexture)), this._colormapTexture = l3(e5, r17), void (this._colormap = r17)) : void 0 : (this._colormapTexture = l3(e5, r17), void (this._colormap = r17)) : (this._colormapTexture && (this._colormapTexture = r2(this._colormapTexture)), void (this._colormap = null));
  }
  _disposeTextures(e5 = false) {
    e5 ? this.projected && (this._transformGridTexture = r2(this._transformGridTexture)) : (this._rasterTexture = r2(this._rasterTexture), this._colormapTexture = r2(this._colormapTexture), this._transformGridTexture = r2(this._transformGridTexture), this._maskTexture = r2(this._maskTexture), this._rasterTextureBandIds = null, this._colormap = null, this._colormapTextureInvalidated = true), this._processedTexture = r2(this._processedTexture);
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterTile.js
var i7 = class extends r7 {
  constructor(t10, e5, i11, a12, r17, l7, n7 = null) {
    super(t10, e5, i11, a12, r17, l7), this.bitmap = null, this.bitmap = new c3(n7, null, null), this.bitmap.coordScale = [r17, l7], this.bitmap.once("isReady", () => this.ready());
  }
  destroy() {
    super.destroy(), this.bitmap.destroy(), this.bitmap = null, this.stage = null;
  }
  set stencilRef(t10) {
    this.bitmap.stencilRef = t10;
  }
  get stencilRef() {
    return this.bitmap.stencilRef;
  }
  setTransform(t10) {
    super.setTransform(t10), this.bitmap.transforms.displayViewScreenMat3 = this.transforms.displayViewScreenMat3;
  }
  _createTransforms() {
    return { displayViewScreenMat3: e2(), tileMat3: e2() };
  }
  onAttach() {
    this.bitmap.stage = this.stage;
  }
  onDetach() {
    this.bitmap.stage = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/sampleBilinear.js
function m5(m12, p6, r17, u5) {
  const x6 = ze(p6.multiply(r17)), o10 = new Z(new W(x6.x), new W(x6.y)), s6 = new Z(o10.x.add(1), o10.y), f8 = new Z(o10.x, o10.y.add(1)), c11 = new Z(o10.x.add(1), o10.y.add(1)), g9 = pn(m12, o10, new W(0)), j4 = pn(m12, s6, new W(0)), h16 = pn(m12, f8, new W(0)), z5 = pn(m12, c11, new W(0)), b5 = Te(p6.multiply(r17)), k2 = Ye(g9, j4, b5.x), q2 = Ye(h16, z5, b5.x), v6 = Ye(k2, q2, b5.y);
  if (!u5) return v6;
  const A2 = new Y(g9.a, j4.a, h16.a, z5.a), B3 = A2.xy.multiply(A2.zw), C7 = ze(B3.x.multiply(B3.y).add(0.5)), D3 = v6.multiply(C7), E3 = D2(C7).multiply(yn(m12, p6));
  return D3.add(E3);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/projection.js
var S4 = class extends P2 {
};
function v2(e5, r17) {
  const t10 = yn(r17.transformTexture, e5);
  return new C3(t10.r, t10.g);
}
function j3(e5, r17) {
  const { transformTexture: t10, targetImageSize: n7, transformSpacing: i11 } = r17, s6 = ze(e5.multiply(n7)), l7 = new C3(4, 1), w5 = ze(s6.divide(i11)).multiply(l7), g9 = Te(s6.add(new C3(0.5, 0.5)).divide(i11)), y5 = new Z(st(w5.x), st(w5.y)), x6 = new X2(g9, 1);
  return zt(Yt(g9.x, g9.y), h6(t10, y5, x6), z3(t10, y5, x6));
}
function h6(e5, r17, t10) {
  const n7 = pn(e5, r17, new W(0)), i11 = new Z(r17.x.add(1), r17.y), s6 = pn(e5, i11, new W(0));
  return new C3(ye(n7.rgb, t10), ye(s6.rgb, t10));
}
function z3(e5, r17, t10) {
  const n7 = new Z(r17.x.add(2), r17.y), i11 = pn(e5, n7, new W(0)), s6 = new Z(r17.x.add(3), r17.y), u5 = pn(e5, s6, new W(0));
  return new C3(ye(i11.rgb, t10), ye(u5.rgb, t10));
}
function I(e5) {
  const r17 = ln(new C3(-1e-5, -1e-5), e5).multiply(ln(e5, new C3(1.00001, 1.00001))), t10 = D2(r17.x.multiply(r17.y));
  return new J(t10);
}
function T(e5, r17, t10 = false) {
  return r17 ? t10 ? v2(e5, r17) : j3(e5, r17) : e5;
}
function G(e5, r17, t10) {
  const { bicubic: n7 = false, bilinear: o10 = false, nearestOnEdge: i11 = false } = t10 ?? {};
  return n7 || o10 ? m5(r17.texture, e5, r17.srcImageSize, i11) : yn(r17.texture, e5);
}
r([g3(U2)], S4.prototype, "transformTexture", void 0), r([g3(C3)], S4.prototype, "targetImageSize", void 0), r([g3(C3)], S4.prototype, "transformSpacing", void 0), r([g3(C3)], S4.prototype, "transformGridSize", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/BaseRasterColorizerShader.js
var w2 = class extends C4 {
};
r([f(0, C3)], w2.prototype, "position", void 0);
var C5 = class extends v {
};
var _4 = class extends P2 {
};
r([g3(U2)], _4.prototype, "texture", void 0), r([g3(rt)], _4.prototype, "dvsMat3", void 0), r([g3(C3)], _4.prototype, "coordScale", void 0), r([g3(C3)], _4.prototype, "srcImageSize", void 0), r([g3(_2)], _4.prototype, "opacity", void 0);
var E2 = class extends P2 {
};
r([g3(U2)], E2.prototype, "maskTexture", void 0);
var O2 = class extends j2 {
  constructor() {
    super(...arguments), this.applyProjection = true, this.lookupProjection = false, this.bilinear = false, this.bicubic = false, this.nearestOnEdge = false, this.applyPixelMask = false;
  }
  vertex(o10) {
    const t10 = o10.position, { dvsMat3: e5, coordScale: i11 } = this.config, p6 = e5.multiply(new X2(t10.multiply(i11), 1));
    return { uv: t10, glPosition: new Y(p6, 1) };
  }
  fragment(o10) {
    const t10 = new w(), e5 = T(o10.uv, this.applyProjection ? this.projectionConfig : void 0, this.lookupProjection), p6 = zt(I(e5), new Y(0, 0, 0, 0), this._colorize(e5));
    let r17 = p6.a.multiply(this.config.opacity);
    if (this.applyPixelMask) {
      const t11 = this._getPixelMask(o10.uv);
      r17 = r17.multiply(t11);
    }
    return t10.fragColor = new Y(p6.rgb, 1).multiply(r17), t10;
  }
  _getPixel(o10) {
    const { config: t10, bicubic: e5, bilinear: i11, nearestOnEdge: p6 } = this;
    return G(o10, t10, { bicubic: e5, bilinear: i11, nearestOnEdge: p6 });
  }
  _getPixelMask(o10) {
    const { maskTexture: t10 } = this.pixelMaskConfig, e5 = yn(t10, o10);
    return cn(e5.a);
  }
};
r([K], O2.prototype, "applyProjection", void 0), r([K], O2.prototype, "lookupProjection", void 0), r([K], O2.prototype, "bilinear", void 0), r([K], O2.prototype, "bicubic", void 0), r([K], O2.prototype, "nearestOnEdge", void 0), r([K], O2.prototype, "applyPixelMask", void 0), r([g3(_4)], O2.prototype, "config", void 0), r([_3(S4)], O2.prototype, "projectionConfig", void 0), r([_3(E2)], O2.prototype, "pixelMaskConfig", void 0), r([e(0, m2(w2))], O2.prototype, "vertex", null), r([e(0, m2(C5))], O2.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/lut.js
var i8 = class extends P2 {
};
function n3(o10, r17, t10, d6 = true) {
  const { colormapTexture: i11, colormapOffset: n7, colormapMaxIndex: c11 } = t10, u5 = o10.r.multiply(r17).subtract(n7), x6 = ue(u5, new _2(0), c11), f8 = new C3(x6.add(0.5).divide(c11.add(1)), 0), y5 = yn(i11, f8), h16 = new Y(y5.rgb, y5.a.multiply(o10.a));
  if (d6) return h16;
  const v6 = ln(new _2(0), u5).multiply(ln(u5, t10.colormapMaxIndex));
  return h16.multiply(v6);
}
r([g3(U2)], i8.prototype, "colormapTexture", void 0), r([g3(_2)], i8.prototype, "colormapOffset", void 0), r([g3(_2)], i8.prototype, "colormapMaxIndex", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/RasterColorizerLUTShader.js
var p3 = class extends O2 {
  constructor() {
    super(...arguments), this.type = "RasterColorizerLUTShader";
  }
  _colorize(r17) {
    const o10 = this._getPixel(r17);
    return n3(o10, new _2(1), this.colormapConfig, false);
  }
};
r([g3(i8)], p3.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/colorConversion.js
function a5(r17) {
  const u5 = new Y(0, -1 / 3, 2 / 3, -1), i11 = zt(Xt(r17.y, r17.z), new Y(r17.zy, u5.wz), new Y(r17.yz, u5.xy)), a12 = zt(Xt(r17.x, i11.x), new Y(i11.xyw, r17.x), new Y(r17.x, i11.yzx)), c11 = a12.x.subtract(Xe(a12.w, a12.y)), l7 = new _2(1e-10), s6 = a12.w.subtract(a12.y), z5 = c11.multiply(6).add(l7), o10 = Qt(s6.divide(z5).add(a12.z)), p6 = a12.x.add(l7), m12 = Xe(c11.divide(p6), new _2(1));
  return new X2(o10, m12, a12.x);
}
function c4(n7) {
  const t10 = new Y(1, 2 / 3, 1 / 3, 3), w5 = Qt(Te(n7.xxx.add(t10.xyz)).multiply(6).subtract(t10.www)), e5 = ue(w5.subtract(t10.xxx), new X2(0, 0, 0), new X2(1));
  return n7.z.multiply(Ye(t10.xxx, e5, n7.y));
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/surface.js
var a6 = class extends P2 {
};
function y(n7) {
  const t10 = Qt(n7), e5 = ln(t10, new C3(1, 1)).multiply(t10), o10 = new _2(2).subtract(t10), r17 = ln(new _2(1), t10).multiply(o10);
  return e5.add(r17);
}
function m6(n7, t10, e5) {
  const l7 = new _2(1).divide(e5), p6 = yn(n7, y(l7.multiply(new C3(-1, -1)).add(t10))), w5 = yn(n7, y(l7.multiply(new C3(0, -1)).add(t10))), c11 = yn(n7, y(l7.multiply(new C3(1, -1)).add(t10))), u5 = yn(n7, y(l7.multiply(new C3(-1, 0)).add(t10))), a12 = yn(n7, y(t10)), m12 = yn(n7, y(l7.multiply(new C3(1, 0)).add(t10))), f8 = yn(n7, y(l7.multiply(new C3(-1, 1)).add(t10))), Z3 = yn(n7, y(l7.multiply(new C3(0, 1)).add(t10))), x6 = yn(n7, y(l7.multiply(new C3(1, 1)).add(t10))), z5 = new Y(p6.a, w5.a, c11.a, u5.a), A2 = new Y(m12.a, f8.a, Z3.a, x6.a), h16 = z5.multiply(A2), g9 = h16.xy.multiply(h16.zw), v6 = g9.x.multiply(g9.y).multiply(a12.a), b5 = new B2(new _2(0), 10);
  return b5[0] = p6.r, b5[1] = w5.r, b5[2] = c11.r, b5[3] = u5.r, b5[4] = a12.r, b5[5] = m12.r, b5[6] = f8.r, b5[7] = Z3.r, b5[8] = x6.r, b5[9] = v6, b5;
}
function f3(n7, t10) {
  const e5 = new Y(n7[5], n7[3], n7[7], n7[1]).multiply(2), i11 = new X2(n7[2], e5[0], n7[8]), o10 = new X2(n7[0], e5[1], n7[6]), d6 = ye(i11.subtract(o10), new X2(1)), l7 = new X2(n7[6], e5[2], n7[8]), c11 = new X2(n7[0], e5[3], n7[2]), u5 = ye(l7.subtract(c11), new X2(1));
  return new C3(d6, u5).multiply(t10);
}
function Z2(n7, t10, e5) {
  const { factor: o10 } = t10, s6 = f3(n7, o10), d6 = hn(ye(s6, s6).add(1)), c11 = n7[9], { sinZsinAs: u5, sinZcosAs: a12, cosZs: y5, weights: m12 } = t10;
  if (!e5) {
    const n8 = x2({ sinZsinA: u5[0], sinZcosA: a12[0], cosZ: y5[0], weights: new _2(1), dzxy: s6, dzd: d6 });
    return new Y(n8, n8, n8, c11);
  }
  const Z3 = x2({ sinZsinA: new X2(u5[0], u5[1], u5[2]), sinZcosA: new X2(a12[0], a12[1], a12[2]), cosZ: new X2(y5[0], y5[1], y5[2]), weights: new X2(m12[0], m12[1], m12[2]), dzxy: s6, dzd: d6 }), z5 = x2({ sinZsinA: new X2(u5[3], u5[4], u5[5]), sinZcosA: new X2(a12[3], a12[5], a12[5]), cosZ: new X2(y5[3], y5[4], y5[5]), weights: new X2(m12[3], m12[4], m12[5]), dzxy: s6, dzd: d6 }), A2 = ye(Z3.add(z5), new X2(1));
  return new Y(A2, A2, A2, c11);
}
function x2(n7) {
  const t10 = n7.sinZsinA.multiply(n7.dzxy.y), e5 = n7.sinZcosA.multiply(n7.dzxy.x), o10 = t10.subtract(e5), s6 = n7.cosZ.add(o10).divide(n7.dzd);
  return s6.multiply(ln(new _2(0), s6)).multiply(n7.weights);
}
function z4(n7, t10) {
  const { pixelSizeFactor: e5 } = n7, i11 = [n7.factor[0] / t10[0], n7.factor[1] / t10[1]];
  if (e5 > 0) {
    const { zFactor: o10, pixelSizePower: s6, gcsFactor: r17 } = n7, d6 = t10[0] * r17, l7 = t10[1] * r17;
    i11[0] = (o10 + d6 ** s6 * e5) / (8 * d6), i11[1] = (o10 + l7 ** s6 * e5) / (8 * l7);
  }
  return i11;
}
r([g3(B2.ofType(_2, 6))], a6.prototype, "sinZcosAs", void 0), r([g3(B2.ofType(_2, 6))], a6.prototype, "sinZsinAs", void 0), r([g3(B2.ofType(_2, 6))], a6.prototype, "cosZs", void 0), r([g3(B2.ofType(_2, 6))], a6.prototype, "weights", void 0), r([g3(_2)], a6.prototype, "minValue", void 0), r([g3(_2)], a6.prototype, "maxValue", void 0), r([g3(C3)], a6.prototype, "factor", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/RasterColorizerShadedReliefShader.js
var g4 = class extends O2 {
  constructor() {
    super(...arguments), this.type = "RasterColorizerShadedReliefShader", this.applyColormap = false, this.isMultidirectional = false;
  }
  _colorize(o10) {
    const { texture: i11 } = this.config, r17 = m6(i11, o10, this.config.srcImageSize), t10 = Z2(r17, this.hillshadeConfig, this.isMultidirectional);
    if (!this.applyColormap) return new Y(t10.x, t10.x, t10.x, t10.a);
    const { minValue: p6, maxValue: c11 } = this.hillshadeConfig, u5 = this._getPixel(o10), g9 = c11.subtract(p6), x6 = u5.r.subtract(p6), y5 = ue(x6.divide(g9), new _2(0), new _2(1)), C7 = n3(new Y(y5, y5, y5, 1), new _2(255), this.colormapConfig), j4 = a5(C7.xyz), w5 = c4(new X2(j4.xy, t10.x));
    return new Y(w5, C7.a.multiply(t10.a));
  }
};
r([K], g4.prototype, "applyColormap", void 0), r([K], g4.prototype, "isMultidirectional", void 0), r([g3(a6)], g4.prototype, "hillshadeConfig", void 0), r([_3(i8)], g4.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/stretch.js
var f4 = class extends P2 {
};
function s3(t10, o10) {
  const { minCutOff: i11, maxCutOff: r17, factor: m12, minOutput: p6 } = o10;
  return ue(t10, i11, r17).subtract(i11).multiply(m12).add(p6);
}
function l4(t10, o10) {
  const { minCutOff: i11, maxCutOff: r17, minOutput: f8, maxOutput: s6, gamma: l7, gammaCorrection: c11 } = o10, y5 = ue(t10, i11, r17).subtract(i11), v6 = r17.subtract(i11), O3 = y5.divide(v6), b5 = ln(new _2(1), l7), g9 = cn(l7.subtract(1)), C7 = s6.subtract(f8), x6 = new X2(1), h16 = We(x6.divide(C7), O3.multiply(c11)), j4 = D2(b5.multiply(g9).multiply(h16)), w5 = We(O3, x6.divide(l7)), k2 = j4.multiply(C7).multiply(w5).add(f8);
  return ue(k2, f8, s6);
}
function c5(t10, o10, i11, u5 = 255) {
  const m12 = i11 ? l4(t10.rgb, o10).divide(u5) : s3(t10.rgb, o10);
  return new Y(m12, t10.a);
}
r([g3(_2)], f4.prototype, "minOutput", void 0), r([g3(_2)], f4.prototype, "maxOutput", void 0), r([g3(X2)], f4.prototype, "minCutOff", void 0), r([g3(X2)], f4.prototype, "maxCutOff", void 0), r([g3(X2)], f4.prototype, "factor", void 0), r([g3(X2)], f4.prototype, "gamma", void 0), r([g3(X2)], f4.prototype, "gammaCorrection", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/RasterColorizerStretchShader.js
var n4 = class extends O2 {
  constructor() {
    super(...arguments), this.type = "RasterColorizerStretchShader", this.isMultiband = true, this.applyColormap = false, this.useGamma = false, this.noOp = false;
  }
  _colorize(o10) {
    const t10 = this._getPixel(o10);
    if (this.noOp) return t10;
    let r17 = c5(t10, this.stretchConfig, this.useGamma);
    if (this.isMultiband) return r17;
    if (r17 = new Y(r17.rrr, r17.a), this.applyColormap) {
      const o11 = this.useGamma ? 255 : 1;
      r17 = n3(r17, new _2(o11), this.colormapConfig);
    }
    return r17;
  }
};
r([K], n4.prototype, "isMultiband", void 0), r([K], n4.prototype, "applyColormap", void 0), r([K], n4.prototype, "useGamma", void 0), r([K], n4.prototype, "noOp", void 0), r([g3(f4)], n4.prototype, "stretchConfig", void 0), r([_3(i8)], n4.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/RasterColorizerTechnique.js
var a7 = class extends t4 {
  constructor() {
    super(...arguments), this.name = "BrushRasterColorizer", this.type = t3.RasterColorizer, this.shaders = { lut: new p3(), stretch: new n4(), shadedRelief: new g4() };
  }
  render(e5, t10) {
    for (const o10 of t10.bitmaps) {
      if (!o10.source || o10.suspended) continue;
      e5.timeline.begin(this.name);
      const { painter: t11 } = e5;
      t11.setPipelineState({ depth: false, stencil: { test: { mask: 255, ref: o10.stencilRef, compare: C.EQUAL, op: { fail: D.KEEP, zFail: D.KEEP, zPass: D.KEEP } }, write: false }, color: { write: [true, true, true, true], blendMode: "composite" } }), o10.updateTexture(e5), o10.processedTexture || o10.updateProcessedTexture();
      const { type: i11 } = o10.symbolizerParameters, r17 = "stretch" === i11 ? this._getStretchOptions(o10) : "lut" === i11 ? this._getLutOptions(o10) : this._getShadedReliefOptions(o10);
      "bilinear" !== o10.interpolation || e5.context.capabilities.textureFloatLinear || (r17.defines.bilinear = true), t11.submitDrawMesh(e5.context, r17, t11.quadMesh), e5.timeline.end(this.name);
    }
  }
  _getLutOptions(e5) {
    const { config: t10, projectionConfig: o10, colormapConfig: i11, pixelMaskConfig: r17, projectionDefines: s6 } = this._getCommonConfig(e5), n7 = this._getInterpolationDefines("nearest", false);
    return { shader: this.shaders.lut, uniforms: { projectionConfig: o10, config: t10, colormapConfig: i11, pixelMaskConfig: r17 }, defines: { ...s6, ...n7, applyPixelMask: !!r17 }, optionalAttributes: null, useComputeBuffer: false };
  }
  _getStretchOptions(e5) {
    const t10 = e5.symbolizerParameters, { config: o10, projectionConfig: i11, colormapConfig: r17, pixelMaskConfig: s6, projectionDefines: n7 } = this._getCommonConfig(e5), a12 = this._getInterpolationDefines(e5.interpolation, 1 === t10.bandCount);
    return { shader: this.shaders.stretch, uniforms: { projectionConfig: i11, config: o10, stretchConfig: t10, colormapConfig: r17, pixelMaskConfig: s6 }, defines: { ...n7, ...a12, isMultiband: t10.bandCount > 1, applyColormap: !!r17, useGamma: t10.useGamma, noOp: e5.isRendereredSource && !e5.processed, applyPixelMask: !!s6 }, optionalAttributes: null, useComputeBuffer: false };
  }
  _getShadedReliefOptions(e5) {
    const t10 = e5.symbolizerParameters, { config: o10, projectionConfig: i11, colormapConfig: r17, pixelMaskConfig: s6, projectionDefines: n7 } = this._getCommonConfig(e5), a12 = this._getInterpolationDefines(e5.interpolation, true);
    return { shader: this.shaders.shadedRelief, uniforms: { projectionConfig: i11, config: o10, hillshadeConfig: t10, colormapConfig: r17, pixelMaskConfig: s6 }, defines: { ...n7, ...a12, isMultidirectional: t10.hillshadeType > 0, applyColormap: !!r17, applyPixelMask: !!s6 }, optionalAttributes: null, useComputeBuffer: false };
  }
  _getCommonConfig(e5) {
    const { coordScale: t10, computedOpacity: o10, transforms: i11 } = e5, { names: r17, textures: s6 } = e5.getTextures({ useProcessedTexture: e5.processed }), n7 = s6[r17.indexOf("u_image")], a12 = e5.getRasterTextureSize(), p6 = { texture: { texture: n7, unit: 0 }, dvsMat3: i11.displayViewScreenMat3, coordScale: t10, srcImageSize: a12, opacity: o10 }, l7 = s6[r17.indexOf("u_transformGrid")], { transformGrid: c11 } = e5, f8 = !(!l7 || !c11), m12 = f8 ? { transformTexture: { texture: l7, unit: 2 }, targetImageSize: [e5.width, e5.height], transformSpacing: c11.spacing, transformGridSize: c11.size } : void 0, u5 = s6[r17.indexOf("u_colormap")], { colormap: d6, colormapOffset: g9 } = e5.symbolizerParameters, h16 = u5 && d6 ? { colormapTexture: { texture: u5, unit: 1 }, colormapOffset: g9 ?? 0, colormapMaxIndex: d6.length / 4 - 1 } : void 0, C7 = s6[r17.indexOf("u_mask")];
    return { config: p6, projectionConfig: m12, colormapConfig: h16, pixelMaskConfig: C7 ? { maskTexture: { texture: C7, unit: 3 } } : void 0, projectionDefines: { applyProjection: f8, lookupProjection: f8 && 1 === c11.spacing[0] } };
  }
  _getInterpolationDefines(e5, t10) {
    const o10 = "bilinear" === e5 && t10;
    return { bilinear: o10, bicubic: "cubic" === e5, nearestOnEdge: o10 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/textureUtils.js
function s4(o10, m12) {
  const s6 = new a2();
  return s6.width = o10, s6.height = m12, s6.internalFormat = B.RGBA32F, s6.samplingMode = L.NEAREST, s6.dataType = X.FLOAT, s6.isImmutable = true, s6.wrapMode = P.CLAMP_TO_EDGE, s6;
}
function u4(e5, r17, t10) {
  const n7 = s4(r17, t10);
  return new S2(e5, n7);
}
function a8(e5, r17, t10) {
  const n7 = s4(r17, t10);
  return new R(e5, n7);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/BaseRasterProcessorTechnique.js
var i9 = class extends t4 {
  shutdown(e5) {
    super.shutdown(e5), this._fbo?.dispose(), this._fbo = void 0;
  }
  render(r17, i11) {
    const { rasterFunction: u5 } = r17;
    if (!u5) return;
    const { context: m12 } = r17, p6 = "indexedColormap" in u5.parameters ? l3(m12, u5.parameters.indexedColormap) : void 0, d6 = "Reproject" === u5.name, l7 = m12.getBoundFramebufferObject(), c11 = m12.getViewport();
    for (const a12 of i11.bitmaps) {
      const l8 = d6 ? !(a12.rasterTexture && a12.projected) : !a12.processed;
      if (!a12.source || !l8 || a12.suspended) continue;
      r17.timeline.begin(this.name);
      const { painter: c12 } = r17;
      c12.setPipelineState({ depth: false, stencil: { test: false, write: false }, color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: A.ONE, dstRGB: A.ZERO, srcAlpha: A.ONE, dstAlpha: A.ZERO } } }), d6 || (a12.processedTexture = r2(a12.processedTexture)), a12.updateTexture(r17);
      const [g9, f8] = a12.getRasterTextureSize(d6), h16 = g9 === a4 && f8 === a4, x6 = h16 ? i11.processorFbo : a8(m12, g9, f8);
      m12.bindFramebuffer(x6), m12.setViewport(0, 0, x6.width, x6.height), this._process(r17, a12, p6);
      const w5 = u4(r17.context, g9, f8);
      if (x6.copyToTexture(0, 0, g9, f8, 0, 0, w5), d6) a12.rasterTexture = w5;
      else {
        const e5 = r17.hasBranches ? u5.id : 0;
        a12.functionTextures[e5] = w5;
      }
      h16 || x6.dispose(), r17.timeline.end(this.name);
    }
    p6?.dispose(), m12.bindFramebuffer(l7), m12.setViewport(c11.x, c11.y, c11.width, c11.height);
  }
  _getCommonConfig(e5, t10) {
    const { rasterFunction: r17, hasBranches: n7 } = e5, { raster: s6, rasters: o10 } = r17.parameters, a12 = n7 ? s6?.id ?? o10?.filter((e6) => "Constant" !== e6.name)?.[0]?.id ?? -1 : 0, i11 = t10.functionTextures[a12] ?? t10.rasterTexture, u5 = "Reproject" === r17.name;
    return { texture: { texture: i11, unit: 0 }, srcImageSize: t10.getRasterTextureSize(u5) };
  }
  _getMultipleInputConfig(e5, t10) {
    return t10?.length ? 2 === t10.length ? { twoRasterConfig: this._getTwoInputConfig(t10, e5) } : 3 === t10.length ? { threeRasterConfig: this._getThreeInputConfig(t10, e5) } : {} : {};
  }
  _getConstantCount(e5) {
    return e5?.filter((e6) => "Constant" === e6.name).length ?? 0;
  }
  _getTextures(e5, t10) {
    return e5.filter((e6) => "Constant" !== e6.name).map((e6) => null != e6.id && "Identity" !== e6.name ? t10.functionTextures[e6.id] : t10.rasterTexture);
  }
  _getTwoInputConfig(e5, t10) {
    const r17 = this._getTextures(e5, t10), n7 = r17[1] ? { texture: r17[1], unit: 1 } : void 0, s6 = e5.findIndex((e6) => "Constant" === e6.name), o10 = 0 === s6 ? new Float32Array([0, 1, 0, 1, 0, 0, 0, 0, 0]) : new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 0]);
    return { image1: n7, image1Const: s6 > -1 ? e5[s6].parameters.value : 0, imageSwap: o10 };
  }
  _getThreeInputConfig(e5, t10) {
    const r17 = this._getTextures(e5, t10);
    let n7 = 0, s6 = 0, o10 = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    const a12 = r17[1] ? { texture: r17[1], unit: 1 } : void 0, i11 = r17[2] ? { texture: r17[2], unit: 2 } : void 0, u5 = [];
    if (e5.forEach((e6, t11) => "Constant" === e6.name && u5.push(t11)), 1 === u5.length) n7 = e5[u5[0]].parameters.value, o10 = 0 === u5[0] ? new Float32Array([0, 1, 0, 0, 0, 1, 1, 0, 0]) : 1 === u5[0] ? new Float32Array([1, 0, 0, 0, 0, 1, 0, 1, 0]) : new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    else if (2 === u5.length) {
      n7 = e5[u5[0]].parameters.value, s6 = e5[u5[1]].parameters.value;
      const t11 = e5.findIndex((e6) => "Constant" !== e6.name);
      o10 = 0 === t11 ? new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]) : 1 === t11 ? new Float32Array([0, 1, 0, 1, 0, 0, 0, 0, 1]) : new Float32Array([0, 0, 1, 1, 0, 0, 0, 1, 0]);
    }
    return { image1: a12, image2: i11, image1Const: n7, image2Const: s6, imageSwap: o10 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/BaseRasterProcessorShader.js
var x3 = class extends C4 {
};
r([f(0, C3)], x3.prototype, "position", void 0);
var v3 = class extends v {
};
var y2 = class extends P2 {
};
r([g3(U2)], y2.prototype, "texture", void 0), r([g3(C3)], y2.prototype, "srcImageSize", void 0);
var h7 = class extends j2 {
  vertex(o10) {
    return { uv: o10.position, glPosition: new Y(z2(o10.position), 0, 1) };
  }
  fragment(o10) {
    const t10 = new w(), e5 = T(o10.uv), s6 = this._process(e5);
    return t10.fragColor = new Y(s6.rgb, 1).multiply(s6.a), t10;
  }
  _getPixel(o10) {
    return G(o10, this.config);
  }
};
r([g3(y2)], h7.prototype, "config", void 0), r([e(0, m2(x3))], h7.prototype, "vertex", null), r([e(0, m2(v3))], h7.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/AspectShader.js
var h8 = class extends P2 {
};
r([g3(C3)], h8.prototype, "cellSize", void 0);
var g5 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "AspectShader";
  }
  _process(e5) {
    const { texture: t10 } = this.config, s6 = m6(t10, e5, this.config.srcImageSize), f8 = new C3(1).divide(this.aspectConfig.cellSize.multiply(8)), { x: h16, y: g9 } = f3(s6, f8), w5 = xt(g9), S5 = s6[9].multiply(cn(Qt(h16).add(Qt(w5)))), j4 = Qt(cn(h16)), x6 = new _2(3.14159265359), v6 = new _2(0), z5 = ln(v6, w5).multiply(0.5).multiply(x6).add(ln(w5, v6).multiply(1.5).multiply(x6)), C7 = Ge(new _2(2.5).multiply(x6).add(ce(w5, xt(h16))), new _2(2).multiply(x6)), _6 = Ye(z5, C7, j4).multiply(180).divide(x6);
    return new Y(_6, _6, _6, S5);
  }
};
r([g3(h8)], g5.prototype, "aspectConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/AspectTechnique.js
var r8 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterAspectProcessor", this.type = t3.Aspect, this.shaders = { aspect: new g5() };
  }
  _process(e5, s6) {
    const t10 = { cellSize: s6.getRasterCellSize() }, r17 = this._getCommonConfig(e5, s6), o10 = { shader: this.shaders.aspect, uniforms: { config: r17, aspectConfig: t10 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: i11, context: a12 } = e5;
    i11.submitDrawMesh(a12, o10, i11.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/math.js
function c6(n7) {
  const t10 = cn(n7), u5 = n7.add(Qt(t10).subtract(1));
  return t10.multiply(t10).divide(u5);
}
function d3(e5) {
  return new Y(ze(e5.rgb.add(0.5)), e5.a);
}
function w3(n7, t10) {
  return ln(t10.x, n7).multiply(ln(n7, t10.y));
}
function p4(n7, t10, r17) {
  const c11 = new X2(n7);
  let d6 = new X2(0, 0, 0), w5 = new _2(0);
  for (let e5 = 0; e5 < r17 / 3; e5++) {
    const n8 = 9 * e5, r18 = new X2(t10[n8], t10[n8 + 3], t10[n8 + 6]), i11 = new X2(t10[n8 + 1], t10[n8 + 4], t10[n8 + 7]), a12 = ln(r18, c11).multiply(ln(c11, i11)), p6 = new X2(t10[n8 + 2], t10[n8 + 5], t10[n8 + 8]);
    w5 = Ye(w5, p6.x, a12.x), w5 = Ye(w5, p6.y, a12.y), w5 = Ye(w5, p6.z, a12.z), d6 = d6.add(a12);
  }
  return { mapValue: w5, includeMask: cn(ye(d6, new X2(1, 1, 1))) };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/BandArithmeticShader.js
var b4 = class extends P2 {
};
r([g3(rt)], b4.prototype, "bandIndexMat3", void 0);
var h9 = class extends P2 {
};
r([g3(X2)], h9.prototype, "adjustments", void 0);
var x4 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "BandArithmeticShader", this.isOutputRounded = false;
  }
  _process(t10) {
    const s6 = this._getPixel(t10), u5 = this.bandArithmeticConfig.bandIndexMat3.multiply(s6.rgb), r17 = this._processIndex(u5), l7 = new Y(r17, r17, r17, s6.a);
    return this.isOutputRounded ? d3(l7) : l7;
  }
  _processIndex(t10) {
    const { r: s6, g: u5 } = t10, r17 = this.adjustmentConfig?.adjustments;
    switch (this.indexType) {
      case "ndxi": {
        const t11 = s6.subtract(u5), r18 = s6.add(u5);
        return t11.multiply(c6(r18));
      }
      case "sr":
        return s6.multiply(c6(u5));
      case "ci":
        return s6.multiply(c6(u5)).subtract(1);
      case "savi": {
        const { x: t11 } = r17, l7 = s6.subtract(u5), i11 = s6.add(u5).add(t11);
        return l7.multiply(c6(i11)).multiply(t11.add(1));
      }
      case "tsavi": {
        const { x: t11, y: l7, z: i11 } = r17, a12 = i11.multiply(t11.multiply(t11).add(1)).subtract(l7.multiply(t11)), e5 = t11.multiply(s6.subtract(t11.multiply(u5)).subtract(l7)), d6 = l7.multiply(s6).add(u5).add(a12);
        return e5.multiply(c6(d6));
      }
      case "msavi": {
        const t11 = s6.multiply(2).add(1), r18 = t11.multiply(t11).subtract(s6.subtract(u5).multiply(8));
        return t11.subtract(hn(r18)).multiply(0.5);
      }
      case "gemi": {
        const t11 = s6.multiply(s6).subtract(u5.multiply(u5)).multiply(2).add(s6.multiply(1.5)).add(u5.multiply(0.5)), r18 = s6.add(u5).add(0.5), l7 = t11.multiply(c6(r18)), i11 = l7.multiply(D2(l7.multiply(0.25))), a12 = u5.subtract(0.125).multiply(c6(D2(u5)));
        return i11.subtract(a12);
      }
      case "pvi": {
        const { x: t11, y: l7 } = r17, i11 = hn(t11.multiply(t11).add(1));
        return s6.subtract(u5.multiply(t11)).subtract(l7).multiply(c6(i11));
      }
      case "vari": {
        const s7 = t10.g.subtract(t10.r), u6 = t10.g.add(t10.r).subtract(t10.b);
        return s7.multiply(c6(u6));
      }
      case "rtvicore":
        return s6.subtract(u5).multiply(100).subtract(s6.subtract(t10.b).multiply(10));
      case "bai": {
        const t11 = We(new _2(0.1).subtract(u5), new _2(2)), r18 = We(new _2(0.06).subtract(s6), new _2(2));
        return c6(t11.add(r18));
      }
      case "evi": {
        const r18 = t10.b, l7 = s6.add(u5.multiply(6)).subtract(r18.multiply(7.5)).add(1);
        return s6.subtract(u5).multiply(2.5).multiply(c6(l7));
      }
      case "wndwi": {
        const { r: s7, g: u6, b: l7 } = t10, i11 = r17.x, a12 = i11.multiply(u6), e5 = i11.multiply(l7), d6 = s7.add(a12).add(l7).subtract(e5);
        return s7.subtract(a12).subtract(l7).add(e5).multiply(c6(d6));
      }
      case "mtvi": {
        const r18 = t10.b, l7 = We(s6.multiply(2).add(1), new _2(2)), i11 = s6.multiply(6).subtract(hn(u5).multiply(5)), p6 = hn(l7.subtract(i11).subtract(0.5)), c11 = s6.subtract(r18).multiply(1.2), m12 = u5.subtract(r18).multiply(2.5);
        return c11.subtract(m12).multiply(1.5).multiply(c6(p6));
      }
      default:
        return s6;
    }
  }
};
r([K], x4.prototype, "indexType", void 0), r([K], x4.prototype, "isOutputRounded", void 0), r([g3(b4)], x4.prototype, "bandArithmeticConfig", void 0), r([_3(h9)], x4.prototype, "adjustmentConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/BandArithmeticTechnique.js
var r9 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterBandArithmeticProcessor", this.type = t3.BandArithmetic, this.shaders = { bandArithmetic: new x4() };
  }
  _process(e5, t10) {
    const s6 = e5.rasterFunction.parameters, r17 = { indexType: s6.indexType, isOutputRounded: s6.isOutputRounded }, i11 = { bandIndexMat3: s6.bandIndexMat3 }, n7 = s6.adjustments ? { adjustments: [...s6.adjustments] } : void 0, a12 = this._getCommonConfig(e5, t10), o10 = { shader: this.shaders.bandArithmetic, uniforms: { config: a12, bandArithmeticConfig: i11, adjustmentConfig: n7 }, defines: r17, optionalAttributes: null, useComputeBuffer: false }, { painter: d6, context: m12 } = e5;
    d6.submitDrawMesh(m12, o10, d6.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ColormapToRGBShader.js
var m7 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "ColormapToRGBShader";
  }
  _process(o10) {
    const r17 = this._getPixel(o10), p6 = n3(r17, new _2(1), this.colormapConfig, false);
    return new Y(p6.xyz.multiply(255), p6.a);
  }
};
r([g3(i8)], m7.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ColormapToRGBTechnique.js
var s5 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterColormapToRGBProcessor", this.type = t3.ColormapToRGB, this.shaders = { colormapToRGB: new m7() };
  }
  _process(o10, e5, r17) {
    const s6 = o10.rasterFunction.parameters, t10 = { colormapTexture: { texture: r17, unit: 1 }, colormapOffset: s6.offset, colormapMaxIndex: s6.indexedColormap.length / 4 - 1 }, a12 = this._getCommonConfig(o10, e5), m12 = { shader: this.shaders.colormapToRGB, uniforms: { config: a12, colormapConfig: t10 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: n7, context: p6 } = o10;
    n7.submitDrawMesh(p6, m12, n7.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/MultiRasterMixin.js
var g6 = class extends P2 {
};
r([g3(U2)], g6.prototype, "image1", void 0), r([g3(_2)], g6.prototype, "image1Const", void 0), r([g3(rt)], g6.prototype, "imageSwap", void 0);
var l5 = class extends P2 {
};
r([g3(U2)], l5.prototype, "image1", void 0), r([g3(U2)], l5.prototype, "image2", void 0), r([g3(_2)], l5.prototype, "image1Const", void 0), r([g3(_2)], l5.prototype, "image2Const", void 0), r([g3(rt)], l5.prototype, "imageSwap", void 0);
var m8 = (a12) => {
  class i11 extends a12 {
    constructor() {
      super(...arguments), this.constantCount = 0, this.imageCount = 1;
    }
    _getRasterValues(t10) {
      const { imageCount: o10 } = this;
      if (1 === o10) {
        const o11 = yn(this.config.texture, t10);
        return { a: o11.r, b: o11.g, c: o11.b, alpha: o11.a };
      }
      if (2 === o10) {
        const o11 = this._getTwoValues(t10);
        return { a: o11.a, b: o11.b, c: o11.b, alpha: o11.alpha };
      }
      return this._getThreeValues(t10);
    }
    _getTwoValues(t10) {
      const o10 = yn(this.config.texture, t10);
      if (1 === this.constantCount) {
        const { imageSwap: t11, image1Const: e6 } = this.twoRasterConfig, a14 = t11.multiply(new X2(o10.r, e6, 0));
        return { a: a14.x, b: a14.y, alpha: o10.a };
      }
      const { image1: e5 } = this.twoRasterConfig, a13 = yn(e5, t10);
      return { a: o10.r, b: a13.r, alpha: o10.a.multiply(a13.a) };
    }
    _getThreeValues(t10) {
      const o10 = yn(this.config.texture, t10), { imageSwap: e5, image1: a13, image2: i12, image1Const: n7, image2Const: p6 } = this.threeRasterConfig;
      if (2 === this.constantCount) {
        const t11 = e5.multiply(new X2(o10.r, n7, p6));
        return { a: t11.x, b: t11.y, c: t11.z, alpha: o10.a };
      }
      if (1 === this.constantCount) {
        const i13 = yn(a13, t10), p7 = e5.multiply(new X2(o10.r, i13.r, n7));
        return { a: p7.x, b: p7.y, c: p7.z, alpha: o10.a.multiply(i13.a) };
      }
      const u5 = yn(a13, t10), g9 = yn(i12, t10);
      return { a: o10.r, b: u5.r, c: g9.r, alpha: o10.a.multiply(u5.a).multiply(g9.a) };
    }
  }
  return r([K], i11.prototype, "constantCount", void 0), r([K], i11.prototype, "imageCount", void 0), r([_3(g6)], i11.prototype, "twoRasterConfig", void 0), r([_3(l5)], i11.prototype, "threeRasterConfig", void 0), i11;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/CompositeBandShader.js
var t5 = class extends m8(h7) {
  constructor() {
    super(...arguments), this.type = "CompositeBandShader";
  }
  _process(r17) {
    const { a: e5, b: t10, c: o10, alpha: a12 } = this._getRasterValues(r17);
    return new Y(e5, t10, o10, a12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/CompositeBandTechnique.js
var o5 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterCompositeBandProcessor", this.type = t3.CompositeBand, this.shaders = { compositeBand: new t5() };
  }
  _process(s6, e5) {
    const { rasters: t10 } = s6.rasterFunction.parameters, o10 = { constantCount: this._getConstantCount(t10), imageCount: t10?.length ?? 1 }, r17 = this._getMultipleInputConfig(e5, t10), n7 = this._getCommonConfig(s6, e5), i11 = { shader: this.shaders.compositeBand, uniforms: { config: n7, ...r17 }, defines: o10, optionalAttributes: null, useComputeBuffer: false }, { painter: a12, context: p6 } = s6;
    a12.submitDrawMesh(p6, i11, a12.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/LocalShader.js
var ee2 = class extends P2 {
};
r([g3(C3)], ee2.prototype, "domainRange", void 0);
var ae = class extends m8(h7) {
  constructor() {
    super(...arguments), this.type = "LocalShader", this.isOutputRounded = false;
  }
  _process(e5) {
    if ("conditional" === this.operationName) return this._conditional(e5);
    const { a: a12, b: s6, alpha: t10 } = this._getRasterValues(e5), { value: n7, alpha: r17 } = this._compute(a12, s6, t10);
    return this._processResult(n7, r17);
  }
  _processResult(e5, a12) {
    const s6 = w3(e5, this.domainRangeConfig.domainRange), t10 = new Y(e5, e5, e5, a12).multiply(s6);
    return this.isOutputRounded ? d3(t10) : t10;
  }
  _compute(e5, a12, s6) {
    const { operationName: t10 } = this;
    let n7;
    switch (t10) {
      case "plus":
        n7 = e5.add(a12);
        break;
      case "minus":
        n7 = e5.subtract(a12);
        break;
      case "times":
        n7 = e5.multiply(a12);
        break;
      case "divide":
      case "floatdivide":
        n7 = e5.multiply(c6(a12)), s6 = s6.multiply(ut(Qt(cn(a12))));
        break;
      case "floordivide":
        n7 = ze(e5.multiply(c6(a12))), s6 = s6.multiply(ut(Qt(cn(a12))));
        break;
      case "square":
        n7 = e5.multiply(e5);
        break;
      case "sqrt":
        n7 = hn(e5);
        break;
      case "power":
        n7 = We(e5, a12);
        break;
      case "ln":
        n7 = zt(Gt(e5, new _2(0)), qe(e5), new _2(0)), s6 = s6.multiply(this._isAboveZero(e5));
        break;
      case "log10":
        n7 = zt(Gt(e5, new _2(0)), Ue(e5).multiply(c6(Ue(new _2(10)))), new _2(0)), s6 = s6.multiply(this._isAboveZero(e5));
        break;
      case "log2":
        n7 = zt(Gt(e5, new _2(0)), Ue(e5), new _2(0)), s6 = s6.multiply(this._isAboveZero(e5));
        break;
      case "exp":
        n7 = xe2(e5);
        break;
      case "exp10":
        n7 = We(new _2(10), e5);
        break;
      case "exp2":
        n7 = We(new _2(2), e5);
        break;
      case "rounddown":
        n7 = ze(e5);
        break;
      case "roundup":
        n7 = se(e5);
        break;
      case "int":
        n7 = cn(e5).multiply(ze(Qt(e5)));
        break;
      case "mod":
        n7 = Ge(e5, a12);
        break;
      case "negate":
        n7 = xt(e5);
        break;
      case "abs":
        n7 = Qt(e5);
        break;
      case "acos": {
        const a13 = this._isAbsBiggerThanOne(e5);
        n7 = zt(a13, new _2(0), Wt(e5)), s6 = zt(a13, new _2(0), s6);
        break;
      }
      case "acosh":
        n7 = Zt(e5);
        break;
      case "asin": {
        const a13 = this._isAbsBiggerThanOne(e5);
        n7 = zt(a13, new _2(0), ne(e5)), s6 = zt(a13, new _2(0), s6);
        break;
      }
      case "asinh":
        n7 = re(e5);
        break;
      case "atan":
        n7 = ce(e5);
        break;
      case "atanh": {
        const a13 = this._isAbsBiggerThanOne(e5);
        n7 = zt(a13, new _2(0), ie(e5)), s6 = zt(a13, new _2(0), s6);
        break;
      }
      case "atan2":
        n7 = ce(e5, a12);
        break;
      case "cos":
        n7 = oe(e5);
        break;
      case "cosh":
        n7 = he(e5);
        break;
      case "sin":
        n7 = sn(e5);
        break;
      case "sinh":
        n7 = un(e5);
        break;
      case "tan":
        n7 = an(e5);
        break;
      case "tanh":
        n7 = fn(e5);
        break;
      case "bitwiseand":
        n7 = new _2(Pt(new W(e5), new W(a12)));
        break;
      case "bitwiseor":
        n7 = new _2(Bt(new W(e5), new W(a12)));
        break;
      case "bitwiseleftshift":
        n7 = new _2(jt(new W(e5), new W(a12)));
        break;
      case "bitwiserightshift":
        n7 = new _2(Rt(new W(e5), new W(a12)));
        break;
      case "bitwisenot":
        n7 = new _2(Ut(new W(e5)));
        break;
      case "bitwisexor":
        n7 = new _2(qt(new W(e5), new W(a12)));
        break;
      case "booleanand":
        n7 = ut(Lt(Ct(e5, new _2(0)), Ct(a12, new _2(0))));
        break;
      case "booleanor":
        n7 = ut(At(Ct(e5, new _2(0)), Ct(a12, new _2(0))));
        break;
      case "booleannot":
        n7 = ut(_t(e5, new _2(0)));
        break;
      case "booleanxor":
        n7 = ut(Jt(Ct(e5, new _2(0)), Ct(a12, new _2(0))));
        break;
      case "greaterthan":
        n7 = ut(Gt(e5, a12));
        break;
      case "greaterthanequal":
        n7 = ut(Ht(e5, a12));
        break;
      case "lessthan":
        n7 = ut(Xt(e5, a12));
        break;
      case "lessthanequal":
        n7 = ut(Yt(e5, a12));
        break;
      case "equalto":
        n7 = ut(_t(e5, a12));
        break;
      case "notequal":
        n7 = ut(Ct(e5, a12));
        break;
      case "isnull":
        n7 = ut(_t(s6, new _2(0))), s6 = new _2(1);
        break;
      case "setnull": {
        const t11 = ut(_t(e5, new _2(0)));
        n7 = t11.multiply(a12), s6 = s6.multiply(t11);
        break;
      }
      default:
        n7 = e5;
    }
    return { value: n7, alpha: s6 };
  }
  _conditional(e5) {
    const { a: a12, b: s6, c: t10, alpha: n7 } = this._getRasterValues(e5), r17 = new _2(Qt(cn(a12))), i11 = Ye(t10, s6, r17);
    return this._processResult(i11, n7);
  }
  _isAboveZero(e5) {
    return ut(Gt(e5, new _2(0)));
  }
  _isAbsBiggerThanOne(e5) {
    return Gt(Qt(e5), new _2(1));
  }
};
r([K], ae.prototype, "operationName", void 0), r([K], ae.prototype, "isOutputRounded", void 0), r([g3(ee2)], ae.prototype, "domainRangeConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ComputeChangeShader.js
var h10 = class extends m8(h7) {
  constructor() {
    super(...arguments), this.type = "ComputeChangeShader", this.isOutputRounded = false;
  }
  _process(t10) {
    const { a: o10, b: e5, alpha: a12 } = this._getRasterValues(t10);
    let p6 = o10.subtract(e5);
    "relative-difference" === this.method && (p6 = p6.multiply(c6(Ce(Qt(o10), Qt(e5)))));
    const u5 = w3(p6, this.domainRangeConfig.domainRange), h16 = new Y(p6, p6, p6, a12).multiply(u5);
    return this.isOutputRounded ? d3(h16) : h16;
  }
};
r([K], h10.prototype, "method", void 0), r([K], h10.prototype, "isOutputRounded", void 0), r([g3(ee2)], h10.prototype, "domainRangeConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ComputeChangeTechnique.js
var o6 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterComputeChangeProcessor", this.type = t3.ComputeChange, this.shaders = { computeChange: new h10() };
  }
  _process(e5, t10) {
    const s6 = e5.rasterFunction.parameters, { rasters: o10 } = s6, n7 = { constantCount: this._getConstantCount(o10), imageCount: o10.length, method: s6.method, isOutputRounded: s6.isOutputRounded }, r17 = { domainRange: s6.domainRange }, { twoRasterConfig: a12 } = this._getMultipleInputConfig(t10, o10), i11 = this._getCommonConfig(e5, t10), u5 = { shader: this.shaders.computeChange, uniforms: { config: i11, domainRangeConfig: r17, twoRasterConfig: a12 }, defines: n7, optionalAttributes: null, useComputeBuffer: false }, { painter: h16, context: m12 } = e5;
    h16.submitDrawMesh(m12, u5, h16.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ContrastBrightnessShader.js
var f5 = class extends P2 {
};
r([g3(_2)], f5.prototype, "contrastOffset", void 0), r([g3(_2)], f5.prototype, "brightnessOffset", void 0);
var h11 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "ContrastBrightnessShader";
  }
  _process(t10) {
    const { rgb: s6, a: e5 } = this._getPixel(t10), { contrastOffset: l7, brightnessOffset: f8 } = this.contrastBrightnessConfig, h16 = new _2(255), c11 = new _2(128), u5 = s6.multiply(200), g9 = h16.multiply(100), y5 = h16.multiply(2).multiply(f8), w5 = u5.subtract(g9).add(y5), b5 = Tt([_t(l7, new _2(-100)), new X2(c11)], [_t(l7, new _2(100)), cn(w5).add(1).divide(2).multiply(h16)], [Gt(l7, new _2(0)), w5.divide(new _2(100).subtract(l7).multiply(2)).add(c11)], [true, w5.multiply(l7.add(100)).divide(2e4).add(c11)]);
    return d3(new Y(b5, e5));
  }
};
r([g3(f5)], h11.prototype, "contrastBrightnessConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ContrastBrightnessTechnique.js
var e4 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterContrastBrightnessProcessor", this.type = t3.ContrastBrightness, this.shaders = { contrastBrightness: new h11() };
  }
  _process(s6, t10) {
    const r17 = this._getCommonConfig(s6, t10), e5 = s6.rasterFunction.parameters, o10 = { shader: this.shaders.contrastBrightness, uniforms: { config: r17, contrastBrightnessConfig: e5 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: n7, context: i11 } = s6;
    n7.submitDrawMesh(i11, o10, n7.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ConvolutionShader.js
var m9 = class extends P2 {
};
r([g3(q.ofType(_2, 5, 5, true))], m9.prototype, "kernel", void 0), r([g3(C3)], m9.prototype, "clampRange", void 0);
var h12 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "ConvolutionShader", this.rows = 3, this.cols = 3;
  }
  _process(o10) {
    const { rows: t10, cols: e5 } = this, r17 = new C3(Math.floor(t10 / 2), Math.floor(e5 / 2)), { texture: c11, srcImageSize: d6 } = this.config, m12 = new _2(1).divide(d6), { kernel: h16 } = this.convolutionConfig, g9 = Rn(h16, { initialValue: new Y(0, 0, 0, 1), xRange: [0, t10], yRange: [0, e5], callback: (t11, e6, n7, a12) => {
      const d7 = new C3(new _2(n7), new _2(a12)).subtract(r17).multiply(m12), h17 = yn(c11, y(o10.add(d7))), g10 = h17.rgb.multiply(e6).add(t11.rgb), f9 = h17.a.multiply(t11.a);
      return new Y(g10, f9);
    } }), { clampRange: f8 } = this.convolutionConfig;
    return new Y(ue(g9.rgb, f8.x, f8.y), 1).multiply(g9.a);
  }
};
r([K], h12.prototype, "rows", void 0), r([K], h12.prototype, "cols", void 0), r([g3(m9)], h12.prototype, "convolutionConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ConvolutionTechnique.js
var r10 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterConvolutionProcessor", this.type = t3.Convolution, this.shaders = { convolution: new h12() };
  }
  _process(o10, e5) {
    const s6 = o10.rasterFunction.parameters, r17 = { rows: s6.kernelRows, cols: s6.kernelCols }, n7 = { kernel: [...s6.kernel], clampRange: s6.clampRange }, t10 = this._getCommonConfig(o10, e5), i11 = { shader: this.shaders.convolution, uniforms: { config: t10, convolutionConfig: n7 }, defines: r17, optionalAttributes: null, useComputeBuffer: false }, { painter: a12, context: c11 } = o10;
    a12.submitDrawMesh(c11, i11, a12.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/CurvatureShader.js
var c7 = class extends P2 {
};
r([g3(_2)], c7.prototype, "zlFactor", void 0);
var m10 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "CurvatureShader";
  }
  _process(t10) {
    const { texture: r17 } = this.config, e5 = m6(r17, t10, this.config.srcImageSize), s6 = e5[3].add(e5[5]).multiply(0.5).subtract(e5[4]), d6 = e5[1].add(e5[7]).multiply(0.5).subtract(e5[4]), { zlFactor: l7 } = this.curvatureConfig, { curvatureType: c11 } = this;
    let m12;
    if ("standard" === c11) m12 = xt(l7).multiply(s6.add(d6));
    else {
      const t11 = e5[2].subtract(e5[0]).add(e5[6]).subtract(e5[8]).divide(4), r18 = e5[5].subtract(e5[3]).divide(2), u5 = e5[1].subtract(e5[7]).divide(2), p6 = r18.multiply(r18), n7 = u5.multiply(u5), y5 = r18.multiply(u5), f8 = l7.divide(p6.add(n7));
      m12 = "profile" === c11 ? ye(new X2(s6, d6, t11), new X2(p6, n7, y5)).multiply(f8) : ye(new X2(s6, d6, xt(t11)), new X2(n7, p6, y5)).multiply(xt(f8));
    }
    return new Y(m12, m12, m12, e5[9]);
  }
};
r([K], m10.prototype, "curvatureType", void 0), r([g3(c7)], m10.prototype, "curvatureConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/CurvatureTechnique.js
var t6 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterCurvatureProcessor", this.type = t3.Curvature, this.shaders = { curvature: new m10() };
  }
  _process(r17, e5) {
    const s6 = r17.rasterFunction.parameters, t10 = { curvatureType: s6.curvatureType }, o10 = e5.getRasterCellSize(), a12 = { zlFactor: 200 * s6.zFactor / o10[0] / o10[1] }, u5 = this._getCommonConfig(r17, e5), i11 = { shader: this.shaders.curvature, uniforms: { config: u5, curvatureConfig: a12 }, defines: t10, optionalAttributes: null, useComputeBuffer: false }, { painter: c11, context: n7 } = r17;
    c11.submitDrawMesh(n7, i11, c11.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ExtractBandShader.js
var n5 = class extends P2 {
};
r([g3(rt)], n5.prototype, "bandIndexMat3", void 0);
var d4 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "ExtractBandShader";
  }
  _process(t10) {
    const r17 = this._getPixel(t10), s6 = this.extractBandConfig.bandIndexMat3.multiply(r17.rgb);
    return new Y(s6, r17.a);
  }
};
r([g3(n5)], d4.prototype, "extractBandConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ExtractBandTechnique.js
var r11 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterExtractBandProcessor", this.type = t3.ExtractBand, this.shaders = { extractBand: new d4() };
  }
  _process(e5, t10) {
    const s6 = { bandIndexMat3: e5.rasterFunction.parameters.bandIndexMat3 }, r17 = this._getCommonConfig(e5, t10), a12 = { shader: this.shaders.extractBand, uniforms: { config: r17, extractBandConfig: s6 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: n7, context: o10 } = e5;
    n7.submitDrawMesh(o10, a12, n7.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/FocalStatisticsShader.js
var f6 = class extends P2 {
};
r([g3(C3)], f6.prototype, "clampRange", void 0);
var _5 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "FocalStatisticsShader", this.rows = 3, this.cols = 3, this.fill = false;
  }
  _process(t10) {
    const e5 = this._process1(t10), r17 = ln(new _2(1), e5.a);
    if (!this.fill) return this._clamp(e5.rgb, r17);
    const s6 = this._getPixel(t10), i11 = Ye(e5.rgb, s6.rgb, s6.a);
    return this._clamp(i11, r17);
  }
  _clamp(t10, e5) {
    const { clampRange: r17 } = this.focalStatisticsConfig;
    return new Y(ue(t10, r17.x, r17.y), 1).multiply(e5);
  }
  _process1(t10) {
    const { texture: e5, srcImageSize: r17 } = this.config, { rows: s6, cols: a12 } = this, n7 = new C3(Math.floor(s6 / 2), Math.floor(a12 / 2)), l7 = new _2(1).divide(r17), w5 = this._getPixel(t10), { statisticsType: b5 } = this, h16 = "min" === b5 || "max" === b5 ? new Y(w5.rgb, 0) : new Y(0, 0, 0, 0);
    switch (b5) {
      case "min":
        return this._stat(s6, a12, h16, (r18, s7, a13) => {
          const p6 = new C3(new _2(s7), new _2(a13)).subtract(n7).multiply(l7), m12 = yn(e5, y(t10.add(p6))), w6 = Xe(r18.rgb, m12.rgb);
          return new Y(w6, r18.a.add(m12.a));
        });
      case "max":
        return this._stat(s6, a12, h16, (r18, s7, a13) => {
          const p6 = new C3(new _2(s7), new _2(a13)).subtract(n7).multiply(l7), d6 = yn(e5, y(t10.add(p6))), w6 = Ce(r18.rgb, d6.rgb);
          return new Y(w6, r18.a.add(d6.a));
        });
      case "mean": {
        const r18 = this._stat(s6, a12, h16, (r19, s7, a13) => {
          const p7 = new C3(new _2(s7), new _2(a13)).subtract(n7).multiply(l7), m12 = yn(e5, y(t10.add(p7))), d6 = r19.rgb.add(m12.rgb.multiply(m12.a));
          return new Y(d6, r19.a.add(m12.a));
        }), p6 = r18.rgb.multiply(c6(r18.a));
        return new Y(p6, r18.a);
      }
      case "stddev": {
        const r18 = this._stat(s6, a12, h16, (r19, s7, a13) => {
          const p6 = new C3(new _2(s7), new _2(a13)).subtract(n7).multiply(l7), m13 = yn(e5, y(t10.add(p6))), d7 = r19.rgb.add(m13.rgb.multiply(m13.a));
          return new Y(d7, r19.a.add(m13.a));
        }), m12 = this._stat(s6, a12, h16, (r19, s7, a13) => {
          const p6 = new C3(new _2(s7), new _2(a13)).subtract(n7).multiply(l7), m13 = yn(e5, y(t10.add(p6))), d7 = r19.rgb.add(m13.a.multiply(m13.rgb).multiply(m13.rgb));
          return new Y(d7, r19.a.add(m13.a));
        }), d6 = c6(m12.a), w6 = hn(m12.subtract(r18.multiply(r18).multiply(d6)).multiply(d6));
        return new Y(w6.rgb, r18.a);
      }
      default:
        return w5;
    }
  }
  _stat(t10 = 3, e5 = 3, r17, s6) {
    const a12 = new W(0).setMutable().setDebugName("StatColIterator"), o10 = new W(0).setMutable().setDebugName("StatRowIterator"), n7 = r17.setMutable().setDebugName("StatAccumulator"), l7 = s6(n7, a12, o10).setDebugName("StatPredicate"), c11 = It({ iterX: a12, iterY: o10, accumulator: n7 }, Y, l7, ({ out: r18, iterX: s7, iterY: a13, accumulator: o11, subgraph: n8 }) => `
  for (${a13} = 0; ${a13} < ${t10}; ${a13}++) {
    for (${s7} = 0; ${s7} < ${e5}; ${s7}++) {
  
    ${n8.body}
  
    ${o11} = ${n8.varName};
    }
  }
  ${r18} = ${o11};
  `).setDebugName("statBody");
    return c11;
  }
};
r([K], _5.prototype, "rows", void 0), r([K], _5.prototype, "cols", void 0), r([K], _5.prototype, "statisticsType", void 0), r([K], _5.prototype, "fill", void 0), r([g3(f6)], _5.prototype, "focalStatisticsConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/FocalStatisticsTechnique.js
var i10 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterFocalStatisticsProcessor", this.type = t3.Statistics, this.shaders = { focalStatistics: new _5() };
  }
  _process(s6, t10) {
    const e5 = s6.rasterFunction.parameters, i11 = { rows: e5.kernelRows, cols: e5.kernelCols, statisticsType: e5.statisticsType, fill: e5.fillNoDataOnly }, o10 = { clampRange: e5.clampRange }, r17 = this._getCommonConfig(s6, t10), a12 = { shader: this.shaders.focalStatistics, uniforms: { config: r17, focalStatisticsConfig: o10 }, defines: i11, optionalAttributes: null, useComputeBuffer: false }, { painter: c11, context: n7 } = s6;
    c11.submitDrawMesh(n7, a12, c11.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/GrayscaleShader.js
var p5 = class extends P2 {
};
r([g3(X2)], p5.prototype, "weights", void 0);
var c8 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "GrayscaleShader";
  }
  _process(s6) {
    const r17 = this._getPixel(s6), { weights: e5 } = this.grayscaleConfig, a12 = ye(e5, r17.rgb);
    return new Y(a12, a12, a12, r17.a);
  }
};
r([g3(p5)], c8.prototype, "grayscaleConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/GrayscaleTechnique.js
var t7 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterGrayscaleProcessor", this.type = t3.Grayscale, this.shaders = { grayscale: new c8() };
  }
  _process(s6, e5) {
    const r17 = { weights: s6.rasterFunction.parameters.weights }, t10 = this._getCommonConfig(s6, e5), a12 = { shader: this.shaders.grayscale, uniforms: { config: t10, grayscaleConfig: r17 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: o10, context: i11 } = s6;
    o10.submitDrawMesh(i11, a12, o10.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/HillshadeShader.js
var h13 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "HillshadeShader", this.isMultidirectional = false;
  }
  _process(s6) {
    const { texture: i11 } = this.config, r17 = m6(i11, s6, this.config.srcImageSize), l7 = Z2(r17, this.hillshadeConfig, this.isMultidirectional);
    return new Y(l7.rgb.multiply(255), l7.a);
  }
};
r([K], h13.prototype, "isMultidirectional", void 0), r([g3(a6)], h13.prototype, "hillshadeConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/HillshadeTechnique.js
var a9 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterHillshadeProcessor", this.type = t3.Hillshade, this.shaders = { hillshade: new h13() };
  }
  _process(e5, s6) {
    const t10 = e5.rasterFunction.parameters, a12 = { isMultidirectional: t10.hillshadeType > 0 }, i11 = s6.getRasterCellSize(), o10 = z4(t10, i11), h16 = { ...t10, factor: o10, minValue: 0, maxValue: 8e3 }, l7 = this._getCommonConfig(e5, s6), n7 = { shader: this.shaders.hillshade, uniforms: { config: l7, hillshadeConfig: h16 }, defines: a12, optionalAttributes: null, useComputeBuffer: false }, { painter: d6, context: m12 } = e5;
    d6.submitDrawMesh(m12, n7, d6.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/LocalTechnique.js
var o7 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterLocalProcessor", this.type = t3.Local, this.shaders = { local: new ae() };
  }
  _process(e5, s6) {
    const t10 = e5.rasterFunction.parameters, o10 = { constantCount: this._getConstantCount(t10.rasters), imageCount: t10.imageCount, operationName: t10.operationName, isOutputRounded: t10.isOutputRounded }, r17 = { domainRange: t10.domainRange }, a12 = "conditional" === t10.operationName ? t10.rasters : t10.rasters?.slice(0, 2), n7 = this._getMultipleInputConfig(s6, a12), i11 = this._getCommonConfig(e5, s6), u5 = { shader: this.shaders.local, uniforms: { config: i11, domainRangeConfig: r17, ...n7 }, defines: o10, optionalAttributes: null, useComputeBuffer: false }, { painter: c11, context: m12 } = e5;
    c11.submitDrawMesh(m12, u5, c11.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/MaskShader.js
var m11 = class extends P2 {
};
r([g3(B2.ofType(_2, 6))], m11.prototype, "includedRanges", void 0), r([g3(B2.ofType(_2, o3))], m11.prototype, "noDataValues", void 0);
var y3 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "MaskShader", this.isMultiband = true;
  }
  _process(t10) {
    const o10 = this._getPixel(t10), s6 = this._computeNoDataFactor(o10.r), e5 = this._computeRangeFactor(o10.rgb);
    let r17;
    if (this.isMultiband) {
      const t11 = this._computeNoDataFactor(o10.g), a12 = this._computeNoDataFactor(o10.b), l7 = new X2(s6, t11, a12).multiply(e5);
      r17 = l7.x.multiply(l7.y).multiply(l7.z);
    } else r17 = s6.multiply(e5.x);
    return o10.multiply(r17);
  }
  _computeNoDataFactor(t10) {
    const { noDataValues: s6 } = this.maskConfig;
    let e5 = new X2(1);
    for (let r17 = 0; r17 < o3 / 3; r17++) {
      const o10 = 3 * r17, p6 = new X2(s6[o10 + 0], s6[o10 + 1], s6[o10 + 2]), n7 = Qt(cn(p6.subtract(t10)));
      e5 = e5.multiply(n7);
    }
    return e5.x.multiply(e5.y).multiply(e5.z);
  }
  _computeRangeFactor(t10) {
    const { includedRanges: o10 } = this.maskConfig, s6 = new X2(o10[0], o10[2], o10[4]), e5 = new X2(o10[1], o10[3], o10[5]);
    return ln(s6, t10).multiply(ln(t10, e5));
  }
};
r([K], y3.prototype, "isMultiband", void 0), r([g3(m11)], y3.prototype, "maskConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/MaskTechnique.js
var a10 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterMaskProcessor", this.type = t3.Mask, this.shaders = { mask: new y3() };
  }
  _process(s6, e5) {
    const r17 = s6.rasterFunction.parameters, a12 = { isMultiband: r17.bandCount > 1 }, t10 = { includedRanges: [...r17.includedRanges], noDataValues: [...r17.noDataValues] }, o10 = this._getCommonConfig(s6, e5), n7 = { shader: this.shaders.mask, uniforms: { config: o10, maskConfig: t10 }, defines: a12, optionalAttributes: null, useComputeBuffer: false }, { painter: i11, context: u5 } = s6;
    i11.submitDrawMesh(u5, n7, i11.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/NDVIShader.js
var n6 = class extends P2 {
};
r([g3(rt)], n6.prototype, "bandIndexMat3", void 0);
var l6 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "NDVIShader", this.scaled = true;
  }
  _process(t10) {
    const s6 = this._getPixel(t10), { r: r17, g: e5 } = this.ndviConfig.bandIndexMat3.multiply(s6.rgb), i11 = r17.subtract(e5), d6 = r17.add(e5), n7 = i11.multiply(c6(d6));
    if (!this.scaled) return new Y(n7, n7, n7, s6.a);
    const l7 = ze(n7.multiply(100).add(100.5));
    return new Y(l7, l7, l7, s6.a);
  }
};
r([K], l6.prototype, "scaled", void 0), r([g3(n6)], l6.prototype, "ndviConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/NDVITechnique.js
var t8 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterNDVIProcessor", this.type = t3.NDVI, this.shaders = { ndvi: new l6() };
  }
  _process(s6, e5) {
    const r17 = s6.rasterFunction.parameters, t10 = { scaled: r17.scaled }, o10 = { bandIndexMat3: r17.bandIndexMat3 }, n7 = this._getCommonConfig(s6, e5), a12 = { shader: this.shaders.ndvi, uniforms: { config: n7, ndviConfig: o10 }, defines: t10, optionalAttributes: null, useComputeBuffer: false }, { painter: i11, context: d6 } = s6;
    i11.submitDrawMesh(d6, a12, i11.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/RemapShader.js
var v4 = class extends P2 {
};
r([g3(B2.ofType(_2, 3 * o3))], v4.prototype, "rangeMaps", void 0), r([g3(B2.ofType(_2, 2 * o3))], v4.prototype, "noDataRanges", void 0), r([g3(_2)], v4.prototype, "unmatchMask", void 0), r([g3(_2)], v4.prototype, "replacementValue", void 0), r([g3(C3)], v4.prototype, "clampRange", void 0);
var x5 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "RemapShader";
  }
  _process(e5) {
    const o10 = this._getPixel(e5), { rangeMaps: r17, unmatchMask: a12, clampRange: n7, replacementValue: l7 } = this.remapConfig, { mapValue: c11, includeMask: u5 } = p4(o10.r, r17, o3), d6 = this.replaceUnmatched ? l7 : a12.multiply(o10.r), h16 = Ye(d6, c11, u5), y5 = ue(h16, n7.x, n7.y), f8 = this._computeNoDataFactor(o10.rrr).multiply(Ce(a12, u5));
    return new Y(y5, y5, y5, o10.a).multiply(f8);
  }
  _computeNoDataFactor(e5) {
    const { noDataRanges: o10 } = this.remapConfig;
    let r17 = new X2(0, 0, 0);
    for (let a12 = 0; a12 < o3 / 3; a12++) {
      const t10 = 6 * a12, p6 = new X2(o10[t10], o10[t10 + 2], o10[t10 + 4]), s6 = new X2(o10[t10 + 1], o10[t10 + 3], o10[t10 + 5]);
      r17 = r17.add(ln(p6, e5).multiply(ln(e5, s6)));
    }
    return D2(cn(ye(r17, new X2(1, 1, 1))));
  }
};
r([g3(v4)], x5.prototype, "remapConfig", void 0), r([K], x5.prototype, "replaceUnmatched", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/RemapTechnique.js
var r12 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterRemapProcessor", this.type = t3.Remap, this.shaders = { remap: new x5() };
  }
  _process(e5, a12) {
    const s6 = e5.rasterFunction.parameters, r17 = { replaceUnmatched: s6.allowUnmatched && null != s6.replacementValue }, t10 = { rangeMaps: [...s6.rangeMaps], noDataRanges: [...s6.noDataRanges], unmatchMask: s6.allowUnmatched ? 1 : 0, replacementValue: s6.replacementValue ?? 0, clampRange: s6.clampRange }, n7 = this._getCommonConfig(e5, a12), o10 = { shader: this.shaders.remap, uniforms: { config: n7, remapConfig: t10 }, defines: r17, optionalAttributes: null, useComputeBuffer: false }, { painter: m12, context: p6 } = e5;
    m12.submitDrawMesh(p6, o10, m12.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ReprojectShader.js
var r13 = class extends O2 {
  constructor() {
    super(...arguments), this.type = "ReprojectShader";
  }
  _colorize(e5) {
    return this._getPixel(e5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ReprojectTechnique.js
var o8 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterReprojectProcessor", this.type = t3.Reproject, this.shaders = { reproject: new r13() };
  }
  _process(e5, r17) {
    const t10 = e5.rasterFunction.parameters, o10 = this._getInterpolationDefines(r17.interpolation, !!t10.requireNNEdge), { config: i11, projectionConfig: n7, projectionDefines: s6 } = this._getReprojectConfig(r17), a12 = { shader: this.shaders.reproject, uniforms: { config: i11, projectionConfig: n7 }, defines: { ...s6, ...o10, applyPixelMask: false }, optionalAttributes: null, useComputeBuffer: false }, { interpolation: c11 } = r17;
    r17.interpolation = "nearest";
    const { painter: p6, context: u5 } = e5;
    p6.submitDrawMesh(u5, a12, p6.quadMesh), r17.interpolation = c11, r17.projected = true;
  }
  _getReprojectConfig(e5) {
    const { source: r17 } = e5, { names: t10, textures: o10 } = e5.getTextures({ forProcessing: true }), i11 = { texture: { texture: o10[t10.indexOf("u_image")], unit: 0 }, dvsMat3: new Float32Array([2, 0, 0, 0, 2, 0, -1, -1, 0]), coordScale: [1, 1], srcImageSize: [r17.width, r17.height], opacity: 1 }, n7 = o10[t10.indexOf("u_transformGrid")], { transformGrid: s6 } = e5, a12 = !(!n7 || !s6);
    return { config: i11, projectionConfig: a12 ? { transformTexture: { texture: n7, unit: 1 }, targetImageSize: [e5.width, e5.height], transformSpacing: s6.spacing, transformGridSize: s6.size } : void 0, projectionDefines: { applyProjection: a12, lookupProjection: a12 && 1 === s6.spacing[0] } };
  }
  _getInterpolationDefines(e5, r17) {
    const t10 = "bilinear" === e5 && r17;
    return { bilinear: t10, bicubic: "cubic" === e5, nearestOnEdge: t10 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ShadedReliefShader.js
var d5 = class extends h13 {
  constructor() {
    super(...arguments), this.type = "ShadedReliefShader";
  }
  _process(r17) {
    const e5 = super._process(r17), { minValue: m12, maxValue: n7 } = this.hillshadeConfig, d6 = this._getPixel(r17), h16 = n7.subtract(m12), u5 = d6.r.subtract(m12), c11 = ue(u5.divide(h16), new _2(0), new _2(1)), f8 = n3(new Y(c11, c11, c11, 1), new _2(255), this.colormapConfig), x6 = a5(f8.xyz), g9 = c4(new X2(x6.xy, e5.x.divide(255))).multiply(255);
    return new Y(g9, f8.a.multiply(e5.a));
  }
};
r([g3(i8)], d5.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ShadedReliefTechnique.js
var t9 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterShadedReliefProcessor", this.type = t3.ShadedRelief, this.shaders = { shadedRelief: new d5() };
  }
  _process(e5, s6, o10) {
    const t10 = e5.rasterFunction.parameters, a12 = { isMultidirectional: t10.hillshadeType > 0 }, i11 = s6.getRasterCellSize(), d6 = z4(t10, i11), h16 = { ...t10, factor: d6 }, n7 = { colormapTexture: { texture: o10, unit: 1 }, colormapOffset: t10.offset, colormapMaxIndex: t10.indexedColormap.length / 4 - 1 }, f8 = this._getCommonConfig(e5, s6), l7 = { shader: this.shaders.shadedRelief, uniforms: { config: f8, hillshadeConfig: h16, colormapConfig: n7 }, defines: a12, optionalAttributes: null, useComputeBuffer: false }, { painter: c11, context: m12 } = e5;
    c11.submitDrawMesh(m12, l7, c11.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/SlopeShader.js
var h14 = class extends P2 {
};
r([g3(_2)], h14.prototype, "pixelSizePower", void 0), r([g3(_2)], h14.prototype, "pixelSizeFactor", void 0), r([g3(_2)], h14.prototype, "zFactor", void 0), r([g3(C3)], h14.prototype, "cellSize", void 0);
var y4 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "SlopeShader", this.isOutputRounded = false, this.percentRise = false;
  }
  _process(e5) {
    const { cellSize: t10, pixelSizePower: o10, pixelSizeFactor: i11, zFactor: u5 } = this.slopeConfig, a12 = We(t10, new C3(o10)).multiply(i11).add(u5).divide(t10.multiply(8)), { texture: h16 } = this.config, y5 = m6(h16, e5, this.config.srcImageSize), { x: f8, y: S5 } = f3(y5, a12), x6 = hn(f8.multiply(f8).add(S5.multiply(S5))), z5 = this.percentRise ? x6.multiply(100) : ce(x6).multiply(57.2957795), v6 = new Y(z5, z5, z5, y5[9]);
    return this.isOutputRounded ? d3(v6) : v6;
  }
};
r([K], y4.prototype, "isOutputRounded", void 0), r([K], y4.prototype, "percentRise", void 0), r([g3(h14)], y4.prototype, "slopeConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/SlopeTechnique.js
var r14 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterSlopeProcessor", this.type = t3.Slope, this.shaders = { slope: new y4() };
  }
  _process(e5, s6) {
    const o10 = e5.rasterFunction.parameters, r17 = { isOutputRounded: o10.isOutputRounded, percentRise: "percent-rise" === o10.slopeType }, t10 = { cellSize: s6.getRasterCellSize(), pixelSizePower: "adjusted" === o10.slopeType ? o10.pixelSizePower : 0, pixelSizeFactor: "adjusted" === o10.slopeType ? o10.pixelSizeFactor : 0, zFactor: o10.zFactor }, i11 = this._getCommonConfig(e5, s6), p6 = { shader: this.shaders.slope, uniforms: { config: i11, slopeConfig: t10 }, defines: r17, optionalAttributes: null, useComputeBuffer: false }, { painter: a12, context: n7 } = e5;
    a12.submitDrawMesh(n7, p6, a12.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/StretchShader.js
var h15 = class extends h7 {
  constructor() {
    super(...arguments), this.type = "StretchShader", this.isMultiband = true, this.isOutputRounded = false, this.useGamma = false;
  }
  _process(t10) {
    const s6 = this._getPixel(t10);
    let r17 = c5(s6, this.stretchConfig, this.useGamma, 1);
    return this.isMultiband || (r17 = new Y(r17.rrr, r17.a)), this.isOutputRounded ? d3(r17) : r17;
  }
};
r([K], h15.prototype, "isMultiband", void 0), r([K], h15.prototype, "isOutputRounded", void 0), r([K], h15.prototype, "useGamma", void 0), r([g3(f4)], h15.prototype, "stretchConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/StretchTechnique.js
var r15 = class extends i9 {
  constructor() {
    super(...arguments), this.name = "RasterStretchProcessor", this.type = t3.Stretch, this.shaders = { stretch: new h15() };
  }
  _process(s6, e5) {
    const t10 = s6.rasterFunction.parameters, r17 = { isMultiband: t10.bandCount > 1, isOutputRounded: t10.isOutputRounded, useGamma: t10.useGamma }, o10 = this._getCommonConfig(s6, e5), a12 = { shader: this.shaders.stretch, uniforms: { config: o10, stretchConfig: t10 }, defines: r17, optionalAttributes: null, useComputeBuffer: false }, { painter: i11, context: n7 } = s6;
    i11.submitDrawMesh(n7, a12, i11.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/RasterProcessorTechnique.js
var g7 = /* @__PURE__ */ new Map([["Aspect", r8], ["BandArithmetic", r9], ["ColormapToRGB", s5], ["CompositeBand", o5], ["ComputeChange", o6], ["ContrastBrightness", e4], ["Convolution", r10], ["Curvature", t6], ["ExtractBand", r11], ["Grayscale", t7], ["Hillshade", a9], ["Local", o7], ["Mask", a10], ["NDVI", t8], ["Remap", r12], ["Reproject", o8], ["ShadedRelief", t9], ["Slope", r14], ["Statistics", i10], ["Stretch", r15]]);
var v5 = class extends t4 {
  constructor() {
    super(...arguments), this.type = t3.RasterProcessor, this.shaders = {}, this._techniques = /* @__PURE__ */ new Map();
  }
  shutdown(e5) {
    super.shutdown(e5), this._fbo?.dispose(), this._fbo = void 0;
    for (const o10 of this._techniques.values()) o10.shutdown();
    this._techniques.clear();
  }
  render(o10, r17) {
    this._fbo ??= a8(o10.context, a4, a4);
    let { name: s6 } = o10.rasterFunction;
    if ("Arithmetic" === s6 && (s6 = "Local"), !this._techniques.has(s6)) {
      const e5 = g7.get(s6);
      if (!e5) return;
      this._techniques.set(s6, new e5());
    }
    this._techniques.get(s6).render(o10, { ...r17, processorFbo: this._fbo });
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterTileContainer.js
var c9 = class extends i4 {
  constructor() {
    super(...arguments), this.isCustomTilingScheme = false;
  }
  createTile(e5) {
    const i11 = this._getTileBounds(e5), [s6, o10] = this.tileInfoView.tileInfo.size, r17 = this.tileInfoView.getTileResolution(e5.level);
    return new i7(e5, r17, i11[0], i11[3], s6, o10);
  }
  onAttach() {
    super.onAttach(), this._colorizerTechnique = new a7(), this._processorTechnique = new v5();
  }
  onDetach() {
    super.onDetach(), this._colorizerTechnique?.shutdown(), this._colorizerTechnique = void 0, this._processorTechnique?.shutdown(), this._processorTechnique = void 0;
  }
  doRender(e5) {
    if (!this.visible || e5.drawPhase !== E.MAP || !this._colorizerTechnique) return;
    const { rasterFunctionChain: i11 } = this;
    if (i11?.functions?.length) {
      if (!this._processorTechnique) return;
      const { functions: t11, hasBranches: s6 } = i11;
      for (const i12 of t11) {
        if ("Constant" === i12.name || "Identity" === i12.name) continue;
        e5.rasterFunction = i12, e5.hasBranches = s6, super.doRender(e5);
        const t12 = this.children.map((e6) => e6.bitmap);
        this._processorTechnique.render(e5, { bitmaps: t12 });
      }
    }
    e5.rasterFunction = null, super.doRender(e5);
    const t10 = this.children.map((e6) => e6.bitmap);
    this._colorizerTechnique.render(e5, { bitmaps: t10 });
  }
  _getTileBounds(t10) {
    const s6 = this.tileInfoView.getTileBounds(u(), t10);
    if (this.isCustomTilingScheme && t10.world) {
      const { tileInfo: e5 } = this.tileInfoView, o10 = mt(e5.spatialReference);
      if (o10) {
        const i11 = e5.lodAt(t10.level);
        if (!i11) return s6;
        const { resolution: r17 } = i11, n7 = r17 * e5.size[0];
        s6[0] = o10 * t10.world + e5.origin.x + t10.col * n7, s6[2] = s6[0] + n7;
      }
    }
    return s6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/imagery/BaseImageryTileSubView2D.js
var C6 = [0, 0];
var U3 = class extends b2 {
  constructor() {
    super(...arguments), this._updatingHandles = new h3(), this._emptyTilePixelBlock = null, this._tileStrategy = null, this._tileInfoView = null, this._fetchQueue = null, this._blockCacheRegistryUrl = null, this._blockCacheRegistryId = null, this._srcResolutions = [], this.previousLOD = null, this._needBlockCacheUpdate = false, this._globalSymbolizerParams = null, this._symbolizerParams = null, this._abortController = null, this._isCustomTilingScheme = false, this._maxIndexedColormapSize = 0, this._rasterFunctionState = "na", this._globalUpdateRequested = false, this.attached = false, this.timeExtent = null, this.redrawOrRefetch = k(async (e5 = {}) => {
      const t10 = this._rasterFunctionState, i11 = e5.reprocess || "gpu" === t10 && !this.canUseWebGLForProcessing || "cpu" === t10 && this.canUseWebGLForProcessing;
      if (i11 && (await this._updatingHandles.addPromise(this.layer.updateRasterFunction()), this.updateRasterFunctionParameters()), !this.previousLOD || this.layerView.suspended) return;
      const s6 = this._rasterFunctionState, { type: r17 } = this;
      return e5.refetch || "raster" !== r17 && !!i11 || "cpu" === s6 || "cpu" === t10 ? this._updatingHandles.addPromise(this.doRefresh()) : this._updatingHandles.addPromise(this._redrawImage(e5.signal));
    });
  }
  destroy() {
    this._updatingHandles.destroy();
  }
  get canUseWebGLForProcessing() {
    return false;
  }
  get canUseLocalSymbolizerParams() {
    return (this.canUseWebGLForProcessing || "rasterVF" === this.type) && !this.layerView.hasTilingEffects;
  }
  get useWebGLForProcessing() {
    return this._get("useWebGLForProcessing") ?? true;
  }
  set useWebGLForProcessing(e5) {
    this._set("useWebGLForProcessing", e5);
  }
  get useProgressiveUpdate() {
    return this._get("useProgressiveUpdate") ?? true;
  }
  set useProgressiveUpdate(e5) {
    if (this._tileStrategy && this.useProgressiveUpdate !== e5) {
      this._tileStrategy.destroy(), this.container.removeAllChildren();
      const t10 = this._getCacheSize(e5);
      this._tileStrategy = new r6({ cachePolicy: "purge", acquireTile: (e6) => this.acquireTile(e6), releaseTile: (e6) => this.releaseTile(e6), cacheSize: t10, tileInfoView: this._tileInfoView }), this._set("useProgressiveUpdate", e5), this.layerView.requestUpdate();
    }
  }
  update(e5) {
    this._fetchQueue.pause(), this._fetchQueue.state = e5.state, this._tileStrategy.update(e5), this._fetchQueue.resume();
    const { extent: t10, resolution: i11, scale: s6 } = e5.state, r17 = this._tileInfoView.getClosestInfoForScale(s6);
    if (this.layer.raster) {
      if (!this.useProgressiveUpdate || this._needBlockCacheUpdate) {
        const e6 = this._srcResolutions[r17.level], s7 = "toJSON" in t10 ? t10 : z.fromJSON(t10);
        g(this._blockCacheRegistryUrl, this._blockCacheRegistryId, s7, i11, e6, this.layer.raster.ioConfig.sampling);
      }
      this._needBlockCacheUpdate = false, this.previousLOD?.level !== r17.level && (this.previousLOD = r17, null != this._symbolizerParams && this.canUseLocalSymbolizerParams && this._updateSymbolizerParams(), this._tileStrategy.updateCacheSize(0));
    }
  }
  moveEnd() {
    !this.layerView.hasTilingEffects && this.useProgressiveUpdate || (this._abortController && this._abortController.abort(), this._abortController = new AbortController(), 0 === this._fetchQueue.length && this._redrawImage(this._abortController.signal).then(() => {
      this._globalUpdateRequested = false, this.layerView.requestUpdate();
    }));
    const e5 = this._getCacheSize(this.useProgressiveUpdate);
    this._tileStrategy.updateCacheSize(e5), this.layerView.requestUpdate();
  }
  get updating() {
    return this._globalUpdateRequested || this._updatingHandles?.updating;
  }
  attach() {
    const e5 = t2();
    this._maxIndexedColormapSize = 4 * (e5.maxTextureSize || 4096), this._initializeTileInfo(), this._tileInfoView = new h4(this.layerView.tileInfo, this.layerView.fullExtent);
    const t10 = this._computeFetchConcurrency();
    this._fetchQueue = new p2({ tileInfoView: this._tileInfoView, concurrency: t10, process: (e6, t11) => this._fetchTile(e6, t11), priority: g2.MAPVIEW_FETCH_QUEUE, scheduler: this.scheduler });
    const i11 = this._getCacheSize(this.useProgressiveUpdate);
    this._tileStrategy = new r6({ cachePolicy: "purge", acquireTile: (e6) => this.acquireTile(e6), releaseTile: (e6) => this.releaseTile(e6), cacheSize: i11, tileInfoView: this._tileInfoView }), this._updateBlockCacheRegistry();
  }
  detach() {
    this._tileStrategy.destroy(), this._fetchQueue.clear(), this.container.removeAllChildren(), this._fetchQueue = this._tileStrategy = this._tileInfoView = null, a3(this._blockCacheRegistryUrl, this._blockCacheRegistryId), this._blockCacheRegistryUrl = this._blockCacheRegistryId = null;
  }
  acquireTile(e5) {
    const t10 = this.container.createTile(e5);
    return this._updatingHandles.addPromise(this._enqueueTileFetch(t10)), this.layerView.requestUpdate(), this._needBlockCacheUpdate = true, this._globalUpdateRequested = this.layerView.hasTilingEffects || !this.useProgressiveUpdate, t10;
  }
  releaseTile(e5) {
    this._fetchQueue.abort(e5.key.id), this.container.removeChild(e5), e5.once("detach", () => {
      e5.destroy(), this.layerView.requestUpdate();
    }), this.layerView.requestUpdate();
  }
  createEmptyTilePixelBlock(e5 = null) {
    const t10 = null == e5 || e5.join(",") === this._tileInfoView.tileInfo.size.join(",");
    if (t10 && null != this._emptyTilePixelBlock) return this._emptyTilePixelBlock;
    e5 = e5 || this._tileInfoView.tileInfo.size;
    const [i11, s6] = e5, r17 = new c({ width: i11, height: s6, pixels: [new Uint8Array(i11 * s6)], mask: new Uint8Array(i11 * s6), pixelType: "u8" });
    return t10 && (this._emptyTilePixelBlock = r17), r17;
  }
  _getBandIds() {
    if (!("rasterFunctionChain" in this.container) || !this.container.rasterFunctionChain) return this.layer.bandIds;
    const { bandIds: e5, raster: t10 } = this.layer, i11 = "rasterFunction" in t10 ? t10.rasterFunction.rawInputBandIds : null;
    return e5?.length && i11?.length && 1 !== t10.rasterInfo.bandCount ? e5.map((e6) => i11[Math.min(e6, i11.length - 1)]) : "rasterFunction" in t10 ? i11 : e5;
  }
  updateRasterFunctionParameters() {
  }
  _fetchTile(e5, t10) {
    const i11 = this._getFetchOptions(e5.level, t10.signal);
    return this.fetchTile(e5, i11);
  }
  _getFetchOptions(e5, t10) {
    const { canUseWebGLForProcessing: i11 } = this, { layerView: s6 } = this, { tileInfo: r17 } = s6, a12 = !r17.isWrappable && null != ee(s6.view.spatialReference), o10 = i11 && this.layer.raster.hasUniqueSourceStorageInfo, { layer: l7 } = this.layerView, n7 = l7.serviceRasterInfo?.storageInfo.isBsqTile ? l7.bandIds : void 0;
    return { allowPartialFill: true, datumTransformation: s6.datumTransformation, interpolation: i11 ? "nearest" : this.layer.interpolation, registryId: this._blockCacheRegistryId, requestRawData: o10, skipRasterFunction: "raster" === this.type && null != this.container.rasterFunctionChain, signal: t10, srcResolution: this._srcResolutions[e5], timeExtent: s6.timeExtent, tileInfo: r17, bandIds: n7, disableWrapAround: a12 };
  }
  _getCacheSize(e5) {
    return e5 ? 40 : 0;
  }
  _initializeTileInfo() {
    const { layerView: e5 } = this, t10 = e5.view.spatialReference;
    if (this._canUseLayerLODs()) {
      const { origin: i12, lods: s6 } = this.layer.tileInfo, r18 = s6.map(({ scale: e6 }) => e6), a13 = j.create({ spatialReference: t10, size: a4, scales: r18, origin: i12 });
      return e5.set("tileInfo", a13), void (this._srcResolutions = s6.map(({ resolution: e6 }) => ({ x: e6, y: e6 })));
    }
    const { scales: i11, srcResolutions: r17, isCustomTilingScheme: a12 } = xe(this.layer.serviceRasterInfo, t10, { tileSize: a4, alignGlobalDatasetWithAGOL: true, limitToSrcResolution: false }), o10 = j.create({ spatialReference: t10, size: a4, scales: i11 }), l7 = 0 === o10.origin.x;
    n(e5.fullExtent);
    const { xmin: n7, ymax: h16 } = e5.fullExtent;
    (l7 || a12 && o10.origin.x > n7) && (o10.origin = new _({ x: n7, y: h16, spatialReference: t10 })), this._isCustomTilingScheme = a12, e5.set("tileInfo", o10), this._srcResolutions = r17 ?? [];
  }
  _canUseLayerLODs() {
    const { layer: e5, layerView: t10 } = this;
    if ("Map" !== e5.raster.tileType) return false;
    const { lods: i11 } = e5.tileInfo, s6 = t10.view.constraints?.effectiveLODs;
    return s6?.length === i11.length && s6.every(({ scale: e6 }, t11) => Math.abs(e6 - i11[t11].scale) < 1e-3);
  }
  _computeFetchConcurrency() {
    const { blockBoundary: e5 } = this.layer.serviceRasterInfo.storageInfo, t10 = e5[e5.length - 1];
    return (t10.maxCol - t10.minCol + 1) * (t10.maxRow - t10.minRow + 1) > 64 ? 2 : 10;
  }
  async _enqueueTileFetch(e5, t10) {
    if (!this._fetchQueue.has(e5.key.id)) {
      try {
        const t11 = await this._fetchQueue.push(e5.key), r17 = this._getBandIds();
        let o10 = !this.useProgressiveUpdate || this.layerView.hasTilingEffects && !this._globalSymbolizerParams;
        if (this._globalUpdateRequested && !this.layerView.moving && 0 === this._fetchQueue.length) {
          o10 = false;
          try {
            await this._redrawImage(this._abortController?.signal);
          } catch (s6) {
            b(s6) && i.getLogger(this).error(s6);
          }
          this._globalUpdateRequested = false;
        }
        this.canUseLocalSymbolizerParams && null == this._symbolizerParams && this._updateSymbolizerParams();
        const l7 = this._tileInfoView.getTileCoords(C6, e5.key), n7 = this._tileInfoView.getTileResolution(e5.key);
        await this.updateTileSource(e5, { source: t11, symbolizerParams: this._symbolizerParams, globalSymbolizerParams: this._globalSymbolizerParams, suspended: o10, bandIds: r17, coords: l7, resolution: n7 }), e5.once("attach", () => this.layerView.requestUpdate()), this.container.addChild(e5);
      } catch (s6) {
        b(s6) || i.getLogger(this).error(s6);
      }
      this.layerView.requestUpdate();
    }
  }
  async _redrawImage(e5) {
    if (0 === this.container.children.length) return;
    await this.layer.updateRenderer(), this.layerView.hasTilingEffects ? await this._updateGlobalSymbolizerParams(e5) : (this.canUseLocalSymbolizerParams && this._updateSymbolizerParams(), this._globalSymbolizerParams = null);
    const t10 = this.container.children.map(async (e6) => this.updateTileSymbolizerParameters(e6, { local: this._symbolizerParams, global: this._globalSymbolizerParams }));
    await Promise.allSettled(t10), this.container.requestRender();
  }
  async _updateGlobalSymbolizerParams(e5) {
    const t10 = this._getFetchOptions(this.previousLOD.level, e5), i11 = await this.layer.fetchPixels(this.layerView.view.extent, this.layerView.view.width, this.layerView.view.height, { ...t10, interpolation: "nearest", requestRawData: false, skipRasterFunction: false });
    if (!i11?.pixelBlock) return;
    const { resolution: s6 } = this.previousLOD, r17 = this._getBandIds(), a12 = this.layer.symbolizer.generateWebGLParameters({ pixelBlock: i11.pixelBlock.extractBands(r17), isGCS: this.layerView.view.spatialReference.isGeographic, resolution: { x: s6, y: s6 }, bandIds: r17 });
    !this.canUseWebGLForProcessing && a12 && "stretch" === a12.type && this.layer.renderer && "raster-stretch" === this.layer.renderer.type && (a12.factor = a12.factor.map((e6) => 255 * e6), a12.minOutput = Math.round(255 * a12.minOutput), a12.maxOutput = Math.round(255 * a12.maxOutput)), this._globalSymbolizerParams = a12;
  }
  _updateSymbolizerParams() {
    const { resolution: e5 } = this.previousLOD, t10 = this._getBandIds();
    this._symbolizerParams = this.layer.symbolizer.generateWebGLParameters({ pixelBlock: null, isGCS: this.layerView.view.spatialReference.isGeographic, resolution: { x: e5, y: e5 }, bandIds: t10 });
  }
  _updateBlockCacheRegistry(e5 = false) {
    const { layer: t10, layerView: i11 } = this, { raster: s6 } = t10, { multidimensionalDefinition: r17 } = t10.normalizeRasterFetchOptions({ multidimensionalDefinition: t10.multidimensionalDefinition, timeExtent: i11.timeExtent }), a12 = s6.rasterInfo.multidimensionalInfo ? s6.getSliceIndex(r17) : null, o10 = s6.rasterInfo.storageInfo.isBsqTile && t10.bandIds?.length ? t10.bandIds : null, l7 = i3(s6.rasterId, a12, o10);
    if (l7 !== this._blockCacheRegistryUrl) {
      if (null != this._blockCacheRegistryUrl && a3(this._blockCacheRegistryUrl, this._blockCacheRegistryId), this._blockCacheRegistryId = u2(l7, s6.rasterInfo), e5) {
        const { view: e6 } = i11, t11 = this._tileInfoView.getClosestInfoForScale(e6.scale), r18 = this._srcResolutions[t11.level];
        g(l7, this._blockCacheRegistryId, e6.extent, e6.resolution, r18, s6.ioConfig.sampling);
      }
      this._blockCacheRegistryUrl = l7;
    }
  }
  async doRefresh() {
    if (!this.attached || !this.previousLOD || this.layerView.suspended) return;
    await this.layer.updateRenderer(), this.canUseLocalSymbolizerParams && this._updateSymbolizerParams(), this._updateBlockCacheRegistry(true), this._fetchQueue.reset();
    const e5 = [];
    this._globalUpdateRequested = this.layerView.hasTilingEffects || !this.useProgressiveUpdate, this._tileStrategy.refresh((t10) => e5.push(this._enqueueTileFetch(t10))), await this._updatingHandles.addPromise(Promise.allSettled(e5));
  }
};
r([m()], U3.prototype, "_globalUpdateRequested", void 0), r([m()], U3.prototype, "attached", void 0), r([m()], U3.prototype, "canUseWebGLForProcessing", null), r([m()], U3.prototype, "canUseLocalSymbolizerParams", null), r([m()], U3.prototype, "container", void 0), r([m()], U3.prototype, "layer", void 0), r([m()], U3.prototype, "layerView", void 0), r([m()], U3.prototype, "scheduler", void 0), r([m()], U3.prototype, "type", void 0), r([m()], U3.prototype, "useWebGLForProcessing", null), r([m()], U3.prototype, "useProgressiveUpdate", null), r([m()], U3.prototype, "timeExtent", void 0), r([m()], U3.prototype, "updating", null), U3 = r([a("esri.views.2d.layers.imagery.BaseImageryTileSubView2D")], U3);

// node_modules/@arcgis/core/views/2d/layers/imagery/ImageryTileView2D.js
var c10 = class extends U3 {
  constructor() {
    super(...arguments), this.type = "raster";
  }
  get canUseWebGLForProcessing() {
    const { loaded: e5, symbolizer: t10 } = this.layer;
    if (!e5 || !t10) return false;
    const r17 = t10.lookup.colormapLut?.indexedColormap, s6 = r17 && r17.length > this._maxIndexedColormapSize, o10 = l2(this.layer.serviceRasterInfo);
    return !(has("ios") && o10 > 4) && this.useWebGLForProcessing && t10.canRenderInWebGL && !s6 && !("majority" === this.layer.interpolation && o4(this.layer));
  }
  attach() {
    super.attach(), this.container = new c9(this._tileInfoView), this.container.isCustomTilingScheme = this._isCustomTilingScheme, this.updateRasterFunctionParameters();
  }
  detach() {
    super.detach(), this.container.removeAllChildren(), this.container = null;
  }
  fetchTile(e5, t10) {
    return this.layer.fetchTile(e5.level, e5.row, e5.col, t10);
  }
  updateRasterFunctionParameters() {
    const { raster: e5, type: t10 } = this.layer, { container: r17 } = this;
    if ("Function" !== e5.datasetFormat || "wcs" === t10) return r17.rasterFunctionChain = null, r17.children.forEach((e6) => {
      const { bitmap: t11 } = e6;
      t11 && (t11.suspended = true, t11.processed = false, t11.projected && (t11.invalidateTexture(), t11.rasterTexture = null));
    }), void (this._rasterFunctionState = "na");
    const s6 = this._rasterFunctionState, { rasterFunction: i11, primaryRasters: o10 } = e5, n7 = i11.supportsGPU && (!o10 || o10.rasters.length <= 1), a12 = n7 ? i11.flatWebGLFunctionChain : null, { renderer: l7 } = this.layer, c11 = !n7 || !a12?.functions.length || "raster-stretch" === l7?.type && l7.dynamicRangeAdjustment || !this.canUseWebGLForProcessing;
    r17.rasterFunctionChain = c11 ? null : this._addProjection(a12);
    const p6 = null == i11 ? "na" : r17.rasterFunctionChain ? "gpu" : "cpu", u5 = s6 === p6 || "na" === s6 && "cpu" === p6 && 0 === a12?.functions?.length;
    r17.children.forEach((e6) => {
      const { bitmap: t11 } = e6;
      t11 && (t11.suspended = !u5, t11.processed = false, t11.processedTexture = null);
    }), this._rasterFunctionState = p6;
  }
  async updateTileSource(e5, t10) {
    const r17 = this._getBandIds(), i11 = this._getLayerInterpolation(), { canUseWebGLForProcessing: n7 } = this, { source: a12, globalSymbolizerParams: l7, suspended: c11, coords: p6, resolution: u5 } = t10, d6 = this.layerView.hasTilingEffects ? l7 : t10.symbolizerParams, { bitmap: h16 } = e5;
    if ([h16.x, h16.y] = p6, h16.resolution = u5, null != a12?.pixelBlock) {
      const e6 = { extent: a12.extent, pixelBlock: a12.pixelBlock, srcPixelSize: a12.srcTilePixelSize };
      if (h16.rawPixelData = e6, n7) h16.source = a12.pixelBlock, h16.isRendereredSource = false;
      else {
        const t11 = await this.layer.applyRenderer(e6, "stretch" === l7?.type ? l7 : void 0);
        h16.source = t11, h16.isRendereredSource = true;
      }
      h16.symbolizerParameters = n7 ? d6 : null, h16.transformGrid = n7 ? a12.transformGrid : null;
    } else {
      const e6 = this.createEmptyTilePixelBlock();
      h16.source = e6, h16.symbolizerParameters = n7 ? d6 : null, h16.transformGrid = null;
    }
    h16.bandIds = n7 ? r17 : null, h16.width = this._tileInfoView.tileInfo.size[0], h16.height = this._tileInfoView.tileInfo.size[1], h16.interpolation = i11, h16.suspended = c11;
    const { raster: m12 } = this.layer;
    if (r4(m12)) {
      const t11 = m12.getClippingGeometry(this.layerView.view.spatialReference);
      if (t11) {
        const r18 = m12.getTileExtentFromTileInfo(e5.key.level, e5.key.row, e5.key.col, this._tileInfoView.tileInfo);
        h16.mask = x({ srcExtent: r18, geometry: t11, size: [h16.width, h16.height] });
      }
    }
    h16.invalidateTexture();
  }
  async updateTileSymbolizerParameters(e5, t10) {
    const { local: r17, global: s6 } = t10, i11 = this._getBandIds(), o10 = this._getLayerInterpolation(), { canUseWebGLForProcessing: n7 } = this, { bitmap: a12 } = e5, { rawPixelData: l7 } = a12;
    n7 || null == l7 ? (a12.isRendereredSource && null != l7 && (a12.source = l7.pixelBlock), a12.isRendereredSource = false) : (a12.source = await this.layer.applyRenderer(l7, "stretch" === s6?.type ? s6 : void 0), a12.isRendereredSource = true), a12.symbolizerParameters = n7 ? this.layerView.hasTilingEffects ? s6 : r17 : null, a12.bandIds = n7 ? i11 : null, a12.interpolation = o10, a12.suspended = false;
  }
  _getLayerInterpolation() {
    const { interpolation: e5, renderer: t10 } = this.layer;
    if (!t10) return e5;
    const r17 = t10.type;
    return "raster-colormap" === r17 || "unique-value" === r17 ? "nearest" : "raster-stretch" === t10.type && null != t10.colorRamp ? "bilinear" === e5 || "cubic" === e5 ? "bilinear" : "nearest" : e5;
  }
  _addProjection(e5) {
    return e5?.functions?.length && !e5.hasFocalFunction && e5.functions.unshift({ name: "Reproject", parameters: { targetImageSize: this._tileInfoView.tileInfo.size, requireNNEdge: e5.isSourceSingleBand }, pixelType: "f32", id: 0, isNoopProcess: false }), e5;
  }
};
r([m()], c10.prototype, "canUseWebGLForProcessing", null), r([m()], c10.prototype, "container", void 0), r([m()], c10.prototype, "layer", void 0), r([m()], c10.prototype, "type", void 0), c10 = r([a("esri.views.2d.layers.imagery.ImageryTileView2D")], c10);

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFTile.js
var r16 = class extends r7 {
  constructor(t10, e5, s6, a12, r17, l7, o10 = null) {
    super(t10, e5, s6, a12, r17, l7), this.tileData = new f2(o10), this.tileData.coordScale = [r17, l7], this.tileData.once("isReady", () => this.ready());
  }
  destroy() {
    super.destroy(), this.tileData.destroy(), this.tileData = null, this.stage = null;
  }
  set stencilRef(t10) {
    this.tileData.stencilRef = t10;
  }
  get stencilRef() {
    return this.tileData.stencilRef;
  }
  _createTransforms() {
    return { displayViewScreenMat3: e2(), tileMat3: e2() };
  }
  setTransform(s6) {
    super.setTransform(s6);
    const i11 = this.resolution / (s6.resolution * s6.pixelRatio), a12 = this.transforms.tileMat3, [r17, l7] = this.tileData.offset, o10 = [this.x + r17 * this.resolution, this.y - l7 * this.resolution], [n7, h16] = s6.toScreenNoRotation([0, 0], o10), { symbolTileSize: c11 } = this.tileData.symbolizerParameters, f8 = Math.round((this.width - this.tileData.offset[0]) / c11) * c11, m12 = Math.round((this.height - this.tileData.offset[1]) / c11) * c11, D3 = f8 / this.rangeX * i11, d6 = m12 / this.rangeY * i11;
    r3(a12, D3, 0, 0, 0, d6, 0, n7, h16, 1), i2(this.transforms.displayViewScreenMat3, s6.displayViewMat3, a12), this.tileData.transforms.displayViewScreenMat3 = this.transforms.displayViewScreenMat3;
  }
  onAttach() {
    this.tileData.stage = this.stage;
  }
  onDetach() {
    this.tileData.stage = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFTileContainer.js
var o9 = class extends i4 {
  constructor() {
    super(...arguments), this.isCustomTilingScheme = false, this.symbolTypes = ["triangle"];
  }
  createTile(s6) {
    const t10 = this.tileInfoView.getTileBounds(u(), s6), [i11, o10] = this.tileInfoView.tileInfo.size, n7 = this.tileInfoView.getTileResolution(s6.level);
    return new r16(s6, n7, t10[0], t10[3], i11, o10);
  }
  prepareRenderPasses(e5) {
    const r17 = e5.registerRenderPass({ name: "imagery (vf tile)", brushes: [d2], target: () => this.children.map((e6) => e6.tileData), drawPhase: E.MAP });
    return [...super.prepareRenderPasses(e5), r17];
  }
  doRender(e5) {
    this.visible && e5.drawPhase === E.MAP && this.symbolTypes.forEach((s6) => {
      e5.renderPass = s6, super.doRender(e5);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/imagery/VectorFieldTileView2D.js
var a11 = class extends U3 {
  constructor() {
    super(...arguments), this._handle = null, this.type = "rasterVF";
  }
  async fetchTile(e5, t10) {
    t10 = { ...t10, interpolation: "nearest", requestProjectedLocalDirections: true };
    const i11 = await this.layer.fetchTile(e5.level, e5.row, e5.col, t10);
    return "vector-magdir" === this.layer.serviceRasterInfo?.dataType && i11?.pixelBlock && (i11.pixelBlock = await this.layer.convertVectorFieldData(i11.pixelBlock, "vector-magdir", t10)), i11;
  }
  updateTileSource(e5, t10) {
    const i11 = t10.symbolizerParams, { tileData: r17 } = e5;
    r17.key = e5.key, r17.width = this._tileInfoView.tileInfo.size[0], r17.height = this._tileInfoView.tileInfo.size[1];
    const { symbolTileSize: o10 } = i11, { source: s6 } = t10;
    if (r17.offset = this._getTileSymbolOffset(r17.key, o10), null != s6?.pixelBlock) {
      const e6 = { extent: s6.extent, pixelBlock: s6.pixelBlock };
      r17.rawPixelData = e6, r17.symbolizerParameters = i11, r17.source = this._sampleVectorFieldData(s6.pixelBlock, i11, r17.offset);
    } else {
      const e6 = [Math.round((this._tileInfoView.tileInfo.size[0] - r17.offset[0]) / o10), Math.round((this._tileInfoView.tileInfo.size[1] - r17.offset[1]) / o10)], t11 = this.createEmptyTilePixelBlock(e6);
      r17.source = t11, r17.symbolizerParameters = i11;
    }
    return r17.invalidateVAO(), Promise.resolve();
  }
  updateTileSymbolizerParameters(e5, t10) {
    const i11 = t10.local, { symbolTileSize: r17 } = i11, { tileData: o10 } = e5;
    o10.offset = this._getTileSymbolOffset(o10.key, r17);
    const s6 = o10.symbolizerParameters.symbolTileSize;
    o10.symbolizerParameters = i11;
    const l7 = o10.rawPixelData?.pixelBlock;
    return null != l7 && s6 !== r17 && (o10.source = this._sampleVectorFieldData(l7, o10.symbolizerParameters, o10.offset)), Promise.resolve();
  }
  attach() {
    super.attach(), this.container = new o9(this._tileInfoView), this.container.isCustomTilingScheme = this._isCustomTilingScheme, this._updateSymbolType(this.layer.renderer), this._handle = l(() => this.layer.renderer, (e5) => this._updateSymbolType(e5));
  }
  detach() {
    super.detach(), this.container.removeAllChildren(), this._handle?.remove(), this._handle = null, this.container = null;
  }
  _getTileSymbolOffset(e5, t10) {
    const i11 = e5.col * this._tileInfoView.tileInfo.size[0] % t10, r17 = e5.row * this._tileInfoView.tileInfo.size[1] % t10;
    return [i11 > t10 / 2 ? t10 - i11 : -i11, r17 > t10 / 2 ? t10 - r17 : -r17];
  }
  _sampleVectorFieldData(e5, t10, i11) {
    const { symbolTileSize: r17 } = t10;
    return S(e5, "vector-uv", r17, i11);
  }
  _updateSymbolType(e5) {
    "vector-field" === e5?.type && (this.container.symbolTypes = "wind-barb" === e5.style ? ["scalar", "triangle"] : "simple-scalar" === e5.style ? ["scalar"] : ["triangle"]);
  }
};
r([m()], a11.prototype, "container", void 0), r([m()], a11.prototype, "layer", void 0), r([m()], a11.prototype, "type", void 0), a11 = r([a("esri.views.2d.layers.imagery.VectorFieldTileView2D")], a11);

// node_modules/@arcgis/core/views/layers/ImageryTileLayerView.js
var f7 = (f8) => {
  let d6 = class extends f8 {
    constructor() {
      super(...arguments), this.layer = null, this.tileInfo = null;
    }
    get fullExtent() {
      try {
        return this.layer.loaded ? this._getFullExtent() : null;
      } catch {
        return null;
      }
    }
    get timeExtent() {
      return i6(this.layer, this.view?.timeExtent, this._get("timeExtent"));
    }
    get hasTilingEffects() {
      return !!(this.layer.renderer && "dynamicRangeAdjustment" in this.layer.renderer && this.layer.renderer.dynamicRangeAdjustment);
    }
    get datumTransformation() {
      try {
        return this.layer.loaded ? C2(this.layer.fullExtent, this.view.spatialReference, true) : null;
      } catch {
        return null;
      }
    }
    supportsSpatialReference(e5) {
      try {
        return !this.layer.loaded || !!me(this.layer.serviceRasterInfo, e5);
      } catch {
        return false;
      }
    }
    async fetchPopupFeaturesAtLocation(e5, s6) {
      const { layer: i11 } = this;
      if (!e5) throw new s("imageryTileLayerView:fetchPopupFeatures", "Nothing to fetch without area", { layer: i11 });
      const { popupEnabled: l7 } = i11, p6 = p(i11, s6);
      if (!l7 || null == p6) return [];
      const c11 = [], { value: m12, magdirValue: f9, processedValue: d7 } = await i11.identify(e5, { timeExtent: this.timeExtent, signal: s6?.signal });
      let h16 = "";
      if (m12?.length) {
        h16 = "imagery-tile" === i11.type && i11.hasStandardTime() && null != m12[0] ? m12.map((e7) => i11.getStandardTimeValue(e7)).join(", ") : m12.join(", ");
        const e6 = { ObjectId: 0 };
        e6[t.servicePixelValue] = "imagery-tile" === i11.type && r4(i11.raster) ? d7?.join(", ") : h16, e6[t.rawServicePixelValue] = h16;
        const r17 = i11.raster?.rasterInfo ?? i11.serviceRasterInfo, s7 = r17?.attributeTable;
        if (null != s7) {
          const { fields: t10, features: r18 } = s7, i12 = t10.find(({ name: e7 }) => "value" === e7.toLowerCase()), a12 = e6[t.servicePixelValue], l9 = i12 ? r18.find((e7) => String(e7.attributes[i12.name]) === a12) : null;
          if (l9) {
            for (const s8 in l9.attributes) if (l9.attributes.hasOwnProperty(s8)) {
              e6[n2 + s8] = l9.attributes[s8];
            }
          }
        }
        const l8 = r17?.dataType;
        "vector-magdir" !== l8 && "vector-uv" !== l8 || (e6[t.magnitude] = f9?.[0], e6[t.direction] = f9?.[1]);
        const { multidimensionalDefinition: p7 } = this.layer.normalizeRasterFetchOptions({ timeExtent: this.timeExtent });
        V(i11.rasterFields, e6, p7);
        const y5 = new d({ geometry: this.fullExtent?.clone(), attributes: e6, layer: i11, sourceLayer: i11 });
        c11.push(y5);
      }
      return c11;
    }
    async getSourceScale() {
      return await this.layer.load(), O(this.layer.serviceRasterInfo, this.view.spatialReference);
    }
    _getFullExtent() {
      return me(this.layer.serviceRasterInfo, this.view.spatialReference);
    }
  };
  return r([m()], d6.prototype, "fullExtent", null), r([m()], d6.prototype, "layer", void 0), r([m({ readOnly: true })], d6.prototype, "timeExtent", null), r([m()], d6.prototype, "tileInfo", void 0), r([m({ readOnly: true })], d6.prototype, "hasTilingEffects", null), r([m()], d6.prototype, "datumTransformation", null), d6 = r([a("esri.views.layers.ImageryTileLayerView")], d6), d6;
};

// node_modules/@arcgis/core/views/2d/layers/ImageryTileLayerView2D.js
var w4 = class extends f7(i5(S3(u3))) {
  constructor() {
    super(...arguments), this._useWebGLForProcessing = true, this._useProgressiveUpdate = true, this.subview = null;
  }
  get useWebGLForProcessing() {
    return this._useWebGLForProcessing;
  }
  set useWebGLForProcessing(e5) {
    this._useWebGLForProcessing = e5, this.subview && "useWebGLForProcessing" in this.subview && (this.subview.useWebGLForProcessing = e5);
  }
  get useProgressiveUpdate() {
    return this._useWebGLForProcessing;
  }
  set useProgressiveUpdate(e5) {
    this._useProgressiveUpdate = e5, this.subview && "useProgressiveUpdate" in this.subview && (this.subview.useProgressiveUpdate = e5);
  }
  get displayParameters() {
    const { layer: e5 } = this, s6 = this._get("displayParameters");
    return e5.renderer && e5.visible ? { bandIds: e5.bandIds, renderer: e5.renderer, interpolation: e5.interpolation, multidimensionalDefinition: e5.multidimensionalDefinition, rasterFunction: "imagery-tile" === e5.type ? e5.rasterFunction : null } : s6;
  }
  update(e5) {
    this.subview?.update(e5), this.notifyChange("updating");
  }
  isUpdating() {
    return !this.subview || this.subview.updating;
  }
  attach() {
    this.layer.increaseRasterJobHandlerUsage(), this._updateSubview(), this.addAttachHandles([l(() => this.displayParameters, (e5, t10) => {
      const r17 = e5.interpolation !== t10?.interpolation && ("majority" === e5.interpolation || "majority" === t10?.interpolation) && o4(this.layer), o10 = !!this.layer.serviceRasterInfo?.storageInfo?.isBsqTile && e5.bandIds?.join() !== t10?.bandIds?.join(), a12 = e5.renderer !== t10?.renderer && this._getSubviewType(t10?.renderer) !== this._getSubviewType(e5.renderer);
      a12 && this._updateSubview();
      const n7 = e5.multidimensionalDefinition !== t10?.multidimensionalDefinition, u5 = e5.rasterFunction !== t10?.rasterFunction, h16 = u5 && !this._useWebGLForProcessing, l7 = n7 || r17 || a12 || h16 || o10;
      this.subview.redrawOrRefetch({ refetch: l7, reprocess: u5 }).catch((e6) => {
        b(e6) || i.getLogger(this).error(e6);
      }), this.notifyChange("updating");
    }), l(() => this.layer.multidimensionalSubset ?? null, (e5, t10) => {
      const { multidimensionalDefinition: r17 } = this.layer;
      null != r17 && o2(r17, e5) !== o2(r17, t10) && (this.subview.redrawOrRefetch({ refetch: true }).catch((e6) => {
        b(e6) || i.getLogger(this).error(e6);
      }), this.notifyChange("updating"));
    }, U), l(() => this.timeExtent, () => {
      this.subview.timeExtent = this.timeExtent, this.subview.redrawOrRefetch({ refetch: true }).catch((e5) => {
        b(e5) || i.getLogger(this).error(e5);
      });
    }, h)]);
  }
  detach() {
    this.layer.decreaseRasterJobHandlerUsage(), this._detachSubview(this.subview), this.subview?.destroy(), this.subview = null;
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.subview.moveEnd();
  }
  doRefresh() {
    return this.subview ? this.subview.doRefresh() : Promise.resolve();
  }
  _updateSubview() {
    const { renderer: e5 } = this.layer;
    if (!e5) return;
    const s6 = this._getSubviewType(e5);
    if (this.subview) {
      if (this.subview.type === s6) return void this._attachSubview(this.subview);
      this._detachSubview(this.subview), this.subview?.destroy(), this.subview = null;
    }
    const { layer: i11 } = this;
    let t10;
    if (t10 = "rasterVF" === s6 ? new a11({ layer: i11, layerView: this, scheduler: this.scheduler }) : "flow" === s6 ? new h5({ layer: i11, layerView: this, scheduler: this.scheduler }) : new c10({ layer: i11, layerView: this, scheduler: this.scheduler }), "useWebGLForProcessing" in t10 && (t10.useWebGLForProcessing = this._useWebGLForProcessing), "useProgressiveUpdate" in t10 && (t10.useProgressiveUpdate = this._useProgressiveUpdate), "previousLOD" in t10) {
      const { subview: e6 } = this;
      t10.previousLOD = e6 && "previousLOD" in e6 ? e6.previousLOD : null;
    }
    this._attachSubview(t10), this.subview = t10, this.requestUpdate();
  }
  _attachSubview(e5) {
    e5 && !e5.attached && (e5.attach(), e5.attached = true, this.container.addChildAt(e5.container, 0));
  }
  _detachSubview(e5) {
    e5?.attached && (this.container.removeChild(e5.container), e5.detach(), e5.attached = false);
  }
  _getSubviewType(e5) {
    const s6 = e5?.type;
    return "vector-field" === s6 ? "rasterVF" : "flow" === s6 ? "flow" : "raster";
  }
};
r([m()], w4.prototype, "subview", void 0), r([m()], w4.prototype, "useWebGLForProcessing", null), r([m()], w4.prototype, "useProgressiveUpdate", null), r([m({ readOnly: true })], w4.prototype, "displayParameters", null), w4 = r([a("esri.views.2d.layers.ImageryTileLayerView2D")], w4);
var g8 = w4;
export {
  g8 as default
};
//# sourceMappingURL=ImageryTileLayerView2D-WBEZT2P5.js.map
