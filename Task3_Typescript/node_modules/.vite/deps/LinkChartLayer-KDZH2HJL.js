import {
  A,
  C,
  D,
  E,
  Ie,
  P,
  _ as _3,
  a as a2,
  b as b3,
  g,
  h2,
  i as i2,
  i2 as i3,
  m2,
  o as o2,
  o2 as o3,
  u as u3,
  v
} from "./chunk-6SUT35DV.js";
import {
  I,
  S as S2,
  _ as _2,
  o,
  t as t3
} from "./chunk-WGTPS6U6.js";
import "./chunk-524UHFSB.js";
import "./chunk-H5N2AXWG.js";
import "./chunk-P4YXQBLK.js";
import "./chunk-WUKLWX63.js";
import "./chunk-LHJOMFWG.js";
import "./chunk-YN3U6WZN.js";
import "./chunk-APGIAJ3M.js";
import "./chunk-ES5H7VGK.js";
import "./chunk-JV7SG7ZY.js";
import "./chunk-2XBUTZI3.js";
import {
  ue
} from "./chunk-VFUR4QXG.js";
import "./chunk-O75YZHXO.js";
import "./chunk-IY3QUJDS.js";
import "./chunk-LW7J7Z4M.js";
import "./chunk-NLQ5JBZ3.js";
import "./chunk-WQVEQTKW.js";
import {
  ut
} from "./chunk-DKS7UUDR.js";
import "./chunk-KDQWOWXR.js";
import "./chunk-JOVQBCRD.js";
import "./chunk-7TPOIM4Y.js";
import "./chunk-LNFOAX5I.js";
import "./chunk-U3MD377S.js";
import "./chunk-2B6XECE5.js";
import "./chunk-QB5ST4HW.js";
import "./chunk-OIO6NR6X.js";
import "./chunk-F5BDMX7A.js";
import "./chunk-OFHPFWHF.js";
import "./chunk-MZJEBIXX.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-AAC6XSCN.js";
import "./chunk-Z7VYTTYM.js";
import "./chunk-BDWOUZQR.js";
import "./chunk-H34ENSPL.js";
import "./chunk-4ADC6HZF.js";
import "./chunk-XFKS4JQP.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-LBC3MAJX.js";
import "./chunk-FSVG2RRX.js";
import "./chunk-L3O6KWVI.js";
import "./chunk-WIICHW3C.js";
import "./chunk-T4BWGCN6.js";
import "./chunk-AC7GOP3F.js";
import "./chunk-XPKVLOAO.js";
import "./chunk-GESOBEYT.js";
import "./chunk-E7YVYF37.js";
import "./chunk-E76L26GR.js";
import "./chunk-GG4VLKUY.js";
import "./chunk-IL45XPTT.js";
import "./chunk-6MFKAT6L.js";
import "./chunk-NOWX6W7R.js";
import "./chunk-OQ76WPLD.js";
import "./chunk-UTU6N7VJ.js";
import "./chunk-RV3SBM2C.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-B6C7UPBZ.js";
import "./chunk-IUQBXXYO.js";
import "./chunk-7WKBQS4R.js";
import {
  p
} from "./chunk-XLF2NMGX.js";
import {
  t as t2
} from "./chunk-X5GD6LFD.js";
import {
  b2,
  y as y2
} from "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import "./chunk-OTSYE6UT.js";
import "./chunk-K5LVZUBF.js";
import "./chunk-J7LSFQNH.js";
import "./chunk-AGDHKBKD.js";
import "./chunk-OC2XWDW2.js";
import "./chunk-C3JHRSMA.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-HUVZEBBO.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-I6IIPG56.js";
import "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-YSCIEMYQ.js";
import "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import {
  h
} from "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-KHRHKYU2.js";
import "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-QVKLS4LH.js";
import "./chunk-2KVNXQA7.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import {
  y
} from "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  U,
  l
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  e,
  m,
  t2 as t
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import {
  u
} from "./chunk-S7IJH524.js";
import {
  b,
  s as s2,
  u3 as u2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/knowledgeGraph/IdealEdgeLengthTypeOptions.js
var e2;
!function(e3) {
  e3.MULTIPLIER = "multiplier", e3.ABSOLUTE = "absolute-value";
}(e2 || (e2 = {}));

// node_modules/@arcgis/core/layers/LinkChartLayer.js
var q = class extends b2(p(t2(S(h)))) {
  constructor(e3) {
    if (super(e3), this.url = null, this.dataPreloadedInLocalCache = false, this.initializationLinkChartConfig = null, this.membershipModified = true, this._currentLinkChartConfig = { layoutMode: "organic-standard" }, this._graphTypeLookup = /* @__PURE__ */ new Map(), this.dataManager = null, this.knowledgeGraph = null, this.layers = new (V.ofType(Ie))(), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.linkChartExtent = new z({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 }), this.memberEntityTypes = null, this.memberRelationshipTypes = null, this.operationalLayerType = "LinkChartLayer", this.sublayerIdsCache = /* @__PURE__ */ new Map(), this.tables = new (V.ofType(Ie))(), this.type = "link-chart", this.chronologicalAuxiliaryGraphics = null, this._originalInclusionList = e3?.initializationInclusionModeDefinition, e3?.dataPreloadedInLocalCache && !e3?.initializationInclusionModeDefinition) throw new s("knowledge-graph:linkchart-layer-constructor", "If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");
    this.addHandles(l(() => this.layers.concat(this.tables), (e4, t4) => this._handleSublayersChange(e4, t4), U));
  }
  normalizeCtorArgs(e3) {
    if (!e3) return {};
    const { url: t4, title: a3, dataPreloadedInLocalCache: i4, initializationLinkChartConfig: n } = e3;
    return { url: t4, title: a3, dataPreloadedInLocalCache: i4, initializationLinkChartConfig: n };
  }
  _initializeLayerProperties(e3) {
    if (!this.title && this.url) {
      const e4 = this.url.split("/");
      this.title = e4[e4.length - 2];
    }
    const t4 = /* @__PURE__ */ new Set();
    let a3 = [], o4 = [];
    if (e3.inclusionModeDefinition && (!e3.inclusionModeDefinition.namedTypeDefinitions || e3.inclusionModeDefinition.namedTypeDefinitions.size < 1)) throw new s("knowledge-graph:composite-layer-constructor", "If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");
    e3.inclusionModeDefinition?.generateAllSublayers ? (a3 = e3.knowledgeGraph.dataModel.entityTypes ?? [], o4 = e3.knowledgeGraph.dataModel.relationshipTypes ?? []) : e3.inclusionModeDefinition?.namedTypeDefinitions && e3.inclusionModeDefinition?.namedTypeDefinitions.size > 0 ? e3.inclusionModeDefinition?.namedTypeDefinitions.forEach((i4, s4) => {
      const r2 = this._graphTypeLookup.get(s4);
      if (!r2) return i.getLogger(this).warn(`A named type, ${s4}, was in the inclusion list that wasn't in the data model and will be removed`), void e3.inclusionModeDefinition?.namedTypeDefinitions.delete(s4);
      "relationship" === r2.type ? t4.has(s4) || (t4.add(s4), o4.push(r2)) : "entity" === r2.type ? t4.has(s4) || (t4.add(s4), a3.push(r2)) : (i.getLogger(this).warn(`A named type, ${s4}, was in the inclusion list that wasn't properly modeled and will be removed`), e3.inclusionModeDefinition?.namedTypeDefinitions.delete(s4));
    }) : (a3 = e3.knowledgeGraph.dataModel.entityTypes ?? [], o4 = e3.knowledgeGraph.dataModel.relationshipTypes ?? []);
    const s3 = new E({ knowledgeGraph: e3.knowledgeGraph, inclusionModeDefinition: e3.inclusionModeDefinition });
    this.knowledgeGraph = e3.knowledgeGraph, this.memberEntityTypes = a3, this.memberRelationshipTypes = o4, this.dataManager = s3;
  }
  load(e3) {
    const a3 = async () => {
      const e4 = [], t4 = [];
      this.loadLayerAssumingLocalCache(), this._layersLoadedFromAuthoritativeItem() || await i3(this), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e5) => {
        e5.useAllData = false;
      }), await this._initializeDiagram(), this.layers.forEach((a4) => {
        t4.push(a4.refreshCachedQueryEngine()), e4.push(new Promise((e5) => {
          a4.on("layerview-create", () => {
            e5(null);
          });
        }));
      }), this.tables.forEach((e5) => {
        t4.push(e5.refreshCachedQueryEngine());
      }), await Promise.all(t4);
    };
    return this.addResolvingPromise(new Promise((i4) => {
      ue(this.url).then(async (n) => {
        n.dataModel.entityTypes?.forEach((e4) => {
          e4.name && this._graphTypeLookup.set(e4.name, e4);
        }), n.dataModel.relationshipTypes?.forEach((e4) => {
          e4.name && this._graphTypeLookup.set(e4.name, e4);
        });
        const s3 = this.linkChart?.linkChartProperties;
        if (s3?.originIdOf("entitiesUrl") === e.LINK_CHART && (this.membershipModified = false, this._originalInclusionList = await D.fetchAndConvertSerializedLinkChart({ entitiesUrl: s3?.entitiesUrl, relationshipsUrl: s3?.relationshipsUrl }), this._alignLayersDataModelAndInclusionDefinition(n.dataModel), this.initializationLinkChartConfig = { layoutSettings: s3?.layoutSettings ?? void 0, layoutMode: C(s3.layoutType) }), this._initializeLayerProperties({ knowledgeGraph: n, inclusionModeDefinition: this._originalInclusionList }), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size || (this.dataManager.inclusionModeDefinition = { generateAllSublayers: false, namedTypeDefinitions: /* @__PURE__ */ new Map() }, this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((e4) => {
          e4.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e4.name, { useAllData: true });
        }), this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((e4) => {
          e4.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e4.name, { useAllData: true });
        })), this.dataPreloadedInLocalCache) {
          const e4 = o2.getInstance();
          for (const [t4, a4] of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions ?? []) for (const i5 of a4.members?.values() ?? []) {
            const a5 = e4.readFromStoreById(`${t4}__${i5.id}`);
            if (a5) {
              u(this.dataManager.sublayerCaches, t4, () => /* @__PURE__ */ new Map()).set(i5.id, a5);
            }
          }
          await a3();
        } else {
          const t4 = "geographic-organic-standard" === this.initializationLinkChartConfig?.layoutMode;
          this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0, false, t4, true).then(async () => {
            s2(e3), await a3();
          }));
        }
        i4(null);
      });
    })), Promise.resolve(this);
  }
  set initializationInclusionModeDefinition(e3) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("initializationInclusionModeDefinition", e3) : i.getLogger(this).error("#initializationInclusionModeDefinition", "initializationInclusionModeDefinition cannot be changed after the layer is loaded.");
  }
  get linkChart() {
    return this.parent;
  }
  async addRecords(e3, t4) {
    let a3 = [];
    t4?.cascadeAddRelationshipEndNodes && this.dataManager.knowledgeGraph.dataModel && (a3 = await g(e3, this.dataManager.knowledgeGraph));
    const i4 = e3.concat(a3).filter((e4) => !this.sublayerIdsCache.get(e4.typeName)?.has(e4.id));
    i4.length > 0 && (this.membershipModified = true), await this._handleNewRecords(i4, t4);
  }
  async createSublayerForNamedType(e3) {
    await this.load();
    const t4 = this._graphTypeLookup.get(e3);
    if (!t4) throw new s("knowledge-graph:missing-type", "The specified type does not exist in the knowledge graph.");
    if (this.dataManager.sublayerCaches.has(e3)) throw new s("knowledge-graph:duplicate-type", "The specified type already exists as a sublayer.");
    this.dataManager.sublayerCaches.set(e3, /* @__PURE__ */ new Map()), u(this.sublayerIdsCache, e3, () => /* @__PURE__ */ new Set());
    const a3 = this._createSublayer(t4);
    return "entity" === t4.type ? this.dataManager.entityTypeNames.add(e3) : this.dataManager.relationshipTypeNames.add(e3), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.set(e3, { useAllData: false, members: /* @__PURE__ */ new Map() }), a3.geometryType ? this.layers.push(a3) : this.tables.push(a3), await i3(this, [e3]), this._refreshNamedTypes(), a3;
  }
  async removeRecords(e3, { cascadeRemoveRelationships: t4 = true, recalculateLayout: a3 = false, overrideMembershipCheck: i4 = false } = { cascadeRemoveRelationships: true, recalculateLayout: false, overrideMembershipCheck: false }) {
    let n = [];
    for (const r2 of e3) (i4 || false === this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(r2.typeName)?.useAllData && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(r2.typeName)?.members?.has(r2.id)) && n.push(r2);
    if (t4) {
      const e4 = /* @__PURE__ */ new Set(), t5 = [];
      for (const a4 of n) if (this.dataManager.nodeConnectionsLookup.has(a4.id)) for (const t6 of this.dataManager.nodeConnectionsLookup.get(a4.id)) e4.add(t6);
      for (const a4 of e4) if (this.dataManager.memberIdTypeLookup.has(a4)) for (const e5 of this.dataManager.memberIdTypeLookup.get(a4)) this.dataManager.relationshipTypeNames.has(e5) && t5.push({ id: a4, typeName: e5 });
      n = n.concat(t5);
    }
    this.dataManager.removeFromLayer(n);
    for (const r2 of n) this.sublayerIdsCache.get(r2.typeName)?.delete(r2.id), this.dataManager.relationshipTypeNames.has(r2.typeName) ? this.relationshipLinkChartDiagramLookup.delete(r2.id) : this.entityLinkChartDiagramLookup.delete(r2.id);
    const o4 = a3 ? void 0 : this.getCurrentNodeLocations();
    await this._calculateLayoutWithSublayerTimeInfo(this._currentLinkChartConfig.layoutMode, { layoutSettings: this._currentLinkChartConfig.layoutSettings, lockedNodeLocations: o4 }), n.length > 0 && (this.membershipModified = true);
    const s3 = [];
    return this.layers.forEach((e4) => {
      s3.push(e4.refreshCachedQueryEngine());
    }), await Promise.all(s3), this._refreshNamedTypes(), n;
  }
  async expand(e3, t4) {
    let a3 = [];
    try {
      const i4 = await this.dataManager.getConnectedRecordIds(e3, t4?.relationshipTypeNames, t4);
      a3 = i4.filter((e4) => !this.sublayerIdsCache.get(e4.typeName)?.has(e4.id)), await this._handleNewRecords(a3, t4), i4.length > 0 && (this.membershipModified = true), s2(t4?.signal);
    } catch (i4) {
      throw b(i4) && a3.length > 0 && await this.removeRecords(a3, { overrideMembershipCheck: true }), i4;
    }
    return { records: a3 };
  }
  loadLayerAssumingLocalCache() {
    const e3 = [...this.memberRelationshipTypes, ...this.memberEntityTypes];
    this.layers.length || this.originIdOf("tables") === e.DEFAULTS ? this.originIdOf("layers") === e.DEFAULTS ? this._createSublayers(e3, this.layers, (e4) => !!e4.geometryType) : this._updateSublayers(e3, this.layers) : this.layers = new V(), this.tables.length || this.originIdOf("layers") === e.DEFAULTS ? this.originIdOf("tables") === e.DEFAULTS ? this._createSublayers(e3, this.tables, (e4) => !e4.geometryType) : this._updateSublayers(e3, this.tables) : this.tables = new V(), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e4, t4) => {
      const a3 = u(this.sublayerIdsCache, t4, () => /* @__PURE__ */ new Set());
      e4.members?.forEach(({ id: e5, linkChartLocation: i4 }) => {
        if (a3.add(e5), i4) {
          const a4 = "coords" in i4 && "lengths" in i4 ? i4 : ut(i4);
          this.dataManager.relationshipTypeNames.has(t4) ? this.relationshipLinkChartDiagramLookup.set(e5, a4) : this.entityLinkChartDiagramLookup.set(e5, a4);
        }
      });
    });
  }
  async calculateLinkChartLayout(e3 = "organic-standard", t4) {
    const a3 = [], s3 = [], l2 = [];
    this.dataManager.sublayerCaches.forEach((e4, t5) => {
      this.dataManager.entityTypeNames.has(t5) ? e4.forEach((e5) => {
        a3.push({ typeName: t5, feature: e5 });
      }) : this.dataManager.relationshipTypeNames.has(t5) && e4.forEach((e5) => {
        s3.push({ typeName: t5, feature: e5 });
      });
    }), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map();
    const d = /* @__PURE__ */ new Map(), p2 = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), u4 = /* @__PURE__ */ new Map(), y3 = new Uint8Array(a3.length), g2 = new Float64Array(a3.length), w = new Float64Array(a3.length), D2 = new Float64Array(a3.length), v2 = new Float64Array(a3.length), x = new Uint32Array(s3.length), I2 = new Uint32Array(s3.length), E2 = new Float64Array(s3.length), S3 = new Float64Array(s3.length), _4 = [], A2 = "organic-standard";
    let R = false;
    const j = new z({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 });
    let G, V2 = "organic-standard", q2 = 0, J2 = 0;
    const X = m2.apply;
    switch (V2 = "geographic-organic-standard" === e3 ? A2 : e3, V2) {
      case "organic-standard":
        G = v.apply;
        break;
      case "organic-community":
        G = A.apply;
        break;
      case "hierarchical-bottom-to-top":
        G = P.apply;
        break;
      case "radial-root-centric":
        G = _3.apply;
        break;
      case "tree-left-to-right":
        G = h2.apply;
        break;
      default:
        G = b3.apply;
    }
    let Y = false;
    a3.forEach(({ typeName: a4, feature: i4 }) => {
      if ("chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 && t4?.lockedNodeLocations?.has(i4.attributes[_2])) {
        "geographic-organic-standard" === e3 && this.dataManager.geographicLookup.has(a4) ? y3[q2] = i2.IsGeographic : y3[q2] = i2.None;
        const n = t4.lockedNodeLocations.get(i4.attributes[_2]);
        g2[q2] = n.x, w[q2] = n.y;
      } else if ("geographic-organic-standard" === e3 && this.dataManager.geographicLookup.has(a4)) {
        y3[q2] = i2.IsGeographic;
        let e4 = null;
        const t5 = i4.attributes[this.dataManager.geographicLookup.get(a4).name], n = this.dataManager.geographicLookup.get(a4)?.geometryType;
        switch (n) {
          case "esriGeometryPoint":
            g2[q2] = t5?.x, w[q2] = t5?.y;
            break;
          case "esriGeometryPolygon":
            e4 = t5?.centroid, null != e4?.x && null != e4?.y ? (g2[q2] = e4.x, w[q2] = e4.y) : y3[q2] = i2.IsMovable;
            break;
          case "esriGeometryPolyline":
          case "esriGeometryMultipoint":
            e4 = t5?.extent?.center, null != e4?.x && null != e4?.y ? (g2[q2] = e4.x, w[q2] = e4.y) : y3[q2] = i2.IsMovable;
            break;
          default:
            y3[q2] = i2.IsMovable;
        }
        (null == g2[q2] || null == w[q2] || Number.isNaN(g2[q2]) || Number.isNaN(w[q2])) && (y3[q2] = i2.IsMovable, g2[q2] = 0, w[q2] = 0);
      } else if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
        !Y && t4?.lockedNodeLocations?.has(i4.attributes[_2]) && (Y = true);
        const e4 = t4?.timeInfoByTypeName?.get(a4), n = e4?.startField, o4 = n && e4?.startField ? i4.attributes[n] : null;
        D2[q2] = o4 ? new Date(o4).getTime() : NaN;
        const s4 = e4?.endField, r2 = s4 && e4?.endField ? i4.attributes[s4] : null;
        v2[q2] = r2 ? new Date(r2).getTime() : NaN, g2[q2] = 0, w[q2] = 0, y3[q2] = i2.IsMovable;
      } else y3[q2] = i2.IsMovable, g2[q2] = 0, w[q2] = 0;
      u4.set(i4.attributes[_2], q2), _4[q2] = { feature: i4, typeName: a4 }, q2++;
    }), Y && i.getLogger(this).warn("Locked node locations are not supported for chronological layout at this time.  Requested node locations were ignored");
    let Z = false;
    const ee = /* @__PURE__ */ new Map();
    s3.forEach((a4) => {
      const i4 = a4.feature.attributes[I], n = a4.feature.attributes[t3], o4 = u4.get(i4), s4 = u4.get(n), r2 = t4?.timeInfoByTypeName?.get(a4.typeName), h3 = t4?.timeInfoByTypeName ? r2?.startField : null, d2 = h3 ? a4.feature.attributes[h3] : null, p3 = r2?.endField, c2 = p3 ? a4.feature.attributes[p3] : null;
      if (void 0 !== o4 && void 0 !== s4) {
        let t5 = i4 + "-" + n;
        "chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 || (t5 = t5 + "-" + d2 + "-" + c2);
        const r3 = ee.get(t5), h4 = r3?.has(a4.typeName);
        h4 || (x[J2] = o4, I2[J2] = s4, "chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 || (E2[J2] = d2 ? new Date(d2).getTime() : NaN, S3[J2] = c2 ? new Date(c2).getTime() : NaN), void 0 === r3 ? ee.set(t5, /* @__PURE__ */ new Map([[a4.typeName, J2]])) : r3.set(a4.typeName, J2), J2++), l2.push(a4);
      } else Z = true, this.relationshipLinkChartDiagramLookup.set(i4, null);
    }), Z && i.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");
    const te = this._validateOrganicLayoutSettings(e3, t4?.layoutSettings?.organicLayoutSettings), ae = this._convertValidatedOrganicSettingsToCalculationSettings(te);
    await a2();
    let ie = o3.Error, ne = null;
    if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
      let a4;
      ({ status: ie, links: ne, graphics: a4 } = X(() => t4?.signal?.aborted ?? false, y3, g2, w, D2, v2, x.subarray(0, J2), I2.subarray(0, J2), E2.subarray(0, J2), S3.subarray(0, J2), "chronological-multi-timeline" === e3, t4?.layoutSettings?.chronologicalLayoutSettings)), ie === o3.Success && (this.chronologicalAuxiliaryGraphics = a4);
    } else ({ status: ie, links: ne } = G(() => t4?.signal?.aborted ?? false, y3, g2, w, x.subarray(0, J2), I2.subarray(0, J2), ae.computationBudgetTime, ae.idealEdgeLengthMultiplier, ae.repulsionRadiusMultiplier));
    if (s2(t4?.signal), ie === o3.Error) throw new s("knowledge-graph:layout-failed", "Attempting to arrange the records in the specified layout failed");
    if (ie === o3.Canceled) throw u2();
    for (let i4 = 0; i4 < _4.length; i4++) {
      if (w[i4] > 84.9999 ? w[i4] = 84.9999 : w[i4] < -84.9999 && (w[i4] = -84.9999), g2[i4] > 179.9999 ? g2[i4] = 179.9999 : g2[i4] < -179.9999 && (g2[i4] = -179.9999), _4[i4].feature.attributes[S2] = new _(g2[i4], w[i4]), d.has(_4[i4].typeName)) {
        const e5 = d.get(_4[i4].typeName);
        e5?.set(_4[i4].feature.attributes[_2], _4[i4].feature);
      } else {
        const e5 = /* @__PURE__ */ new Map();
        e5.set(_4[i4].feature.attributes[_2], _4[i4].feature), d.set(_4[i4].typeName, e5);
      }
      c.set(_4[i4].feature.attributes[_2], _4[i4].feature);
      const e4 = ut(_4[i4].feature.attributes[S2]);
      this.entityLinkChartDiagramLookup.set(_4[i4].feature.attributes[_2], _4[i4].feature.attributes[S2] ? e4 : null);
      const t5 = u(this.dataManager.inclusionModeDefinition.namedTypeDefinitions, _4[i4].typeName, () => ({ useAllData: false, members: /* @__PURE__ */ new Map() }));
      u(t5.members, _4[i4].feature.attributes[_2], () => ({ id: _4[i4].feature.attributes[_2], linkChartLocation: void 0 })).linkChartLocation = _4[i4].feature.attributes[S2];
      const { x: a4, y: n } = _4[i4].feature.attributes[S2];
      if (R) j.xmin = Math.min(j.xmin, a4), j.xmax = Math.max(j.xmax, a4), j.ymin = Math.min(j.ymin, n), j.ymax = Math.max(j.ymax, n);
      else {
        const e5 = 1e-7;
        j.xmin = a4 - e5, j.xmax = a4 + e5, j.ymin = n - e5, j.ymax = n + e5, R = true;
      }
    }
    if (this.linkChartExtent.xmin = j.xmin, this.linkChartExtent.xmax = j.xmax, this.linkChartExtent.ymin = j.ymin, this.linkChartExtent.ymax = j.ymax, !ne) throw new s("knowledge-graph:layout-failed", "Attempting to retrieve link geometry from diagram engine failed");
    const oe = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Map(), re = /* @__PURE__ */ new Map(), le = /* @__PURE__ */ new Set();
    for (let i4 = 0; i4 < l2.length; i4++) {
      const a4 = [], s4 = l2[i4], r2 = s4.feature.attributes[I], h3 = s4.feature.attributes[t3];
      let d2 = r2 + "-" + h3;
      if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
        const e4 = t4?.timeInfoByTypeName?.get(s4.typeName), a5 = t4?.timeInfoByTypeName ? e4?.startField : null, i5 = a5 ? s4.feature.attributes[a5] : null, n = e4?.endField;
        d2 += "-" + i5 + "-" + (n ? s4.feature.attributes[n] : null);
      }
      const y4 = ee.get(d2).get(s4.typeName), g3 = 0 === y4 ? 0 : ne?.vertexEndIndex[y4 - 1];
      if (!le.has(y4)) {
        if (le.add(y4), ne.types[y4] === u3.Recursive) {
          const e4 = [ne.vertices[2 * g3], ne.vertices[2 * g3 + 1]], t5 = [ne.vertices[2 * (g3 + 1)], ne.vertices[2 * (g3 + 1) + 1]], i5 = [0.5 * (e4[0] + t5[0]), 0.5 * (e4[1] + t5[1])], n = [i5[0] - e4[0], i5[1] - e4[1]], o4 = [i5[0] + n[1], i5[1] - n[0]], s5 = [i5[0] - n[1], i5[1] + n[0]];
          a4.push(e4), a4.push(o4), a4.push(t5), a4.push(s5), a4.push(e4);
        } else {
          if (ne.types[y4] !== u3.Regular) {
            i.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");
            continue;
          }
          for (let e4 = g3; e4 < ne.vertexEndIndex[y4]; e4++) a4.push([ne.vertices[2 * e4], ne.vertices[2 * e4 + 1]]);
        }
        if ("chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3) {
          const e4 = _4[u4.get(r2)]?.feature.attributes[S2], t5 = _4[u4.get(h3)]?.feature.attributes[S2];
          a4[0][0] === e4.x && a4[0][1] === e4.y || (a4[0] = [e4.x, e4.y]), a4[a4.length - 1][0] === t5.x && a4[a4.length - 1][1] === t5.y || (a4[a4.length - 1] = [t5.x, t5.y]);
        }
        for (let e4 = 1; e4 < a4.length - 1; e4++) a4[e4][1] > 85.5 ? a4[e4][1] = 85.5 : a4[e4][1] < -85.5 && (a4[e4][1] = -85.5), a4[e4][0] > 179.9999 ? a4[e4][0] = 179.9999 : a4[e4][0] < -179.9999 && (a4[e4][0] = -179.9999);
        oe.has(d2) ? oe.get(d2).push(a4) : oe.set(d2, [a4]);
      }
      const m3 = oe.get(d2);
      se.has(d2) || (se.set(d2, /* @__PURE__ */ new Map()), re.set(d2, /* @__PURE__ */ new Map()));
      const f = se.get(d2), w2 = re.get(d2);
      f.has(s4.typeName) || (f.set(s4.typeName, m3.shift()), w2.set(s4.typeName, 0));
      const N = f.get(s4.typeName);
      w2.set(s4.typeName, w2.get(s4.typeName) + 1);
      const D3 = new y({ paths: [N] });
      if (s4.feature.attributes[S2] = D3, p2.has(s4.typeName)) {
        const e4 = p2.get(s4.typeName);
        e4?.set(s4.feature.attributes[_2], s4.feature);
      } else {
        const e4 = /* @__PURE__ */ new Map();
        e4.set(s4.feature.attributes[_2], s4.feature), p2.set(s4.typeName, e4);
      }
      c.set(s4.feature.attributes[_2], s4.feature);
      const v3 = ut(s4.feature.attributes[S2]);
      this.relationshipLinkChartDiagramLookup.set(s4.feature.attributes[_2], s4.feature.attributes[S2] ? v3 : null);
      const x2 = u(this.dataManager.inclusionModeDefinition.namedTypeDefinitions, s4.typeName, () => ({ useAllData: false, members: /* @__PURE__ */ new Map() }));
      u(x2.members, s4.feature.attributes[_2], () => ({ id: s4.feature.attributes[_2], linkChartLocation: void 0 })).linkChartLocation = v3;
    }
    for (const i4 of l2) i4.feature.attributes[o] = re.get(i4.feature.attributes[I] + "-" + i4.feature.attributes[t3])?.get(i4.typeName) ?? null;
    return this._currentLinkChartConfig = { layoutMode: e3, layoutSettings: t4?.layoutSettings?.clone() }, { nodes: d, links: p2, idMap: c };
  }
  async applyNewLinkChartLayout(e3 = "organic-standard", t4) {
    const a3 = [];
    await this._calculateLayoutWithSublayerTimeInfo(e3, t4), this.layers.forEach((e4) => {
      a3.push(e4.refreshCachedQueryEngine());
    }), this.membershipModified = true, await Promise.all(a3), this._refreshNamedTypes();
  }
  getCurrentNodeLocations() {
    const e3 = /* @__PURE__ */ new Map();
    for (const [t4, a3] of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.entries() ?? []) this.dataManager.relationshipTypeNames.has(t4) || a3?.members?.forEach((t5) => {
      const a4 = t5.linkChartLocation;
      let i4;
      const n = t5.id;
      a4 && (i4 = "x" in a4 ? { x: a4.x, y: a4.y } : { x: a4.coords[0], y: a4.coords[1] }, e3.set(n, new _({ x: i4.x, y: i4.y })));
    });
    return e3;
  }
  async refreshLinkChartCache(e3) {
    await this.dataManager.refreshCacheContent(e3);
    const t4 = [];
    this.layers.forEach((e4) => {
      t4.push(e4.refreshCachedQueryEngine());
    }), await Promise.all(t4), this._refreshNamedTypes();
  }
  async connectBetweenEntities(e3, t4) {
    if (!e3.length) return { records: [] };
    let a3 = [];
    try {
      let i4 = [];
      for (const e4 of this.dataManager.relationshipTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (i4 = i4.concat(Array.from(t5.keys())));
      }
      a3 = await this.dataManager.getRelationshipsBetweenNodes(e3, i4, t4), await this._handleNewRecords(a3, t4), s2(t4);
    } catch (i4) {
      throw b(i4) && this.removeRecords(a3), i4;
    }
    return { records: a3 };
  }
  async connectFromEntities(e3, t4) {
    if (!e3.length) return { records: [] };
    let a3 = [];
    try {
      let i4 = [];
      for (const e4 of this.dataManager.relationshipTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (i4 = i4.concat(Array.from(t5.keys())));
      }
      let n = [];
      for (const e4 of this.dataManager.entityTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (n = n.concat(Array.from(t5)));
      }
      a3 = await this.dataManager.getRelationshipsFromNodes(e3, n, i4, t4), await this._handleNewRecords(a3, t4), a3.length > 0 && (this.membershipModified = true), s2(t4);
    } catch (i4) {
      throw b(i4) && this.removeRecords(a3), i4;
    }
    return { records: a3 };
  }
  getCurrentLayout() {
    return this._currentLinkChartConfig.layoutMode;
  }
  async _calculateLayoutWithSublayerTimeInfo(e3 = "organic-standard", t4) {
    const a3 = /* @__PURE__ */ new Map();
    this.layers.forEach((e4) => {
      a3.set(e4.objectType.name, e4.timeInfo);
    }), await this.calculateLinkChartLayout(e3, { timeInfoByTypeName: a3, ...t4 }), this.linkChart?.handleChronologicalOverlay();
  }
  async _handleNewRecords(e3, t4) {
    const a3 = /* @__PURE__ */ new Set(), i4 = [], n = this.layers.concat(this.tables);
    for (const r2 of e3) {
      if (!this._graphTypeLookup.has(r2.typeName)) continue;
      false === n.some((e4) => e4.objectType.name === r2.typeName) && (this.dataManager.sublayerCaches.set(r2.typeName, /* @__PURE__ */ new Map()), a3.add(r2.typeName));
      u(this.sublayerIdsCache, r2.typeName, () => /* @__PURE__ */ new Set()).add(r2.id), i4.push(r2);
    }
    this.dataManager.addToLayer(i4);
    for (const o4 of a3) {
      const e4 = this._graphTypeLookup.get(o4);
      if (e4) {
        const t5 = this._createSublayer(e4);
        "entity" === e4.type ? this.dataManager.entityTypeNames.add(o4) : this.dataManager.relationshipTypeNames.add(o4), t5.geometryType ? this.layers.push(t5) : this.tables.push(t5);
      }
    }
    await i3(this, Array.from(a3), t4), await this.dataManager.refreshCacheContent(e3.map((e4) => e4.id), void 0, void 0, void 0, t4);
    const s3 = { layoutSettings: this._currentLinkChartConfig.layoutSettings, lockedNodeLocations: /* @__PURE__ */ new Map() };
    for (const [o4, r2] of this.entityLinkChartDiagramLookup.entries()) r2 && s3.lockedNodeLocations.set(o4, new _(r2.coords[0], r2.coords[1]));
    await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode, s3);
  }
  _createSublayers(e3, t4, a3) {
    e3.forEach((e4) => {
      const i4 = this._createSublayer(e4);
      a3(i4) && t4.push(i4), this._updateSublayerCaches(e4);
    });
  }
  _updateSublayers(e3, t4) {
    t4.forEach((t5) => {
      t5.parentCompositeLayer = this;
      const a3 = e3.find((e4) => e4.type === t5.graphType && e4.name === t5.graphTypeName);
      a3 && (t5.objectType = a3, t5.read({ title: a3.name }, { origin: "service" }), this._updateSublayerCaches(a3));
    });
  }
  _updateSublayerCaches({ name: e3 }) {
    if (!e3) return;
    const t4 = this.dataManager.sublayerCaches;
    t4.has(e3) || t4.set(e3, /* @__PURE__ */ new Map());
  }
  _layersLoadedFromAuthoritativeItem() {
    const e3 = this.originIdOf("layers");
    return e3 >= e.PORTAL_ITEM && e3 < e.USER;
  }
  async _initializeDiagram() {
    this.initializationLinkChartConfig ? this.initializationLinkChartConfig.doNotRecalculateLayout ? (this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e3, t4) => {
      e3?.members?.forEach((e4) => {
        const a3 = e4.linkChartLocation;
        let i4;
        const n = e4.id;
        if (!a3) return;
        i4 = "x" in a3 ? { x: a3.x, y: a3.y } : { x: a3.coords[0], y: a3.coords[1] };
        const o4 = ut(i4);
        this.dataManager.relationshipTypeNames.has(t4) ? this.relationshipLinkChartDiagramLookup.set(n, o4) : this.entityLinkChartDiagramLookup.set(n, o4), this.linkChartExtent.xmin > i4.x && (this.linkChartExtent.xmin = i4.x), this.linkChartExtent.xmax < i4.x && (this.linkChartExtent.xmax = i4.x), this.linkChartExtent.ymin > i4.y && (this.linkChartExtent.ymin = i4.y), this.linkChartExtent.ymax < i4.y && (this.linkChartExtent.ymax = i4.y);
      });
    }), this.memberRelationshipTypes.forEach((e3) => {
      e3.name && this.dataManager.sublayerCaches.get(e3.name)?.forEach((e4) => {
        const t4 = this.relationshipLinkChartDiagramLookup.get(e4.attributes[I]), a3 = this.relationshipLinkChartDiagramLookup.get(e4.attributes[t3]);
        if (t4 && a3) {
          const i4 = ut(new y({ paths: [[[t4.coords[0], t4.coords[1]], [a3.coords[0], a3.coords[1]]]] }));
          this.relationshipLinkChartDiagramLookup.set(e4.attributes[_2], i4);
        } else this.relationshipLinkChartDiagramLookup.set(e4.attributes[_2], null);
      });
    })) : await this._calculateLayoutWithSublayerTimeInfo(this.initializationLinkChartConfig.layoutMode, { lockedNodeLocations: this.getCurrentNodeLocations(), ...this.initializationLinkChartConfig || {} }) : await this._calculateLayoutWithSublayerTimeInfo("organic-standard", { lockedNodeLocations: this.getCurrentNodeLocations() });
  }
  _refreshNamedTypes() {
    for (const e3 of this.layers) e3.emit("refresh", { dataChanged: true });
    for (const e3 of this.tables) e3.emit("refresh", { dataChanged: true });
  }
  _validateOrganicLayoutSettings(e3, t4) {
    const a3 = (e4) => "number" == typeof e4 && !isNaN(e4), i4 = (e4) => a3(e4) && e4 >= 1, o4 = (e4) => a3(e4) && e4 >= 1, s3 = (e4) => Object.values(e2).includes(e4), r2 = (e4) => a3(e4) && e4 >= 0, l2 = {};
    if (!(/* @__PURE__ */ new Set(["organic-standard", "organic-community", "geographic-organic-standard", "chronological-multi-timeline", "chronological-mono-timeline"])).has(e3) || !t4) return l2;
    const { computationBudgetTime: h3, autoRepulsionRadius: d, repulsionRadiusMultiplier: p2, absoluteIdealEdgeLength: c, multiplicativeIdealEdgeLength: u4, idealEdgeLengthType: y3 } = t4;
    return o4(h3) ? l2.computationBudgetTime = h3 : h3 && i.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"), l2.autoRepulsionRadius = d, !d && i4(p2) ? l2.repulsionRadiusMultiplier = p2 : d || (l2.autoRepulsionRadius = true, i.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting")), "geographic-organic-standard" === e3 && (s3(y3) ? l2.idealEdgeLengthType = y3 : void 0 !== y3 && i.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'), "absolute-value" === y3 && r2(c) ? l2.absoluteIdealEdgeLength = c : "absolute-value" === y3 && void 0 !== c ? i.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting") : "multiplier" === y3 && r2(u4) ? l2.multiplicativeIdealEdgeLength = u4 : "multiplier" === y3 && void 0 !== u4 && i.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")), l2;
  }
  _convertValidatedOrganicSettingsToCalculationSettings(e3) {
    let t4 = e3.idealEdgeLengthType === e2.ABSOLUTE ? e3.absoluteIdealEdgeLength : e3.multiplicativeIdealEdgeLength;
    return e3.idealEdgeLengthType === e2.ABSOLUTE && (void 0 === t4 ? t4 = -1 : t4 *= -1), { computationBudgetTime: e3.computationBudgetTime ?? void 0, repulsionRadiusMultiplier: e3.repulsionRadiusMultiplier && !e3.autoRepulsionRadius ? e3.repulsionRadiusMultiplier : void 0, idealEdgeLengthMultiplier: t4 };
  }
  _createSublayer(e3) {
    return new Ie({ objectType: e3, parentCompositeLayer: this, graphType: e3.type });
  }
  _handleSublayersChange(e3, t4) {
    t4 && (t4.forEach((e4) => {
      e4.parent = null;
    }), this.removeHandles("sublayers-owner")), e3 && (e3.forEach((e4) => {
      e4.parent = this;
    }), this.addHandles([e3.on("after-add", ({ item: e4 }) => {
      e4.parent = this;
    }), e3.on("after-remove", ({ item: e4 }) => {
      e4.parent = null;
    })], "sublayers-owner"));
  }
  _alignLayersDataModelAndInclusionDefinition(e3) {
    const t4 = new Set((e3.entityTypes ?? []).map((e4) => e4.name).concat((e3.relationshipTypes ?? []).map((e4) => e4.name))), i4 = new Set((e3.entityTypes ?? []).map((e4) => e4.name)), o4 = new Set((e3.relationshipTypes ?? []).map((e4) => e4.name));
    if (this.layers) {
      for (const a3 of this.layers) !a3.graphType && t4.has(a3.graphTypeName) && (a3.graphType = i4.has(a3.graphTypeName) ? "entity" : "relationship");
      const e4 = this.layers.filter((e5) => t4.has(e5.graphTypeName) && ("entity" === e5.graphType ? i4.has(e5.graphTypeName) : o4.has(e5.graphTypeName)));
      this.setAtOrigin("layers", e4, t(this.originIdOf("layers")));
    } else this.layers = new V();
    if (this.layers && this._originalInclusionList) {
      const e4 = new Set(this._originalInclusionList.namedTypeDefinitions.keys()), t5 = this.tables?.map((e5) => e5.graphTypeName) ?? [], a3 = this.layers.map((e5) => e5.graphTypeName).concat(t5);
      for (const n of a3) e4.has(n) || this._originalInclusionList.namedTypeDefinitions.set(n, { useAllData: false, members: /* @__PURE__ */ new Map() });
      const i5 = [];
      for (const o5 of this._originalInclusionList.namedTypeDefinitions.keys()) a3.includes(o5) || (i.getLogger(this).warn(`A named type, ${o5}, was in the serialized feature collection but did not have a sublayer config in the item, so will be removed`), i5.push(o5));
      for (const n of i5) this._originalInclusionList.namedTypeDefinitions.delete(n);
    }
  }
};
r([m(y2)], q.prototype, "url", void 0), r([m()], q.prototype, "dataPreloadedInLocalCache", void 0), r([m()], q.prototype, "initializationLinkChartConfig", void 0), r([m()], q.prototype, "membershipModified", void 0), r([m()], q.prototype, "dataManager", void 0), r([m()], q.prototype, "initializationInclusionModeDefinition", null), r([m()], q.prototype, "knowledgeGraph", void 0), r([m({ type: V.ofType(Ie), json: { write: { ignoreOrigin: true } } })], q.prototype, "layers", void 0), r([m({ readOnly: true })], q.prototype, "linkChart", null), r([m()], q.prototype, "entityLinkChartDiagramLookup", void 0), r([m()], q.prototype, "relationshipLinkChartDiagramLookup", void 0), r([m()], q.prototype, "linkChartExtent", void 0), r([m()], q.prototype, "memberEntityTypes", void 0), r([m()], q.prototype, "memberRelationshipTypes", void 0), r([m({ type: ["LinkChartLayer"] })], q.prototype, "operationalLayerType", void 0), r([m()], q.prototype, "sublayerIdsCache", void 0), r([m({ type: V.ofType(Ie), json: { write: { ignoreOrigin: true } } })], q.prototype, "tables", void 0), r([m({ json: { read: false } })], q.prototype, "type", void 0), r([m({ json: { read: false } })], q.prototype, "chronologicalAuxiliaryGraphics", void 0), q = r([a("esri.layers.LinkChartLayer")], q);
var J = q;
export {
  J as default
};
//# sourceMappingURL=LinkChartLayer-KDZH2HJL.js.map
