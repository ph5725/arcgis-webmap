import {
  m,
  n,
  t
} from "./chunk-5726E5A7.js";
import {
  T as T2
} from "./chunk-MEHT6AJM.js";
import "./chunk-N6VYJNA5.js";
import {
  se,
  v
} from "./chunk-Z5EDZREM.js";
import {
  _ as _2,
  h,
  j,
  p
} from "./chunk-U5MPARPW.js";
import {
  D,
  I,
  R,
  T,
  c,
  f2 as f,
  j as j2,
  s2 as s,
  u2 as u
} from "./chunk-NXHGFG67.js";
import {
  c as c2
} from "./chunk-JEBSIDYN.js";
import "./chunk-56LGCTGZ.js";
import "./chunk-PVI3IOCA.js";
import "./chunk-76QJRCNC.js";
import "./chunk-D443BZKU.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-KE3WBZYL.js";
import {
  r as r2
} from "./chunk-EOMIFMDH.js";
import "./chunk-7BWCD63N.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-FPSA4NFH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import "./chunk-GZ2P4SCJ.js";
import "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e;
var a2 = e = class extends t {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e();
  }
};
r([r2({ IdentityXform: "identity" })], a2.prototype, "type", void 0), a2 = e = r([a("esri.layers.support.rasterTransforms.IdentityTransform")], a2);

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var n2 = { GCSShiftXform: n, IdentityXform: a2, PolynomialXform: m };
function f2(r3) {
  const o = r3?.type;
  if (!o) return null;
  const t2 = n2[r3?.type];
  if (t2) {
    const o2 = new t2();
    return o2.read(r3), o2;
  }
  return null;
}

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var N = class {
  convertVectorFieldData(r3) {
    const e2 = c.fromJSON(r3.pixelBlock), t2 = f(e2, r3.type);
    return Promise.resolve(null != t2 ? t2.toJSON() : null);
  }
  computeStatisticsHistograms(r3) {
    const e2 = c.fromJSON(r3.pixelBlock), t2 = h(e2);
    return Promise.resolve(t2);
  }
  async decode(r3) {
    const e2 = await j(r3.data, r3.options);
    return e2 && e2.toJSON();
  }
  symbolize(e2) {
    e2.pixelBlock = c.fromJSON(e2.pixelBlock), e2.extent = e2.extent ? z.fromJSON(e2.extent) : null;
    const t2 = this.symbolizer.symbolize(e2);
    return Promise.resolve(null != t2 ? t2.toJSON() : null);
  }
  async updateSymbolizer(r3) {
    this.symbolizer = _2.fromJSON(r3.symbolizerJSON), r3.histograms && "rasterStretch" === this.symbolizer?.rendererJSON.type && (this.symbolizer.rendererJSON.histograms = r3.histograms);
  }
  async updateRasterFunction(r3) {
    this.rasterFunction = T2(r3.rasterFunctionJSON);
  }
  async process(t2) {
    const o = this.rasterFunction.process({ extent: z.fromJSON(t2.extent), primaryPixelBlocks: t2.primaryPixelBlocks.map((r3) => null != r3 ? c.fromJSON(r3) : null), primaryPixelSizes: t2.primaryPixelSizes?.map((r3) => null != r3 ? _.fromJSON(r3) : null), primaryRasterIds: t2.primaryRasterIds });
    return null != o ? o.toJSON() : null;
  }
  stretch(r3) {
    const e2 = this.symbolizer.simpleStretch(c.fromJSON(r3.srcPixelBlock), r3.stretchParams);
    return Promise.resolve(e2?.toJSON());
  }
  estimateStatisticsHistograms(r3) {
    const e2 = p(c.fromJSON(r3.srcPixelBlock));
    return Promise.resolve(e2);
  }
  split(r3) {
    const e2 = I(c.fromJSON(r3.srcPixelBlock), r3.tileSize, r3.maximumPyramidLevel ?? 0, false === r3.useBilinear);
    return e2 && e2.forEach((r4, t2) => {
      e2.set(t2, r4?.toJSON());
    }), Promise.resolve(e2);
  }
  clipTile(r3) {
    const e2 = c.fromJSON(r3.pixelBlock), t2 = R({ ...r3, pixelBlock: e2 });
    return Promise.resolve(t2?.toJSON());
  }
  async mosaicAndTransform(r3) {
    const e2 = r3.srcPixelBlocks.map((r4) => r4 ? new c(r4) : null), t2 = T(e2, r3.srcMosaicSize, { blockWidths: r3.blockWidths, alignmentInfo: r3.alignmentInfo, clipOffset: r3.clipOffset, clipSize: r3.clipSize });
    let o, i = t2;
    return r3.coefs && (i = D(t2, r3.destDimension, r3.coefs, r3.sampleSpacing, r3.interpolation)), r3.projectDirections && r3.gcsGrid && (o = j2(r3.destDimension, r3.gcsGrid), i = u(i, r3.isUV ? "vector-uv" : "vector-magdir", o)), { pixelBlock: i?.toJSON(), localNorthDirections: o };
  }
  async createFlowMesh(r3, e2) {
    const t2 = { data: new Float32Array(r3.flowData.buffer), mask: new Uint8Array(r3.flowData.maskBuffer), width: r3.flowData.width, height: r3.flowData.height }, { vertexData: s2, indexData: o } = await s(r3.meshType, r3.simulationSettings, t2, e2.signal);
    return { result: { vertexBuffer: s2.buffer, indexBuffer: o.buffer }, transferList: [s2.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(e2) {
    const s2 = z.fromJSON(e2.projectedExtent), o = z.fromJSON(e2.srcBufferExtent);
    let i = null;
    e2.datumTransformationSteps?.length && (i = new c2({ steps: e2.datumTransformationSteps })), await v();
    const n3 = e2.rasterTransform ? f2(e2.rasterTransform) : null;
    return se({ ...e2, projectedExtent: s2, srcBufferExtent: o, datumTransformation: i, rasterTransform: n3 });
  }
};
export {
  N as default
};
//# sourceMappingURL=RasterWorker-LXO3DRM2.js.map
