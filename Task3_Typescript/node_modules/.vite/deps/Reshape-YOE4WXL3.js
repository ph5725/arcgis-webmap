import {
  h as h4
} from "./chunk-T2XVDW2J.js";
import {
  E as E2,
  a as a3
} from "./chunk-SV35MYMN.js";
import {
  a as a2,
  t as t3
} from "./chunk-VVMAWXMO.js";
import {
  e as e5,
  i as i3,
  p
} from "./chunk-MEKLRE3T.js";
import {
  i as i4
} from "./chunk-GEXDBKAY.js";
import {
  d as d3
} from "./chunk-ACGNX7DG.js";
import {
  i as i2
} from "./chunk-ICVOVIUL.js";
import {
  E2 as E,
  P as P2,
  e3 as e4
} from "./chunk-3AJC75KZ.js";
import {
  C2 as C,
  F,
  H2 as H,
  R,
  r as r2
} from "./chunk-RFM3ACHA.js";
import "./chunk-SP5E3FR4.js";
import {
  R as R2
} from "./chunk-6VC2SGU3.js";
import {
  c as c5
} from "./chunk-R4OUYMNP.js";
import "./chunk-YIOJR4CO.js";
import "./chunk-U6CQ42B3.js";
import "./chunk-HPOHIVBI.js";
import "./chunk-5TKMN7TZ.js";
import "./chunk-P5XPQUDN.js";
import "./chunk-WYLBCBQH.js";
import "./chunk-ENM5QFON.js";
import "./chunk-QRQFF5JU.js";
import "./chunk-2H2JCT45.js";
import "./chunk-NMV57LDC.js";
import {
  h as h3
} from "./chunk-NZUIJLHR.js";
import {
  c as c3
} from "./chunk-2XBUTZI3.js";
import "./chunk-IAKXH7PU.js";
import "./chunk-3MVOHROR.js";
import "./chunk-RVXIJHL6.js";
import "./chunk-2JAL6FAS.js";
import "./chunk-TUSII7EA.js";
import "./chunk-RTDWTAVK.js";
import "./chunk-QLJ6JQFC.js";
import "./chunk-YWGFBTRS.js";
import "./chunk-BHCIAS6L.js";
import "./chunk-TNKA4BMD.js";
import "./chunk-VKKELZ6R.js";
import "./chunk-3SJIVSAT.js";
import "./chunk-HXR4TQII.js";
import "./chunk-FQ4JUVCN.js";
import "./chunk-3LL6ALVC.js";
import "./chunk-NZPABYQQ.js";
import "./chunk-CCHJ3WNU.js";
import {
  x
} from "./chunk-23GI2JAZ.js";
import "./chunk-KW7LX4F6.js";
import "./chunk-7KOC3Z4A.js";
import "./chunk-QXLW5W5A.js";
import "./chunk-OFHPFWHF.js";
import "./chunk-MZJEBIXX.js";
import "./chunk-76QJRCNC.js";
import "./chunk-KQZAPZ6K.js";
import "./chunk-UVUJMAAB.js";
import "./chunk-TB5DDCF3.js";
import "./chunk-HFUGSKPL.js";
import {
  c as c4
} from "./chunk-BUA5NESM.js";
import {
  _ as _2
} from "./chunk-SHYE33QH.js";
import "./chunk-LTMF2W73.js";
import "./chunk-5Y3EUPZN.js";
import "./chunk-XBU3UEEJ.js";
import {
  h as h2
} from "./chunk-YIXK32VF.js";
import "./chunk-XFKS4JQP.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-TMFB3DKM.js";
import "./chunk-LBC3MAJX.js";
import {
  l as l3
} from "./chunk-H7XUEHGR.js";
import "./chunk-NMP7ZOVG.js";
import "./chunk-YHYQP7QX.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-XAXNVZUO.js";
import "./chunk-DIR2YFTR.js";
import "./chunk-ZSRASSN6.js";
import "./chunk-N5GLJRXG.js";
import "./chunk-77M4J56U.js";
import "./chunk-XLF2NMGX.js";
import "./chunk-X5GD6LFD.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-KSRBNZJ2.js";
import "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-ZAISHGSP.js";
import {
  d as d2
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import {
  u as u3
} from "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import {
  c as c2
} from "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  d
} from "./chunk-HPGYEHVI.js";
import {
  g,
  l as l2
} from "./chunk-YBJ5GVXQ.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import {
  c,
  e as e3,
  m as m2
} from "./chunk-VNTEV3V4.js";
import {
  y
} from "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import {
  o
} from "./chunk-YIV2QKTZ.js";
import {
  P,
  U,
  f,
  h,
  j,
  l,
  w
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  b,
  m,
  t4 as t2
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import {
  u
} from "./chunk-S7IJH524.js";
import {
  e,
  e2,
  n,
  s as s2,
  t,
  u2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/draw/support/ConnectedReshapeManager.js
var _3;
!function(e6) {
  e6[e6.FeatureMove = 0] = "FeatureMove", e6[e6.VertexMove = 1] = "VertexMove";
}(_3 || (_3 = {}));
var w2 = () => i.getLogger("esri.views.draw.support.ConnectedReshapeManager");
var G = Symbol();
var L = class extends b {
  constructor(e6) {
    super(e6), this.activeOperationType = null, this.providerFactories = [], this.view = null, this._activeProviders = /* @__PURE__ */ new Set(), this._graphics = /* @__PURE__ */ new Map(), this._modifiedFeatures = /* @__PURE__ */ new Map(), this._modifiedGraphicsLayer = new c3({ listMode: "hide", internal: true, title: "Connected Reshape Modified Graphics (Internal)" }), this._pendingGraphicsLayer = new c3({ listMode: "hide", internal: true, title: "Connected Reshape Pending Graphics (Internal)" }), this._pendingFeatures = /* @__PURE__ */ new Map(), this._updatingHandles = new h2();
  }
  initialize() {
    this.view.map.addMany([this._modifiedGraphicsLayer, this._pendingGraphicsLayer]);
  }
  destroy() {
    this.view.destroyed || this.view.map.removeMany([this._modifiedGraphicsLayer, this._pendingGraphicsLayer]), this._modifiedGraphicsLayer.destroy(), this._pendingGraphicsLayer.destroy(), this._updatingHandles.destroy();
  }
  get updating() {
    return this._updatingHandles.updating || Array.from(this._activeProviders).some((e6) => e6.updating);
  }
  startFeatureMove(e6) {
    this.activeOperationType = _3.FeatureMove, this._activeProviders.clear();
    for (const i6 of this.providerFactories) t2(this._activeProviders, i6.getFeatureReshapeProvider(e6));
  }
  startVertexMove(e6, i6) {
    this.activeOperationType = _3.VertexMove, this._activeProviders.clear();
    for (const t4 of this.providerFactories) t2(this._activeProviders, t4.getVertexReshapeProvider(e6, i6));
  }
  finish() {
    this.activeOperationType = null, this._activeProviders.clear();
    for (const [e6, i6] of this._pendingFeatures) {
      this._pendingFeatures.delete(e6), this._modifiedFeatures.set(e6, i6);
      const t4 = this._graphics.get(e6);
      t4 && (this._modifiedGraphicsLayer.add(t4), this._pendingGraphicsLayer.remove(t4));
    }
  }
  translate(e6, i6, t4 = 0) {
    if (null === this.activeOperationType) return;
    const r3 = P3(e6), s3 = P3(i6), a4 = P3(t4);
    for (const o2 of this._activeProviders) {
      const e7 = o2.translate(r3, s3, a4);
      this._update(e7);
    }
  }
  async _initializeGraphic(e6, i6) {
    e6.symbol ??= await this._updatingHandles.addPromise(x(e6, { scale: this.view.scale, useSourceLayer: true })), this._pendingFeatures.has(i6.uniqueId) ? this._pendingGraphicsLayer.add(e6) : this._modifiedFeatures.has(i6.uniqueId) && this._modifiedGraphicsLayer.add(e6), this.addHandles(await F2(i6.originalGraphic, e6, this.view), G);
  }
  _update(e6) {
    for (const i6 of e6) {
      const e7 = this._modifiedFeatures.delete(i6.uniqueId);
      this._pendingFeatures.set(i6.uniqueId, i6);
      const t4 = u(this._graphics, i6.uniqueId, () => {
        const e8 = i6.graphic.cloneShallow();
        return this._initializeGraphic(e8, i6), e8;
      });
      t4.geometry = i6.graphic.geometry, e7 && (this._modifiedGraphicsLayer.remove(t4), this._pendingGraphicsLayer.add(t4));
    }
  }
  get test() {
    return { activeProviders: this._activeProviders, modifiedFeatures: this._modifiedFeatures, modifiedGraphicsLayer: this._modifiedGraphicsLayer, pendingFeatures: this._pendingFeatures, pendingGraphicsLayer: this._pendingGraphicsLayer };
  }
};
async function F2(e6, i6, a4) {
  const o2 = e6.sourceLayer, d5 = e6.getObjectId();
  if (null == d5) return w2().error("editing:cannot-hide-graphic", "Unable to hide original graphic because it has no objectId."), e();
  let c6 = null;
  function h6(e7) {
    c6?.abort(), c6 = d(async (i7) => {
      const t4 = await b2(a4, o2);
      s2(i7), t4 && t4.setVisibility?.(d5, e7);
    });
  }
  return await M(a4, i6), h6(false), t([j2(a4, i6, (e7) => h6(!e7)), e(async () => {
    h6(true);
    const e7 = await b2(a4, o2);
    await j(() => !e7?.updating);
  })]);
}
function j2(e6, i6, t4) {
  if ("3d" === e6.type) {
    const r3 = new e5({ graphic: i6 });
    return t([e6.trackGraphicState(r3), l(() => r3.displaying, t4)]);
  }
  return l(() => i6.visible, t4);
}
async function M(e6, i6) {
  if ("3d" === e6.type) {
    const t4 = new e5({ graphic: i6 }), r3 = e6.trackGraphicState(t4);
    await j(() => t4.displaying || t4.error), r3.remove();
  } else await j(() => i6.visible);
}
async function b2(e6, i6) {
  const t4 = g(i6) || l2(i6) ? i6.parent : i6;
  return t4 ? e6.whenLayerView(t4) : null;
}
function P3(e6) {
  return isNaN(e6) ? 0 : e6;
}
r([m()], L.prototype, "activeOperationType", void 0), r([m()], L.prototype, "providerFactories", void 0), r([m()], L.prototype, "updating", null), r([m({ constructOnly: true })], L.prototype, "view", void 0), L = r([a("esri.views.draw.support.ConnectedReshapeManager")], L);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/TranslateVertexTooltipInfo.js
var i5 = class extends r2 {
  constructor(t4) {
    super(t4), this.type = "translate-vertex", this.distance = h3, this.elevation = null, this.area = null, this.totalLength = null;
  }
  clear() {
    this.distance = h3, this.elevation = null, this.area = null, this.totalLength = null;
  }
};
r([m()], i5.prototype, "type", void 0), r([m()], i5.prototype, "distance", void 0), r([m()], i5.prototype, "elevation", void 0), r([m()], i5.prototype, "area", void 0), r([m()], i5.prototype, "totalLength", void 0), i5 = r([a("esri.views.interactive.tooltip.infos.TranslateVertexTooltipInfo")], i5);

// node_modules/@arcgis/core/views/draw/support/reshapeTooltipUtils.js
function y2(t4) {
  const e6 = { sketchOptions: t4, viewType: "2d" };
  return { movePoint: new i3(e6), selectedVertex: new p(e6), translateGraphic: new i4(e6), translateVertices: new i5(e6) };
}
function v(e6, r3) {
  function a4() {
    const t4 = r3(), e7 = t4.sketchOptions.tooltips.effectiveEnabled ? t4.activeTooltipInfo : null;
    return { ...t4, activeTooltipInfo: e7 };
  }
  let s3 = false;
  function l4(t4) {
    s3 || (s3 = true, t4(), s3 = false);
  }
  return t([l(() => {
    const t4 = a4();
    return { context: t4, geometry: t4.graphic?.geometry, vertexGeometry: t4.selectedVertex?.geometry };
  }, ({ context: t4 }) => {
    l4(() => {
      g2(t4), e6.info = t4.activeTooltipInfo;
    });
  }, w), l(() => {
    const t4 = a4(), { activeTooltipInfo: e7 } = t4;
    if (e7 && "key" in e7) return { context: t4, key: e7.key };
  }, (t4, e7) => {
    t4 && e7 && t4.key !== e7.key && l4(() => T(t4.context));
  }, U), C(e6, { onBeforePaste: () => {
    s3 = true;
  }, onAfterPaste: () => {
    T(a4()), s3 = false;
  } })]);
}
function g2(t4) {
  const e6 = t4.activeTooltipInfo;
  if (e6) {
    switch (e6?.type) {
      case "move-point":
        return h5(e6, t4);
      case "selected-vertex":
        return d4(e6, t4);
    }
    e6.sketchOptions = t4.sketchOptions;
  }
}
function h5(t4, { graphic: e6 }) {
  x2(t4, e6, e6?.geometry);
}
function d4(t4, { graphic: e6, selectedVertex: o2, automaticAreaMeasurementUtils: n2, automaticLengthMeasurementUtils: i6 }) {
  x2(t4, e6, o2?.geometry);
  const r3 = e6?.geometry;
  switch (r3?.type) {
    case "polygon":
      t4.geometryType = "polygon", t4.totalLength.visible = false, t4.area.actual = n2.autoArea2D(r3);
      break;
    case "polyline":
      t4.geometryType = "polyline", t4.totalLength.actual = i6.autoLength2D(r3), t4.area.visible = false;
  }
}
function x2(t4, e6, o2) {
  e6 && "point" === o2?.type && (t4.setLocationFromPoint(o2), t4.elevation.actual = R2(o2), t4.elevation.visible = !!e6.geometry?.hasZ, t4.elevation.readOnly = false, t4.elevation.showAsZ = true);
}
function T(t4) {
  function e6(e7, o3) {
    const n3 = o3?.geometry;
    if (!n3 || "point" !== n3.type) return;
    const { dx: i7, dy: r3, dz: c6 } = F(e7, n3);
    if (0 === i7 && 0 === r3 && 0 === c6) return;
    const { x: l4, y: p2, z: m3, m: u4, spatialReference: f2 } = n3, y3 = new _({ x: l4 + i7, y: p2 + r3, z: null != m3 ? m3 + c6 : void 0, m: u4, spatialReference: f2 });
    t4.updateGeometry(o3, y3, n3, i7, r3);
  }
  const { activeTooltipInfo: o2, graphic: n2, selectedVertex: i6 } = t4;
  switch (o2?.type) {
    case "move-point":
      return e6(o2, n2);
    case "selected-vertex":
      return e6(o2, i6);
  }
}
function j3(t4, e6, o2, n2) {
  t4.clear(), U2(t4, e6, n2, o2);
}
function w3(t4, e6, o2, n2, i6) {
  t4.clear();
  const { automaticAreaMeasurementUtils: r3, automaticLengthMeasurementUtils: a4 } = n2;
  "polygon" === o2?.type ? t4.area = r3.autoArea2D(o2) : "polyline" === o2?.type && (t4.totalLength = a4.autoLength2D(o2)), U2(t4, e6, i6, n2);
}
function U2(t4, o2, n2, { automaticLengthMeasurementUtils: i6 }) {
  if (!n2) return;
  const { x: a4, y: c6 } = n2.origin, s3 = o2.toMap(n2), l4 = o2.toMap(c2(a4, c6)), p2 = i6.autoDistanceBetweenPoints2D(l4, s3);
  t4.distance = null != p2 ? p2 : h3;
}

// node_modules/@arcgis/core/views/draw/support/Reshape.js
var X = class {
  constructor(e6, t4, i6) {
    this.graphic = e6, this.mover = t4, this.selected = i6, this.type = "reshape-start";
  }
};
var Y = class {
  constructor(e6, t4, i6) {
    this.graphic = e6, this.mover = t4, this.selected = i6, this.type = "reshape";
  }
};
var K = class {
  constructor(e6, t4, i6) {
    this.graphic = e6, this.mover = t4, this.selected = i6, this.type = "reshape-stop";
  }
};
var q = class {
  constructor(e6, t4, i6) {
    this.mover = e6, this.dx = t4, this.dy = i6, this.type = "move-start";
  }
};
var B = class {
  constructor(e6, t4, i6) {
    this.mover = e6, this.dx = t4, this.dy = i6, this.type = "move";
  }
};
var J = class {
  constructor(e6, t4, i6) {
    this.mover = e6, this.dx = t4, this.dy = i6, this.type = "move-stop";
  }
};
var Q = class {
  constructor(e6) {
    this.added = e6, this.type = "vertex-select";
  }
};
var W = class {
  constructor(e6) {
    this.removed = e6, this.type = "vertex-deselect";
  }
};
var $ = class {
  constructor(e6, t4, i6, s3) {
    this.added = e6, this.graphic = t4, this.oldGraphic = i6, this.vertices = s3, this.type = "vertex-add";
  }
};
var ee = class {
  constructor(e6, t4, i6, s3) {
    this.removed = e6, this.graphic = t4, this.oldGraphic = i6, this.vertices = s3, this.type = "vertex-remove";
  }
};
var te = h4.reshapeGraphics;
var ie = { vertices: { default: new u3({ style: "circle", size: te.vertex.size, color: te.vertex.color, outline: { color: te.vertex.outlineColor, width: 1 } }), hover: new u3({ style: "circle", size: te.vertex.hoverSize, color: te.vertex.hoverColor, outline: { color: te.vertex.hoverOutlineColor, width: 1 } }), selected: new u3({ style: "circle", size: te.selected.size, color: te.selected.color, outline: { color: te.selected.outlineColor, width: 1 } }) }, midpoints: { default: new u3({ style: "circle", size: te.midpoint.size, color: te.midpoint.color, outline: { color: te.midpoint.outlineColor, width: 1 } }), hover: new u3({ style: "circle", size: te.midpoint.size, color: te.midpoint.color, outline: { color: te.midpoint.outlineColor, width: 1 } }) } };
var se = class extends o.EventedAccessor {
  constructor(e6) {
    super(e6), this._updateHandlesOnExternalGeometryChange = null, this._activeOperationInfo = null, this._connectedReshapeManager = null, this._editGeometryOperations = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._snappingContext = null, this._snappingGraphicsLayer = null, this._hoverGraphic = null, this._snappingTask = null, this._stagedVertex = null, this.tooltip = null, this.activeTooltipInfo = null, this.callbacks = { onReshapeStart() {
    }, onReshape() {
    }, onReshapeStop() {
    }, onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onGraphicClick() {
    } }, this.connectedReshapeProviders = [], this.enableMidpoints = true, this.enableMovement = true, this.enableVertices = true, this.graphic = null, this.highlightName = null, this.highlightsEnabled = true, this.layer = null, this.midpointGraphics = new V(), this.midpointSymbol = new u3({ style: "circle", size: 6, color: [200, 200, 200], outline: { color: [100, 100, 100], width: 1 } }), this.selectedVertices = new V(), this.snappingManager = null, this.symbols = ie, this.sketchOptions = new c5(), this.type = "reshape", this.vertexGraphics = new V(), this.view = null;
  }
  initialize() {
    const e6 = this.view;
    this._highlightHelper = new a3({ view: e6 }), this._setup(), this._updateHandlesOnExternalGeometryChange = P(() => this.graphic?.geometry, (e7) => {
      if (!e7) return;
      const t4 = new Set(this.selectedVertices.map((e8) => e8.attributes?.pointIndex));
      this._highlightHelper.removeAll(), this._setUpHighlights(), this._setupGraphics(), this._clearSelection(), this.vertexGraphics.filter((e8) => t4.has(e8.attributes.pointIndex)).forEach((e8) => this._addToSelection(e8));
      const { enableMovement: i6, _mover: s3, graphic: o2, midpointGraphics: r3, vertexGraphics: n2 } = this, h6 = n2.concat(r3).items;
      i6 && h6.push(o2), s3?.set("graphics", h6);
    }, U), this.tooltip = R(() => ({ view: e6, options: this.sketchOptions.tooltips })), this.tooltipInfos = y2(this.sketchOptions), this.addHandles([f(() => e6?.ready, () => {
      const { layer: e7, view: t4 } = this;
      t3(t4, e7), this.addHandles(t4.on("key-down", (e8) => this._keyDownHandler(e8), _2.TOOL));
    }, { once: true, initial: true }), l(() => this.graphic, () => this.refresh()), l(() => this.layer, (e7, t4) => {
      t4 && (this._clearSelection(), this._resetGraphics(t4)), this.refresh();
    }), l(() => [this.highlightsEnabled, this.highlightName], () => {
      this._highlightHelper?.removeAll(), this._setUpHighlights();
    }), l(() => this.enableMidpoints, () => this.refresh()), v(this.tooltip, () => this._tooltipsContext), l(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), h), this._updateHandlesOnExternalGeometryChange]), this._updateTooltip();
  }
  destroy() {
    this._reset(), this._mover?.destroy(), this._mover = null, this._connectedReshapeManager = u2(this._connectedReshapeManager), this.tooltip = u2(this.tooltip);
  }
  get _coordinateHelper() {
    return this._editGeometryOperations?.data.coordinateHelper ?? P2(!!this.graphic.geometry?.hasZ, !!this.graphic.geometry?.hasM, this.view.spatialReference);
  }
  get _selectedVertex() {
    return 1 === this.selectedVertices.length ? this.selectedVertices.at(0) : void 0;
  }
  get _tooltipsContext() {
    const { automaticAreaMeasurementUtils: e6, automaticLengthMeasurementUtils: t4, sketchOptions: i6, activeTooltipInfo: s3, graphic: o2 } = this;
    return { sketchOptions: i6, activeTooltipInfo: s3, graphic: o2, selectedVertex: this._selectedVertex, automaticAreaMeasurementUtils: e6, automaticLengthMeasurementUtils: t4, updateGeometry: (e7, t5, i7, s4, o3) => {
      this._setUpGeometryHelper();
      const r3 = e7 === this.graphic;
      r3 ? this._emitMoveStartEvent(0, 0) : this._emitReshapeStartEvent(e7);
      const n2 = true;
      if (this._syncGeometryAfterVertexMove(e7, t5, s4, o3, n2), r3) {
        const { view: e8 } = this, s5 = e8.toScreen(i7), o4 = e8.toScreen(t5), r4 = (o4?.x ?? 0) - (s5?.x ?? 0), n3 = (o4?.y ?? 0) - (s5?.y ?? 0);
        this._emitMoveEvent(r4, n3), this._emitMoveStopEvent(r4, n3);
      } else this._emitReshapeEvent(e7), this._emitReshapeStopEvent(e7);
      this._editGeometryOperations = u2(this._editGeometryOperations);
    } };
  }
  get state() {
    const e6 = this.view.ready, t4 = !(!this.graphic || !this.layer);
    return e6 && t4 ? "active" : e6 ? "ready" : "disabled";
  }
  isUIGraphic(e6) {
    const t4 = [];
    return this.graphic && t4.push(this.graphic), t4.concat(this.vertexGraphics.items, this.midpointGraphics.items), t4.length > 0 && t4.includes(e6);
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphic = null;
  }
  clearSelection() {
    this._clearSelection();
  }
  removeSelectedVertices() {
    const { selectedVertices: e6 } = this;
    e6.length && this._removeVertices(e6);
  }
  _setup() {
    const { graphic: e6, layer: t4 } = this;
    if (!t4 || null == e6?.geometry) return;
    const i6 = e6.geometry;
    "mesh" !== i6.type && "extent" !== i6.type ? ("polygon" === i6.type && m2(i6), this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._setupConnectedReshapeManager()) : this._logGeometryTypeError();
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphic && this._highlightHelper?.add(this.graphic, this.highlightName);
  }
  _setUpGeometryHelper() {
    const e6 = this.graphic.geometry;
    if (null == e6 || "mesh" === e6.type || "extent" === e6.type) return void this._logGeometryTypeError();
    const t4 = "multipoint" === e6.type ? new y({ paths: [e6.points], spatialReference: e6.spatialReference }) : e6;
    this._editGeometryOperations = E.fromGeometry(t4, l3.Local);
  }
  _saveSnappingContextForHandle(e6, t4) {
    this._snappingGraphicsLayer = new c3({ listMode: "hide", internal: true, title: "Reshape snapping layer" }), this.view.map.layers.add(this._snappingGraphicsLayer);
    const i6 = this._editGeometryOperations;
    n(i6), this._snappingContext = new e4({ editGeometryOperations: i6, elevationInfo: { mode: "on-the-ground", offset: 0 }, pointer: t4.viewEvent?.pointerType || "mouse", excludeFeature: this.graphic, feature: this.graphic, visualizer: new d3(this._snappingGraphicsLayer), vertexHandle: this._getVertexFromEditGeometry(e6) });
  }
  _reset() {
    this._clearSelection(), this._highlightHelper?.removeAll(), this._updateTooltip(), this._resetGraphics(), this._resetSnappingStateVars(), this._activeOperationInfo = null, this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetSnappingStateVars() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), null != this._snappingGraphicsLayer && (this.view?.map && this.view.map.layers.remove(this._snappingGraphicsLayer), this._snappingGraphicsLayer.destroy()), this._editGeometryOperations = u2(this._editGeometryOperations), this._snappingTask = e2(this._snappingTask), this._snappingTask = null, this._snappingContext = null, this._stagedVertex = null;
  }
  _resetGraphics(e6) {
    this._removeMidpointGraphics(e6), this._removeVertexGraphics(e6), this.selectedVertices.removeAll(), this._updateTooltip();
  }
  _removeMidpointGraphics(e6) {
    const t4 = e6 || this.layer;
    t4 && t4.removeMany(this.midpointGraphics.items), this.midpointGraphics.items.forEach((e7) => e7.destroy()), this.midpointGraphics.removeAll();
  }
  _removeVertexGraphics(e6) {
    const t4 = e6 || this.layer;
    t4 && t4.removeMany(this.vertexGraphics.items), this.vertexGraphics.items.forEach((e7) => e7.destroy()), this.vertexGraphics.removeAll();
  }
  _setupGraphics() {
    const e6 = this.graphic.geometry;
    if (null != e6 && ("polyline" === e6.type || "polygon" === e6.type)) {
      const t4 = oe(e6);
      this.enableMidpoints && this._setUpMidpointGraphics(t4), this.enableVertices && this._setUpVertexGraphics(t4);
    }
  }
  _setUpMidpointGraphics(e6) {
    this._removeMidpointGraphics();
    const t4 = this._createMidpointGraphics(e6);
    this.midpointGraphics.addMany(t4), this.layer.addMany(t4);
  }
  _setUpVertexGraphics(e6) {
    this._removeVertexGraphics();
    const t4 = this._createVertexGraphics(e6);
    this.vertexGraphics.addMany(t4), this._storeRelatedVertexIndices(), this.layer.addMany(t4);
  }
  _createVertexGraphics(e6) {
    const { _graphicAttributes: i6, symbols: s3 } = this, o2 = [];
    return e6?.forEach((e7, r3) => {
      e7.forEach((e8, n2) => {
        o2.push(new d2({ geometry: this._coordinateHelper.arrayToPoint(e8), symbol: s3?.vertices?.default, attributes: { ...i6, pathIndex: r3, pointIndex: n2 } }));
      });
    }), o2;
  }
  _createMidpointGraphics(e6) {
    const { _graphicAttributes: i6, symbols: s3 } = this, o2 = [];
    for (let r3 = 0; r3 < e6.length; r3++) {
      const n2 = e6[r3];
      for (let e7 = 0; e7 < n2.length; e7++) {
        const h6 = (e7 + 1) % n2.length;
        if ("polyline" === this.graphic.geometry?.type && 0 === h6) continue;
        const a4 = n2[e7], p2 = n2[h6], c6 = this._getMidpoint(a4, p2);
        o2.push(new d2({ geometry: c6, symbol: s3.midpoints.default, attributes: { ...i6, pathIndex: r3, pointIndexStart: e7, pointIndexEnd: h6 } }));
      }
    }
    return o2;
  }
  _updateSymbolsForTheme() {
    const e6 = this.view.effectiveTheme.accentColor;
    this.symbols = { vertices: { ...this.symbols.vertices, default: this.symbols.vertices.default.clone().set("color", e6), hover: this.symbols.vertices.hover?.clone().set("color", e6) }, midpoints: { ...this.symbols.midpoints } };
    for (const t4 of this.vertexGraphics) this._isSelected(t4) ? t4.symbol = this.symbols.vertices.selected : this._hoverGraphic === t4 ? t4.symbol = this.symbols.vertices.hover : t4.symbol = this.symbols.vertices.default;
  }
  _storeRelatedVertexIndices() {
    const e6 = this.vertexGraphics.items;
    if (!e6) return;
    const t4 = e6.map(({ geometry: e7 }) => ({ x: e7.x, y: e7.y }));
    for (let i6 = 0; i6 < t4.length; i6++) {
      const s3 = [];
      for (let e7 = 0; e7 < t4.length; e7++) {
        if (i6 === e7) continue;
        const o2 = t4[i6], r3 = t4[e7];
        o2.x === r3.x && o2.y === r3.y && s3.push(e7);
      }
      e6[i6].attributes.relatedGraphicIndices = s3;
    }
  }
  _setupMover() {
    const { enableMovement: e6, graphic: t4, midpointGraphics: i6, vertexGraphics: s3, view: o2 } = this, r3 = s3.concat(i6).items;
    e6 && r3.push(t4), this._mover = new E2({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, graphics: r3, view: o2, callbacks: { onGraphicClick: (e7) => this._onGraphicClickCallback(e7), onGraphicMoveStart: (e7) => this._onGraphicMoveStartCallback(e7), onGraphicMove: (e7) => this._onGraphicMoveCallback(e7), onGraphicMoveStop: (e7) => this._onGraphicMoveStopCallback(e7), onGraphicPointerOver: (e7) => this._onGraphicPointerOverCallback(e7), onGraphicPointerOut: (e7) => this._onGraphicPointerOutCallback(e7) } });
  }
  _setupConnectedReshapeManager() {
    const { connectedReshapeProviders: e6 } = this;
    0 !== e6.length && (this._connectedReshapeManager = new L({ providerFactories: e6, view: this.view }));
  }
  _onGraphicClickCallback(e6) {
    e6.viewEvent.stopPropagation();
    const t4 = e6.graphic;
    if (t4 === this.graphic) this.clearSelection(), this.emit("graphic-click", e6), this.callbacks.onGraphicClick?.(e6);
    else if (this._isMidpoint(t4)) {
      if (2 === e6.viewEvent.button) return;
      const i6 = this.graphic.clone(), s3 = this._createVertexFromMidpoint(t4);
      this.refresh(), this._emitVertexAddEvent([t4], i6, s3);
    } else if (this._isVertex(t4)) if (e6.viewEvent.stopPropagation(), 2 === e6.viewEvent.button) this._removeVertices(t4);
    else {
      e6.viewEvent.native.shiftKey || this._clearSelection(), this.selectedVertices.includes(t4) ? this._removeFromSelection(t4, true) : this._addToSelection(t4);
    }
  }
  _setUpOperation(e6) {
    const { graphic: t4, dx: i6, dy: s3 } = e6, o2 = t4 === this.graphic;
    this._resetSnappingStateVars(), this._setUpGeometryHelper(), this._saveSnappingContextForHandle(t4, e6), this._activeOperationInfo = { target: this.graphic, mover: t4, operationType: o2 ? "move" : "reshape", totalDx: i6, totalDy: s3 };
  }
  _onGraphicMoveStartCallback(e6) {
    const { dx: t4, dy: i6, graphic: s3 } = e6, o2 = this._connectedReshapeManager, r3 = o2 ? he(this.graphic) : null;
    if (s3 === this.graphic) {
      const { geometry: n3 } = s3;
      return this._setUpOperation(e6), this._emitMoveStartEvent(t4, i6), r3 && o2?.startFeatureMove([r3]), void (null != n3 && "point" === n3.type && this._onHandleMove(s3, t4, i6, e6, () => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(t4, i6);
      }));
    }
    const { selectedVertices: n2 } = this;
    if (!n2.includes(s3)) {
      if (this._clearSelection(), this._isMidpoint(s3)) {
        const e7 = this.graphic.clone(), t5 = this._createVertexFromMidpoint(s3);
        this._emitVertexAddEvent([s3], e7, t5);
      }
      this._addToSelection(s3);
    }
    this._setUpOperation(e6), r3 && o2?.startVertexMove(r3, ae(n2)), this._emitReshapeStartEvent(s3), this._onHandleMove(s3, t4, i6, e6, () => {
      this._updateTooltip(s3, e6.viewEvent), this._emitReshapeEvent(s3);
    });
  }
  _onGraphicMoveCallback(e6) {
    const t4 = this._activeOperationInfo;
    if (!t4) return;
    const { dx: i6, dy: s3, graphic: o2 } = e6;
    t4.totalDx += i6, t4.totalDy += s3;
    const { operationType: r3 } = t4, { geometry: n2 } = o2;
    if (null != n2) {
      if ("move" !== r3) this._onHandleMove(o2, i6, s3, e6, () => {
        this._updateTooltip(o2, e6.viewEvent), this._emitReshapeEvent(o2);
      });
      else if ("point" === n2.type) this._onHandleMove(o2, i6, s3, e6, () => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i6, s3);
      });
      else if ("polyline" === n2.type || "polygon" === n2.type) {
        const t5 = oe(n2);
        this._updateVertexGraphicLocations(t5);
        const { dxMap: o3, dyMap: r4 } = pe(i6, s3, this.view);
        this._connectedReshapeManager?.translate(o3, r4, 0), this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i6, s3);
      }
    }
  }
  _onGraphicMoveStopCallback(e6) {
    const t4 = this._activeOperationInfo;
    if (!t4) return;
    const { dx: i6, dy: s3, graphic: o2 } = e6, { operationType: r3 } = t4;
    t4.totalDx += i6, t4.totalDy += s3, this._onHandleMove(o2, i6, s3, e6, () => "move" === r3 ? this._emitMoveStopEvent() : this._emitReshapeStopEvent(o2)), this._isMidpoint(o2) ? this.refresh() : (this._updateTooltip(this._isVertex(o2) ? o2 : null), this._resetSnappingStateVars(), this._connectedReshapeManager?.finish(), this._activeOperationInfo = null);
  }
  _updateVertexGraphicLocations(e6) {
    const { _coordinateHelper: t4 } = this;
    for (const i6 of this.vertexGraphics) {
      const { pathIndex: s3, pointIndex: o2 } = i6.attributes;
      i6.geometry = t4.arrayToPoint(e6[s3][o2]);
    }
    this._updateMidpointGraphicLocations(e6);
  }
  _updateMidpointGraphicLocations(e6) {
    for (const t4 of this.midpointGraphics) {
      const { pathIndex: i6, pointIndexStart: s3, pointIndexEnd: o2 } = t4.attributes, r3 = e6[i6];
      t4.geometry = this._getMidpoint(r3[s3], r3[o2]);
    }
  }
  _getMidpoint(e6, t4) {
    const { _coordinateHelper: i6 } = this, s3 = i6.arrayToVector(e6), o2 = i6.arrayToVector(t4), r3 = i6.toXYZ(s3), n2 = i6.toXYZ(o2), [h6, a4, p2] = c(r3, n2), c6 = i6.hasM() ? 0 : void 0;
    return new _({ x: h6, y: a4, z: p2, m: c6, spatialReference: i6.spatialReference });
  }
  _getVertexFromEditGeometry(e6) {
    const [t4, i6] = re(e6);
    return n(this._editGeometryOperations), this._editGeometryOperations.data.components[t4].vertices[i6];
  }
  _onHandleMove(e6, t4, s3, o2, r3) {
    e2(this._snappingTask);
    const n2 = this._snappingContext;
    if (!n2) return;
    const h6 = e6.geometry, a4 = "graphic-move-stop" === o2.type;
    if (null != this.snappingManager && this.selectedVertices.length < 2 && !a4) {
      const o3 = this.snappingManager;
      this._stagedVertex = o3.update({ point: h6, context: n2 }), this._syncGeometryAfterVertexMove(e6, new _(this._stagedVertex), t4, s3, a4), r3(), this._snappingTask = d(async (i6) => {
        const p2 = await o3.snap({ point: h6, context: n2, signal: i6 });
        p2.valid && (this._stagedVertex = p2.apply(), this._syncGeometryAfterVertexMove(e6, new _(this._stagedVertex), t4, s3, a4), r3());
      });
    } else {
      const i6 = null != this._stagedVertex ? new _(this._stagedVertex) : h6;
      this._syncGeometryAfterVertexMove(e6, i6, t4, s3, a4), r3();
    }
  }
  _syncGeometryAfterVertexMove(e6, t4, i6, s3, o2 = false) {
    const r3 = this._editGeometryOperations?.data.geometry;
    if (r3) if ("point" === r3.type) e6.geometry = t4;
    else if ("mesh" === r3.type) e6.geometry = r3.centerAt(t4);
    else {
      const { _coordinateHelper: n2 } = this, [h6, a4] = re(e6);
      let p2 = e3(r3);
      const c6 = p2[h6].length - 1, l4 = n2.pointToArray(t4);
      p2[h6][a4] = l4, "polygon" === r3.type && (0 === a4 ? p2[h6][c6] = l4 : a4 === c6 && (p2[h6][0] = l4)), this._isVertex(e6) && (p2 = this._moveRelatedCoordinates(p2, e6, l4), p2 = this._moveSelectedHandleCoordinates(p2, e6, i6, s3, "polygon" === r3.type), this._updateMidpointGraphicLocations(p2)), this._updateGraphicGeometry(r3.clone());
      const d5 = n2.pointToVector(t4), m3 = this._getVertexFromEditGeometry(e6), v2 = n2.getZ(d5), y3 = d5[0] - m3.pos[0], _4 = d5[1] - m3.pos[1], g3 = null != v2 ? v2 - m3.pos[2] : 0;
      this._editGeometryOperations?.moveVertices([m3], y3, _4, g3), this._connectedReshapeManager?.translate(y3, _4, g3), o2 && (this._mover ? this._mover.updateGeometry(this._mover.graphics.indexOf(e6), t4) : e6.geometry = t4);
    }
  }
  _moveRelatedCoordinates(e6, t4, i6) {
    const { relatedGraphicIndices: s3 } = t4.attributes;
    for (const o2 of s3) {
      const s4 = this.vertexGraphics.at(o2), { pathIndex: r3, pointIndex: n2 } = s4.attributes;
      e6[r3][n2] = i6, s4.geometry = t4.geometry;
    }
    return e6;
  }
  _moveSelectedHandleCoordinates(e6, t4, i6, s3, o2) {
    for (const r3 of this.selectedVertices) if (r3 !== t4) {
      const { pathIndex: t5, pointIndex: n2, relatedGraphicIndices: h6 } = r3.attributes, a4 = i2(r3.geometry, i6, s3, this.view), p2 = e3(a4), c6 = e6[t5].length - 1;
      e6[t5][n2] = p2, r3.geometry = a4, o2 && (0 === n2 ? e6[t5][c6] = p2 : n2 === c6 && (e6[t5][0] = p2));
      for (const i7 of h6) {
        const t6 = this.vertexGraphics.at(i7), { pathIndex: s4, pointIndex: o3 } = t6.attributes;
        e6[s4][o3] = p2, t6.geometry = a4;
      }
    }
    return e6;
  }
  _onGraphicPointerOverCallback(e6) {
    const t4 = e6.graphic;
    this._hoverGraphic = t4;
    const i6 = this._isVertex(t4);
    i6 && !this._isSelected(t4) && (t4.symbol = this.symbols.vertices.hover), this._updateTooltip(i6 ? t4 : null), this._updateHoverCursor(t4);
  }
  _onGraphicPointerOutCallback(e6) {
    const t4 = e6.graphic;
    this._hoverGraphic = null, this._isVertex(t4) && !this._isSelected(t4) && (t4.symbol = this.symbols.vertices.default), this.view.cursor = "default", this._updateTooltip();
  }
  _createVertexFromMidpoint(e6) {
    const { _graphicAttributes: t4, graphic: i6 } = this, s3 = i6.geometry;
    if (null == s3 || "polygon" !== s3.type && "polyline" !== s3.type) return [];
    const o2 = s3.clone(), r3 = [], { pathIndex: n2, pointIndexStart: h6, pointIndexEnd: a4 } = e6.attributes, p2 = e3(e6.geometry), c6 = 0 === a4 ? h6 + 1 : a4, l4 = e3(o2);
    return l4[n2].splice(c6, 0, p2), e6.attributes = { ...t4, pathIndex: n2, pointIndex: c6, relatedGraphicIndices: [] }, r3.push({ coordinates: l4[n2][c6], componentIndex: n2, vertexIndex: c6 }), this._updateGraphicGeometry(o2), r3;
  }
  _addToSelection(e6) {
    const t4 = ne(e6);
    for (const i6 of t4) i6.symbol = this.symbols.vertices.selected, this.selectedVertices.add(i6), this._updateTooltip(i6);
    this._emitSelectEvent(t4);
  }
  _removeFromSelection(e6, t4) {
    const { vertices: i6 } = this.symbols, s3 = t4 ? i6.hover : i6.default;
    this.selectedVertices.remove(e6), e6.symbol = s3, this._emitDeselectEvent([e6]), this._updateTooltip();
  }
  _clearSelection() {
    const e6 = this.selectedVertices.toArray();
    if (e6.length > 0) {
      for (const t4 of e6) t4.set("symbol", this.symbols.vertices.default);
      this.selectedVertices.removeAll(), this._emitDeselectEvent(e6), this._updateTooltip();
    }
  }
  _keyDownHandler(e6) {
    null == this._activeOperationInfo && H(e6, this.tooltip) || c4.delete.includes(e6.key) && !e6.repeat && this.selectedVertices.length && this._removeVertices(this.selectedVertices);
  }
  _removeVertices(e6) {
    const t4 = this.graphic.geometry;
    if (null == t4 || "polygon" !== t4.type && "polyline" !== t4.type) return;
    if ("polygon" === t4.type && this.vertexGraphics.length < 4 || this.vertexGraphics.length < 3) return;
    const i6 = this.graphic.clone(), s3 = t4.clone();
    let o2 = e3(s3);
    const r3 = [], n2 = ne(e6);
    for (const h6 of n2) {
      const { x: e7, y: t5 } = h6.geometry;
      for (let i7 = 0; i7 < o2.length; i7++) {
        const s4 = o2[i7];
        for (let n3 = 0; n3 < s4.length; n3++) {
          const [h7, a4] = s4[n3];
          e7 === h7 && t5 === a4 && (r3.push({ coordinates: o2[i7][n3], componentIndex: i7, vertexIndex: n3 }), o2[i7].splice(Number(n3), 1));
        }
      }
    }
    if ("polygon" === s3.type) o2 = o2.filter((e7) => {
      if (e7.length < 2) return false;
      const [t5, i7] = e7[0], [s4, o3] = e7[e7.length - 1];
      return (2 !== e7.length || t5 !== s4 || i7 !== o3) && (t5 === s4 && i7 === o3 || e7.push(e7[0]), true);
    }), s3.rings = o2;
    else {
      for (const e7 of o2) 1 === e7.length && o2.splice(o2.indexOf(e7), 1);
      s3.paths = o2;
    }
    this._updateGraphicGeometry(s3), this.refresh(), this._emitVertexRemoveEvent(n2, i6, r3);
  }
  _isVertex(e6) {
    return this.vertexGraphics.includes(e6);
  }
  _isSelected(e6) {
    return this._isVertex(e6) && this.selectedVertices.includes(e6);
  }
  _isMidpoint(e6) {
    return this.midpointGraphics.includes(e6);
  }
  _updateHoverCursor(e6) {
    this.view.cursor = this._isMidpoint(e6) ? "copy" : "move";
  }
  _updateTooltip(e6, t4) {
    let i6 = null;
    const { graphic: s3, view: o2, tooltipInfos: r3 } = this, n2 = s3?.geometry;
    "point" === n2?.type ? i6 = r3.movePoint : this._selectedVertex ? i6 = r3.selectedVertex : e6 === this.graphic ? (i6 = r3.translateGraphic, j3(i6, o2, this._tooltipsContext, t4)) : e6 && this.selectedVertices.length > 1 && (i6 = r3.translateVertices, w3(i6, o2, n2, this._tooltipsContext, t4)), this.activeTooltipInfo = i6;
  }
  _updateGraphicGeometry(e6) {
    this._updateHandlesOnExternalGeometryChange?.pause(), this.graphic.geometry = e6, this._updateHandlesOnExternalGeometryChange?.resume();
  }
  _emitMoveStartEvent(e6, t4) {
    const i6 = new q(this.graphic, e6, t4);
    this.emit("move-start", i6), this.callbacks.onMoveStart?.(i6);
  }
  _emitMoveEvent(e6, t4) {
    const i6 = new B(this.graphic, e6, t4);
    this.emit("move", i6), this.callbacks.onMove?.(i6);
  }
  _emitMoveStopEvent(e6, t4) {
    if (null == e6 || null == t4) {
      const i7 = this._activeOperationInfo;
      if (!i7) return;
      e6 = i7.totalDx, t4 = i7.totalDy;
    }
    const i6 = new J(this.graphic, e6, t4);
    this.emit("move-stop", i6), this.callbacks.onMoveStop?.(i6);
  }
  _emitReshapeStartEvent(e6) {
    const t4 = new X(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape-start", t4), this.callbacks.onReshapeStart?.(t4);
  }
  _emitReshapeEvent(e6) {
    const t4 = new Y(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape", t4), this.callbacks.onReshape?.(t4);
  }
  _emitReshapeStopEvent(e6) {
    const t4 = new K(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape-stop", t4), this.callbacks.onReshapeStop?.(t4);
  }
  _emitSelectEvent(e6) {
    const t4 = new Q(e6);
    this.emit("select", t4), this.callbacks.onVertexSelect?.(t4);
  }
  _emitDeselectEvent(e6) {
    const t4 = new W(e6);
    this.emit("deselect", t4), this.callbacks.onVertexDeselect?.(t4);
  }
  _emitVertexAddEvent(e6, t4, i6) {
    const s3 = new $(e6, this.graphic, t4, i6);
    this.emit("vertex-add", s3), this.callbacks.onVertexAdd?.(s3);
  }
  _emitVertexRemoveEvent(e6, t4, i6) {
    const s3 = new ee(e6, this.graphic, t4, i6);
    this.emit("vertex-remove", s3), this.callbacks.onVertexRemove?.(s3);
  }
  _logGeometryTypeError() {
    i.getLogger(this).error(new s("reshape:invalid-geometry", "Reshape operation not supported for the provided graphic. The geometry type is not supported."));
  }
};
function oe(e6) {
  const t4 = e3(e6.clone());
  if ("polygon" === e6.type) for (const i6 of t4) {
    const e7 = i6[i6.length - 1];
    i6[0][0] === e7[0] && i6[0][1] === e7[1] && i6.length > 2 && i6.pop();
  }
  return t4;
}
function re({ attributes: e6 }) {
  return [e6?.pathIndex || 0, e6?.pointIndex || 0];
}
function ne(e6) {
  return e6 instanceof d2 ? [e6] : [...e6];
}
function he(e6) {
  const t4 = e6.sourceLayer ?? e6.layer;
  return a2(t4) ? { graphic: e6, layer: t4 } : null;
}
function ae(e6) {
  return e6.toArray().map((e7) => ({ pathIndex: e7.attributes.pathIndex, vertexIndex: e7.attributes.pointIndex }));
}
function pe(e6, t4, i6) {
  const s3 = i6.state.inverseTransform;
  return { dxMap: s3[0] * e6 + s3[2] * t4, dyMap: s3[1] * e6 + s3[3] * t4 };
}
r([m()], se.prototype, "_activeOperationInfo", void 0), r([m()], se.prototype, "_connectedReshapeManager", void 0), r([m()], se.prototype, "_coordinateHelper", null), r([m()], se.prototype, "_editGeometryOperations", void 0), r([m()], se.prototype, "tooltip", void 0), r([m()], se.prototype, "tooltipInfos", void 0), r([m()], se.prototype, "activeTooltipInfo", void 0), r([m({ constructOnly: true })], se.prototype, "automaticAreaMeasurementUtils", void 0), r([m({ constructOnly: true })], se.prototype, "automaticLengthMeasurementUtils", void 0), r([m()], se.prototype, "_selectedVertex", null), r([m()], se.prototype, "_tooltipsContext", null), r([m()], se.prototype, "callbacks", void 0), r([m()], se.prototype, "connectedReshapeProviders", void 0), r([m()], se.prototype, "enableMidpoints", void 0), r([m()], se.prototype, "enableMovement", void 0), r([m()], se.prototype, "enableVertices", void 0), r([m()], se.prototype, "graphic", void 0), r([m()], se.prototype, "highlightName", void 0), r([m()], se.prototype, "highlightsEnabled", void 0), r([m()], se.prototype, "layer", void 0), r([m({ readOnly: true })], se.prototype, "midpointGraphics", void 0), r([m()], se.prototype, "midpointSymbol", void 0), r([m({ readOnly: true })], se.prototype, "selectedVertices", void 0), r([m()], se.prototype, "snappingManager", void 0), r([m({ readOnly: true })], se.prototype, "state", null), r([m()], se.prototype, "symbols", void 0), r([m({ type: c5 })], se.prototype, "sketchOptions", void 0), r([m({ readOnly: true })], se.prototype, "type", void 0), r([m({ readOnly: true })], se.prototype, "vertexGraphics", void 0), r([m()], se.prototype, "view", void 0), se = r([a("esri.views.draw.support.Reshape")], se);
var ce = se;
export {
  ce as default
};
//# sourceMappingURL=Reshape-YOE4WXL3.js.map
