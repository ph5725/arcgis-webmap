import {
  a as a6,
  b as b4,
  c,
  c2,
  f as f5
} from "./chunk-PLM5FUIE.js";
import {
  S as S2,
  S2 as S3,
  d as d2,
  h as h3,
  n as n2,
  o as o6
} from "./chunk-PC3GTHZ5.js";
import {
  t as t3
} from "./chunk-7T3OPELU.js";
import {
  a as a5
} from "./chunk-IY3QUJDS.js";
import {
  D,
  M as M2,
  R as R2,
  U as U2,
  a as a4,
  b as b3,
  f as f4,
  l as l3,
  m as m6,
  n,
  o as o5,
  q as q2,
  r as r4,
  w
} from "./chunk-LW7J7Z4M.js";
import {
  i as i2
} from "./chunk-BMFPNVV7.js";
import {
  R
} from "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import {
  g
} from "./chunk-B6C7UPBZ.js";
import {
  j as j2
} from "./chunk-VGIEH4HM.js";
import {
  p
} from "./chunk-XLF2NMGX.js";
import {
  t as t2
} from "./chunk-X5GD6LFD.js";
import {
  b2
} from "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import {
  E
} from "./chunk-UGXCZZ7N.js";
import {
  o as o4
} from "./chunk-OTSYE6UT.js";
import "./chunk-AGDHKBKD.js";
import "./chunk-OC2XWDW2.js";
import "./chunk-C3JHRSMA.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-HUVZEBBO.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-I6IIPG56.js";
import "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import {
  f as f3,
  s as s3
} from "./chunk-SYPTUUSZ.js";
import "./chunk-YZLWQJLF.js";
import {
  h
} from "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import {
  O,
  Q
} from "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import {
  k
} from "./chunk-F4KXGA4J.js";
import "./chunk-KHRHKYU2.js";
import {
  d
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import {
  q
} from "./chunk-YX2VTIZR.js";
import {
  C,
  M,
  h as h2
} from "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import {
  m as m5,
  u
} from "./chunk-HNQNVI5C.js";
import {
  m as m4
} from "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import {
  r as r3
} from "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import {
  f as f2
} from "./chunk-N3A2BVTW.js";
import {
  l as l2
} from "./chunk-IGYEHOTB.js";
import {
  a as a2
} from "./chunk-TVM3SZJR.js";
import {
  m as m3
} from "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import {
  y as y2
} from "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  a as a3
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import {
  C as C2
} from "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import {
  o as o2
} from "./chunk-JUAPMINU.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import {
  r as r2
} from "./chunk-YFPGM5UE.js";
import {
  U,
  j
} from "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  m as m2,
  o
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import {
  m
} from "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  o as o3
} from "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H,
  y2 as y
} from "./chunk-ZWFY3WY5.js";
import {
  I,
  jt
} from "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  b
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s as s2
} from "./chunk-XWG6QGFK.js";
import {
  e,
  s,
  t
} from "./chunk-GWNLQRNM.js";
import {
  L
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p2 = class extends l {
  constructor(o7) {
    super(o7), this.break = new u({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new u({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new u({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new u({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new u({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new u({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
r([m2({ types: M })], p2.prototype, "break", void 0), r([m2({ types: M })], p2.prototype, "first", void 0), r([m2({ types: M })], p2.prototype, "unlocated", void 0), r([m2({ types: M })], p2.prototype, "last", void 0), r([m2({ types: M })], p2.prototype, "middle", void 0), r([m2({ types: M })], p2.prototype, "waypoint", void 0), p2 = r([a("esri.layers.support.RouteStopSymbols")], p2);

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var c3 = class extends l {
  constructor(o7) {
    super(o7), this.directionLines = new m4({ color: [0, 122, 194], width: 6 }), this.directionPoints = new u({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new u({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new m5({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new m4({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new m4({ width: 8, color: [20, 89, 127] }), this.stops = new p2();
  }
};
r([m2({ types: C })], c3.prototype, "directionLines", void 0), r([m2({ types: M })], c3.prototype, "directionPoints", void 0), r([m2({ types: M })], c3.prototype, "pointBarriers", void 0), r([m2({ types: h2 })], c3.prototype, "polygonBarriers", void 0), r([m2({ types: C })], c3.prototype, "polylineBarriers", void 0), r([m2({ types: C })], c3.prototype, "routeInfo", void 0), r([m2({ type: p2 })], c3.prototype, "stops", void 0), c3 = r([a("esri.layers.support.RouteSymbols")], c3);

// node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var m7 = class extends l {
  constructor(t4) {
    super(t4), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
r([m2({ type: String })], m7.prototype, "dataType", void 0), r([r3(D, { ignoreUnknown: false })], m7.prototype, "name", void 0), r([m2({ type: [String] })], m7.prototype, "parameterNames", void 0), r([m2({ type: String })], m7.prototype, "restrictionUsageParameterName", void 0), r([r3(U2, { ignoreUnknown: false })], m7.prototype, "timeNeutralAttributeName", void 0), r([m2({ type: String })], m7.prototype, "trafficSupport", void 0), r([r3(n)], m7.prototype, "units", void 0), r([r3(b3)], m7.prototype, "usageType", void 0), m7 = r([a("esri.rest.support.NetworkAttribute")], m7);
var u2 = m7;

// node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p3 = class extends l {
  constructor(t4) {
    super(t4), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
r([m2({ type: Number })], p3.prototype, "buildTime", void 0), r([m2({ type: String })], p3.prototype, "name", void 0), r([m2({ type: [u2] })], p3.prototype, "networkAttributes", void 0), r([m2()], p3.prototype, "networkSources", void 0), r([m2({ type: String })], p3.prototype, "state", void 0), p3 = r([a("esri.rest.support.NetworkDataset")], p3);
var i3 = p3;

// node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var c4 = class extends l {
  constructor(t4) {
    super(t4), this.accumulateAttributeNames = null, this.attributeParameterValues = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => D.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r5) {
    t4?.length && (e2[r5] = t4.map((t5) => D.toJSON(t5)));
  }
  get capabilities() {
    return { supportsNow: (this.currentVersion ?? 10) >= 10.81 };
  }
  readDefaultTravelMode(t4, e2) {
    const r5 = e2.supportedTravelModes?.find(({ id: t5 }) => t5 === e2.defaultTravelMode) ?? e2.supportedTravelModes?.find(({ itemId: t5 }) => t5 === e2.defaultTravelMode);
    return r5 ? b4.fromJSON(r5) : null;
  }
};
r([m2()], c4.prototype, "accumulateAttributeNames", void 0), r([o2("accumulateAttributeNames")], c4.prototype, "readAccumulateAttributes", null), r([r2("accumulateAttributeNames")], c4.prototype, "writeAccumulateAttributes", null), r([m2()], c4.prototype, "attributeParameterValues", void 0), r([m2()], c4.prototype, "capabilities", null), r([m2()], c4.prototype, "currentVersion", void 0), r([m2()], c4.prototype, "defaultTravelMode", void 0), r([o2("defaultTravelMode", ["defaultTravelMode", "supportedTravelModes"])], c4.prototype, "readDefaultTravelMode", null), r([m2()], c4.prototype, "directionsLanguage", void 0), r([r3(a4)], c4.prototype, "directionsLengthUnits", void 0), r([m2()], c4.prototype, "directionsSupportedLanguages", void 0), r([r3(U2, { ignoreUnknown: false })], c4.prototype, "directionsTimeAttribute", void 0), r([m2()], c4.prototype, "hasZ", void 0), r([r3(D, { ignoreUnknown: false })], c4.prototype, "impedance", void 0), r([m2({ type: i3 })], c4.prototype, "networkDataset", void 0), r([m2({ type: [b4] })], c4.prototype, "supportedTravelModes", void 0), c4 = r([a("esri.rest.support.NetworkServiceDescription")], c4);

// node_modules/@arcgis/core/rest/networkService.js
var l4 = () => i.getLogger("esri.rest.networkService");
function u3(e2, r5, t4, o7) {
  o7[t4] = [r5.length, r5.length + e2.length], e2.forEach((e3) => {
    r5.push(e3.geometry);
  });
}
function f6(e2, r5) {
  for (let t4 = 0; t4 < r5.length; t4++) {
    const o7 = e2[r5[t4]];
    if (o7 && o7.length) for (const e3 of o7) e3.z = void 0;
  }
  l4().warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function c5(e2, r5) {
  for (let t4 = 0; t4 < r5.length; t4++) {
    const o7 = e2[r5[t4]];
    if (o7 && o7.length) {
      for (const e3 of o7) if (null != e3 && e3.hasZ) return true;
    }
  }
  return false;
}
async function d3(t4, o7, s5) {
  if (!t4) throw new s2("network-service:missing-url", "Url to Network service is missing");
  const n5 = s3({ f: "json", token: o7 }, s5), { data: l7 } = await H(t4, n5), u6 = l7.currentVersion >= 10.4 ? p4(t4, o7, s5) : v(t4, s5), { defaultTravelMode: f7, supportedTravelModes: c13 } = await u6;
  return l7.defaultTravelMode = f7, l7.supportedTravelModes = c13, c4.fromJSON(l7);
}
async function v(r5, t4) {
  const i6 = s3({ f: "json" }, t4), { data: l7 } = await H(r5.replace(/\/rest\/.*$/i, "/info"), i6);
  if (!l7?.owningSystemUrl) return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: u6 } = l7, f7 = jt(u6) + "/sharing/rest/portals/self", { data: c13 } = await H(f7, i6), d4 = t("helperServices.routingUtilities.url", c13);
  if (!d4) return { supportedTravelModes: [], defaultTravelMode: null };
  const v2 = f3(u6), p8 = /\/solve$/i.test(v2.path) ? "Route" : /\/solveclosestfacility$/i.test(v2.path) ? "ClosestFacility" : "ServiceAreas", m11 = s3({ f: "json", serviceName: p8 }, t4), h4 = jt(d4) + "/GetTravelModes/execute", g2 = await H(h4, m11), w2 = [];
  let T = null;
  if (g2?.data?.results?.length) {
    const e2 = g2.data.results;
    for (const r6 of e2) if ("supportedTravelModes" === r6.paramName) {
      if (r6.value?.features) {
        for (const { attributes: e3 } of r6.value.features) if (e3) {
          const r7 = JSON.parse(e3.TravelMode);
          w2.push(r7);
        }
      }
    } else "defaultTravelMode" === r6.paramName && (T = r6.value);
  }
  return { supportedTravelModes: w2, defaultTravelMode: T };
}
async function p4(t4, o7, n5) {
  try {
    const r5 = s3({ f: "json", token: o7 }, n5), i6 = jt(t4) + "/retrieveTravelModes", { data: { supportedTravelModes: l7, defaultTravelMode: u6 } } = await H(i6, r5);
    return { supportedTravelModes: l7, defaultTravelMode: u6 };
  } catch (i6) {
    throw new s2("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: i6 });
  }
}

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p5 = new o3({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c6 = class extends a5 {
  constructor(r5) {
    super(r5), this.type = null;
  }
};
r([m2({ type: String, json: { read: p5.read, write: p5.write } })], c6.prototype, "type", void 0), c6 = r([a("esri.rest.support.NAMessage")], c6);
var i4 = c6;

// node_modules/@arcgis/core/rest/support/DirectionsString.js
var c7 = class extends l {
  constructor(r5) {
    super(r5);
  }
};
r([m2({ json: { read: { source: "string" } } })], c7.prototype, "text", void 0), r([r3(q2, { name: "stringType" })], c7.prototype, "type", void 0), c7 = r([a("esri.rest.support.DirectionsString")], c7);
var i5 = c7;

// node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a7 = class extends l {
  constructor(r5) {
    super(r5), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r5, e2) {
    return n2(e2.ETA, e2.arriveTimeUTC);
  }
  readGeometry(r5, e2) {
    return _.fromJSON(e2.point);
  }
};
r([m2({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a7.prototype, "arriveTime", void 0), r([m2()], a7.prototype, "arriveTimeOffset", void 0), r([o2("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a7.prototype, "readArriveTimeOffset", null), r([m2({ type: _ })], a7.prototype, "geometry", void 0), r([o2("geometry", ["point"])], a7.prototype, "readGeometry", null), r([m2({ type: [i5] })], a7.prototype, "strings", void 0), a7 = r([a("esri.rest.support.DirectionsEvent")], a7);
var c8 = a7;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function c9(r5) {
  if (null == r5 || "" === r5) return null;
  let e2 = 0, t4 = 0, o7 = 0, s5 = 0;
  const p8 = [];
  let n5, i6, c13, a9, m11, l7, u6, y3, d4 = 0, f7 = 0, h4 = 0;
  if (m11 = r5.match(/((\+|-)[^+\-|]+|\|)/g), m11 || (m11 = []), 0 === parseInt(m11[d4], 32)) {
    d4 = 2;
    const r6 = parseInt(m11[d4], 32);
    d4++, l7 = parseInt(m11[d4], 32), d4++, 1 & r6 && (f7 = m11.indexOf("|") + 1, u6 = parseInt(m11[f7], 32), f7++), 2 & r6 && (h4 = m11.indexOf("|", f7) + 1, y3 = parseInt(m11[h4], 32), h4++);
  } else l7 = parseInt(m11[d4], 32), d4++;
  for (; d4 < m11.length && "|" !== m11[d4]; ) {
    n5 = parseInt(m11[d4], 32) + e2, d4++, e2 = n5, i6 = parseInt(m11[d4], 32) + t4, d4++, t4 = i6;
    const r6 = [n5 / l7, i6 / l7];
    f7 && (a9 = parseInt(m11[f7], 32) + o7, f7++, o7 = a9, r6.push(a9 / u6)), h4 && (c13 = parseInt(m11[h4], 32) + s5, h4++, s5 = c13, r6.push(c13 / y3)), p8.push(r6);
  }
  return { paths: [p8], hasZ: f7 > 0, hasM: h4 > 0 };
}
var a8 = class extends d {
  constructor(r5) {
    super(r5), this.events = null, this.geometry = null, this.strings = null;
  }
  readGeometry(r5, e2) {
    const t4 = c9(e2.compressedGeometry);
    return null != t4 ? y2.fromJSON(t4) : null;
  }
};
r([m2({ type: [c8] })], a8.prototype, "events", void 0), r([m2({ type: y2 })], a8.prototype, "geometry", void 0), r([o2("geometry", ["compressedGeometry"])], a8.prototype, "readGeometry", null), r([m2({ type: [i5] })], a8.prototype, "strings", void 0), a8 = r([a("esri.rest.support.DirectionsFeature")], a8);
var m8 = a8;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function u4(e2, t4) {
  if (0 === e2.length) return new y2({ spatialReference: t4 });
  const r5 = [];
  for (const n5 of e2) for (const e3 of n5.paths) r5.push(...e3);
  const o7 = [];
  r5.forEach((e3, t5) => {
    0 !== t5 && e3[0] === r5[t5 - 1][0] && e3[1] === r5[t5 - 1][1] || o7.push(e3);
  });
  const { hasM: s5, hasZ: a9 } = e2[0];
  return new y2({ hasM: s5, hasZ: a9, paths: [o7], spatialReference: t4 });
}
var m9 = class extends g {
  constructor(e2) {
    super(e2), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e2, t4) {
    if (!e2) return [];
    const r5 = t4.summary.envelope.spatialReference ?? t4.spatialReference, o7 = r5 && f.fromJSON(r5);
    return e2.map((e3) => {
      const t5 = m8.fromJSON(e3);
      if (null != t5.geometry && (t5.geometry.spatialReference = o7), null != t5.events) for (const r6 of t5.events) null != r6.geometry && (r6.geometry.spatialReference = o7);
      return t5;
    });
  }
  get mergedGeometry() {
    if (!this.features) return null;
    return u4(this.features.map(({ geometry: e2 }) => e2), this.extent.spatialReference);
  }
  get strings() {
    return this.features.flatMap(({ strings: e2 }) => e2).filter(L);
  }
};
r([m2({ type: z, json: { read: { source: "summary.envelope" } } })], m9.prototype, "extent", void 0), r([m2({ nonNullable: true })], m9.prototype, "features", void 0), r([o2("features")], m9.prototype, "readFeatures", null), r([m2()], m9.prototype, "geometryType", void 0), r([m2({ readOnly: true })], m9.prototype, "mergedGeometry", null), r([m2()], m9.prototype, "routeId", void 0), r([m2()], m9.prototype, "routeName", void 0), r([m2({ value: null, readOnly: true })], m9.prototype, "strings", null), r([m2({ json: { read: { source: "summary.totalDriveTime" } } })], m9.prototype, "totalDriveTime", void 0), r([m2({ json: { read: { source: "summary.totalLength" } } })], m9.prototype, "totalLength", void 0), r([m2({ json: { read: { source: "summary.totalTime" } } })], m9.prototype, "totalTime", void 0), m9 = r([a("esri.rest.support.DirectionsFeatureSet")], m9);
var c10 = m9;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n3 = class extends l {
  constructor(t4) {
    super(t4), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
r([m2({ type: g, json: { write: true } })], n3.prototype, "directionLines", void 0), r([m2({ type: g, json: { write: true } })], n3.prototype, "directionPoints", void 0), r([m2({ type: c10, json: { write: true } })], n3.prototype, "directions", void 0), r([m2({ type: d, json: { write: true } })], n3.prototype, "route", void 0), r([m2({ type: String, json: { write: true } })], n3.prototype, "routeName", void 0), r([m2({ type: [d], json: { write: true } })], n3.prototype, "stops", void 0), r([m2({ type: g, json: { write: true } })], n3.prototype, "traversedEdges", void 0), r([m2({ type: g, json: { write: true } })], n3.prototype, "traversedJunctions", void 0), r([m2({ type: g, json: { write: true } })], n3.prototype, "traversedTurns", void 0), n3 = r([a("esri.rest.support.RouteResult")], n3);
var u5 = n3;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function n4(r5) {
  return r5 ? g.fromJSON(r5).features.filter(L) : [];
}
var c11 = class extends l {
  constructor(r5) {
    super(r5), this.checksum = null, this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r5, o7) {
    return n4(o7.barriers);
  }
  readPolylineBarriers(r5) {
    return n4(r5);
  }
  readPolygonBarriers(r5) {
    return n4(r5);
  }
};
r([m2({ type: String })], c11.prototype, "checksum", void 0), r([m2({ type: [i4] })], c11.prototype, "messages", void 0), r([m2({ type: [d] })], c11.prototype, "pointBarriers", void 0), r([o2("pointBarriers", ["barriers"])], c11.prototype, "readPointBarriers", null), r([m2({ type: [d] })], c11.prototype, "polylineBarriers", void 0), r([o2("polylineBarriers")], c11.prototype, "readPolylineBarriers", null), r([m2({ type: [d] })], c11.prototype, "polygonBarriers", void 0), r([o2("polygonBarriers")], c11.prototype, "readPolygonBarriers", null), r([m2({ type: [u5] })], c11.prototype, "routeResults", void 0), c11 = r([a("esri.rest.support.RouteSolveResult")], c11);

// node_modules/@arcgis/core/rest/route.js
function p6(e2) {
  return e2 instanceof g;
}
async function l5(c13, f7, l7) {
  const y3 = [], d4 = [], h4 = {}, g2 = {}, R4 = f3(c13), { path: v2 } = R4;
  p6(f7.stops) && u3(f7.stops.features, d4, "stops.features", h4), p6(f7.pointBarriers) && u3(f7.pointBarriers.features, d4, "pointBarriers.features", h4), p6(f7.polylineBarriers) && u3(f7.polylineBarriers.features, d4, "polylineBarriers.features", h4), p6(f7.polygonBarriers) && u3(f7.polygonBarriers.features, d4, "polygonBarriers.features", h4);
  const B = await R(d4);
  for (const e2 in h4) {
    const r5 = h4[e2];
    y3.push(e2), g2[e2] = B.slice(r5[0], r5[1]);
  }
  if (c5(g2, y3)) {
    let e2 = null;
    try {
      e2 = await d3(v2, f7.apiKey, l7);
    } catch {
    }
    e2 && !e2.hasZ && f6(g2, y3);
  }
  for (const e2 in g2) g2[e2].forEach((t4, s5) => {
    o(f7, e2)[s5].geometry = t4;
  });
  const E2 = { ...l7, query: { ...R4.query, ...o6(f7), f: "json" } }, T = v2.endsWith("/solve") ? v2 : `${v2}/solve`, { data: b5 } = await H(T, E2);
  return m10(b5);
}
function m10(e2) {
  const { barriers: r5, checksum: t4, directionLines: s5, directionPoints: o7, directions: a9, messages: u6, polygonBarriers: i6, polylineBarriers: n5, routes: c13, stops: p8, traversedEdges: l7, traversedJunctions: m11, traversedTurns: y3 } = e2, d4 = (e3) => {
    const r6 = g2.find((r7) => r7.routeName === e3);
    if (null != r6) return r6;
    const t5 = { routeId: g2.length + 1, routeName: e3 };
    return g2.push(t5), t5;
  }, h4 = (e3) => {
    const r6 = g2.find((r7) => r7.routeId === e3);
    if (null != r6) return r6;
    const t5 = { routeId: e3, routeName: null };
    return g2.push(t5), t5;
  }, g2 = [];
  c13?.features.forEach((e3, r6) => {
    e3.geometry.spatialReference = c13.spatialReference ?? void 0;
    const t5 = e3.attributes.Name, s6 = r6 + 1;
    g2.push({ routeId: s6, routeName: t5, route: e3 });
  }), a9?.forEach((e3) => {
    const { routeName: r6 } = e3;
    d4(r6).directions = e3;
  });
  const R4 = (p8?.features.every((e3) => null == e3.attributes.RouteName) ?? false) && g2.length > 0 ? g2[0].routeName : null;
  return p8?.features.forEach((e3) => {
    e3.geometry && (e3.geometry.spatialReference ??= p8.spatialReference ?? void 0);
    const r6 = R4 ?? e3.attributes.RouteName, t5 = d4(r6);
    t5.stops ??= [], t5.stops.push(e3);
  }), s5?.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h4(r6), { geometryType: o8, spatialReference: a10 } = s5;
    t5.directionLines ??= { features: [], geometryType: o8, spatialReference: a10 }, t5.directionLines.features.push(e3);
  }), o7?.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h4(r6), { geometryType: s6, spatialReference: a10 } = o7;
    t5.directionPoints ??= { features: [], geometryType: s6, spatialReference: a10 }, t5.directionPoints.features.push(e3);
  }), l7?.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h4(r6), { geometryType: s6, spatialReference: o8 } = l7;
    t5.traversedEdges ??= { features: [], geometryType: s6, spatialReference: o8 }, t5.traversedEdges.features.push(e3);
  }), m11?.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h4(r6), { geometryType: s6, spatialReference: o8 } = m11;
    t5.traversedJunctions ??= { features: [], geometryType: s6, spatialReference: o8 }, t5.traversedJunctions.features.push(e3);
  }), y3?.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h4(r6);
    t5.traversedTurns ??= { features: [] }, t5.traversedTurns.features.push(e3);
  }), c11.fromJSON({ barriers: r5, checksum: t4, messages: u6, polygonBarriers: i6, polylineBarriers: n5, routeResults: g2 });
}

// node_modules/@arcgis/core/rest/support/DataLayer.js
var l6 = class extends a2.ClonableMixin(l) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
r([m2({ type: Boolean, json: { write: true } })], l6.prototype, "doNotLocateOnRestrictedElements", void 0), r([m2({ types: l2, json: { read: f2, write: true } })], l6.prototype, "geometry", void 0), r([r3(R2)], l6.prototype, "geometryType", void 0), r([m2({ type: String, json: { name: "layerName", write: true } })], l6.prototype, "name", void 0), r([r3(M2, { name: "spatialRel" })], l6.prototype, "spatialRelationship", void 0), r([m2({ type: String, json: { write: true } })], l6.prototype, "type", void 0), r([m2({ type: String, json: { write: true } })], l6.prototype, "where", void 0), l6 = r([a("esri.rest.support.DataLayer")], l6);

// node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s4;
var _a;
var c12 = (_a = class extends g {
  constructor(t4) {
    super(t4), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s4({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
}, s4 = _a, _a);
r([m2({ type: Boolean, json: { write: true } })], c12.prototype, "doNotLocateOnRestrictedElements", void 0), c12 = s4 = r([a("esri.rest.support.NetworkFeatureSet")], c12);

// node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p7 = class extends a2.ClonableMixin(l) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
r([m2({ type: Boolean, json: { write: true } })], p7.prototype, "doNotLocateOnRestrictedElements", void 0), r([m2({ type: String, json: { write: true } })], p7.prototype, "url", void 0), p7 = r([a("esri.rest.support.NetworkUrl")], p7);

// node_modules/@arcgis/core/rest/support/RouteParameters.js
var N;
var _a2;
var P = (_a2 = class extends a2.ClonableMixin(l) {
  constructor(t4) {
    super(t4), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.checksum = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t4) {
    return m(N, t4);
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => D.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r5) {
    t4?.length && (e2[r5] = t4.map((t5) => D.toJSON(t5)));
  }
  writePointBarriers(t4, e2, r5) {
    C3(t4, e2, r5);
  }
  writePolygonBarrier(t4, e2, r5) {
    C3(t4, e2, r5);
  }
  writePolylineBarrier(t4, e2, r5) {
    C3(t4, e2, r5);
  }
  readRestrictionAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => w.fromJSON(t5));
  }
  writeRestrictionAttributes(t4, e2, r5) {
    t4?.length && (e2[r5] = t4.map((t5) => w.toJSON(t5)));
  }
  readStartTime(t4, e2) {
    const { startTime: r5 } = e2;
    return null == r5 ? null : "now" === r5 ? "now" : new Date(r5);
  }
  writeStartTime(t4, e2) {
    null != t4 && (e2.startTime = "now" === t4 ? "now" : t4.getTime());
  }
  readStops(t4, e2) {
    return U3(e2.stops);
  }
  writeStops(t4, e2, r5) {
    C3(t4, e2, r5);
  }
}, N = _a2, _a2);
function O2(t4) {
  return t4 && "type" in t4;
}
function J(t4) {
  return t4 && "features" in t4 && "doNotLocateOnRestrictedElements" in t4;
}
function L2(t4) {
  return t4 && "url" in t4;
}
function R3(t4) {
  return t4 && "features" in t4;
}
function U3(t4) {
  return O2(t4) ? l6.fromJSON(t4) : L2(t4) ? p7.fromJSON(t4) : J(t4) ? c12.fromJSON(t4) : R3(t4) ? g.fromJSON(t4) : null;
}
function C3(t4, e2, o7) {
  null != t4 && (e2[o7] = V.isCollection(t4) ? { features: t4.toArray().map((t5) => t5.toJSON()) } : t4.toJSON());
}
r([m2({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], P.prototype, "accumulateAttributes", void 0), r([o2("accumulateAttributes")], P.prototype, "readAccumulateAttributes", null), r([r2("accumulateAttributes")], P.prototype, "writeAccumulateAttributes", null), r([m2(t3)], P.prototype, "apiKey", void 0), r([m2({ json: { write: true } })], P.prototype, "attributeParameterValues", void 0), r([m2({ type: String, json: { write: true } })], P.prototype, "checksum", void 0), r([m2({ type: String, json: { write: true } })], P.prototype, "directionsLanguage", void 0), r([r3(a4)], P.prototype, "directionsLengthUnits", void 0), r([r3(o5)], P.prototype, "directionsOutputType", void 0), r([r3(f4)], P.prototype, "directionsStyleName", void 0), r([r3(U2, { name: "directionsTimeAttributeName", ignoreUnknown: false })], P.prototype, "directionsTimeAttribute", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "findBestSequence", void 0), r([m2({ type: Number, json: { write: true } })], P.prototype, "geometryPrecision", void 0), r([m2({ type: Number, json: { write: true } })], P.prototype, "geometryPrecisionM", void 0), r([m2({ type: Number, json: { write: true } })], P.prototype, "geometryPrecisionZ", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "ignoreInvalidLocations", void 0), r([r3(D, { name: "impedanceAttributeName", ignoreUnknown: false })], P.prototype, "impedanceAttribute", void 0), r([m2({ type: Number, json: { write: true } })], P.prototype, "outputGeometryPrecision", void 0), r([r3(r4)], P.prototype, "outputGeometryPrecisionUnits", void 0), r([r3(l3)], P.prototype, "outputLines", void 0), r([m2({ type: f, json: { name: "outSR", write: true } })], P.prototype, "outSpatialReference", void 0), r([m2({ json: { write: true } })], P.prototype, "overrides", void 0), r([m2({ json: { name: "barriers", write: true } })], P.prototype, "pointBarriers", void 0), r([r2("pointBarriers")], P.prototype, "writePointBarriers", null), r([m2({ json: { write: true } })], P.prototype, "polygonBarriers", void 0), r([r2("polygonBarriers")], P.prototype, "writePolygonBarrier", null), r([m2({ json: { write: true } })], P.prototype, "polylineBarriers", void 0), r([r2("polylineBarriers")], P.prototype, "writePolylineBarrier", null), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "preserveFirstStop", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "preserveLastStop", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "preserveObjectID", void 0), r([m2({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], P.prototype, "restrictionAttributes", void 0), r([o2("restrictionAttributes")], P.prototype, "readRestrictionAttributes", null), r([r2("restrictionAttributes")], P.prototype, "writeRestrictionAttributes", null), r([r3(m6)], P.prototype, "restrictUTurns", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnBarriers", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnDirections", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnPolygonBarriers", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnPolylineBarriers", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnRoutes", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnStops", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedEdges", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedJunctions", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedTurns", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "returnZ", void 0), r([m2({ json: { write: true } })], P.prototype, "startTime", void 0), r([o2("startTime")], P.prototype, "readStartTime", null), r([r2("startTime")], P.prototype, "writeStartTime", null), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "startTimeIsUTC", void 0), r([m2({ json: { write: true } })], P.prototype, "stops", void 0), r([o2("stops")], P.prototype, "readStops", null), r([r2("stops")], P.prototype, "writeStops", null), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "timeWindowsAreUTC", void 0), r([m2({ type: b4, json: { write: true } })], P.prototype, "travelMode", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "useHierarchy", void 0), r([m2({ type: Boolean, json: { write: true } })], P.prototype, "useTimeWindows", void 0), P = N = r([a("esri.rest.support.RouteParameters")], P);

// node_modules/@arcgis/core/layers/RouteLayer.js
function Y(e2) {
  if (!e2.length) return;
  const t4 = e2.toArray(), r5 = t4.map(({ objectId: e3 }) => e3).filter((e3) => null != e3);
  let o7 = Math.max(...r5, 0);
  for (const i6 of t4) null == i6.objectId && (i6.objectId = ++o7);
}
function Z(e2, t4) {
  return !!e2.length && e2.length === t4.length && z2(e2) && z2(t4);
}
function z2(e2) {
  return e2.every(({ objectId: e3 }) => null != e3);
}
function K(e2) {
  return e2.length ? e2 : null;
}
function X(e2) {
  switch (e2) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: X("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: X("esriGeometryPolyline") };
  }
}
function H2(e2) {
  return "layers" in e2;
}
function Q2(e2) {
  return "esri.rest.support.FeatureSet" === e2.declaredClass;
}
function $(e2) {
  return "esri.rest.support.NetworkFeatureSet" === e2.declaredClass;
}
function ee(e2, t4) {
  for (const r5 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r5.objectId);
    e3 && (e3.addedCost = r5.addedCost, e3.barrierType = r5.barrierType, e3.costs = r5.costs, e3.curbApproach = r5.curbApproach, e3.fullEdge = r5.fullEdge, e3.geometry = r5.geometry, e3.name = r5.name, e3.sideOfEdge = r5.sideOfEdge, e3.sourceId = r5.sourceId, e3.sourceOid = r5.sourceOid, e3.status = r5.status, e3.symbol = r5.symbol);
  }
}
function te(e2, t4) {
  for (const r5 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r5.objectId);
    e3 && (e3.barrierType = r5.barrierType, e3.costs = r5.costs, e3.geometry = r5.geometry, e3.name = r5.name, e3.scaleFactor = r5.scaleFactor, e3.symbol = r5.symbol);
  }
}
function re(e2, t4) {
  for (const r5 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r5.objectId);
    e3 && (e3.barrierType = r5.barrierType, e3.costs = r5.costs, e3.geometry = r5.geometry, e3.name = r5.name, e3.scaleFactor = r5.scaleFactor, e3.symbol = r5.symbol);
  }
}
function oe(e2, t4) {
  for (const r5 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r5.objectId);
    e3 && (e3.arriveCurbApproach = r5.arriveCurbApproach, e3.arriveTime = r5.arriveTime, e3.arriveTimeOffset = r5.arriveTimeOffset, e3.cumulativeCosts = r5.cumulativeCosts, e3.cumulativeDistance = r5.cumulativeDistance, e3.cumulativeDuration = r5.cumulativeDuration, e3.curbApproach = r5.curbApproach, e3.departCurbApproach = r5.departCurbApproach, e3.departTime = r5.departTime, e3.departTimeOffset = r5.departTimeOffset, e3.distanceToNetworkInMeters = r5.distanceToNetworkInMeters, e3.geometry = r5.geometry, e3.lateDuration = r5.lateDuration, e3.name = r5.name, e3.navLatency = r5.navLatency, e3.posAlong = r5.posAlong, e3.routeName = r5.routeName, e3.serviceCosts = r5.serviceCosts, e3.serviceDistance = r5.serviceDistance, e3.serviceDuration = r5.serviceDuration, e3.sequence = r5.sequence, e3.sideOfEdge = r5.sideOfEdge, e3.snapX = r5.snapX, e3.snapY = r5.snapY, e3.snapZ = r5.snapZ, e3.sourceId = r5.sourceId, e3.sourceOid = r5.sourceOid, e3.status = r5.status, e3.symbol = r5.symbol, e3.timeWindowEnd = r5.timeWindowEnd, e3.timeWindowStart = r5.timeWindowStart, e3.violations = r5.violations, e3.waitDuration = r5.waitDuration, e3.wait = r5.wait);
  }
}
async function ie(e2) {
  const t4 = f.WGS84;
  return await Q(e2.spatialReference, t4), O(e2, t4);
}
function se(e2, t4) {
  switch (t4) {
    case "seconds":
      return e2 / 60;
    case "hours":
      return 60 * e2;
    case "days":
      return 60 * e2 * 24;
    default:
      return e2;
  }
}
function ne(e2, t4) {
  return "decimal-degrees" === t4 || "points" === t4 || "unknown" === t4 ? e2 : j(e2, t4, "meters");
}
function ae(e2) {
  const { attributes: t4, geometry: r5, popupTemplate: o7, symbol: i6 } = e2.toGraphic().toJSON();
  return { attributes: t4, geometry: r5, popupInfo: o7, symbol: i6 };
}
var le = V.ofType(c);
var ue = V.ofType(c2);
var pe = V.ofType(S2);
var ce = V.ofType(h3);
var me = V.ofType(d2);
var ye = V.ofType(S3);
var fe = class extends p(t2(b2(j2(S(h))))) {
  constructor(e2) {
    super(e2), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.checksum = null, this.defaultSymbols = new c3(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new pe(), this.polygonBarriers = new ce(), this.polylineBarriers = new me(), this.routeInfo = null, this.spatialReference = f.WGS84, this.stops = new ye(), this.type = "route";
    const t4 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(a3(() => this.stops, "change", t4, { sync: true, onListenerAdd: t4 }));
  }
  writeFeatureCollectionWebmap(e2, t4, r5, o7) {
    const i6 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e3) => !!e3), s5 = i6.map((e3, t5) => t5), n5 = "web-map" === o7.origin ? "featureCollection.layers" : "layers";
    e(n5, i6, t4), t4.opacity = this.opacity, t4.visibility = this.visible, t4.visibleLayers = s5;
  }
  readDirectionLines(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionLines", (e3) => c.fromGraphic(e3));
  }
  readDirectionPoints(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionPoints", (e3) => c2.fromGraphic(e3));
  }
  get fullExtent() {
    const e2 = new z({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: f.WGS84 });
    if (null != this.routeInfo?.geometry) return this.routeInfo.geometry.extent ?? e2;
    if (null == this.stops) return e2;
    const t4 = this.stops.filter((e3) => null != e3.geometry);
    if (t4.length < 2) return e2;
    const { spatialReference: r5 } = t4.at(0).geometry;
    if (null == r5) return e2;
    const o7 = t4.toArray().map((e3) => {
      const t5 = e3.geometry;
      return [t5.x, t5.y];
    });
    return new m3({ points: o7, spatialReference: r5 }).extent;
  }
  readMaxScale(e2, t4) {
    const r5 = H2(t4) ? t4.layers : t4.featureCollection?.layers, o7 = r5?.find((e3) => null != e3.layerDefinition.maxScale);
    return o7?.layerDefinition.maxScale ?? 0;
  }
  readMinScale(e2, t4) {
    const r5 = H2(t4) ? t4.layers : t4.featureCollection?.layers, o7 = r5?.find((e3) => null != e3.layerDefinition.minScale);
    return o7?.layerDefinition.minScale ?? 0;
  }
  readPointBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "Barriers", (e3) => S2.fromGraphic(e3));
  }
  readPolygonBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolygonBarriers", (e3) => h3.fromGraphic(e3));
  }
  readPolylineBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolylineBarriers", (e3) => d2.fromGraphic(e3));
  }
  readRouteInfo(e2, t4) {
    return this._getNetworkFeatures(t4, "RouteInfo", (e3) => f5.fromGraphic(e3)).at(0) ?? null;
  }
  readSpatialReference(e2, t4) {
    const r5 = H2(t4) ? t4.layers : t4.featureCollection?.layers;
    if (!r5?.length) return f.WGS84;
    const { layerDefinition: o7, featureSet: i6 } = r5[0], s5 = i6.features[0], n5 = s5?.geometry?.spatialReference ?? i6.spatialReference ?? o7.spatialReference ?? o7.extent.spatialReference ?? U;
    return f.fromJSON(n5);
  }
  readStops(e2, t4) {
    return this._getNetworkFeatures(t4, "Stops", (e3) => S3.fromGraphic(e3), (e3) => this._setStopSymbol(e3));
  }
  get title() {
    return this.routeInfo?.name ?? "Route";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e2) {
    null != e2 ? this._set("url", y(e2, i.getLogger(this))) : this._set("url", s.routeServiceUrl);
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e2)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e2, portalItem: t4 } = this;
    if (!t4) throw new s2("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t4.id) throw new s2("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t4.type) throw new s2("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (!this.routeInfo) throw new s2("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r5 } = t4;
    await r5.signIn(), r5.user || await t4.reload();
    const { itemUrl: o7, itemControl: i6 } = t4;
    if ("admin" !== i6 && "update" !== i6) throw new s2("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const n5 = { messages: [], origin: "portal-item", portal: r5, url: o7 ? I(o7) : void 0, writtenProperties: [] }, a9 = this.write(void 0, n5);
    return t4.extent = await ie(e2), t4.title = this.title, await t4.update({ data: a9 }), t4;
  }
  async saveAs(e2, t4 = {}) {
    if (await this.load(), null == this.routeInfo) throw new s2("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r5 = k.from(e2).clone();
    r5.extent ??= await ie(this.fullExtent), r5.id = null, r5.portal ??= C2.getDefault(), r5.title ??= this.title, r5.type = "Feature Collection", r5.typeKeywords = ["Data", "Feature Collection", E.MULTI_LAYER, "Route Layer"];
    const { portal: o7 } = r5, i6 = { messages: [], origin: "portal-item", portal: o7, url: null, writtenProperties: [] };
    await o7.signIn();
    const n5 = t4?.folder, a9 = this.write(void 0, i6);
    return await o7.user.addItem({ item: r5, folder: n5, data: a9 }), this.portalItem = r5, i2(i6), i6.portalItem = r5, r5;
  }
  async solve(e2, t4) {
    Y(this.stops), Y(this.pointBarriers), Y(this.polylineBarriers), Y(this.polygonBarriers);
    const r5 = e2?.stops ?? this.stops, o7 = e2?.pointBarriers ?? K(this.pointBarriers), n5 = e2?.polylineBarriers ?? K(this.polylineBarriers), a9 = e2?.polygonBarriers ?? K(this.polygonBarriers);
    if (null == r5) throw new s2("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((Q2(r5) || $(r5)) && r5.features.length < 2 || V.isCollection(r5) && r5.length < 2) throw new s2("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (V.isCollection(r5)) for (const i6 of r5) i6.routeName = null;
    const l7 = e2?.apiKey, { checksum: p8, url: c13 } = this, m11 = await this._getServiceDescription(c13, l7, t4), y3 = e2?.travelMode ?? m11.defaultTravelMode, f7 = e2?.accumulateAttributes ?? [];
    y3 && (f7.push(y3.distanceAttributeName), y3.timeAttributeName && f7.push(y3.timeAttributeName));
    const d4 = { accumulateAttributes: f7, checksum: p8, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o7, polylineBarriers: n5, polygonBarriers: a9, preserveObjectID: true, returnBarriers: !!o7, returnDirections: true, returnPolygonBarriers: !!a9, returnPolylineBarriers: !!n5, returnRoutes: true, returnStops: true, stops: r5 }, h4 = P.from(e2 ?? {});
    let w2;
    h4.set(d4);
    try {
      w2 = await l5(c13, h4, t4);
    } catch (S4) {
      throw b(S4) ? S4 : new s2("routelayer:failed-route-request", "the routing request failed", { error: S4 });
    }
    const g2 = this._toRouteLayerSolution(w2);
    return this._isOverridden("title") || (this.title = g2.routeInfo.name ?? "Route"), this._populatePortalFields(g2, m11, h4), g2;
  }
  update(e2) {
    const { checksum: t4, directionLines: r5, directionPoints: o7, pointBarriers: i6, polygonBarriers: s5, polylineBarriers: n5, routeInfo: a9, stops: l7 } = e2;
    Z(l7, this.stops) ? oe(l7, this.stops) : this.set({ stops: l7 }), Z(i6, this.pointBarriers) ? ee(i6, this.pointBarriers) : this.set({ pointBarriers: i6 }), Z(n5, this.polylineBarriers) ? te(n5, this.polylineBarriers) : this.set({ polylineBarriers: n5 }), Z(s5, this.polygonBarriers) ? re(s5, this.polygonBarriers) : this.set({ polygonBarriers: s5 }), this.set({ checksum: t4 }), this._set("directionLines", r5), this._set("directionPoints", o7), this._set("routeInfo", a9), null != a9.geometry && (this.spatialReference = a9.geometry.spatialReference);
  }
  _getNetworkFeatures(e2, t4, s5, n5) {
    const a9 = H2(e2) ? e2.layers : e2.featureCollection?.layers, l7 = a9?.find((e3) => e3.layerDefinition.name === t4);
    if (null == l7) return new V();
    const { layerDefinition: u6, popupInfo: p8, featureSet: c13 } = l7, m11 = u6.drawingInfo.renderer, { features: y3 } = c13, f7 = c13.spatialReference ?? u6.spatialReference ?? u6.extent.spatialReference ?? U, d4 = m11 && o4(m11), h4 = f.fromJSON(f7), w2 = y3.map((e3) => {
      const i6 = d.fromJSON(e3);
      null != i6.geometry && null != e3.geometry && null == e3.geometry.spatialReference && (i6.geometry.spatialReference = h4);
      const n6 = s5(i6);
      return n6.symbol ??= d4?.getSymbol(i6) ?? this._getNetworkSymbol(t4), n6.popupTemplate ??= p8 && q.fromJSON(p8), n6;
    });
    return n5 && w2.some(({ symbol: e3 }) => !e3) && n5(w2), new V(w2);
  }
  _getNetworkSymbol(e2) {
    switch (e2) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e2, t4, r5) {
    if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e2) return this._cachedServiceDescription.serviceDescription;
    const o7 = await d3(e2, t4, r5);
    return this._cachedServiceDescription = { serviceDescription: o7, url: e2 }, o7;
  }
  _setStopSymbol(e2) {
    if (!e2 || !e2.length || !this.defaultSymbols.stops || e2.every(({ symbol: e3 }) => !!e3)) return;
    const { first: t4, last: r5, middle: o7, unlocated: i6, waypoint: s5, break: n5 } = this.defaultSymbols.stops, a9 = e2.map(({ sequence: e3 }) => e3).filter((e3) => null != e3), l7 = e2.length === a9.length;
    if (!this.routeInfo && !l7 || 1 === e2.length) return void e2.forEach((i7, s6) => {
      switch (s6) {
        case 0:
          i7.symbol = t4;
          break;
        case e2.length - 1:
          i7.symbol = r5;
          break;
        default:
          i7.symbol = o7;
      }
    });
    const u6 = Math.min(...a9), p8 = Math.max(...a9);
    for (const c13 of e2) c13.sequence !== u6 ? c13.sequence !== p8 ? this.routeInfo && "ok" !== c13.status && "not-located-on-closest" !== c13.status ? c13.symbol = i6 : "waypoint" !== c13.locationType ? "break" !== c13.locationType ? c13.symbol = o7 : c13.symbol = n5 : c13.symbol = s5 : c13.symbol = r5 : c13.symbol = t4;
  }
  _toRouteLayerSolution(e2) {
    const { checksum: t4, routeResults: r5 } = e2, o7 = r5[0].stops?.map((e3) => S3.fromJSON(e3.toJSON()));
    this._setStopSymbol(o7);
    const i6 = new ye(o7), s5 = new ce(e2.polygonBarriers?.map((e3) => {
      const t5 = h3.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polygonBarriers, t5;
    })), n5 = new me(e2.polylineBarriers?.map((e3) => {
      const t5 = d2.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polylineBarriers, t5;
    })), a9 = new pe(e2.pointBarriers?.map((e3) => {
      const t5 = S2.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.pointBarriers, t5;
    })), l7 = r5[0].route?.toJSON(), u6 = f5.fromJSON(l7);
    u6.symbol = this.defaultSymbols.routeInfo;
    const p8 = new ue(r5[0].directionPoints?.features.map((e3) => {
      const t5 = c2.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionPoints, t5;
    }));
    return { checksum: t4, directionLines: new le(r5[0].directionLines?.features.map((e3) => {
      const t5 = c.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionLines, t5;
    })), directionPoints: p8, pointBarriers: a9, polygonBarriers: s5, polylineBarriers: n5, routeInfo: u6, stops: i6 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", c.fields, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", c2.fields, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e2, t4, r5, o7, i6, s5) {
    if (!e2?.length) return null;
    const n5 = this.spatialReference.toJSON(), { fullExtent: a9, maxScale: l7, minScale: u6 } = this;
    return { featureSet: { features: e2.toArray().map((e3) => ae(e3)), geometryType: r5, spatialReference: n5 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: null != t4 ? t4.toJSON() : X(r5) } }, extent: a9.toJSON(), fields: o7, geometryType: r5, hasM: false, hasZ: false, maxScale: l7, minScale: u6, name: i6, objectIdField: "ObjectID", spatialReference: n5, title: s5, type: "Feature Layer", typeIdField: "" } };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", S2.fields, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", h3.fields, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", d2.fields, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new V([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", f5.fields, "RouteInfo", "Route Details");
  }
  _writeStops() {
    const e2 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", S3.fields, "Stops", "Stops");
    if (null == e2) return null;
    const { stops: t4 } = this.defaultSymbols, r5 = t4?.first?.toJSON(), o7 = t4?.middle?.toJSON(), i6 = t4?.last?.toJSON();
    return e2.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o7, uniqueValueInfos: [{ value: "1", symbol: r5, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i6, label: "Last Stop" }] }, e2;
  }
  _populatePortalFields(e2, t4, r5) {
    const o7 = t4.networkDataset?.networkAttributes, i6 = o7?.filter(({ usageType: e3 }) => "cost" === e3) ?? [], a9 = r5.travelMode ?? t4.defaultTravelMode;
    if (null == a9) return void i.getLogger(this).warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
    const { timeAttributeName: l7, distanceAttributeName: u6 } = a9, p8 = i6.find(({ name: e3 }) => e3 === l7), c13 = i6.find(({ name: e3 }) => e3 === u6), m11 = r5.travelMode?.impedanceAttributeName ?? r5.impedanceAttribute ?? t4.impedance, y3 = p8?.units, f7 = c13?.units;
    if (!y3 || !f7) throw new s2("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
    const d4 = r5.directionsLanguage ?? t4.directionsLanguage, h4 = r5.accumulateAttributes ?? t4.accumulateAttributeNames ?? [], w2 = new Set(i6.filter(({ name: e3 }) => e3 === l7 || e3 === u6 || e3 === m11 || null != e3 && h4.includes(e3)).map(({ name: e3 }) => e3)), g2 = (e3) => {
      for (const t5 in e3) w2.has(t5) || delete e3[t5];
    };
    for (const s5 of e2.pointBarriers) null != s5.costs && (s5.addedCost = s5.costs[m11] ?? 0, g2(s5.costs));
    for (const s5 of e2.polygonBarriers) null != s5.costs && (s5.scaleFactor = s5.costs[m11] ?? 1, g2(s5.costs));
    for (const s5 of e2.polylineBarriers) null != s5.costs && (s5.scaleFactor = s5.costs[m11] ?? 1, g2(s5.costs));
    const { routeInfo: S4 } = e2, { findBestSequence: b5, preserveFirstStop: v2, preserveLastStop: B, startTimeIsUTC: P2, timeWindowsAreUTC: I2 } = r5;
    S4.analysisSettings = new a6({ accumulateAttributes: h4, directionsLanguage: d4, findBestSequence: b5, preserveFirstStop: v2, preserveLastStop: B, startTimeIsUTC: P2, timeWindowsAreUTC: I2, travelMode: a9 }), S4.totalDuration = se(S4.totalCosts?.[l7] ?? 0, y3), S4.totalDistance = ne(S4.totalCosts?.[u6] ?? 0, f7), S4.totalLateDuration = se(S4.totalViolations?.[l7] ?? 0, y3), S4.totalWaitDuration = se(S4.totalWait?.[l7] ?? 0, y3), null != S4.totalCosts && g2(S4.totalCosts), null != S4.totalViolations && g2(S4.totalViolations), null != S4.totalWait && g2(S4.totalWait);
    for (const s5 of e2.stops) null != s5.serviceCosts && (s5.serviceDuration = se(s5.serviceCosts[l7] ?? 0, y3), s5.serviceDistance = ne(s5.serviceCosts[u6] ?? 0, f7), g2(s5.serviceCosts)), null != s5.cumulativeCosts && (s5.cumulativeDuration = se(s5.cumulativeCosts[l7] ?? 0, y3), s5.cumulativeDistance = ne(s5.cumulativeCosts[u6] ?? 0, f7), g2(s5.cumulativeCosts)), null != s5.violations && (s5.lateDuration = se(s5.violations[l7] ?? 0, y3), g2(s5.violations)), null != s5.wait && (s5.waitDuration = se(s5.wait[l7] ?? 0, y3), g2(s5.wait));
  }
};
r([m2({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], fe.prototype, "_featureCollection", void 0), r([r2(["web-map", "portal-item"], "_featureCollection")], fe.prototype, "writeFeatureCollectionWebmap", null), r([m2({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], fe.prototype, "_type", void 0), r([m2({ type: String })], fe.prototype, "checksum", void 0), r([m2({ nonNullable: true, type: c3 })], fe.prototype, "defaultSymbols", void 0), r([m2({ readOnly: true })], fe.prototype, "directionLines", void 0), r([o2(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], fe.prototype, "readDirectionLines", null), r([m2({ readOnly: true })], fe.prototype, "directionPoints", void 0), r([o2(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], fe.prototype, "readDirectionPoints", null), r([m2({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], fe.prototype, "featureCollectionType", void 0), r([m2({ readOnly: true })], fe.prototype, "fullExtent", null), r([m2({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], fe.prototype, "legendEnabled", void 0), r([m2({ type: ["show", "hide"] })], fe.prototype, "listMode", void 0), r([m2({ type: Number, nonNullable: true, json: { write: false } })], fe.prototype, "maxScale", void 0), r([o2(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], fe.prototype, "readMaxScale", null), r([m2({ type: Number, nonNullable: true, json: { write: false } })], fe.prototype, "minScale", void 0), r([o2(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], fe.prototype, "readMinScale", null), r([m2({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], fe.prototype, "operationalLayerType", void 0), r([m2({ nonNullable: true, type: V.ofType(S2) })], fe.prototype, "pointBarriers", void 0), r([o2(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], fe.prototype, "readPointBarriers", null), r([m2({ nonNullable: true, type: V.ofType(h3) })], fe.prototype, "polygonBarriers", void 0), r([o2(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], fe.prototype, "readPolygonBarriers", null), r([m2({ nonNullable: true, type: V.ofType(d2) })], fe.prototype, "polylineBarriers", void 0), r([o2(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], fe.prototype, "readPolylineBarriers", null), r([m2({ readOnly: true })], fe.prototype, "routeInfo", void 0), r([o2(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], fe.prototype, "readRouteInfo", null), r([m2({ type: f })], fe.prototype, "spatialReference", void 0), r([o2(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], fe.prototype, "readSpatialReference", null), r([m2({ nonNullable: true, type: V.ofType(S3) })], fe.prototype, "stops", void 0), r([o2(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], fe.prototype, "readStops", null), r([m2()], fe.prototype, "title", null), r([m2({ readOnly: true, json: { read: false } })], fe.prototype, "type", void 0), r([m2()], fe.prototype, "url", null), fe = r([a("esri.layers.RouteLayer")], fe);
var de = fe;
export {
  de as default
};
//# sourceMappingURL=RouteLayer-BBDT763T.js.map
