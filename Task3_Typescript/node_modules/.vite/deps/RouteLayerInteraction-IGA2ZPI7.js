import {
  t as t3
} from "./chunk-VVMAWXMO.js";
import {
  E as E4,
  P,
  r as r4
} from "./chunk-HUIZDFYQ.js";
import {
  g as g2,
  g2 as g3
} from "./chunk-RPT2LHBU.js";
import {
  n as n6,
  p as p5,
  s as s5
} from "./chunk-PQSYYE6U.js";
import "./chunk-EQXUGRYF.js";
import {
  r as r7
} from "./chunk-7VEHC2ZL.js";
import {
  r as r8
} from "./chunk-QK2WX3FC.js";
import {
  r as r5
} from "./chunk-24K5NVHX.js";
import {
  r as r6
} from "./chunk-KCZYWZT4.js";
import "./chunk-EOS5YLWS.js";
import {
  r as r3
} from "./chunk-ITMEGD3M.js";
import {
  Z,
  f as f3,
  l as l5,
  t,
  z
} from "./chunk-6VC2SGU3.js";
import {
  c as c6,
  n as n5,
  p as p4,
  t as t2
} from "./chunk-R4OUYMNP.js";
import {
  p as p3
} from "./chunk-YIOJR4CO.js";
import "./chunk-U6CQ42B3.js";
import "./chunk-HPOHIVBI.js";
import "./chunk-5TKMN7TZ.js";
import {
  E as E3,
  N,
  g
} from "./chunk-LYH5EAFA.js";
import {
  E,
  E2,
  h as h5,
  p as p2
} from "./chunk-ENM5QFON.js";
import {
  R,
  b as b2,
  q as q2,
  v as v3
} from "./chunk-2H2JCT45.js";
import {
  a as a4,
  l as l4
} from "./chunk-NZUIJLHR.js";
import {
  l as l3,
  m as m4
} from "./chunk-4HGNIREA.js";
import {
  S,
  S2,
  d as d5,
  h as h3
} from "./chunk-PC3GTHZ5.js";
import {
  c as c3
} from "./chunk-2XBUTZI3.js";
import "./chunk-LW7J7Z4M.js";
import {
  v as v2
} from "./chunk-37WACOMS.js";
import "./chunk-3GCFO25G.js";
import {
  n as n3
} from "./chunk-3MVOHROR.js";
import "./chunk-RVXIJHL6.js";
import {
  f as f2,
  j as j3,
  l as l2,
  v
} from "./chunk-2JAL6FAS.js";
import "./chunk-BGR5EVZD.js";
import "./chunk-PBLU5SUP.js";
import {
  e as e3
} from "./chunk-GYAK76KG.js";
import {
  D,
  J,
  O as O2,
  p
} from "./chunk-RTDWTAVK.js";
import "./chunk-QLJ6JQFC.js";
import "./chunk-TNKA4BMD.js";
import "./chunk-VKKELZ6R.js";
import "./chunk-3LL6ALVC.js";
import "./chunk-NZPABYQQ.js";
import "./chunk-CCHJ3WNU.js";
import {
  n as n4
} from "./chunk-HFUGSKPL.js";
import {
  c as c4
} from "./chunk-BUA5NESM.js";
import {
  _
} from "./chunk-SHYE33QH.js";
import "./chunk-LTMF2W73.js";
import {
  c as c5
} from "./chunk-5Y3EUPZN.js";
import {
  h as h4
} from "./chunk-YIXK32VF.js";
import "./chunk-XFKS4JQP.js";
import "./chunk-DRAQJS2F.js";
import "./chunk-VNTS5E5O.js";
import {
  j as j2,
  o as o2,
  q
} from "./chunk-TMFB3DKM.js";
import "./chunk-LBC3MAJX.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-XLF2NMGX.js";
import "./chunk-X5GD6LFD.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-KSRBNZJ2.js";
import "./chunk-6WL2SHX6.js";
import "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import {
  K,
  L,
  O,
  Q,
  k
} from "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-ZAISHGSP.js";
import "./chunk-KHRHKYU2.js";
import "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import {
  a as a3,
  d as d4,
  x
} from "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import {
  m as m3,
  u as u3
} from "./chunk-HNQNVI5C.js";
import {
  m as m2
} from "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  d as d3
} from "./chunk-HPGYEHVI.js";
import {
  w as w2
} from "./chunk-YBJ5GVXQ.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import {
  n as n2
} from "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import {
  e as e2
} from "./chunk-VNTEV3V4.js";
import {
  y
} from "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import {
  o
} from "./chunk-YIV2QKTZ.js";
import {
  U,
  a as a2,
  f,
  h as h2,
  j,
  l,
  w
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import {
  ce,
  s as s3,
  s2 as s4
} from "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  b,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  c,
  c3 as c2,
  d as d2,
  e2 as e,
  h,
  r as r2,
  s as s2,
  u2 as u,
  u3 as u2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  d,
  n
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/3d/interactive/editingTools/reshape/isSupportedObject.js
function e4(t4) {
  return o3(t4).result;
}
function o3(e6) {
  if (e6.graphic && "graphics" !== e6.graphic.layer?.type) return { result: P.GRAPHICS_LAYER_MISSING };
  if (!e6.operations) return { result: P.GEOMETRY_MISSING };
  if (v(e6.elevationInfo)) return { result: P.ELEVATION_MODE_UNSUPPORTED };
  const o6 = e6.operations.data.type, i4 = e6.operations.data.geometry;
  return "point" === o6 || "mesh" === o6 || "polyline" === o6 || "polygon" === o6 ? { result: P.SUPPORTED, geometry: i4 } : { result: P.GEOMETRY_TYPE_UNSUPPORTED };
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transform/isSupportedGraphic.js
function r9(r11) {
  if ("graphics" !== r11.layer?.type) return P.GRAPHICS_LAYER_MISSING;
  if (null == r11.geometry) return P.GEOMETRY_MISSING;
  switch (r11.geometry.type) {
    case "point":
      break;
    case "polygon":
    case "polyline":
    case "multipoint":
    case "extent":
    case "mesh":
      return P.SUPPORTED;
    default:
      return P.GEOMETRY_TYPE_UNSUPPORTED;
  }
  const s8 = null != r11.symbol && "point-3d" === r11.symbol.type && r11.symbol.symbolLayers;
  if (!s8 || !s8.some((e6) => "object" === e6.type)) return P.SYMBOL_TYPE_UNSUPPORTED;
  return "on-the-ground" !== l2(r11) && f2(r11) ? P.ELEVATION_MODE_UNSUPPORTED : P.SUPPORTED;
}

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingLayerSource.js
var i2 = class extends b {
  constructor(o6) {
    super(o6), this.layer = null, this.enabled = true, this.updating = false, this.availability = 1, this.sublayerSources = new V();
  }
};
r([m({ constructOnly: true })], i2.prototype, "layer", void 0), r([m()], i2.prototype, "enabled", void 0), r([m()], i2.prototype, "updating", void 0), r([m()], i2.prototype, "availability", void 0), r([m()], i2.prototype, "sublayerSources", void 0), i2 = r([a("esri.views.interactive.snapping.FeatureSnappingLayerSource")], i2);

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOptions.js
var u4 = class extends b {
  constructor(e6) {
    super(e6), this.enabled = false, this.enabledToggled = false, this.forceDisabled = false, this.selfEnabled = true, this.featureEnabled = true, this.gridEnabled = false, this.attributeRulesEnabled = false, this.featureSources = new V(), this.distance = p3.distance, this.touchSensitivityMultiplier = p3.touchSensitivityMultiplier;
  }
  get effectiveEnabled() {
    return !this.forceDisabled && (this.enabledToggled ? !this.enabled : this.enabled);
  }
  get effectiveGridEnabled() {
    return this.effectiveEnabled && this.gridEnabled;
  }
  get effectiveSelfEnabled() {
    return this.effectiveEnabled && this.selfEnabled;
  }
  get effectiveFeatureEnabled() {
    return this.effectiveEnabled && this.featureEnabled;
  }
  get _effectiveFeatureSources() {
    const e6 = this.featureSources;
    e6.some(c7) && i.getLogger(this).warnOnce("Do not configure SubtypeGroupLayer sources in SnappingOptions.featureSources directly. Create a FeatureSnappingLayerSource for each SubtypeSublayer.");
    const t4 = e6.filter(d6), s8 = this._get("_effectiveFeatureSources")?.filter(c7) ?? new V();
    for (const r11 of t4) {
      const e7 = s8.find((e8) => e8.layer === r11.layer.parent);
      if (e7) e7.sublayerSources.includes(r11) || e7.sublayerSources.add(r11);
      else if (r11.layer.parent) {
        const e8 = new i2({ layer: r11.layer.parent });
        e8.sublayerSources.add(r11), s8.add(e8);
      }
    }
    for (const r11 of s8) {
      const e7 = r11.sublayerSources.filter((e8) => !t4.includes(e8));
      r11.sublayerSources.removeMany(e7);
    }
    s8.removeMany(s8.filter((e7) => 0 === e7.sublayerSources.length));
    const a8 = e6.filter(p6), l7 = this._get("_effectiveFeatureSources") ?? new V(), { added: u7, removed: f5 } = d(l7.toArray(), [...a8, ...s8]);
    return l7.removeMany(f5), l7.addMany(u7), l7;
  }
};
function c7(e6) {
  return "subtype-group" === e6.layer.type;
}
function p6(e6) {
  return "subtype-group" !== e6.layer.type;
}
function d6(e6) {
  return "subtype-sublayer" === e6.layer.type;
}
r([m()], u4.prototype, "enabled", void 0), r([m()], u4.prototype, "enabledToggled", void 0), r([m()], u4.prototype, "forceDisabled", void 0), r([m()], u4.prototype, "selfEnabled", void 0), r([m()], u4.prototype, "featureEnabled", void 0), r([m()], u4.prototype, "gridEnabled", void 0), r([m()], u4.prototype, "attributeRulesEnabled", void 0), r([m({ type: V.ofType(i2) })], u4.prototype, "featureSources", void 0), r([m()], u4.prototype, "distance", void 0), r([m()], u4.prototype, "touchSensitivityMultiplier", void 0), r([m({ readOnly: true })], u4.prototype, "effectiveEnabled", null), r([m({ readOnly: true })], u4.prototype, "effectiveGridEnabled", null), r([m({ readOnly: true })], u4.prototype, "effectiveSelfEnabled", null), r([m({ readOnly: true })], u4.prototype, "effectiveFeatureEnabled", null), r([m({ readOnly: true })], u4.prototype, "_effectiveFeatureSources", null), u4 = r([a("esri.views.interactive.snapping.SnappingOptions")], u4);

// node_modules/@arcgis/core/views/support/geodesicLengthMeasurementUtils.js
function m5(e6) {
  const { spatialReference: t4 } = e6;
  return t(t4, j4, h6, e6);
}
function f4(e6, t4) {
  if (!s3(e6.spatialReference, t4.spatialReference)) return null;
  const { spatialReference: r11 } = e6;
  return x2[0] = e6.x, x2[1] = e6.y, x2[2] = e6.hasZ ? e6.z : 0, U2[0] = t4.x, U2[1] = t4.y, U2[2] = t4.hasZ ? t4.z : 0, p7(x2, U2, r11);
}
function p7(e6, t4, r11) {
  return t(r11, y2, d7, e6, t4, r11);
}
var l6 = { geodesicLength: m5, geodesicDistanceBetweenPoints: f4, geodesicDistance: p7 };
async function g4() {
  return await m4(), l6;
}
function y2(t4, r11, n11) {
  return a4(q2(w3, t4, r11, n11).distance, "meters");
}
function d7(t4, r11, n11) {
  return a4(l3(R2(t4, r11, n11), { unit: "meters" }), "meters");
}
function j4(t4) {
  return a4(R([t4], "meters")[0], "meters");
}
function h6(t4) {
  return a4(l3(t4, { unit: "meters" }), "meters");
}
function R2(e6, t4, n11) {
  return new y({ spatialReference: n11, paths: [[[...e6], [...t4]]] });
}
var w3 = new b2();
var x2 = n2();
var U2 = n2();

// node_modules/@arcgis/core/views/interactive/snapping/SnappingManager.js
var x3 = class extends o.EventedMixin(b) {
  constructor(e6) {
    super(e6), this.options = new u4(), this._engineCache = /* @__PURE__ */ new Map(), this._loadTask = null, this._engines = [], this._currentMainCandidate = null, this._currentOtherActiveCandidates = [], this._currentSnappedType = b3.MAIN;
  }
  initialize() {
    this.addHandles([l(() => {
      const { distance: e6, touchSensitivityMultiplier: t4, effectiveSelfEnabled: n11, effectiveFeatureEnabled: i4, effectiveGridEnabled: s8 } = this.options;
      return { selfEnabled: n11, featureEnabled: i4, gridEnabled: "2d" === this.view.type && s8, viewReady: this.view.ready, viewSpatialReference: this.view.spatialReference, distance: e6, touchSensitivityMultiplier: t4 };
    }, (e6, t4) => {
      t4 && (this.doneSnapping(), this.emit("changed")), this._loadTask?.abort(), this._loadTask = d3((n11) => this._updateEngines(e6, t4, n11));
    }, w), l(() => this.options, (e6) => {
      for (const t4 of this._engines) t4.options = e6;
    }, U)]);
  }
  destroy() {
    this._loadTask?.abort(), this._destroyEngines();
  }
  get updating() {
    return this._engines.some((e6) => e6.updating) || !this._loadTask?.finished;
  }
  _destroyEngines() {
    this._engineCache.forEach((e6) => e6.destroy()), this._engineCache.clear(), this._engines = [];
  }
  async _updateEngines(e6, t4, n11) {
    if (!e6.viewReady) return void this._destroyEngines();
    t4?.viewSpatialReference !== e6.viewSpatialReference && this._destroyEngines();
    const i4 = this._engineCache, s8 = await Promise.allSettled([e6.featureEnabled && !i4.has("feature") ? this._createFeatureSnappingEngine(n11) : void 0, e6.selfEnabled && !i4.has("self") ? this._createSelfSnappingEngine(n11) : void 0, e6.gridEnabled && !i4.has("grid") ? this._createGridSnappingEngine(n11) : void 0]);
    if (n11.aborted) for (const a8 of s8) "fulfilled" === a8.status && a8.value?.engine.destroy();
    else {
      for (const e7 of s8) "fulfilled" === e7.status && e7.value && i4.set(e7.value.type, e7.value.engine);
      this._engines = Array.from(i4.values());
    }
  }
  async _createSelfSnappingEngine(e6) {
    const [{ SelfSnappingEngine: t4 }, n11] = await Promise.all([import("./SelfSnappingEngine-NC6HLM6P.js"), g4()]);
    return s2(e6), { type: "self", engine: new t4({ view: this.view, options: this.options, geodesicLengthMeasurementUtils: n11 }) };
  }
  async _createGridSnappingEngine(e6) {
    const { view: t4 } = this;
    if ("2d" !== t4.type) return;
    const { GridSnappingEngine: n11 } = await import("./GridSnappingEngine-4QYP5DXR.js");
    return s2(e6), { type: "grid", engine: new n11({ view: t4, options: this.options }) };
  }
  async _createFeatureSnappingEngine(e6) {
    const { FeatureSnappingEngine: t4 } = await import("./FeatureSnappingEngine-KYLVEV7H.js");
    s2(e6);
    const { view: n11, options: i4 } = this, { spatialReference: a8 } = n11;
    return { type: "feature", engine: new t4({ view: n11, options: i4, spatialReference: a8 }) };
  }
  get _squaredMouseProximityThreshold() {
    return this.options.distance * this.options.distance;
  }
  get _squaredTouchProximityThreshold() {
    const { distance: e6, touchSensitivityMultiplier: t4 } = this.options, n11 = e6 * t4;
    return n11 * n11;
  }
  snap(e6) {
    return k2(e6) ? this._snapMultiPoint(e6) : this._snapSinglePoint(e6);
  }
  update(e6) {
    const { point: t4, context: n11 } = e6;
    this._removeVisualization();
    const i4 = this._currentMainCandidate;
    if (null == i4) return t4;
    const s8 = this._selectUpdateInput(e6);
    if (null == s8) return t4;
    const { spatialReference: a8 } = n11, r11 = O(s8, a8);
    if (null == r11) return t4;
    const { view: o6 } = this, { elevationInfo: p9, visualizer: d9 } = n11, c9 = [], l7 = E(r11, o6, p9), u7 = i4.constraint.closestTo(l7);
    if (!this._arePointsWithinScreenThreshold(l7, u7, n11) || !L2(i4, n11.drawConstraints)) return this._resetSnappingState(), t4;
    i4.targetPoint = p2(u7), c9.push(...i4.hints);
    for (const h8 of this._currentOtherActiveCandidates) L2(h8, n11.drawConstraints) && (h8.targetPoint = p2(u7), c9.push(...h8.hints));
    return null != d9 && this.addHandles(d9.draw(c9, { spatialReference: a8, elevationInfo: H(n11), view: o6, selfSnappingZ: n11.selfSnappingZ }), z2), h5(u7, o6, t4, n11);
  }
  doneSnapping() {
    this._removeVisualization(), this._resetSnappingState();
  }
  _selectUpdateInput({ point: e6, scenePoint: t4 }) {
    switch (this._currentSnappedType) {
      case b3.MAIN:
        return e6;
      case b3.SCENE:
        return t4;
    }
  }
  _resetSnappingState() {
    this._currentMainCandidate = null, this._currentOtherActiveCandidates = [], this._currentSnappedType = b3.MAIN;
  }
  _removeVisualization() {
    this.removeHandles(z2);
  }
  async _snapSinglePoint({ point: e6, context: t4, signal: n11 }) {
    const { view: i4 } = this, { elevationInfo: s8 } = t4, a8 = E(e6, i4, s8), r11 = await this._fetchCandidates(a8, E2.ALL, t4, n11);
    return this._createSnapResult(a8, b3.MAIN, r11, i4, e6, t4, n11);
  }
  async _snapMultiPoint({ point: e6, scenePoint: t4, context: n11, signal: i4 }) {
    const { view: s8 } = this, { coordinateHelper: a8, elevationInfo: r11, spatialReference: o6 } = n11;
    await Q(t4.spatialReference, o6);
    const p9 = O(t4, o6), d9 = E(p9, s8, r11), c9 = await this._fetchCandidates(d9, E2.FEATURE, n11, i4);
    if (c9.length > 0) {
      const e7 = await this._fetchCandidates(d9, E2.SELF, n11, i4);
      return this._createSnapResult(d9, b3.SCENE, [...c9, ...e7], s8, p9, n11, i4);
    }
    const u7 = E(e6, s8, r11), g7 = await this._fetchCandidates(u7, E2.SELF, n11, i4);
    return this._createSnapResult(u7, b3.MAIN, g7, s8, { z: a8.hasZ() && e6.hasZ ? e6.z ?? 0 : void 0, m: a8.hasM() && e6.hasM ? e6.m ?? 0 : void 0 }, n11, i4);
  }
  async _fetchCandidates(e6, t4, n11, i4) {
    return (await Promise.all(this._engines.map((s8) => s8.fetchCandidates(e6, t4, n11, i4)))).flat();
  }
  _createSnapResult(e6, t4, n11, i4, s8, r11, o6) {
    return { get valid() {
      return !c2(o6);
    }, apply: () => {
      const { spatialReference: a8 } = r11, { snappedPoint: o7, hints: p9 } = this._processCandidates(e6, t4, n11, r11);
      return this._removeVisualization(), null != r11.visualizer && this.addHandles(r11.visualizer.draw(p9, { spatialReference: a8, elevationInfo: j3, view: i4, selfSnappingZ: r11.selfSnappingZ }), z2), h5(o7, i4, s8, r11);
    } };
  }
  _processCandidates(e6, t4, n11, i4) {
    if (n11.length < 1) return this.doneSnapping(), { snappedPoint: e6, hints: [] };
    this._currentSnappedType !== t4 && this._resetSnappingState(), E3(e6, n11);
    const s8 = this._currentMainCandidate;
    if (null != s8) {
      const a8 = N2(s8, n11);
      if (a8 >= 0) {
        if (!(n11[a8] instanceof r7)) return this._intersectWithOtherCandidates(a8, n11, e6, t4, i4);
        if (this._arePointsWithinScreenThreshold(e6, s8.targetPoint, i4)) return this._updateSnappingCandidate(s8, t4, n11, i4);
      }
    }
    return this._intersectWithOtherCandidates(0, n11, e6, t4, i4);
  }
  _intersectWithOtherCandidates(e6, t4, n11, i4, s8) {
    const { coordinateHelper: a8 } = s8, r11 = t4[e6], o6 = [];
    for (let p9 = 0; p9 < t4.length; ++p9) {
      if (p9 === e6) continue;
      const i5 = t4[p9], s9 = r11.constraint.intersect(i5.constraint);
      if (s9) for (const e7 of s9.closestPoints(r11.targetPoint)) o6.push([new r7(p2(e7), r11, i5, i5.isDraped), this._squaredScreenDistance(n11, e7, a8)]);
    }
    return o6.length > 0 && (o6.sort((e7, t5) => e7[1] - t5[1]), o6[0][1] < this._squaredPointProximityThreshold(s8.pointer)) ? this._updateSnappingCandidate(o6[0][0], i4, t4, s8) : L2(r11, s8.drawConstraints) ? this._updateSnappingCandidate(r11, i4, t4, s8) : { snappedPoint: n11, hints: [] };
  }
  _updateSnappingCandidate(e6, t4, n11, i4) {
    this.doneSnapping(), this._currentMainCandidate = e6, this._currentSnappedType = t4;
    const s8 = this._currentMainCandidate.targetPoint, a8 = [];
    a8.push(...e6.hints);
    for (const r11 of n11) {
      if (e6 instanceof r7) {
        if (r11.constraint.equals(e6.first.constraint) || r11.constraint.equals(e6.second.constraint)) continue;
      } else if (r11.constraint.equals(e6.constraint)) continue;
      const t5 = r11.constraint.closestTo(s8);
      this._squaredScreenDistance(t5, s8, i4.coordinateHelper) < U3() && (r11.targetPoint = s8, this._currentOtherActiveCandidates.push(r11), a8.push(...r11.hints));
    }
    return { snappedPoint: s8, hints: a8 };
  }
  _squaredPointProximityThreshold(e6) {
    return "touch" === e6 ? this._squaredTouchProximityThreshold : this._squaredMouseProximityThreshold;
  }
  _arePointsWithinScreenThreshold(e6, t4, n11) {
    return this._squaredScreenDistance(e6, t4, n11.coordinateHelper) < this._squaredPointProximityThreshold(n11.pointer);
  }
  _squaredScreenDistance(e6, t4, n11) {
    return g(this._toScreen(e6, n11), this._toScreen(t4, n11));
  }
  _toScreen(e6, t4) {
    return s5(e6, t4.spatialReference, j3, this.view);
  }
  get test() {
  }
};
var b3;
r([m({ constructOnly: true })], x3.prototype, "view", void 0), r([m()], x3.prototype, "options", void 0), r([m({ readOnly: true })], x3.prototype, "updating", null), r([m()], x3.prototype, "_loadTask", void 0), r([m()], x3.prototype, "_engines", void 0), r([m()], x3.prototype, "_squaredMouseProximityThreshold", null), r([m()], x3.prototype, "_squaredTouchProximityThreshold", null), x3 = r([a("esri.views.interactive.snapping.SnappingManager")], x3), function(e6) {
  e6[e6.MAIN = 0] = "MAIN", e6[e6.SCENE = 1] = "SCENE";
}(b3 || (b3 = {}));
var z2 = "visualization-handle";
function U3() {
  return p3.satisfiesConstraintScreenThreshold * p3.satisfiesConstraintScreenThreshold;
}
function L2(e6, t4) {
  return !t4 || null == t4.direction && null == t4.distance || !(e6 instanceof r5 || e6 instanceof r6 || e6 instanceof r8 || e6 instanceof g2 || e6 instanceof g3) && (!(e6 instanceof n6) || null == t4.direction && e6.selfSnappingType === p5.LastVertex);
}
function N2(e6, t4) {
  return e6 instanceof r7 ? O3(t4, e6.first) >= 0 && O3(t4, e6.second) >= 0 ? 0 : -1 : O3(t4, e6);
}
function O3(e6, t4) {
  let n11 = -1;
  for (let i4 = 0; i4 < e6.length; ++i4) if (t4.constraint.equals(e6[i4].constraint)) {
    n11 = i4;
    break;
  }
  return n11;
}
function k2(e6) {
  return null != e6.scenePoint;
}
function H({ coordinateHelper: e6, elevationInfo: t4 }) {
  return e6.hasZ() ? j3 : t4;
}

// node_modules/@arcgis/core/views/support/euclideanAreaMeasurementUtils.js
function g5(t4, o6 = k3()) {
  return h7(t4, o6);
}
function j5(t4, o6 = k3()) {
  return h7(t4, o6, false);
}
function h7(r11, g7, j6 = r11.hasZ) {
  const h8 = l5(r11.spatialReference), k5 = ce(h8);
  if (null == k5) return null;
  const b6 = (t4, o6) => !(o6.length < 2) && (o2(t4, o6[0], o6[1], j6 && o6[2] || 0), true);
  let v4 = 0;
  for (const t4 of r11.rings) {
    const o6 = t4.length;
    if (o6 < 3) continue;
    const { positionsWorldCoords: a8 } = g7;
    for (; a8.length < o6; ) a8.push(n2());
    const j7 = y3, k6 = o2(d8, 0, 0, 0), x4 = 1 / o6;
    for (let n11 = 0; n11 < o6; n11++) {
      if (!b6(j7, t4[n11])) return null;
      if (!n3(j7, r11.spatialReference, a8[n11], h8)) return null;
      q(k6, k6, a8[n11], x4);
    }
    const C = p(a8[0], a8[1], k6, D());
    if (0 === j2(O2(C))) continue;
    for (let t5 = 0; t5 < o6; t5++) J(C, k6, a8[t5], a8[t5]);
    const R3 = U4(a8);
    for (let t5 = 0; t5 < R3.length; t5 += 3) v4 += v2(a8[R3[t5]], a8[R3[t5 + 1]], a8[R3[t5 + 2]]);
  }
  return l4(v4, k5);
}
var y3 = n2();
var d8 = n2();
function k3() {
  return { positionsWorldCoords: [] };
}
function U4(t4) {
  return e3(b4(t4), [], 2);
}
function b4(t4) {
  const o6 = new Float64Array(2 * t4.length);
  for (let r11 = 0; r11 < t4.length; ++r11) {
    const n11 = t4[r11], e6 = 2 * r11;
    o6[e6] = n11[0], o6[e6 + 1] = n11[1];
  }
  return o6;
}

// node_modules/@arcgis/core/views/support/geodesicAreaMeasurementUtils.js
var s6 = (e6) => ({ geodesicArea(r11) {
  const { spatialReference: s8 } = r11;
  return t(s8, n7, (r12) => a5(e6, r12), r11);
} });
async function o4() {
  const e6 = await import("./geometryEngine-RYSJJDJO.js");
  return s6(e6);
}
function n7(t4) {
  return l4(Math.abs(v3([t4], "square-meters")[0]), "square-meters");
}
function a5(r11, t4) {
  try {
    return l4(Math.abs(r11.geodesicArea(t4, "square-meters")), "square-meters");
  } catch (s8) {
    return null;
  }
}

// node_modules/@arcgis/core/views/support/automaticAreaMeasurementUtils.js
var n8 = (o6) => ({ autoAreaByElevationMode(n11, a8, u7 = k3()) {
  if ("on-the-ground" === a8) {
    const e6 = o6.geodesicArea(n11);
    return null != e6 ? e6 : j5(n11, u7);
  }
  return g5(n11, u7);
}, autoArea2D(t4, r11 = k3()) {
  return this.autoAreaByElevationMode(t4, "on-the-ground", r11);
} });
var a6 = null;
async function u5() {
  return a6 || (a6 = n8(await o4())), a6;
}

// node_modules/@arcgis/core/views/support/automaticLengthMeasurementUtils.js
function s7(e6) {
  return { autoLength2D: (t4) => e6.geodesicLength(t4) ?? f3(t4), autoDistanceBetweenPoints2D: (t4, i4) => e6.geodesicDistanceBetweenPoints(t4, i4) ?? z(t4, i4), autoDistance2D: (n11, i4, o6) => (r10[0] = n11[0], r10[1] = n11[1], r10[2] = 3 === n11.length ? n11[2] : 0, a7[0] = i4[0], a7[1] = i4[1], a7[2] = 3 === i4.length ? i4[2] : 0, e6.geodesicDistance(r10, a7, o6) ?? Z(r10, a7, o6)) };
}
async function c8() {
  return s7(await g4());
}
var r10 = n2();
var a7 = n2();

// node_modules/@arcgis/core/widgets/Sketch/support/OperationHandle.js
var n9 = class extends o.EventedAccessor {
  constructor(e6) {
    super(e6), this.cancelled = false, this.history = { undo: [], redo: [] }, this.type = null;
  }
  get tool() {
    if (!this.activeComponent) return null;
    switch (this.activeComponent.type) {
      case "graphic-mover":
      case "move-3d":
        return "move";
      case "box":
      case "transform-3d":
        return "transform";
      case "reshape":
      case "reshape-3d":
        return "reshape";
      case "draw-2d":
      case "draw-3d":
        return this.activeComponent.geometryType;
      default:
        n(this.activeComponent);
    }
    return null;
  }
  addToHistory(e6) {
    this.history.redo = [], this.history.undo.push(e6);
  }
  resetHistory() {
    this.history.redo = [], this.history.undo = [];
  }
  canUndo() {
    return this.history.undo.length > 0;
  }
  canRedo() {
    return this.history.redo.length > 0;
  }
  complete() {
    this._reset(), this.onEnd(), this.emit("complete");
  }
  cancel() {
    this.cancelled = true, this.complete();
  }
  _reset() {
    this.activeComponent?.reset();
  }
  refreshComponent() {
    const e6 = this.activeComponent;
    e6 && ("box" !== e6.type && "reshape" !== e6.type && "graphic-mover" !== e6.type || e6.refresh());
  }
  set undo(e6) {
    this._set("undo", () => {
      this.canUndo() && e6();
    });
  }
  set redo(e6) {
    this._set("redo", () => {
      this.canRedo() && e6();
    });
  }
};
r([m()], n9.prototype, "activeComponent", void 0), r([m()], n9.prototype, "cancelled", void 0), r([m()], n9.prototype, "history", void 0), r([m()], n9.prototype, "tool", null), r([m()], n9.prototype, "type", void 0), r([m()], n9.prototype, "canUndo", null), r([m()], n9.prototype, "canRedo", null), r([m()], n9.prototype, "onEnd", void 0), r([m()], n9.prototype, "undo", null), r([m()], n9.prototype, "redo", null), r([m()], n9.prototype, "toggleTool", void 0), r([m()], n9.prototype, "addToSelection", void 0), r([m()], n9.prototype, "removeFromSelection", void 0), n9 = r([a("esri.widgets.Sketch.support.OperationHandle")], n9);
var p8 = class extends n9 {
};
r([m()], p8.prototype, "activeComponent", void 0), p8 = r([a("esri.widgets.Sketch.support.OperationHandle.CreateOperationHandle")], p8);
var i3 = class extends n9 {
};
r([m()], i3.prototype, "activeComponent", void 0), i3 = r([a("esri.widgets.Sketch.support.OperationHandle.UpdateOperationHandle")], i3);

// node_modules/@arcgis/core/widgets/Sketch/support/sketchUtils.js
function e5(e6, n11) {
  if ("freehandPolygon" === n11 || "freehandPolyline" === n11) return "freehand";
  return e6 ?? ("rectangle" === n11 || "circle" === n11 ? "hybrid" : "click");
}
function n10(e6) {
  switch (e6) {
    case "freehandPolygon":
      return "polygon";
    case "freehandPolyline":
      return "polyline";
    default:
      return e6;
  }
}
var o5;
!function(e6) {
  e6[e6.ForceCollapse = -1] = "ForceCollapse", e6[e6.Low = 0] = "Low", e6[e6.Medium = 10] = "Medium", e6[e6.High = 100] = "High", e6[e6.Max = 1e3] = "Max";
}(o5 || (o5 = {}));

// node_modules/@arcgis/core/widgets/Sketch/SketchViewModel.js
var ae = { defaultZ: 0 };
var se = { reshapeOptions: { edgeOperation: "split", shapeOperation: "move", vertexOperation: "move" }, enableMoveAllGraphics: true, enableRotation: true, enableScaling: true, multipleSelectionEnabled: true, preserveAspectRatio: false, toggleToolOnClick: true, enableZ: true, highlightOptions: { enabled: true, name: c5 }, tool: "transform" };
var re = class extends o.EventedAccessor {
  constructor(e6) {
    super(e6), this._defaultSnappingManager = null, this._updatingHandles = new h4(), this._internalGraphicsLayer = new c3({ listMode: "hide", internal: true, title: "SVM Internal" }), this._operationHandle = null, this._viewHandlesKey = "viewHandles", this.activeFillSymbol = null, this.activeLineSymbol = null, this.activeVertexSymbol = null, this.allowDeleteKey = true, this.layer = null, this.pointSymbol = new u3({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.polygonSymbol = new m3({ color: [150, 150, 150, 0.2], outline: { color: [50, 50, 50], width: 2 } }), this.polylineSymbol = new m2({ color: [130, 130, 130, 1], width: 2 }), this.meshSymbol = new a3({ symbolLayers: new V([new d4()]) }), this.updateGraphics = new V(), this.updateOnGraphicClick = true, this.creationMode = "single", this.vertexSymbol = new u3({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.sketchOptions = new c6(), this._moduleLoaderAbortController = null, this._viewReadyAbortController = null, this._sketchContinuationFlag = false, this._originalPopupEnabled = null, this.defaultCreateOptions = ae, this.defaultUpdateOptions = se, this.snappingOptions = e6?.snappingManager?.options ?? e6?.snappingOptions ?? new u4();
  }
  initialize() {
    this.addHandles([a2(() => this.view?.map?.layers, "change", (e6) => {
      e6.removed.includes(this.layer) && this.cancel();
    }), a2(() => this.layer?.graphics, "change", (e6) => {
      if (null != this._operationHandle) for (const t4 of e6.removed) this.updateGraphics.includes(t4) && (this.updateGraphics.length > 1 ? this._operationHandle.removeFromSelection(t4) : this._operationHandle.cancel());
    }), l(() => this.layer?.elevationInfo ?? null, (e6) => {
      e6 !== this._internalGraphicsLayer.elevationInfo && (this.cancel(), this._internalGraphicsLayer.elevationInfo = e6);
    }, w), l(() => this.view, (e6) => {
      this._defaultSnappingManager = u(this._defaultSnappingManager), e6 && (this.snappingManager || (this._defaultSnappingManager = new x3({ view: e6, options: this.snappingOptions })), "2d" === e6.type ? import("./editingTools-HYAJJMTG.js") : "3d" === e6.type && (import("./editingTools-X4XGKBIC.js"), import("./GraphicsLayerView3D-WUP6YWCB.js")));
    }, w), l(() => this.view?.spatialReference, (e6, t4) => {
      e6 && t4 && !e6.equals(t4) && this.cancel();
    })]), N(this);
  }
  destroy() {
    this.cancel(), this._removeDefaultLayer(), this._defaultSnappingManager = u(this._defaultSnappingManager), this._set("snappingManager", null), this._set("view", null), this._updatingHandles.destroy(), this.emit("destroy");
  }
  get updating() {
    return this._updatingHandles.updating || null != this.snappingManager && this.snappingManager.updating;
  }
  get activeTool() {
    return this._operationHandle?.tool ?? null;
  }
  get activeCreateToolDrawMode() {
    return "create" === this._operationHandle?.type && this._operationHandle.activeComponent && "mode" in this._operationHandle.activeComponent ? this._operationHandle.activeComponent.mode : null;
  }
  get activeTooltip() {
    const { activeComponent: e6, destroyed: t4 } = this, o6 = !t4 && e6 && "tooltip" in e6 ? e6.tooltip : null;
    return o6?.visible ? o6 : null;
  }
  get activeComponent() {
    return this._operationHandle?.activeComponent ?? null;
  }
  get createGraphic() {
    return null == this.activeComponent || "draw-3d" !== this.activeComponent.type && "draw-2d" !== this.activeComponent.type ? this._get("createGraphic") : this.activeComponent.graphic;
  }
  get defaultCreateOptions() {
    return this._get("defaultCreateOptions");
  }
  set defaultCreateOptions(e6) {
    this._set("defaultCreateOptions", { ...ae, ...e6 });
  }
  get defaultUpdateOptions() {
    return this._get("defaultUpdateOptions");
  }
  set defaultUpdateOptions(e6) {
    this._set("defaultUpdateOptions", { ...se, ...e6, reshapeOptions: { ...se.reshapeOptions, ...e6?.reshapeOptions }, highlightOptions: { ...se.highlightOptions, ...e6?.highlightOptions } });
  }
  get labelOptions() {
    return this.sketchOptions.labels;
  }
  set labelOptions(e6) {
    this.sketchOptions.labels = e6;
  }
  get snappingOptions() {
    return this.snappingManager?.options ?? this._get("snappingOptions");
  }
  set snappingOptions(e6) {
    null != this._defaultSnappingManager && (this._defaultSnappingManager.options = e6), this._set("snappingOptions", e6);
  }
  get snappingManager() {
    return this._isOverridden("snappingManager") && this._get("snappingManager"), this._defaultSnappingManager;
  }
  set snappingManager(e6) {
    if (e6) this._isOverridden("snappingManager") || (this._defaultSnappingManager = u(this._defaultSnappingManager)), this._override("snappingManager", e6);
    else {
      const { view: e7 } = this;
      !this._defaultSnappingManager && e7 && (this._defaultSnappingManager = new x3({ options: this.snappingOptions, view: e7 })), this._clearOverride("snappingManager");
    }
  }
  get state() {
    const e6 = !(!this.view?.ready || !this.layer), t4 = this._operationHandle;
    return e6 && t4 ? "active" : e6 ? "ready" : "disabled";
  }
  get tooltipOptions() {
    return this.sketchOptions.tooltips;
  }
  set tooltipOptions(e6) {
    this.sketchOptions.tooltips = e6;
  }
  get valueOptions() {
    return this.sketchOptions.values;
  }
  set valueOptions(e6) {
    this.sketchOptions.values = e6;
  }
  get view() {
    return this._get("view");
  }
  set view(e6) {
    const t4 = this._get("view");
    if (t4) {
      const { container: e7, map: o7 } = t4;
      e7 && (t4.cursor = null), o7?.remove(this._internalGraphicsLayer), this.removeHandles(this._viewHandlesKey), this.cancel();
    }
    const o6 = "view-ready";
    this.removeHandles(o6), e6 && this.addHandles(f(() => e6.ready, (t5) => {
      this.removeHandles(this._viewHandlesKey), t5 && this.addHandles(this._generateViewHandles(e6), this._viewHandlesKey);
    }, w), o6), this._set("view", e6);
  }
  cancel() {
    this._moduleLoaderAbortController = e(this._moduleLoaderAbortController), this._viewReadyAbortController = e(this._viewReadyAbortController), this._sketchContinuationFlag = true, this._operationHandle && this._operationHandle.cancel();
  }
  complete() {
    this._operationHandle && this._operationHandle.complete();
  }
  delete() {
    const { state: e6, updateGraphics: t4 } = this;
    if ("active" === e6 && t4.length) {
      const { activeTool: e7, layer: o6 } = this, i4 = t4.toArray();
      o6.removeMany(i4), this.cancel(), this._emitDeleteEvent({ graphics: i4, tool: e7 });
    }
  }
  duplicate() {
    if ("active" === this.state && this.updateGraphics.length) {
      const e6 = this.updateGraphics.map((e7) => e7.clone()).toArray();
      return this.layer.addMany(e6), this.emit("duplicate", { graphics: e6, type: "duplicate" }), e6;
    }
    return [];
  }
  async create(e6, t4) {
    this.cancel(), await this._waitViewReady();
    const { view: o6, layer: i4 } = this;
    if (!o6 || "disabled" === this.state) throw i4 || this._logMissingLayer(), u2();
    if (null != o6.activeTool && (o6.activeTool = null), !e6) return void this._logError("sketch:missing-parameter", "Missing parameter 'tool'.");
    t3(o6, this._internalGraphicsLayer);
    const a8 = await this._updatingHandles.addPromise(this._setupCreateOperation(e6, t4));
    if (null == a8 || this.destroyed) return void o6.map.remove(this._internalGraphicsLayer);
    const s8 = () => {
      if (a8 === this._operationHandle) {
        const o7 = this.createGraphic, s9 = this._operationHandle.cancelled;
        if (this._operationHandle.destroy(), this._operationHandle = null, this._set("createGraphic", null), this.view?.map && this.view.map.remove(this._internalGraphicsLayer), a8.cancelled || null == o7 || i4.add(o7), this._sketchContinuationFlag = false, this.emit("create", { graphic: o7, state: s9 ? "cancel" : "complete", tool: e6, toolEventInfo: null, type: "create" }), s9 || this._sketchContinuationFlag) return;
        const { creationMode: r11 } = this;
        if ("continuous" === r11) {
          if (t4?.geometryToPlace) return;
          this._updatingHandles.addPromise(d2(this.create(e6, t4)));
        } else "update" === r11 && o7 && this._updatingHandles.addPromise(d2(this.update([o7])));
      }
    };
    a8.on("complete", s8), this._operationHandle = a8, o6.ready && o6.focus();
  }
  async place(e6, t4) {
    return this.create("mesh", { mode: "click", hasZ: e6.hasZ, geometryToPlace: e6, ...t4 });
  }
  async update(e6, t4) {
    this.cancel(), await this._waitViewReady();
    const { layer: o6, view: i4, state: a8 } = this;
    if (!i4 || "disabled" === a8) throw o6 || this._logMissingLayer(), u2();
    null != i4.activeTool && (i4.activeTool = null);
    const s8 = Array.isArray(e6) ? e6 : [e6];
    if (null == e6 || !s8?.length) return void this._logError("sketch:missing-parameter", "Missing parameter 'graphics'.");
    if (s8.some((e7) => e7.layer !== o6 ? (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics missing from the supplied GraphicsLayer."), true) : null == e7.geometry && (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics with an unsupported geometry."), true))) return;
    const r11 = await this._updatingHandles.addPromise(this._setupUpdateOperation(s8, t4));
    this.destroyed || null == r11 || ge(r11) || (t3(i4, this._internalGraphicsLayer), this._setUpdateOperationHandle(r11, t4), this.emit("update", { graphics: s8, state: "start", aborted: false, tool: r11.tool, toolEventInfo: null, type: "update" }));
  }
  async _updateSpatialReference(e6) {
    const t4 = this.view;
    if (t4) {
      e6 = Array.isArray(e6) ? e6 : [e6];
      for (const o6 of e6) null == o6.geometry || "mesh" === o6.geometry.type || s3(o6.geometry.spatialReference, t4.spatialReference) || (L(o6.geometry.spatialReference, t4.spatialReference) || k() || await K(), o6.geometry = O(o6.geometry, t4.spatialReference));
    } else this._logMissingView();
  }
  undo() {
    this.canUndo() && this._operationHandle?.undo();
  }
  redo() {
    this.canRedo() && this._operationHandle?.redo();
  }
  canUndo() {
    return !!this._operationHandle?.canUndo();
  }
  canRedo() {
    return !!this._operationHandle?.canRedo();
  }
  toggleUpdateTool() {
    this._operationHandle?.toggleTool();
  }
  async _getFirstHit(e6) {
    const t4 = this.view;
    if (!t4) return this._logMissingView(), null;
    if ("2d" === t4.type) {
      const o7 = [];
      t4.map.allLayers.forEach((e7) => {
        "vector-tile" !== e7.type && "imagery" !== e7.type || o7.push(e7);
      });
      const i5 = await t4.hitTest(e6, { exclude: o7 });
      return r3(i5.results);
    }
    const o6 = [t4.map.ground];
    t4.map.allLayers.forEach((e7) => {
      w2(e7.type) && o6.push(e7);
    });
    const i4 = await t4.hitTest(e6, { exclude: o6 });
    if (i4.results.length > 0) {
      const e7 = i4.results[0];
      if (null != e7 && "graphic" === e7.type && e7.graphic && (!i4.ground.mapPoint || t4.map.ground.opacity < 1 || i4.ground.distance - (e7.distance ?? 0) > -Math.min(3 * i4.ground.distance, "global" === t4.viewingMode ? s4(t4.renderCoordsHelper.spatialReference).radius / t4.renderCoordsHelper.unitInMeters : Number.POSITIVE_INFINITY))) return e7;
    }
    return null;
  }
  _generateViewHandles(e6) {
    return [e6.on("immediate-click", async (e7) => {
      const t4 = "active" === this.state && "create" === this._operationHandle?.type;
      "disabled" !== this.state && !t4 && this.updateOnGraphicClick && await this._updatingHandles.addPromise(this._handleImmediateClick(e7));
    }, _.WIDGET)];
  }
  async _handleImmediateClick(e6) {
    const t4 = await e6.defer(() => this._getFirstHit(n4(e6)));
    let o6 = null;
    if (null != t4) {
      const i4 = t4.graphic;
      this.updateGraphics.includes(i4) || i4.layer === this.layer ? (e6.stopPropagation(), o6 = i4) : "2d" !== this.view?.type || this._isComponentGraphic(i4) || "active" !== this.state || this.cancel();
    } else "active" === this.state && this.cancel();
    null == o6 || this.updateGraphics.includes(o6) || await this.update([o6], { ...this.defaultUpdateOptions, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions } });
  }
  async _setupCreateOperation(e6, t4) {
    const o6 = this.view;
    if (!o6) return this._logMissingView(), null;
    const i4 = { hasZ: "3d" === o6.type, ...this.defaultCreateOptions, ...t4 }, a8 = await this._setupDrawGraphicTool(e6, o6, i4);
    return null == a8 ? null : (o6.tools.add(a8), o6.activeTool = a8, this._setupCreateOperationHandle(a8));
  }
  async _setupDrawGraphicTool(e6, t4, o6) {
    if ("multipoint" === e6 && "3d" === t4.type) return this._logError("sketch:create", "Multipoint geometries are not supported in SceneView."), null;
    if (!t4) return this._logMissingView(), null;
    const { cursor: i4, defaultZ: a8, hasZ: s8, geometryToPlace: r11, graphicProperties: n11, mode: p9, preserveAspectRatio: l7 } = o6, h8 = e5(p9, e6), c9 = n10(e6), d9 = o6?.optionsPerTool?.has(e6) ? o6.optionsPerTool.get(e6) : {}, u7 = d9?.preserveAspectRatio ?? l7 ?? "rectangle" !== e6, m6 = { centered: "rectangle" !== e6 && !("circle" === e6 && !u7), cursor: i4, defaultZ: a8, forceUniformSize: u7, graphicProperties: { ...n11, attributes: { ...n11?.attributes } }, geometryToPlace: r11, geometryType: c9, mode: h8, graphicSymbol: this._getGraphicSymbolFromTool(e6), hasZ: s8, snappingManager: this.snappingManager, snapToScene: false, view: t4, ...d9 };
    return "2d" === t4.type ? this._makeDrawGraphicTool2D(m6) : this._makeDrawGraphicTool3D(m6);
  }
  async _makeDrawGraphicTool2D(e6) {
    const [t4, o6, i4] = await Promise.all([this._requireModule(import("./editingTools-HYAJJMTG.js")), u5(), c8()]);
    return ge(t4) || this.destroyed ? null : new t4.module.DrawGraphicTool2D({ ...e6, activeVertexSymbol: this.activeVertexSymbol, regularVerticesSymbol: this.vertexSymbol, activeLineSymbol: this.activeLineSymbol, activeFillSymbol: le(e6.geometryType) ? this.activeFillSymbol : null, sketchOptions: this.sketchOptions, automaticAreaMeasurementUtils: o6, automaticLengthMeasurementUtils: i4 });
  }
  async _makeDrawGraphicTool3D(e6) {
    const [t4, o6, i4] = await Promise.all([this._requireModule(import("./editingTools-X4XGKBIC.js")), u5(), c8()]);
    if (ge(t4) || this.destroyed) return null;
    const { elevationInfo: a8 } = this.layer;
    return new t4.module.DrawGraphicTool3D({ ...e6, elevationInfo: a8, snapToScene: true, sketchOptions: this.sketchOptions, automaticAreaMeasurementUtils: o6, automaticLengthMeasurementUtils: i4 });
  }
  _setupCreateOperationHandle(e6) {
    const t4 = this.view;
    if (!t4) return this._logMissingView(), null;
    let o6 = null;
    const i4 = e6.forceUniformSize, s8 = e6.centered, r11 = [t4.on("key-down", (t5) => {
      if (t5.key === c4.pan) t5.stopPropagation(), t5.repeat || (e6.enabled = false);
      else if (t5.key === c4.complete) t5.stopPropagation(), e6.completeCreateOperation();
      else if (t5.key !== c4.vertexAdd || t5.repeat) t5.key === c4.undo ? (t5.stopPropagation(), n11.undo()) : t5.key === c4.redo ? (t5.stopPropagation(), n11.redo()) : t5.key !== c4.constraint || "rectangle" !== e6.geometryType && "circle" !== e6.geometryType || t5.repeat ? t5.key === c4.center && (t5.repeat || (e6.centered = !s8, t5.stopPropagation())) : (e6.forceUniformSize = !i4, t5.stopPropagation());
      else {
        const o7 = e6.drawOperation.geometryType;
        "polyline" !== o7 && "polygon" !== o7 && "multipoint" !== o7 || (t5.stopPropagation(), e6.drawOperation.commitStagedVertex());
      }
    }, _.WIDGET), t4.on("key-up", (t5) => {
      t5.key === c4.pan ? e6.enabled = true : t5.key !== c4.constraint || "rectangle" !== e6.geometryType && "circle" !== e6.geometryType ? t5.key === c4.center && (e6.centered = s8, t5.stopPropagation()) : (e6.forceUniformSize = i4, t5.stopPropagation());
    }, _.WIDGET), e6.on("vertex-add", (t5) => {
      switch (o6 = null == o6 ? "start" : "active", t5.operation) {
        case "apply":
          this.emit("create", { graphic: e6.graphic, state: o6, tool: this.activeTool, toolEventInfo: t5, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e6.graphic], tool: e6.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e6.graphic], tool: e6.geometryType });
      }
    }), e6.on("cursor-update", (t5) => {
      e6.drawOperation.numCommittedVertices > 0 && this.emit("create", { graphic: e6.graphic, state: "active", tool: this.activeTool, toolEventInfo: { coordinates: t5.vertices[0].coordinates, type: "cursor-update" }, type: "create" });
    }), e6.on("vertex-remove", (t5) => {
      switch (t5.operation) {
        case "apply":
          this.emit("create", { graphic: e6.graphic, state: "active", tool: this.activeTool, toolEventInfo: t5, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e6.graphic], tool: e6.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e6.graphic], tool: e6.geometryType });
      }
    }), e6.on("complete", (e7) => {
      this._set("createGraphic", e7.graphic), o6 = "complete", e7.aborted ? n11 && n11.cancel() : n11 && n11.complete();
    }), l(() => this._getGraphicSymbolFromTool(e6.geometryType), (t5) => {
      e6.graphicSymbol = t5;
    })], n11 = new p8({ activeComponent: e6, tool: e6.geometryType, type: "create", onEnd: () => {
      r2(r11), t4.tools?.remove(e6);
    }, undo: () => {
      e6.canUndo && e6.undo();
    }, redo: () => {
      e6.canRedo && e6.redo();
    }, canUndo: () => e6.canUndo, canRedo: () => e6.canRedo });
    return n11;
  }
  _getGraphicSymbolFromTool(e6) {
    switch (e6) {
      case "point":
      case "multipoint":
        return this.pointSymbol;
      case "polyline":
      case "freehandPolyline":
        return this.polylineSymbol;
      case "circle":
      case "rectangle":
      case "polygon":
      case "freehandPolygon":
        return this.polygonSymbol;
      case "mesh":
        return this.meshSymbol;
    }
  }
  async _setupUpdateOperation(e6, t4) {
    const { layer: o6, view: i4 } = this;
    if (!i4) return this._logMissingView(), null;
    const a8 = { ...this.defaultUpdateOptions, ...t4, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions, ...t4?.reshapeOptions }, highlightOptions: { ...this.defaultUpdateOptions.highlightOptions, ...t4?.highlightOptions } };
    let s8 = a8.tool ?? se.tool;
    for (const r11 of e6) o6.remove(r11), o6.add(r11);
    if ("3d" === i4.type) {
      if (0 === e6.length) return null;
      switch (s8) {
        case "move":
          return this._setupMove3DOperation(e6, a8, i4, s8);
        case "reshape":
          return e6.length > 1 ? (this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null) : this._setupReshape3DOperation(e6[0], a8, i4);
        case "transform":
          return this._setupGraphicTransform3DOperation(e6, a8, i4);
      }
    }
    switch (s8) {
      case "move":
        return this._setupMove2DOperation(e6, a8, i4);
      case "reshape":
        return e6.length > 1 ? (this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null) : this._setupTransformOrReshape2DOperation(e6, s8, a8, i4);
      case "transform":
        if (1 === e6.length) {
          const t5 = e6[0].geometry?.type;
          "point" !== t5 && "multipoint" !== t5 || (s8 = "reshape");
        }
        return this._setupTransformOrReshape2DOperation(e6, s8, a8, i4);
    }
  }
  async _setupMove3DOperation(e6, t4, o6, i4, s8 = false) {
    const [r11, n11] = await Promise.all([this._requireModule(import("./editingTools-X4XGKBIC.js")), c8()]);
    if (ge(r11)) return r11;
    const { ManipulatedObject3DGraphic: p9, MoveTool3D: l7 } = r11.module, h8 = /* @__PURE__ */ new Map(), c9 = () => {
      h8.forEach((e7) => e7.destroy()), h8.clear();
    };
    for (const a8 of e6) {
      const e7 = new p9({ view: o6, graphic: a8 }), t5 = r4(e7);
      if (t5 !== P.SUPPORTED) return c9(), this._logError("sketch:move", `Move operation not supported for provided graphic(s) (${E4(t5)}).`), null;
      h8.set(a8, e7);
    }
    const d9 = new l7({ view: o6, enableZ: t4.enableZ, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions, autoLengthMeasurementUtils: n11 });
    o6.tools.add(d9), d9.objects.addMany(Array.from(h8.values())), s8 || this.updateGraphics.addMany(e6);
    const u7 = [], m6 = new i3({ activeComponent: d9, tool: i4, type: "update", onEnd: () => {
      r2(u7), ye(o6, d9), c9();
    }, undo: () => {
      ue(this.view, d9), he(m6, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i4 });
    }, redo: () => {
      ce2(m6, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i4 });
    }, addToSelection: (e7) => {
      this.updateGraphics.push(e7);
      const t5 = new p9({ view: o6, graphic: e7 });
      h8.set(e7, t5), d9.objects.push(t5), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e7) => {
      const t5 = this.updateGraphics.indexOf(e7);
      if (m6.history.undo.forEach((e8) => e8.updates.splice(t5, 1)), m6.history.redo.forEach((e8) => e8.updates.splice(t5, 1)), this.updateGraphics.remove(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), 0 === this.updateGraphics.length) return void m6.complete();
      const o7 = h8.get(e7);
      o7 && (d9.objects.remove(o7), o7.destroy(), h8.delete(e7));
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t4.toggleToolOnClick) return;
      if ("transform" !== i4) return;
      const e7 = this.updateGraphics.at(0), a8 = await this._setupReshape3DOperation(e7, t4, o6, true);
      a8 && !ge(a8) && (m6.onEnd(), m6.destroy(), this._setUpdateOperationHandle(a8, t4));
    } });
    return u7.push(...this._getHandlesForComponent(m6, t4), o6.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(m6, e7, t4), _.WIDGET), o6.on("key-down", (e7) => {
      this._getCommonUpdateOperationKeyDownHandlers(m6, e7);
    }, _.WIDGET)), m6;
  }
  _setupGraphicTransform3DOperation(e6, t4, o6, i4 = false) {
    if (1 === e6.length && r9(e6[0]) === P.SUPPORTED) {
      const a8 = e6[0], s8 = a8.geometry;
      if (null != s8 && ("point" === s8.type || "mesh" === s8.type)) return this._setupPointTransform3DOperation(a8, t4, o6);
      if (null != s8 && ("polygon" === s8.type || "polyline" === s8.type)) return this._setupPolyTransform3DOperation(a8, t4, o6, i4);
    }
    return this._setupMove3DOperation(e6, t4, o6, "transform", i4);
  }
  async _setupPointTransform3DOperation(e6, t4, o6) {
    const i4 = "transform", { enableRotation: s8, enableScaling: r11, enableZ: n11 } = t4, p9 = await this._requireModule(import("./editingTools-X4XGKBIC.js"));
    if (ge(p9)) return p9;
    const { TransformTool3D: l7, ManipulatedObject3DGraphic: h8 } = p9.module, c9 = new h8({ graphic: e6, view: o6 }), d9 = new l7({ object: c9, view: o6, enableRotation: s8, enableScaling: r11, enableZ: n11, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions });
    o6.tools.add(d9), this.updateGraphics.add(e6);
    const u7 = [], m6 = new i3({ activeComponent: d9, tool: i4, type: "update", onEnd: () => {
      r2(u7), ye(o6, d9), c9.destroy();
    }, undo: () => {
      ue(this.view, d9), he(m6, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i4 });
    }, redo: () => {
      ce2(m6, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i4 });
    }, addToSelection: async (e7) => {
      this.updateGraphics.add(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" }), m6.onEnd(), m6.destroy();
      const i5 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t4, o6, "transform", true);
      ge(i5) || this._setUpdateOperationHandle(i5, t4);
    }, removeFromSelection: (e7) => {
      this.updateGraphics.remove(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), m6.complete();
    }, toggleTool: () => {
    } });
    return u7.push(...this._getHandlesForComponent(m6, t4), o6.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(m6, e7, t4), _.WIDGET), o6.on("key-down", (e7) => {
      this._getCommonUpdateOperationKeyDownHandlers(m6, e7);
    }, _.WIDGET)), m6;
  }
  async _setupPolyTransform3DOperation(e6, t4, o6, i4 = false) {
    const s8 = "transform", { enableRotation: r11, enableScaling: n11, enableZ: p9, preserveAspectRatio: l7 } = t4, [h8, c9] = await Promise.all([this._requireModule(import("./editingTools-X4XGKBIC.js")), c8()]);
    if (ge(h8)) return h8;
    const { ManipulatedObject3DGraphic: d9, ExtentTransformTool: u7 } = h8.module, m6 = this.view?.inputManager?.isModifierKeyDown(c4.constraint), y4 = new d9({ view: o6, graphic: e6 }), g7 = new u7({ object: y4, view: o6, enableRotation: r11, enableScaling: n11, enableZ: p9, preserveAspectRatio: !!l7 != !!m6, sketchOptions: this.sketchOptions, automaticLengthMeasurementUtils: c9 });
    o6.tools.add(g7), i4 || this.updateGraphics.add(e6);
    const v4 = [], f5 = new i3({ activeComponent: g7, tool: s8, type: "update", onEnd: () => {
      r2(v4), ye(o6, g7), y4.destroy();
    }, canUndo: () => !g7.destroyed && g7.canUndo, undo: () => {
      g7.destroyed || (g7.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: s8 }));
    }, canRedo: () => !g7.destroyed && g7.canRedo, redo: () => {
      g7.destroyed || (g7.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: s8 }));
    }, addToSelection: async (e7) => {
      this.updateGraphics.add(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" }), f5.onEnd(), f5.destroy();
      const i5 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t4, o6, "transform", true);
      ge(i5) || this._setUpdateOperationHandle(i5, t4);
    }, removeFromSelection: (e7) => {
      this.updateGraphics.remove(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), f5.complete();
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t4.toggleToolOnClick) return;
      const i5 = await this._setupReshape3DOperation(e6, t4, o6, true);
      i5 && !ge(i5) && (f5.onEnd(), f5.destroy(), this._setUpdateOperationHandle(i5, t4));
    } });
    return v4.push(...this._getHandlesForComponent(f5, t4), o6.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(f5, e7, t4), _.WIDGET), o6.on("key-down", (e7) => this._getCommonUpdateOperationKeyDownHandlers(f5, e7), _.WIDGET), o6.on("key-down", (e7) => {
      e7.key !== c4.constraint || e7.repeat || (g7.preserveAspectRatio = !g7.preserveAspectRatio, e7.stopPropagation());
    }, _.WIDGET), o6.on("key-up", (e7) => {
      e7.key === c4.constraint && (g7.preserveAspectRatio = !g7.preserveAspectRatio, e7.stopPropagation());
    }, _.WIDGET)), f5;
  }
  async _setupMove2DOperation(e6, t4, o6) {
    const i4 = "move";
    this.updateGraphics.addMany(e6), await this._updatingHandles.addPromise(this._updateSpatialReference(e6));
    const s8 = await this._getGraphicMover(e6, t4, o6);
    if (ge(s8)) return s8;
    const r11 = new i3({ activeComponent: s8, tool: i4, type: "update", onEnd: () => {
      this._displayDefaultCursor(), r2(l7), r2(p9), s8.destroy(), this._internalGraphicsLayer?.removeMany([...this.updateGraphics.toArray()]);
    }, undo: () => {
      const e7 = this.updateGraphics.toArray();
      he(r11, e7), r11.refreshComponent(), this._emitUndoEvent({ graphics: e7, tool: i4 });
    }, redo: () => {
      const e7 = this.updateGraphics.toArray();
      ce2(r11, e7), r11.refreshComponent(), this._emitRedoEvent({ graphics: e7, tool: i4 });
    }, addToSelection: async (e7) => {
      await this._updatingHandles.addPromise(this._updateSpatialReference(e7)), this.updateGraphics.push(e7), s8.graphics = this.updateGraphics.toArray(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e7) => {
      const t5 = this.updateGraphics.indexOf(e7);
      r11.history.undo.forEach((e8) => e8.updates.splice(t5, 1)), r11.history.redo.forEach((e8) => e8.updates.splice(t5, 1)), this.updateGraphics.remove(e7);
      const o7 = this.updateGraphics.toArray();
      this.emit("update", { graphics: o7, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), 0 !== this.updateGraphics.length ? s8.graphics = o7 : r11.complete();
    } });
    let n11 = false;
    const p9 = [o6.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(r11, e7, t4), _.WIDGET), o6.on("key-down", (e7) => {
      this._getCommonUpdateOperationKeyDownHandlers(r11, e7), e7.key !== c4.constraint || e7.repeat || (n11 = true, s8.enableMoveAllGraphics = !s8.enableMoveAllGraphics);
    }, _.WIDGET), o6.on("key-up", (e7) => {
      e7.key === c4.constraint && n11 && (n11 = false, s8.enableMoveAllGraphics = !s8.enableMoveAllGraphics);
    }, _.WIDGET)], l7 = this._getHandlesForComponent(r11, t4);
    return r11;
  }
  async _setupReshape3DOperation(e6, t4, o6, i4 = false) {
    const s8 = "reshape", [r11, n11, p9] = await Promise.all([this._requireModule(import("./editingTools-X4XGKBIC.js")), u5(), c8()]);
    if (ge(r11)) return r11;
    const { ManipulatedObject3DGraphic: l7, ReshapeTool3D: h8 } = r11.module, c9 = new l7({ view: o6, graphic: e6 }), d9 = e4(c9);
    if (d9 !== P.SUPPORTED) return c9.destroy(), this._logError("sketch:reshape", `Reshape operation not supported for provided graphic(s) (${E4(d9)}).`), null;
    const u7 = t4.reshapeOptions, m6 = new h8({ view: o6, object: c9, enableZVertex: t4.enableZ && "move" === u7?.vertexOperation, enableZShape: t4.enableZ && "move" === u7?.shapeOperation, enableMoveObject: "move" === u7?.shapeOperation || "move-xy" === u7?.shapeOperation, enableMidpoints: "split" === u7?.edgeOperation, enableEdgeOffset: "offset" === u7?.edgeOperation, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions, automaticAreaMeasurementUtils: n11, automaticLengthMeasurementUtils: p9 });
    o6.tools.add(m6), i4 || this.updateGraphics.add(c9.graphic);
    const y4 = [], g7 = new i3({ activeComponent: m6, tool: s8, type: "update", onEnd: () => {
      r2(y4), ye(o6, m6), c9.destroy();
    }, canUndo: () => !m6.destroyed && m6.canUndo, undo: () => {
      m6.destroyed || (m6.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: s8 }));
    }, canRedo: () => !m6.destroyed && m6.canRedo, redo: () => {
      m6.destroyed || (m6.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: s8 }));
    }, addToSelection: async (e7) => {
      this.updateGraphics.add(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" }), g7.onEnd(), g7.destroy();
      const i5 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t4, o6, "transform", true);
      ge(i5) || this._setUpdateOperationHandle(i5, t4);
    }, removeFromSelection: (e7) => {
      this.updateGraphics.remove(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), g7.complete();
    }, toggleTool: async () => {
      if (false === t4.toggleToolOnClick) return;
      g7.onEnd(), g7.destroy();
      const e7 = await this._setupGraphicTransform3DOperation(this.updateGraphics.toArray(), t4, o6, true);
      ge(e7) || this._setUpdateOperationHandle(e7, t4);
    } });
    return y4.push(...this._getHandlesForComponent(g7, t4), o6.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(g7, e7, t4), _.WIDGET), o6.on("key-down", (e7) => {
      this._getCommonUpdateOperationKeyDownHandlers(g7, e7);
    }, _.WIDGET)), g7;
  }
  async _setupTransformOrReshape2DOperation(e6, t4, o6, i4) {
    this.updateGraphics.addMany(e6), await this._updatingHandles.addPromise(this._updateSpatialReference(e6));
    const s8 = "transform" === t4 ? await this._getBox(e6, o6, i4) : await this._getReshape(e6, o6, i4);
    if (ge(s8)) return s8;
    const r11 = new i3({ activeComponent: s8, type: "update", onEnd: () => {
      r2(p9), r2(n11), r11.activeComponent && !r11.activeComponent.destroyed && r11.activeComponent.destroy(), this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray());
    }, undo: () => {
      he(r11, this.updateGraphics.toArray()), r11.refreshComponent(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: r11.tool });
    }, redo: () => {
      ce2(r11, this.updateGraphics.toArray()), r11.refreshComponent(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: r11.tool });
    }, addToSelection: async (e7) => {
      let t5 = r11.activeComponent;
      if ("reshape" === t5?.type) {
        const t6 = [...this.updateGraphics, e7];
        this.updateGraphics.removeAll(), r11.onEnd(), r11.destroy();
        const a8 = await this._setupTransformOrReshape2DOperation(t6, "transform", o6, i4);
        if (ge(a8)) return;
        this._setUpdateOperationHandle(a8, o6);
      } else this.updateGraphics.add(e7), t5.graphics = this.updateGraphics.toArray(), t5.refresh(), r11.resetHistory();
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: async (e7) => {
      const t5 = this.updateGraphics.indexOf(e7);
      r11.history.undo.forEach((e8) => e8.updates.splice(t5, 1)), r11.history.redo.forEach((e8) => e8.updates.splice(t5, 1)), this.updateGraphics.remove(e7);
      const o7 = this.updateGraphics.toArray();
      if (0 === o7.length) r11.complete();
      else {
        const e8 = o7[0].geometry;
        1 !== o7.length || null == e8 || "point" !== e8.type && "multipoint" !== e8.type ? r11.activeComponent.graphics = o7 : r11.toggleTool();
      }
      this.emit("update", { graphics: o7, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" });
    }, toggleTool: async () => {
      if (this.updateGraphics.length > 1) return;
      const e7 = this.updateGraphics.at(0), t5 = e7.geometry;
      if (null != t5 && ("reshape" === r11.tool && ("point" === t5.type || "multipoint" === t5.type) || "transform" === r11.tool && "extent" === t5.type)) return;
      let s9 = null;
      "transform" === r11.tool ? s9 = await this._getReshape([e7], o6, i4) : "reshape" === r11.tool && (s9 = await this._getBox([e7], o6, i4)), ge(s9) || (r11.activeComponent?.destroy(), r11.activeComponent = s9, r11.activeComponent && (r2(p9), p9 = this._getHandlesForComponent(r11, o6)));
    } }), n11 = [i4.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(r11, e7, o6), _.WIDGET), i4.on("key-down", (e7) => {
      if (this._getCommonUpdateOperationKeyDownHandlers(r11, e7), e7.key === c4.constraint && !e7.repeat && r11) {
        const e8 = r11.activeComponent;
        e8 && "box" === e8.type && (e8.preserveAspectRatio = !e8.preserveAspectRatio);
      }
    }, _.WIDGET), i4.on("key-up", (e7) => {
      if (e7.key === c4.constraint && r11) {
        const e8 = r11.activeComponent;
        e8 && "box" === e8.type && (e8.preserveAspectRatio = !e8.preserveAspectRatio);
      }
    }, _.WIDGET)];
    let p9 = this._getHandlesForComponent(r11, o6);
    return r11;
  }
  async _getGraphicMover(e6, t4, o6) {
    const { enableMoveAllGraphics: i4, highlightOptions: a8 } = t4, s8 = await this._requireModule(import("./GraphicMover-WZVGNJBS.js"));
    return ge(s8) ? s8 : new s8.module.default({ enableMoveAllGraphics: i4, highlightName: a8?.name, highlightsEnabled: !!a8?.enabled, indicatorsEnabled: false, graphics: e6, view: o6, callbacks: { onGraphicMoveStart: ({ dx: e7, dy: t5, graphic: o7 }) => {
      this._displayGrabbingCursor(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t5, mover: o7, type: "move-start" }, type: "update" });
    }, onGraphicMove: ({ dx: e7, dy: t5, graphic: o7 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t5, mover: o7, type: "move" }, type: "update" }), onGraphicMoveStop: ({ dx: e7, dy: t5, graphic: o7 }) => {
      this._displayPointerCursor(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t5, mover: o7, type: "move-stop" }, type: "update" });
    }, onGraphicPointerOver: () => this._displayMoveCursor(), onGraphicPointerOut: () => this._displayDefaultCursor() } });
  }
  async _getBox(e6, t4, o6) {
    const { enableRotation: i4, enableScaling: a8, highlightOptions: s8, preserveAspectRatio: r11 } = t4, [n11, p9] = await Promise.all([this._requireModule(import("./Box-EFHYMP2E.js")), c8()]);
    if (ge(n11)) return n11;
    const l7 = this.view?.inputManager?.isModifierKeyDown(c4.constraint);
    return new n11.module.default({ graphics: e6, enableRotation: i4, enableScaling: a8, highlightName: s8?.name, highlightsEnabled: !!s8?.enabled, preserveAspectRatio: !!r11 != !!l7, layer: this._internalGraphicsLayer, view: o6, sketchOptions: this.sketchOptions, automaticLengthMeasurementUtils: p9, callbacks: { onMoveStart: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onMove: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onMoveStop: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onScaleStart: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onScale: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onScaleStop: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onRotateStart: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onRotate: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onRotateStop: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }) } });
  }
  async _getReshape(e6, t4, o6) {
    const { highlightOptions: i4, reshapeOptions: a8 } = t4, s8 = "split" === a8?.edgeOperation, r11 = "move" === a8?.shapeOperation, [n11, p9, l7] = await Promise.all([this._requireModule(import("./Reshape-YOE4WXL3.js")), u5(), c8()]);
    return ge(n11) ? n11 : new n11.module.default({ enableMidpoints: s8, enableMovement: r11, graphic: e6[0], highlightName: i4?.name, highlightsEnabled: !!i4?.enabled, layer: this._internalGraphicsLayer, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions, automaticAreaMeasurementUtils: p9, automaticLengthMeasurementUtils: l7, view: o6, callbacks: { onReshapeStart: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onReshape: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onReshapeStop: ({ mover: e7, type: t5 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7, type: t5 }, type: "update" }), onMoveStart: ({ dx: e7, dy: t5, mover: o7, type: i5 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t5, mover: o7, type: i5 }, type: "update" }), onMove: ({ dx: e7, dy: t5, mover: o7, type: i5 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t5, mover: o7, type: i5 }, type: "update" }), onMoveStop: ({ dx: e7, dy: t5, mover: o7, type: i5 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t5, mover: o7, type: i5 }, type: "update" }), onVertexAdd: ({ added: e7, type: t5, vertices: o7 }) => {
      const i5 = e7.map((e8) => e2(e8.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: i5, vertices: o7, type: t5 }, type: "update" });
    }, onVertexRemove: ({ removed: e7, type: t5, vertices: o7 }) => {
      const i5 = e7.map((e8) => e2(e8.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { removed: i5, vertices: o7, type: t5 }, type: "update" });
    } } });
  }
  _getHandlesForComponent(e6, t4) {
    const o6 = e6.activeComponent;
    if (!o6) return [];
    switch (o6.type) {
      case "graphic-mover":
        return [o6.on("graphic-click", ({ graphic: o7, viewEvent: i4 }) => {
          i4.native?.shiftKey && t4.multipleSelectionEnabled && (i4.stopPropagation(), e6.removeFromSelection(o7));
        }), o6.on("graphic-move-start", (t5) => e6.addToHistory(me(t5.allGraphics)))];
      case "box":
        return [o6.on("graphic-click", (o7) => this._onTransformOrReshape2DGraphicClick(e6, t4, o7)), o6.on("move-start", (t5) => e6.addToHistory(me(t5.graphics))), o6.on("rotate-start", (t5) => e6.addToHistory(me(t5.graphics))), o6.on("scale-start", (t5) => e6.addToHistory(me(t5.graphics)))];
      case "reshape":
        return [o6.on("graphic-click", (o7) => this._onTransformOrReshape2DGraphicClick(e6, t4, o7)), o6.on("move-start", (t5) => e6.addToHistory(me([t5.mover]))), o6.on("reshape-start", (t5) => e6.addToHistory(me([t5.graphic]))), o6.on("vertex-add", (t5) => e6.addToHistory(me([t5.oldGraphic]))), o6.on("vertex-remove", (t5) => e6.addToHistory(me([t5.oldGraphic])))];
      case "move-3d":
        return [o6.events.on("record-undo", ({ updates: t5 }) => {
          e6.addToHistory({ updates: t5 });
        }), o6.events.on("move-start", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: e7.objects.length > 0 ? e7.objects[0].graphic : null, type: "move-start" }, type: "update" });
        }), o6.events.on("move", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7.dx, dy: e7.dy, mover: e7.objects.length > 0 ? e7.objects[0].graphic : null, type: "move" }, type: "update" });
        }), o6.events.on("move-stop", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: e7.objects.length > 0 ? e7.objects[0].graphic : null, type: "move-stop" }, type: "update" });
        }), o6.events.on("immediate-click", (o7) => {
          o7.shiftKey ? this._toggleSelection([o7.object.graphic], e6, t4) : e6.toggleTool();
        })];
      case "transform-3d":
        return [o6.events.on("record-undo", ({ updates: t5 }) => {
          e6.addToHistory({ updates: t5 });
        }), o6.events.on("translate-start", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, dx: e7.dxScreen, dy: e7.dyScreen, type: "move-start" }, type: "update" });
        }), o6.events.on("translate-stop", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, dx: e7.dxScreen, dy: e7.dyScreen, type: "move-stop" }, type: "update" });
        }), o6.events.on("rotate-start", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, angle: e7.angle, type: "rotate-start" }, type: "update" });
        }), o6.events.on("rotate-stop", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, angle: e7.angle, type: "rotate-stop" }, type: "update" });
        }), o6.events.on("scale-start", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, xScale: e7.xScale, yScale: e7.yScale, type: "scale-start" }, type: "update" });
        }), o6.events.on("scale-stop", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, xScale: e7.xScale, yScale: e7.yScale, type: "scale-stop" }, type: "update" });
        }), o6.events.on("translate", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, dx: e7.dxScreen, dy: e7.dyScreen, type: "move" }, type: "update" });
        }), o6.events.on("rotate", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, angle: e7.angle, type: "rotate" }, type: "update" });
        }), o6.events.on("scale", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, xScale: e7.xScale, yScale: e7.yScale, type: "scale" }, type: "update" });
        }), o6.events.on("immediate-click", (o7) => {
          o7.shiftKey ? this._toggleSelection([o7.object.graphic], e6, t4) : e6.toggleTool();
        })];
      case "reshape-3d":
        return [o6.events.on("reshape", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7, mover: e7.object.graphic }, type: "update" });
        }), o6.events.on("move", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7, mover: e7.object.graphic }, type: "update" });
        }), o6.events.on("vertex-add", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e7, type: "update" });
        }), o6.events.on("vertex-remove", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e7, type: "update" });
        }), o6.events.on("immediate-click", (o7) => {
          o7.shiftKey ? this._toggleSelection([o7.object.graphic], e6, t4) : e6.toggleTool();
        })];
    }
  }
  _onTransformOrReshape2DGraphicClick(e6, t4, o6) {
    const { graphic: i4, viewEvent: a8 } = o6;
    return a8.native?.shiftKey && i4.layer === this.layer ? (a8.stopPropagation(), e6.removeFromSelection(i4)) : t4.toggleToolOnClick ? (a8.stopPropagation(), e6.toggleTool()) : void 0;
  }
  _setUpdateOperationHandle(e6, t4) {
    this._operationHandle = e6;
    const o6 = this.view?.map;
    this._disablePopup(t4);
    const i4 = () => {
      if (e6 === this._operationHandle) {
        const i5 = this.updateGraphics.toArray(), a8 = this._operationHandle.tool;
        this._operationHandle.destroy(), this._operationHandle = null, this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray()), this.updateGraphics.removeAll(), o6 && o6.remove(this._internalGraphicsLayer), this._restorePopup(t4), this.emit("update", { graphics: i5, state: "complete", aborted: e6.cancelled, tool: a8, toolEventInfo: null, type: "update" });
      }
    };
    e6.on("complete", i4);
  }
  async _getCommonUpdateOperationClickHandlers(e6, t4, o6) {
    const i4 = n4(t4), a8 = await t4.defer(() => this._getFirstHit(i4));
    if (null == a8) return void e6.complete();
    if (t4.native.shiftKey && this._toggleSelection([a8.graphic], e6, o6)) return void t4.stopPropagation();
    this.updateGraphics.includes(a8.graphic) ? t4.stopPropagation() : e6.complete();
  }
  _toggleSelection(e6, t4, o6) {
    const i4 = !!o6.multipleSelectionEnabled;
    return e6.some((e7) => null != e7 && (!(!i4 || e7.layer !== this.layer) && (this.updateGraphics.includes(e7) ? t4.removeFromSelection(e7) : t4.addToSelection(e7), true)));
  }
  _getCommonUpdateOperationKeyDownHandlers(e6, t4) {
    if (!e6) return;
    const o6 = t4.key;
    o6 === c4.undo && e6.canUndo() ? (t4.stopPropagation(), e6.undo()) : o6 === c4.redo && e6.canRedo() ? (t4.stopPropagation(), e6.redo()) : o6 === c4.cancel ? (t4.stopPropagation(), e6.cancel()) : this.allowDeleteKey && c4.delete.includes(o6) && this._onDeleteKey(t4);
  }
  _onDeleteKey(e6) {
    if (!this._operationHandle || "update" !== this._operationHandle.type) return;
    const t4 = this.activeComponent, o6 = this.updateGraphics.toArray();
    null != t4 && ("reshape" !== t4.type || 1 === o6.length && "point" === o6[0].geometry?.type) && (e6.stopPropagation(), this.delete());
  }
  _removeDefaultLayer() {
    this._internalGraphicsLayer && (this.view?.map?.remove(this._internalGraphicsLayer), this._internalGraphicsLayer = u(this._internalGraphicsLayer));
  }
  _isComponentGraphic(e6) {
    const { activeComponent: t4 } = this;
    return !(!e6 || null == t4) && (e6.attributes?.esriSketchTool || "draw-2d" === t4.type && t4.graphic === e6 || ("box" === t4.type || "reshape" === t4.type) && t4.isUIGraphic(e6));
  }
  _displayPointerCursor() {
    this.view?.container && "pointer" !== this.view.cursor && (this.view.cursor = "pointer");
  }
  _displayGrabbingCursor() {
    this.view?.container && "grabbing" !== this.view.cursor && (this.view.cursor = "grabbing");
  }
  _displayMoveCursor() {
    this.view?.container && "move" !== this.view.cursor && (this.view.cursor = "move");
  }
  _displayDefaultCursor() {
    this.view?.container && null !== this.view.cursor && (this.view.cursor = null);
  }
  _logError(e6, t4, i4) {
    i.getLogger(this).error(new s(e6, t4, i4));
  }
  async _requireModule(e6) {
    const t4 = new AbortController();
    this._moduleLoaderAbortController = t4;
    const o6 = await e6;
    return this._moduleLoaderAbortController !== t4 || t4.signal.aborted ? { requireError: "aborted" } : { module: o6 };
  }
  _emitUndoEvent(e6) {
    this.emit("undo", { ...e6, type: "undo" });
  }
  _emitRedoEvent(e6) {
    this.emit("redo", { ...e6, type: "redo" });
  }
  _emitDeleteEvent(e6) {
    this.emit("delete", { ...e6, type: "delete" });
  }
  get test() {
  }
  wait() {
    return j(() => !this.updating);
  }
  _disablePopupEnabled(e6) {
    return "3d" !== this.view?.type || this.updateOnGraphicClick || (e6?.toggleToolOnClick ?? false);
  }
  _disablePopup(e6) {
    this._disablePopupEnabled(e6) && this.view && null == this._originalPopupEnabled && (this._originalPopupEnabled = this.view.popupEnabled, this.view.popupEnabled = false);
  }
  _restorePopup(e6) {
    this._disablePopupEnabled(e6) && this.view && null != this._originalPopupEnabled && (this.view.popupEnabled = this._originalPopupEnabled, this._originalPopupEnabled = null);
  }
  async _waitViewReady() {
    const e6 = this.view;
    e6 ? (e(this._viewReadyAbortController), this._viewReadyAbortController = new AbortController(), await h(j(() => e6?.ready), this._viewReadyAbortController.signal)) : this._logMissingView();
  }
  _logMissingView() {
    this._logError("sketch:missing-property", pe("view"));
  }
  _logMissingLayer() {
    this._logError(ne, pe("layer"));
  }
};
r([m()], re.prototype, "_defaultSnappingManager", void 0), r([m()], re.prototype, "updating", null), r([m({ readOnly: true })], re.prototype, "_updatingHandles", void 0), r([m()], re.prototype, "_operationHandle", void 0), r([m({ readOnly: true })], re.prototype, "activeTool", null), r([m({ readOnly: true })], re.prototype, "activeCreateToolDrawMode", null), r([m()], re.prototype, "activeTooltip", null), r([m({ types: x })], re.prototype, "activeFillSymbol", void 0), r([m()], re.prototype, "activeLineSymbol", void 0), r([m()], re.prototype, "activeVertexSymbol", void 0), r([m()], re.prototype, "allowDeleteKey", void 0), r([m({ readOnly: true })], re.prototype, "createGraphic", null), r([m()], re.prototype, "defaultCreateOptions", null), r([m()], re.prototype, "defaultUpdateOptions", null), r([m({ type: t2, nonNullable: true })], re.prototype, "labelOptions", null), r([m()], re.prototype, "layer", void 0), r([m({ types: x })], re.prototype, "pointSymbol", void 0), r([m({ types: x })], re.prototype, "polygonSymbol", void 0), r([m({ types: x })], re.prototype, "polylineSymbol", void 0), r([m()], re.prototype, "meshSymbol", void 0), r([m({ type: u4, nonNullable: true })], re.prototype, "snappingOptions", null), r([m()], re.prototype, "snappingManager", null), r([m({ readOnly: true })], re.prototype, "state", null), r([m({ type: p4, nonNullable: true })], re.prototype, "tooltipOptions", null), r([m({ readOnly: true })], re.prototype, "updateGraphics", void 0), r([m()], re.prototype, "updateOnGraphicClick", void 0), r([m()], re.prototype, "creationMode", void 0), r([m({ type: n5, nonNullable: true })], re.prototype, "valueOptions", null), r([m({ types: x })], re.prototype, "vertexSymbol", void 0), r([m({ value: null })], re.prototype, "view", null), r([m({ constructOnly: true, type: c6 })], re.prototype, "sketchOptions", void 0), re = r([a("esri.widgets.Sketch.SketchViewModel")], re);
var ne = "sketch:missing-property";
var pe = (e6) => `Property '${e6}' is missing on SketchViewModel.`;
function le(e6) {
  return "polygon" === e6 || "rectangle" === e6 || "circle" === e6;
}
function he(e6, t4) {
  de("undo", e6.history.undo, e6.history.redo, t4);
}
function ce2(e6, t4) {
  de("redo", e6.history.redo, e6.history.undo, t4);
}
function de(e6, t4, o6, i4) {
  const a8 = t4.pop();
  if (!a8) return;
  const s8 = a8.updates, r11 = [];
  i4.forEach((t5, o7) => {
    const i5 = s8[o7];
    null != i5 && ("geometry" in i5 && null != i5.geometry && (r11.push({ geometry: t5.geometry }), t5.geometry = i5.geometry), "symbol" in i5 && null != i5.symbol && (r11.push({ symbol: t5.symbol }), t5.symbol = i5.symbol), "undo" in i5 && (r11.push(i5), i5[e6](t5)));
  }), o6.push({ updates: r11 });
}
function ue(e6, t4) {
  null != e6 && t4.hasGrabbedManipulators && (e6.activeTool = null);
}
function me(e6) {
  return { updates: e6.map(({ geometry: e7 }) => "mesh" === e7?.type ? { geometry: e7.cloneShallow() } : { geometry: e7 }) };
}
function ye(e6, t4) {
  e6.tools?.remove(t4), t4.destroyed || t4.destroy();
}
function ge(e6) {
  return "requireError" in e6 && "aborted" === e6.requireError;
}

// node_modules/@arcgis/core/views/2d/layers/support/RouteLayerInteraction.js
function g6(e6, r11) {
  e6.networkFeature = r11;
}
function u6(e6) {
  const r11 = w4(e6.graphic);
  return { ...e6, networkFeature: r11 };
}
function b5(e6) {
  const r11 = e6.graphics.map((e7) => w4(e7));
  return { ...e6, networkFeatures: r11 };
}
function w4(e6) {
  return e6.networkFeature;
}
function k4(e6) {
  return "point" === e6?.type || "polyline" === e6?.type || "polygon" === e6?.type;
}
var _2 = class extends b {
  constructor(e6) {
    super(e6), this._createMode = null, this._graphicsLayer = new c3({ internal: true, listMode: "hide", title: "Banana" }), this._updatingHandles = new h4(), this.enabled = true, this._handleSketchViewModelEvents = async (e7) => {
      switch (e7.type) {
        case "update":
          switch (e7.state) {
            case "active":
            case "complete":
              for (const r11 of e7.graphics) {
                w4(r11).geometry = k4(r11.geometry) ? r11.geometry.clone() : null;
              }
          }
          break;
        case "undo":
        case "redo":
          break;
        case "delete":
          for (const r11 of e7.graphics) {
            const e8 = w4(r11);
            this._removeNetworkFeature(e8);
          }
          break;
        case "create":
          if (e7.graphic && "complete" === e7.state && this._createMode) {
            const r11 = e7.graphic.geometry?.clone(), t4 = e7.graphic.symbol?.clone();
            if (!r11) break;
            switch (this._createMode) {
              case "stop": {
                if ("point" !== r11.type) break;
                const { stops: t5 } = this.layer;
                if (t5.length > 0 && t5.every(({ geometry: e8 }) => !e8)) {
                  t5.at(0).geometry = r11;
                  break;
                }
                if (t5.length > 1 && t5.filter((e8, r12) => 0 !== r12).every(({ geometry: e8 }) => !e8)) {
                  t5.at(1).geometry = r11;
                  break;
                }
                const o6 = new S2({ geometry: r11 });
                t5.add(o6), g6(e7.graphic, o6);
                break;
              }
              case "point-barrier": {
                if ("point" !== r11.type) break;
                const o6 = new S({ geometry: r11, symbol: t4 });
                this.layer.pointBarriers.add(o6), g6(e7.graphic, o6);
                break;
              }
              case "polyline-barrier": {
                if ("polyline" !== r11.type) break;
                const o6 = new d5({ geometry: r11, symbol: t4 });
                this.layer.polylineBarriers.add(o6), g6(e7.graphic, o6);
                break;
              }
              case "polygon-barrier": {
                if ("polygon" !== r11.type) break;
                const o6 = new h3({ geometry: r11, symbol: t4 });
                this.layer.polygonBarriers.add(o6), g6(e7.graphic, o6);
                break;
              }
            }
          }
      }
      (await this.view.whenLayerView(this.layer)).emit(e7.type, "create" === e7.type ? u6(e7) : b5(e7));
    };
  }
  initialize() {
    this._sketchViewModel = new re({ layer: this._graphicsLayer, view: this.view }), this.addHandles([l(() => this.enabled, (e6) => {
      e6 ? this._activate() : this._deactivate();
    }, h2), l(() => {
      const { stops: e6, pointBarriers: r11, polylineBarriers: t4, polygonBarriers: o6 } = this.layer;
      return { stops: e6, pointBarriers: r11, polylineBarriers: t4, polygonBarriers: o6 };
    }, () => {
      this.enabled && this._loadClonedGraphics();
    }), this._sketchViewModel.on(["create", "delete", "redo", "undo", "update"], this._handleSketchViewModelEvents), c(this._updatingHandles)]);
  }
  destroy() {
    this.view.map.remove(this._graphicsLayer), this._graphicsLayer.removeAll(), this._graphicsLayer = u(this._graphicsLayer), this._sketchViewModel = u(this._sketchViewModel);
  }
  get selectedNetworkFeatures() {
    return this._sketchViewModel.updateGraphics.map((e6) => w4(e6));
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  create(e6) {
    switch (this._createMode = e6, e6) {
      case "stop":
        this.layer.defaultSymbols.stops?.unlocated && (this._sketchViewModel.pointSymbol = this.layer.defaultSymbols.stops.unlocated.clone());
        break;
      case "point-barrier":
        this.layer.defaultSymbols.pointBarriers && (this._sketchViewModel.pointSymbol = this.layer.defaultSymbols.pointBarriers.clone());
        break;
      case "polyline-barrier":
        this.layer.defaultSymbols.polylineBarriers && (this._sketchViewModel.polylineSymbol = this.layer.defaultSymbols.polylineBarriers.clone());
        break;
      case "polygon-barrier":
        this.layer.defaultSymbols.polygonBarriers && (this._sketchViewModel.polygonSymbol = this.layer.defaultSymbols.polygonBarriers.clone());
    }
    switch (e6) {
      case "stop":
      case "point-barrier":
        return this._sketchViewModel.create("point");
      case "polyline-barrier":
        return this._sketchViewModel.create("polyline");
      case "polygon-barrier":
        return this._sketchViewModel.create("polygon");
    }
  }
  remove(e6) {
    const r11 = this._graphicsLayer.graphics.find((r12) => w4(r12) === e6);
    r11 && this._graphicsLayer.remove(r11), this._removeNetworkFeature(e6);
  }
  _activate() {
    this._loadClonedGraphics(), this.view.map.add(this._graphicsLayer);
  }
  _deactivate() {
    this._sketchViewModel.cancel(), this.view.map?.remove(this._graphicsLayer), this._graphicsLayer.removeAll();
  }
  _loadClonedGraphics() {
    const e6 = [this.layer.stops, this.layer.pointBarriers, this.layer.polylineBarriers, this.layer.polygonBarriers].flatMap((e7) => e7.toArray().map((e8) => {
      const r11 = e8.toGraphic();
      return r11.networkFeature = e8, r11;
    }));
    this._graphicsLayer.removeAll().addMany(e6);
  }
  _removeNetworkFeature(e6) {
    switch (e6.type) {
      case "stop":
        this.layer.stops.remove(e6);
        break;
      case "point-barrier":
        this.layer.pointBarriers.remove(e6);
        break;
      case "polyline-barrier":
        this.layer.polylineBarriers.remove(e6);
        break;
      case "polygon-barrier":
        this.layer.polygonBarriers.remove(e6);
    }
  }
};
r([m()], _2.prototype, "enabled", void 0), r([m({ constructOnly: true })], _2.prototype, "layer", void 0), r([m({ readOnly: true })], _2.prototype, "selectedNetworkFeatures", null), r([m()], _2.prototype, "updating", null), r([m({ constructOnly: true })], _2.prototype, "view", void 0), _2 = r([a("esri.views.2d.layers.support.RouteLayerInteraction")], _2);
export {
  _2 as RouteLayerInteraction
};
//# sourceMappingURL=RouteLayerInteraction-IGA2ZPI7.js.map
