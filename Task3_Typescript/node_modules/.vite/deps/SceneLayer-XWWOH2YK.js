import {
  n as n3,
  p as p5
} from "./chunk-WEJSS4SJ.js";
import {
  B
} from "./chunk-QL5YMCLB.js";
import "./chunk-4B62IUNF.js";
import "./chunk-C6WRFAXG.js";
import "./chunk-IAKXH7PU.js";
import "./chunk-3MVOHROR.js";
import "./chunk-RVXIJHL6.js";
import "./chunk-QXKZRZ4D.js";
import "./chunk-ILO2YRRS.js";
import "./chunk-KVDS5WGN.js";
import {
  t as t5
} from "./chunk-ZC6JYTVG.js";
import {
  a as a7,
  m as m4,
  p as p4,
  y
} from "./chunk-6HC7YXCP.js";
import {
  R as R2,
  V as V3
} from "./chunk-TQYXUH7I.js";
import {
  $,
  P,
  w
} from "./chunk-2JAL6FAS.js";
import "./chunk-ZN7Z7TAB.js";
import "./chunk-3ECQNGV5.js";
import "./chunk-Q77BGVST.js";
import "./chunk-TTPBKTNJ.js";
import "./chunk-ZPAWXU2P.js";
import "./chunk-KQOOCDUQ.js";
import "./chunk-PP3UNFGS.js";
import "./chunk-FYCLQ3SU.js";
import "./chunk-BGR5EVZD.js";
import "./chunk-DQG3SJJO.js";
import "./chunk-LWV5GP6V.js";
import "./chunk-QNHQE3IL.js";
import "./chunk-6EOJZ6DP.js";
import "./chunk-DRLVYVHZ.js";
import "./chunk-UZRZVWLE.js";
import {
  i as i5,
  m as m3,
  t2 as t4
} from "./chunk-LIOMEBWU.js";
import "./chunk-RTDWTAVK.js";
import "./chunk-QLJ6JQFC.js";
import "./chunk-YWGFBTRS.js";
import "./chunk-BHCIAS6L.js";
import "./chunk-TNKA4BMD.js";
import "./chunk-VKKELZ6R.js";
import "./chunk-DLD56RZZ.js";
import "./chunk-FQ4JUVCN.js";
import "./chunk-3LL6ALVC.js";
import "./chunk-NZPABYQQ.js";
import "./chunk-CCHJ3WNU.js";
import "./chunk-P4RYESYB.js";
import "./chunk-BMFPNVV7.js";
import {
  a as a8
} from "./chunk-36ZF27RV.js";
import {
  s as s2
} from "./chunk-HRJUJZF6.js";
import "./chunk-HCBZZ3ZP.js";
import "./chunk-PXOUV6KP.js";
import "./chunk-H5K53FMS.js";
import "./chunk-DRAQJS2F.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-TMFB3DKM.js";
import "./chunk-H7XUEHGR.js";
import {
  c,
  t as t3
} from "./chunk-L3O6KWVI.js";
import {
  i as i4
} from "./chunk-WBSGKMRV.js";
import {
  i as i3
} from "./chunk-PZV6BOD6.js";
import {
  l as l3
} from "./chunk-H7SHPX7W.js";
import {
  s as s4
} from "./chunk-GESOBEYT.js";
import {
  A,
  l as l4
} from "./chunk-GG4VLKUY.js";
import "./chunk-IL45XPTT.js";
import {
  f as f2
} from "./chunk-6MFKAT6L.js";
import {
  a as a6,
  u as u4
} from "./chunk-NOWX6W7R.js";
import {
  p as p3
} from "./chunk-OQ76WPLD.js";
import {
  e as e2
} from "./chunk-KSVHYEPS.js";
import {
  N,
  Y,
  ne
} from "./chunk-UTU6N7VJ.js";
import "./chunk-RV3SBM2C.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-7WKBQS4R.js";
import {
  F
} from "./chunk-SJHAGLIM.js";
import {
  n as n2,
  r as r3
} from "./chunk-Z6OMEWWC.js";
import "./chunk-ELSQQIKB.js";
import {
  j as j2
} from "./chunk-VGIEH4HM.js";
import {
  t as t2
} from "./chunk-X5GD6LFD.js";
import {
  I,
  b2,
  d,
  l as l2,
  m as m2,
  p as p2,
  s as s3
} from "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import {
  t
} from "./chunk-UDSZVLDS.js";
import "./chunk-UGXCZZ7N.js";
import {
  u as u3
} from "./chunk-AGDHKBKD.js";
import "./chunk-OC2XWDW2.js";
import "./chunk-C3JHRSMA.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-HUVZEBBO.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-I6IIPG56.js";
import {
  Z
} from "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import {
  l as l5
} from "./chunk-CL7PETHS.js";
import {
  v
} from "./chunk-CAZNHUEV.js";
import "./chunk-XDXJG3QL.js";
import "./chunk-YSCIEMYQ.js";
import "./chunk-5GBXHGKW.js";
import {
  R
} from "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-YZLWQJLF.js";
import {
  h
} from "./chunk-L7EN54WK.js";
import {
  u as u2
} from "./chunk-6QTMK7BB.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import "./chunk-KHRHKYU2.js";
import {
  d as d2
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import {
  q
} from "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import {
  r as r2
} from "./chunk-45ILJ6ZH.js";
import {
  I as I2,
  g as g2,
  h as h2
} from "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import {
  V as V2
} from "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import {
  a as a4
} from "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  U,
  a as a5,
  j
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import {
  o
} from "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  e,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import {
  n
} from "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H,
  g2 as g,
  p
} from "./chunk-ZWFY3WY5.js";
import {
  V
} from "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  a as a3,
  b,
  f2 as f,
  i as i2,
  u2 as u
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import {
  a
} from "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/support/sceneLayerCacheUtils.js
function e3({ associatedLayer: e5, serviceUpdateTimeStamp: t7 }) {
  const n4 = e5?.editingInfo?.lastEditDate, r4 = e5?.serverGens, a9 = null != n4, i7 = null != t7, s6 = a9 && i7 && t7.lastUpdate !== n4.getTime();
  return a9 && (s6 || !i7 && r4?.minServerGen !== r4?.serverGen);
}

// node_modules/@arcgis/core/layers/mixins/TemporalSceneLayer.js
var m5 = (t7) => {
  let m6 = class extends t7 {
    constructor() {
      super(...arguments), this.serviceTimeInfo = null;
    }
    get timeInfo() {
      const e5 = this.associatedLayer?.timeInfo;
      if (null == e5) return null;
      const t8 = e5.clone();
      return I2(t8, this.fieldsIndex), t8;
    }
    set timeInfo(e5) {
      I2(e5, this.fieldsIndex), this._override("timeInfo", e5);
    }
    get timeExtent() {
      return this.associatedLayer?.timeExtent;
    }
    set timeExtent(e5) {
      this._override("timeExtent", e5);
    }
    get timeOffset() {
      return this.associatedLayer?.timeOffset;
    }
    set timeOffset(e5) {
      this._override("timeOffset", e5);
    }
    get datesInUnknownTimezone() {
      return this.associatedLayer?.datesInUnknownTimezone ?? false;
    }
    set datesInUnknownTimezone(e5) {
      this._override("datesInUnknownTimezone", e5);
    }
    async loadTimeInfoFromService(e5) {
      const { serviceTimeInfo: t8 } = this;
      if (null == t8) return;
      const { startTimeField: r4, endTimeField: i7 } = t8;
      if (null == r4 && null == i7) return;
      if (e3({ associatedLayer: this.associatedLayer, serviceUpdateTimeStamp: this.serviceUpdateTimeStamp })) return;
      const s6 = async (t9) => {
        let i8 = null;
        try {
          const r5 = await this.fetchStatistics?.(t9, e5);
          i8 = r5?.stats;
        } catch {
        }
        if (null == i8) return null;
        const { minTimeStr: s7, min: n4, maxTimeStr: o2, max: l6 } = i8, a10 = t9 === r4 ? s7 ?? n4 : o2 ?? l6;
        return null != a10 ? new Date(a10) : null;
      }, [a9, m7] = await Promise.all([s6(r4), s6(i7)]);
      if (null != r4 && null == a9 || null != i7 && null == m7) return;
      const c3 = new u2({ start: a9, end: m7 });
      this.setAtOrigin("timeInfo", new u4({ endField: i7, startField: r4, fullTimeExtent: c3 }), "service");
    }
  };
  return r([m({ type: u4, json: { read: false, write: false } })], m6.prototype, "timeInfo", null), r([m({ type: u2, json: { read: false, write: false } })], m6.prototype, "timeExtent", null), r([m({ type: a6, json: { read: false, write: false } })], m6.prototype, "timeOffset", null), r([m({ type: Boolean, nonNullable: true, json: { read: false, write: false } })], m6.prototype, "datesInUnknownTimezone", null), r([m({ type: c2, readOnly: true, json: { read: { source: "timeInfo" } } })], m6.prototype, "serviceTimeInfo", void 0), m6 = r([a2("esri.layers.mixins.TemporalSceneLayer")], m6), m6;
};
var c2 = class extends l {
  constructor() {
    super(...arguments), this.endTimeField = null, this.startTimeField = null;
  }
};
r([m({ type: String })], c2.prototype, "endTimeField", void 0), r([m({ type: String })], c2.prototype, "startTimeField", void 0), c2 = r([a2("esri.layers.mixins.TemporalSceneLayer.SceneServiceTimeInfo")], c2);

// node_modules/@arcgis/core/layers/support/RangeInfo.js
var s5 = class extends l {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
r([m({ type: String, json: { read: true, write: { isRequired: true } } })], s5.prototype, "name", void 0), r([m({ type: String, json: { read: true, write: { isRequired: true } } })], s5.prototype, "field", void 0), r([m({ type: [Number], json: { read: true, write: true } })], s5.prototype, "currentRangeExtent", void 0), r([m({ type: [Number], json: { read: true, write: true } })], s5.prototype, "fullRangeExtent", void 0), r([m({ type: ["rangeInfo"], readOnly: true, json: { read: false, write: { isRequired: true } } })], s5.prototype, "type", void 0), s5 = r([a2("esri.layers.support.RangeInfo")], s5);

// node_modules/@arcgis/core/layers/support/SceneFilter.js
var u5;
var g3 = u5 = class extends l {
  constructor(e5) {
    super(e5), this.spatialRelationship = "disjoint", this.geometries = new l5(), this._geometriesSource = null;
  }
  initialize() {
    this.addHandles(a5(() => this.geometries, "after-changes", () => this.geometries = this.geometries, U));
  }
  readGeometries(e5, r4, o2) {
    Array.isArray(e5) ? this.geometries = l5.fromJSON(e5, o2) : this._geometriesSource = { url: p(e5, o2), context: o2 };
  }
  async loadGeometries(e5, o2) {
    if (null == this._geometriesSource) return;
    const { url: s6, context: t7 } = this._geometriesSource, i7 = await H(s6, { responseType: "json", signal: o2?.signal }), a9 = e5.toJSON(), p6 = i7.data.map((e6) => ({ ...e6, spatialReference: a9 }));
    this.geometries = l5.fromJSON(p6, t7), this._geometriesSource = null;
  }
  clone() {
    const e5 = new u5({ geometries: a(this.geometries), spatialRelationship: this.spatialRelationship });
    return e5._geometriesSource = this._geometriesSource, e5;
  }
};
r([m({ type: ["disjoint", "contains"], nonNullable: true, json: { write: { isRequired: true } } })], g3.prototype, "spatialRelationship", void 0), r([m({ type: l5, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } }), v({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], g3.prototype, "geometries", void 0), r([o(["web-scene", "portal-item"], "geometries")], g3.prototype, "readGeometries", null), g3 = u5 = r([a2("esri.layers.support.SceneFilter")], g3);
var h3 = g3;

// node_modules/@arcgis/core/layers/support/sceneLayerStatistics.js
async function i6({ fieldName: i7, statisticsInfo: a9, errorContext: o2, fieldsIndex: r4, path: n4, customParameters: l6, apiKey: c3, signal: f3 }) {
  if (null == a9) throw new s(`${o2}:no-cached-statistics`, "Cached statistics are not available for this layer");
  const d3 = r4.get(i7);
  if (null == d3) throw new s(`${o2}:field-unexisting`, `Field '${i7}' does not exist on the layer`);
  const h4 = a9.find((t7) => t7.name === d3.name);
  if (null == h4) throw new s(`${o2}:no-cached-statistics`, "Cached statistics for this attribute are not available");
  const m6 = V(n4, h4.href), { data: u6 } = await H(m6, { query: { f: "json", ...l6, token: c3 }, responseType: "json", signal: f3 });
  return u6;
}

// node_modules/@arcgis/core/support/zipUtils.js
async function e4(e5) {
  const r4 = [];
  for (const n4 of e5) n4.name.toLowerCase().endsWith(".zip") ? r4.push(t6(n4)) : r4.push(Promise.resolve(n4));
  return (await Promise.all(r4)).flat();
}
async function t6(e5) {
  const { BlobReader: t7, ZipReader: r4, BlobWriter: n4 } = await import("./zipjs-wrapper-ZRCFJW42.js"), a9 = [], i7 = new r4(new t7(e5));
  return (await i7.getEntries()).forEach((e6) => {
    if (e6.directory || /^__MACOS/i.test(e6.filename)) return;
    const t8 = new n4(), r5 = e6.getData?.(t8).then((t9) => new File([t9], e6.filename));
    r5 && a9.push(r5);
  }), Promise.all(a9);
}

// node_modules/@arcgis/core/layers/SceneLayer.js
var Se = /* @__PURE__ */ new Set(["3DObject", "Point"]);
var _e = s4();
var Ae = class extends m5(F(R2(l3(b2(j2(t2(S(e2(i3(a4.ClonableMixin(h))))))))))) {
  constructor(...e5) {
    super(...e5), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new V2(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = { color: false }, this.popupEnabled = true, this.popupTemplate = null, this.attributeTableTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true, this.serviceItemId = void 0;
  }
  normalizeCtorArgs(e5, t7) {
    return "string" == typeof e5 ? { url: e5, ...t7 } : e5;
  }
  destroy() {
    this._set("renderer", null), this.associatedLayer = u(this.associatedLayer);
  }
  getField(e5) {
    return this.fieldsIndex.get(e5);
  }
  getFieldDomain(e5, t7) {
    const r4 = this.getField(e5)?.domain ?? null;
    return this.associatedLayer ? N(this.associatedLayer, e5, t7, r4) : r4;
  }
  getFeatureType(e5) {
    return e5 && this.associatedLayer ? this.associatedLayer.getFeatureType(e5) : null;
  }
  get types() {
    return this.associatedLayer?.types ?? [];
  }
  get typeIdField() {
    return this.associatedLayer?.typeIdField ?? null;
  }
  get templates() {
    return this.associatedLayer?.templates ?? null;
  }
  get formTemplate() {
    return this.associatedLayer?.formTemplate ?? null;
  }
  get fieldsIndex() {
    return new Z(this.fields);
  }
  readNodePages(e5, t7, r4) {
    return "Point" === t7.layerType && (e5 = t7.pointNodePages), null == e5 || "object" != typeof e5 ? null : p4.fromJSON(e5, r4);
  }
  set elevationInfo(e5) {
    this._set("elevationInfo", e5), this.loaded && this._validateElevationInfo();
  }
  get effectiveCapabilities() {
    return this._capabilitiesFromAssociatedFeatureLayer(this.associatedLayer?.effectiveCapabilities);
  }
  get effectiveEditingEnabled() {
    return null != this.associatedLayer && Y(this.associatedLayer);
  }
  get geometryType() {
    return Pe[this.profile] || "mesh";
  }
  set renderer(e5) {
    g2(e5, this.fieldsIndex), this._set("renderer", e5);
  }
  readCachedDrawingInfo(e5) {
    return null != e5 && "object" == typeof e5 || (e5 = {}), null == e5.color && (e5.color = false), e5;
  }
  get capabilities() {
    return this._capabilitiesFromAssociatedFeatureLayer(this.associatedLayer?.capabilities);
  }
  _capabilitiesFromAssociatedFeatureLayer(e5) {
    e5 = null != e5 ? e5 : t5;
    const { query: t7, queryRelated: r4, editing: { supportsGlobalId: i7, supportsRollbackOnFailure: s6, supportsUploadWithItemId: o2, supportsGeometryUpdate: a9, supportsReturnServiceEditsInSourceSpatialReference: n4 }, data: { supportsZ: l6, supportsM: p6, isVersioned: d3, supportsAttachment: y2 }, operations: { supportsEditing: u6, supportsAdd: c3, supportsUpdate: h4, supportsDelete: f3, supportsQuery: m6, supportsQueryAttachments: g4, supportsAsyncConvert3D: v2 } } = e5, b3 = e5.operations.supportsChangeTracking, w2 = !!this.associatedLayer?.infoFor3D;
    return { query: t7, queryRelated: r4, editing: { supportsGlobalId: i7, supportsReturnServiceEditsInSourceSpatialReference: n4, supportsRollbackOnFailure: s6, supportsGeometryUpdate: w2 && a9, supportsUploadWithItemId: o2 }, data: { supportsAttachment: y2, supportsZ: l6, supportsM: p6, isVersioned: d3 }, operations: { supportsQuery: m6, supportsQueryAttachments: g4, supportsEditing: u6 && b3, supportsAdd: w2 && c3 && b3, supportsDelete: w2 && f3 && b3, supportsUpdate: h4 && b3, supportsAsyncConvert3D: v2 } };
  }
  get editingEnabled() {
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this.associatedLayer?.editingEnabled ?? false;
  }
  set editingEnabled(e5) {
    this._overrideIfSome("editingEnabled", e5);
  }
  get infoFor3D() {
    return this.associatedLayer?.infoFor3D ?? null;
  }
  get relationships() {
    return this.associatedLayer?.relationships;
  }
  get defaultPopupTemplate() {
    return this.associatedLayer || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e5, t7) {
    return !e5 && t7.fields && t7.fields.some((t8) => ("esriFieldTypeOID" === t8.type && (e5 = t8.name), !!e5)), e5 || void 0;
  }
  readGlobalIdField(e5, t7) {
    return !e5 && t7.fields && t7.fields.some((t8) => ("esriFieldTypeGlobalID" === t8.type && (e5 = t8.name), !!e5)), e5 || void 0;
  }
  get displayField() {
    return this.associatedLayer?.displayField ?? null;
  }
  readProfile(e5, t7) {
    const r4 = t7.store.profile;
    return null != r4 && Oe[r4] ? Oe[r4] : (i.getLogger(this).error("Unknown or missing profile", { profile: r4, layer: this }), "mesh-pyramids");
  }
  get useViewTime() {
    return this.associatedLayer?.useViewTime ?? true;
  }
  set useViewTime(e5) {
    this._override("useViewTime", e5);
  }
  load(e5) {
    return this.addResolvingPromise(this._load(e5)), Promise.resolve(this);
  }
  async _load(e5) {
    const t7 = null != e5 ? e5.signal : null;
    await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e5).catch(a3), await this._fetchService(t7), await Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t7), this._setAssociatedFeatureLayer(t7), this._loadFilterGeometries()]), this._validateElevationInfo(), this._applyAssociatedLayerOverrides(), this._populateFieldUsageInfo(), await this.loadTimeInfoFromService(e5), await t(this, { origin: "service" }, t7), g2(this.renderer, this.fieldsIndex), await this.finishLoadEditablePortalLayer(e5);
  }
  async beforeSave() {
    null != this.filter && (this.filter = this.filter.clone(), await this.load());
  }
  async _loadFilterGeometries() {
    if (this.filter) try {
      await this.filter.loadGeometries(this.spatialReference);
    } catch (e5) {
      i.getLogger(this).error("#_loadFilterGeometries()", this, "Failed to load filter geometries. Geometry filter will not be applied for this layer.", { error: e5 }), this.filter = null;
    }
  }
  createQuery() {
    const e5 = new R();
    return "mesh" === this.geometryType ? this.capabilities.query.supportsReturnMesh && (e5.returnGeometry = true) : (e5.returnGeometry = true, e5.returnZ = true), e5.where = this.definitionExpression || "1=1", e5.sqlFormat = "standard", e5.outFields = ["*"], e5;
  }
  queryExtent(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryExtent(e5 || this.createQuery(), t7));
  }
  queryFeatureCount(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryFeatureCount(e5 || this.createQuery(), t7));
  }
  queryFeatures(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryFeatures(e5 || this.createQuery(), t7)).then((e6) => {
      if (e6?.features) for (const t8 of e6.features) t8.layer = this, t8.sourceLayer = this;
      return e6;
    });
  }
  async queryRelatedFeatures(e5, t7) {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeatures(e5, t7);
  }
  async queryRelatedFeaturesCount(e5, t7) {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeaturesCount(e5, t7);
  }
  async queryCachedAttributes(e5, t7) {
    const r4 = h2(this.fieldsIndex, await n3(this, p5(this)));
    return B(this.parsedUrl?.path ?? "", this.attributeStorageInfo ?? [], e5, t7, r4, this.apiKey, this.customParameters);
  }
  async queryCachedFeature(e5, r4) {
    const i7 = await this.queryCachedAttributes(e5, [r4]);
    if (!i7 || 0 === i7.length) throw new s("scenelayer:feature-not-in-cached-data", "Feature not found in cached data");
    const s6 = new d2();
    return s6.attributes = i7[0], s6.layer = this, s6.sourceLayer = this, s6;
  }
  queryObjectIds(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryObjectIds(e5 || this.createQuery(), t7));
  }
  queryAttachments(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryAttachments(e5, t7));
  }
  getFieldUsageInfo(e5) {
    const t7 = { supportsLabelingInfo: false, supportsRenderer: false, supportsPopupTemplate: false, supportsLayerQuery: false };
    return this.loaded ? this._fieldUsageInfo[e5] || t7 : (i.getLogger(this).error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t7);
  }
  createPopupTemplate(e5) {
    return p3(this, e5);
  }
  _getAssociatedLayerForQuery() {
    const e5 = this.associatedLayer;
    return e5?.loaded ? Promise.resolve(e5) : this._loadAssociatedLayerForQuery();
  }
  async _loadAssociatedLayerForQuery() {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    try {
      await this.associatedLayer.load();
    } catch (e5) {
      throw new s("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", { layer: this, error: e5 });
    }
    return this.associatedLayer;
  }
  hasCachedStatistics(e5) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t7) => t7.name === e5);
  }
  async queryCachedStatistics(e5, t7) {
    return await this.load(t7), await this.fetchStatistics(e5, t7);
  }
  async saveAs(e5, t7) {
    return this._debouncedSaveOperations(V3.SAVE_AS, { ...t7, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, e5);
  }
  async save() {
    const e5 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" };
    return this._debouncedSaveOperations(V3.SAVE, e5);
  }
  async applyEdits(e5, t7) {
    const { applyEdits: r4 } = await import("./editingSupport-PKXMF3HO.js");
    let i7 = t7;
    await this.load();
    const s6 = this.associatedLayer;
    if (!s6) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    await s6.load();
    const { globalIdField: a9 } = s6, n4 = !!s6.infoFor3D, l6 = i7?.globalIdUsed ?? true;
    if (n4 && null == a9) throw new s(`${this.type}-layer:not-editable`, "Valid globalIdField expected on editable SceneLayer");
    if (n4 && !l6) throw new s(`${this.type}-layer:globalid-required`, "globalIdUsed must not be false for SceneLayer editing as globalIds are required.");
    return g(s6.url) && n4 && null != e5.deleteFeatures && null != a9 && (i7 = { ...i7, globalIdToObjectId: await ne(s6, e5.deleteFeatures, a9) }), r4(this, s6.source, e5, i7);
  }
  async uploadAssets(e5, t7) {
    if (await this.load(), null == this.associatedLayer) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), this.associatedLayer.uploadAssets(e5, t7);
  }
  on(e5, t7) {
    return super.on(e5, t7);
  }
  async convertMesh(e5, t7) {
    t7 ??= {};
    const r4 = (e6) => {
      throw i.getLogger(this).error(".convertMesh()", e6.message), e6;
    };
    await this.load(), this.infoFor3D || r4(new s("invalid:layer", "SceneLayer has no capability for mesh conversion"));
    const i7 = await this.extractAndFilterFiles(e5), s6 = i7.reduce((e6, t8) => r3(this.infoFor3D, t8) ? e6 + 1 : e6, 0);
    0 === s6 && r4(new i5()), s6 > 1 && r4(new m3());
    const a9 = this.spatialReference, l6 = t7.location ?? new _({ x: 0, y: 0, z: 0, spatialReference: a9 }), p6 = l6.spatialReference.isGeographic ? "local" : "georeferenced", { default: d3 } = await import("./Mesh-E4DPAAZQ.js"), y2 = d3.createWithExternalSource(l6, { type: "client", files: i7 }, { vertexSpace: p6, transform: t4(l6.spatialReference), unitConversionDisabled: true }), [u6] = await this.uploadAssets([y2], { ...t7, useAssetOrigin: !t7.location });
    return u6;
  }
  async extractAndFilterFiles(e5) {
    await this.load();
    const t7 = this.infoFor3D;
    if (!t7) return e5;
    return (await e4(e5)).filter((e6) => n2(t7, e6));
  }
  validateLayer(e5) {
    if (e5.layerType && !Se.has(e5.layerType)) throw new s("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", { layerType: e5.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    if (this.version.major > 2) throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    function t7(e6, t8) {
      let r4 = false, i7 = false;
      if (null == e6) r4 = true, i7 = true;
      else {
        const s6 = t8 && t8.isGeographic;
        switch (e6) {
          case "east-north-up":
          case "earth-centered":
            r4 = true, i7 = s6;
            break;
          case "vertex-reference-frame":
            r4 = true, i7 = !s6;
            break;
          default:
            r4 = false;
        }
      }
      if (!r4) throw new s("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!i7) throw new s("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t7(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e5 = [];
    if ("points" === this.profile) e5.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile) throw new s("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e5.push("3DObject");
    }
    return e5;
  }
  _populateFieldUsageInfo() {
    if (this._fieldUsageInfo = {}, this.fields) for (const e5 of this.fields) {
      const t7 = !!this.attributeStorageInfo?.some((t8) => t8.name === e5.name), r4 = !!this.associatedLayer?.fields?.some((t8) => t8 && e5.name === t8.name), i7 = { supportsLabelingInfo: t7, supportsRenderer: t7, supportsPopupTemplate: t7 || r4, supportsLayerQuery: r4 };
      this._fieldUsageInfo[e5.name] = i7;
    }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPropertyOverrides(), this._applyAssociatedLayerExtentOverride(), this._applyAssociatedLayerPrivileges();
  }
  _applyAssociatedLayerFieldsOverrides() {
    if (!this.associatedLayer?.fields) return;
    let e5 = null;
    for (const t7 of this.associatedLayer.fields) {
      const r4 = this.getField(t7.name);
      r4 ? (!r4.domain && t7.domain && (r4.domain = t7.domain.clone()), r4.editable = t7.editable, r4.nullable = t7.nullable, r4.length = t7.length) : (e5 || (e5 = this.fields ? this.fields.slice() : []), e5.push(t7.clone()));
    }
    e5 && this._set("fields", e5);
  }
  _applyAssociatedLayerPropertyOverrides() {
    if (!this.associatedLayer) return;
    const e5 = ["popupTemplate", "popupEnabled", "attributeTableTemplate"], t7 = n(this);
    for (let r4 = 0; r4 < e5.length; r4++) {
      const i7 = e5[r4], s6 = this.originIdOf(i7), o2 = this.associatedLayer.originIdOf(i7);
      s6 < o2 && (o2 === e.SERVICE || o2 === e.PORTAL_ITEM) && t7.setAtOrigin(i7, this.associatedLayer[i7], o2);
    }
  }
  _applyAssociatedLayerExtentOverride() {
    const e5 = this.associatedLayer?.getAtOrigin("fullExtent", "service");
    if (null == this.associatedLayer?.infoFor3D || !e5 || !g(this.associatedLayer?.url) || !e3(this)) return;
    n(this).setAtOrigin("fullExtent", e5.clone(), e.SERVICE);
  }
  _applyAssociatedLayerPrivileges() {
    const e5 = this.associatedLayer;
    e5 && (this._set("userHasEditingPrivileges", e5.userHasEditingPrivileges), this._set("userHasFullEditingPrivileges", e5.userHasFullEditingPrivileges), this._set("userHasUpdateItemPrivileges", e5.userHasUpdateItemPrivileges));
  }
  async _setAssociatedFeatureLayer(e5) {
    if (["mesh-pyramids", "points"].includes(this.profile)) try {
      const { serverUrl: t7, layerId: r4, portalItem: i7 } = await s2(`${this.url}/layers/${this.layerId}`, { sceneLayerItem: this.portalItem, customParameters: this.customParameters, apiKey: this.apiKey, signal: e5 }), s6 = await a8.FeatureLayer();
      this.associatedLayer = new s6({ url: t7, customParameters: this.customParameters, layerId: r4, portalItem: i7 }), await this.associatedLayer.load();
    } catch (t7) {
      b(t7) || this._logWarningOnPopupEnabled();
    }
  }
  async _logWarningOnPopupEnabled() {
    const e5 = new AbortController();
    this.addHandles(i2(e5));
    try {
      await j(() => this.popupEnabled && null != this.popupTemplate, e5.signal);
    } catch (r4) {
      return void f(r4);
    }
    const t7 = `this SceneLayer: ${this.title}`;
    null == this.attributeStorageInfo ? i.getLogger(this).warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${t7}`) : i.getLogger(this).info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${t7}`);
  }
  _validateElevationInfo() {
    const e5 = this.elevationInfo;
    "mesh-pyramids" === this.profile && $(i.getLogger(this), P("Mesh scene layers", "relative-to-scene", e5)), $(i.getLogger(this), w("Scene layers", e5));
  }
  async fetchStatistics(e5, t7) {
    return await i6({ fieldName: e5, statisticsInfo: this.statisticsInfo, errorContext: "scenelayer", fieldsIndex: this.fieldsIndex, path: this.parsedUrl?.path ?? "", customParameters: this.customParameters, apiKey: this.apiKey, signal: t7?.signal });
  }
};
r([m({ types: { key: "type", base: t3, typeMap: { selection: c } }, json: { origins: { "web-scene": { name: "layerDefinition.featureReduction", write: true }, "portal-item": { name: "layerDefinition.featureReduction", write: true } } } })], Ae.prototype, "featureReduction", void 0), r([m({ type: [s5], json: { read: false, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: true }, "portal-item": { name: "layerDefinition.rangeInfos", write: true } } } })], Ae.prototype, "rangeInfos", void 0), r([m({ json: { read: false } })], Ae.prototype, "associatedLayer", void 0), r([m({ type: ["show", "hide"] })], Ae.prototype, "listMode", void 0), r([m({ type: ["ArcGISSceneServiceLayer"] })], Ae.prototype, "operationalLayerType", void 0), r([m({ json: { read: false }, readOnly: true })], Ae.prototype, "type", void 0), r([m({ ..._e.fields, readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Ae.prototype, "fields", void 0), r([m()], Ae.prototype, "types", null), r([m()], Ae.prototype, "typeIdField", null), r([m()], Ae.prototype, "templates", null), r([m()], Ae.prototype, "formTemplate", null), r([m({ readOnly: true, clonable: false })], Ae.prototype, "fieldsIndex", null), r([m({ type: i4, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], Ae.prototype, "floorInfo", void 0), r([m(_e.outFields)], Ae.prototype, "outFields", void 0), r([m({ type: p4, readOnly: true, json: { read: false } })], Ae.prototype, "nodePages", void 0), r([o("service", "nodePages", ["nodePages", "pointNodePages"])], Ae.prototype, "readNodePages", null), r([m({ type: [a7], readOnly: true })], Ae.prototype, "materialDefinitions", void 0), r([m({ type: [y], readOnly: true })], Ae.prototype, "textureSetDefinitions", void 0), r([m({ type: [m4], readOnly: true })], Ae.prototype, "geometryDefinitions", void 0), r([m({ readOnly: true })], Ae.prototype, "serviceUpdateTimeStamp", void 0), r([m({ readOnly: true })], Ae.prototype, "attributeStorageInfo", void 0), r([m({ readOnly: true })], Ae.prototype, "statisticsInfo", void 0), r([m({ type: V2.ofType(Number), nonNullable: true, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.excludeObjectIds", write: { enabled: true } } })], Ae.prototype, "excludeObjectIds", void 0), r([m({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], Ae.prototype, "definitionExpression", void 0), r([m({ type: h3, json: { name: "layerDefinition.polygonFilter", write: { enabled: true, allowNull: true }, origins: { service: { read: false, write: false } } } })], Ae.prototype, "filter", void 0), r([m({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], Ae.prototype, "path", void 0), r([m(m2)], Ae.prototype, "elevationInfo", null), r([m({ readOnly: true, json: { read: false } })], Ae.prototype, "effectiveCapabilities", null), r([m({ readOnly: true })], Ae.prototype, "effectiveEditingEnabled", null), r([m({ type: String })], Ae.prototype, "geometryType", null), r([m(p2)], Ae.prototype, "labelsVisible", void 0), r([m({ type: [A], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: l4 }, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: l4 }, write: true } })], Ae.prototype, "labelingInfo", void 0), r([m(d)], Ae.prototype, "legendEnabled", void 0), r([m({ type: Number, json: { origins: { "web-document": { default: 1, write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(e5, t7) {
  if ("number" == typeof e5 && e5 >= 0 && e5 <= 1) return e5;
  const r4 = t7.layerDefinition?.drawingInfo?.transparency;
  return void 0 !== r4 ? r2(r4) : void 0;
} } }, "portal-item": { write: true }, service: { read: false } } } })], Ae.prototype, "opacity", void 0), r([m({ type: ["Low", "High"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Ae.prototype, "priority", void 0), r([m({ type: ["Labels"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Ae.prototype, "semantic", void 0), r([m({ types: u3, json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: true }, value: null })], Ae.prototype, "renderer", null), r([m({ json: { read: false } })], Ae.prototype, "cachedDrawingInfo", void 0), r([o("service", "cachedDrawingInfo")], Ae.prototype, "readCachedDrawingInfo", null), r([m({ readOnly: true, json: { read: false } })], Ae.prototype, "capabilities", null), r([m({ type: Boolean, json: { read: false } })], Ae.prototype, "editingEnabled", null), r([m({ readOnly: true, json: { write: false, read: false } })], Ae.prototype, "infoFor3D", null), r([m({ readOnly: true, json: { write: false, read: false } })], Ae.prototype, "relationships", null), r([m(l2)], Ae.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], Ae.prototype, "popupTemplate", void 0), r([m({ readOnly: true, json: { read: false } })], Ae.prototype, "defaultPopupTemplate", null), r([m(I)], Ae.prototype, "attributeTableTemplate", void 0), r([m({ type: String, json: { read: false } })], Ae.prototype, "objectIdField", void 0), r([o("service", "objectIdField", ["objectIdField", "fields"])], Ae.prototype, "readObjectIdField", null), r([m({ type: String, json: { read: false } })], Ae.prototype, "globalIdField", void 0), r([o("service", "globalIdField", ["globalIdField", "fields"])], Ae.prototype, "readGlobalIdField", null), r([m({ readOnly: true, type: String, json: { read: false } })], Ae.prototype, "displayField", null), r([m({ type: String, json: { read: false } })], Ae.prototype, "profile", void 0), r([o("service", "profile", ["store.profile"])], Ae.prototype, "readProfile", null), r([m({ readOnly: true, type: String, json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: false } })], Ae.prototype, "normalReferenceFrame", void 0), r([m(s3)], Ae.prototype, "screenSizePerspectiveEnabled", void 0), r([m({ json: { read: false, origins: { service: { read: true } } } })], Ae.prototype, "serviceItemId", void 0), r([m(f2)], Ae.prototype, "useViewTime", null), Ae = r([a2("esri.layers.SceneLayer")], Ae);
var Oe = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" };
var Pe = { "mesh-pyramids": "mesh", points: "point" };
var Ee = Ae;
export {
  Ee as default
};
//# sourceMappingURL=SceneLayer-XWWOH2YK.js.map
