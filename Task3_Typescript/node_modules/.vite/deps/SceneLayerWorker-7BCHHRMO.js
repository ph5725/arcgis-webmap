import "./chunk-QL5YMCLB.js";
import "./chunk-4B62IUNF.js";
import "./chunk-C6WRFAXG.js";
import "./chunk-IAKXH7PU.js";
import "./chunk-3MVOHROR.js";
import "./chunk-RVXIJHL6.js";
import "./chunk-QXKZRZ4D.js";
import "./chunk-ILO2YRRS.js";
import "./chunk-KVDS5WGN.js";
import "./chunk-ZN7Z7TAB.js";
import "./chunk-3ECQNGV5.js";
import "./chunk-Q77BGVST.js";
import "./chunk-TTPBKTNJ.js";
import "./chunk-ZPAWXU2P.js";
import "./chunk-KQOOCDUQ.js";
import "./chunk-PP3UNFGS.js";
import "./chunk-FYCLQ3SU.js";
import "./chunk-BGR5EVZD.js";
import "./chunk-DQG3SJJO.js";
import "./chunk-LWV5GP6V.js";
import "./chunk-QNHQE3IL.js";
import "./chunk-6EOJZ6DP.js";
import "./chunk-DRLVYVHZ.js";
import "./chunk-UZRZVWLE.js";
import "./chunk-HHJDK6FG.js";
import "./chunk-RTDWTAVK.js";
import "./chunk-QLJ6JQFC.js";
import {
  d,
  n as n3
} from "./chunk-24KTNAIE.js";
import "./chunk-TNKA4BMD.js";
import "./chunk-VKKELZ6R.js";
import "./chunk-DLD56RZZ.js";
import {
  i,
  i2
} from "./chunk-HXR4TQII.js";
import "./chunk-FQ4JUVCN.js";
import "./chunk-3LL6ALVC.js";
import "./chunk-NZPABYQQ.js";
import "./chunk-CCHJ3WNU.js";
import "./chunk-H5K53FMS.js";
import "./chunk-DRAQJS2F.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-TMFB3DKM.js";
import "./chunk-H7XUEHGR.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  n as n2
} from "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import {
  T
} from "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import "./chunk-N3XLUQJI.js";
import "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import {
  n
} from "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import {
  r
} from "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import "./chunk-GZ2P4SCJ.js";
import "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n4;
var e;
!function(n8) {
  n8[n8.None = 0] = "None", n8[n8.Int16 = 1] = "Int16", n8[n8.Int32 = 2] = "Int32";
}(n4 || (n4 = {})), function(n8) {
  n8[n8.Replace = 0] = "Replace", n8[n8.Outside = 1] = "Outside", n8[n8.Inside = 2] = "Inside", n8[n8.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n5 || (n5 = new Promise((t) => import("./i3s-O6XSX356.js").then((t2) => t2.i).then(({ default: e4 }) => {
    const n8 = e4({ locateFile: i3, onRuntimeInitialized: () => t(n8) });
    delete n8.then;
  })).catch((t) => {
    throw t;
  })), n5;
}
function i3(e4) {
  return n(`esri/libs/i3s/${e4}`);
}
var n5;

// node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var n7 = class {
  constructor(s, e4, t, o2, r4, i5) {
    this.layout = s, this.interleavedVertexData = e4, this.indices = t, this.hasColors = o2, this.hasModifications = r4, this.positionData = i5;
  }
};
var p = class {
  constructor(s, e4, t, o2, r4, i5, h3) {
    this.componentOffsets = s, this.featureIds = e4, this.anchorIds = t, this.anchors = o2, this.transformedGeometry = r4, this.globalTrafo = i5, this.obb = h3;
  }
};
var u = new r({ deallocator: null });
var c = n2();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var o;
var r3;
var a;
var d2;
var c2;
!function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.Culled = 1] = "Culled", e4[e4.NotChecked = 2] = "NotChecked";
}(o || (o = {})), function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.PotentiallyModified = 1] = "PotentiallyModified", e4[e4.Culled = 2] = "Culled", e4[e4.Unknown = 3] = "Unknown", e4[e4.NotChecked = 4] = "NotChecked";
}(r3 || (r3 = {}));
!function(e4) {
  e4[e4.Unknown = 0] = "Unknown", e4[e4.Uncached = 1] = "Uncached", e4[e4.Cached = 2] = "Cached";
}(a || (a = {})), function(e4) {
  e4[e4.None = 0] = "None", e4[e4.MaxScreenThreshold = 1] = "MaxScreenThreshold", e4[e4.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e4[e4.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e4[e4.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
}(d2 || (d2 = {})), function(e4) {
  e4[e4.Hole = 0] = "Hole", e4[e4.Leaf = 1] = "Leaf";
}(c2 || (c2 = {}));

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function u2(e4) {
  E = await U();
  const r4 = [e4.geometryBuffer];
  return { result: A(E, e4, r4), transferList: r4 };
}
async function m(e4) {
  E = await U();
  const r4 = [e4.geometryBuffer], { geometryBuffer: t } = e4, o2 = t.byteLength, n8 = E._malloc(o2), s = new Uint8Array(E.HEAPU8.buffer, n8, o2);
  s.set(new Uint8Array(t));
  const i5 = E.dracoDecompressPointCloudData(n8, s.byteLength);
  if (E._free(n8), i5.error.length > 0) throw new Error(`i3s.wasm: ${i5.error}`);
  const a2 = i5.featureIds?.length > 0 ? i5.featureIds.slice() : null, f2 = i5.positions.slice();
  return a2 && r4.push(a2.buffer), r4.push(f2.buffer), { result: { positions: f2, featureIds: a2 }, transferList: r4 };
}
async function y(e4) {
  await U(), S(e4);
  const r4 = { buffer: e4.buffer };
  return { result: r4, transferList: [r4.buffer] };
}
async function p2(e4) {
  await U(), j(e4);
}
async function d3(e4) {
  E = await U(), E.setLegacySchema(e4.context, e4.jsonSchema);
}
async function h2(e4) {
  const { localMatrix: n8, origin: s, positions: i5, vertexSpace: a2 } = e4, f2 = f.fromJSON(e4.inSpatialReference), c3 = f.fromJSON(e4.outSpatialReference);
  let l;
  const [{ projectBuffer: u3 }, { initializeProjection: m2 }] = await Promise.all([import("./projectBuffer-JIEFHW43.js"), import("./projectionUtils-BHBZZUH3.js")]);
  await m2(f2, c3);
  const y2 = [0, 0, 0];
  if (!u3(s, f2, 0, y2, c3, 0)) throw new Error("Failed to project");
  if ("georeferenced" === a2.type && null == a2.origin) {
    if (l = new Float64Array(i5.length), !u3(i5, f2, 0, l, c3, 0, l.length / 3)) throw new Error("Failed to project");
  } else {
    const e5 = "georeferenced" === a2.type ? i.fromJSON(a2) : i2.fromJSON(a2), { projectMeshVertexPositions: r4 } = await import("./projectMeshVertexPositions-RIXUVE2L.js"), s2 = r4({ vertexAttributes: { position: i5 }, transform: n8 ? { localMatrix: n8 } : void 0, vertexSpace: e5, spatialReference: f2 }, c3);
    if (!s2) throw new Error("Failed to project");
    l = s2;
  }
  const p3 = l.length, [d4, h3, b2] = y2;
  for (let r4 = 0; r4 < p3; r4 += 3) l[r4] -= d4, l[r4 + 1] -= h3, l[r4 + 2] -= b2;
  return { result: { projected: l, original: i5, projectedOrigin: y2 }, transferList: [l.buffer, i5.buffer] };
}
async function b({ normalMatrix: r4, normals: t }) {
  const o2 = new Float32Array(t.length);
  return n3(o2, t, r4), T(r4) && d(o2, o2), { result: { transformed: o2, original: t }, transferList: [o2.buffer, t.buffer] };
}
function g(e4) {
  x(e4);
}
var w;
var E;
function j(e4) {
  if (!E) return;
  const r4 = e4.modifications, t = E._malloc(8 * r4.length), o2 = new Float64Array(E.HEAPU8.buffer, t, r4.length);
  for (let n8 = 0; n8 < r4.length; ++n8) o2[n8] = r4[n8];
  E.setModifications(e4.context, t, r4.length, e4.isGeodetic), E._free(t);
}
function A(e4, r4, t) {
  const { context: o2, globalTrafo: n8, mbs: s, obbData: a2, elevationOffset: l, geometryBuffer: u3, geometryDescriptor: m2, indexToVertexProjector: y2, vertexToRenderProjector: p3 } = r4, d4 = e4._malloc(u3.byteLength), h3 = 33, b2 = e4._malloc(h3 * Float64Array.BYTES_PER_ELEMENT), g2 = new Uint8Array(e4.HEAPU8.buffer, d4, u3.byteLength);
  g2.set(new Uint8Array(u3));
  const w2 = new Float64Array(e4.HEAPU8.buffer, b2, h3);
  _(w2, [NaN, NaN, NaN]);
  let E2 = w2.byteOffset + 3 * w2.BYTES_PER_ELEMENT, j2 = new Float64Array(w2.buffer, E2);
  _(j2, n8), E2 += 16 * w2.BYTES_PER_ELEMENT, j2 = new Float64Array(w2.buffer, E2), _(j2, s), E2 += 4 * w2.BYTES_PER_ELEMENT, a2 && (j2 = new Float64Array(w2.buffer, E2), _(j2, a2));
  const A2 = m2, L3 = { isDraco: false, isLegacy: false, color: r4.layouts.some((e5) => e5.some((e6) => "color" === e6.name)), normal: r4.needNormals && r4.layouts.some((e5) => e5.some((e6) => "normalCompressed" === e6.name)), uv0: r4.layouts.some((e5) => e5.some((e6) => "uv0" === e6.name)), uvRegion: r4.layouts.some((e5) => e5.some((e6) => "uvRegion" === e6.name)), featureIndex: A2.featureIndex }, S2 = e4.process(o2, !!r4.obbData, d4, g2.byteLength, A2, L3, b2, l, y2, p3, r4.normalReferenceFrame);
  if (e4._free(b2), e4._free(d4), S2.error.length > 0) throw new Error(`i3s.wasm: ${S2.error}`);
  if (S2.discarded) return null;
  const x2 = S2.componentOffsets.length > 0 ? S2.componentOffsets.slice() : null, P2 = S2.featureIds.length > 0 ? S2.featureIds.slice() : null, U2 = S2.anchorIds.length > 0 ? Array.from(S2.anchorIds) : null, M2 = S2.anchors.length > 0 ? Array.from(S2.anchors) : null, N = S2.interleavedVertedData.slice().buffer, I = S2.indicesType === n4.Int16 ? new Uint16Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 2).slice() : new Uint32Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 4).slice(), F = S2.positions.slice(), { buffer: T2, byteOffset: B, byteLength: O } = S2.positionIndices, R = S2.positionIndicesType === n4.Int16 ? new Uint16Array(T2, B, O / 2).slice() : new Uint32Array(T2, B, O / 4).slice(), v = new n7(r4.layouts[0], N, I, S2.hasColors, S2.hasModifications, { data: F, indices: R });
  return P2 && t.push(P2.buffer), x2 && t.push(x2.buffer), t.push(N), t.push(I.buffer), t.push(F.buffer), t.push(R.buffer), new p(x2, P2, U2, M2, v, n8, S2.obb);
}
function L2(e4) {
  return 0 === e4 ? r3.Unmodified : 1 === e4 ? r3.PotentiallyModified : 2 === e4 ? r3.Culled : r3.Unknown;
}
function S(e4) {
  if (!E) return;
  const { context: r4, buffer: t } = e4, o2 = E._malloc(t.byteLength), n8 = t.byteLength / Float64Array.BYTES_PER_ELEMENT, s = new Float64Array(E.HEAPU8.buffer, o2, n8), i5 = new Float64Array(t);
  s.set(i5), E.filterOBBs(r4, o2, n8), i5.set(s), E._free(o2);
}
function x(e4) {
  E && 0 === E.destroy(e4) && (E = null);
}
function _(e4, r4) {
  for (let t = 0; t < r4.length; ++t) e4[t] = r4[t];
}
async function P() {
  E || await U();
}
async function U() {
  return E || (E = await (w ??= e2())), E;
}
var M = { transform: (e4, r4) => E && A(E, e4, r4), destroy: x };
export {
  g as destroyContext,
  m as dracoDecompressPointCloudData,
  y as filterObbsForModifications,
  S as filterObbsForModificationsSync,
  P as initialize,
  L2 as interpretObbModificationResults,
  u2 as process,
  h2 as project,
  d3 as setLegacySchema,
  p2 as setModifications,
  j as setModificationsSync,
  M as test,
  b as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-7BCHHRMO.js.map
