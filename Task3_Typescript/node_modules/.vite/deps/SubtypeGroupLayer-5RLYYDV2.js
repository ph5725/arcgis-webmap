import {
  L as L2,
  w2
} from "./chunk-OFHPFWHF.js";
import {
  k as k3
} from "./chunk-MZJEBIXX.js";
import {
  T as T2
} from "./chunk-76QJRCNC.js";
import {
  u as u7
} from "./chunk-VGXBH5PT.js";
import {
  V as V3,
  k as k2
} from "./chunk-2SK5ARBZ.js";
import "./chunk-RNXMAHSA.js";
import "./chunk-VD4HSDHE.js";
import "./chunk-WBSGKMRV.js";
import {
  i as i2
} from "./chunk-PZV6BOD6.js";
import {
  t as t3
} from "./chunk-DD7VYTDF.js";
import {
  l as l3
} from "./chunk-H7SHPX7W.js";
import {
  a as a6
} from "./chunk-XPKVLOAO.js";
import {
  s as s2
} from "./chunk-GESOBEYT.js";
import {
  a as a8
} from "./chunk-3IU6SQCC.js";
import {
  A as A3,
  l as l4
} from "./chunk-GG4VLKUY.js";
import "./chunk-IL45XPTT.js";
import {
  c as c3
} from "./chunk-6MFKAT6L.js";
import {
  u as u6
} from "./chunk-NOWX6W7R.js";
import {
  p as p4
} from "./chunk-OQ76WPLD.js";
import {
  e as e2
} from "./chunk-KSVHYEPS.js";
import {
  A as A2,
  B,
  C,
  D,
  E,
  F as F2,
  H,
  L,
  O,
  P,
  Q,
  R as R2,
  T,
  U as U2,
  Y,
  q as q2,
  v as v2
} from "./chunk-UTU6N7VJ.js";
import "./chunk-RV3SBM2C.js";
import "./chunk-4GXVCEW4.js";
import {
  f as f2
} from "./chunk-IUQBXXYO.js";
import "./chunk-7WKBQS4R.js";
import {
  F
} from "./chunk-SJHAGLIM.js";
import "./chunk-Z6OMEWWC.js";
import {
  A
} from "./chunk-MULCOUFY.js";
import {
  j as j2
} from "./chunk-VGIEH4HM.js";
import {
  p as p2
} from "./chunk-XLF2NMGX.js";
import {
  t as t2
} from "./chunk-X5GD6LFD.js";
import {
  b2 as b,
  c,
  d,
  j,
  l as l2,
  p as p3,
  u as u4,
  v
} from "./chunk-G4PMFSAZ.js";
import {
  a as a5
} from "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import "./chunk-UGXCZZ7N.js";
import "./chunk-K5LVZUBF.js";
import "./chunk-J7LSFQNH.js";
import {
  j as j3
} from "./chunk-M2UZRY7C.js";
import {
  m as m2
} from "./chunk-HUVZEBBO.js";
import {
  $
} from "./chunk-VLPG2W66.js";
import {
  a as a7
} from "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import {
  S as S2,
  c as c2,
  u as u5
} from "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-5GBXHGKW.js";
import {
  R
} from "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import {
  h as h2
} from "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import {
  t
} from "./chunk-5SRIFOTG.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import {
  q
} from "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import {
  I as I2,
  g
} from "./chunk-VCRP2PLV.js";
import {
  r as r3
} from "./chunk-BDLVUYG2.js";
import {
  n
} from "./chunk-6QA2BVC5.js";
import {
  n as n2
} from "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import {
  V as V2
} from "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import {
  a as a4
} from "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  U,
  l
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import {
  p
} from "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import {
  o
} from "./chunk-JUAPMINU.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import {
  r as r2
} from "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2,
  u as u2
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  w
} from "./chunk-ZWFY3WY5.js";
import {
  I,
  V
} from "./chunk-LQFTAGIV.js";
import {
  u
} from "./chunk-S7IJH524.js";
import {
  a as a3,
  h,
  k,
  u2 as u3
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import {
  a,
  e
} from "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/support/subtypeGroupLayerUtils.js
var f3 = { key: "type", base: a7, errorContext: "renderer", typeMap: { simple: m2, "unique-value": $, "class-breaks": j3 } };
var i3 = u2({ types: f3 });
function c4(e3, r4) {
  const s3 = e3.drawingInfo?.renderer, o2 = s3 ? i3(s3, e3, r4) : null;
  if ("simple" !== o2?.type) return;
  return w2(o2.symbol, null) ? o2.symbol.clone() : null;
}
var u8 = ["#ed5151", "#149ece", "#a7c636", "#9e559c", "#fc921f", "#ffde3e", "#f789d8", "#b7814a", "#3caf99", "#6b6bd6", "#b54779", "#7f7f7f"];
function a9(r4, s3) {
  return T2(u8, r4, { offset: true, shuffle: true }).reverse().map((e3) => {
    const r5 = s3.clone();
    return "cim" === r5.type ? k3(r5, e3) : L2(r5, e3), new m2({ symbol: r5 });
  });
}

// node_modules/@arcgis/core/layers/support/SubtypeSublayer.js
var M = s2();
var U3 = 0;
function k4(e3, t4) {
  let r4 = e3.json.write;
  return "object" != typeof r4 && (r4 = e3.json.write = {}), r4.ignoreOrigin = true, t4?.spatialOnly && (r4.layerContainerTypes = a5), e3;
}
function Q2(e3) {
  const t4 = { write: { ignoreOrigin: true } };
  return e3?.name && (t4.name = e3.name), "object" == typeof t4.write && (e3?.spatialOnly && (t4.write.layerContainerTypes = a5), e3?.target && (t4.write.target = e3.target)), t4;
}
function B2(e3) {
  return new m2({ symbol: H2(e3) });
}
function H2(e3) {
  switch (e3) {
    case "point":
    case "multipoint":
      return S2.clone();
    case "polyline":
      return u5.clone();
    case "polygon":
    case "multipatch":
      return c2.clone();
    default:
      return null;
  }
}
function J(e3, t4) {
  return !!t4 && ("unique-value" === e3?.type && null != e3.field && e3.field.toLowerCase() === t4.toLowerCase() && !e3.field2 && !e3.field3 && !e3.valueExpression);
}
function W(e3, t4) {
  return null == e3 ? null : t4.subtypes?.find((t5) => t5.code === e3);
}
function z(e3, t4) {
  let r4 = null;
  switch (t4.geometryType) {
    case "esriGeometryPoint":
    case "esriGeometryMultipoint":
      r4 = "point";
      break;
    case "esriGeometryPolyline":
      r4 = "line";
      break;
    case "esriGeometryPolygon":
    case "esriGeometryMultiPatch":
      r4 = "polygon";
      break;
    default:
      t4.type, r4 = null;
  }
  const i4 = {}, o2 = W(e3, t4);
  if (null != o2) {
    const { defaultValues: e4 } = o2;
    for (const t5 in e4) i4[t5] = e4[t5];
  }
  return i4[t4.subtypeField] = e3, new a8({ name: "New Feature", drawingTool: r4, prototype: { attributes: i4 } });
}
var K = class extends S(a4.ClonableMixin(n2.IdentifiableMixin(p))) {
  constructor(e3) {
    super(e3), this.attributeTableTemplate = null, this.charts = null, this.editingEnabled = true, this.fieldOverrides = null, this.fieldsIndex = null, this.formTemplate = null, this.id = `${Date.now().toString(16)}-subtype-sublayer-${U3++}`, this.type = "subtype-sublayer", this.labelsVisible = true, this.labelingInfo = null, this.layerType = "ArcGISFeatureLayer", this.legendEnabled = true, this.listMode = "show", this.minScale = 0, this.maxScale = 0, this.opacity = 1, this.parent = null, this.popupEnabled = true, this.popupTemplate = null, this.subtypeCode = null, this.templates = null, this.title = null, this.visible = true;
  }
  load(e3) {
    return g(this.renderer, this.fieldsIndex), Promise.resolve(this);
  }
  get _titleCreator() {
    const e3 = this._get("_titleCreator");
    return u3(e3), new u7({ fieldsIndex: this.fieldsIndex, objectIdField: this.objectIdField, displayField: this.parent?.displayField ?? "", fields: this.fields, effectivePopupTemplate: this.popupTemplate ?? this.defaultPopupTemplate });
  }
  get capabilities() {
    return this.parent?.capabilities;
  }
  get effectiveCapabilities() {
    return this.parent?.effectiveCapabilities;
  }
  get effectiveEditingEnabled() {
    const { parent: e3 } = this;
    return e3 ? e3.effectiveEditingEnabled && this.editingEnabled : this.editingEnabled;
  }
  get elevationInfo() {
    return this.parent?.elevationInfo;
  }
  get featureTitleFields() {
    return [...this._titleCreator.requiredFields];
  }
  writeFieldOverrides(e3, t4, r4) {
    const { fields: i4, parent: o2 } = this;
    let l5;
    if (i4) {
      l5 = [];
      let e4 = 0;
      i4.forEach(({ name: t5, alias: r5, editable: i5, visible: n3 }) => {
        if (!n3) return;
        const s3 = o2?.fields?.find((e5) => e5.name === t5);
        if (!s3) return;
        const a10 = { name: t5 };
        let p5 = false;
        r5 !== s3.alias && (a10.alias = r5, p5 = true), i5 !== s3.editable && (a10.editable = i5, p5 = true), l5.push(a10), p5 && e4++;
      }), 0 === e4 && l5.length === i4.length && (l5 = null);
    } else l5 = a(e3);
    l5?.length && e(r4, l5, t4);
  }
  get fields() {
    const { parent: e3, fieldOverrides: t4, subtypeCode: r4 } = this, i4 = e3?.fields;
    if (!e3 || !i4?.length) return null;
    const { subtypes: o2, subtypeField: n3 } = e3, l5 = o2?.find((e4) => e4.code === r4), s3 = l5?.defaultValues, a10 = l5?.domains, p5 = [];
    for (const d2 of i4) {
      const e4 = d2.clone(), { name: i5 } = e4, o3 = t4?.find((e5) => e5.name === i5);
      if (e4.visible = !t4?.length || !!o3, o3) {
        const { alias: t5, editable: r5 } = o3;
        t5 && (e4.alias = t5), false === r5 && (e4.editable = false);
      }
      const l6 = s3?.[i5] ?? null;
      e4.defaultValue = i5 === n3 ? r4 : l6;
      const u9 = a10?.[i5] ?? null;
      e4.domain = i5 === n3 ? null : u9 ? "inherited" === u9.type ? e4.domain : u9.clone() : null, p5.push(e4);
    }
    return p5;
  }
  get floorInfo() {
    return this.parent?.floorInfo;
  }
  get isTable() {
    return !!this.parent?.isTable;
  }
  get geometryType() {
    return this.parent?.geometryType;
  }
  get globalIdField() {
    return this.parent ? this.parent.globalIdField : (i.getLogger(this).error(Z("globalIdField")), null);
  }
  get effectiveScaleRange() {
    const { minScale: e3, maxScale: t4 } = this;
    return { minScale: e3, maxScale: t4 };
  }
  get objectIdField() {
    return this.parent || i.getLogger(this).error(Z("objectIdField")), this.parent?.objectIdField;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get relationships() {
    return this.parent?.relationships;
  }
  set renderer(e3) {
    g(e3, this.fieldsIndex), this._override("renderer", e3);
  }
  get renderer() {
    if (this._isOverridden("renderer")) return this._get("renderer");
    const { parent: e3 } = this;
    return e3 && !e3.isTable && "mesh" !== e3.geometryType ? B2(e3.geometryType) : null;
  }
  readRendererFromService(e3, t4, r4) {
    if ("Table" === t4.type) return null;
    const i4 = t4.drawingInfo?.renderer, o2 = i3(i4, t4, r4);
    let n3;
    const { subtypeCode: l5 } = this;
    if (null != l5 && J(o2, t4.subtypeField)) {
      const e4 = o2.uniqueValueInfos?.find(({ value: e5 }) => (e5 = "number" == typeof e5 ? String(e5) : e5) === String(l5));
      e4 && (n3 = new m2({ symbol: e4.symbol }));
    } else "simple" !== o2?.type || o2.visualVariables?.length || (n3 = o2);
    return n3;
  }
  readRenderer(e3, t4, r4) {
    const i4 = t4?.layerDefinition?.drawingInfo?.renderer;
    if (!i4) return;
    const o2 = i4.visualVariables?.some((e4) => "rotationInfo" !== e4.type);
    return o2 ? void 0 : i3(i4, t4, r4) || void 0;
  }
  get spatialReference() {
    return this.parent?.spatialReference ?? f.WGS84;
  }
  get subtypeField() {
    return this.parent?.subtypeField;
  }
  readTemplatesFromService(e3, t4) {
    return [z(this.subtypeCode, t4)];
  }
  readTitleFromService(e3, t4) {
    const r4 = W(this.subtypeCode, t4);
    return null != r4 ? r4.name : null;
  }
  get url() {
    return this.parent?.url;
  }
  get userHasUpdateItemPrivileges() {
    return !!this.parent?.userHasUpdateItemPrivileges;
  }
  async addAttachment(e3, t4) {
    const { parent: r4 } = this;
    if (!r4) throw Z("addAttachment");
    if (e3.getAttribute(r4.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:addAttachment", "The feature provided does not belong to this SubtypeSublayer");
    return r4.addAttachment(e3, t4);
  }
  async updateAttachment(e3, t4, r4) {
    const { parent: o2 } = this;
    if (!o2) throw Z("updateAttachment");
    if (e3.getAttribute(o2.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:updateAttachment", "The feature provided does not belong to this SubtypeSublayer");
    return o2.updateAttachment(e3, t4, r4);
  }
  async deleteAttachments(e3, t4) {
    const { parent: r4 } = this;
    if (!r4) throw Z("deleteAttachments");
    if (e3.getAttribute(r4.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:deleteAttachments", "The feature provided does not belong to this SubtypeSublayer");
    return r4.deleteAttachments(e3, t4);
  }
  async applyEdits(e3, t4) {
    if (!this.parent) throw Z("applyEdits");
    return this.parent.applyEdits(e3, t4);
  }
  createPopupTemplate(e3) {
    let t4 = this;
    const { parent: r4, fields: i4, title: o2 } = this;
    if (r4) {
      const { displayField: e4, editFieldsInfo: n3, objectIdField: l5 } = r4;
      t4 = { displayField: e4, editFieldsInfo: n3, fields: i4, objectIdField: l5, title: o2 };
    }
    return p4(t4, e3);
  }
  createQuery() {
    if (!this.parent) throw Z("createQuery");
    const e3 = R2(this.parent), t4 = `${this.parent.subtypeField}=${this.subtypeCode}`;
    return e3.where = r3(t4, this.parent.definitionExpression), e3;
  }
  getFeatureTitle(e3, t4) {
    return this._titleCreator.getTitle(this, e3, t4);
  }
  getFeatureTitles(e3, t4) {
    return this._titleCreator.getTitles(this, e3, t4);
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, t4) {
    if (!t4?.excludeImpliedDomains && this.parent) {
      const t5 = U2(this.parent, e3);
      if (t5) return t5;
    }
    return this._getLayerDomain(e3);
  }
  async queryAttachments(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryAttachments");
    const i4 = e3.clone();
    return i4.where = Y2(i4.where, r4.parent.subtypeField, r4.subtypeCode), r4.parent.queryAttachments(e3, t4);
  }
  async queryFeatureCount(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryFeatureCount");
    return r4.parent.queryFeatureCount(X(r4.parent, r4, e3), t4);
  }
  async queryFeatures(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryFeatures");
    return r4.parent.queryFeatures(X(r4.parent, r4, e3), t4);
  }
  async queryObjectIds(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryObjectIds");
    return r4.parent.queryObjectIds(X(r4.parent, r4, e3), t4);
  }
  async queryRelatedFeatures(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryRelatedFeatures");
    return r4.parent.queryRelatedFeatures(e3, t4);
  }
  async queryRelatedFeaturesCount(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryRelatedFeaturesCount");
    return r4.parent.queryRelatedFeaturesCount(e3, t4);
  }
  _getLayerDomain(e3) {
    const t4 = this.fieldsIndex.get(e3);
    return t4 ? t4.domain : null;
  }
};
r([m({ clonable: false, readOnly: true })], K.prototype, "_titleCreator", null), r([m({ type: c, json: Q2({ name: "attributeTableInfo" }) })], K.prototype, "attributeTableTemplate", void 0), r([m({ readOnly: true, json: { read: false } })], K.prototype, "capabilities", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "effectiveCapabilities", null), r([m({ json: Q2() })], K.prototype, "charts", void 0), r([m({ type: Boolean, nonNullable: true, json: Q2({ name: "enableEditing" }) })], K.prototype, "editingEnabled", void 0), r([m({ type: Boolean, readOnly: true })], K.prototype, "effectiveEditingEnabled", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "elevationInfo", null), r([m({ clonable: false, readOnly: true })], K.prototype, "featureTitleFields", null), r([m({ json: { name: "layerDefinition.fieldOverrides", origins: { service: { read: false } }, write: { ignoreOrigin: true, allowNull: true } } })], K.prototype, "fieldOverrides", void 0), r([r2("fieldOverrides")], K.prototype, "writeFieldOverrides", null), r([m({ ...M.fields, readOnly: true, json: { read: false } })], K.prototype, "fields", null), r([m(M.fieldsIndex)], K.prototype, "fieldsIndex", void 0), r([m({ readOnly: true, json: { read: false } })], K.prototype, "floorInfo", null), r([m({ type: V3, json: Q2({ name: "formInfo" }) })], K.prototype, "formTemplate", void 0), r([m({ type: String, clonable: false, json: { origins: { service: { read: false }, "portal-item": { read: false } }, write: { ignoreOrigin: true } } })], K.prototype, "id", void 0), r([m({ readOnly: true, json: { read: false } })], K.prototype, "isTable", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "geometryType", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "globalIdField", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "type", void 0), r([m(k4(a(p3)))], K.prototype, "labelsVisible", void 0), r([m({ type: [A3], json: { name: "layerDefinition.drawingInfo.labelingInfo", origins: { service: { read: false } }, read: { reader: l4 }, write: { ignoreOrigin: true, layerContainerTypes: a5 } } })], K.prototype, "labelingInfo", void 0), r([m({ type: ["ArcGISFeatureLayer"], readOnly: true, json: { read: false, write: { ignoreOrigin: true, layerContainerTypes: a5 } } })], K.prototype, "layerType", void 0), r([m(k4(a(d)))], K.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide"] })], K.prototype, "listMode", void 0), r([m((() => {
  const e3 = a(j);
  return e3.json.origins.service.read = false, k4(e3, { spatialOnly: true });
})())], K.prototype, "minScale", void 0), r([m((() => {
  const e3 = a(v);
  return e3.json.origins.service.read = false, k4(e3, { spatialOnly: true });
})())], K.prototype, "maxScale", void 0), r([m({ readOnly: true })], K.prototype, "effectiveScaleRange", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "objectIdField", null), r([m({ type: Number, range: { min: 0, max: 1 }, nonNullable: true, json: Q2({ spatialOnly: true }) })], K.prototype, "opacity", void 0), r([m({ clonable: false })], K.prototype, "parent", void 0), r([m(k4(a(l2)))], K.prototype, "popupEnabled", void 0), r([m({ type: q, json: Q2({ name: "popupInfo" }) })], K.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], K.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "relationships", null), r([m({ types: f3, json: Q2({ target: "layerDefinition.drawingInfo.renderer", spatialOnly: true }) })], K.prototype, "renderer", null), r([o("service", "renderer", ["drawingInfo.renderer", "subtypeField", "type"])], K.prototype, "readRendererFromService", null), r([o("renderer", ["layerDefinition.drawingInfo.renderer"])], K.prototype, "readRenderer", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "spatialReference", null), r([m({ type: Number, json: { origins: { service: { read: false } }, write: { ignoreOrigin: true } } })], K.prototype, "subtypeCode", void 0), r([m({ readOnly: true, json: { read: false } })], K.prototype, "subtypeField", null), r([m({ type: [a8], json: Q2({ name: "layerDefinition.templates" }) })], K.prototype, "templates", void 0), r([o("service", "templates", ["geometryType", "subtypeField", "subtypes", "type"])], K.prototype, "readTemplatesFromService", null), r([m({ type: String, json: Q2() })], K.prototype, "title", void 0), r([o("service", "title", ["subtypes"])], K.prototype, "readTitleFromService", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "url", null), r([m({ readOnly: true })], K.prototype, "userHasUpdateItemPrivileges", null), r([m({ type: Boolean, nonNullable: true, json: Q2({ name: "visibility", spatialOnly: true }) })], K.prototype, "visible", void 0), K = r([a2("esri.layers.support.SubtypeSublayer")], K);
var X = (e3, t4, r4) => {
  if (!r4) return t4.createQuery();
  const i4 = R.from(r4);
  return i4.where = Y2(i4.where, e3.subtypeField, t4.subtypeCode), i4;
};
var Y2 = (e3, t4, r4) => {
  const i4 = new RegExp(`${t4}\\s*=\\s*\\d+`), o2 = `${t4}=${r4}`, n3 = e3 ?? "";
  return i4.test(n3) ? n3.replace(i4, o2) : r3(o2, n3);
};
var Z = (e3) => new s("subtype-sublayer:parent-missing", `This sublayer must have a parent SubtypeGroupLayer in order to use ${e3}`);

// node_modules/@arcgis/core/layers/SubtypeGroupLayer.js
var ae = "SubtypeGroupLayer";
function ne(e3, t4) {
  return new s("layer:unsupported", `Layer (${e3.title}, ${e3.id}) of type '${e3.declaredClass}' ${t4}`, { layer: e3 });
}
function ue(e3, t4) {
  const r4 = [];
  for (const s3 of e3) {
    const e4 = new K();
    e4.read(s3, t4), r4.push(e4);
  }
  return r4;
}
var le = s2();
function pe() {
  return { name: "layerType", read: { enabled: true }, write: { enabled: true, ignoreOrigin: true, isRequired: true } };
}
var ye = class extends k2(a6(F(p2(c3(t2(f2(l3(b(j2(S(e2(i2(a4.ClonableMixin(h2)))))))))))))) {
  constructor(...e3) {
    super(...e3), this._sublayerLookup = /* @__PURE__ */ new Map(), this.fields = null, this.fieldsIndex = null, this.outFields = null, this.sublayers = new (V2.ofType(K))(), this.useUniqueColorsForSublayers = true, this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Table"]), this.timeInfo = null, this.title = "Layer", this.type = "subtype-group", this._debouncedSaveOperations = k(async (e4, t4, r4) => {
      const { save: s3, saveAs: i4 } = await import("./featureLayerUtils-2CNJC43G.js");
      switch (e4) {
        case A.SAVE:
          return s3(this, t4);
        case A.SAVE_AS:
          return i4(this, r4, t4);
      }
    }), this.addHandles(l(() => this.sublayers, (e4, t4) => this._handleSublayersChange(e4, t4), U));
  }
  destroy() {
    this.source?.destroy();
  }
  normalizeCtorArgs(e3, t4) {
    return "string" == typeof e3 ? { url: e3, ...t4 } : e3;
  }
  load(e3) {
    const t4 = null != e3 ? e3.signal : null, r4 = this.loadFromPortal({ supportedTypes: ["Feature Service"] }, e3).catch(a3).then(async () => {
      if (!this.url) throw new s("subtype-grouplayer:missing-url-or-source", "SubtypeGroupLayer must be created with either a url or a portal item");
      if (null == this.layerId) throw new s("subtype-grouplayer:missing-layerid", "layerId is required for a SubtypeGroupLayer created with url");
      return this._initLayerProperties(await this.createGraphicsSource(t4));
    }).then(() => H(this, "load", e3));
    return this.addResolvingPromise(r4), Promise.resolve(this);
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") ?? 0) + 1;
  }
  get editingEnabled() {
    return this.loaded && null != this.capabilities && this.capabilities.operations.supportsEditing && this.userHasEditingPrivileges;
  }
  get effectiveEditingEnabled() {
    return Y(this);
  }
  get operationalLayerType() {
    return this.isTable ? "SubtypeGroupTable" : "SubtypeGroupLayer";
  }
  get parsedUrl() {
    const e3 = I(this.url);
    return null != e3 && null != this.layerId && (e3.path = V(e3.path, this.layerId.toString())), e3;
  }
  set source(e3) {
    this._get("source") !== e3 && this._set("source", e3);
  }
  readTitleFromService(e3, { name: t4 }) {
    return this.url ? w(this.url, t4) : t4;
  }
  async addAttachment(e3, t4) {
    const r4 = await F2(this, e3, t4, ae);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r4;
  }
  async updateAttachment(e3, t4, r4) {
    const s3 = await P(this, e3, t4, r4, ae);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), s3;
  }
  async applyEdits(e3, t4) {
    return q2(this, e3, t4);
  }
  on(e3, t4) {
    return super.on(e3, t4);
  }
  async createGraphicsSource(e3) {
    const { default: t4 } = await h(import("./FeatureLayerSource-WDG5MVUF.js"), e3);
    return new t4({ layer: this, supportedSourceTypes: this.supportedSourceTypes }).load({ signal: e3 });
  }
  createQuery() {
    const e3 = R2(this), t4 = this.sublayers.map((e4) => e4.subtypeCode);
    return e3.where = r3(`${this.subtypeField} IN (${t4.join(",")})`, this.definitionExpression), e3;
  }
  async deleteAttachments(e3, t4) {
    const r4 = await v2(this, e3, t4, ae);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r4;
  }
  async fetchRecomputedExtents(e3) {
    return O(this, e3, ae);
  }
  findSublayerForFeature(e3) {
    const t4 = this.fieldsIndex.get(this.subtypeField), r4 = e3.attributes[t4.name];
    return this.findSublayerForSubtypeCode(r4);
  }
  findSublayerForSubtypeCode(e3) {
    return this._sublayerLookup.get(e3);
  }
  getFieldDomain(e3, t4) {
    if (!t4?.excludeImpliedDomains) {
      const t5 = U2(this, e3);
      if (t5) return t5;
    }
    const r4 = Q(this, t4?.feature);
    if (r4) {
      const t5 = r4.domains?.[e3];
      return "inherited" === t5?.type ? this._getLayerDomain(e3) : t5;
    }
    return this._getLayerDomain(e3);
  }
  loadAll() {
    return t(this, (e3) => {
      e3(this.sublayers);
    });
  }
  async queryAttachments(e3, t4) {
    return A2(this, e3, t4, ae);
  }
  async queryFeatures(e3, t4) {
    const r4 = await this.load(), s3 = R.from(e3) ?? r4.createQuery(), i4 = s3.outFields ?? [];
    i4.includes(this.subtypeField) || (i4.push(this.subtypeField), s3.outFields = i4);
    const o2 = await r4.source.queryFeatures(s3, t4);
    if (o2?.features) for (const a10 of o2.features) a10.layer = a10.sourceLayer = this.findSublayerForFeature(a10);
    return o2;
  }
  async queryObjectIds(e3, t4) {
    return (await L(this, e3, t4, ae)).filter(n);
  }
  async queryFeatureCount(e3, t4) {
    return E(this, e3, t4, ae);
  }
  async queryExtent(e3, t4) {
    return D(this, e3, t4, ae);
  }
  async queryRelatedFeatures(e3, t4) {
    return T(this, e3, t4, ae);
  }
  async queryRelatedFeaturesCount(e3, t4) {
    return C(this, e3, t4, ae);
  }
  async save(e3) {
    return this._debouncedSaveOperations(A.SAVE, e3);
  }
  async saveAs(e3, t4) {
    return this._debouncedSaveOperations(A.SAVE_AS, t4, e3);
  }
  write(e3, t4) {
    const { origin: r4, layerContainerType: i4, messages: o2 } = t4;
    if (this.isTable) {
      if ("web-scene" === r4 || "web-map" === r4 && "tables" !== i4) return o2?.push(ne(this, "using a table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && "web-map" === r4 && "tables" === i4) return o2?.push(ne(this, "using a non-table source cannot be written to tables in web maps")), null;
    return this.sublayers?.length ? super.write(e3, t4) : (o2?.push(new s("web-document-write:invalid-property", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' has invalid value for 'sublayers' property. 'sublayers' collection should contain at least one sublayer`, { layer: this })), null);
  }
  serviceSupportsSpatialReference(e3) {
    return !!this.loaded && t3(this, e3);
  }
  async getFeatureTitle(e3, t4) {
    const r4 = this.findSublayerForFeature(e3);
    return r4 ? await r4.getFeatureTitle(e3, t4) : this._getFeatureTitleForUnknownSublayer(e3);
  }
  async getFeatureTitles(e3, t4) {
    const r4 = /* @__PURE__ */ new Map(), s3 = /* @__PURE__ */ new Map(), i4 = [s3];
    e3.forEach((e4) => {
      const t5 = this.findSublayerForFeature(e4);
      if (t5) u(r4, t5, () => []).push(e4);
      else {
        const t6 = e4.getObjectId() ?? e4.attributes[this.objectIdField];
        s3.set(t6, this._getFeatureTitleForUnknownSublayer(e4));
      }
    });
    const a10 = await Promise.all(Array.from(r4).map(([e4, r5]) => e4.getFeatureTitles(r5, t4)));
    return a10.forEach((e4) => i4.push(e4)), new Map(i4.flatMap((e4) => [...e4]));
  }
  get featureTitleFields() {
    const e3 = /* @__PURE__ */ new Set();
    for (const t4 of this.sublayers) {
      const r4 = t4.featureTitleFields;
      for (const t5 of r4) e3.add(t5);
    }
    return [...e3];
  }
  _getLayerDomain(e3) {
    const t4 = this.fieldsIndex.get(e3);
    return t4 ? t4.domain : null;
  }
  async _initLayerProperties(e3) {
    this._set("source", e3);
    const { sourceJSON: t4 } = e3;
    if (t4 && (this.sourceJSON = t4, this.read(t4, { origin: "service", url: this.parsedUrl })), !this.subtypes?.length) throw new s("subtype-grouplayer:missing-subtypes", "SubtypeGroupLayer must be created using a layer with subtypes");
    this._verifyFields(), I2(this.timeInfo, this.fieldsIndex);
  }
  async hasDataChanged() {
    return B(this);
  }
  _verifyFields() {
    const e3 = this.parsedUrl?.path ?? "undefined";
    this.objectIdField || console.log("SubtypeGroupLayer: 'objectIdField' property is not defined (url: " + e3 + ")"), this.isTable || -1 !== e3.search(/\/FeatureServer\//i) || this.fields?.some((e4) => "geometry" === e4.type) || console.log("SubtypeGroupLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e3 + ")");
  }
  _handleSublayersChange(e3, t4) {
    t4 && (t4.forEach((e4) => {
      e4.parent = null;
    }), this.removeHandles("sublayers-owner"), this._sublayerLookup.clear()), e3 && (e3.forEach((e4) => {
      e4.parent = this, this._sublayerLookup.set(e4.subtypeCode, e4);
    }), this.addHandles([e3.on("after-add", ({ item: e4 }) => {
      e4.parent = this, this._sublayerLookup.set(e4.subtypeCode, e4);
    }), e3.on("after-remove", ({ item: e4 }) => {
      e4.parent = null, this._sublayerLookup.delete(e4.subtypeCode);
    })], "sublayers-owner"));
  }
  _getFeatureTitleForUnknownSublayer(e3) {
    const { displayField: t4, fieldsIndex: r4, objectIdField: s3 } = this;
    if (t4 && r4.has(t4)) return e3.attributes[r4.get(t4).name] ?? "";
    const i4 = e3.getObjectId();
    return null != i4 ? i4.toString() : s3 && r4.has(s3) ? e3.attributes[r4.get(s3).name] ?? "" : "";
  }
};
r([m({ readOnly: true })], ye.prototype, "createQueryVersion", null), r([m({ readOnly: true })], ye.prototype, "editingEnabled", null), r([m({ readOnly: true })], ye.prototype, "effectiveEditingEnabled", null), r([m({ ...le.fields, readOnly: true, json: { origins: { service: { read: true } }, read: false } })], ye.prototype, "fields", void 0), r([m(le.fieldsIndex)], ye.prototype, "fieldsIndex", void 0), r([m(u4)], ye.prototype, "id", void 0), r([m({ type: ["show", "hide", "hide-children"], json: { origins: { "portal-item": { read: false, write: false } } } })], ye.prototype, "listMode", void 0), r([m({ type: ["SubtypeGroupLayer", "SubtypeGroupTable"], json: { ...pe(), origins: { "web-document": pe(), "portal-item": pe() } } })], ye.prototype, "operationalLayerType", null), r([m(le.outFields)], ye.prototype, "outFields", void 0), r([m({ readOnly: true })], ye.prototype, "parsedUrl", null), r([m({ clonable: false })], ye.prototype, "source", null), r([m({ type: V2.ofType(K), json: { origins: { service: { read: { source: "subtypes", reader(e3, t4, s3) {
  let i4 = null;
  if (this.useUniqueColorsForSublayers) {
    const r4 = c4(t4, s3);
    i4 = r4 ? a9(e3.length, r4) : null;
  }
  const o2 = e3.map(({ code: e4 }, r4) => {
    const o3 = new K({ subtypeCode: e4 });
    o3.read(t4, s3);
    const a10 = i4?.[r4];
    return a10 && o3.read({ drawingInfo: { renderer: a10.toJSON() } }, s3), o3;
  });
  return new (V2.ofType(K))(o2);
} } } }, read: { source: ["layers", "tables"], reader(e3, t4, s3) {
  let i4;
  return "SubtypeGroupLayer" === t4.layerType && t4.layers?.length ? i4 = ue(t4.layers, s3) : "SubtypeGroupTable" === t4.layerType && t4.tables?.length && (i4 = ue(t4.tables, s3)), new (V2.ofType(K))(i4);
} }, write: { ignoreOrigin: true, writer(e3, t4, r4, s3) {
  const i4 = [];
  for (const o2 of e3) {
    const e4 = o2.write({}, s3);
    i4.push(e4);
  }
  this.isTable ? t4.tables = i4 : t4.layers = i4;
} } } })], ye.prototype, "sublayers", void 0), r([m()], ye.prototype, "useUniqueColorsForSublayers", void 0), r([m({ type: u6 })], ye.prototype, "timeInfo", void 0), r([m({ json: { origins: { "portal-item": { write: { enabled: true, ignoreOrigin: true, writerEnsuresNonNull: true } } } } })], ye.prototype, "title", void 0), r([o("service", "title", ["name"])], ye.prototype, "readTitleFromService", null), r([m({ json: { read: false } })], ye.prototype, "type", void 0), r([m({ clonable: false, readOnly: true })], ye.prototype, "featureTitleFields", null), ye = r([a2("esri.layers.SubtypeGroupLayer")], ye);
var de = ye;
export {
  de as default
};
//# sourceMappingURL=SubtypeGroupLayer-5RLYYDV2.js.map
