import {
  i as i4
} from "./chunk-CEMHA5WX.js";
import {
  S as S2
} from "./chunk-YR4BEFGH.js";
import {
  u as u5
} from "./chunk-EEB2RHCK.js";
import {
  c as c2,
  c2 as c3,
  m as m2
} from "./chunk-625W4ZH5.js";
import {
  i as i3
} from "./chunk-MGE3DVJJ.js";
import {
  r as r2
} from "./chunk-GEY3MNEN.js";
import "./chunk-QARUBZM2.js";
import "./chunk-F6HYAIOQ.js";
import "./chunk-733XT7D4.js";
import {
  s as s4,
  t as t3
} from "./chunk-JXATTI6K.js";
import "./chunk-O3AUTEBE.js";
import "./chunk-TAPCW5Z5.js";
import "./chunk-JOUWZB2W.js";
import {
  L,
  o as o2
} from "./chunk-NCPKBH2V.js";
import {
  E,
  I,
  c,
  o,
  t
} from "./chunk-S4X4QGA7.js";
import {
  a as a6,
  i as i2
} from "./chunk-CF5GNPLI.js";
import "./chunk-5WTH3GBK.js";
import {
  s as s2
} from "./chunk-JV7SG7ZY.js";
import "./chunk-IAKXH7PU.js";
import "./chunk-DKS7UUDR.js";
import {
  a as a4
} from "./chunk-6DARBDBU.js";
import "./chunk-KDQWOWXR.js";
import "./chunk-JOVQBCRD.js";
import "./chunk-GYAK76KG.js";
import "./chunk-KB5I2WHB.js";
import "./chunk-P3YYANTX.js";
import {
  u as u4
} from "./chunk-ZWJOMK2U.js";
import "./chunk-Y2ZAHGIO.js";
import {
  t as t2
} from "./chunk-OV7XVIQP.js";
import {
  d as d2
} from "./chunk-JQSXFLSD.js";
import "./chunk-H5K53FMS.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-76QJRCNC.js";
import "./chunk-GKCEBA6Q.js";
import "./chunk-VWMPQK5V.js";
import {
  e as e5
} from "./chunk-IGBV77N3.js";
import "./chunk-5Y3EUPZN.js";
import {
  p as p2
} from "./chunk-YBXGYFQH.js";
import {
  h,
  s as s3
} from "./chunk-NFDUQVJM.js";
import {
  E as E2
} from "./chunk-3PPDORWL.js";
import "./chunk-YIXK32VF.js";
import "./chunk-7DRFV7H6.js";
import {
  e as e4
} from "./chunk-2NTKYBCL.js";
import {
  g
} from "./chunk-BDWOUZQR.js";
import "./chunk-H34ENSPL.js";
import "./chunk-4ADC6HZF.js";
import {
  S,
  a as a5
} from "./chunk-H6F6O2KE.js";
import "./chunk-AF3FX2UV.js";
import "./chunk-DRAQJS2F.js";
import {
  A,
  C,
  D,
  M,
  P,
  _ as _2
} from "./chunk-BZYXFNL4.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-TMFB3DKM.js";
import "./chunk-NO2XQDLB.js";
import "./chunk-LBC3MAJX.js";
import {
  j
} from "./chunk-3ZORAHSR.js";
import "./chunk-SZN55B2M.js";
import "./chunk-NMP7ZOVG.js";
import "./chunk-YHYQP7QX.js";
import "./chunk-RP7FUW55.js";
import "./chunk-MPV4X4LZ.js";
import "./chunk-TNW4TPNP.js";
import {
  p,
  y as y2
} from "./chunk-G5DA3EEG.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-RGFH75DR.js";
import {
  e as e3
} from "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import {
  p as p3
} from "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import "./chunk-BNO7HCVD.js";
import {
  d
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import {
  R,
  e as e2,
  u as u3
} from "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import {
  s
} from "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H
} from "./chunk-ZWFY3WY5.js";
import {
  Ht
} from "./chunk-LQFTAGIV.js";
import {
  u
} from "./chunk-S7IJH524.js";
import {
  a as a3,
  b,
  e2 as e,
  f2 as f,
  u2,
  y
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i
} from "./chunk-XWG6QGFK.js";
import {
  a
} from "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e6 = class {
  constructor(e7, t6) {
    this._width = 0, this._height = 0, this._free = [], this._width = e7, this._height = t6, this._free.push(new t2(0, 0, e7, t6));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e7, t6) {
    if (e7 > this._width || t6 > this._height) return new t2();
    let i5 = null, s6 = -1;
    for (let h4 = 0; h4 < this._free.length; ++h4) {
      const w = this._free[h4];
      e7 <= w.width && t6 <= w.height && (null === i5 || w.y <= i5.y && w.x <= i5.x) && (i5 = w, s6 = h4);
    }
    return null === i5 ? new t2() : (this._free.splice(s6, 1), i5.width < i5.height ? (i5.width > e7 && this._free.push(new t2(i5.x + e7, i5.y, i5.width - e7, t6)), i5.height > t6 && this._free.push(new t2(i5.x, i5.y + t6, i5.width, i5.height - t6))) : (i5.width > e7 && this._free.push(new t2(i5.x + e7, i5.y, i5.width - e7, i5.height)), i5.height > t6 && this._free.push(new t2(i5.x, i5.y + t6, e7, i5.height - t6))), new t2(i5.x, i5.y, e7, t6));
  }
  release(h4) {
    for (let e7 = 0; e7 < this._free.length; ++e7) {
      const t6 = this._free[e7];
      if (t6.y === h4.y && t6.height === h4.height && t6.x + t6.width === h4.x) t6.width += h4.width;
      else if (t6.x === h4.x && t6.width === h4.width && t6.y + t6.height === h4.y) t6.height += h4.height;
      else if (h4.y === t6.y && h4.height === t6.height && h4.x + h4.width === t6.x) t6.x = h4.x, t6.width += h4.width;
      else {
        if (h4.x !== t6.x || h4.width !== t6.width || h4.y + h4.height !== t6.y) continue;
        t6.y = h4.y, t6.height += h4.height;
      }
      this._free.splice(e7, 1), this.release(h4);
    }
    this._free.push(h4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n = class {
  constructor(e7, s6, i5) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e7, this.height = s6, this._glyphSource = i5, this._binPack = new e6(e7 - 4, s6 - 4), this._glyphData.push(new Uint8Array(e7 * s6)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s6, i5) {
    const h4 = [], r5 = this._glyphSource, n4 = /* @__PURE__ */ new Set(), o4 = 1 / 256;
    for (const t6 of i5) {
      const e7 = Math.floor(t6 * o4);
      n4.add(e7);
    }
    const a9 = [];
    return n4.forEach((t6) => {
      const e7 = s6 + t6;
      if (this._rangePromises.has(e7)) a9.push(this._rangePromises.get(e7));
      else {
        const i6 = r5.getRange(s6, t6).then(() => {
          this._rangePromises.delete(e7);
        }, () => {
          this._rangePromises.delete(e7);
        });
        this._rangePromises.set(e7, i6), a9.push(i6);
      }
    }), Promise.all(a9).then(() => {
      let n5 = this._glyphIndex[s6];
      n5 || (n5 = {}, this._glyphIndex[s6] = n5);
      for (const o5 of i5) {
        const i6 = n5[o5];
        if (i6) {
          h4[o5] = { sdf: true, rect: i6.rect, metrics: i6.metrics, page: i6.page, code: o5 };
          continue;
        }
        const a10 = r5.getGlyph(s6, o5);
        if (!a10?.metrics) continue;
        const l = a10.metrics;
        let c5;
        if (0 === l.width) c5 = new t2(0, 0, 0, 0);
        else {
          const e7 = 3, s7 = l.width + 2 * e7, i7 = l.height + 2 * e7;
          let h5 = s7 % 4 ? 4 - s7 % 4 : 4, r6 = i7 % 4 ? 4 - i7 % 4 : 4;
          1 === h5 && (h5 = 5), 1 === r6 && (r6 = 5), c5 = this._binPack.allocate(s7 + h5, i7 + r6), c5.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e6(this.width - 4, this.height - 4), c5 = this._binPack.allocate(s7 + h5, i7 + r6));
          const n6 = this._glyphData[this._currentPage], o6 = a10.bitmap;
          let g3, _5;
          if (o6) for (let t6 = 0; t6 < i7; t6++) {
            g3 = s7 * t6, _5 = this.width * (c5.y + t6 + 1) + c5.x;
            for (let t7 = 0; t7 < s7; t7++) n6[_5 + t7 + 1] = o6.at(g3 + t7);
          }
        }
        n5[o5] = { rect: c5, metrics: l, tileIDs: null, page: this._currentPage }, h4[o5] = { sdf: true, rect: c5, metrics: l, page: this._currentPage, code: o5 }, this._dirties[this._currentPage] = true;
      }
      return h4;
    });
  }
  removeGlyphs(t6) {
    for (const e7 in this._glyphIndex) {
      const s6 = this._glyphIndex[e7];
      if (!s6) continue;
      let i5;
      for (const e8 in s6) if (i5 = s6[e8], i5.tileIDs.delete(t6), 0 === i5.tileIDs.size) {
        const t7 = this._glyphData[i5.page], h4 = i5.rect;
        let r5, n4;
        for (let e9 = 0; e9 < h4.height; e9++) for (r5 = this.width * (h4.y + e9) + h4.x, n4 = 0; n4 < h4.width; n4++) t7[r5 + n4] = 0;
        delete s6[e8], this._dirties[i5.page] = true;
      }
    }
  }
  bind(t6, e7, n4, o4 = 0) {
    if (!this._textures[n4]) {
      const e8 = new a5();
      e8.pixelFormat = M.ALPHA, e8.wrapMode = P.CLAMP_TO_EDGE, e8.width = this.width, e8.height = this.height, this._textures[n4] = new S(t6, e8, new Uint8Array(this.width * this.height));
    }
    const a9 = this._textures[n4];
    a9.setSamplingMode(e7), this._dirties[n4] && a9.setData(this._glyphData[n4]), t6.bindTexture(a9, o4), this._dirties[n4] = false;
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._glyphData.length = 0, this._binPack = null;
    for (const t6 of this._textures) t6 && t6.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s5 = class {
  constructor(t6) {
    if (this._metrics = [], !t6) return void (this._allBitmaps = null);
    const e7 = /* @__PURE__ */ new Map();
    let s6 = 0;
    for (; t6.next(); ) switch (t6.tag()) {
      case 1: {
        const a10 = t6.getMessage();
        for (; a10.next(); ) switch (a10.tag()) {
          case 3: {
            const t7 = a10.getMessage();
            let r6, n4, i5, c5, o4, g3, h4;
            for (; t7.next(); ) switch (t7.tag()) {
              case 1:
                r6 = t7.getUInt32();
                break;
              case 2:
                n4 = t7.getBytes();
                break;
              case 3:
                i5 = t7.getUInt32();
                break;
              case 4:
                c5 = t7.getUInt32();
                break;
              case 5:
                o4 = t7.getSInt32();
                break;
              case 6:
                g3 = t7.getSInt32();
                break;
              case 7:
                h4 = t7.getUInt32();
                break;
              default:
                t7.skip();
            }
            if (t7.release(), r6) {
              const t8 = n4?.length ?? 0;
              this._metrics[r6] = { width: i5, height: c5, left: o4, top: g3, advance: h4, startOffset: s6, length: t8 }, e7.set(r6, n4), s6 += t8;
            }
            break;
          }
          default:
            a10.skip();
        }
        a10.release();
        break;
      }
      default:
        t6.skip();
    }
    const a9 = new Uint8Array(s6), r5 = this._metrics;
    for (const [n4, i5] of e7) {
      const { startOffset: t7, length: e8 } = r5[n4];
      if (i5) for (let s7 = 0; s7 < e8; ++s7) a9[t7 + s7] = i5[s7];
    }
    this._allBitmaps = a9;
  }
  getMetrics(t6) {
    return this._metrics[t6];
  }
  getBitmap(t6) {
    if (!this._allBitmaps) return;
    const e7 = this._metrics[t6];
    if (void 0 === e7) return;
    const { startOffset: s6, length: a9 } = e7;
    return 0 !== a9 ? new n2(this._allBitmaps, s6, a9) : void 0;
  }
};
var a7 = class {
  constructor() {
    this._ranges = [];
  }
  get ranges() {
    return this._ranges;
  }
  getRange(t6) {
    return this._ranges[t6];
  }
  addRange(t6, e7) {
    this._ranges[t6] = e7;
  }
};
var r3 = class {
  constructor(t6) {
    this._glyphInfo = {}, this._baseURL = t6;
  }
  getRange(a9, r5) {
    const n4 = this._getFontStack(a9);
    if (n4.getRange(r5)) return Promise.resolve();
    const i5 = 256 * r5, c5 = i5 + 255;
    if (this._baseURL) {
      const o4 = this._baseURL.replace("{fontstack}", a9).replace("{range}", i5 + "-" + c5);
      return H(o4, { responseType: "array-buffer" }).then((t6) => {
        n4.addRange(r5, new s5(new a4(new Uint8Array(t6.data), new DataView(t6.data))));
      }).catch(() => {
        n4.addRange(r5, new s5());
      });
    }
    return n4.addRange(r5, new s5()), Promise.resolve();
  }
  getGlyph(t6, e7) {
    const s6 = this._getFontStack(t6);
    if (!s6) return;
    const a9 = Math.floor(e7 / 256), r5 = s6.getRange(a9);
    return r5 ? { metrics: r5.getMetrics(e7), bitmap: r5.getBitmap(e7) } : void 0;
  }
  _getFontStack(t6) {
    let e7 = this._glyphInfo[t6];
    return e7 || (e7 = this._glyphInfo[t6] = new a7()), e7;
  }
};
var n2 = class {
  constructor(t6, e7, s6) {
    this._array = t6, this._start = e7, this.length = s6;
  }
  at(t6) {
    return 0 <= t6 && t6 < this.length ? this._array[this._start + t6] : void 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r4 = "dasharray-";
var o3 = class _o {
  constructor(t6, s6, e7 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, s6 <= 0 && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t6, this._pageHeight = s6, e7 > 0 && (this._maxItemSize = e7), this._binPack = new e6(t6 - 4, s6 - 4);
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._binPack = null, this._mosaicsData.length = 0, this._mosaicRects = {};
    for (const t6 of this._textures) t6 && t6.dispose();
    this._textures.length = 0;
  }
  getWidth(t6) {
    return t6 >= this._size.length ? -1 : this._size[t6][0];
  }
  getHeight(t6) {
    return t6 >= this._size.length ? -1 : this._size[t6][1];
  }
  getPageSize(t6) {
    return t6 >= this._size.length ? null : this._size[t6];
  }
  setSpriteSource(t6) {
    if (this.dispose(), this.pixelRatio = t6.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e6(this._pageWidth - 4, this._pageHeight - 4);
      const t7 = Math.floor(this._pageWidth), s6 = Math.floor(this._pageHeight), e7 = new Uint32Array(t7 * s6);
      this._mosaicsData[0] = e7, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t6;
  }
  getSpriteItem(t6, i5 = false) {
    let s6, e7, h4 = this._mosaicRects[t6];
    if (h4) return h4;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus) return null;
    if (t6 && t6.startsWith(r4) ? ([s6, e7] = this._rasterizeDash(t6), i5 = true) : s6 = this._sprites.getSpriteInfo(t6), !s6?.width || !s6.height || s6.width < 0 || s6.height < 0) return null;
    const a9 = s6.width, o4 = s6.height, [n4, _5, g3] = this._allocateImage(a9, o4);
    return n4.width <= 0 ? null : (this._copy(n4, s6, _5, g3, i5, e7), h4 = { type: "sprite", rect: n4, width: a9, height: o4, sdf: s6.sdf, simplePattern: false, rasterizationScale: s6.pixelRatio ?? 1, samplingMode: "Linear", page: _5 }, this._mosaicRects[t6] = h4, h4);
  }
  getSpriteItems(t6) {
    const i5 = {};
    for (const s6 of t6) i5[s6.name] = this.getSpriteItem(s6.name, s6.repeat);
    return i5;
  }
  getMosaicItemPosition(t6, i5) {
    const s6 = this.getSpriteItem(t6, i5), e7 = s6?.rect;
    if (!e7) return null;
    e7.width = s6.width, e7.height = s6.height;
    const h4 = s6.width, a9 = s6.height, r5 = 2;
    return { tl: [e7.x + r5, e7.y + r5], br: [e7.x + r5 + h4, e7.y + r5 + a9], page: s6.page };
  }
  bind(t6, i5, s6 = 0, r5 = 0) {
    if (s6 >= this._size.length || s6 >= this._mosaicsData.length) return;
    if (!this._textures[s6]) {
      const i6 = new a5();
      i6.wrapMode = P.CLAMP_TO_EDGE, i6.width = this._size[s6][0], i6.height = this._size[s6][1], this._textures[s6] = new S(t6, i6, new Uint8Array(this._mosaicsData[s6].buffer));
    }
    const o4 = this._textures[s6];
    o4.setSamplingMode(i5), this._dirties[s6] && o4.setData(new Uint8Array(this._mosaicsData[s6].buffer)), t6.bindTexture(o4, r5), this._dirties[s6] = false;
  }
  static _copyBits(t6, i5, s6, e7, h4, a9, r5, o4, n4, _5, g3) {
    let p5 = e7 * i5 + s6, c5 = o4 * a9 + r5;
    if (g3) {
      c5 -= a9;
      for (let r6 = -1; r6 <= _5; r6++, p5 = ((r6 + _5) % _5 + e7) * i5 + s6, c5 += a9) for (let i6 = -1; i6 <= n4; i6++) h4[c5 + i6] = t6[p5 + (i6 + n4) % n4];
    } else for (let l = 0; l < _5; l++) {
      for (let i6 = 0; i6 < n4; i6++) h4[c5 + i6] = t6[p5 + i6];
      p5 += i5, c5 += a9;
    }
  }
  _copy(t6, i5, s6, e7, h4, a9) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || s6 >= this._mosaicsData.length) return;
    const r5 = new Uint32Array(a9 ? a9.buffer : this._sprites.image.buffer), n4 = this._mosaicsData[s6], _5 = 2, g3 = a9 ? i5.width : this._sprites.width;
    _o._copyBits(r5, g3, i5.x, i5.y, n4, e7[0], t6.x + _5, t6.y + _5, i5.width, i5.height, h4), this._dirties[s6] = true;
  }
  _allocateImage(t6, e7) {
    t6 += 2, e7 += 2;
    const h4 = Math.max(t6, e7);
    if (this._maxItemSize && this._maxItemSize < h4) {
      const i5 = new t2(0, 0, t6, e7);
      return this._mosaicsData.push(new Uint32Array(t6 * e7)), this._dirties.push(true), this._size.push([t6, e7]), this._textures.push(void 0), [i5, this._mosaicsData.length - 1, [t6, e7]];
    }
    let a9 = t6 % 4 ? 4 - t6 % 4 : 4, r5 = e7 % 4 ? 4 - e7 % 4 : 4;
    1 === a9 && (a9 = 5), 1 === r5 && (r5 = 5);
    const o4 = this._binPack.allocate(t6 + a9, e7 + r5);
    return o4.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e6(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t6, e7)) : [o4, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i5) {
    const s6 = /\[(.*?)\]/, e7 = i5.match(s6);
    if (!e7) return null;
    const h4 = e7[1].split(",").map(Number), a9 = i5.slice(i5.lastIndexOf("-") + 1), [r5, o4, n4] = u4(h4, a9);
    return [{ x: 0, y: 0, width: o4, height: n4, sdf: true, pixelRatio: 1 }, new Uint8Array(r5.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var p4 = class {
  constructor(t6, e7, s6, r5) {
    this._layer = t6, this._styleRepository = e7, this.devicePixelRatio = s6, this._sourceDataMaxLOD = r5, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    this._connection?.close(), this._connection = null, this._styleRepository = null, this._layer = null, this._spriteMosaic?.destroy(), this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && this._startOptionsInputSignal?.removeEventListener("abort", this._inputSignalEventListener), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t6) {
    this._requestSprite(t6);
    const s6 = this._layer.currentStyleInfo.glyphsUrl, r5 = new r3(s6 ? Ht(s6, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n(1024, 1024, r5), this._broadcastPromise = p3("WorkerTileHandler", { client: this, schedule: t6.schedule, signal: t6.signal }).then((s7) => {
      if (this._layer && (this._connection?.close(), this._connection = s7, this._layer && !this._connection.closed)) {
        const r6 = s7.broadcast("setStyle", { style: this._layer.currentStyleInfo.style, sourceDataMaxLOD: this._sourceDataMaxLOD }, t6);
        Promise.all(r6).catch((t7) => f(t7));
      }
    });
  }
  _requestSprite(t6) {
    this._spriteSourceAbortController?.abort();
    const e7 = new AbortController();
    this._spriteSourceAbortController = e7;
    const r5 = t6?.signal;
    this._inputSignalEventListener && this._startOptionsInputSignal?.removeEventListener("abort", this._inputSignalEventListener), this._startOptionsInputSignal = null, r5 && (this._inputSignalEventListener = _3(e7), r5.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i5 } = e7, o4 = { ...t6, signal: i5 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o4), this._spriteSourcePromise.then((t7) => {
      a3(i5), this._spriteMosaic = new o3(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t7);
    });
  }
  async updateStyle(t6) {
    const e7 = [];
    for (const s6 of t6) s6.type === I.SPRITES_CHANGED ? e7.push({ type: I.SPRITES_CHANGED, data: { spriteSource: null } }) : e7.push(s6);
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", e7)), this._broadcastPromise;
  }
  setSpriteSource(t6) {
    const e7 = new o3(1024, 1024, 250);
    return e7.setSpriteSource(t6), this._spriteMosaic = e7, this._spriteSourcePromise = Promise.resolve(t6), this._spriteSourceAbortController = null, e7;
  }
  async setStyle(t6, e7, s6) {
    await this._broadcastPromise, this._styleRepository = t6, this._sourceDataMaxLOD = s6, this._requestSprite();
    const r5 = new r3(this._layer.currentStyleInfo.glyphsUrl ? Ht(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n(1024, 1024, r5), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", { style: e7, sourceDataMaxLOD: this._sourceDataMaxLOD })), this._broadcastPromise;
  }
  async fetchTileData(t6, e7) {
    const s6 = await this._getRefKeys(t6, e7);
    return this._getSourcesData(Object.keys(this._layer.sourceNameToSource), s6, e7);
  }
  async fetchTilePBFs(t6) {
    const e7 = Object.keys(this._layer.sourceNameToSource), s6 = {}, r5 = await this._getRefKeys(t6, s6), i5 = [], o4 = [];
    for (let n4 = 0; n4 < r5.length; n4++) if (null == r5[n4].value || null == e7[n4]) o4.push(null);
    else {
      const t7 = r5[n4].value, a9 = this._getTilePayload(t7, e7[n4], s6);
      a9.then((e8) => {
        i5.push({ ...e8, key: t7 });
      }), o4.push(a9);
    }
    return Promise.all(o4).then(() => i5);
  }
  async parseTileData(t6, e7) {
    const s6 = t6 && t6.data;
    if (!s6) return null;
    const { sourceName2DataAndRefKey: r5, transferList: i5 } = s6;
    return 0 === Object.keys(r5).length ? null : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t6.key.id, sourceName2DataAndRefKey: r5, styleLayerUIDs: t6.styleLayerUIDs }, { ...e7, transferList: i5 }));
  }
  async getSprites(t6) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t6);
  }
  getGlyphs(t6) {
    return this._glyphMosaic.getGlyphItems(t6.font, t6.codePoints);
  }
  async _getTilePayload(t6, e7, s6) {
    const i5 = e4.pool.acquire(t6.id), o4 = this._layer.sourceNameToSource[e7], { level: n4, row: a9, col: l } = i5;
    e4.pool.release(i5);
    try {
      return { protobuff: await o4.requestTile(n4, a9, l, s6), sourceName: e7 };
    } catch (c5) {
      if (b(c5)) throw c5;
      return { protobuff: null, sourceName: e7 };
    }
  }
  async _getRefKeys(t6, e7) {
    const s6 = this._layer.sourceNameToSource, r5 = new Array();
    for (const i5 in s6) {
      const o4 = s6[i5].getRefKey(t6, e7);
      r5.push(o4);
    }
    return y(r5);
  }
  _getSourcesData(t6, e7, s6) {
    const r5 = [];
    for (let i5 = 0; i5 < e7.length; i5++) if (null == e7[i5].value || null == t6[i5]) r5.push(null);
    else {
      const o4 = e7[i5].value, n4 = this._getTilePayload(o4, t6[i5], s6);
      r5.push(n4);
    }
    return y(r5).then((t7) => {
      const s7 = {}, r6 = [];
      for (let i5 = 0; i5 < t7.length; i5++) {
        const o4 = t7[i5].value;
        if (o4 && (o4.protobuff && o4.protobuff.byteLength > 0)) {
          const t8 = e7[i5].value.id;
          s7[o4.sourceName] = { refKey: t8, protobuff: o4.protobuff }, r6.push(o4.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s7, transferList: r6 };
    });
  }
};
function _3(t6) {
  return () => t6.abort();
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var n3 = 1e-6;
var a8 = (e7, i5) => e7 + 1 / (1 << 2 * i5);
var c4 = class {
  constructor(i5, t6) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e3(40, (e7) => e7.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i5.acquireTile, this.releaseTile = i5.releaseTile, this.tileInfoView = i5.tileInfoView, this._container = t6;
  }
  destroy() {
    for (const e7 of this._tiles.values()) e7.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e7) {
    this._updateCacheSize(e7);
    const i5 = this.tileInfoView, t6 = i5.getTileCoverage(e7.state, 0, true, "smallest");
    if (!t6) return true;
    const { spans: s6, lodInfo: l } = t6, { level: n4 } = l, a9 = this._tiles, c5 = /* @__PURE__ */ new Set(), h4 = /* @__PURE__ */ new Set();
    for (const { row: o4, colFrom: _5, colTo: f2 } of s6) for (let e8 = _5; e8 <= f2; e8++) {
      const i6 = e4.getId(n4, o4, l.normalizeCol(e8), l.getWorldForColumn(e8)), t7 = this._getOrAcquireTile(i6);
      c5.add(i6), t7.processed() ? this._addToContainer(t7) : h4.add(new e4(i6));
    }
    for (const [o4, r5] of a9) r5.isCoverage = c5.has(o4);
    for (const o4 of h4) this._findPlaceholdersForMissingTiles(o4, c5);
    let d5 = false;
    for (const [o4, r5] of a9) r5.neededForCoverage = c5.has(o4), r5.neededForCoverage || r5.isHoldingForFade && i5.intersects(t6, r5.key) && c5.add(o4), r5.isFading && (d5 = true);
    for (const o4 of this._tiles.keys()) c5.has(o4) || this._releaseTile(o4);
    return s3.pool.release(t6), !d5;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  getIntersectingTiles(e7, l, o4, r5, n4) {
    const a9 = [0, 0], c5 = [0, 0];
    r5.toMap(a9, e7 - o4, l + o4), r5.toMap(c5, e7 + o4, l - o4);
    const h4 = Math.min(a9[0], c5[0]), d5 = Math.min(a9[1], c5[1]), _5 = Math.max(a9[0], c5[0]), f2 = Math.max(a9[1], c5[1]), T = e2(h4, d5, _5, f2), u6 = u3(), p5 = [];
    for (const i5 of this._visibleTiles.values()) this.tileInfoView.getTileBounds(u6, i5.key), R(T, u6) && p5.push(i5);
    if (null != n4 && n4.length > 0) {
      const e8 = new Set(p5.map((e9) => e9.id)), i5 = n4.filter((i6) => !e8.has(i6.tileKey.id)).map((e9) => this._visibleTiles.get(e9.tileKey.id)).filter((e9) => void 0 !== e9);
      p5.push(...i5);
    }
    return p5;
  }
  _findPlaceholdersForMissingTiles(e7, i5) {
    const t6 = [];
    for (const l of this._tiles.values()) this._addPlaceholderChild(t6, l, e7, i5);
    const s6 = t6.reduce(a8, 0);
    Math.abs(1 - s6) < n3 || this._addPlaceholderParent(e7.id, i5);
  }
  _addPlaceholderChild(e7, i5, t6, s6) {
    i5.key.level <= t6.level || !i5.hasData() || d3(t6, i5.key) && (this._addToContainer(i5), s6.add(i5.id), e7.push(i5.key.level - t6.level));
  }
  _addPlaceholderParent(e7, i5) {
    const t6 = this._tiles;
    let s6 = e7;
    for (; ; ) {
      if (s6 = h2(s6), !s6 || i5.has(s6)) return;
      const e8 = t6.get(s6);
      if (e8?.hasData()) return this._addToContainer(e8), void i5.add(e8.id);
    }
  }
  _getOrAcquireTile(e7) {
    let i5 = this._tiles.get(e7);
    return i5 || (i5 = this._tileCache.pop(e7), i5 || (i5 = this.acquireTile(new e4(e7))), this._tiles.set(e7, i5), i5);
  }
  _releaseTile(e7) {
    const i5 = this._tiles.get(e7);
    this.releaseTile(i5), this._removeFromContainer(i5), this._tiles.delete(e7), i5.hasData() ? this._tileCache.put(e7, i5, 1) : i5.dispose();
  }
  _addToContainer(e7) {
    let i5;
    const t6 = [], s6 = this._container;
    if (s6.contains(e7)) return;
    const l = this._visibleTiles;
    for (const o4 of l.values()) this._canConnectDirectly(e7, o4) && t6.push(o4), null == i5 && this._canConnectDirectly(o4, e7) && (i5 = o4);
    if (null != i5) {
      for (const s7 of t6) i5.childrenTiles.delete(s7), e7.childrenTiles.add(s7), s7.parentTile = e7;
      i5.childrenTiles.add(e7), e7.parentTile = i5;
    } else for (const o4 of t6) e7.childrenTiles.add(o4), o4.parentTile = e7;
    l.set(e7.id, e7), s6.addChild(e7);
  }
  _removeFromContainer(e7) {
    if (this._visibleTiles.delete(e7.id), this._container.removeChild(e7), null != e7.parentTile) {
      e7.parentTile.childrenTiles.delete(e7);
      for (const i5 of e7.childrenTiles) null != e7.parentTile && e7.parentTile.childrenTiles.add(i5);
    }
    for (const i5 of e7.childrenTiles) i5.parentTile = e7.parentTile;
    e7.parentTile = null, e7.childrenTiles.clear();
  }
  _canConnectDirectly(e7, i5) {
    const t6 = e7.key;
    let { level: s6, row: l, col: o4, world: r5 } = i5.key;
    const n4 = this._visibleTiles;
    for (; s6 > 0; ) {
      if (s6--, l >>= 1, o4 >>= 1, t6.level === s6 && t6.row === l && t6.col === o4 && t6.world === r5) return true;
      if (n4.has(`${s6}/${l}/${o4}/${r5}`)) return false;
    }
    return false;
  }
  _updateCacheSize(e7) {
    const i5 = e7.state.size;
    if (i5[0] === this._viewSize[0] && i5[1] === this._viewSize[1]) return;
    const t6 = Math.ceil(i5[0] / o) + 1, s6 = Math.ceil(i5[1] / o) + 1;
    this._viewSize[0] = i5[0], this._viewSize[1] = i5[1], this._tileCache.maxSize = 5 * t6 * s6;
  }
};
function h2(e7) {
  const [i5, t6, s6, l] = e7.split("/"), o4 = parseInt(i5, 10);
  return 0 === o4 ? null : `${o4 - 1}/${parseInt(t6, 10) >> 1}/${parseInt(s6, 10) >> 1}/${parseInt(l, 10)}`;
}
function d3(e7, i5) {
  const t6 = i5.level - e7.level;
  return e7.row === i5.row >> t6 && e7.col === i5.col >> t6 && e7.world === i5.world;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t4 = class extends r2 {
  _createTransforms() {
    return { displayViewScreenMat3: e5(), tileMat3: e5() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var g2 = 1e-6;
function b2(e7, t6) {
  if (e7) {
    const s6 = e7.getLayoutProperty("visibility");
    if (!s6 || s6.getValue() !== a6.NONE && (void 0 === e7.minzoom || e7.minzoom < t6 + g2) && (void 0 === e7.maxzoom || e7.maxzoom >= t6 - g2)) return true;
  }
  return false;
}
var _4 = class extends i3 {
  constructor(e7) {
    super(e7), this._backgroundTiles = [], this._computeDisplayInfoView(e7);
  }
  destroy() {
    this.removeAllChildren(), this._spriteMosaic?.dispose(), this._spriteMosaic = null, this._glyphMosaic?.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [];
  }
  get fading() {
    return this._symbolFader?.fading ?? false;
  }
  get symbolFader() {
    return this._symbolFader;
  }
  get symbolRepository() {
    return this._symbolFader?.symbolRepository;
  }
  setStyleResources(e7, t6, r5, o4) {
    if (this._spriteMosaic = e7, this._glyphMosaic = t6, this._styleRepository = r5, this.tileInfoView = o4, this._computeDisplayInfoView(o4), null == this._symbolFader) {
      const e8 = (e9, t7) => {
        e9.allSymbolsFadingOut = true, e9.lastOpacityUpdate = t7, c2(e9, t7, true), e9.decluttered = true, e9.requestRender();
      };
      this._symbolFader = new c3("vector-tile", this._styleRepository, e8, this.children, t);
    }
    this._symbolFader.styleRepository = r5;
  }
  setSpriteMosaic(e7) {
    this._spriteMosaic?.dispose(), this._spriteMosaic = e7;
  }
  deleteStyleLayers(e7) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e7);
  }
  createRenderParams(e7) {
    return { ...super.createRenderParams(e7), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e7) {
    !this.visible || e7.drawPhase !== E2.MAP && e7.drawPhase !== E2.DEBUG || void 0 === this._spriteMosaic || super.doRender(e7);
  }
  addChild(e7) {
    return super.addChild(e7), null != this._symbolFader ? this._symbolFader.addTile(e7) : e7.decluttered = true, this.requestRender(), e7;
  }
  removeChild(e7) {
    return null != this._symbolFader && this._symbolFader.removeTile(e7), this.requestRender(), super.removeChild(e7);
  }
  renderChildren(e7) {
    const { drawPhase: t6 } = e7;
    t6 !== E2.DEBUG ? this._doRender(e7) : super.renderChildren(e7);
  }
  removeAllChildren() {
    for (let e7 = 0; e7 < this.children.length; e7++) {
      const t6 = this.children[e7];
      null != this._symbolFader && this._symbolFader.removeTile(t6), t6.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e7) => e7.neededForCoverage && e7.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e7) {
    const { context: t6, state: s6 } = e7, r5 = this._styleRepository;
    if (!r5) return;
    const i5 = r5.layers, l = this._displayInfo.scaleToZoom(s6.scale);
    r5.backgroundBucketIds.length > 0 && (e7.renderPass = "background", this._renderBackgroundLayers(e7, r5.backgroundBucketIds, l)), super.renderChildren(e7), e7.drawPhase === E2.MAP && this._fade(l, s6);
    const o4 = this.children.filter((e8) => e8.visible && e8.hasData());
    if (!o4 || 0 === o4.length) return t6.bindVAO(), t6.setStencilTestEnabled(true), void t6.setBlendingEnabled(true);
    for (const n4 of o4) n4.triangleCount = 0;
    t6.setStencilWriteMask(0), t6.setColorMask(true, true, true, true), t6.setStencilOp(D.KEEP, D.KEEP, D.REPLACE), t6.setStencilTestEnabled(true), t6.setBlendingEnabled(false), t6.setDepthTestEnabled(true), t6.setDepthWriteEnabled(true), t6.setDepthFunction(C.LEQUAL), t6.setClearDepth(1), t6.clear(_2.DEPTH), e7.renderPass = "opaque";
    for (let n4 = i5.length - 1; n4 >= 0; n4--) this._renderStyleLayer(i5[n4], e7, o4);
    t6.setDepthWriteEnabled(false), t6.setBlendingEnabled(true), t6.setBlendFunctionSeparate(A.ONE, A.ONE_MINUS_SRC_ALPHA, A.ONE, A.ONE_MINUS_SRC_ALPHA), e7.renderPass = "translucent";
    for (let n4 = 0; n4 < i5.length; n4++) this._renderStyleLayer(i5[n4], e7, o4);
    t6.bindVAO(), t6.setStencilTestEnabled(true), t6.setBlendingEnabled(true);
    for (const n4 of o4) n4.debugInfo.display.triangleCount = n4.triangleCount;
  }
  _fade(e7, t6) {
    null != this._symbolFader && (this._symbolFader.update(e7, t6) || this.requestRender());
  }
  _renderStyleLayer(e7, t6, s6) {
    const { displayLevel: r5, painter: i5, renderPass: l } = t6;
    if (void 0 === e7) return;
    const a9 = e7.getLayoutProperty("visibility");
    if (a9 && a9.getValue() === a6.NONE) return;
    let d5;
    switch (e7.type) {
      case i2.BACKGROUND:
        return;
      case i2.FILL:
        if ("opaque" !== l && "translucent" !== t6.renderPass) return;
        d5 = "vtlFill";
        break;
      case i2.LINE:
        if ("translucent" !== l) return;
        d5 = "vtlLine";
        break;
      case i2.CIRCLE:
        if ("translucent" !== l) return;
        d5 = "vtlCircle";
        break;
      case i2.SYMBOL:
        if ("translucent" !== l) return;
        d5 = "vtlSymbol";
    }
    if (s6 = e7.type === i2.SYMBOL ? s6.filter((e8) => e8.decluttered) : s6.filter((e8) => e8.neededForCoverage), "vtlSymbol" !== d5 && (0 === s6.length || void 0 !== e7.minzoom && e7.minzoom >= r5 + g2 || void 0 !== e7.maxzoom && e7.maxzoom < r5 - g2)) return;
    const c5 = e7.uid;
    t6.styleLayerUID = c5, t6.styleLayer = e7;
    for (const o4 of s6) if (o4.layerData.has(c5)) {
      i5.renderObjects(t6, s6, d5);
      break;
    }
  }
  _renderBackgroundLayers(t6, i5, l) {
    const { context: o4, painter: a9, state: c5 } = t6, m4 = this._styleRepository;
    let f2 = false;
    for (const e7 of i5) {
      if (m4.getLayerById(e7).type === i2.BACKGROUND && b2(m4.getLayerById(e7), l)) {
        f2 = true;
        break;
      }
    }
    if (!f2) return;
    const g3 = this.tileInfoView, _5 = g3.getTileCoverage(t6.state, 0, true, "smallest"), { spans: C2, lodInfo: E4 } = _5, { level: F } = E4, L2 = u3(), R2 = [];
    if (this._renderPasses) {
      const e7 = this._renderPasses[0];
      null != this._clippingInfos && (e7.brushes[0].prepareState(t6), e7.brushes[0].drawMany(t6, this._clippingInfos));
    }
    const v = this._backgroundTiles;
    let S4, I2 = 0;
    for (const { row: n4, colFrom: h4, colTo: y3 } of C2) for (let t7 = h4; t7 <= y3; t7++) {
      if (I2 < v.length) S4 = v[I2], S4.key.set(F, n4, E4.normalizeCol(t7), E4.getWorldForColumn(t7)), g3.getTileBounds(L2, S4.key, false), S4.x = L2[0], S4.y = L2[3], S4.resolution = g3.getTileResolution(F);
      else {
        const i6 = new e4(F, n4, E4.normalizeCol(t7), E4.getWorldForColumn(t7)), l2 = g3.getTileBounds(u3(), i6), o5 = g3.getTileResolution(F);
        S4 = new t4(i6, o5, l2[0], l2[3], o, o, t, t), v.push(S4);
      }
      S4.setTransform(c5), R2.push(S4), I2++;
    }
    o4.setStencilWriteMask(0), o4.setColorMask(true, true, true, true), o4.setStencilOp(D.KEEP, D.KEEP, D.REPLACE), o4.setStencilFunction(C.EQUAL, 0, 255), o4.setStencilTestEnabled(true);
    for (const e7 of i5) {
      const s6 = m4.getLayerById(e7);
      s6.type === i2.BACKGROUND && b2(s6, l) && (t6.styleLayerUID = s6.uid, t6.styleLayer = s6, a9.renderObjects(t6, R2, "vtlBackground"));
    }
    s3.pool.release(_5);
  }
  _computeDisplayInfoView(e7) {
    let s6 = e7.tileInfo.lods[0].scale;
    const i5 = Math.max(25, e7.tileInfo.lods.length), l = [];
    for (let t6 = 0; t6 <= i5; t6++) l.push(s6), s6 /= 2;
    this._displayInfo = j.create({ scales: l, size: o, spatialReference: e7.spatialReference, numLODs: i5 });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileFeatureIndex.js
var h3 = (e7, t6) => {
  const s6 = e7.vtlSymbol.sourceTile, r5 = t6.vtlSymbol.sourceTile;
  return s6.level !== r5.level ? s6.level - r5.level : s6.row !== r5.row ? s6.row - r5.row : s6.col !== r5.col ? s6.col - r5.col : e7.styleLayerUID - t6.styleLayerUID;
};
var m3 = class _m {
  constructor(e7, t6, s6, r5, i5) {
    this.tileKey = e7, this._tileLayerData = t6, this._styleRepository = s6, this._tileHandler = r5, this._parentLayer = i5, this._index = null, this._tileKeyToPBF = /* @__PURE__ */ new Map();
  }
  static create(e7, t6, s6, r5, i5) {
    return new _m(e7, t6, s6, r5, i5);
  }
  clear() {
    this._index?.clear(), this._tileKeyToPBF.clear();
  }
  async queryAttributes(e7, t6, s6, i5, o4) {
    if (0 === this._tileLayerData.size || !this._styleRepository || !this._tileHandler) return [];
    null === this._index && (this._index = new s2(100, d4), await this._indexLayers());
    const l = [];
    return this._queryIndex(l, e7, t6, s6, this.tileKey.level, i5), o4 && o4?.length > 0 && await this._getSymbolsAttributes(l, o4), l;
  }
  async _indexLayers() {
    const e7 = this.tileKey, t6 = this._styleRepository.layers, s6 = await this._getTilePayload(e7);
    for (const [r5, i5] of this._tileLayerData) {
      const o4 = t6[r5], l = s6.find((e8) => e8.sourceName === o4.source);
      if (!l) continue;
      const { protobuff: a9, key: y3 } = l;
      if (i5.type !== E.SYMBOL) {
        const t7 = 1 << e7.level - y3.level, s7 = e7.row - y3.row * t7, r6 = e7.col - y3.col * t7;
        this._indexLayer(o4, a9, e7.level, t7, s7, r6);
      }
    }
  }
  _indexLayer(e7, t6, r5, l, n4, h4) {
    const m4 = e7.sourceLayer, d5 = e7.getFeatureFilter(), f2 = r5, _5 = r5 + 1, p5 = d2(f2), g3 = new a4(new Uint8Array(t6), new DataView(t6));
    for (; g3.next(); ) switch (g3.tag()) {
      case 3: {
        const t7 = g3.getMessage(), s6 = new t3(t7);
        if (t7.release(), s6.name !== m4) continue;
        const y3 = s6.getData(), w = s6.extent / l, b3 = w * h4 - p5, x = w * n4 - p5, L2 = b3 + w + 2 * p5, v = x + w + 2 * p5, I2 = w / o, D3 = t / w, T = w * h4, S4 = w * n4;
        for (; y3.nextTag(2); ) {
          const t8 = y3.getMessage(), i5 = new s4(t8, s6);
          if (t8.release(), d5 && !d5.filter(i5, r5)) continue;
          const o4 = i5.values || {}, l2 = o4._minzoom, n5 = o4._maxzoom;
          if (l2 && l2 >= 10 * _5 || n5 && n5 <= 10 * f2) continue;
          const c5 = e7.getFeatureInflatedBounds(i5, f2, s6.extent, I2);
          null == c5 || c5[0] > L2 || c5[1] > v || c5[2] < b3 || c5[3] < x || (c5[0] = (c5[0] - T) * D3, c5[1] = (c5[1] - S4) * D3, c5[2] = (c5[2] - T) * D3, c5[3] = (c5[3] - S4) * D3, this._index.insert(new L(e7, i5, c5, D3, T, S4)));
        }
        break;
      }
      default:
        g3.skip();
    }
    g3.release();
  }
  async _getSymbolsAttributes(e7, t6) {
    if (!t6 || 0 === t6.length) return e7;
    const s6 = [];
    if (t6.sort(h3), t6.length > 0) {
      let e8 = 0, { styleLayerUID: r6 } = t6[0];
      for (let o4 = 1; o4 < t6.length; o4++) {
        const { styleLayerUID: i6 } = t6[o4];
        i6 !== r6 && (s6.push({ from: e8, to: o4, styleLayerUID: r6, sourceTileKey: t6[o4 - 1].vtlSymbol.sourceTile }), e8 = o4, r6 = i6);
      }
      const i5 = t6.length - 1;
      s6.push({ from: e8, to: t6.length, styleLayerUID: r6, sourceTileKey: t6[i5].vtlSymbol.sourceTile });
    }
    const r5 = this._styleRepository.layers;
    for (const i5 of s6) {
      const s7 = await this._getTilePayload(i5.sourceTileKey), o4 = r5[i5.styleLayerUID], l = !!o4 && s7.find((e8) => e8.sourceName === o4.source);
      l && this._addSymbolsAttributes(e7, t6.slice(i5.from, i5.to).map((e8) => e8.vtlSymbol.featureIndex), i5.styleLayerUID, l);
    }
    return e7;
  }
  _addSymbolsAttributes(t6, s6, r5, i5) {
    const o4 = this._styleRepository.layers, l = i5.key, n4 = this.tileKey, a9 = 1 << n4.level - l.level, y3 = n4.row - l.row * a9, c5 = n4.col - l.col * a9;
    this._getSymbolAttributes(i5.protobuff, s6, r5, a9, y3, c5).forEach((s7) => {
      const { attributes: i6, tilePoint: l2 } = s7;
      t6.push({ layerId: o4[r5].id, layerIndex: r5, graphic: new d({ attributes: i6, origin: { type: "vector-tile", layerId: o4[r5].id, layerIndex: r5, layer: this._parentLayer } }), tilePoint: l2 });
    });
  }
  _getSymbolAttributes(e7, t6, r5, i5, l, n4) {
    const y3 = [], u6 = this._styleRepository.layers;
    let h4 = 0;
    t6.sort((e8, t7) => e8 - t7);
    const m4 = new a4(new Uint8Array(e7), new DataView(e7));
    for (; m4.next(); ) switch (m4.tag()) {
      case 3: {
        const e8 = m4.getMessage(), s6 = new t3(e8);
        if (e8.release(), s6.name !== u6[r5].sourceLayer) continue;
        const d5 = s6.getData(), f2 = s6.extent / i5, _5 = t / f2, p5 = f2 * n4, g3 = f2 * l;
        let w = 0;
        for (; d5.nextTag(2); ) {
          const e9 = d5.getMessage();
          if (w++ === t6[h4]) {
            const t7 = new s4(e9, s6), r6 = t7.values, i6 = t7.getGeometry(), o4 = null != i6 ? [_5 * (i6[0][0].x - p5), _5 * (i6[0][0].y - g3)] : null;
            y3.push({ attributes: r6, tilePoint: o4 }), h4++;
          }
          if (e9.release(), h4 === t6.length) return y3;
        }
        break;
      }
      default:
        m4.skip();
    }
    return m4.release(), y3;
  }
  _queryIndex(t6, s6, r5, i5, o4, n4) {
    const a9 = c * i5 * (window.devicePixelRatio || 1);
    return this._index?.search({ minX: s6 - a9, minY: r5 - a9, maxX: s6 + a9, maxY: r5 + a9 }, (l) => {
      const { layer: a10, feature: y3 } = l;
      a10.isIntersectingFeature(s6, r5, i5, y3, o4, n4, l) && t6.push({ layerId: a10.id, layerIndex: a10.uid, tilePoint: null, graphic: new d({ attributes: y3.values, origin: { type: "vector-tile", layerId: l.layer.id, layerIndex: l.layer.uid, layer: this._parentLayer } }) });
    }), t6;
  }
  async _getTilePayload(e7) {
    return u(this._tileKeyToPBF, e7.id, () => this._tileHandler.fetchTilePBFs(e7)).then((e8) => e8);
  }
};
var d4 = (e7) => ({ minX: e7.bounds[0], minY: e7.bounds[1], maxX: e7.bounds[2], maxY: e7.bounds[3] });

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t5 = class extends h {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e7) {
    const l = e4.pool.acquire(e7), t6 = 0 === l.level ? null : e4.getId(l.level - 1, l.row >> 1, l.col >> 1, l.world);
    return e4.pool.release(l), t6;
  }
  getTileCoverage(e7, l, s6 = true, t6) {
    const o4 = super.getTileCoverage(e7, l, s6, t6);
    if (!o4) return o4;
    const i5 = 1 << o4.lodInfo.level;
    return o4.spans = o4.spans.filter((e8) => e8.row >= 0 && e8.row < i5), o4;
  }
  scaleToLevel(e7) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e7]) return this._levelByScale[e7];
    {
      const l = this._fullCacheLodInfos;
      if (e7 > l[0].scale) return l[0].level;
      let s6, t6;
      for (let o4 = 0; o4 < l.length - 1; o4++) if (t6 = l[o4 + 1], e7 > t6.scale) return s6 = l[o4], s6.level + (s6.scale - e7) / (s6.scale - t6.scale);
      return l[l.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l) {
    let s6;
    if (0 === l[0].level) s6 = l.map((e7) => ({ level: e7.level, resolution: e7.resolution, scale: e7.scale }));
    else {
      const l2 = this.tileInfo.size[0], t6 = this.tileInfo.spatialReference;
      s6 = j.create({ size: l2, spatialReference: t6 }).lods.map((e7) => ({ level: e7.level, resolution: e7.resolution, scale: e7.scale }));
    }
    for (let e7 = 0; e7 < s6.length; e7++) this._levelByScale[s6[e7].scale] = s6[e7].level;
    this._fullCacheLodInfos = s6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var S3 = 2;
var D2 = 8;
var P2 = 512;
var Q = class extends i4(S2(u5)) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._styeChanged = false, this._spriteSourceChanged = false;
  }
  get fading() {
    return this._vectorTileContainer?.fading ?? false;
  }
  get hasVisibleFeatures() {
    const e7 = this._vectorTileContainer.children;
    for (const t6 of e7) if (t6.hasFeatures()) return true;
    return false;
  }
  get spriteSourceChanged() {
    return this._spriteSourceChanged;
  }
  get styleChanged() {
    return this._styeChanged;
  }
  async hitTest(e7, t6) {
    const i5 = this._tileHandlerPromise, s6 = this._vectorTileContainer?.symbolFader;
    if (!i5 || !this._isTileHandlerReady || !s6) return;
    await i5;
    let r5 = null;
    const a9 = this._vectorTileContainer?.symbolRepository;
    a9 && (r5 = a9.querySymbols(t6, S3, s6.decluttererOffset, {}));
    const l = this.view.state, n4 = this._tileManager.getIntersectingTiles(t6.x, t6.y, S3, l, r5);
    if ((!n4 || 0 === n4.length) && 0 === r5?.length) return null;
    e7 = e7.clone().normalize();
    const o4 = [], h4 = [];
    for (const u6 of n4) o4.push(this._queryTile(h4, e7, S3, this.view.state.rotation, u6, r5?.filter((e8) => e8.tileKey.id === u6.id)));
    return await Promise.all(o4), h4;
  }
  update(e7) {
    if (this._tileHandlerPromise && this._isTileHandlerReady) return e7.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._tileHandler.devicePixelRatio = e7.pixelRatio, void this._loadStyle()) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._pauseQueues(), this._fetchQueue.state = e7.state, this._parseQueue.state = e7.state, this._tileManager.update(e7) || this.requestUpdate(), this._resumeQueues()));
  }
  attach() {
    const { style: e7 } = this.layer.currentStyleInfo;
    this._styleRepository = new o2(e7), this._tileInfoView = new t5(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new _4(this._tileInfoView), this._tileHandler = new p4(this.layer, this._styleRepository, window.devicePixelRatio || 1, this.layer.tileInfo.lods.length - 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this.layer.on("paint-change", (e8) => {
      if (this._styeChanged = true, e8.isDataDriven) this._styleChanges.push({ type: I.PAINTER_CHANGED, data: e8 }), this.requestUpdate();
      else {
        const t6 = this._styleRepository, i5 = t6.getLayerById(e8.layer);
        if (!i5) return;
        const s6 = i5.type === i2.SYMBOL;
        t6.setPaintProperties(e8.layer, e8.paint), s6 && this._vectorTileContainer?.restartDeclutter(), this._vectorTileContainer?.requestRender();
      }
    }), this.layer.on("layout-change", (e8) => {
      const t6 = this._styleRepository, i5 = t6.getLayerById(e8.layer);
      if (!i5) return;
      this._styeChanged = true;
      const s6 = y2(i5.layout, e8.layout);
      if (null != s6) {
        if (p(s6, "visibility") && 1 === E3(s6)) return t6.setLayoutProperties(e8.layer, e8.layout), i5.type === i2.SYMBOL && this._vectorTileContainer?.restartDeclutter(), void this._vectorTileContainer?.requestRender();
        this._styleChanges.push({ type: I.LAYOUT_CHANGED, data: e8 }), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e8) => {
      const t6 = this._styleRepository, i5 = t6.getLayerById(e8.layer);
      i5 && (this._styeChanged = true, t6.setStyleLayerVisibility(e8.layer, e8.visibility), i5.type === i2.SYMBOL && this._vectorTileContainer?.restartDeclutter(), this._vectorTileContainer?.requestRender());
    }), this.layer.on("style-layer-change", (e8) => {
      this._styleChanges.push({ type: I.LAYER_CHANGED, data: e8 }), this._styeChanged = true, this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e8) => {
      this._styleChanges.push({ type: I.LAYER_REMOVED, data: e8 }), this._styeChanged = true, this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e8) => {
      this._spriteSourceChanged = true, this._styleChanges.push({ type: I.SPRITES_CHANGED, data: e8 });
      const t6 = this._styleRepository.layers;
      for (const i5 of t6) switch (i5.type) {
        case i2.SYMBOL:
          i5.getLayoutProperty("icon-image") && this._styleChanges.push({ type: I.LAYOUT_CHANGED, data: { layer: i5.id, layout: i5.layout } });
          break;
        case i2.LINE:
          i5.getPaintProperty("line-pattern") && this._styleChanges.push({ type: I.PAINTER_CHANGED, data: { layer: i5.id, paint: i5.paint, isDataDriven: i5.isPainterDataDriven() } });
          break;
        case i2.FILL:
          i5.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: I.PAINTER_CHANGED, data: { layer: i5.id, paint: i5.paint, isDataDriven: i5.isPainterDataDriven() } });
      }
      this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = u2(this._vectorTileContainer), this._tileHandler = u2(this._tileHandler);
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  supportsSpatialReference(e7) {
    return s(this.layer.tileInfo?.spatialReference, e7);
  }
  canResume() {
    let e7 = super.canResume();
    const { currentStyleInfo: t6 } = this.layer;
    if (e7 && t6?.layerDefinition) {
      const i5 = this.view.scale, { minScale: s6, maxScale: r5 } = t6.layerDefinition;
      t6?.layerDefinition && (s6 && s6 < i5 && (e7 = false), r5 && r5 > i5 && (e7 = false));
    }
    return e7;
  }
  isUpdating() {
    return this.fading;
  }
  acquireTile(e7) {
    const t6 = this._createVectorTile(e7);
    return this._updatingHandles.addPromise(this._fetchQueue.push(t6.key).then((e8) => this._parseQueue.push({ key: t6.key, data: e8 })).then((e8) => {
      t6.once("attach", () => this.requestUpdate()), t6.setData(e8), this.requestUpdate();
    }).catch((e8) => {
      b(e8) || i.getLogger(this).error(e8);
    })), t6;
  }
  releaseTile(e7) {
    const t6 = e7.key.id;
    this._fetchQueue.abort(t6), this._parseQueue.abort(t6), this.requestUpdate();
  }
  async doRefresh() {
    if (!this.attached) return;
    if (this.suspended) return this._tileManager.clear(), void this.requestUpdate();
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._tileManager.clearCache(), this._resumeQueues();
    const e7 = this._vectorTileContainer.children, t6 = [];
    try {
      for (const i5 of e7) {
        const e8 = this._updatingHandles.addPromise(this._fetchQueue.push(i5.key).then((e9) => this._parseQueue.push({ key: i5.key, data: e9 })).then((e9) => i5.setData(e9)).finally(() => i5.featureIndex = null));
        t6.push(e8);
      }
      await Promise.all(t6);
    } catch (s6) {
      i.getLogger(this).error("error refreshing vector-tiles layer-view", s6), this._resumeQueues(), this._isTileHandlerReady = true;
    }
    this._isTileHandlerReady = true, this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new c4({ acquireTile: (e8) => this.acquireTile(e8), releaseTile: (e8) => this.releaseTile(e8), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo) return;
    const e7 = new AbortController(), t6 = this._tileHandler.start({ signal: e7.signal }).then(() => {
      this._fetchQueue = new p2({ tileInfoView: this._tileInfoView, process: (e8, t7) => this._getTileData(e8, t7), concurrency: 15, scheduler: this.scheduler, priority: g.MAPVIEW_FETCH_QUEUE }), this._parseQueue = new p2({ tileInfoView: this._tileInfoView, process: (e8, t7) => this._parseTileData(e8, t7), concurrency: 8, scheduler: this.scheduler, priority: g.MAPVIEW_VECTOR_TILE_PARSING_QUEUE }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e8) => {
      this._vectorTileContainer.setStyleResources(e8, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this.requestUpdate();
    }), this._tileHandlerAbortController = e7, this._tileHandlerPromise = t6;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer) return;
    const e7 = this._tileHandlerAbortController;
    e7 && e7.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = u2(this._fetchQueue), this._parseQueue = u2(this._parseQueue), this._tileManager = u2(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e7, t6) {
    return this._tileHandler.fetchTileData(e7, t6);
  }
  async _parseTileData(e7, t6) {
    return this._tileHandler.parseTileData(e7, t6);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._tileManager.clearCache();
    const e7 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e7);
    } catch (l) {
      i.getLogger(this).error("error applying vector-tiles style update", l.message), this._resumeQueues(), this._isTileHandlerReady = true;
    }
    const t6 = this._styleRepository, s6 = /* @__PURE__ */ new Set();
    e7.forEach((e8) => {
      if (e8.type !== I.LAYER_REMOVED) return;
      const i5 = e8.data, r6 = t6.getLayerById(i5.layer);
      r6 && s6.add(r6.uid);
    });
    const r5 = /* @__PURE__ */ new Set();
    e7.forEach((e8) => {
      let i5;
      switch (e8.type) {
        case I.PAINTER_CHANGED:
          t6.setPaintProperties(e8.data.layer, e8.data.paint), i5 = e8.data.layer;
          break;
        case I.LAYOUT_CHANGED:
          t6.setLayoutProperties(e8.data.layer, e8.data.layout), i5 = e8.data.layer;
          break;
        case I.LAYER_REMOVED:
          return void t6.deleteStyleLayer(e8.data.layer);
        case I.LAYER_CHANGED:
          t6.setStyleLayer(e8.data.layer, e8.data.index), i5 = e8.data.layer.id;
          break;
        case I.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(e8.data.spriteSource));
      }
      if (i5) {
        const e9 = t6.getLayerById(i5);
        e9 && r5.add(e9.uid);
      }
    });
    const a9 = this._vectorTileContainer.children;
    if (s6.size > 0) {
      const e8 = Array.from(s6);
      this._vectorTileContainer.deleteStyleLayers(e8);
      for (const t7 of a9) t7.deleteLayerData(e8);
    }
    if (this._resumeQueues(), r5.size > 0) {
      const e8 = Array.from(r5), t7 = [];
      for (const i5 of a9) {
        const s7 = this._updatingHandles.addPromise(this._fetchQueue.push(i5.key).then((t8) => this._parseQueue.push({ key: i5.key, data: t8, styleLayerUIDs: e8 })).then((e9) => i5.setData(e9)).finally(() => i5.featureIndex = null));
        t7.push(s7);
      }
      await Promise.all(t7);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e7 } = this.layer.currentStyleInfo, i5 = a(e7);
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._styleRepository = new o2(i5), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s6 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, i5, this.layer.tileInfo.lods.length - 1), await this._tileHandlerPromise;
    } catch (n4) {
      if (!b(n4)) throw n4;
    }
    if (s6.aborted) return this._resumeQueues(), this._isTileHandlerReady = true, this._styeChanged = false, this._spriteSourceChanged = false, void this.requestUpdate();
    const a9 = await this._tileHandler.spriteMosaic, l = this._vectorTileContainer;
    this._tileInfoView = new t5(this.layer.tileInfo, this.layer.fullExtent), l.setStyleResources(a9, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this._tileManager = new c4({ acquireTile: (e8) => this.acquireTile(e8), releaseTile: (e8) => this.releaseTile(e8), tileInfoView: this._tileInfoView }, this._vectorTileContainer), this._resumeQueues(), this._isTileHandlerReady = true, this.requestUpdate(), this._styeChanged = false, this._spriteSourceChanged = false;
  }
  _createVectorTile(e7) {
    const t6 = this._tileInfoView.getTileBounds(u3(), e7), i5 = this._tileInfoView.getTileResolution(e7.level);
    return new m2(e7, i5, t6[0], t6[3], 512, 512, this._styleRepository);
  }
  async _queryTile(e7, t6, i5, s6, r5, a9) {
    if (0 === r5.layerData.size) return;
    const l = this._ensureTileIndex(r5), n4 = this._tileInfoView.getTileBounds(u3(), r5.key, true), o4 = D2 * P2 * ((t6.x - n4[0]) / (n4[2] - n4[0])), h4 = D2 * P2 * (1 - (t6.y - n4[1]) / (n4[3] - n4[1])), y3 = await l.queryAttributes(o4, h4, i5, s6, a9);
    for (const u6 of y3) u6.graphic.geometry = this._tileToMapPoint(u6.tilePoint, r5.transforms.tileUnitsToPixels), e7.push({ type: "graphic", layer: this.layer, graphic: u6.graphic, mapPoint: t6.clone() });
    e7.sort((e8, t7) => t7.graphic.origin.layerIndex - e8.graphic.origin.layerIndex);
  }
  _tileToMapPoint(e7, t6) {
    if (!e7) return null;
    const i5 = e7[0] * t6[0] + e7[1] * t6[3] + t6[6], s6 = e7[0] * t6[1] + e7[1] * t6[4] + t6[7], r5 = this.view.state, a9 = [0, 0];
    return r5.toMap(a9, [i5, s6]), new _({ x: a9[0], y: a9[1], spatialReference: r5.spatialReference });
  }
  _ensureTileIndex(e7) {
    let t6 = e7.featureIndex;
    return t6 || (t6 = m3.create(e7.key, e7.layerData, this._styleRepository, this._tileHandler, this.layer), e7.featureIndex = t6), t6;
  }
  _pauseQueues() {
    this._fetchQueue.pause(), this._parseQueue.pause();
  }
  _resumeQueues() {
    this._fetchQueue.resume(), this._parseQueue.resume();
  }
  _clearQueues() {
    this._fetchQueue.clear(), this._parseQueue.clear();
  }
};
function E3(e7) {
  if (null == e7) return 0;
  switch (e7.type) {
    case "partial":
      return Object.keys(e7.diff).length;
    case "complete":
      return Math.max(Object.keys(e7.oldValue).length, Object.keys(e7.newValue).length);
    case "collection":
      return Object.keys(e7.added).length + Object.keys(e7.changed).length + Object.keys(e7.removed).length;
  }
}
r([m()], Q.prototype, "_isTileHandlerReady", void 0), Q = r([a2("esri.views.2d.layers.VectorTileLayerView2D")], Q);
var A2 = Q;
export {
  A2 as default
};
//# sourceMappingURL=VectorTileLayerView2D-2D3MMNJA.js.map
