import {
  R
} from "./chunk-TQYXUH7I.js";
import {
  b as b2,
  x as x2
} from "./chunk-FQ4JUVCN.js";
import {
  e as e3
} from "./chunk-3LL6ALVC.js";
import "./chunk-CCHJ3WNU.js";
import "./chunk-P4RYESYB.js";
import "./chunk-BMFPNVV7.js";
import "./chunk-HCBZZ3ZP.js";
import "./chunk-PXOUV6KP.js";
import {
  A,
  Q,
  c as c2,
  e as e2,
  i as i4,
  s as s4,
  u as u5
} from "./chunk-TMFB3DKM.js";
import {
  i as i3
} from "./chunk-PZV6BOD6.js";
import {
  l as l3
} from "./chunk-H7SHPX7W.js";
import {
  a as a7,
  u as u4
} from "./chunk-NOWX6W7R.js";
import {
  p
} from "./chunk-OQ76WPLD.js";
import {
  e
} from "./chunk-KSVHYEPS.js";
import "./chunk-ELSQQIKB.js";
import {
  j
} from "./chunk-VGIEH4HM.js";
import {
  t
} from "./chunk-X5GD6LFD.js";
import {
  b2 as b,
  d,
  y as y2
} from "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import "./chunk-UGXCZZ7N.js";
import {
  Z
} from "./chunk-JEYXDNAT.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-QG7JWSBW.js";
import {
  v
} from "./chunk-CAZNHUEV.js";
import "./chunk-XDXJG3QL.js";
import "./chunk-YSCIEMYQ.js";
import "./chunk-5GBXHGKW.js";
import {
  m as m2
} from "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-YZLWQJLF.js";
import {
  h
} from "./chunk-L7EN54WK.js";
import {
  u as u2
} from "./chunk-6QTMK7BB.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import {
  a as a6
} from "./chunk-ZAISHGSP.js";
import {
  q
} from "./chunk-YX2VTIZR.js";
import {
  l as l2
} from "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import {
  i as i2
} from "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import {
  c,
  u as u3
} from "./chunk-7BWCD63N.js";
import {
  n
} from "./chunk-65K4DQAH.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import {
  n as n2,
  r as r3,
  u
} from "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import {
  a as a5
} from "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import "./chunk-A3VAC24F.js";
import {
  o,
  r as r2
} from "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  _
} from "./chunk-Q6XRAGMA.js";
import {
  o as o2
} from "./chunk-JUAPMINU.js";
import {
  f as f2
} from "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import {
  s as s3
} from "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import {
  s as s2
} from "./chunk-KTUX3OKX.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a3
} from "./chunk-JUAD7TJ6.js";
import {
  a as a2,
  x
} from "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  f2 as f,
  y2 as y
} from "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  a as a4
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import {
  a
} from "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/voxel/voxelPlaneUtils.js
var f3 = n2();
var l4 = e3();
var u6 = e3();
var p2 = e3();
var h2 = r3(0, 0, 1);
var j2 = r3(0, 1, 0);
var x3 = r3(1, 0, 0);
function b3(r5) {
  s4(f3, r5), A(f3, f3);
  const a10 = Math.atan2(f3[1], f3[0]), s8 = b2(e3(), h2, -a10);
  Q(f3, f3, s8);
  const c5 = -1 * Math.atan2(f3[2], f3[0]);
  return [c(a10) + 270, c(c5) + 90];
}
function g(o3, a10) {
  return b2(u6, h2, u3(o3 - 270)), b2(p2, j2, u3(a10 - 90)), x2(l4, u6, p2), s4(f3, x3), Q(f3, f3, l4), A(f3, f3), [f3[0], f3[1], f3[2]];
}

// node_modules/@arcgis/core/layers/voxel/VoxelSlice.js
var m3 = class extends a5.ClonableMixin(l) {
  constructor(o3) {
    super(o3), this.enabled = true, this.label = "", this.normal = null, this.point = null;
  }
  get orientation() {
    if (!Array.isArray(this.normal) || 3 !== this.normal.length) return 0;
    const [o3, r5] = b3(this.normal);
    return a6.normalize(a2(o3), 0, true);
  }
  set orientation(o3) {
    const r5 = g(o3, this.tilt);
    this._set("normal", r5), this._set("orientation", o3);
  }
  get tilt() {
    if (!Array.isArray(this.normal) || 3 !== this.normal.length) return 0;
    const [o3, r5] = b3(this.normal);
    return a6.normalize(a2(r5), 0, true);
  }
  set tilt(o3) {
    const r5 = g(this.orientation, o3);
    this._set("normal", r5), this._set("tilt", o3);
  }
};
r([m({ type: Boolean, json: { write: true } })], m3.prototype, "enabled", void 0), r([m({ type: String, json: { write: true } })], m3.prototype, "label", void 0), r([m({ type: Number, json: { read: false }, clonable: false, range: { min: 0, max: 360 } }), s2((o3) => a6.normalize(a2(o3), 0, true))], m3.prototype, "orientation", null), r([m({ type: Number, json: { read: false }, clonable: false, range: { min: 0, max: 360 } }), s2((o3) => a6.normalize(a2(o3), 0, true))], m3.prototype, "tilt", null), r([m({ type: [Number], json: { write: { isRequired: true } } })], m3.prototype, "normal", void 0), r([m({ type: [Number], json: { write: { isRequired: true } } })], m3.prototype, "point", void 0), m3 = r([a3("esri.layers.voxel.VoxelSlice")], m3);

// node_modules/@arcgis/core/layers/voxel/VoxelSection.js
var d2 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.enabled = true, this.href = null, this.id = null, this.label = "", this.normal = null, this.point = null, this.sizeInPixel = null, this.slices = null, this.timeId = 0, this.variableId = null;
  }
  get orientation() {
    if (!Array.isArray(this.normal) || 3 !== this.normal.length) return 0;
    const [e4, r5] = b3(this.normal);
    return a6.normalize(a2(e4), 0, true);
  }
  get tilt() {
    if (!Array.isArray(this.normal) || 3 !== this.normal.length) return 0;
    const [e4, r5] = b3(this.normal);
    return a6.normalize(a2(r5), 0, true);
  }
};
r([m({ type: Boolean, json: { default: true, write: true } })], d2.prototype, "enabled", void 0), r([m({ type: String, json: { origins: { service: { read: f }, "web-scene": { write: { isRequired: true } } }, write: true } }), v({ origins: ["web-scene"], type: "resource", prefix: "sections", compress: true })], d2.prototype, "href", void 0), r([m({ type: x, json: { write: { enabled: true, isRequired: true } } })], d2.prototype, "id", void 0), r([m({ type: String, json: { write: true } })], d2.prototype, "label", void 0), r([m({ type: Number, clonable: false, readOnly: true, range: { min: 0, max: 360 } })], d2.prototype, "orientation", null), r([m({ type: Number, clonable: false, readOnly: true, range: { min: 0, max: 360 } })], d2.prototype, "tilt", null), r([m({ type: [Number], json: { write: { enabled: true, isRequired: true } } })], d2.prototype, "normal", void 0), r([m({ type: [Number], json: { write: { enabled: true, isRequired: true } } })], d2.prototype, "point", void 0), r([m({ type: [x], json: { write: { enabled: true, isRequired: true } } })], d2.prototype, "sizeInPixel", void 0), r([m({ type: [m3], json: { write: true } })], d2.prototype, "slices", void 0), r([m({ type: x, json: { default: 0, write: true } })], d2.prototype, "timeId", void 0), r([m({ type: x, json: { write: { enabled: true, isRequired: true } } })], d2.prototype, "variableId", void 0), d2 = r([a3("esri.layers.voxel.VoxelSection")], d2);

// node_modules/@arcgis/core/layers/voxel/VoxelSimpleShading.js
var t2 = class extends l {
  constructor() {
    super(...arguments), this.diffuseFactor = 0.5, this.specularFactor = 0.5;
  }
};
r([m({ type: Number, range: { min: 0, max: 1 }, json: { default: 0.5, write: true } })], t2.prototype, "diffuseFactor", void 0), r([m({ type: Number, range: { min: 0, max: 1 }, json: { default: 0.5, write: true } })], t2.prototype, "specularFactor", void 0), t2 = r([a3("esri.layers.voxel.VoxelSimpleShading")], t2);

// node_modules/@arcgis/core/layers/voxel/VoxelFormat.js
var s5 = class extends l {
  constructor() {
    super(...arguments), this.continuity = null, this.hasNoData = false, this.noData = 0, this.offset = 0, this.scale = 1, this.type = null;
  }
};
r([m({ type: ["discrete", "continuous"], json: { write: true } })], s5.prototype, "continuity", void 0), r([m({ type: Boolean, json: { write: true } })], s5.prototype, "hasNoData", void 0), r([m({ type: Number, json: { write: true } })], s5.prototype, "noData", void 0), r([m({ type: Number, json: { write: true } })], s5.prototype, "offset", void 0), r([m({ type: Number, json: { write: true } })], s5.prototype, "scale", void 0), r([m({ type: String, json: { write: { enabled: true, isRequired: true } } })], s5.prototype, "type", void 0), s5 = r([a3("esri.layers.voxel.VoxelFormat")], s5);
var p3 = s5;

// node_modules/@arcgis/core/layers/voxel/VoxelVariable.js
var s6 = class extends l {
  constructor() {
    super(...arguments), this.id = null, this.description = "", this.name = null, this.originalFormat = null, this.renderingFormat = null, this.unit = "", this.volumeId = 0, this.type = null;
  }
};
r([m({ type: Number, json: { write: { enabled: true, isRequired: true } } })], s6.prototype, "id", void 0), r([m({ type: String, json: { write: true } })], s6.prototype, "description", void 0), r([m({ type: String, json: { write: { enabled: true, isRequired: true } } })], s6.prototype, "name", void 0), r([m({ type: p3, json: { write: true } })], s6.prototype, "originalFormat", void 0), r([m({ type: p3, json: { write: { enabled: true, isRequired: true } } })], s6.prototype, "renderingFormat", void 0), r([m({ type: String, json: { write: true } })], s6.prototype, "unit", void 0), r([m({ type: Number, json: { write: true } })], s6.prototype, "volumeId", void 0), r([m({ type: ["stc-hot-spot-results", "stc-cluster-outlier-results", "stc-estimated-bin", "generic-nearest-interpolated"], json: { write: true } })], s6.prototype, "type", void 0), s6 = r([a3("esri.layers.voxel.VoxelVariable")], s6);
var p4 = s6;

// node_modules/@arcgis/core/layers/voxel/VoxelIsosurface.js
var l5 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.color = l2.fromArray([0, 0, 0, 0]), this.value = 0, this.enabled = true, this.label = "", this.colorLocked = false;
  }
};
r([m({ type: l2, json: { type: [x], write: { enabled: true, isRequired: true } } })], l5.prototype, "color", void 0), r([m({ type: Number, json: { write: { enabled: true, isRequired: true } } })], l5.prototype, "value", void 0), r([m({ type: Boolean, json: { default: true, write: true } })], l5.prototype, "enabled", void 0), r([m({ type: String, json: { write: true } })], l5.prototype, "label", void 0), r([m({ type: Boolean, json: { default: false, write: true } })], l5.prototype, "colorLocked", void 0), l5 = r([a3("esri.layers.voxel.VoxelIsosurface")], l5);

// node_modules/@arcgis/core/layers/voxel/VoxelColorStop.js
var c3 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.color = null, this.position = 0;
  }
};
r([m({ type: l2, json: { type: [x], write: { enabled: true, isRequired: true } } })], c3.prototype, "color", void 0), r([m({ type: Number, json: { write: { enabled: true, isRequired: true } } })], c3.prototype, "position", void 0), c3 = r([a3("esri.layers.voxel.VoxelColorStop")], c3);
var l6 = c3;

// node_modules/@arcgis/core/layers/voxel/VoxelOpacityStop.js
var p5 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.opacity = 1, this.position = 0;
  }
};
r([m({ type: Number, json: { name: "alpha", write: { enabled: true, isRequired: true } } })], p5.prototype, "opacity", void 0), r([m({ type: Number, json: { write: { enabled: true, isRequired: true } } })], p5.prototype, "position", void 0), p5 = r([a3("esri.layers.voxel.VoxelOpacityStop")], p5);
var i5 = p5;

// node_modules/@arcgis/core/layers/voxel/VoxelRangeFilter.js
var p6 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.enabled = false, this.range = null;
  }
};
r([m({ type: Boolean, json: { default: false, write: true } })], p6.prototype, "enabled", void 0), r([m({ type: [Number], json: { write: { isRequired: true } } })], p6.prototype, "range", void 0), p6 = r([a3("esri.layers.voxel.VoxelRangeFilter")], p6);
var a8 = p6;

// node_modules/@arcgis/core/layers/voxel/VoxelTransferFunctionStyle.js
var u7;
!function(o3) {
  o3[o3.Color = 1] = "Color", o3[o3.Alpha = 2] = "Alpha", o3[o3.Both = 3] = "Both";
}(u7 || (u7 = {}));
var y3 = class extends a5.ClonableMixin(l) {
  constructor(o3) {
    super(o3), this.interpolation = null, this.stretchRange = null, this.rangeFilter = null, this._colorMapSize = 256, this.colorStops = new (V.ofType(l6))(), this.opacityStops = new (V.ofType(i5))();
  }
  set colorStops(o3) {
    this._set("colorStops", n(o3, this._get("colorStops"), V.ofType(l6)));
  }
  set opacityStops(o3) {
    this._set("opacityStops", n(o3, this._get("opacityStops"), V.ofType(i5)));
  }
  getPreviousNext(o3, t6, r5) {
    let e4 = o3;
    for (; --e4 > 0 && t6[e4].type !== r5 && t6[e4].type !== u7.Both; ) ;
    let s8 = o3;
    const i6 = t6.length;
    for (; ++s8 < i6 && t6[s8].type !== r5 && t6[s8].type !== u7.Both; ) ;
    return [e4, s8];
  }
  get rasterizedTransferFunction() {
    const o3 = [];
    if (this.colorStops.length < 2) return o3;
    const r5 = [], e4 = [], s8 = 1e-5;
    for (const t6 of this.colorStops) {
      if (!t6.color) return o3;
      e4.push({ color: { r: t6.color.r, g: t6.color.g, b: t6.color.b, a: Math.round(255 * (1 - t6.color.a)) }, position: t6.position, type: u7.Color });
    }
    if (0 === this.opacityStops.length) for (const t6 of e4) r5.push({ color: t6.color, position: t6.position });
    else {
      for (const t6 of this.opacityStops) {
        const o5 = r2(t6.position, 0, 1), r6 = Math.round(255 * r2(1 - t6.opacity, 0, 1));
        let i7 = false;
        for (const t7 of e4) if (t7.type === u7.Color && Math.abs(t7.position - o5) < s8) {
          t7.color.a = r6, t7.type = u7.Both, i7 = true;
          break;
        }
        i7 || e4.push({ color: { r: 0, g: 0, b: 0, a: r6 }, position: t6.position, type: u7.Alpha });
      }
      e4.sort((o5, t6) => o5.position < t6.position ? -1 : 1);
      const o4 = e4.length;
      for (let t6 = 0; t6 < o4; ++t6) {
        const r6 = e4[t6];
        if (r6.type !== u7.Both) if (r6.type === u7.Color) {
          const [s9, i7] = this.getPreviousNext(t6, e4, u7.Alpha);
          if (-1 !== s9 && i7 !== o4) {
            const o5 = (r6.position - e4[s9].position) / (e4[i7].position - e4[s9].position);
            r6.color.a = Math.round(o(e4[s9].color.a, e4[i7].color.a, o5));
          } else r6.color.a = -1 !== s9 ? e4[s9].color.a : e4[i7].color.a;
        } else {
          const [s9, i7] = this.getPreviousNext(t6, e4, u7.Color);
          if (-1 !== s9 && i7 !== o4) {
            const o5 = (r6.position - e4[s9].position) / (e4[i7].position - e4[s9].position), t7 = e4[s9].color, p12 = e4[i7].color;
            S2.forEach((e5) => {
              r6.color[e5] = Math.round(o(t7[e5], p12[e5], o5));
            });
          } else -1 !== s9 ? S2.forEach((o5) => {
            r6.color[o5] = e4[s9].color[o5];
          }) : S2.forEach((o5) => {
            r6.color[o5] = e4[i7].color[o5];
          });
        }
      }
      for (const t6 of e4) r5.push({ color: t6.color, position: t6.position });
    }
    r5[0].position = 0, r5[r5.length - 1].position = 1;
    let i6 = 0, l8 = 1;
    for (let c5 = 0; c5 < this._colorMapSize; ++c5) {
      const e5 = c5 / this._colorMapSize;
      for (; e5 > r5[l8].position; ) i6 = l8++;
      const s9 = (e5 - r5[i6].position) / (r5[l8].position - r5[i6].position), a10 = r5[i6].color, h3 = r5[l8].color, f5 = new l2();
      S2.forEach((o4) => {
        f5[o4] = Math.round(o(a10[o4], h3[o4], s9));
      }), f5.a = r2(1 - o(a10.a, h3.a, s9) / 255, 0, 1), o3.push(f5);
    }
    return o3;
  }
  getColorForContinuousDataValue(o3, t6) {
    const r5 = this.rasterizedTransferFunction;
    if (this.colorStops.length < 2 || !Array.isArray(this.stretchRange) || this.stretchRange.length < 2 || r5.length < 256) return null;
    let e4 = this.stretchRange[0], s8 = this.stretchRange[1];
    if (e4 > s8) {
      const o4 = e4;
      e4 = s8, s8 = o4;
    }
    o3 = r2(o3, e4, s8);
    const i6 = r5[Math.round((o3 - e4) / (s8 - e4) * (this._colorMapSize - 1))].clone();
    return t6 || (i6.a = 1), i6;
  }
};
r([m({ type: ["linear", "nearest"], json: { write: true } })], y3.prototype, "interpolation", void 0), r([m({ type: [Number], json: { write: { enabled: true, isRequired: true } } })], y3.prototype, "stretchRange", void 0), r([m({ type: V.ofType(l6), json: { write: { enabled: true, overridePolicy() {
  return { enabled: !!this.colorStops && this.colorStops.length > 0 };
} } } })], y3.prototype, "colorStops", null), r([m({ type: V.ofType(i5), json: { read: { source: "alphaStops" }, write: { enabled: true, target: "alphaStops", overridePolicy() {
  return { enabled: !!this.opacityStops && this.opacityStops.length > 0 };
} } } })], y3.prototype, "opacityStops", null), r([m({ type: a8, json: { write: true } })], y3.prototype, "rangeFilter", void 0), r([m({ type: [l2], clonable: false, json: { read: false } })], y3.prototype, "rasterizedTransferFunction", null), y3 = r([a3("esri.layers.voxel.VoxelTransferFunctionStyle")], y3);
var g2 = y3;
var S2 = ["r", "g", "b"];

// node_modules/@arcgis/core/layers/voxel/VoxelUniqueValue.js
var l7 = class extends a5.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.color = l2.fromArray([0, 0, 0, 0]), this.value = 0, this.enabled = true, this.label = "";
  }
};
r([m({ type: l2, json: { type: [x], write: { enabled: true, isRequired: true } } })], l7.prototype, "color", void 0), r([m({ type: x, json: { write: { enabled: true, isRequired: true } } })], l7.prototype, "value", void 0), r([m({ type: Boolean, json: { default: true, write: true } })], l7.prototype, "enabled", void 0), r([m({ type: String, json: { write: true } })], l7.prototype, "label", void 0), l7 = r([a3("esri.layers.voxel.VoxelUniqueValue")], l7);

// node_modules/@arcgis/core/layers/voxel/VoxelVariableStyle.js
var p7;
var c4 = p7 = class extends l {
  constructor(e4) {
    super(e4), this.variableId = 0, this.label = "", this.transferFunction = null, this.uniqueValues = null, this.isosurfaces = null, this.uniqueValues = new (V.ofType(l7))(), this.isosurfaces = new (V.ofType(l5))();
  }
  clone() {
    return new p7({ variableId: this.variableId, label: this.label, transferFunction: a(this.transferFunction), uniqueValues: a(this.uniqueValues), isosurfaces: a(this.isosurfaces) });
  }
};
r([m({ type: x, json: { write: { enabled: true, isRequired: true } } })], c4.prototype, "variableId", void 0), r([m({ type: String, json: { write: true } })], c4.prototype, "label", void 0), r([m({ type: g2, json: { write: { enabled: true, overridePolicy() {
  return { enabled: !this.uniqueValues || this.uniqueValues.length < 1 };
} } } })], c4.prototype, "transferFunction", void 0), r([m({ type: V.ofType(l7), json: { write: { enabled: true, overridePolicy() {
  return { enabled: !!this.uniqueValues && this.uniqueValues.length > 0 };
} } } })], c4.prototype, "uniqueValues", void 0), r([m({ type: V.ofType(l5), json: { write: { enabled: true, overridePolicy() {
  const e4 = !this.uniqueValues || this.uniqueValues.length < 1, s8 = !!this.isosurfaces && this.isosurfaces.length > 0;
  return { enabled: e4 && s8 };
} } } })], c4.prototype, "isosurfaces", void 0), c4 = p7 = r([a3("esri.layers.voxel.VoxelVariableStyle")], c4);

// node_modules/@arcgis/core/layers/voxel/NCTimeParser.js
function r4(r5) {
  const e4 = /^(days?|hours?|minutes?|seconds?|d|h|m|s) since (\d{1,4})-(\d{1,2})-(\d{1,2})[ |T](\d{1,2}):(\d{1,2}):(\d{1,2})(\.[0-9]+)?[\s|Z]?(([+|\-|\s?])(\d{1,2}):(\d{1,2}))?$/i.exec(r5);
  if (null == e4) return { didParse: false };
  const [, t6, s8, a10, d4, n3, i6, u8, N, o3, c5, f5, p12] = e4;
  let $ = "seconds";
  const P = t6.charAt(0).toLowerCase();
  "d" === P ? $ = "days" : "h" === P ? $ = "hours" : "m" === P && ($ = "minutes");
  const m6 = parseInt(s8, 10);
  if (Number.isNaN(m6)) return { didParse: false };
  const b4 = parseInt(a10, 10);
  if (Number.isNaN(b4) || b4 < 1 || b4 > 12) return { didParse: false };
  const I = parseInt(d4, 10);
  if (Number.isNaN(I) || I < 1 || I > 31) return { didParse: false };
  if (2 === b4) {
    const r6 = m6 % 4 == 0 && (m6 % 100 != 0 || m6 % 400 == 0);
    if (r6 && I > 29 || !r6 && I > 28) return { didParse: false };
  } else if ((4 === b4 || 6 === b4 || 9 === b4 || 11 === b4) && I > 30) return { didParse: false };
  const S3 = parseInt(n3, 10);
  if (Number.isNaN(S3) || S3 < 0 || S3 > 23) return { didParse: false };
  const l8 = parseInt(i6, 10);
  if (Number.isNaN(l8) || l8 < 0 || l8 > 59) return { didParse: false };
  const h3 = parseInt(u8, 10);
  if (Number.isNaN(h3) || h3 < 0 || h3 > 59) return { didParse: false };
  let w = 1, x4 = 0, y4 = 0;
  if (c5 && (w = "-" === c5 ? -1 : 1), f5) {
    if (x4 = parseInt(f5, 10), Number.isNaN(x4) || x4 < 0) return { didParse: false };
    if (0 !== x4) {
      const r6 = w * x4;
      if (r6 < -12 || r6 > 14) return { didParse: false };
    }
  }
  if (p12 && (y4 = parseInt(p12, 10), Number.isNaN(y4) || y4 < 0 || y4 > 59)) return { didParse: false };
  const T = `${m6}`.padStart(4, "0"), Z2 = `${b4}`.padStart(2, "0"), A2 = `${I}`.padStart(2, "0"), C = `${S3}`.padStart(2, "0"), D = `${l8}`.padStart(2, "0"), L = `${h3}`.padStart(2, "0");
  let g3 = "Z";
  0 === x4 && 0 === y4 || (g3 = w > 0 ? "+" : "-", g3 += `${x4}`.padStart(2, "0"), g3 += ":", g3 += `${y4}`.padStart(2, "0"));
  return { didParse: true, unit: $, reference: /* @__PURE__ */ new Date(`${T}-${Z2}-${A2}T${C}:${D}:${L}.000${g3}`) };
}

// node_modules/@arcgis/core/layers/voxel/VoxelIrregularSpacing.js
var t3 = class extends l {
  constructor() {
    super(...arguments), this.values = null;
  }
};
r([m({ type: [Number], json: { write: true } })], t3.prototype, "values", void 0), t3 = r([a3("esri.layers.voxel.VoxelIrregularSpacing")], t3);
var p8 = t3;

// node_modules/@arcgis/core/layers/voxel/VoxelRegularSpacing.js
var t4 = class extends l {
  constructor() {
    super(...arguments), this.scale = 1, this.offset = 0;
  }
};
r([m({ type: Number, json: { write: true } })], t4.prototype, "scale", void 0), r([m({ type: Number, json: { write: true } })], t4.prototype, "offset", void 0), t4 = r([a3("esri.layers.voxel.VoxelRegularSpacing")], t4);
var p9 = t4;

// node_modules/@arcgis/core/layers/voxel/VoxelDimension.js
var a9 = class extends l {
  constructor() {
    super(...arguments), this.irregularSpacing = null, this.isPositiveUp = true, this.isWrappedDateLine = false, this.label = null, this.name = null, this.quantity = null, this.regularSpacing = null, this.size = 0, this.unit = null;
  }
  get isRegular() {
    return (null == this.irregularSpacing || void 0 === this.irregularSpacing) && null !== this.regularSpacing;
  }
  getRange() {
    return this.isRegular ? [this.regularSpacing.offset, this.regularSpacing.offset + this.regularSpacing.scale * (this.size - 1)] : Array.isArray(this.irregularSpacing?.values) && this.irregularSpacing.values.length > 1 ? [this.irregularSpacing.values[0], this.irregularSpacing.values[this.irregularSpacing.values.length - 1]] : [0, 0];
  }
};
r([m({ type: p8, json: { write: true } })], a9.prototype, "irregularSpacing", void 0), r([m({ type: Boolean, json: { write: true } })], a9.prototype, "isPositiveUp", void 0), r([m({ type: Boolean, json: { write: true } })], a9.prototype, "isWrappedDateLine", void 0), r([m({ type: String, json: { write: true } })], a9.prototype, "label", void 0), r([m({ type: String, json: { write: true } })], a9.prototype, "name", void 0), r([m({ type: String, json: { write: true } })], a9.prototype, "quantity", void 0), r([m({ type: p9, json: { write: true } })], a9.prototype, "regularSpacing", void 0), r([m({ type: Number, json: { write: true } })], a9.prototype, "size", void 0), r([m({ type: String, json: { write: true } })], a9.prototype, "unit", void 0), r([m({ type: Boolean, json: { read: false } })], a9.prototype, "isRegular", null), a9 = r([a3("esri.layers.voxel.VoxelDimension")], a9);
var p10 = a9;

// node_modules/@arcgis/core/layers/voxel/VoxelVolume.js
var f4 = class extends l {
  constructor(e4) {
    super(e4), this.id = 0, this.dimensions = null, this.spatialReference = f2.WGS84;
  }
  get zDimension() {
    if (!this.dimensions) return -1;
    if (!Array.isArray(this.dimensions)) return -1;
    if (4 !== this.dimensions.length) return -1;
    for (let e4 = 2; e4 < 4; ++e4) if (this.dimensions[e4].size > 0) return e4;
    return -1;
  }
  get isValid() {
    return !!this.dimensions && (!!Array.isArray(this.dimensions) && (4 === this.dimensions.length && (!(this.dimensions[0].size < 1 || this.dimensions[1].size < 1) && !(-1 === this.zDimension || this.dimensions[this.zDimension].size < 1))));
  }
  get originInLayerSpace3D() {
    if (!this.isValid || "xyt" === this.volumeType) return [0, 0, 0];
    const e4 = this.dimensions[0].getRange(), i6 = this.dimensions[1].getRange(), s8 = this.dimensions[2], r5 = s8.isRegular ? s8.getRange() : [0, s8.size];
    return [e4[0], i6[0], r5[0]];
  }
  get voxelSizeInLayerSpaceSigned() {
    if (!this.isValid || "xyt" === this.volumeType) return [0, 0, 0];
    const e4 = this.dimensions[0].getRange(), i6 = this.dimensions[1].getRange(), s8 = this.dimensions[2], r5 = s8.isRegular ? s8.getRange() : [0, s8.size], t6 = [this.sizeInVoxels[0], this.sizeInVoxels[1], this.sizeInVoxels[2]];
    for (let n3 = 0; n3 < 3; ++n3) t6[n3] < 2 ? t6[n3] = 1 : t6[n3] -= 1;
    return s8.isRegular && !s8.isPositiveUp && (t6[2] *= -1), [(e4[1] - e4[0]) / t6[0], (i6[1] - i6[0]) / t6[1], (r5[1] - r5[0]) / t6[2]];
  }
  get volumeType() {
    if (this.isValid) {
      const e4 = this.dimensions[2].size > 0;
      let i6 = this.dimensions[3].size > 0;
      if (i6) {
        const e5 = this.dimensions[3];
        if (i6 = "time" === e5.quantity, i6 && null !== e5.unit) {
          i6 = r4(e5.unit).didParse;
        }
      }
      if (!e4 && i6) return "xyt";
      if (e4 && i6) return "xyzt";
    }
    return "xyz";
  }
  get sizeInVoxels() {
    if (!this.isValid) return [0, 0, 0];
    const e4 = this.zDimension;
    return [this.dimensions[0].size, this.dimensions[1].size, this.dimensions[e4].size];
  }
  get timeStops() {
    if ("xyzt" !== this.volumeType) return [];
    const e4 = this.dimensions[3], i6 = [], s8 = r4(e4.unit);
    if (s8.didParse) {
      if (e4.isRegular) {
        const t6 = e4.regularSpacing?.offset ?? 0, n3 = e4.regularSpacing?.scale || 1;
        for (let o3 = 0; o3 < e4.size; ++o3) {
          const e5 = t6 + n3 * o3;
          i6.push(i2(s8.reference, e5, s8.unit));
        }
      } else if (Array.isArray(e4.irregularSpacing?.values) && e4.irregularSpacing.values.length > 0) for (let t6 = 0; t6 < e4.irregularSpacing.values.length; ++t6) {
        const n3 = e4.irregularSpacing.values[t6];
        i6.push(i2(s8.reference, n3, s8.unit));
      }
    }
    return i6;
  }
  computeVoxelSpaceLocation(e4) {
    if (!this.isValid) return [0, 0, 0];
    if ("xyt" === this.volumeType) return i.getLogger(this).error("computeVoxelSpacePosition cannot be used with XYT volumes."), [0, 0, 0];
    if (!s3(this.spatialReference, e4.spatialReference)) return i.getLogger(this).error("pos argument should have the same spatial reference as the VoxelLayer."), [0, 0, 0];
    const i6 = r3(e4.x, e4.y, e4.z ?? 0);
    c2(i6, i6, this.originInLayerSpace3D), i4(i6, i6, this.voxelSizeInLayerSpaceSigned);
    const r5 = this.dimensions[this.zDimension];
    if (!r5.isRegular && Array.isArray(r5.irregularSpacing?.values) && r5.irregularSpacing.values.length > 1) {
      const s8 = e4.z ?? 0, t6 = r5.irregularSpacing.values, n3 = r5.isPositiveUp ? 1 : -1, o3 = t6.reduce((e5, i7) => Math.abs(n3 * i7 - s8) < Math.abs(n3 * e5 - s8) ? i7 : e5);
      for (let e5 = 0; e5 < t6.length; ++e5) if (t6[e5] === o3) {
        i6[2] = e5;
        break;
      }
    }
    return [i6[0], i6[1], i6[2]];
  }
  computeLayerSpaceLocation(e4) {
    if (!this.isValid) return new _({ x: 0, y: 0, spatialReference: this.spatialReference });
    const i6 = u(e4);
    if (e2(i6, i6, this.voxelSizeInLayerSpaceSigned), u5(i6, i6, this.originInLayerSpace3D), "xyt" === this.volumeType) return new _({ x: i6[0], y: i6[1], spatialReference: this.spatialReference });
    const s8 = this.dimensions[this.zDimension];
    return s8.isRegular || Array.isArray(s8.irregularSpacing?.values) && (e4[2] < 0 ? i6[2] = s8.irregularSpacing.values[0] : e4[2] < s8.irregularSpacing.values.length ? i6[2] = s8.irregularSpacing.values[e4[2]] : i6[2] = s8.irregularSpacing.values[s8.irregularSpacing.values.length - 1], s8.isPositiveUp || (i6[2] *= -1)), new _({ x: i6[0], y: i6[1], z: i6[2], spatialReference: this.spatialReference });
  }
};
r([m({ type: Number, json: { write: { enabled: true, isRequired: true } } })], f4.prototype, "id", void 0), r([m({ type: [p10], json: { write: { enabled: true, isRequired: true } } })], f4.prototype, "dimensions", void 0), r([m({ type: f2, json: { read: { enabled: false } } })], f4.prototype, "spatialReference", void 0), r([m({ type: Number, json: { read: false } })], f4.prototype, "zDimension", null), r([m({ type: [Boolean], json: { read: false } })], f4.prototype, "isValid", null), r([m({ type: [Number], json: { read: false } })], f4.prototype, "originInLayerSpace3D", null), r([m({ type: [Number], json: { read: false } })], f4.prototype, "voxelSizeInLayerSpaceSigned", null), r([m({ type: ["xyz", "xyzt", "xyt"], json: { read: { enabled: false } } })], f4.prototype, "volumeType", null), r([m({ type: [Number], json: { read: false } })], f4.prototype, "sizeInVoxels", null), r([m({ type: [Date], json: { read: false, write: false } })], f4.prototype, "timeStops", null), f4 = r([a3("esri.layers.voxel.VoxelVolume")], f4);

// node_modules/@arcgis/core/layers/voxel/VoxelVolumeIndex.js
var t5;
var s7 = t5 = class extends l {
  constructor() {
    super(...arguments), this.apronWidth = 1, this.brickSize = [32, 32, 32], this.maxLodLevel = 0, this.nodeSize = [4, 4, 4];
  }
  isValid() {
    const e4 = new t5();
    return e4.apronWidth === this.apronWidth && e4.maxLodLevel === this.maxLodLevel && (!!this.brickSize && (!!this.nodeSize && (!(!Array.isArray(this.brickSize) || !Array.isArray(this.nodeSize)) && (3 === this.brickSize.length && 3 === this.nodeSize.length && (32 === this.brickSize[0] && 32 === this.brickSize[1] && 32 === this.brickSize[2] && (4 === this.nodeSize[0] && 4 === this.nodeSize[1] && 4 === this.nodeSize[2]))))));
  }
};
r([m({ type: Number, json: { write: { enabled: true, isRequired: true } } })], s7.prototype, "apronWidth", void 0), r([m({ type: [Number], json: { write: { enabled: true, isRequired: true } } })], s7.prototype, "brickSize", void 0), r([m({ type: Number, json: { write: { enabled: true, isRequired: true } } })], s7.prototype, "maxLodLevel", void 0), r([m({ type: [Number], json: { write: { enabled: true, isRequired: true } } })], s7.prototype, "nodeSize", void 0), s7 = t5 = r([a3("esri.layers.voxel.VoxelVolumeIndex")], s7);
var d3 = s7;

// node_modules/@arcgis/core/layers/voxel/VoxelDynamicSection.js
var m4 = class extends a5.ClonableMixin(l) {
  constructor(o3) {
    super(o3), this.enabled = true, this.label = "", this.normal = null, this.point = null;
  }
  get orientation() {
    if (!Array.isArray(this.normal) || 3 !== this.normal.length) return 0;
    const [o3, t6] = b3(this.normal);
    return a6.normalize(a2(o3), 0, true);
  }
  set orientation(o3) {
    const t6 = g(o3, this.tilt);
    this._set("normal", t6), this._set("orientation", o3);
  }
  get tilt() {
    if (!Array.isArray(this.normal) || 3 !== this.normal.length) return 0;
    const [o3, t6] = b3(this.normal);
    return a6.normalize(a2(t6), 0, true);
  }
  set tilt(o3) {
    const t6 = g(this.orientation, o3);
    this._set("normal", t6), this._set("tilt", o3);
  }
};
r([m({ type: Boolean, json: { default: true, write: true } })], m4.prototype, "enabled", void 0), r([m({ type: String, json: { write: true } })], m4.prototype, "label", void 0), r([m({ type: Number, json: { read: false }, clonable: false, range: { min: 0, max: 360 } }), s2((o3) => a6.normalize(a2(o3), 0, true))], m4.prototype, "orientation", null), r([m({ type: Number, json: { read: false }, clonable: false, range: { min: 0, max: 360 } }), s2((o3) => a6.normalize(a2(o3), 0, true))], m4.prototype, "tilt", null), r([m({ type: [Number], json: { write: { isRequired: true } } })], m4.prototype, "normal", void 0), r([m({ type: [Number], json: { write: { isRequired: true } } })], m4.prototype, "point", void 0), m4 = r([a3("esri.layers.voxel.VoxelDynamicSection")], m4);

// node_modules/@arcgis/core/layers/voxel/VoxelVolumeStyle.js
var p11;
var m5 = p11 = class extends l {
  constructor(e4) {
    super(e4), this.volumeId = 0, this.verticalExaggeration = 1, this.exaggerationMode = "scale-height", this.verticalOffset = 0, this.slices = new (V.ofType(m3))(), this.dynamicSections = new (V.ofType(m4))();
  }
  set slices(e4) {
    this._set("slices", n(e4, this._get("slices"), V.ofType(m3)));
  }
  set dynamicSections(e4) {
    this._set("dynamicSections", n(e4, this._get("dynamicSections"), V.ofType(m4)));
  }
  clone() {
    return new p11({ volumeId: this.volumeId, verticalExaggeration: this.verticalExaggeration, exaggerationMode: this.exaggerationMode, verticalOffset: this.verticalOffset, slices: a(this.slices), dynamicSections: a(this.dynamicSections) });
  }
};
r([m({ type: x, json: { write: { enabled: true, isRequired: true } } })], m5.prototype, "volumeId", void 0), r([m({ type: Number, json: { default: 1, write: true } })], m5.prototype, "verticalExaggeration", void 0), r([m({ type: ["scale-position", "scale-height"], json: { default: "scale-height", write: true } })], m5.prototype, "exaggerationMode", void 0), r([m({ type: Number, json: { default: 0, write: true } })], m5.prototype, "verticalOffset", void 0), r([m({ type: V.ofType(m3), json: { write: { enabled: true, overridePolicy() {
  return { enabled: !!this.slices && this.slices.length > 0 };
} } } })], m5.prototype, "slices", null), r([m({ type: V.ofType(m4), json: { write: { enabled: true, overridePolicy() {
  return { enabled: !!this.dynamicSections && this.dynamicSections.length > 0 };
} } } })], m5.prototype, "dynamicSections", null), m5 = p11 = r([a3("esri.layers.voxel.VoxelVolumeStyle")], m5);

// node_modules/@arcgis/core/layers/VoxelLayer.js
var z2 = class extends R(l3(b(j(t(S(e(i3(h)))))))) {
  constructor(e4) {
    super(e4), this.serviceRoot = "", this.operationalLayerType = "Voxel", this.legendEnabled = true, this.title = null, this.sections = null, this.currentVariableId = 0, this.volumeStyles = null, this.renderMode = "volume", this.variableStyles = null, this.enableSlices = true, this.enableSections = true, this.enableDynamicSections = true, this.enableIsosurfaces = true, this.shading = new t2(), this.opacity = 1, this.variables = new V(), this.volumes = new V(), this.index = null, this.minScale = 0, this.maxScale = 0, this.type = "voxel", this.version = { major: Number.NaN, minor: Number.NaN, versionString: "" }, this.fullExtent = null, this.popupEnabled = false, this.popupTemplate = null, this.test = null, this.timeExtent = null, this.timeOffset = null, this.useViewTime = true, this.volumeStyles = new (V.ofType(m5))(), this.variableStyles = new (V.ofType(c4))(), this.sections = new (V.ofType(d2))();
  }
  normalizeCtorArgs(e4) {
    return e4?.constantUpscaling && (this.test = { constantUpscaling: true }, delete e4.constantUpscaling), e4;
  }
  set url(e4) {
    this._set("url", y(e4, i.getLogger(this)));
  }
  load(e4) {
    const t6 = null != e4 ? e4.signal : null, i6 = this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e4).catch(a4).then(() => this._fetchService(t6)).then(() => this.serviceRoot = this.url);
    return this.addResolvingPromise(i6), Promise.resolve(this);
  }
  read(e4, t6) {
    super.read(e4, t6), "service" === t6?.origin && this.version.major <= 3 && this.version.minor <= 0 && !this.getAtOrigin("popupTemplate", "service") && this.setAtOrigin("popupTemplate", this.createPopupTemplate(), "service");
    for (const i6 of this.volumes) i6.spatialReference = this.spatialReference;
  }
  readVersion(e4, t6) {
    return super.parseVersionString(e4);
  }
  validateLayer(e4) {
    if (e4.layerType && e4.layerType !== this.operationalLayerType) throw new s("voxel-layer:layer-type-not-supported", "VoxelLayer does not support this layer type", { layerType: e4.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor) || this.version.major < 3) throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "3.x" });
    if (this.version.major > 3) throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "3.x" });
  }
  readFullExtent(e4, t6, i6) {
    if (null != e4 && "object" == typeof e4) {
      const o3 = z.fromJSON(e4, i6);
      if (0 === o3.zmin && 0 === o3.zmax && Array.isArray(t6.volumes)) {
        const e5 = f4.fromJSON(t6.volumes[0]);
        if (e5.isValid && "xyt" !== e5.volumeType) {
          const t7 = e5.dimensions[2];
          if (t7.isRegular) {
            let e6 = t7.regularSpacing.offset, i7 = t7.regularSpacing.offset + t7.regularSpacing.scale * (t7.size - 1);
            if (e6 > i7) {
              const t8 = e6;
              e6 = i7, i7 = t8;
            }
            o3.zmin = e6, o3.zmax = i7;
          }
        }
      }
      return o3;
    }
    return null;
  }
  get fields() {
    const e4 = [new m2({ name: "Voxel.Position", alias: "Voxel Position", domain: null, editable: false, length: 128, type: "string" }), new m2({ name: "Voxel.CurrentVariable", alias: "Current Variable", domain: null, editable: false, length: 128, type: "string" })];
    for (const i6 of this.variables) {
      const t7 = new m2({ name: i6.name, alias: i6.description, domain: null, editable: false, length: 128, type: "discrete" === i6.renderingFormat.continuity ? "string" : "double" });
      e4.push(t7);
    }
    const t6 = this.getVolume(null);
    if (null != t6) {
      if ("xyzt" === t6.volumeType || "xyt" === t6.volumeType) {
        const t7 = new m2({ name: "Voxel.LocalTime", alias: "Local Time", domain: null, editable: false, length: 256, type: "date" });
        e4.push(t7);
        const i6 = new m2({ name: "Voxel.SourceTime", alias: "Source Time", domain: null, editable: false, length: 256, type: "string" });
        e4.push(i6);
      }
      if ("xyt" !== t6.volumeType) {
        const t7 = new m2({ name: "Voxel.Depth", alias: "Depth", domain: null, editable: false, length: 128, type: "double" });
        e4.push(t7);
      }
    }
    return e4;
  }
  get fieldsIndex() {
    return this.loaded ? new Z(this.fields) : null;
  }
  getField(e4) {
    return this.fieldsIndex?.get(e4);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  createPopupTemplate(e4) {
    const t6 = this.fields;
    return p({ fields: t6, title: "{Voxel.Position}" }, e4);
  }
  getConfiguration() {
    const e4 = { layerType: this.operationalLayerType, version: this.version.versionString, name: this.title, spatialReference: this.spatialReference, fullExtent: this.fullExtent, volumes: this.volumes.toJSON(), variables: this.variables.toJSON(), index: this.index?.toJSON(), sections: this.getSections(), style: { volumeStyles: this.getVolumeStyles(), currentVariableId: this.currentVariableId, renderMode: this.renderMode, variableStyles: this.getVariableStyles(), enableSections: this.enableSections, enableDynamicSections: this.enableDynamicSections, enableIsosurfaces: this.enableIsosurfaces, enableSlices: this.enableSlices, shading: this.shading } };
    return e4.index && this.index?.isValid() ? JSON.stringify(e4) : "";
  }
  getVariableStyle(e4) {
    let t6 = -1;
    t6 = null != e4 ? e4 : this.currentVariableId;
    if (!this.variableStyles || -1 === t6) return null;
    const i6 = this.variableStyles.findIndex((e5) => e5.variableId === t6);
    return i6 < 0 ? null : this.variableStyles.at(i6);
  }
  getVariable(e4) {
    let t6 = -1;
    if (t6 = null != e4 ? e4 : this.currentVariableId, !this.variables || -1 === t6) return null;
    const i6 = this.variables.findIndex((e5) => e5.id === t6);
    return i6 < 0 ? null : this.variables.at(i6);
  }
  getVolume(e4) {
    const t6 = this.getVariable(e4);
    return null != t6 ? this.volumes.find(({ id: e5 }) => e5 === t6.volumeId) : null;
  }
  get timeInfo() {
    const e4 = this.getVolume(null);
    if ("xyzt" !== e4?.volumeType) return null;
    const t6 = e4.timeStops;
    if (!t6?.length) return null;
    const i6 = new u2({ start: t6[0], end: t6.at(-1) });
    return new u4({ fullTimeExtent: i6, stops: t6 });
  }
  getVolumeStyle(e4) {
    const t6 = this.getVariable(e4);
    return null != t6 ? this.volumeStyles.find(({ volumeId: e5 }) => e5 === t6.volumeId) : null;
  }
  getColorForContinuousDataValue(e4, t6, i6) {
    const o3 = this.getVariable(e4);
    if (null == o3 || "continuous" !== o3.renderingFormat?.continuity) return null;
    if (!this.variableStyles) return null;
    const r5 = this.variableStyles.findIndex((t7) => t7.variableId === e4);
    if (r5 < 0) return null;
    const s8 = this.variableStyles.at(r5);
    return s8?.transferFunction ? s8.transferFunction.getColorForContinuousDataValue(t6, i6) : null;
  }
  getSections() {
    const e4 = [];
    for (const t6 of this.sections) e4.push(new d2({ enabled: t6.enabled, href: t6.href, id: t6.id, label: t6.label, normal: t6.normal, point: t6.point, sizeInPixel: t6.sizeInPixel, slices: t6.slices, timeId: t6.timeId, variableId: t6.variableId }));
    return e4;
  }
  getVariableStyles() {
    const e4 = [];
    for (const t6 of this.variableStyles) {
      const i6 = this._getVariable(t6);
      if (null != i6) {
        const o3 = t6.clone();
        o3.isosurfaces.length > 4 && (o3.isosurfaces = o3.isosurfaces.slice(0, 3), i.getLogger(this).error("A maximum of 4 isosurfaces are supported for Voxel Layers."));
        for (const e5 of o3.isosurfaces) if (!e5.colorLocked) {
          const t7 = this.getColorForContinuousDataValue(o3.variableId, e5.value, false);
          null == t7 || t7.equals(e5.color) || (e5.color = t7);
        }
        if ("continuous" === i6.renderingFormat.continuity) (null === o3.transferFunction || o3.transferFunction.colorStops.length < 2) && i.getLogger(this).error(`VoxelVariableStyle for variable ${i6.id} is invalid. At least 2 color stops are required in the transferFunction for continuous Voxel Layer variables.`), null !== o3.transferFunction && (Array.isArray(o3.transferFunction.stretchRange) && 2 === o3.transferFunction.stretchRange.length || (i.getLogger(this).error(`VoxelVariableStyle for variable ${i6.id} is invalid. The stretchRange of the transferFunction for continuous Voxel Layer variables must be of the form [minimumDataValue, maximumDataValue].`), o3.transferFunction.stretchRange = [0, 1], o3.transferFunction.colorStops.removeAll()));
        else if ("discrete" === i6.renderingFormat.continuity) if (0 === t6.uniqueValues.length) i.getLogger(this).error(`VoxelVariableStyle for variable ${i6.id} is invalid. Unique values are required for discrete Voxel Layer variables.`);
        else for (const e5 of t6.uniqueValues) null !== e5.label && void 0 !== e5.label || null === e5.value || void 0 === e5.value || (e5.label = e5.value.toString());
        e4.push(o3);
      } else i.getLogger(this).error(`VoxelVariable ID=${t6.variableId} doesn't exist, VoxelVariableStyle for this VoxelVariable will be ignored.`);
    }
    return e4;
  }
  getVolumeStyles() {
    const e4 = [];
    for (const t6 of this.volumeStyles) {
      const i6 = this._getVolumeFromVolumeId(t6.volumeId);
      if (null != i6) {
        const o3 = t6.clone();
        for (const e5 of o3.slices) this._isPlaneValid(e5, [0, 1, i6.zDimension], i6.dimensions) || (e5.enabled = false, e5.label = "invalid");
        for (const e5 of o3.dynamicSections) this._isPlaneValid(e5, [0, 1, i6.zDimension], i6.dimensions) || (e5.enabled = false, e5.label = "invalid");
        e4.push(o3);
      } else i.getLogger(this).error(`VoxelVolume ID=${t6.volumeId} doesn't exist, VoxelVolumeStyle for this VoxelVolume will be ignored.`);
    }
    return e4;
  }
  _getVariable(e4) {
    const t6 = e4.variableId;
    for (const i6 of this.variables) if (i6.id === t6) return i6;
    return null;
  }
  _getVolumeFromVolumeId(e4) {
    for (const t6 of this.volumes) if (t6.id === e4) return t6;
    return null;
  }
  _isPlaneValid(e4, t6, i6) {
    if (!e4.point) return false;
    if (!Array.isArray(e4.point) || 3 !== e4.point.length) return false;
    if (!e4.normal) return false;
    if (!Array.isArray(e4.normal) || 3 !== e4.normal.length) return false;
    const o3 = r3(e4.normal[0], e4.normal[1], e4.normal[2]);
    A(o3, o3);
    const r5 = 1e-6;
    return !(Math.abs(o3[0]) + Math.abs(o3[1]) + Math.abs(o3[2]) < r5) && (e4.normal[0] = o3[0], e4.normal[1] = o3[1], e4.normal[2] = o3[2], true);
  }
};
r([m({ type: ["Voxel"] })], z2.prototype, "operationalLayerType", void 0), r([m(d)], z2.prototype, "legendEnabled", void 0), r([m({ json: { write: true } })], z2.prototype, "title", void 0), r([m(y2)], z2.prototype, "url", null), r([m({ type: V.ofType(d2), json: { origins: { "web-scene": { name: "layerDefinition.sections", write: true } } } })], z2.prototype, "sections", void 0), r([m({ type: x, json: { origins: { "web-scene": { name: "layerDefinition.style.currentVariableId", write: { enabled: true, isRequired: true, ignoreOrigin: true } }, service: { name: "style.currentVariableId" } } } })], z2.prototype, "currentVariableId", void 0), r([m({ type: V.ofType(m5), json: { origins: { "web-scene": { name: "layerDefinition.style.volumeStyles", write: true }, service: { name: "style.volumeStyles" } } } })], z2.prototype, "volumeStyles", void 0), r([m({ type: ["volume", "surfaces"], json: { origins: { "web-scene": { name: "layerDefinition.style.renderMode", write: true }, service: { name: "style.renderMode" } } } })], z2.prototype, "renderMode", void 0), r([m({ type: V.ofType(c4), json: { origins: { "web-scene": { name: "layerDefinition.style.variableStyles", write: true }, service: { name: "style.variableStyles" } } } })], z2.prototype, "variableStyles", void 0), r([m({ type: Boolean, json: { origins: { "web-scene": { name: "layerDefinition.style.enableSlices", write: true }, service: { name: "style.enableSlices" } } } })], z2.prototype, "enableSlices", void 0), r([m({ type: Boolean, json: { origins: { "web-scene": { name: "layerDefinition.style.enableSections", write: true }, service: { name: "style.enableSections" } } } })], z2.prototype, "enableSections", void 0), r([m({ type: Boolean, json: { origins: { "web-scene": { name: "layerDefinition.style.enableDynamicSections", write: true }, service: { name: "style.enableDynamicSections" } } } })], z2.prototype, "enableDynamicSections", void 0), r([m({ type: Boolean, json: { origins: { "web-scene": { name: "layerDefinition.style.enableIsosurfaces", write: true }, service: { name: "style.enableIsosurfaces" } } } })], z2.prototype, "enableIsosurfaces", void 0), r([m({ type: t2, json: { origins: { "web-scene": { name: "layerDefinition.style.shading", write: true }, service: { name: "style.shading" } } } })], z2.prototype, "shading", void 0), r([m({ type: ["show", "hide"] })], z2.prototype, "listMode", void 0), r([m({ type: Number, range: { min: 0, max: 1 }, nonNullable: true, json: { read: false, write: false, origins: { "web-scene": { read: false, write: false }, "portal-item": { read: false, write: false } } } })], z2.prototype, "opacity", void 0), r([m({ type: V.ofType(p4) })], z2.prototype, "variables", void 0), r([m({ type: V.ofType(f4) })], z2.prototype, "volumes", void 0), r([m({ type: d3 })], z2.prototype, "index", void 0), r([m({ type: Number, json: { name: "layerDefinition.minScale", write: true, origins: { service: { read: false, write: false } } } })], z2.prototype, "minScale", void 0), r([m({ type: Number, json: { name: "layerDefinition.maxScale", write: true, origins: { service: { read: false, write: false } } } })], z2.prototype, "maxScale", void 0), r([m({ json: { read: false }, readOnly: true })], z2.prototype, "type", void 0), r([m({ readOnly: true, json: { name: "serviceVersion" } })], z2.prototype, "version", void 0), r([o2("service", "version")], z2.prototype, "readVersion", null), r([m({ type: z })], z2.prototype, "fullExtent", void 0), r([o2("service", "fullExtent", ["fullExtent"])], z2.prototype, "readFullExtent", null), r([m({ readOnly: true, clonable: false, json: { read: false } })], z2.prototype, "fields", null), r([m({ readOnly: true })], z2.prototype, "fieldsIndex", null), r([m({ type: Boolean, json: { name: "disablePopup", read: { reader: (e4, t6) => !t6.disablePopup }, write: { enabled: true, ignoreOrigin: true, writer(e4, t6, i6) {
  t6[i6] = !e4;
} }, origins: { "portal-item": { default: true }, "web-scene": { default: true } } } })], z2.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], z2.prototype, "popupTemplate", void 0), r([m({ readOnly: true, json: { read: false } })], z2.prototype, "defaultPopupTemplate", null), r([m({ type: u4, readOnly: true, json: { read: false } })], z2.prototype, "timeInfo", null), r([m({ type: u2, json: { read: false } })], z2.prototype, "timeExtent", void 0), r([m({ type: a7, json: { read: false } })], z2.prototype, "timeOffset", void 0), r([m({ type: Boolean, nonNullable: true, json: { origins: { "web-scene": { name: "timeAnimation", write: true }, service: { read: false } } } })], z2.prototype, "useViewTime", void 0), z2 = r([a3("esri.layers.VoxelLayer")], z2);
var _2 = z2;
export {
  _2 as default
};
//# sourceMappingURL=VoxelLayer-5BUCHZAX.js.map
