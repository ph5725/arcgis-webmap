import {
  o as o2
} from "./chunk-4BWHW3TP.js";
import {
  $,
  X,
  c as c2,
  e as e2,
  i as i3,
  l as l3,
  n,
  r as r2,
  t as t2
} from "./chunk-QK4VRPQW.js";
import "./chunk-23ZUIA4B.js";
import "./chunk-MEHT6AJM.js";
import "./chunk-N6VYJNA5.js";
import "./chunk-Z5EDZREM.js";
import {
  i2
} from "./chunk-TZWHWOLK.js";
import {
  D,
  o,
  p as p3,
  p2 as p4,
  w
} from "./chunk-623AYJP2.js";
import {
  P2,
  m2 as m3
} from "./chunk-U5MPARPW.js";
import {
  W
} from "./chunk-NXHGFG67.js";
import "./chunk-3NJEC7QC.js";
import "./chunk-WQVEQTKW.js";
import "./chunk-56LGCTGZ.js";
import "./chunk-RD652CDC.js";
import "./chunk-PVI3IOCA.js";
import "./chunk-OFHPFWHF.js";
import "./chunk-MZJEBIXX.js";
import "./chunk-76QJRCNC.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-NO2XQDLB.js";
import "./chunk-LBC3MAJX.js";
import "./chunk-3ZORAHSR.js";
import "./chunk-SZN55B2M.js";
import {
  c
} from "./chunk-6MFKAT6L.js";
import "./chunk-NOWX6W7R.js";
import {
  p as p2
} from "./chunk-OQ76WPLD.js";
import {
  e
} from "./chunk-KSVHYEPS.js";
import "./chunk-B6C7UPBZ.js";
import {
  f
} from "./chunk-IUQBXXYO.js";
import {
  A
} from "./chunk-MULCOUFY.js";
import {
  j
} from "./chunk-VGIEH4HM.js";
import {
  p
} from "./chunk-XLF2NMGX.js";
import {
  t
} from "./chunk-X5GD6LFD.js";
import {
  b2,
  d,
  l as l2
} from "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import "./chunk-UGXCZZ7N.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import {
  m as m2
} from "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import {
  h
} from "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import {
  q
} from "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import {
  a as a3
} from "./chunk-TVM3SZJR.js";
import {
  P
} from "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  l
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H
} from "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  a as a2,
  b,
  k
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/wcsCapabilitiesParser.js
function l4(e4) {
  return e4.endsWith("?") ? e4.slice(0, -1) : e4;
}
function u(e4) {
  return e4.filter(({ coverageSubType: e5 }) => null == e5 || "" === e5 || /^rectified(grid|dataset)/i.test(e5));
}
function p5(e4) {
  const i5 = t2(e4, "Service/name"), s2 = e2(e4, "Capability"), c3 = e2(s2, "GetCapabilities/Get/OnlineResource")?.getAttribute("xlink:href") ?? "", p6 = e2(s2, "DescribeCoverage/Get/OnlineResource")?.getAttribute("xlink:href") ?? "", m5 = e2(s2, "GetCoverage/Get/OnlineResource")?.getAttribute("xlink:href") ?? "", g4 = { getCapabilities: l4(c3), describeCoverage: l4(p6), getCoverage: l4(m5) }, v4 = n(e4, "CoverageOfferingBrief"), d4 = [];
  for (let r4 = 0; r4 < v4.length; r4++) {
    const e5 = v4[r4], i6 = t2(e5, "name"), s3 = n(e5, "pos"), c4 = r2(s3[0]), l5 = r2(s3[1]), u2 = new z({ xmin: c4[0], ymin: c4[1], xmax: l5[0], ymax: l5[1], spatialReference: { wkid: 4326 } });
    d4.push({ id: i6, lonLatEnvelope: u2 });
  }
  return { name: i5, onlineResources: g4, coverages: d4, gridCoverages: u(d4), supportedVersions: ["1.0.0"], version: "1.0.0" };
}
function m4(e4) {
  const r4 = {};
  for (let i5 = 0; i5 < e4.childNodes.length; i5++) {
    const n4 = e4.childNodes[i5];
    if (1 !== n4.nodeType) continue;
    const s2 = c2(n4).toLowerCase();
    switch (s2) {
      case "title":
      case "abstract":
        r4[s2] = t2(n4);
        break;
      case "identifier":
        r4.id = t2(n4);
        break;
      case "wgs84boundingbox":
        {
          const e5 = r2(n4, "LowerCorner"), o3 = r2(n4, "UpperCorner");
          r4.lonLatEnvelope = new z({ xmin: e5[0], ymin: e5[1], xmax: o3[0], ymax: o3[1], spatialReference: { wkid: 4326 } });
        }
        break;
      case "coveragesummary":
        r4.coverageSummaries = r4.coverageSummaries || [], r4.coverageSummaries.push(m4(n4));
    }
  }
  return r4;
}
function g(e4, t4) {
  if (e4.coverageSummaries) for (let r4 = 0; r4 < e4.coverageSummaries.length; r4++) e4.coverageSummaries[r4].abstract = e4.coverageSummaries[r4].abstract || e4.abstract, e4.coverageSummaries[r4].lonLatEnvelope = e4.coverageSummaries[r4].lonLatEnvelope || e4.lonLatEnvelope, e4.coverageSummaries[r4].title = e4.coverageSummaries[r4].title || e4.title, g(e4.coverageSummaries[r4], t4);
  null != e4.id && t4.push(e4);
}
function v(e4) {
  const t4 = e2(e4.querySelector("Operation[name=GetCapabilities]"), "Get")?.getAttribute("xlink:href") || "", o3 = e2(e4.querySelector("Operation[name=DescribeCoverage]"), "Get")?.getAttribute("xlink:href") || "", i5 = e2(e4.querySelector("Operation[name=GetCoverage]"), "Get")?.getAttribute("xlink:href") || "";
  return { getCapabilities: l4(t4), describeCoverage: l4(o3), getCoverage: l4(i5) };
}
function d2(e4) {
  const t4 = t2(e4, "ServiceIdentification/Title"), n4 = l3(e4, "ServiceIdentification/ServiceTypeVersion"), a4 = v(e2(e4, "OperationsMetadata")), c3 = [], l5 = e2(e4, "Contents");
  for (let r4 = 0; r4 < l5.childNodes.length; r4++) {
    const e5 = l5.childNodes[r4];
    1 === e5.nodeType && (i3(e5, "CoverageSummary") && g(m4(e5), c3));
  }
  const p6 = l3(l5, "SupportedFormat");
  return { name: t4, onlineResources: a4, coverages: c3, gridCoverages: u(c3), supportedVersions: n4, supportedFormats: p6, version: "1.1.0" };
}
function f2(e4) {
  const s2 = e2(e4, "ServiceIdentification"), c3 = t2(s2, "Title"), l5 = l3(s2, "ServiceTypeVersion"), p6 = l3(s2, "Profile"), m5 = v(e2(e4, "OperationsMetadata")), g4 = n(e4, "Contents/CoverageSummary"), d4 = [];
  for (let i5 = 0; i5 < g4.length; i5++) {
    const e5 = g4[i5], n4 = t2(e5, "CoverageId"), s3 = e2(e5, "WGS84BoundingBox");
    let c4;
    if (s3) {
      const e6 = r2(s3, "LowerCorner"), r4 = r2(s3, "UpperCorner");
      c4 = new z({ xmin: e6[0], ymin: e6[1], xmax: r4[0], ymax: r4[1], spatialReference: { wkid: 4326 } });
    }
    const l6 = t2(e5, "CoverageSubtype") || "RectifiedGridCoverage";
    d4.push({ id: n4, lonLatEnvelope: c4, coverageSubType: l6 });
  }
  const f4 = e2(e4, "ServiceMetadata");
  return { name: c3, supportedVersions: l5, supportedFormats: l3(f4, "formatSupported"), supportedInterpolations: l3(f4, "interpolationSupported").concat(l3(f4, "InterpolationSupported")), onlineResources: m5, profiles: p6, coverages: d4, gridCoverages: u(d4), version: "2.0.1" };
}
function S2(e4) {
  let t4 = null;
  if ("string" == typeof e4) {
    t4 = new DOMParser().parseFromString(e4, "text/xml");
  } else t4 = e4;
  const r4 = t4.documentElement.getAttribute("version"), o3 = r4?.slice(0, 3);
  return null != o3 && o3 < "2.1";
}
function b3(t4, r4 = null) {
  let o3 = null;
  if ("string" == typeof t4) {
    o3 = new DOMParser().parseFromString(t4, "text/xml");
  } else o3 = t4;
  let i5 = o3.documentElement.getAttribute("version");
  "1.0" === i5 ? i5 = "1.0.0" : "1.1" === i5 && (i5 = "1.1.0");
  const n4 = i5 || r4 || "1.0.0", a4 = n4.slice(0, 3);
  let s2;
  if ("2.0" === a4) s2 = f2(o3);
  else if ("1.1" === a4) s2 = d2(o3);
  else {
    if ("1.0" !== a4) throw new s("wcsraster:parsecapabilities", "the capabilities version is not supported");
    s2 = p5(o3);
  }
  return s2.version = n4, s2;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/wcsCoverageParser.js
function d3(e4) {
  e4.variables.forEach((e5) => e5.dimensions.forEach((e6) => e6.values ??= D(e6)));
}
function f3(e4) {
  return { requestResponseCRSs: l3(e4, "requestResponseCRSs").map((e5) => e5.split(":")[1]), nativeCRSs: l3(e4, "nativeCRSs").map((e5) => e5.split(":")[1]) };
}
function g2(e4, t4) {
  const n4 = l3(e4, "1.0.0" === t4 ? "interpolationMethod" : "InterpolationMethod"), i5 = "1.0.0" === t4 ? e4.getAttribute("default") : t2(e4, "InterpolationMethods/Default");
  return null != i5 ? [i5].concat(n4.filter((e5) => e5.toLowerCase() !== i5.toLowerCase())) : n4;
}
function h2(e4) {
  return null == e4 ? ["nearest"] : e4.map((e5) => {
    const t4 = e5.toLowerCase();
    return t4.includes("nearest") ? "nearest" : t4.includes("linear") ? "bilinear" : t4.includes("cubic") ? "cubic" : null;
  }).filter((e5) => !!e5);
}
function b4(t4) {
  const n4 = n(t4, "pos"), i5 = r2(n4[0]), s2 = r2(n4[1]);
  return new z({ xmin: i5[0], ymin: i5[1], xmax: s2[0], ymax: s2[1], spatialReference: { wkid: 4326 } });
}
function x(e4, t4) {
  const n4 = l3(e4, t4);
  return n4?.length && "" !== n4[0] && !isNaN(Number(n4[0])) ? n4.map((e5) => Number(e5)) : null;
}
function v2(e4) {
  const t4 = r2(e4, "MinimumValue"), n4 = r2(e4, "MaximumValue");
  return t4.length && n4.length ? t4.map((e5, t5) => ({ min: e5, max: n4[t5], avg: -1, stddev: -1 })) : null;
}
function D2(e4) {
  return null == e4 ? null : e4.every((t4) => t4 === e4[0]) ? e4[0] : e4;
}
function y(e4) {
  const t4 = [], n4 = n(e4, "RangeSet");
  let i5 = [];
  for (let s2 = 0; s2 < n4.length; s2++) {
    const e5 = t2(n4[s2], "name"), a4 = t2(n4[s2], "label"), l5 = [], m5 = x(n4[s2], "nullValues/singleValue"), p6 = n(n4[s2], "AxisDescription");
    for (let t5 = 0; t5 < p6.length; t5++) {
      const e6 = t2(p6[t5], "name"), n5 = t2(p6[t5], "label"), s3 = l3(p6[t5], "singleValue");
      if (0 === s3.length) {
        const e7 = t2(p6[t5], "min"), n6 = t2(p6[t5], "max"), i6 = Number(t2(p6[t5], "res")) || 1;
        if (null !== e7 && null !== n6) for (let t6 = parseInt(e7, 10); t6 <= parseInt(n6, 10); t6 += i6) s3.push(t6.toString());
      }
      "band" === e6.toLowerCase() && (i5 = s3), l5.push({ name: e6, label: n5, values: s3 });
    }
    t4.push({ name: e5, label: a4, nullValues: m5, axis: l5 });
  }
  return { rangeSet: t4, bandNames: i5 };
}
function w2(e4 = null) {
  if (!e4) return { resolution: null, units: null };
  let t4 = e4.toUpperCase();
  const n4 = ["Y", "M", "D"], i5 = ["H", "M", "S"], s2 = ["Years", "Months", "Days", "Hours", "Minutes", "Seconds"];
  let a4, o3, l5;
  return t4.includes("PT") ? (t4 = t4.slice(2), l5 = i5.findIndex((e5) => t4.includes(e5)), a4 = s2[3 + l5], o3 = parseFloat(t4.slice(0, -1))) : (t4 = t4.slice(1), l5 = n4.findIndex((e5) => t4.includes(e5)), l5 > -1 && (a4 = s2[l5]), o3 = parseFloat(t4.slice(0, -1))), { resolution: o3, units: a4 };
}
function S3(e4) {
  const t4 = n(e4, "timeposition");
  if (t4.length > 0) {
    const e5 = [];
    for (let n5 = 0; n5 < t4.length; n5++) e5.push(new Date(t2(t4[n5])));
    return { begin: e5[0], end: e5[e5.length - 1], values: e5 };
  }
  const n4 = e2(e4, "timePeriod") || e2(e4, "TimePeriod");
  if (n4) {
    return { begin: new Date(t2(n4, "beginPosition") || t2(n4, "BeginPosition")), end: new Date(t2(n4, "endPosition") || t2(n4, "EndPosition")), ...w2(t2(n4, "timeResolution") || t2(n4, "TimeResolution")) };
  }
  return null;
}
function I(t4) {
  const n4 = e2(t4, "spatialDomain"), i5 = e2(n4, "Envelope") || e2(n4, "EnvelopeWithTimePeriod"), s2 = i5.getAttribute("srsName").split(":"), a4 = s2[s2.length - 1], l5 = n(i5, "pos"), u2 = r2(l5[0]), m5 = r2(l5[1]), d4 = parseInt(a4, 10), f4 = isNaN(d4) ? null : { wkid: d4 }, g4 = new z({ xmin: u2[0], ymin: u2[1], xmax: m5[0], ymax: m5[1], spatialReference: f4 }), h3 = e2(n4, "RectifiedGrid"), b6 = t2(h3, "low").split(" "), x3 = t2(h3, "high").split(" "), v4 = parseInt(x3[0], 10) - parseInt(b6[0], 10) + 1, D3 = parseInt(x3[1], 10) - parseInt(b6[1], 10) + 1, y3 = r2(n4, "origin/pos"), w4 = n(n4, "offsetVector"), I3 = { envelope: g4, columns: v4, rows: D3, offset: { x: parseFloat(t2(w4[0]).split(" ")[0]), y: parseFloat(t2(w4[1]).split(" ")[1]) }, origin: { x: y3[0], y: y3[1] } }, L2 = e2(t4, "temporalDomain") || e2(t4, "TemporalDomain");
  return { spatialDomain: I3, temporalDomain: L2 ? S3(L2) : null };
}
function L(e4) {
  const t4 = { version: "1.0" };
  let n4, s2 = [];
  for (let i5 = 0; i5 < e4.childNodes.length; i5++) {
    const a5 = e4.childNodes[i5];
    if (1 === a5.nodeType) if (i3(a5, "description")) t4.description = t2(a5);
    else if (i3(a5, "name")) t4.name = t2(a5);
    else if (i3(a5, "label")) t4.label = t2(a5);
    else if (i3(a5, "supportedFormats")) t4.supportedFormats = l3(a5, "formats");
    else if (i3(a5, "supportedCRSs")) t4.supportedCRSs = f3(a5);
    else if (i3(a5, "supportedInterpolations")) t4.supportedInterpolations = g2(a5, "1.0.0");
    else if (i3(a5, "lonLatEnvelope")) t4.lonLatEnvelope = b4(a5);
    else if (i3(a5, "rangeSet")) {
      const e5 = y(a5);
      t4.rangeSet = e5.rangeSet, s2 = e5.bandNames;
      const i6 = e5.rangeSet[0].nullValues;
      i6?.length && (n4 = D2(i6));
    } else i3(a5, "domainSet") && (t4.domainSet = I(a5));
  }
  const a4 = h2(t4.supportedInterpolations), { name: o3, description: m5, label: p6, lonLatEnvelope: c3, supportedFormats: d4 } = t4, { spatialDomain: x3 } = t4.domainSet, v4 = { x: Math.abs(x3.offset.x), y: Math.abs(x3.offset.y) }, w4 = C(t4.domainSet), S4 = new m3({ width: x3.columns, height: x3.rows, pixelSize: v4, pixelType: "unknown", extent: x3.envelope, spatialReference: x3.envelope.spatialReference, bandCount: s2.length || 1, noDataValue: n4, multidimensionalInfo: w4 });
  return { id: o3, title: t4.name, description: m5 || p6, lonLatEnvelope: c3, rasterInfo: S4, bandNames: s2, supportedFormats: d4, supportedInterpolations: a4, coverageDescription: t4, version: "1.0.0", useEPSGAxis: false };
}
function C(e4) {
  if (!e4.temporalDomain) return null;
  const { begin: t4, end: n4, values: i5, units: s2, resolution: a4 } = e4.temporalDomain, o3 = { variables: [{ name: "default", description: "", dimensions: [{ name: "StdTime", description: "", unit: "ISO8601", values: i5?.map((e5) => e5.getTime()), hasRegularIntervals: !i5, interval: a4, intervalUnit: s2, extent: [t4.getTime(), n4.getTime()] }] }] };
  return d3(o3), o3;
}
function T(e4, t4) {
  const n4 = [], i5 = n(e4, "Field");
  let s2, a4 = [];
  for (let l5 = 0; l5 < i5.length; l5++) {
    const e5 = t2(i5[l5], "Identifier"), m5 = t2(i5[l5], "Description"), c3 = t2(i5[l5], "Definition"), d4 = t2(i5[l5], "Abstract"), f4 = t2(i5[l5], "Title"), h3 = x(i5[l5], "NullValue"), b6 = e2(i5[l5], "AllowedValues"), D3 = b6 ? v2(b6) : null, y3 = g2(i5[l5], "1.1.0"), w4 = [], S4 = n(i5[l5], "Axis");
    for (let n5 = 0; n5 < S4.length; n5++) {
      const e6 = S4[n5].getAttribute("identifier"), i6 = t2(S4[n5], "UOM"), o3 = t2(S4[n5], "DataType"), l6 = l3(S4[n5], "Key");
      t4 && !e6.toLowerCase().includes("band") || (a4 = l6, s2 = h3), w4.push({ identifier: e6, uom: i6, dataType: o3, values: l6, bandNoDataValues: s2 });
    }
    n4.push({ identifier: e5, description: m5, definition: c3, abstract: d4, title: f4, supportedInterpolations: y3, axis: w4, nullValues: h3, statistics: D3 });
  }
  return { rangeSet: n4, bandNames: a4, bandNoDataValues: s2, statistics: n4[0].statistics };
}
function R(e4, t4) {
  if (!t4.temporalDomain) return null;
  const n4 = e4.filter((e5) => !e5.identifier.toLowerCase().includes("field_1") && !e5.axis.some((e6) => e6.identifier.includes("band"))), i5 = [];
  if (n4.length && n4.forEach((e5) => {
    const t5 = e5.axis.map((e6) => {
      const t6 = e6.values.map((t7) => {
        if ("ISO8601" === e6.uom) {
          return (t7 = t7.trim()).toLowerCase().includes("z") ? new Date(t7).getTime() : (/* @__PURE__ */ new Date(t7 + "Z")).getTime();
        }
        return parseFloat(t7.trim());
      }), n5 = [Math.min.apply(null, t6), Math.max.apply(null, t6)];
      return { name: e6.identifier.trim(), description: "", field: e6.identifier.trim(), unit: e6.uom ? e6.uom.trim() : "", hasRegularIntervals: false, values: t6, extent: n5 };
    });
    i5.push({ name: e5.identifier.trim(), description: e5.description?.trim() ?? "", unit: "", dimensions: t5, statistics: e5.statistics });
  }), t4.temporalDomain) {
    const { begin: e5, end: n5, values: s2, units: a4, resolution: o3 } = t4.temporalDomain;
    i5.some((e6) => e6.dimensions.some((e7) => "stdtime" === e7.name.toLowerCase())) || i5.forEach((t5) => {
      t5.dimensions.push({ name: "StdTime", description: "", unit: "ISO8601", values: s2?.map((e6) => e6.getTime()), hasRegularIntervals: !s2, interval: o3, intervalUnit: a4, extent: [e5.getTime(), n5.getTime()] });
    });
  }
  if (i5.length) {
    const e5 = { variables: i5 };
    return d3(e5), e5;
  }
  return null;
}
function M(t4) {
  const i5 = e2(t4, "SpatialDomain"), s2 = e2(i5, "GridCRS"), a4 = t2(s2, "GridBaseCRS"), l5 = t2(s2, "GridOrigin"), u2 = l5?.split(" ").map((e4) => parseFloat(e4)) ?? [0, 0], m5 = r2(s2, "GridOffsets"), d4 = n(i5, "BoundingBox");
  let f4, g4, h3, b6;
  for (let n4 = 0; n4 < d4.length; n4++) {
    const t5 = d4[n4].getAttribute("crs")?.toLowerCase();
    if (null != t5) {
      if (t5.includes("imagecrs")) {
        const e4 = r2(d4[n4], "LowerCorner"), t6 = r2(d4[n4], "UpperCorner");
        f4 = t6[0] - e4[0] + 1, g4 = t6[1] - e4[1] + 1;
      } else if (t5.indexOf("epsg") > 0) {
        const i6 = t5.split(":");
        h3 = parseInt(i6[i6.length - 1], 10);
        const s3 = r2(d4[n4], "LowerCorner"), a5 = r2(d4[n4], "UpperCorner");
        b6 = new z({ xmin: s3[0], ymin: s3[1], xmax: a5[0], ymax: a5[1], spatialReference: { wkid: h3 } });
      }
    }
  }
  const x3 = f4 > g4, v4 = b6.xmax - b6.xmin > b6.ymax - b6.ymin;
  let D3 = false;
  o2(h3) && (x3 === v4 ? D3 = false : (D3 = true, b6 = new z({ xmin: b6.ymin, ymin: b6.xmin, xmax: b6.ymax, ymax: b6.xmax, spatialReference: { wkid: h3 } })));
  const y3 = { columns: f4, rows: g4, origin: { x: u2[0], y: u2[1] }, offset: { x: m5[0], y: m5[m5.length - 1] }, gridBaseCRS: a4, envelope: b6, useEPSGAxis: D3 }, w4 = e2(t4, "temporalDomain") || e2(t4, "TemporalDomain");
  return { spatialDomain: y3, temporalDomain: w4 ? S3(w4) : null };
}
function N(e4, t4) {
  const n4 = [], s2 = [], a4 = { supportedFormats: n4, supportedCRSs: s2, version: "1.1" };
  let o3, l5, u2 = [];
  for (let i5 = 0; i5 < e4.childNodes.length; i5++) {
    const t5 = e4.childNodes[i5];
    if (1 !== t5.nodeType) continue;
    const p7 = c2(t5).toLowerCase();
    switch (p7) {
      case "title":
      case "abstract":
      case "identifier":
        a4[p7] = t2(t5);
        break;
      case "supportedformat":
        {
          const e5 = t2(t5);
          n4.includes(e5) || n4.push(e5);
        }
        break;
      case "supportedcrs":
        {
          const e5 = t2(t5);
          s2.includes(e5) || s2.push(e5);
        }
        break;
      case "range":
        {
          const e5 = T(t5, !!a4.domain?.temporalDomain);
          a4.range = e5.rangeSet, u2 = e5.bandNames;
          const { bandNoDataValues: n5 } = e5;
          n5?.length && (o3 = D2(n5)), l5 = e5.statistics;
        }
        break;
      case "domain":
        a4.domain = M(t5);
    }
  }
  const p6 = h2(a4.range[0].supportedInterpolations), { identifier: c3, abstract: d4, title: f4, domain: g4, range: b6 } = a4, x3 = { x: Math.abs(g4.spatialDomain.offset.x), y: Math.abs(g4.spatialDomain.offset.y) }, v4 = R(b6, g4);
  v4 && (o3 = b6[0].nullValues, 1 === o3?.length && (o3 = o3[0]));
  const y3 = new m3({ width: g4.spatialDomain.columns, height: g4.spatialDomain.rows, pixelSize: x3, pixelType: "unknown", extent: g4.spatialDomain.envelope, spatialReference: g4.spatialDomain.envelope.spatialReference, bandCount: u2.length || 1, noDataValue: o3, statistics: l5, multidimensionalInfo: v4 });
  return { id: c3, title: a4.title, description: d4 || f4, bandNames: u2, rasterInfo: y3, supportedFormats: n4, supportedInterpolations: p6, coverageDescription: a4, version: t4, useEPSGAxis: g4.spatialDomain.useEPSGAxis };
}
function P3(t4) {
  const n4 = e2(t4, "Envelope") || e2(t4, "EnvelopeWithTimePeriod"), i5 = n4.getAttribute("srsName"), s2 = i5.slice(i5.lastIndexOf("/") + 1), a4 = n4.getAttribute("axisLabels").split(" ").map((e4) => e4.trim()).filter((e4) => "" !== e4.trim()), o3 = r2(n4, "lowerCorner"), u2 = r2(n4, "upperCorner"), m5 = !["y", "lat", "latitude", "north", "nor", "n", "b"].includes(a4[0].toLowerCase());
  let d4;
  const f4 = parseInt(s2, 10), g4 = isNaN(f4) ? null : { wkid: f4 };
  d4 = new z(m5 ? { xmin: o3[0], ymin: o3[1], xmax: u2[0], ymax: u2[1], spatialReference: g4 } : { xmin: o3[1], ymin: o3[0], xmax: u2[1], ymax: u2[0], spatialReference: g4 });
  const h3 = { mins: o3, maxs: u2 }, b6 = n4.getAttribute("uomLabels").trim().split(" ");
  let x3, v4;
  if (i3(n4, "EnvelopeWithTimePeriod")) {
    x3 = new Date(t2(t4, "beginPosition") || t2(t4, "BeginPosition")), v4 = new Date(t2(t4, "endPosition") || t2(t4, "EndPosition"));
    const e4 = b6?.findIndex((e5) => "oledatetime" === e5?.toLowerCase());
    e4 > -1 && (b6[e4] = "ISO8601");
  }
  return { envelope: d4, axisLabels: a4, uomLabels: b6.length ? b6 : null, envelopeAllDims: h3, beginPosition: x3, endPosition: v4, isEastFirst: m5 };
}
function E(e4, t4) {
  const n4 = [], i5 = n(e4, "DataRecord"), s2 = [];
  let a4, l5 = [];
  for (let u2 = 0; u2 < i5.length; u2++) {
    const e5 = n(i5[u2], "field"), m5 = [];
    for (let n5 = 0; n5 < e5.length; n5++) {
      const i6 = e5[n5].getAttribute("name"), o3 = t2(e5[n5], "description") || "", u3 = e2(e5[n5], "uom")?.getAttribute("code") || "", d4 = r2(e5[n5], "interval"), f4 = x(e5[n5], "nilValue")?.[0];
      t4 && !i6.toLowerCase().includes("band") || (s2.push(i6), d4?.length && (a4 = a4 || [], a4.push({ min: d4[0], max: d4[1], avg: -1, stddev: -1 })), l5.push(f4)), m5.push({ name: i6, description: o3, uom: u3, allowedValues: d4, nilValue: f4 });
    }
    n4.push(m5);
  }
  return l5.some((e5) => null != e5) || (l5 = null), { rangeType: n4, bandNames: s2, bandStats: a4, bandNoDataValues: l5 };
}
function V(e4) {
  let t4 = 1, n4 = "";
  const i5 = 0.01;
  return Math.abs(e4 - 1 / 24) < 1 / 24 * i5 ? n4 = "Hours" : Math.abs(e4 - 1) < 1 * i5 ? n4 = "Days" : e4 < 1 ? (t4 = Math.round(24 * e4), n4 = "Hours") : e4 > 28 - i5 && e4 < 31 + i5 || Math.round(e4 / 30) < 12 ? n4 = "Months" : e4 > 365 - i5 && e4 < 366 + i5 && (n4 = "Years"), { interval: t4, intervalUnit: n4 };
}
function A2(e4, t4, n4) {
  if (n4.axisLabels.length <= 2) return null;
  const i5 = [];
  for (let s2 = 0; s2 < e4.length; s2++) {
    const t5 = e4[s2];
    for (let e5 = 0; e5 < t5.length; e5++) t5[e5].name.toLowerCase().includes("band") || i5.push(t5[e5]);
  }
  const a4 = [];
  if (i5.length) {
    const e5 = [];
    for (let i6 = 2; i6 < n4.axisLabels.length; i6++) {
      const a5 = t4.uomLabels?.[i6]?.trim() ?? "", o3 = n4.axisLabels[i6].toLowerCase().includes("time") || "iso8601" === a5.toLowerCase() || "oledatetime" === a5.toLowerCase();
      let l5, r4;
      if (o3) {
        const e6 = V(n4.offset[i6]);
        l5 = e6.interval, r4 = e6.intervalUnit;
      } else l5 = n4.offset[i6], r4 = a5;
      const u2 = [];
      o3 ? (u2.push(w(t4.envelopeAllDims.mins[i6])), u2.push(w(t4.envelopeAllDims.maxs[i6]))) : (u2.push(t4.envelopeAllDims.mins[i6]), u2.push(t4.envelopeAllDims.maxs[i6])), e5.push({ name: n4.axisLabels[i6].trim(), description: n4.axisLabels[i6].trim(), unit: o3 ? "ISO8601" : a5, hasRegularIntervals: true, extent: u2, interval: l5, intervalUnit: r4 });
    }
    if (i5.forEach((t5) => {
      const { allowedValues: n5 } = t5, i6 = 2 === n5?.length ? [{ min: n5[0], max: n5[1], avg: -1, stddev: -1 }] : null;
      a4.push({ name: t5.name.trim(), description: t5.description?.trim() ?? "", unit: t5.uom.trim(), statistics: i6, dimensions: [...e5] });
    }), a4.length) {
      const e6 = { variables: a4 };
      return d3(e6), e6;
    }
  }
  return null;
}
function F(e4, t4) {
  const n4 = e2(e4, "RectifiedGrid"), i5 = r2(n4, "low"), s2 = r2(n4, "high"), a4 = [];
  for (let o3 = 0; o3 < i5.length; o3++) a4.push(s2[o3] - i5[o3] + 1);
  const l5 = t2(n4, "axisLabels").split(" "), u2 = r2(n4, "origin/pos"), m5 = n(n4, "offsetVector"), d4 = [];
  for (let o3 = 0; o3 < m5.length; o3++) {
    const e5 = r2(m5[o3]), t5 = e5.findIndex((e6) => 0 !== e6);
    d4[t5] = e5[t5];
  }
  const f4 = ["y", "lat", "latitude", "north", "nor", "n", "b"];
  let g4 = false;
  if (t4?.length && l5?.length) {
    g4 = [...t4].sort((e5, t5) => e5 < t5 ? -1 : 1).join(",") === [...l5].sort((e5, t5) => e5 < t5 ? -1 : 1).join(",");
  }
  const h3 = g4 ? l5 : t4;
  let b6, x3, v4;
  return f4.includes(h3[0].toLowerCase()) ? (b6 = a4[1], x3 = a4[0], v4 = { y: Math.abs(d4[0]), x: Math.abs(d4[1]) }) : (b6 = a4[0], x3 = a4[1], v4 = { x: Math.abs(d4[0]), y: Math.abs(d4[1]) }), { columns: b6, rows: x3, origin: u2, offset: d4, resolution: v4, gridSamples: a4, axisLabels: l5, hasSameAxisLabelsAsBoundedBy: g4 };
}
function O(e4) {
  const n4 = e2(e4, "EarthObservation");
  if (!n4) return null;
  const i5 = e2(n4, "phenomenonTime"), s2 = i5 ? S3(i5) : null, a4 = e2(n4, "phenomenonTime"), o3 = a4 ? S3(a4) : null, l5 = t2(n4, "featureOfInterest/Footprint/multiExtentOf/MultiSurface/surfaceMembers/Polygon/exterior/LinearRing/posList");
  let u2 = null;
  if (l5) {
    const e5 = l5.split(" ").map((e6) => e6.trim()).filter((e6) => null != e6 && "" !== e6).map(Number);
    if (e5.length) {
      const n5 = [];
      for (let t4 = 0; t4 < e5.length / 2; t4 += 2) n5.push(e5[t4], e5[t4 + 1]);
      u2 = new P({ rings: [[n5]] });
    }
  }
  return { observation: { phenomenonTime: s2, resultTime: o3, footprint: u2, identifier: t2(e4, "metaDataProperty/EarthObservationMetaData/identifier"), acquisitionType: t2(e4, "metaDataProperty/EarthObservationMetaData/acquisitionType"), status: t2(e4, "metaDataProperty/EarthObservationMetaData/status") } };
}
function B(e4) {
  const t4 = { version: "2.0" };
  let n4, s2, a4 = [];
  for (let i5 = 0; i5 < e4.childNodes.length; i5++) {
    const o4 = e4.childNodes[i5];
    if (1 === o4.nodeType) {
      if (i3(o4, "coverageId")) t4.coverageId = t2(o4);
      else if (i3(o4, "ServiceParameters")) t4.serviceParameters = { supportedFormats: l3(o4, "nativeFormat") };
      else if (i3(o4, "boundedBy")) t4.boundedBy = P3(o4);
      else if (i3(o4, "rangeType")) {
        const e5 = E(o4, t4.boundedBy?.axisLabels.length > 2 || t4.domainSet?.axisLabels.length > 2);
        t4.rangeType = e5.rangeType, a4 = e5.bandNames, n4 = e5.bandStats;
        const { bandNoDataValues: i6 } = e5;
        i6?.length && (s2 = D2(i6));
      } else if (i3(o4, "domainSet")) t4.domainSet = F(o4, t4.boundedBy?.axisLabels);
      else if (i3(o4, "metadata")) {
        const e5 = e2(o4, "EOMetadata");
        t4.eoMetadata = e5 ? O(e5) : null;
      }
    }
  }
  const { coverageId: o3, boundedBy: m5, domainSet: c3, rangeType: d4, serviceParameters: f4 } = t4, g4 = A2(d4, m5, c3);
  !n4 && g4 && (n4 = g4?.variables[0].statistics), null != g4 && (s2 = d4[0][0].nilValue);
  return { id: o3, title: o3, description: o3, bandNames: a4, rasterInfo: new m3({ width: c3.columns, height: c3.rows, pixelSize: c3.resolution, pixelType: "unknown", extent: m5.envelope, spatialReference: m5.envelope.spatialReference, bandCount: a4.length || 1, statistics: n4, noDataValue: s2, multidimensionalInfo: g4 }), supportedFormats: f4.supportedFormats, coverageDescription: t4, version: "2.0.1", useEPSGAxis: false };
}
function k2(e4, t4) {
  let n4 = null;
  if ("string" == typeof e4) {
    n4 = new DOMParser().parseFromString(e4, "text/xml");
  } else n4 = e4;
  if ("1.0.0" === t4) {
    return n(n4, "CoverageOffering").map((e5) => L(e5));
  }
  const i5 = n(n4, "CoverageDescription");
  return "1.1.0" === t4 || "1.1.1" === t4 || "1.1.2" === t4 ? i5.map((e5) => N(e5, t4)) : i5.map((e5) => B(e5));
}

// node_modules/@arcgis/core/layers/ogc/wcsUtils.js
async function i4(a4, i5) {
  const { version: n4, customParameters: c3, signal: p6 } = i5 ?? {}, l5 = n4?.startsWith("1.0") ? "version" : "acceptVersions", m5 = { service: "WCS", request: "GetCapabilities", [l5]: n4, ...c3 };
  try {
    let { data: r4 } = await H(a4, { query: m5, responseType: "xml", signal: p6 });
    return i5?.version || S2(r4) || (m5[l5] = "2.0.1", { data: r4 } = await H(a4, { query: m5, responseType: "xml", signal: p6 })), b3(r4);
  } catch (u2) {
    if (!b(u2)) throw new s("wcslayer:open", "wcs capabilities is not valid or supported");
    throw u2;
  }
}
async function n2(t4, o3) {
  const { coverageIds: i5, version: n4, customParameters: c3, signal: p6 } = o3, l5 = n4.slice(0, 3), m5 = "1.0" === l5 ? "coverage" : "1.1" === l5 ? "identifiers" : "coverageId", u2 = { service: "WCS", request: "DescribeCoverage", version: n4, [m5]: i5.join(","), ...c3 };
  try {
    const { data: r4 } = await H(t4, { query: u2, responseType: "xml", signal: p6 });
    return k2(r4, n4);
  } catch (v4) {
    if (!b(v4)) throw new s("wcslayer:open", "wcs coverage description is not valid or supported");
    throw v4;
  }
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/multipartParser.js
function t3(t4) {
  const r4 = e3(t4);
  return r4 ? { isMultipart: true, data: r4.boundary ? n3(t4.data, r4, 0) : null } : { isMultipart: false, data: null };
}
function n3(t4, n4, e4 = 0) {
  const o3 = "--" + n4.boundary, i5 = [];
  for (let r4 = 0; r4 < o3.length; r4++) i5.push(o3.charCodeAt(r4));
  const a4 = [], s2 = "\n--" + n4.boundary + "--";
  for (let r4 = 0; r4 < s2.length; r4++) a4.push(s2.charCodeAt(r4));
  const l5 = [10], c3 = [13, 10], f4 = [], u2 = i5.length, h3 = new Uint8Array(t4, e4), g4 = h3.length - u2;
  let p6 = 0, d4 = 0;
  for (let b6 = 0; b6 < g4; b6++) {
    for (d4 = 0; d4 < u2 && h3[b6 + d4] === i5[d4]; d4++) ;
    if (d4 !== u2) continue;
    let t5 = false;
    if (p6) {
      const e5 = r3(h3.subarray(p6, b6), n4);
      f4.push(e5), t5 = !!e5.isValidImage;
    }
    if (b6 += u2 - 1, h3[b6 + 1] === l5[0] ? b6 += 1 : h3[b6 + 1] === c3[0] && h3[b6 + 2] === c3[1] && (b6 += 2), p6 = b6 + 1, t5) break;
  }
  const y3 = a4.length;
  for (let b6 = h3.length - y3 - 10; b6 < h3.length - y3; b6++) {
    for (d4 = 0; d4 < y3 && h3[b6 + d4] === a4[d4]; d4++) ;
    if (d4 === y3) {
      f4.push(r3(h3.subarray(p6, b6), n4));
      break;
    }
  }
  return f4;
}
function e3(t4) {
  const n4 = t4.getHeader?.("Content-Type")?.split(";");
  if (!n4) return null;
  if (!(n4[0].trim() ?? "").startsWith("multipart/")) return null;
  const e4 = { boundary: "", start: "", type: "" };
  for (let r4 = 1; r4 < n4.length; r4++) {
    const t5 = n4[r4].indexOf("=");
    if (t5 > 0) {
      const o3 = n4[r4].slice(0, t5).trim(), i5 = n4[r4].slice(t5 + 1).trim();
      e4[o3] = i5.startsWith('"') ? i5.slice(1, -1) : i5;
    }
  }
  return e4;
}
function r3(t4, n4) {
  const e4 = String.fromCharCode.apply(null, t4.subarray(0, Math.min(300, t4.length))).split("\n"), r4 = Math.min(e4.length, 7), o3 = { contentDisposition: "inline" };
  let i5 = 0;
  for (let a4 = 0; a4 < r4; a4++) if (e4[a4].length < 4) i5 = i5 + e4[a4].length + 1;
  else if ("content" === e4[a4].slice(0, 7).toLowerCase()) {
    i5 = i5 + e4[a4].length + 1;
    const t5 = e4[a4].indexOf(":");
    if (-1 === t5) continue;
    const n5 = e4[a4].slice(0, t5).trim(), r5 = e4[a4].slice(t5 + 1).trim();
    switch (n5.toLowerCase()) {
      case "content-type":
        o3.contentType = r5;
        break;
      case "content-description":
        o3.contentDescription = r5;
        break;
      case "content-transfer-encoding":
        o3.contentTransferEncoding = r5;
        break;
      case "content-id":
        o3.contentID = r5;
        break;
      case "content-disposition":
        o3.contentDisposition = r5;
        break;
      case "content-location":
        o3.contentLocation = r5;
    }
  } else {
    if (o3.contentDisposition.toLowerCase().includes("inline") && e4[a4].length >= 4 && o3.contentType?.toLowerCase().indexOf("image") > -1) {
      let n5 = true, e5 = t4.subarray(i5, t4.length);
      if (o3.contentType.toLowerCase().indexOf("tif") > 0) {
        if ("base64" === o3.contentTransferEncoding) {
          let t5 = "";
          const n6 = e5;
          for (let e6 = 0; e6 < n6.length; e6 += 65535) {
            const r6 = n6.subarray(e6, e6 + 65535 > n6.length - 1 ? n6.length - 1 : e6 + 65535);
            t5 += String.fromCharCode.apply(null, r6);
          }
          const r5 = atob(t5);
          e5 = new Uint8Array(r5.length);
          for (let o4 = 0; o4 < e5.length; o4++) e5[o4] = r5.charCodeAt(o4);
        }
        n5 = 73 === e5[0] && 73 === e5[1] || 77 === e5[0] && 77 === e5[1];
      }
      if (n5) {
        let n6 = e5.buffer;
        "base64" !== o3.contentTransferEncoding && (n6 = new ArrayBuffer(t4.length - i5), e5 = new Uint8Array(n6), e5.set(t4.subarray(i5, t4.length))), o3.contentData = n6, o3.isValidImage = true;
      }
      break;
    }
    if (("" === n4.start || o3.contentID === n4.start) && o3.contentType) {
      if (o3.contentType.includes("text") || o3.contentType.includes("xml")) {
        o3.contentData = String.fromCharCode.apply(null, t4.subarray(i5, t4.length));
        break;
      }
      o3.contentData = t4.subarray(i5, t4.length);
    }
  }
  return o3;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/WCSRaster.js
var g3 = ["nearest neighbor", "bilinear", "bicubic"];
var w3 = ["nearest", "linear", "cubic"];
var v3 = "response is not a supported multipart/related mediaType with inline tiff,  switching to compatibility mode";
var y2 = "response is not a supported multipart mediaType with inline tiff";
var x2 = "response is base64 encoded which may impact layer display performance";
var I2 = "server returns an exception";
var C2 = /* @__PURE__ */ new Set(["1.0.0", "1.1.0", "1.1.1", "1.1.2", "2.0.1"]);
var b5 = class extends $ {
  constructor() {
    super(...arguments), this.datasetFormat = "WCSServer", this.tileType = "Raster";
  }
  get rasterId() {
    return `${this.url}-${this.coverageId}-${this.version}`;
  }
  async fetchRawTile(e4, i5, n4, s2 = {}) {
    if (this.isBlockOutside(e4, i5, n4)) return null;
    const { nativePixelSize: o3, spatialReference: r4 } = this.rasterInfo, a4 = 2 ** e4, l5 = o3.x * a4, c3 = o3.y * a4, { blockWidth: d4, blockHeight: f4 } = this.getBlockWidthHeight(e4), { origin: p6 } = this.rasterInfo.storageInfo.tileInfo, u2 = this.getTileExtent({ x: l5, y: c3 }, i5, n4, p6, r4, [d4, f4]), h3 = this.rasterInfo.extent, g4 = u2.xmax > h3.xmax, w4 = u2.ymin < h3.ymin, v4 = g4 || w4;
    let y3 = u2, x3 = d4, I3 = f4;
    if (v4 && (y3 = u2.clone().intersection(h3), null != y3 && (g4 && (x3 = Math.floor((y3.xmax - y3.xmin) / l5), y3.xmax = y3.xmin + l5 * x3), w4 && (I3 = Math.floor((y3.ymax - y3.ymin) / c3), y3.ymin = y3.ymax - c3 * I3))), null == y3 || x3 <= 1 || I3 <= 1) return null;
    const C4 = await this._getCoverage(y3, x3, I3, a4, s2);
    if (!C4) return null;
    const { coverageDescription: b6 } = this.coverageInfo, { noDataValue: $3, multidimensionalInfo: S4 } = this.rasterInfo, { multidimensionalDefinition: j2 } = s2;
    let T3;
    if (null != S4 && null != j2 && j2.length) {
      const e5 = j2[0].variableName;
      if ("2.0" === b6.version) {
        const t4 = b6.rangeType[0].find((t5) => t5.name === e5);
        T3 = t4?.nilValue;
      } else if ("1.1" === b6.version) {
        const t4 = b6.range.find((t5) => t5.identifier === e5);
        T3 = t4?.nullValues;
      }
    }
    const L2 = T3 ?? $3, P4 = await this.decodePixelBlock(C4, { width: x3, height: I3, planes: null, pixelType: null, tiffNoDataValue: Array.isArray(L2) ? L2[0] : L2, matchAllNoData: true });
    if (null == P4) return null;
    if (P4 && (P4.width !== x3 || P4.height !== I3)) throw new s("wcsraster-fetch", `the response has unexpected dimension width: ${P4.width}, height: {pixelBlock.height}`);
    return v4 ? W(P4, { x: 0, y: 0 }, { width: f4, height: f4 }) : P4;
  }
  async _open(e4) {
    const { customFetchParameters: i5 } = this.ioConfig, n4 = e4?.signal, s2 = await i4(this.url, { version: i5?.version ?? this.version, customParameters: i5, signal: n4 });
    if (this.capabilities = s2, !this.version) {
      let e5 = s2.version.slice(0, 3);
      "2.0" === e5 || "1.1" === e5 || "1.0" === e5 ? this.version = s2.version : (e5 = s2.supportedVersions.find((e6) => "2.0.1" === e6) || s2.supportedVersions.find((e6) => "2.0" === e6.slice(0, 3)) || s2.supportedVersions.find((e6) => "1.1" === e6.slice(0, 3)) || s2.supportedVersions.find((e6) => "1.0" === e6.slice(0, 3)) || "1.0.0", this.version = e5);
    }
    const { version: o3 } = this;
    if (!C2.has(o3)) throw new s("wcsraster-open", `unsupported WCS version ${o3}`);
    const { gridCoverages: r4 } = s2;
    if (!r4.length) throw new s("wcsraster-open", "cannot find rectified grid coverages");
    this.coverageId ??= r4[0].id;
    const { coverageId: c3 } = this, d4 = r4.find((e5) => e5.id === c3);
    if (null == d4) throw new s("wcsraster-open", `the coverageId ${c3} does not exist in capabilities`);
    const f4 = await n2(this.url, { coverageIds: [c3], version: o3, customParameters: i5, signal: n4 });
    if (this.coverageInfo = f4[0], "2.0" === o3.slice(0, 3)) {
      const { coverageInfo: e5 } = this;
      e5.lonLatEnvelope = d4.lonLatEnvelope, e5.supportedInterpolations = h2(s2.supportedInterpolations), this._patchDimensionValues201(c3, n4);
    }
    this.datasetName = this.coverageInfo.title;
    const { rasterInfo: p6 } = this.coverageInfo;
    if (this.createRemoteDatasetStorageInfo(p6, 512, 512), this._set("rasterInfo", p6), null == p6.spatialReference) throw new s("wcsraster-open", `coverage without spatial reference is not supported: ${c3}`);
    const { pixelType: h3, bandCount: m5 } = await this._getPixelTypeAndBandCount(n4);
    p6.pixelType = h3, 1 === p6.bandCount && m5 > 1 && (p6.bandCount = m5), this.updateTileInfo();
  }
  async _patchDimensionValues201(e4, t4) {
    const { coverageInfo: i5 } = this, n4 = i5.rasterInfo.multidimensionalInfo?.variables, s2 = C2.has("1.1.2") ? "1.1.2" : C2.has("1.1.1") ? "1.1.1" : C2.has("1.1.0") ? "1.1.0" : null, { customFetchParameters: o3 } = this.ioConfig;
    if (n4 && s2) try {
      const i6 = this.url.includes("/ImageServer/"), r4 = e4.length > 8 && e4.startsWith("Coverage") && i6 ? e4.slice(8) : e4, a4 = await n2(this.url, { coverageIds: [r4 ?? e4], version: s2, customParameters: o3, signal: t4 }).catch(() => {
        if (r4) return n2(this.url, { coverageIds: [e4], version: s2, customParameters: o3, signal: t4 });
      }), c3 = a4?.[0].rasterInfo.multidimensionalInfo?.variables;
      if (c3) for (const e5 of n4) {
        const t5 = c3.find(({ name: t6 }) => t6 === e5.name);
        if (t5?.dimensions?.length) for (let n5 = e5.dimensions.length - 1; n5 >= 0; n5--) {
          const s3 = e5.dimensions[n5], o4 = t5.dimensions.find(({ name: e6 }) => e6 === s3.name);
          o4 ? o4.values && o4.extent?.join(",") === s3.extent?.join(",") && (e5.dimensions[n5] = { ...s3, values: o4.values }) : i6 && e5.dimensions.splice(n5, 1);
        }
      }
    } catch {
    }
  }
  async _getPixelTypeAndBandCount(e4) {
    const { pixelSize: n4, extent: s2, multidimensionalInfo: r4 } = this.rasterInfo, a4 = s2.center, l5 = new z({ xmin: a4.x - n4.x, xmax: a4.x + n4.x, ymin: a4.y - n4.y, ymax: a4.y + n4.y, spatialReference: s2.spatialReference });
    let d4 = [];
    if (null != r4) {
      const e5 = r4.variables[0];
      d4 = [], e5.dimensions.forEach((t4) => {
        d4.push(new p3({ variableName: e5.name, dimensionName: t4.name, values: t4.hasRegularIntervals ? t4.extent?.[0] : t4.values?.[0], isSlice: true }));
      });
    }
    const { coverageDescription: f4 } = this.coverageInfo, p6 = { interpolation: "nearest", multidimensionalDefinition: d4, signal: e4 }, { version: u2 } = f4, { ioConfig: h3 } = this, m5 = "2.0" === u2 && null == h3.allowAnyMediaType || "1.1" === u2 && null == h3.use2GridOffsets;
    let g4;
    try {
      g4 = await this._getCoverage(l5, 2, 2, 1, p6, true);
    } catch (y3) {
      if (!m5) throw y3;
      if ("1.1" === u2) {
        if (!y3.details?.isResolutionMismatch) throw y3;
        h3.use2GridOffsets = true;
      }
    }
    if (!g4 && m5 && ("2.0" === u2 && (h3.allowAnyMediaType = true), g4 = await this._getCoverage(l5, 2, 2, 1, p6), g4 && i.getLogger(this).warn("wcsraster:getcoverage", v3)), !g4) throw new s("wcsraster-open", "unable to determine pixel type");
    const w4 = await this.decodePixelBlock(g4, { width: 2, height: 2, planes: null, pixelType: null });
    if (null == w4) throw new s("wcsraster-open", "unable to determine pixel type");
    return { pixelType: w4.pixelType, bandCount: w4.getPlaneCount() ?? 0 };
  }
  async _getCoverage(e4, n4, s2, o3, r4, a4 = false) {
    const { coverageDescription: l5 } = this.coverageInfo, { version: c3 } = l5, d4 = "2.0" === c3 ? this._getCoverage201Parameters(e4, n4, s2, o3, r4, l5) : "1.1" === c3 ? this._getCoverage110Parameters(e4, n4, s2, r4, l5) : this._getCoverage100Parameters(e4, n4, s2, r4), f4 = "2.0" === c3 ? await this.request(this._constructWCS201Url(d4), { signal: r4.signal, responseType: "array-buffer" }) : await this.request(this.url, { query: d4, signal: r4.signal, responseType: "array-buffer" });
    if ("1.0" === c3) return f4.data;
    if ("2.0" === c3 && false !== this.ioConfig.allowAnyMediaType) {
      if ("tiff" === P2(f4.data)) return a4 && (this.ioConfig.allowAnyMediaType = true, i.getLogger(this).warn("wcsraster:getcoverage", v3)), f4.data;
    }
    const u2 = t3(f4);
    if (u2.isMultipart && u2.data) {
      const e5 = u2.data.find((e6) => e6.isValidImage);
      return a4 && "base64" === e5?.contentTransferEncoding && i.getLogger(this).warn("wcsraster:getcoverage", x2), e5?.contentData;
    }
    const m5 = new Uint8Array(f4.data, 0, Math.min(f4.data.byteLength, 2e3)), g4 = String.fromCharCode.apply(null, m5).toLowerCase().includes("exception"), w4 = g4 && String.fromCharCode.apply(null, m5).includes("A non-zero RESX/RESY or WIDTH/HEIGHT is required but neither was provided");
    if (g4) throw new s("wcsraster:getcoverage", I2, { isResolutionMismatch: w4 });
    throw new s("wcsraster:getcoverage", y2);
  }
  _getInterpolationIndex(e4) {
    return e4 && this.coverageInfo.supportedInterpolations?.includes(e4) ? "nearest" === e4 ? 0 : "bilinear" === e4 ? 1 : "cubic" === e4 ? 2 : 0 : 0;
  }
  _getCoverage100Parameters(e4, t4, i5, n4) {
    const s2 = `${e4.xmin},${e4.ymin},${e4.xmax},${e4.ymax}`, o3 = e4.spatialReference.wkid, r4 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "GEOTIFF", { bandIds: a4, interpolation: l5 } = n4, c3 = this._getInterpolationIndex(l5), d4 = a4 ? a4.map((e5) => this.coverageInfo.bandNames[e5]) : null, f4 = g3[c3], { multidimensionalDefinition: p6 } = n4;
    let u2;
    if (null != p6 && null != this.rasterInfo.multidimensionalInfo) {
      const e5 = p6.find((e6) => "StdTime" === e6.dimensionName);
      let t5 = e5?.values;
      t5 && t5.length > 0 && (Array.isArray(t5[0]) && (t5 = t5[0]), u2 = t5.map((e6) => $2(e6)).join(","));
    }
    return { service: "WCS", request: "GetCoverage", version: this.version, coverage: this.coverageId, format: r4, crs: `EPSG:${o3}`, bbox: s2, width: t4, height: i5, time: u2, interpolation: f4, band: d4?.join(",") };
  }
  _getCoverage110Parameters(e4, t4, i5, n4, s2) {
    const { multidimensionalDefinition: o3, bandIds: a4, interpolation: l5 } = n4, c3 = e4.spatialReference.wkid, d4 = `urn:ogc:def:crs:EPSG::${c3}`, f4 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "image/tiff", p6 = this._getInterpolationIndex(l5), u2 = w3[p6], h3 = null == l5 || 0 === this.coverageInfo.supportedInterpolations?.indexOf(l5), m5 = s2.domain.spatialDomain, g4 = m5.origin.x <= m5.envelope.xmin && m5.origin.y <= m5.envelope.ymin, v4 = e4.width / t4, y3 = e4.height / i5 * (g4 ? 1 : -1), x3 = g4 ? [e4.xmin, e4.ymin] : [e4.xmin, e4.ymax], I3 = m5.useEPSGAxis && o2(c3), C4 = I3 ? `${x3[1]},${x3[0]}` : `${x3[0]},${x3[1]}`, b6 = this.ioConfig.use2GridOffsets, S4 = I3 ? b6 ? `${y3},${v4}` : `${y3},0,0,${v4}` : b6 ? `${v4},${y3}` : `${v4},0,0,${y3}`, j2 = v4 / 2, T3 = e4.xmin + j2, L2 = e4.xmax - j2, P4 = Math.abs(y3) / 2, R3 = e4.ymin + P4, _ = e4.ymax - P4, D3 = I3 ? `${R3},${T3},${_},${L2},${d4}` : `${T3},${R3},${L2},${_},${d4}`, A3 = s2.range.find((e5) => e5.axis.some((e6) => e6.identifier.toLowerCase().includes("band")));
    let E2, G = A3 && u2 && a4 ? h3 ? `${A3.identifier}[${A3.axis[0].identifier}[${a4.join(",")}]]` : `${A3.identifier}:${u2}[${A3.axis[0].identifier}[${a4.join(",")}]]` : null;
    if (null != o3 && o3.length) for (let r4 = 0; r4 < o3.length; r4++) {
      let e5 = o3[r4].values;
      const t5 = o3[r4].dimensionName?.toLowerCase(), i6 = o3[r4].variableName?.toLowerCase(), n5 = s2.range.find((e6) => e6.identifier.toLowerCase() === i6);
      if (e5.length > 0) {
        if (Array.isArray(e5[0]) && (e5 = e5[0]), "stdtime" === t5) E2 = e5.map((e6) => $2(e6)).join(",");
        else if (n5) {
          const i7 = n5.axis.find((e6) => e6.identifier.toLowerCase() === t5);
          i7 && (G = h3 ? n5.identifier + "[" + i7.identifier + "[" + e5.join(",") + "]]" : n5.identifier + ":" + u2 + "[" + i7.identifier + "[" + e5.join(",") + "]]");
        }
      }
      r4 === o3.length - 1 && n5 && !G && (G = h3 ? n5.identifier : n5.identifier + ":" + u2);
    }
    return { service: "WCS", request: "GetCoverage", version: this.version, identifier: this.coverageId, format: f4, crs: `EPSG:${c3}`, boundingbox: D3, gridCS: "urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS", gridType: "urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs", gridOrigin: C4, gridOffsets: S4, gridBaseCRS: d4, timeSequence: E2, rangeSubset: G };
  }
  _getCoverage201Parameters(e4, t4, i5, n4, s2, o3) {
    const { multidimensionalDefinition: r4, interpolation: a4 } = s2, l5 = this._getInterpolationIndex(a4);
    let c3 = null;
    const { supportedInterpolations: d4 } = this.capabilities;
    if (d4?.length) switch (l5) {
      case 0:
        c3 = d4.find((e5) => e5.toLowerCase().includes("nearest"));
        break;
      case 1:
        c3 = d4.find((e5) => e5.toLowerCase().includes("linear"));
        break;
      case 2:
        c3 = d4.find((e5) => e5.toLowerCase().includes("cubic") || e5.toLowerCase().includes("quadratic"));
    }
    const f4 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "image/tiff", { bandNames: p6 } = this.coverageInfo, { boundedBy: u2, domainSet: h3, rangeType: m5 } = o3, g4 = u2.isEastFirst ? 0 : 1, w4 = 1 - g4, { axisLabels: v4 } = u2, y3 = v4[g4], x3 = v4[w4], I3 = `http://www.opengis.net/def/crs/EPSG/0/${e4.spatialReference.wkid}`, C4 = I3, b6 = [];
    b6.push(`${y3}(${e4.xmin},${e4.xmax})`), b6.push(`${x3}(${e4.ymin},${e4.ymax})`);
    const S4 = [];
    if (v4.length > 2) for (let _ = 2; _ < v4.length; _++) {
      const e5 = h3.origin[_];
      if (v4[_].toLowerCase().includes("time")) {
        let t5 = e5.toString();
        u2.uomLabels?.[_].toLowerCase().includes("ole") && (S4.push(v4[_]), t5 = $2(e5, true)), b6.push(v4[_] + ",http://www.opengis.net(" + t5 + ")");
      } else b6.push(v4[_] + ",http://www.opengis.net(" + e5 + ")");
    }
    let j2 = null;
    if (null != r4 && r4.length) {
      const e5 = [];
      m5.forEach((t6) => t6.forEach((t7) => e5.push(t7.name)));
      const t5 = [];
      for (let i6 = 0; i6 < r4.length; i6++) {
        const n5 = v4.find((e6) => e6 === r4[i6].dimensionName), s3 = e5.find((e6) => e6 === r4[i6].variableName);
        if (t5.includes(s3) || t5.push(s3), n5) {
          let e6 = r4[i6].values;
          if (e6.length > 0) {
            Array.isArray(e6[0]) && (e6 = e6[0]);
            let t6 = "";
            t6 = n5.toLowerCase().includes("time") ? e6.map((e7) => $2(e7)).join(",") : e6.join(",");
            const i7 = b6.findIndex((e7) => 0 === e7.indexOf(n5 + ",http://www.opengis.net"));
            -1 === i7 && b6.push(n5 + ",http://www.opengis.net(" + t6 + ")"), -1 === i7 || b6[i7].includes("(" + t6 + ")") || b6.splice(i7, 1, n5 + ",http://www.opengis.net(" + t6 + ")");
          }
        }
      }
      t5.length && (j2 = t5.join(","));
    } else if (p6?.length >= 2) {
      j2 = (s2.bandIds ? s2.bandIds.map((e5) => p6[e5]) : p6).join(",");
    }
    const T3 = b6.join("&subset="), L2 = !o3.domainSet.hasSameAxisLabelsAsBoundedBy && false !== this.ioConfig.allowScaleFactor, P4 = L2 ? null : `${y3}(${t4}),${x3}(${i5})`, R3 = L2 ? 1 / n4 : null;
    return { service: "WCS", request: "GetCoverage", version: this.version, coverageId: this.coverageId, rangesubset: j2, interpolation: c3, scaleSize: P4, scaleFactor: R3, subset: T3, format: f4, mediaType: this.ioConfig.allowAnyMediaType ? null : "multipart/related", outputcrs: I3, subsettingcrs: C4 };
  }
  _constructWCS201Url(e4) {
    const t4 = { ...this.ioConfig.customFetchParameters, ...e4 }, i5 = [];
    Object.keys(t4).forEach((e5) => {
      const n4 = t4[e5];
      null != n4 && ("subset" === e5 ? "string" == typeof n4 && n4.split("&subset=").forEach((e6) => {
        e6 && i5.push(`subset=${encodeURIComponent(e6)}`);
      }) : i5.push(`${e5}=${encodeURIComponent(n4)}`));
    });
    return `${encodeURI(this.url)}?${i5.join("&")}`;
  }
};
function $2(e4, t4 = false) {
  return (t4 ? new Date(w(e4)) : new Date(e4)).toISOString();
}
r([m({ type: String, json: { write: true } })], b5.prototype, "datasetFormat", void 0), r([m({ readOnly: true })], b5.prototype, "tileType", void 0), r([m({ type: String, json: { write: true } })], b5.prototype, "version", void 0), r([m({ type: String, json: { write: true } })], b5.prototype, "coverageId", void 0), r([m({ readOnly: true })], b5.prototype, "rasterId", null), b5 = r([a("esri.layers.support.rasterDatasets.WCSRaster")], b5);

// node_modules/@arcgis/core/layers/WCSLayer.js
var R2 = /* @__PURE__ */ new Set(["milliseconds", "seconds", "minutes", "hours", "days", "weeks", "months", "years", "decades", "centuries"]);
var C3 = class extends p(t(b2(j(e(X(i2(c(f(S(a3.ClonableMixin(h))))))))))) {
  constructor(...e4) {
    super(...e4), this.coverageId = null, this.version = null, this.isReference = null, this.legendEnabled = true, this.noData = 0, this.operationalLayerType = "WCS", this.type = "wcs", this.popupEnabled = true, this.popupTemplate = null, this.fields = null, this._debouncedSaveOperations = k(async (e5, t4, r4) => {
      const { save: o3, saveAs: s2 } = await import("./imageryUtils-JYE6ZWUM.js");
      switch (e5) {
        case A.SAVE:
          return o3(this, t4);
        case A.SAVE_AS:
          return s2(this, r4, t4);
      }
    });
  }
  normalizeCtorArgs(e4, t4) {
    return "string" == typeof e4 ? { url: e4, ...t4 } : e4;
  }
  load(e4) {
    const t4 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WCS"] }, e4).catch(a2).then(() => this._openRaster(t4))), Promise.resolve(this);
  }
  get coverageInfo() {
    return this.raster.coverageInfo;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    const e4 = [o("Pixel Value")], t4 = this.raster?.rasterInfo ?? this.serviceRasterInfo, r4 = t4?.multidimensionalInfo;
    if (r4) {
      const t5 = p4(r4);
      e4.push(...t5);
    }
    return e4;
  }
  createPopupTemplate(e4) {
    return p2({ fields: this.rasterFields, title: this.title }, e4);
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, t4) {
    return this._debouncedSaveOperations(A.SAVE_AS, t4, e4);
  }
  async _openRaster(e4) {
    const t4 = new b5({ url: this.url, version: this.version, coverageId: this.coverageId, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters } });
    if (await t4.open({ signal: e4 }), !t4.rasterInfo) throw t4.destroy(), new s("wcs-layer:load", "cannot load resources on " + this.url);
    const { rasterInfo: r4 } = t4;
    null == r4.noDataValue && (r4.noDataValue = this.noData), this._set("serviceRasterInfo", r4), this._set("spatialReference", r4.spatialReference), null == this.title && this.setAtOrigin("title", t4.datasetName, "service"), null == this.coverageId && this.setAtOrigin("coverageId", t4.coverageInfo.id, "service"), null == this.version && t4.version && this.setAtOrigin("version", t4.version, "service"), this.setAtOrigin("tileInfo", t4.rasterInfo.storageInfo.tileInfo, "service");
    const { multidimensionalInfo: s2 } = r4;
    if (null != s2) {
      const e5 = s2.variables[0].dimensions.find(({ name: e6 }) => "StdTime" === e6);
      if (e5) {
        let t5 = e5.extent?.[0] ?? e5.values[0];
        Array.isArray(t5) && (t5 = t5[0]);
        let r5 = e5.extent?.[1] ?? e5.values[e5.values.length - 1];
        Array.isArray(r5) && (r5 = r5[1]);
        const o3 = R2.has(e5.intervalUnit?.toLowerCase()) ? e5.intervalUnit?.toLowerCase() : null;
        this.set("timeInfo", { startField: "StdTime", fullTimeExtent: { start: t5, end: r5 }, timeZone: null, interval: o3 ? { value: e5.interval, unit: o3 } : null });
      }
    }
    this.raster = t4, this._configDefaultSettings(), this.addHandles(l(() => this.customParameters, (e5) => this.raster.ioConfig.customFetchParameters = e5));
  }
};
r([m({ type: String, nonNullable: true, json: { name: "wcsInfo.coverageId", write: { isRequired: true, ignoreOrigin: true } } })], C3.prototype, "coverageId", void 0), r([m()], C3.prototype, "coverageInfo", null), r([m({ type: ["1.0.0", "1.1.0", "1.1.1", "1.1.2", "2.0.1"], nonNullable: true, json: { name: "wcsInfo.version", write: { isRequired: true, ignoreOrigin: true } } })], C3.prototype, "version", void 0), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], C3.prototype, "isReference", void 0), r([m({ json: { read: true, write: true } })], C3.prototype, "blendMode", void 0), r([m(d)], C3.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide"] })], C3.prototype, "listMode", void 0), r([m()], C3.prototype, "noData", void 0), r([m({ type: ["WCS"] })], C3.prototype, "operationalLayerType", void 0), r([m()], C3.prototype, "raster", void 0), r([m({ readOnly: true })], C3.prototype, "type", void 0), r([m(l2)], C3.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], C3.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], C3.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, type: [m2] })], C3.prototype, "fields", void 0), r([m({ readOnly: true, type: [m2] })], C3.prototype, "rasterFields", null), C3 = r([a("esri.layers.WCSLayer")], C3);
var T2 = C3;
export {
  T2 as default
};
//# sourceMappingURL=WCSLayer-YEDGJSU6.js.map
