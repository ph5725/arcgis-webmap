import {
  C as C2,
  j as j2,
  p as p6,
  s as s8
} from "./chunk-M3GWMAOD.js";
import {
  p as p5
} from "./chunk-SLSJWTDB.js";
import {
  t as t7
} from "./chunk-JSKJKRHP.js";
import {
  u as u4
} from "./chunk-67IMFEKD.js";
import {
  H as H3,
  L as L2,
  N as N2,
  b as b3,
  j
} from "./chunk-VBGMA7VY.js";
import {
  A as A3,
  E as E6,
  F,
  N,
  P as P2,
  e2 as e7,
  e3 as e9,
  f2,
  h as h3,
  i2 as i3,
  l as l2,
  m2 as m6,
  n as n6,
  o2 as o7,
  p as p3,
  p2 as p4,
  r as r11,
  s as s7,
  v as v2
} from "./chunk-CWLDBABC.js";
import {
  O as O2
} from "./chunk-B7AMZ4LC.js";
import {
  t as t5
} from "./chunk-PJ7AE5BM.js";
import {
  g as g3,
  h as h4,
  t as t4
} from "./chunk-SMESMUA5.js";
import {
  e as e8
} from "./chunk-RS3I6DPK.js";
import {
  B as B2,
  c as c3,
  g as g2
} from "./chunk-56ZY2WLU.js";
import {
  n2 as n7,
  o2 as o6,
  t2 as t6
} from "./chunk-4XEYVSQH.js";
import {
  o as o5
} from "./chunk-QY6CN52R.js";
import {
  o2 as o8
} from "./chunk-VT5VIQO4.js";
import {
  B,
  M as M2,
  h as h2,
  v
} from "./chunk-3GCFO25G.js";
import {
  t as t3
} from "./chunk-ZN7Z7TAB.js";
import {
  e as e6
} from "./chunk-TTPBKTNJ.js";
import {
  S as S2,
  e as e5,
  i as i2,
  n as n5,
  s as s6,
  u as u3
} from "./chunk-ZPAWXU2P.js";
import {
  E as E4,
  U,
  b as b2
} from "./chunk-BGR5EVZD.js";
import {
  E as E5,
  e as e4
} from "./chunk-UZRZVWLE.js";
import {
  M,
  O,
  V,
  m as m3,
  p as p2
} from "./chunk-RTDWTAVK.js";
import {
  a as a3
} from "./chunk-QLJ6JQFC.js";
import {
  m as m4
} from "./chunk-DLD56RZZ.js";
import {
  t as t2
} from "./chunk-67CCONUO.js";
import {
  t
} from "./chunk-6DBRCIDV.js";
import {
  m as m5,
  s as s5
} from "./chunk-YSRSL2SU.js";
import {
  e as e3,
  r as r8
} from "./chunk-NZPABYQQ.js";
import {
  R as R2
} from "./chunk-BZYXFNL4.js";
import {
  r as r9
} from "./chunk-VNTS5E5O.js";
import {
  A as A2,
  E as E2,
  H as H2,
  I,
  K,
  P,
  R,
  X as X2,
  Z,
  _,
  c as c2,
  g,
  o as o4,
  p,
  r as r7,
  s as s4,
  u as u2
} from "./chunk-TMFB3DKM.js";
import {
  l
} from "./chunk-H7XUEHGR.js";
import {
  E as E3,
  r as r10
} from "./chunk-TNW4TPNP.js";
import {
  e as e2,
  n as n3
} from "./chunk-UG6RJXJ2.js";
import {
  n as n4,
  r as r6,
  s as s3
} from "./chunk-7FAVUXK2.js";
import {
  E,
  L,
  a as a2,
  m as m2,
  x,
  z
} from "./chunk-IVNFIIVI.js";
import {
  o as o3
} from "./chunk-UGTICYU7.js";
import {
  e2 as e10
} from "./chunk-VCRP2PLV.js";
import {
  A,
  C,
  H,
  X,
  c,
  h,
  n as n2,
  s as s2
} from "./chunk-DNZK6PPI.js";
import {
  f,
  y
} from "./chunk-MUKDJQWB.js";
import {
  n,
  r as r5
} from "./chunk-RACDQ3AL.js";
import {
  o as o2
} from "./chunk-YIV2QKTZ.js";
import {
  o,
  r as r4
} from "./chunk-FPSA4NFH.js";
import {
  b,
  e3 as e,
  m,
  r2 as r3
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  s,
  u2 as u
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i
} from "./chunk-XWG6QGFK.js";
import {
  S,
  r as r2
} from "./chunk-FXKORAMT.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/UpdatePolicy.js
var C3;
!function(C6) {
  C6[C6.ASYNC = 0] = "ASYNC", C6[C6.SYNC = 1] = "SYNC";
}(C3 || (C3 = {}));

// node_modules/@arcgis/core/views/3d/layers/interfaces.js
var e11;
var a4;
var t8;
!function(e14) {
  e14[e14.RasterImage = 0] = "RasterImage", e14[e14.Features = 1] = "Features";
}(e11 || (e11 = {})), function(e14) {
  e14[e14.MapLayer = 0] = "MapLayer", e14[e14.ViewLayer = 1] = "ViewLayer", e14[e14.Outline = 2] = "Outline", e14[e14.SnappingHint = 3] = "SnappingHint";
}(a4 || (a4 = {})), function(e14) {
  e14[e14.WithRasterImage = 0] = "WithRasterImage", e14[e14.WithoutRasterImage = 1] = "WithoutRasterImage";
}(t8 || (t8 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/utils.js
function n8(t14, e14) {
  return null == t14 && (t14 = []), t14.push(e14), t14;
}
function r12(t14, e14) {
  if (null == t14) return null;
  const n11 = t14.filter((t15) => t15 !== e14);
  return 0 === n11.length ? null : n11;
}
function l3(t14, n11, r17, l7, i5) {
  o9[0] = t14.get(n11, 0), o9[1] = t14.get(n11, 1), o9[2] = t14.get(n11, 2), t5(o9, s9, 3), r17.set(i5, 0, s9[0]), l7.set(i5, 0, s9[1]), r17.set(i5, 1, s9[2]), l7.set(i5, 1, s9[3]), r17.set(i5, 2, s9[4]), l7.set(i5, 2, s9[5]);
}
var o9 = n();
var s9 = new Float32Array(6);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3D.js
var A4 = class {
  constructor(i5 = {}) {
    this.id = e(), this._highlightIds = /* @__PURE__ */ new Set(), this._shaderTransformation = null, this._visible = true, this.castShadow = i5.castShadow ?? true, this.usesVerticalDistanceToGround = i5.usesVerticalDistanceToGround ?? false, this.graphicUid = i5.graphicUid, this.layerViewUid = i5.layerViewUid, i5.isElevationSource && (this.lastValidElevationBB = new M3()), this._geometries = i5.geometries ? Array.from(i5.geometries) : new Array();
  }
  dispose() {
    this._geometries.length = 0;
  }
  get layer() {
    return this._layer;
  }
  set layer(t14) {
    s5(null == this._layer || null == t14, "Object3D can only be added to a single Layer"), this._layer = t14;
  }
  addGeometry(t14) {
    t14.visible = this._visible, this._geometries.push(t14);
    for (const i5 of this._highlightIds) t14.addHighlight(i5);
    this._emit("geometryAdded", { object: this, geometry: t14 }), this._highlightIds.size && this._emit("highlightChanged", this), this._invalidateBoundingVolume();
  }
  removeGeometry(t14) {
    const i5 = this._geometries.splice(t14, 1)[0];
    if (i5) {
      for (const t15 of this._highlightIds) i5.removeHighlight(t15);
      this._emit("geometryRemoved", { object: this, geometry: i5 }), this._highlightIds.size && this._emit("highlightChanged", this), this._invalidateBoundingVolume();
    }
  }
  removeAllGeometries() {
    for (; this._geometries.length > 0; ) this.removeGeometry(0);
  }
  geometryVertexAttributeUpdated(t14, i5, e14 = false) {
    this._emit("attributesChanged", { object: this, geometry: t14, attribute: i5, sync: e14 }), E5(i5) && this._invalidateBoundingVolume();
  }
  get visible() {
    return this._visible;
  }
  set visible(t14) {
    if (this._visible !== t14) {
      this._visible = t14;
      for (const t15 of this._geometries) t15.visible = this._visible;
      this._emit("visibilityChanged", this);
    }
  }
  maskOccludee() {
    const t14 = new r11();
    for (const i5 of this._geometries) i5.occludees = n8(i5.occludees, t14);
    return this._emit("occlusionChanged", this), t14;
  }
  removeOcclude(t14) {
    for (const i5 of this._geometries) i5.occludees = r12(i5.occludees, t14);
    this._emit("occlusionChanged", this);
  }
  highlight(t14) {
    const i5 = new e7(t14);
    for (const e14 of this._geometries) e14.addHighlight(i5);
    return this._emit("highlightChanged", this), this._highlightIds.add(i5), i5;
  }
  removeHighlight(t14) {
    this._highlightIds.delete(t14);
    for (const i5 of this._geometries) i5.removeHighlight(t14);
    this._emit("highlightChanged", this);
  }
  removeStateID(t14) {
    t14.channel === t2.Highlight ? this.removeHighlight(t14) : this.removeOcclude(t14);
  }
  getCombinedStaticTransformation(t14, e14) {
    return c(e14, this.transformation, t14.transformation);
  }
  getCombinedShaderTransformation(t14, e14 = e3()) {
    return c(e14, this.effectiveTransformation, t14.transformation);
  }
  get boundingVolumeWorldSpace() {
    return this._bvWorldSpace || (this._bvWorldSpace = this._bvWorldSpace || new O3(), this._validateBoundingVolume(this._bvWorldSpace, w.WorldSpace)), this._bvWorldSpace;
  }
  get boundingVolumeObjectSpace() {
    return this._bvObjectSpace || (this._bvObjectSpace = this._bvObjectSpace || new O3(), this._validateBoundingVolume(this._bvObjectSpace, w.ObjectSpace)), this._bvObjectSpace;
  }
  _validateBoundingVolume(t14, i5) {
    const e14 = i5 === w.ObjectSpace;
    for (const s12 of this._geometries) {
      const i6 = s12.boundingInfo;
      i6 && T(i6, t14, e14 ? s12.transformation : this.getCombinedShaderTransformation(s12));
    }
    I(U(t14.bounds), t14.min, t14.max, 0.5);
    for (const s12 of this._geometries) {
      const i6 = s12.boundingInfo;
      if (null == i6) continue;
      const o12 = e14 ? s12.transformation : this.getCombinedShaderTransformation(s12), r17 = m3(o12);
      E2(I2, i6.center, o12);
      const a8 = p(I2, U(t14.bounds)), m9 = i6.radius * r17;
      t14.bounds[3] = Math.max(t14.bounds[3], a8 + m9);
    }
  }
  _invalidateBoundingVolume() {
    const t14 = this._bvWorldSpace?.bounds;
    this._bvObjectSpace = this._bvWorldSpace = void 0, this.layer && t14 && this.layer.notifyObjectBBChanged(this, t14);
  }
  _emit(t14, i5) {
    this.layer?.events.emit(t14, i5);
  }
  get geometries() {
    return this._geometries;
  }
  get transformation() {
    return this._transformation ?? r8;
  }
  set transformation(t14) {
    this._transformation = n2(this._transformation ?? e3(), t14), this._invalidateBoundingVolume(), this._emit("transformationChanged", this);
  }
  get shaderTransformation() {
    return this._shaderTransformation;
  }
  set shaderTransformation(t14) {
    this._shaderTransformation = t14 ? n2(this._shaderTransformation ?? e3(), t14) : null, this._invalidateBoundingVolume(), this._emit("shaderTransformationChanged", this);
  }
  get effectiveTransformation() {
    return this.shaderTransformation ?? this.transformation;
  }
  get test() {
  }
};
var M3 = class {
  constructor() {
    this.min = r5(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this.max = r5(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  }
  isEmpty() {
    return this.max[0] < this.min[0] && this.max[1] < this.min[1] && this.max[2] < this.min[2];
  }
};
var O3 = class extends M3 {
  constructor() {
    super(...arguments), this.bounds = E4();
  }
};
function T(t14, i5, e14) {
  const o12 = t14.bbMin, r17 = t14.bbMax;
  if (H(e14)) {
    const t15 = o4(C4, e14[12], e14[13], e14[14]);
    u2(B3, o12, t15), u2(U2, r17, t15);
    for (let e15 = 0; e15 < 3; ++e15) i5.min[e15] = Math.min(i5.min[e15], B3[e15]), i5.max[e15] = Math.max(i5.max[e15], U2[e15]);
  } else if (E2(B3, o12, e14), H2(o12, r17)) for (let s12 = 0; s12 < 3; ++s12) i5.min[s12] = Math.min(i5.min[s12], B3[s12]), i5.max[s12] = Math.max(i5.max[s12], B3[s12]);
  else {
    E2(U2, r17, e14);
    for (let t15 = 0; t15 < 3; ++t15) i5.min[t15] = Math.min(i5.min[t15], B3[t15], U2[t15]), i5.max[t15] = Math.max(i5.max[t15], B3[t15], U2[t15]);
    for (let t15 = 0; t15 < 3; ++t15) {
      s4(B3, o12), s4(U2, r17), B3[t15] = r17[t15], U2[t15] = o12[t15], E2(B3, B3, e14), E2(U2, U2, e14);
      for (let t16 = 0; t16 < 3; ++t16) i5.min[t16] = Math.min(i5.min[t16], B3[t16], U2[t16]), i5.max[t16] = Math.max(i5.max[t16], B3[t16], U2[t16]);
    }
  }
}
var C4 = n();
var B3 = n();
var U2 = n();
var I2 = n();
var w;
!function(t14) {
  t14[t14.WorldSpace = 0] = "WorldSpace", t14[t14.ObjectSpace = 1] = "ObjectSpace";
}(w || (w = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RibbonLineTechnique.js
var S3 = class extends g3 {
  constructor(e14, i5) {
    super(e14, i5, new t4(C2, () => import("./RibbonLine.glsl-C3INHNXB.js")), _2), this.primitiveType = i5.wireframe ? R2.LINES : R2.TRIANGLE_STRIP;
  }
  _makePipelineState(t14, i5) {
    const { oitPass: c6, output: f5, hasOccludees: h6, hasPolygonOffset: m9 } = t14, O5 = c6 === o5.NONE, E8 = c6 === o5.FrontFace;
    return B2({ blending: u3(f5) ? p4(c6) : null, depthTest: { func: E6(c6) }, depthWrite: N(t14), drawBuffers: h4(f5, F(c6, f5)), colorWrite: g2, stencilWrite: h6 ? e9 : null, stencilTest: h6 ? i5 ? o7 : f2 : null, polygonOffset: O5 || E8 ? m9 ? L3 : null : h3 });
  }
  initializePipeline(e14) {
    if (e14.occluder) {
      const t14 = e14.hasPolygonOffset ? L3 : null, { output: i5, hasOccludees: l7 } = e14;
      this._occluderPipelineTransparent = B2({ blending: c3, polygonOffset: t14, depthTest: s7, depthWrite: null, colorWrite: g2, stencilWrite: null, stencilTest: l7 ? m6 : null, drawBuffers: h4(i5) }), this._occluderPipelineOpaque = B2({ blending: c3, polygonOffset: t14, depthTest: l7 ? s7 : i3, depthWrite: null, colorWrite: g2, stencilWrite: l7 ? l2 : null, stencilTest: l7 ? P2 : null, drawBuffers: h4(i5) }), this._occluderPipelineMaskWrite = B2({ blending: null, polygonOffset: t14, depthTest: i3, depthWrite: null, colorWrite: null, stencilWrite: l7 ? e9 : null, stencilTest: l7 ? o7 : null, drawBuffers: h4(i5) });
    }
    return this._occludeePipeline = this._makePipelineState(e14, true), this._makePipelineState(e14, false);
  }
  getPipeline(e14, t14) {
    if (e14) return this._occludeePipeline;
    switch (t14) {
      case A3.TRANSPARENT_OCCLUDER_MATERIAL:
        return this._occluderPipelineTransparent ?? super.getPipeline();
      case A3.OCCLUDER_MATERIAL:
        return this._occluderPipelineOpaque ?? super.getPipeline();
      default:
        return this._occluderPipelineMaskWrite ?? super.getPipeline();
    }
  }
};
var L3 = { factor: 0, units: -4 };
var _2 = /* @__PURE__ */ new Map([[e4.POSITION, 0], [e4.PREVIOUSDELTA, 1], [e4.NEXTDELTA, 2], [e4.U0, 3], [e4.LINEPARAMETERS, 4], [e4.COLOR, 5], [e4.COLORFEATUREATTRIBUTE, 5], [e4.SIZE, 6], [e4.SIZEFEATUREATTRIBUTE, 6], [e4.OPACITYFEATUREATTRIBUTE, 7], [e4.OLIDCOLOR, 8]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/RibbonLineMaterial.js
var Y;
!function(e14) {
  e14[e14.LEFT_JOIN_START = -2] = "LEFT_JOIN_START", e14[e14.LEFT_JOIN_END = -1] = "LEFT_JOIN_END", e14[e14.LEFT_CAP_START = -4] = "LEFT_CAP_START", e14[e14.LEFT_CAP_END = -5] = "LEFT_CAP_END", e14[e14.RIGHT_JOIN_START = 2] = "RIGHT_JOIN_START", e14[e14.RIGHT_JOIN_END = 1] = "RIGHT_JOIN_END", e14[e14.RIGHT_CAP_START = 4] = "RIGHT_CAP_START", e14[e14.RIGHT_CAP_END = 5] = "RIGHT_CAP_END";
}(Y || (Y = {}));
var q = class extends n7 {
  constructor(e14) {
    super(e14, Q), this._configuration = new p6(), this.vertexAttributeLocations = _2, this.produces = /* @__PURE__ */ new Map([[A3.OPAQUE_MATERIAL, (e15) => i2(e15) || u3(e15) && this.parameters.renderOccluded === o6.OccludeAndTransparentStencil], [A3.OPAQUE_MATERIAL_WITHOUT_NORMALS, (e15) => S2(e15)], [A3.OCCLUDER_MATERIAL, (e15) => s6(e15) && this.parameters.renderOccluded === o6.OccludeAndTransparentStencil], [A3.TRANSPARENT_OCCLUDER_MATERIAL, (e15) => s6(e15) && this.parameters.renderOccluded === o6.OccludeAndTransparentStencil], [A3.TRANSPARENT_MATERIAL, (e15) => u3(e15) && this.parameters.writeDepth && this.parameters.renderOccluded !== o6.OccludeAndTransparentStencil], [A3.TRANSPARENT_MATERIAL_WITHOUT_DEPTH, (e15) => u3(e15) && !this.parameters.writeDepth && this.parameters.renderOccluded !== o6.OccludeAndTransparentStencil], [A3.DRAPED_MATERIAL, (e15) => e5(e15)]]);
  }
  getConfiguration(e14, t14) {
    super.getConfiguration(e14, t14, this._configuration), this._configuration.oitPass = t14.oitPass, this._configuration.draped = t14.slot === A3.DRAPED_MATERIAL;
    const r17 = null != this.parameters.stipplePattern && e14 !== n5.Highlight;
    return this._configuration.stippleEnabled = r17, this._configuration.stippleOffColorEnabled = r17 && null != this.parameters.stippleOffColor, this._configuration.stipplePreferContinuous = r17 && this.parameters.stipplePreferContinuous, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.roundJoins = "round" === this.parameters.join, this._configuration.capType = this.parameters.cap, this._configuration.applyMarkerOffset = null != this.parameters.markerParameters && te(this.parameters.markerParameters), this._configuration.hasPolygonOffset = this.parameters.hasPolygonOffset, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.vvOpacity = !!this.parameters.vvOpacity, this._configuration.innerColorEnabled = this.parameters.innerWidth > 0 && null != this.parameters.innerColor, this._configuration.falloffEnabled = this.parameters.falloff > 0, this._configuration.hasOccludees = t14.hasOccludees, this._configuration.occluder = this.parameters.renderOccluded === o6.OccludeAndTransparentStencil, this._configuration.terrainDepthTest = t14.terrainDepthTest && u3(e14), this._configuration.cullAboveTerrain = t14.cullAboveTerrain, this._configuration.wireframe = this.parameters.wireframe, this._configuration;
  }
  get visible() {
    return this.parameters.color[3] >= o8 || null != this.parameters.stipplePattern && (this.parameters.stippleOffColor?.[3] ?? 0) > o8;
  }
  intersectDraped({ attributes: e14, screenToWorldRatio: r17 }, i5, s12, a8, n11) {
    if (!i5.options.selectionMode) return;
    const o12 = e14.get(e4.SIZE);
    let l7 = this.parameters.width;
    if (this.parameters.vvSize) {
      const r18 = e14.get(e4.SIZEFEATUREATTRIBUTE).data[0];
      Number.isNaN(r18) ? l7 *= this.parameters.vvSize.fallback[0] : l7 *= r4(this.parameters.vvSize.offset[0] + r18 * this.parameters.vvSize.factor[0], this.parameters.vvSize.minSize[0], this.parameters.vvSize.maxSize[0]);
    } else o12 && (l7 *= o12.data[0]);
    const c6 = s12[0], p9 = s12[1], h6 = (l7 / 2 + 4) * r17;
    let f5 = Number.MAX_VALUE, m9 = 0;
    const u6 = e14.get(e4.POSITION).data, T3 = ee(this.parameters, e14) ? u6.length - 2 : u6.length - 5;
    for (let d3 = 0; d3 < T3; d3 += 3) {
      const e15 = u6[d3], r18 = u6[d3 + 1], i6 = (d3 + 3) % u6.length, s13 = c6 - e15, a9 = p9 - r18, n12 = u6[i6] - e15, o13 = u6[i6 + 1] - r18, l8 = r4((n12 * s13 + o13 * a9) / (n12 * n12 + o13 * o13), 0, 1), h7 = n12 * l8 - s13, T4 = o13 * l8 - a9, E8 = h7 * h7 + T4 * T4;
      E8 < f5 && (f5 = E8, m9 = d3 / 3);
    }
    f5 < h6 * h6 && a8(n11.distance, n11.normal, m9);
  }
  intersect(r17, f5, m9, u6, T3, A6) {
    const { options: S4, camera: v4, rayBegin: P3, rayEnd: N3 } = m9;
    if (!S4.selectionMode || !r17.visible || !v4) return;
    if (!m5(f5)) return void i.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");
    const L4 = r17.attributes, b5 = L4.get(e4.POSITION).data;
    let C6 = this.parameters.width;
    if (this.parameters.vvSize) {
      const e14 = L4.get(e4.SIZEFEATUREATTRIBUTE).data[0];
      Number.isNaN(e14) || (C6 *= r4(this.parameters.vvSize.offset[0] + e14 * this.parameters.vvSize.factor[0], this.parameters.vvSize.minSize[0], this.parameters.vvSize.maxSize[0]));
    } else L4.has(e4.SIZE) && (C6 *= L4.get(e4.SIZE).data[0]);
    const U3 = ne;
    r10(U3, m9.point);
    const y3 = C6 * v4.pixelRatio / 2 + 4 * v4.pixelRatio;
    o4(de[0], U3[0] - y3, U3[1] + y3, 0), o4(de[1], U3[0] + y3, U3[1] + y3, 0), o4(de[2], U3[0] + y3, U3[1] - y3, 0), o4(de[3], U3[0] - y3, U3[1] - y3, 0);
    for (let e14 = 0; e14 < 4; e14++) if (!v4.unprojectFromRenderScreen(de[e14], Ee[e14])) return;
    p2(v4.eye, Ee[0], Ee[1], _e), p2(v4.eye, Ee[1], Ee[2], Ae), p2(v4.eye, Ee[2], Ee[3], Re), p2(v4.eye, Ee[3], Ee[0], ge);
    let j3 = Number.MAX_VALUE, D2 = 0;
    const F2 = ee(this.parameters, L4) ? b5.length - 2 : b5.length - 5;
    for (let e14 = 0; e14 < F2; e14 += 3) {
      re[0] = b5[e14] + f5[12], re[1] = b5[e14 + 1] + f5[13], re[2] = b5[e14 + 2] + f5[14];
      const t14 = (e14 + 3) % b5.length;
      if (ie[0] = b5[t14] + f5[12], ie[1] = b5[t14 + 1] + f5[13], ie[2] = b5[t14 + 2] + f5[14], V(_e, re) < 0 && V(_e, ie) < 0 || V(Ae, re) < 0 && V(Ae, ie) < 0 || V(Re, re) < 0 && V(Re, ie) < 0 || V(ge, re) < 0 && V(ge, ie) < 0) continue;
      if (v4.projectToRenderScreen(re, oe), v4.projectToRenderScreen(ie, le), oe[2] < 0 && le[2] > 0) {
        c2(se, re, ie);
        const e15 = v4.frustum, t15 = -V(e15[j.NEAR], re) / P(se, O(e15[j.NEAR]));
        g(se, se, t15), u2(re, re, se), v4.projectToRenderScreen(re, oe);
      } else if (oe[2] > 0 && le[2] < 0) {
        c2(se, ie, re);
        const e15 = v4.frustum, t15 = -V(e15[j.NEAR], ie) / P(se, O(e15[j.NEAR]));
        g(se, se, t15), u2(ie, ie, se), v4.projectToRenderScreen(ie, le);
      } else if (oe[2] < 0 && le[2] < 0) continue;
      oe[2] = 0, le[2] = 0;
      const r18 = M2(h2(oe, le, he), U3);
      r18 < j3 && (j3 = r18, s4(ce, re), s4(pe, ie), D2 = e14 / 3);
    }
    if (j3 < y3 * y3) {
      let e14 = Number.MAX_VALUE;
      if (B(h2(ce, pe, he), h2(P3, N3, fe), ae)) {
        c2(ae, ae, P3);
        const t14 = r7(ae);
        g(ae, ae, 1 / t14), e14 = t14 / p(P3, N3);
      }
      A6(e14, ae, D2);
    }
  }
  get _layout() {
    const e14 = O2().vec3f(e4.POSITION).vec4f16(e4.PREVIOUSDELTA).vec4f16(e4.NEXTDELTA).f32(e4.U0).vec2f16(e4.LINEPARAMETERS);
    return this.parameters.vvColor ? e14.f32(e4.COLORFEATUREATTRIBUTE) : e14.vec4u8(e4.COLOR, { glNormalized: true }), this.parameters.vvSize ? e14.f32(e4.SIZEFEATUREATTRIBUTE) : e14.f32(e4.SIZE), this.parameters.vvOpacity && e14.f32(e4.OPACITYFEATUREATTRIBUTE), e6() && e14.vec4u8(e4.OLIDCOLOR), e14;
  }
  createBufferWriter() {
    return new K2(this._layout, this.parameters);
  }
  createGLMaterial(e14) {
    return new X3(e14);
  }
  validateParameters(e14) {
    "miter" !== e14.join && (e14.miterLimit = 0), null != e14.markerParameters && (e14.markerScale = e14.markerParameters.width / e14.width);
  }
};
var X3 = class extends e8 {
  constructor() {
    super(...arguments), this._stipplePattern = null;
  }
  dispose() {
    super.dispose(), this._stippleTextures.release(this._stipplePattern), this._stipplePattern = null;
  }
  beginSlot(e14) {
    const t14 = this._material.parameters.stipplePattern;
    return this._stipplePattern !== t14 && (this._material.setParameters({ stippleTexture: this._stippleTextures.swap(t14, this._stipplePattern) }), this._stipplePattern = t14), this.getTechnique(S3, e14);
  }
};
var Q = class extends t6 {
  constructor() {
    super(...arguments), this.width = 0, this.color = s3, this.join = "miter", this.cap = s8.BUTT, this.miterLimit = 5, this.writeDepth = true, this.hasPolygonOffset = false, this.stippleTexture = null, this.stipplePreferContinuous = true, this.markerParameters = null, this.markerScale = 1, this.hasSlicePlane = false, this.vvFastUpdate = false, this.isClosed = false, this.falloff = 0, this.innerWidth = 0, this.wireframe = false;
  }
  get transparent() {
    return this.color[3] < 1 || null != this.stipplePattern && (this.stippleOffColor?.[3] ?? 0) < 1;
  }
};
var K2 = class {
  constructor(e14, t14) {
    this.vertexBufferLayout = e14, this._parameters = t14;
    const r17 = t14.stipplePattern ? 1 : 0;
    switch (this._parameters.join) {
      case "miter":
      case "bevel":
        this.numJoinSubdivisions = r17;
        break;
      case "round":
        this.numJoinSubdivisions = j2 + r17;
    }
  }
  _isClosed(e14) {
    return ee(this._parameters, e14);
  }
  allocate(e14) {
    return this.vertexBufferLayout.createBuffer(e14);
  }
  elementCount(e14) {
    const t14 = 2, r17 = e14.get(e4.POSITION).indices.length / 2 + 1, i5 = this._isClosed(e14);
    let s12 = i5 ? 2 : 2 * t14;
    return s12 += ((i5 ? r17 : r17 - 1) - (i5 ? 0 : 1)) * (2 * this.numJoinSubdivisions + 4), s12 += 2, this._parameters.wireframe && (s12 = 2 + 4 * (s12 - 2)), s12;
  }
  write(e14, t14, r17, i5, a8, n11) {
    const o12 = r17.get(e4.POSITION), l7 = o12.indices, p9 = o12.data.length / 3, m9 = r17.get(e4.DISTANCETOSTART)?.data;
    l7 && l7.length !== 2 * (p9 - 1) && console.warn("RibbonLineMaterial does not support indices");
    const u6 = (this.vertexBufferLayout.fields.has(e4.SIZEFEATUREATTRIBUTE) ? r17.get(e4.SIZEFEATUREATTRIBUTE)?.data[0] : r17.get(e4.SIZE)?.data[0]) ?? 1;
    let d3 = [1, 1, 1, 1], E8 = 0;
    const _4 = this.vertexBufferLayout.fields.has(e4.COLORFEATUREATTRIBUTE);
    _4 ? E8 = r17.get(e4.COLORFEATUREATTRIBUTE).data[0] : r17.has(e4.COLOR) && (d3 = r17.get(e4.COLOR).data);
    const A6 = this.vertexBufferLayout.fields.has(e4.OPACITYFEATUREATTRIBUTE), R4 = A6 ? r17.get(e4.OPACITYFEATUREATTRIBUTE).data[0] : 0, g5 = new Float32Array(a8.buffer), S4 = t(a8.buffer), O5 = new Uint8Array(a8.buffer), I3 = this.vertexBufferLayout.stride / 4;
    let v4 = n11 * I3;
    const P3 = v4;
    let N3 = 0;
    const L4 = m9 ? (e15, t15, r18) => N3 = m9[r18] : (e15, t15, r18) => N3 += p(e15, t15), b5 = g5.BYTES_PER_ELEMENT / S4.BYTES_PER_ELEMENT, C6 = 4 / b5, U3 = (e15, t15, r18, s12, a9, n12, o13) => {
      g5[v4++] = t15[0], g5[v4++] = t15[1], g5[v4++] = t15[2], v2(e15, t15, S4, v4 * b5), v4 += C6, v2(r18, t15, S4, v4 * b5), v4 += C6, g5[v4++] = o13;
      let l8 = v4 * b5;
      if (S4[l8++] = s12, S4[l8++] = a9, v4 = Math.ceil(l8 / b5), _4) g5[v4] = E8;
      else {
        const e16 = Math.min(4 * n12, d3.length - 4), t16 = 4 * v4;
        O5[t16] = 255 * d3[e16], O5[t16 + 1] = 255 * d3[e16 + 1], O5[t16 + 2] = 255 * d3[e16 + 2], O5[t16 + 3] = 255 * d3[e16 + 3];
      }
      if (v4++, g5[v4++] = u6, A6 && (g5[v4++] = R4), e6()) {
        let e16 = 4 * v4;
        i5 ? (O5[e16++] = i5[0], O5[e16++] = i5[1], O5[e16++] = i5[2], O5[e16++] = i5[3]) : (O5[e16++] = 0, O5[e16++] = 0, O5[e16++] = 0, O5[e16++] = 0), v4 = Math.ceil(0.25 * e16);
      }
    };
    v4 += I3, o4(ue, o12.data[0], o12.data[1], o12.data[2]), e14 && E2(ue, ue, e14);
    const j3 = this._isClosed(r17);
    if (j3) {
      const t15 = o12.data.length - 3;
      o4(me, o12.data[t15], o12.data[t15 + 1], o12.data[t15 + 2]), e14 && E2(me, me, e14);
    } else o4(Te, o12.data[3], o12.data[4], o12.data[5]), e14 && E2(Te, Te, e14), U3(ue, ue, Te, 1, Y.LEFT_CAP_START, 0, 0), U3(ue, ue, Te, 1, Y.RIGHT_CAP_START, 0, 0), s4(me, ue), s4(ue, Te);
    const D2 = j3 ? 0 : 1, F2 = j3 ? p9 : p9 - 1;
    for (let h6 = D2; h6 < F2; h6++) {
      const t15 = (h6 + 1) % p9 * 3;
      o4(Te, o12.data[t15], o12.data[t15 + 1], o12.data[t15 + 2]), e14 && E2(Te, Te, e14), L4(me, ue, h6), U3(me, ue, Te, 0, Y.LEFT_JOIN_END, h6, N3), U3(me, ue, Te, 0, Y.RIGHT_JOIN_END, h6, N3);
      const r18 = this.numJoinSubdivisions;
      for (let e15 = 0; e15 < r18; ++e15) {
        const t16 = (e15 + 1) / (r18 + 1);
        U3(me, ue, Te, t16, Y.LEFT_JOIN_END, h6, N3), U3(me, ue, Te, t16, Y.RIGHT_JOIN_END, h6, N3);
      }
      U3(me, ue, Te, 1, Y.LEFT_JOIN_START, h6, N3), U3(me, ue, Te, 1, Y.RIGHT_JOIN_START, h6, N3), s4(me, ue), s4(ue, Te);
    }
    j3 ? (o4(Te, o12.data[3], o12.data[4], o12.data[5]), e14 && E2(Te, Te, e14), N3 = L4(me, ue, F2), U3(me, ue, Te, 0, Y.LEFT_JOIN_END, D2, N3), U3(me, ue, Te, 0, Y.RIGHT_JOIN_END, D2, N3)) : (N3 = L4(me, ue, F2), U3(me, ue, ue, 0, Y.LEFT_CAP_END, F2, N3), U3(me, ue, ue, 0, Y.RIGHT_CAP_END, F2, N3)), $(g5, P3 + I3, g5, P3, I3);
    return v4 = $(g5, v4 - I3, g5, v4, I3), this._parameters.wireframe && this._addWireframeVertices(a8, P3, v4, I3), null;
  }
  _addWireframeVertices(e14, t14, r17, i5) {
    const s12 = new Float32Array(e14.buffer, r17 * Float32Array.BYTES_PER_ELEMENT), a8 = new Float32Array(e14.buffer, t14 * Float32Array.BYTES_PER_ELEMENT, r17 - t14);
    let n11 = 0;
    const o12 = (e15) => n11 = $(a8, e15, s12, n11, i5);
    for (let l7 = 0; l7 < a8.length - 1; l7 += 2 * i5) o12(l7), o12(l7 + 2 * i5), o12(l7 + 1 * i5), o12(l7 + 2 * i5), o12(l7 + 1 * i5), o12(l7 + 3 * i5);
  }
};
function $(e14, t14, r17, i5, s12) {
  for (let a8 = 0; a8 < s12; a8++) r17[i5++] = e14[t14++];
  return i5;
}
function ee(e14, t14) {
  if (!e14.isClosed) return false;
  return t14.get(e4.POSITION).indices.length > 2;
}
function te(e14) {
  return e14.anchor === p5.Tip && e14.hideOnShortSegments && "begin-end" === e14.placement && e14.worldSpace;
}
var re = n();
var ie = n();
var se = n();
var ae = n();
var ne = n();
var oe = y();
var le = y();
var ce = n();
var pe = n();
var he = v();
var fe = v();
var me = n();
var ue = n();
var Te = n();
var de = [y(), y(), y(), y()];
var Ee = [n(), n(), n(), n()];
var _e = M();
var Ae = M();
var Re = M();
var ge = M();

// node_modules/@arcgis/core/views/3d/support/ElevationProvider.js
var r13 = class {
  constructor(e14, r17 = null, t14 = 0) {
    this.array = e14, this.spatialReference = r17, this.offset = t14;
  }
};
function t9(e14) {
  return "array" in e14;
}
function a5(r17, a8, n11 = "ground") {
  if (t7(a8)) return r17.getElevation(a8.x, a8.y, a8.z || 0, a8.spatialReference, n11);
  if (t9(a8)) {
    let e14 = a8.offset;
    return r17.getElevation(a8.array[e14++], a8.array[e14++], a8.array[e14] || 0, a8.spatialReference ?? r17.spatialReference, n11);
  }
  return r17.getElevation(a8[0], a8[1], a8[2] || 0, r17.spatialReference, n11);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/elevationAlignmentUtils.js
function u5(e14, t14, n11, o12, i5, a8, s12, l7, u6, c6, f5) {
  const m9 = x2[f5.mode];
  let d3, g5, p9 = 0;
  if (o3(e14, t14, n11, o12, u6.spatialReference, i5, l7)) return m9?.requiresAlignment(f5) ? (p9 = m9.applyElevationAlignmentBuffer(o12, i5, a8, s12, l7, u6, c6, f5), d3 = a8, g5 = s12) : (d3 = o12, g5 = i5), o3(d3, u6.spatialReference, g5, a8, c6.spatialReference, s12, l7) ? p9 : void 0;
}
function c4(e14, t14, n11, o12, r17) {
  const l7 = (t7(e14) ? e14.z : t9(e14) ? e14.array[e14.offset + 2] : e14[2]) || 0;
  switch (n11.mode) {
    case "on-the-ground": {
      const n12 = a5(t14, e14, "ground") ?? 0;
      return r17.verticalDistanceToGround = 0, r17.sampledElevation = n12, void (r17.z = n12);
    }
    case "relative-to-ground": {
      const i5 = a5(t14, e14, "ground") ?? 0, a8 = n11.geometryZWithOffset(l7, o12);
      return r17.verticalDistanceToGround = a8, r17.sampledElevation = i5, void (r17.z = a8 + i5);
    }
    case "relative-to-scene": {
      const i5 = a5(t14, e14, "scene") ?? 0, a8 = n11.geometryZWithOffset(l7, o12);
      return r17.verticalDistanceToGround = a8, r17.sampledElevation = i5, void (r17.z = a8 + i5);
    }
    case "absolute-height": {
      const i5 = n11.geometryZWithOffset(l7, o12), a8 = a5(t14, e14, "ground") ?? 0;
      return r17.verticalDistanceToGround = i5 - a8, r17.sampledElevation = a8, void (r17.z = i5);
    }
    default:
      return void (r17.z = 0);
  }
}
function f3(e14, t14, n11, o12) {
  return c4(e14, t14, n11, o12, D), D.z;
}
function m7(e14, t14, n11) {
  return "on-the-ground" === t14 && "on-the-ground" === n11 ? e14.staysOnTheGround : t14 === n11 || "on-the-ground" !== t14 && "on-the-ground" !== n11 ? null == t14 || null == n11 ? e14.definedChanged : b4.UPDATE : e14.onTheGroundChanged;
}
function d(e14) {
  return "relative-to-ground" === e14 || "relative-to-scene" === e14;
}
function g4(e14) {
  return "absolute-height" !== e14;
}
function p7(t14, n11, r17, i5, a8) {
  c4(n11, r17, a8, i5, D), E7(t14, D.verticalDistanceToGround);
  const s12 = D.sampledElevation, l7 = n2(C5, t14.transformation);
  O4[0] = n11.x, O4[1] = n11.y, O4[2] = D.z;
  return m4(n11.spatialReference, O4, l7, i5.spatialReference) ? t14.transformation = l7 : console.warn("Could not locate symbol object properly, it might be misplaced"), s12;
}
function E7(e14, t14) {
  for (let n11 = 0; n11 < e14.geometries.length; ++n11) {
    const o12 = e14.geometries[n11].getMutableAttribute(e4.CENTEROFFSETANDDISTANCE);
    o12 && o12.data[3] !== t14 && (o12.data[3] = t14, e14.geometryVertexAttributeUpdated(e14.geometries[n11], e4.CENTEROFFSETANDDISTANCE));
  }
}
function v3(e14, t14, n11, o12, r17, i5) {
  let a8 = 0;
  const s12 = i5.spatialReference;
  t14 *= 3, o12 *= 3;
  for (let l7 = 0; l7 < r17; ++l7) {
    const r18 = e14[t14], l8 = e14[t14 + 1], u6 = e14[t14 + 2], c6 = i5.getElevation(r18, l8, u6, s12, "ground") ?? 0;
    a8 += c6, n11[o12] = r18, n11[o12 + 1] = l8, n11[o12 + 2] = c6, t14 += 3, o12 += 3;
  }
  return a8 / r17;
}
function h5(e14, t14, n11, o12, r17, i5, a8, s12) {
  let l7 = 0;
  const u6 = s12.calculateOffsetRenderUnits(a8), c6 = s12.featureExpressionInfoContext, f5 = i5.spatialReference;
  t14 *= 3, o12 *= 3;
  for (let m9 = 0; m9 < r17; ++m9) {
    const r18 = e14[t14], a9 = e14[t14 + 1], s13 = e14[t14 + 2], m10 = i5.getElevation(r18, a9, s13, f5, "ground") ?? 0;
    l7 += m10, n11[o12] = r18, n11[o12 + 1] = a9, n11[o12 + 2] = null == c6 ? s13 + m10 + u6 : m10 + u6, t14 += 3, o12 += 3;
  }
  return l7 / r17;
}
function A5(e14, t14, n11, o12, r17, i5, a8, s12) {
  let l7 = 0;
  const u6 = s12.calculateOffsetRenderUnits(a8), c6 = s12.featureExpressionInfoContext, f5 = i5.spatialReference;
  t14 *= 3, o12 *= 3;
  for (let m9 = 0; m9 < r17; ++m9) {
    const r18 = e14[t14], a9 = e14[t14 + 1], s13 = e14[t14 + 2], m10 = i5.getElevation(r18, a9, s13, f5, "scene") ?? 0;
    l7 += m10, n11[o12] = r18, n11[o12 + 1] = a9, n11[o12 + 2] = null == c6 ? s13 + m10 + u6 : m10 + u6, t14 += 3, o12 += 3;
  }
  return l7 / r17;
}
function T2(e14) {
  const t14 = e14.meterUnitOffset, n11 = e14.featureExpressionInfoContext;
  return 0 !== t14 || null != n11;
}
function y2(e14, t14, n11, o12, r17, i5, a8, s12) {
  const l7 = s12.calculateOffsetRenderUnits(a8), u6 = s12.featureExpressionInfoContext;
  t14 *= 3, o12 *= 3;
  for (let c6 = 0; c6 < r17; ++c6) {
    const r18 = e14[t14], i6 = e14[t14 + 1], a9 = e14[t14 + 2];
    n11[o12] = r18, n11[o12 + 1] = i6, n11[o12 + 2] = null == u6 ? a9 + l7 : l7, t14 += 3, o12 += 3;
  }
  return 0;
}
var R3 = class {
  constructor() {
    this.verticalDistanceToGround = 0, this.sampledElevation = 0, this.z = 0;
  }
};
var b4;
!function(e14) {
  e14[e14.NONE = 0] = "NONE", e14[e14.UPDATE = 1] = "UPDATE", e14[e14.RECREATE = 2] = "RECREATE";
}(b4 || (b4 = {}));
var x2 = { "absolute-height": { applyElevationAlignmentBuffer: y2, requiresAlignment: T2 }, "on-the-ground": { applyElevationAlignmentBuffer: v3, requiresAlignment: () => true }, "relative-to-ground": { applyElevationAlignmentBuffer: h5, requiresAlignment: () => true }, "relative-to-scene": { applyElevationAlignmentBuffer: A5, requiresAlignment: () => true } };
var C5 = e3();
var D = new R3();
var O4 = n();

// node_modules/@arcgis/core/views/3d/layers/graphics/featureExpressionInfoUtils.js
var c5 = () => i.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");
function o10(e14) {
  return { cachedResult: e14.cachedResult, arcade: e14.arcade ? { func: e14.arcade.func, context: e14.arcade.modules.arcadeUtils.createExecContext(null, { sr: e14.arcade.context.spatialReference }), modules: e14.arcade.modules } : null };
}
async function a6(e14, r17, c6, o12) {
  const u6 = e14?.expression;
  if ("string" != typeof u6) return null;
  const a8 = m8(u6);
  if (null != a8) return { cachedResult: a8 };
  const s12 = await e10();
  s(c6);
  const l7 = s12.arcadeUtils, i5 = l7.createSyntaxTree(u6);
  return l7.dependsOnView(i5) ? (null != o12 && o12.error("Expressions containing '$view' are not supported on ElevationInfo"), { cachedResult: 0 }) : { arcade: { func: l7.createFunction(i5), context: l7.createExecContext(null, { sr: r17 }), modules: s12 } };
}
function s10(e14, t14, r17) {
  return e14.arcadeUtils.createFeature(t14.attributes, t14.geometry, r17);
}
function l4(e14, t14) {
  if (null != e14 && !p8(e14)) {
    if (!t14 || !e14.arcade) return void c5().errorOncePerTick("Arcade support required but not provided");
    const n11 = t14;
    n11._geometry && (n11._geometry = u4(n11._geometry)), e14.arcade.modules.arcadeUtils.updateExecContext(e14.arcade.context, t14);
  }
}
function i4(e14) {
  if (null != e14) {
    if (p8(e14)) return e14.cachedResult;
    const t14 = e14.arcade;
    let r17 = t14?.modules.arcadeUtils.executeFunction(t14.func, t14.context);
    return "number" != typeof r17 && (e14.cachedResult = 0, r17 = 0), r17;
  }
  return 0;
}
function d2(e14, t14 = false) {
  let r17 = e14?.featureExpressionInfo;
  const n11 = r17?.expression;
  return t14 || "0" === n11 || (r17 = null), r17 ?? null;
}
var f4 = { cachedResult: 0 };
function p8(e14) {
  return null != e14.cachedResult;
}
function m8(e14) {
  return "0" === e14 ? 0 : null;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationContext.js
var o11 = class _o {
  constructor() {
    this._meterUnitOffset = 0, this._renderUnitOffset = 0, this._unit = "meters", this._metersPerElevationInfoUnit = 1, this._featureExpressionInfoContext = null, this.centerPointInElevationSR = null, this.mode = null;
  }
  get featureExpressionInfoContext() {
    return this._featureExpressionInfoContext;
  }
  get meterUnitOffset() {
    return this._meterUnitOffset;
  }
  get unit() {
    return this._unit;
  }
  set unit(e14) {
    this._unit = e14, this._metersPerElevationInfoUnit = n3(e14);
  }
  get requiresSampledElevationInfo() {
    return "absolute-height" !== this.mode;
  }
  reset() {
    this.mode = null, this._meterUnitOffset = 0, this._renderUnitOffset = 0, this._featureExpressionInfoContext = null, this.unit = "meters";
  }
  set offsetMeters(t14) {
    this._meterUnitOffset = t14, this._renderUnitOffset = 0;
  }
  set offsetElevationInfoUnits(t14) {
    this._meterUnitOffset = t14 * this._metersPerElevationInfoUnit, this._renderUnitOffset = 0;
  }
  addOffsetRenderUnits(t14) {
    this._renderUnitOffset += t14;
  }
  geometryZWithOffset(t14, e14) {
    const n11 = this.calculateOffsetRenderUnits(e14);
    return null != this.featureExpressionInfoContext ? n11 : t14 + n11;
  }
  calculateOffsetRenderUnits(t14) {
    let e14 = this._meterUnitOffset;
    const s12 = this.featureExpressionInfoContext;
    return null != s12 && (e14 += i4(s12) * this._metersPerElevationInfoUnit), e14 / t14.unitInMeters + this._renderUnitOffset;
  }
  setFromElevationInfo(t14) {
    this.mode = t14.mode, this.unit = e2(t14.unit) ? t14.unit : "meters", this.offsetElevationInfoUnits = t14.offset ?? 0;
  }
  updateFeatureExpressionInfoContext(t14, e14, n11) {
    if (null == t14) return void (this._featureExpressionInfoContext = null);
    const o12 = t14?.arcade;
    o12 && null != e14 && null != n11 ? (this._featureExpressionInfoContext = o10(t14), l4(this._featureExpressionInfoContext, s10(o12.modules, e14, n11))) : this._featureExpressionInfoContext = t14;
  }
  static fromElevationInfo(t14) {
    const e14 = new _o();
    return null != t14 && e14.setFromElevationInfo(t14), e14;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DirtyEvents.js
var e12 = ["layerObjectAdded", "layerObjectRemoved", "layerObjectsAdded", "layerObjectsRemoved", "transformationChanged", "shaderTransformationChanged", "visibilityChanged", "occlusionChanged", "highlightChanged", "geometryAdded", "geometryRemoved", "attributesChanged"];

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/WebGLLayer.js
var l5 = class {
  constructor(e14, t14, o12 = "") {
    this.stage = e14, this.apiLayerViewUid = o12, this.id = e(), this.events = new o2(), this.visible = true, this.sliceable = false, this._objectsAdded = new Array(), this._handles = new r3(), this._objects = /* @__PURE__ */ new Map(), this._pickable = true, this.visible = t14?.visible ?? true, this._pickable = t14?.pickable ?? true, this.updatePolicy = t14?.updatePolicy ?? C3.ASYNC, e14.addLayer(this);
    for (const s12 of e12) this._handles.add(this.events.on(s12, (t15) => e14.handleEvent(s12, t15)));
  }
  destroy() {
    this._handles.size && (this._handles.destroy(), this.stage.removeLayer(this), this.invalidateSpatialQueryAccelerator());
  }
  get objects() {
    return this._objects;
  }
  getObject(e14) {
    return r2(this._objects.get(e14));
  }
  set pickable(e14) {
    this._pickable = e14;
  }
  get pickable() {
    return this._pickable && this.visible;
  }
  add(e14) {
    this._objects.set(e14.id, e14), e14.layer = this, this.events.emit("layerObjectAdded", e14), null != this._octree && this._objectsAdded.push(e14);
  }
  remove(t14) {
    this._objects.delete(t14.id) && (this.events.emit("layerObjectRemoved", t14), t14.layer = null, null != this._octree && (S(this._objectsAdded, t14) || this._octree.remove([t14])));
  }
  addMany(e14) {
    for (const t14 of e14) this._objects.set(t14.id, t14), t14.layer = this;
    this.events.emit("layerObjectsAdded", e14), null != this._octree && this._objectsAdded.push(...e14);
  }
  removeMany(t14) {
    const s12 = new Array();
    for (const e14 of t14) this._objects.delete(e14.id) && s12.push(e14);
    if (0 !== s12.length && (this.events.emit("layerObjectsRemoved", s12), s12.forEach((e14) => e14.layer = null), null != this._octree)) {
      for (let t15 = 0; t15 < s12.length; ) S(this._objectsAdded, s12[t15]) ? (s12[t15] = s12[s12.length - 1], s12.length -= 1) : ++t15;
      this._octree.remove(s12);
    }
  }
  sync() {
    this.updatePolicy !== C3.SYNC && this.stage.syncLayer(this.id);
  }
  notifyObjectBBChanged(e14, t14) {
    null == this._octree || this._objectsAdded.includes(e14) || this._octree.update(e14, t14);
  }
  getSpatialQueryAccelerator() {
    return null == this._octree && this._objects.size > 50 ? (this._octree = new b3((e14) => e14.boundingVolumeWorldSpace.bounds), this._octree.add(this._objects.values())) : null != this._octree && this._objectsAdded.length > 0 && (this._octree.add(this._objectsAdded), this._objectsAdded.length = 0), this._octree;
  }
  invalidateSpatialQueryAccelerator() {
    this._octree = u(this._octree), this._objectsAdded.length = 0;
  }
  get test() {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/fov.js
function t10(t14, a8, n11) {
  return 2 * Math.atan(Math.sqrt(a8 * a8 + n11 * n11) * Math.tan(0.5 * t14) / a8);
}
function a7(t14, a8, n11) {
  return 2 * Math.atan(Math.sqrt(a8 * a8 + n11 * n11) * Math.tan(0.5 * t14) / n11);
}
function n9(t14, a8, n11) {
  return 2 * Math.atan(a8 * Math.tan(0.5 * t14) / Math.sqrt(a8 * a8 + n11 * n11));
}
function r14(t14, a8, n11) {
  return 2 * Math.atan(n11 * Math.tan(0.5 * t14) / Math.sqrt(a8 * a8 + n11 * n11));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/rendererUtils.js
var r16;
var t12;
!function(e14) {
  e14[e14.Default = 0] = "Default", e14[e14.Screenshot = 1] = "Screenshot", e14[e14.ObjectAndLayerID = 2] = "ObjectAndLayerID";
}(r16 || (r16 = {})), function(e14) {
  e14[e14.TOP = 0] = "TOP", e14[e14.RIGHT = 1] = "RIGHT", e14[e14.BOTTOM = 2] = "BOTTOM", e14[e14.LEFT = 3] = "LEFT";
}(t12 || (t12 = {}));

// node_modules/@arcgis/core/views/3d/webgl/RenderCamera.js
var $2;
var tt = $2 = class extends b {
  constructor(t14) {
    super(t14), this._ray = b2(), this._viewport = r6(0, 0, 1, 1), this._padding = r6(0, 0, 0, 0), this._fov = 55 / 180 * Math.PI, this._nearFar = r9(1, 1e3), this._viewDirty = true, this._viewMatrix = e3(), this._viewProjectionDirty = true, this._viewProjectionMatrix = e3(), this._viewInverseTransposeMatrixDirty = true, this._viewInverseTransposeMatrix = e3(), this._frustumDirty = true, this._frustum = H3(), this._fullViewport = n4(), this._pixelRatio = 1, this.row = 0, this.column = 0, this._rows = 1, this._columns = 1, this._center = n(), this._up = n(), this.relativeElevation = 0;
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  set pixelRatio(t14) {
    this._pixelRatio = t14 > 0 ? t14 : 1;
  }
  get rows() {
    return this._rows;
  }
  set rows(t14) {
    this._rows = Math.max(1, t14);
  }
  get columns() {
    return this._columns;
  }
  set columns(t14) {
    this._columns = Math.max(1, t14);
  }
  get eye() {
    return this._ray.origin;
  }
  set eye(t14) {
    this._compareAndSetView(t14, this._ray.origin);
  }
  get center() {
    return this._center;
  }
  set center(t14) {
    this._compareAndSetView(t14, this._center, "_center");
  }
  get ray() {
    return c2(this._ray.direction, this.center, this.eye), this._ray;
  }
  get up() {
    return this._up;
  }
  set up(t14) {
    this._compareAndSetView(t14, this._up, "_up");
  }
  get viewMatrix() {
    return this._ensureViewClean(), this._viewMatrix;
  }
  set viewMatrix(t14) {
    n2(this._viewMatrix, t14), this.notifyChange("_viewMatrix"), this._viewDirty = false, this._viewInverseTransposeMatrixDirty = true, this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get viewForward() {
    return this._ensureViewClean(), o4(n(), -this._viewMatrix[2], -this._viewMatrix[6], -this._viewMatrix[10]);
  }
  get viewUp() {
    return this._ensureViewClean(), o4(n(), this._viewMatrix[1], this._viewMatrix[5], this._viewMatrix[9]);
  }
  get viewRight() {
    return this._ensureViewClean(), o4(n(), this._viewMatrix[0], this._viewMatrix[4], this._viewMatrix[8]);
  }
  get nearFar() {
    return this._nearFar;
  }
  get near() {
    return this._nearFar[0];
  }
  set near(t14) {
    this._nearFar[0] !== t14 && (this._nearFar[0] = t14, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_nearFar"));
  }
  get far() {
    return this._nearFar[1];
  }
  set far(t14) {
    this._nearFar[1] !== t14 && (this._nearFar[1] = t14, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_nearFar"));
  }
  get viewport() {
    return this._viewport;
  }
  set viewport(t14) {
    this.x = t14[0], this.y = t14[1], this.width = t14[2], this.height = t14[3];
  }
  get screenViewport() {
    if (1 === this.pixelRatio) return this._viewport;
    const t14 = m2(n4(), this._viewport, 1 / this.pixelRatio), i5 = this._get("screenViewport");
    return i5 && L(t14, i5) ? i5 : t14;
  }
  get screenPadding() {
    if (1 === this.pixelRatio) return this._padding;
    const t14 = m2(n4(), this._padding, 1 / this.pixelRatio), i5 = this._get("screenPadding");
    return i5 && L(t14, i5) ? i5 : t14;
  }
  get x() {
    return this._viewport[0];
  }
  set x(t14) {
    t14 += this._padding[t12.LEFT], this._viewport[0] !== t14 && (this._viewport[0] = t14, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get y() {
    return this._viewport[1];
  }
  set y(t14) {
    t14 += this._padding[t12.BOTTOM], this._viewport[1] !== t14 && (this._viewport[1] = t14, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get width() {
    return this._viewport[2];
  }
  set width(t14) {
    this._viewport[2] !== t14 && (this._viewport[2] = t14, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get height() {
    return this._viewport[3];
  }
  set height(t14) {
    this._viewport[3] !== t14 && (this._viewport[3] = t14, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get fullWidth() {
    return this._viewport[2] + this._padding[t12.RIGHT] + this._padding[t12.LEFT];
  }
  set fullWidth(t14) {
    this.width = t14 - (this._padding[t12.RIGHT] + this._padding[t12.LEFT]);
  }
  get fullHeight() {
    return this._viewport[3] + this._padding[t12.TOP] + this._padding[t12.BOTTOM];
  }
  set fullHeight(t14) {
    this.height = t14 - (this._padding[t12.TOP] + this._padding[t12.BOTTOM]);
  }
  get fullViewport() {
    return this._fullViewport[0] = this._viewport[0] - this._padding[t12.LEFT], this._fullViewport[1] = this._viewport[1] - this._padding[t12.BOTTOM], this._fullViewport[2] = this.fullWidth, this._fullViewport[3] = this.fullHeight, this._fullViewport;
  }
  get _aspect() {
    return this.width / this.height;
  }
  get padding() {
    return this._padding;
  }
  set padding(t14) {
    E(this._padding, t14) || (this._viewport[0] += t14[t12.LEFT] - this._padding[t12.LEFT], this._viewport[1] += t14[t12.BOTTOM] - this._padding[t12.BOTTOM], this._viewport[2] -= t14[t12.RIGHT] + t14[t12.LEFT] - (this._padding[t12.RIGHT] + this._padding[t12.LEFT]), this._viewport[3] -= t14[t12.TOP] + t14[t12.BOTTOM] - (this._padding[t12.TOP] + this._padding[t12.BOTTOM]), a2(this._padding, t14), this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_padding"), this.notifyChange("_viewport"));
  }
  get viewProjectionMatrix() {
    return this._viewProjectionDirty && (c(this._viewProjectionMatrix, this.projectionMatrix, this.viewMatrix), this._viewProjectionDirty = false), this._viewProjectionMatrix;
  }
  get projectionMatrix() {
    return this._projectionMatrixInternal;
  }
  get inverseProjectionMatrix() {
    return h(e3(), this.projectionMatrix) || this._get("inverseProjectionMatrix") || e3();
  }
  get fov() {
    return this._fov;
  }
  set fov(t14) {
    this._fov = t14, this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get fovX() {
    return n9(this._fov, this.width, this.height);
  }
  set fovX(t14) {
    this._fov = t10(t14, this.width, this.height), this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get fovY() {
    return r14(this._fov, this.width, this.height);
  }
  set fovY(t14) {
    this._fov = a7(t14, this.width, this.height), this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get distance() {
    return p(this.center, this.eye);
  }
  get frustum() {
    return this._recomputeFrustum(), this._frustum;
  }
  get viewInverseTransposeMatrix() {
    return (this._viewInverseTransposeMatrixDirty || this._viewDirty) && (h(this._viewInverseTransposeMatrix, this.viewMatrix), s2(this._viewInverseTransposeMatrix, this._viewInverseTransposeMatrix), this._viewInverseTransposeMatrixDirty = false), this._viewInverseTransposeMatrix;
  }
  depthNDCToWorld(t14) {
    const { near: i5, far: e14 } = this;
    return 2 * i5 * e14 / (e14 + i5 - t14 * (e14 - i5));
  }
  get perRenderPixelRatio() {
    return Math.tan(this.fovX / 2) / (this.width / 2);
  }
  get perScreenPixelRatio() {
    return this.perRenderPixelRatio * this.pixelRatio;
  }
  get aboveGround() {
    return null != this.relativeElevation && this.relativeElevation >= 0;
  }
  get _projectionMatrixInternal() {
    const t14 = this.width, i5 = this.height, e14 = this.near * Math.tan(this.fovY / 2) * 2, r17 = e14 * this._aspect, s12 = e14 / this.rows, o12 = r17 / this.columns, n11 = -r17 / 2 + this.column * o12, h6 = n11 + o12, a8 = -e14 / 2 + this.row * s12, p9 = a8 + s12, u6 = A(e3(), n11 * (1 + 2 * this._padding[t12.LEFT] / t14), h6 * (1 + 2 * this._padding[t12.RIGHT] / t14), a8 * (1 + 2 * this._padding[t12.BOTTOM] / i5), p9 * (1 + 2 * this._padding[t12.TOP] / i5), this.near, this.far), l7 = this._get("projectionMatrix");
    return l7 && C(l7, u6) ? l7 : u6;
  }
  copyFrom(t14) {
    s4(this._ray.origin, t14.eye), this.center = t14.center, this.up = t14.up, a2(this._viewport, t14.viewport), this.notifyChange("_viewport"), a2(this._padding, t14.padding), this.notifyChange("_padding"), r10(this._nearFar, t14.nearFar), this.notifyChange("_nearFar"), this._fov = t14.fov, this.row = t14.row, this.column = t14.column, this.rows = t14.rows, this.columns = t14.columns, this.relativeElevation = t14.relativeElevation;
    const i5 = t14;
    return this._viewDirty = i5._viewDirty, this._viewDirty || (n2(this._viewMatrix, t14.viewMatrix), this.notifyChange("_viewMatrix")), this._viewProjectionDirty = true, this._frustumDirty = i5._frustumDirty, this._frustumDirty || (N2(this._frustum, t14.frustum), this._frustumDirty = false), i5._viewInverseTransposeMatrixDirty ? this._viewInverseTransposeMatrixDirty = true : (n2(this._viewInverseTransposeMatrix, t14.viewInverseTransposeMatrix), this._viewInverseTransposeMatrixDirty = false), a2(this._fullViewport, t14.fullViewport), this.pixelRatio = t14.pixelRatio, this;
  }
  copyViewFrom(t14) {
    this.eye = t14.eye, this.center = t14.center, this.up = t14.up, this.fov = t14.fov;
  }
  clone() {
    return new $2().copyFrom(this);
  }
  equals(t14) {
    return H2(this.eye, t14.eye) && H2(this.center, t14.center) && H2(this.up, t14.up) && E(this._viewport, t14.viewport) && E(this._padding, t14.padding) && E3(this.nearFar, t14.nearFar) && this._fov === t14.fov && this.pixelRatio === t14.pixelRatio && this.relativeElevation === t14.relativeElevation && this.row === t14.row && this.column === t14.column && this.rows === t14.rows && this.columns === t14.columns;
  }
  almostEquals(t14) {
    const i5 = Math.max(1, 1 / this.pixelRatio, 1 / t14.pixelRatio);
    if (Math.abs(t14.fov - this._fov) >= 1e-3 || x(t14.screenPadding, this.screenPadding) >= i5 || x(this.screenViewport, t14.screenViewport) >= i5 || this.row !== t14.row || this.column !== t14.column || this.rows !== t14.rows || this.columns !== t14.columns) return false;
    R(st, t14.eye, t14.center), R(ot, this.eye, this.center);
    const e14 = P(st, ot), r17 = Z(st), s12 = Z(ot), o12 = 5e-4;
    return e14 * e14 >= (1 - 1e-10) * r17 * s12 && X2(t14.eye, this.eye) < Math.max(r17, s12) * o12 * o12;
  }
  computeRenderPixelSizeAt(t14) {
    return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t14));
  }
  computeRenderPixelSizeAtDist(t14) {
    return t14 * this.perRenderPixelRatio;
  }
  computeScreenPixelSizeAt(t14) {
    return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t14));
  }
  _viewDirectionDistance(t14) {
    return Math.abs(a3(this.viewForward, c2(st, t14, this.eye)));
  }
  computeScreenPixelSizeAtDist(t14) {
    return t14 * this.perScreenPixelRatio;
  }
  computeDistanceFromRadius(t14, i5) {
    return t14 / Math.tan(Math.min(this.fovX, this.fovY) / (2 * (i5 || 1)));
  }
  getScreenCenter(t14 = f()) {
    return t14[0] = (this.padding[t12.LEFT] + this.width / 2) / this.pixelRatio, t14[1] = (this.padding[t12.TOP] + this.height / 2) / this.pixelRatio, t14;
  }
  getRenderCenter(t14, i5 = 0.5, e14 = 0.5) {
    return t14[0] = this.padding[t12.LEFT] + this.width * i5, t14[1] = this.padding[t12.BOTTOM] + this.height * e14, t14[2] = 0.5, t14;
  }
  setGLViewport(t14) {
    const i5 = this.viewport, e14 = this.padding;
    t14.setViewport(i5[0] - e14[3], i5[1] - e14[2], i5[2] + e14[1] + e14[3], i5[3] + e14[0] + e14[2]);
  }
  applyProjection(t14, i5) {
    t14 !== et && s4(et, t14), et[3] = 1, z(et, et, this.projectionMatrix);
    const e14 = Math.abs(et[3]);
    g(et, et, 1 / e14);
    const s12 = this.fullViewport;
    i5[0] = o(0, s12[0] + s12[2], 0.5 + 0.5 * et[0]), i5[1] = o(0, s12[1] + s12[3], 0.5 + 0.5 * et[1]), i5[2] = 0.5 * (et[2] + 1), i5[3] = e14;
  }
  unapplyProjection(t14, i5) {
    const e14 = this.fullViewport;
    et[0] = (t14[0] / (e14[0] + e14[2]) * 2 - 1) * t14[3], et[1] = (t14[1] / (e14[1] + e14[3]) * 2 - 1) * t14[3], et[2] = (2 * t14[2] - 1) * t14[3], et[3] = t14[3], null != this.inverseProjectionMatrix && (z(et, et, this.inverseProjectionMatrix), i5[0] = et[0], i5[1] = et[1], i5[2] = et[2]);
  }
  projectToScreen(t14, i5) {
    return this.projectToRenderScreen(t14, nt), this.renderToScreen(nt, i5), i5;
  }
  projectToRenderScreen(t14, i5) {
    if (et[0] = t14[0], et[1] = t14[1], et[2] = t14[2], et[3] = 1, z(et, et, this.viewProjectionMatrix), 0 === et[3]) return null;
    const e14 = et;
    g(e14, e14, 1 / Math.abs(et[3]));
    const s12 = this.fullViewport, o12 = o(0, s12[0] + s12[2], 0.5 + 0.5 * e14[0]), n11 = o(0, s12[1] + s12[3], 0.5 + 0.5 * e14[1]);
    return "x" in i5 ? (i5.x = o12, i5.y = n11) : (i5[0] = o12, i5[1] = n11, i5.length > 2 && (i5[2] = 0.5 * (e14[2] + 1))), i5;
  }
  unprojectFromScreen(t14, i5) {
    return this.unprojectFromRenderScreen(this.screenToRender(t14, nt), i5);
  }
  unprojectFromRenderScreen(t14, i5) {
    if (c(rt, this.projectionMatrix, this.viewMatrix), !h(rt, rt)) return null;
    const e14 = this.fullViewport;
    return et[0] = 2 * (t14[0] - e14[0]) / e14[2] - 1, et[1] = 2 * (t14[1] - e14[1]) / e14[3] - 1, et[2] = 2 * t14[2] - 1, et[3] = 1, z(et, et, rt), 0 === et[3] ? null : (i5[0] = et[0] / et[3], i5[1] = et[1] / et[3], i5[2] = et[2] / et[3], i5);
  }
  constrainWindowSize(t14, i5, e14, r17) {
    const s12 = t14 * this.pixelRatio, o12 = i5 * this.pixelRatio, n11 = Math.max(s12 - e14 / 2, 0), h6 = Math.max(this.fullHeight - o12 - r17 / 2, 0), a8 = -Math.min(s12 - e14 / 2, 0), p9 = -Math.min(this.fullHeight - o12 - r17 / 2, 0), u6 = e14 - a8 - -Math.min(this.fullWidth - s12 - e14 / 2, 0), l7 = r17 - p9 - -Math.min(o12 - r17 / 2, 0);
    return [Math.round(n11), Math.round(h6), Math.round(u6), Math.round(l7)];
  }
  computeUp(t14) {
    t14 === l.Global ? this._computeUpGlobal() : this._computeUpLocal();
  }
  screenToRender(t14, i5) {
    const e14 = t14[0] * this.pixelRatio, r17 = this.fullHeight - t14[1] * this.pixelRatio;
    return i5[0] = e14, i5[1] = r17, i5;
  }
  renderToScreen(t14, i5) {
    const e14 = t14[0] / this.pixelRatio, r17 = (this.fullHeight - t14[1]) / this.pixelRatio;
    i5[0] = e14, i5[1] = r17;
  }
  _computeUpGlobal() {
    c2(st, this.center, this.eye);
    const t14 = r7(this.center);
    t14 < 1 ? (o4(this._up, 0, 0, 1), this._markViewDirty(), this.notifyChange("_up")) : Math.abs(P(st, this.center)) > 0.9999 * r7(st) * t14 || (_(this._up, st, this.center), _(this._up, this._up, st), A2(this._up, this._up), this.notifyChange("_up"), this._markViewDirty());
  }
  _computeUpLocal() {
    K(st, this.eye, this.center), Math.abs(st[2]) <= 0.9999 && (g(st, st, st[2]), o4(this._up, -st[0], -st[1], 1 - st[2]), A2(this._up, this._up), this.notifyChange("_up"), this._markViewDirty());
  }
  _compareAndSetView(t14, i5, r17 = "") {
    "number" == typeof t14[0] && isFinite(t14[0]) && "number" == typeof t14[1] && isFinite(t14[1]) && "number" == typeof t14[2] && isFinite(t14[2]) ? H2(t14, i5) || (s4(i5, t14), this._markViewDirty(), r17.length && this.notifyChange(r17)) : i.getLogger("esri.views.3d.webgl-engine.lib.RenderCamera").warn("RenderCamera vector contains invalid number, ignoring value");
  }
  _markViewDirty() {
    this._viewDirty = true, this._frustumDirty = true, this._viewProjectionDirty = true;
  }
  _recomputeFrustum() {
    this._frustumDirty && (L2(this.viewMatrix, this.projectionMatrix, this._frustum), this._frustumDirty = false);
  }
  _ensureViewClean() {
    this._viewDirty && (X(this._viewMatrix, this.eye, this.center, this.up), this.notifyChange("_viewMatrix"), this._viewDirty = false, this._viewInverseTransposeMatrixDirty = true);
  }
};
r([m()], tt.prototype, "_viewport", void 0), r([m()], tt.prototype, "_padding", void 0), r([m()], tt.prototype, "_fov", void 0), r([m()], tt.prototype, "_nearFar", void 0), r([m()], tt.prototype, "_viewDirty", void 0), r([m()], tt.prototype, "_viewMatrix", void 0), r([m()], tt.prototype, "_pixelRatio", void 0), r([m()], tt.prototype, "pixelRatio", null), r([m()], tt.prototype, "row", void 0), r([m()], tt.prototype, "column", void 0), r([m()], tt.prototype, "_rows", void 0), r([m()], tt.prototype, "rows", null), r([m()], tt.prototype, "_columns", void 0), r([m()], tt.prototype, "columns", null), r([m()], tt.prototype, "eye", null), r([m()], tt.prototype, "center", null), r([m()], tt.prototype, "_center", void 0), r([m()], tt.prototype, "up", null), r([m()], tt.prototype, "_up", void 0), r([m()], tt.prototype, "viewMatrix", null), r([m({ readOnly: true })], tt.prototype, "viewForward", null), r([m({ readOnly: true })], tt.prototype, "viewUp", null), r([m({ readOnly: true })], tt.prototype, "viewRight", null), r([m({ readOnly: true })], tt.prototype, "nearFar", null), r([m()], tt.prototype, "near", null), r([m()], tt.prototype, "far", null), r([m()], tt.prototype, "viewport", null), r([m({ readOnly: true })], tt.prototype, "screenViewport", null), r([m({ readOnly: true })], tt.prototype, "screenPadding", null), r([m()], tt.prototype, "x", null), r([m()], tt.prototype, "y", null), r([m()], tt.prototype, "width", null), r([m()], tt.prototype, "height", null), r([m()], tt.prototype, "fullWidth", null), r([m()], tt.prototype, "fullHeight", null), r([m({ readOnly: true })], tt.prototype, "_aspect", null), r([m()], tt.prototype, "padding", null), r([m({ readOnly: true })], tt.prototype, "projectionMatrix", null), r([m({ readOnly: true })], tt.prototype, "inverseProjectionMatrix", null), r([m()], tt.prototype, "fov", null), r([m()], tt.prototype, "fovX", null), r([m()], tt.prototype, "fovY", null), r([m()], tt.prototype, "viewInverseTransposeMatrix", null), r([m({ readOnly: true })], tt.prototype, "_projectionMatrixInternal", null), r([m()], tt.prototype, "relativeElevation", void 0), tt = $2 = r([a("esri.views.3d.webgl.RenderCamera")], tt);
var it = tt;
var et = n4();
var rt = e3();
var st = n();
var ot = n();
var nt = y();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/LocalOriginFactory.js
var s11 = class {
  constructor(r17, s12) {
    this.vec3 = r17, this.id = s12;
  }
};
function t13(t14, o12, c6, e14) {
  return new s11(r5(t14, o12, c6), e14);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/testUtils.js
var n10 = { stableRendering: false };
var e13 = { rootOrigin: null };

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GridLocalOriginFactory.js
var l6 = class {
  constructor(r17) {
    this._originSR = r17, this._rootOriginId = "root/" + e(), this._origins = /* @__PURE__ */ new Map(), this._objects = /* @__PURE__ */ new Map(), this._gridSize = 5e5;
  }
  getOrigin(t14) {
    const i5 = this._origins.get(this._rootOriginId);
    if (null == i5) {
      const r17 = e13.rootOrigin;
      if (null != r17) return this._origins.set(this._rootOriginId, t13(r17[0], r17[1], r17[2], this._rootOriginId)), this.getOrigin(t14);
      const i6 = t13(t14[0] + Math.random() - 0.5, t14[1] + Math.random() - 0.5, t14[2] + Math.random() - 0.5, this._rootOriginId);
      return this._origins.set(this._rootOriginId, i6), i6;
    }
    const o12 = this._gridSize, s12 = Math.round(t14[0] / o12), e14 = Math.round(t14[1] / o12), n11 = Math.round(t14[2] / o12), h6 = `${s12}/${e14}/${n11}`;
    let c6 = this._origins.get(h6);
    const g5 = 0.5 * o12;
    if (c2(_3, t14, i5.vec3), _3[0] = Math.abs(_3[0]), _3[1] = Math.abs(_3[1]), _3[2] = Math.abs(_3[2]), _3[0] < g5 && _3[1] < g5 && _3[2] < g5) {
      if (c6) {
        const i6 = Math.max(..._3);
        c2(_3, t14, c6.vec3), _3[0] = Math.abs(_3[0]), _3[1] = Math.abs(_3[1]), _3[2] = Math.abs(_3[2]);
        if (Math.max(..._3) < i6) return c6;
      }
      return i5;
    }
    return c6 || (c6 = t13(s12 * o12, e14 * o12, n11 * o12, h6), this._origins.set(h6, c6)), c6;
  }
  _drawOriginBox(t14, r17 = r6(1, 1, 0, 1)) {
    const i5 = window.view, a8 = i5.stage, m9 = r17.toString();
    if (!this._objects.has(m9)) {
      this._material = new q({ width: 2, color: r17 });
      const t15 = new l5(a8, { pickable: false }), i6 = new A4({ castShadow: false });
      t15.add(i6), this._objects.set(m9, i6);
    }
    const l7 = this._objects.get(m9), _4 = [0, 1, 5, 4, 0, 2, 1, 7, 6, 2, 0, 1, 3, 7, 5, 4, 6, 2, 0], p9 = _4.length, j3 = new Array(3 * p9), b5 = new Array(), u6 = 0.5 * this._gridSize;
    for (let o12 = 0; o12 < p9; o12++) j3[3 * o12] = t14[0] + (1 & _4[o12] ? u6 : -u6), j3[3 * o12 + 1] = t14[1] + (2 & _4[o12] ? u6 : -u6), j3[3 * o12 + 2] = t14[2] + (4 & _4[o12] ? u6 : -u6), o12 > 0 && b5.push(o12 - 1, o12);
    o3(j3, this._originSR, 0, j3, i5.renderSpatialReference, 0, p9);
    const M4 = new p3(this._material, [[e4.POSITION, new t3(j3, b5, 3, true)]], null, n6.Line);
    l7.addGeometry(M4);
  }
  get test() {
  }
};
var _3 = n();

export {
  e11 as e,
  a4 as a,
  t8 as t,
  C3 as C,
  l3 as l,
  A4 as A,
  l5 as l2,
  t13 as t2,
  it,
  n10 as n,
  q,
  l6 as l3,
  r13 as r,
  a5 as a2,
  u5 as u,
  c4 as c,
  f3 as f,
  m7 as m,
  d,
  g4 as g,
  p7 as p,
  E7 as E,
  R3 as R,
  b4 as b,
  a6 as a3,
  s10 as s,
  l4,
  d2,
  f4 as f2,
  o11 as o
};
//# sourceMappingURL=chunk-4KOJY6ZH.js.map
