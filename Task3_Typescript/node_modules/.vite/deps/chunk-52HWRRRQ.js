import {
  a as a3,
  c as c3,
  i as i2
} from "./chunk-VNTEV3V4.js";
import {
  h as h2,
  v
} from "./chunk-OGOQOMMV.js";
import {
  f as f2,
  p,
  z
} from "./chunk-O5TPFXRT.js";
import {
  _,
  c as c2,
  y
} from "./chunk-Q6XRAGMA.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import {
  r as r2
} from "./chunk-YFPGM5UE.js";
import {
  c,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2
} from "./chunk-JUAD7TJ6.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  i2 as i
} from "./chunk-XWG6QGFK.js";
import {
  a
} from "./chunk-GWNLQRNM.js";
import {
  h
} from "./chunk-FXKORAMT.js";

// node_modules/@arcgis/core/geometry/Multipoint.js
var h3;
function l(t2) {
  return (s2, e) => null == s2 ? e : null == e ? s2 : t2(s2, e);
}
function c4(t2) {
  return t2 && ("esri.geometry.SpatialReference" === t2.declaredClass || null != t2.wkid);
}
var m2 = h3 = class extends c2 {
  constructor(...t2) {
    super(...t2), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t2, s2) {
    if (!t2 && !s2) return {};
    const e = {};
    Array.isArray(t2) ? (e.points = t2, e.spatialReference = s2) : c4(t2) ? e.spatialReference = t2 : (t2.points && (e.points = t2.points), t2.spatialReference && (e.spatialReference = t2.spatialReference), t2.hasZ && (e.hasZ = t2.hasZ), t2.hasM && (e.hasM = t2.hasM));
    const i4 = e.points?.[0];
    return i4 && (void 0 === e.hasZ && void 0 === e.hasM ? (e.hasZ = i4.length > 2, e.hasM = false) : void 0 === e.hasZ ? e.hasZ = i4.length > 3 : void 0 === e.hasM && (e.hasM = i4.length > 3)), e;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t2 = this.points;
    if (!t2.length) return null;
    const s2 = new z(), e = this.hasZ, i4 = this.hasM, r4 = e ? 3 : 2, n2 = t2[0], a4 = l(Math.min), p2 = l(Math.max);
    let h5, c6, m3, u2, [f4, y2] = n2, [d, g] = n2;
    for (let o2 = 0, l3 = t2.length; o2 < l3; o2++) {
      const s3 = t2[o2], [n3, l4] = s3;
      if (f4 = a4(f4, n3), y2 = a4(y2, l4), d = p2(d, n3), g = p2(g, l4), e && s3.length > 2) {
        const t3 = s3[2];
        h5 = a4(h5, t3), m3 = p2(m3, t3);
      }
      if (i4 && s3.length > r4) {
        const t3 = s3[r4];
        c6 = a4(c6, t3), u2 = p2(u2, t3);
      }
    }
    return s2.xmin = f4, s2.ymin = y2, s2.xmax = d, s2.ymax = g, s2.spatialReference = this.spatialReference, e ? (s2.zmin = h5, s2.zmax = m3) : (s2.zmin = void 0, s2.zmax = void 0), i4 ? (s2.mmin = c6, s2.mmax = u2) : (s2.mmin = void 0, s2.mmax = void 0), s2;
  }
  writePoints(t2, e) {
    e.points = a(this.points);
  }
  addPoint(t2) {
    return h2(this, t2), Array.isArray(t2) ? this.points.push(t2) : this.points.push(t2.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t2 = { points: a(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t2.hasZ = true), this.hasM && (t2.hasM = true), new h3(t2);
  }
  getPoint(t2) {
    if (!this._validateInputs(t2)) return null;
    const s2 = this.points[t2], e = { x: s2[0], y: s2[1], spatialReference: this.spatialReference };
    let i4 = 2;
    return this.hasZ && (e.z = s2[2], i4 = 3), this.hasM && (e.m = s2[i4]), new _(e);
  }
  removePoint(t2) {
    if (!this._validateInputs(t2)) return null;
    const s2 = new _(this.points.splice(t2, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s2;
  }
  setPoint(t2, s2) {
    return this._validateInputs(t2) ? (h2(this, s2), Array.isArray(s2) || (s2 = s2.toArray()), this.points[t2] = s2, this.notifyChange("points"), this) : this;
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
  _validateInputs(t2) {
    return null != t2 && t2 >= 0 && t2 < this.points.length;
  }
};
r([m({ readOnly: true })], m2.prototype, "cache", null), r([m()], m2.prototype, "extent", null), r([m({ type: [[Number]], json: { write: { isRequired: true } } })], m2.prototype, "points", void 0), r([r2("points")], m2.prototype, "writePoints", null), m2 = h3 = r([a2("esri.geometry.Multipoint")], m2), m2.prototype.toJSON.isDefaultToJSON = true;

// node_modules/@arcgis/core/geometry/geometryCursorCollectUtils.js
function t(t2) {
  const n2 = [];
  for (t2.reset(); t2.nextPath(); ) {
    const e = [];
    for (; t2.nextPoint(); ) e.push([t2.x, t2.y]);
    n2.push(e);
  }
  return t2.reset(), n2;
}
function n(t2) {
  const n2 = [];
  for (; t2.nextPoint(); ) n2.push([t2.x, t2.y]);
  return t2.seekPathStart(), n2;
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function r3(t2) {
  return t2 ? t2.hasZ ? [t2.xmax - t2.xmin / 2, t2.ymax - t2.ymin / 2, t2.zmax - t2.zmin / 2] : [t2.xmax - t2.xmin / 2, t2.ymax - t2.ymin / 2] : null;
}
function l2(t2) {
  return t2 ? o(t2.rings, t2.hasZ ?? false) : null;
}
function o(t2, n2) {
  if (!t2?.length) return null;
  const e = [], r4 = [], l3 = n2 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o2 = 0, i4 = t2.length; o2 < i4; o2++) {
    const e2 = u(t2[o2], n2, l3);
    e2 && r4.push(e2);
  }
  if (r4.sort((t3, e2) => {
    let r5 = t3[2] - e2[2];
    return 0 === r5 && n2 && (r5 = t3[4] - e2[4]), r5;
  }), r4.length && (e[0] = r4[0][0], e[1] = r4[0][1], n2 && (e[2] = r4[0][3]), (e[0] < l3[0] || e[0] > l3[1] || e[1] < l3[2] || e[1] > l3[3] || n2 && (e[2] < l3[4] || e[2] > l3[5])) && (e.length = 0)), !e.length) {
    const r5 = t2[0] && t2[0].length ? s(t2[0], n2) : null;
    if (!r5) return null;
    e[0] = r5[0], e[1] = r5[1], n2 && r5.length > 2 && (e[2] = r5[2]);
  }
  return e;
}
function u(t2, n2, e) {
  let r4 = 0, l3 = 0, o2 = 0, u2 = 0, i4 = 0;
  const s2 = t2.length ? t2[0][0] : 0, I2 = t2.length ? t2[0][1] : 0, h5 = t2.length && n2 ? t2[0][2] : 0;
  for (let f4 = 0; f4 < t2.length; f4++) {
    const c7 = t2[f4], N2 = t2[(f4 + 1) % t2.length], [x3, g, a4] = c7, m3 = x3 - s2, P2 = g - I2, [T, y2, E] = N2, S = T - s2, p2 = y2 - I2, z2 = m3 * p2 - S * P2;
    if (u2 += z2, r4 += (m3 + S) * z2, l3 += (P2 + p2) * z2, n2 && c7.length > 2 && N2.length > 2) {
      const t3 = a4 - h5, n3 = E - h5, e2 = m3 * n3 - S * t3;
      o2 += (t3 + n3) * e2, i4 += e2;
    }
    x3 < e[0] && (e[0] = x3), x3 > e[1] && (e[1] = x3), g < e[2] && (e[2] = g), g > e[3] && (e[3] = g), n2 && (a4 < e[4] && (e[4] = a4), a4 > e[5] && (e[5] = a4));
  }
  if (u2 > 0 && (u2 *= -1), i4 > 0 && (i4 *= -1), !u2) return null;
  u2 *= 0.5, i4 *= 0.5;
  const c6 = [r4 / (6 * u2) + s2, l3 / (6 * u2) + I2, u2];
  return n2 && (e[4] === e[5] || 0 === i4 ? (c6[3] = (e[4] + e[5]) / 2, c6[4] = 0) : (c6[3] = o2 / (6 * i4) + h5, c6[4] = i4)), c6;
}
function i3(t2, n2) {
  let e = 0, r4 = 0, l3 = 0;
  t2.nextPoint();
  const o2 = t2.pathSize ? t2.x : 0, u2 = t2.pathSize ? t2.y : 0;
  for (let i4 = 0; i4 < t2.pathSize; i4++) {
    t2.seekInPath(i4);
    const s2 = [t2.x, t2.y];
    t2.seekInPath((i4 + 1) % t2.pathSize);
    const I2 = [t2.x, t2.y], [h5, c6] = s2, f4 = h5 - o2, N2 = c6 - u2, [x3, g] = I2, a4 = x3 - o2, m3 = g - u2, P2 = f4 * m3 - a4 * N2;
    l3 += P2, e += (f4 + a4) * P2, r4 += (N2 + m3) * P2, h5 < n2[0] && (n2[0] = h5), h5 > n2[1] && (n2[1] = h5), c6 < n2[2] && (n2[2] = c6), c6 > n2[3] && (n2[3] = c6);
  }
  if (l3 > 0 && (l3 *= -1), !l3) return null;
  l3 *= 0.5;
  return [e / (6 * l3) + o2, r4 / (6 * l3) + u2, l3];
}
function s(t2, r4) {
  const l3 = r4 ? [0, 0, 0] : [0, 0], o2 = r4 ? [0, 0, 0] : [0, 0];
  let u2 = 0, i4 = 0, s2 = 0, I2 = 0;
  for (let h5 = 0, c6 = t2.length; h5 < c6 - 1; h5++) {
    const c7 = t2[h5], f4 = t2[h5 + 1];
    if (c7 && f4) {
      l3[0] = c7[0], l3[1] = c7[1], o2[0] = f4[0], o2[1] = f4[1], r4 && c7.length > 2 && f4.length > 2 && (l3[2] = c7[2], o2[2] = f4[2]);
      const t3 = i2(l3, o2);
      if (t3) {
        u2 += t3;
        const e = c3(c7, f4);
        i4 += t3 * e[0], s2 += t3 * e[1], r4 && e.length > 2 && (I2 += t3 * e[2]);
      }
    }
  }
  return u2 > 0 ? r4 ? [i4 / u2, s2 / u2, I2 / u2] : [i4 / u2, s2 / u2] : t2.length ? t2[0] : null;
}
function I(n2) {
  const { hasZ: e, totalSize: r4 } = n2;
  if (0 === r4) return null;
  const l3 = [], o2 = [], i4 = e ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  for (n2.reset(); n2.nextPath(); ) {
    const e2 = u(n(n2), n2.hasZ, i4);
    e2 && o2.push(e2);
  }
  if (o2.sort((t2, n3) => {
    let r5 = t2[2] - n3[2];
    return 0 === r5 && e && (r5 = t2[4] - n3[4]), r5;
  }), o2.length && (l3[0] = o2[0][0], l3[1] = o2[0][1], e && (l3[2] = o2[0][3]), (l3[0] < i4[0] || l3[0] > i4[1] || l3[1] < i4[2] || l3[1] > i4[3] || e && (l3[2] < i4[4] || l3[2] > i4[5])) && (l3.length = 0)), !l3.length) {
    n2.reset(), n2.nextPath();
    const t2 = n2.pathSize ? h4(n2) : null;
    if (!t2) return null;
    l3[0] = t2[0], l3[1] = t2[1], e && t2.length > 2 && (l3[2] = t2[2]);
  }
  return l3;
}
function h4(t2) {
  const { hasZ: r4 } = t2, l3 = r4 ? [0, 0, 0] : [0, 0], o2 = r4 ? [0, 0, 0] : [0, 0];
  let u2 = 0, i4 = 0, s2 = 0, I2 = 0;
  if (t2.nextPoint()) {
    let h5 = t2.x, c6 = t2.y, f4 = t2.z;
    for (; t2.nextPoint(); ) {
      const N2 = t2.x, x3 = t2.y, g = t2.z;
      l3[0] = h5, l3[1] = c6, o2[0] = N2, o2[1] = x3, r4 && (l3[2] = f4, o2[2] = g);
      const a4 = i2(l3, o2);
      if (a4) {
        u2 += a4;
        const t3 = c3(l3, o2);
        i4 += a4 * t3[0], s2 += a4 * t3[1], r4 && t3.length > 2 && (I2 += a4 * t3[2]);
      }
      h5 = N2, c6 = x3, f4 = g;
    }
  }
  return u2 > 0 ? r4 ? [i4 / u2, s2 / u2, I2 / u2] : [i4 / u2, s2 / u2] : t2.pathSize ? (t2.seekPathStart(), t2.nextPoint(), [t2.x, t2.y]) : null;
}
var c5 = 1e-6;
function f3(t2) {
  let n2 = 0;
  for (t2.reset(); t2.nextPath(); ) n2 += t2.getCurrentRingArea();
  if (n2 < c5) {
    const n3 = I(t2);
    return n3 ? [n3[0], n3[1]] : null;
  }
  const e = [0, 0];
  if (t2.reset(), !t2.nextPath() || !t2.nextPoint()) return null;
  const r4 = [t2.x, t2.y];
  for (t2.reset(); t2.nextPath(); ) x(e, r4, t2);
  return e[0] *= 1 / n2, e[1] *= 1 / n2, e[0] += r4[0], e[1] += r4[1], e;
}
var N = 1 / 3;
function x(t2, n2, e) {
  if (!t2 || !e || e.pathSize < 3) return null;
  e.nextPoint();
  const r4 = e.x, l3 = e.y;
  e.nextPoint();
  let o2, u2 = e.x - r4, i4 = e.y - l3, s2 = 0, I2 = 0;
  for (; e.nextPoint(); ) s2 = e.x - r4, I2 = e.y - l3, o2 = 0.5 * N * (s2 * i4 - I2 * u2), t2[0] += o2 * (u2 + s2), t2[1] += o2 * (i4 + I2), u2 = s2, i4 = I2;
  const h5 = e.getCurrentRingArea(), c6 = [r4, l3];
  return c6[0] -= n2[0], c6[1] -= n2[1], c6[0] *= h5, c6[1] *= h5, t2[0] += c6[0], t2[1] += c6[1], t2;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var w;
function v2(t2) {
  return !Array.isArray(t2[0]);
}
function j(t2) {
  return "number" == typeof t2[0]?.[0];
}
function x2(t2) {
  if (!t2) return;
  let { rings: e, hasM: r4, hasZ: s2, spatialReference: i4 } = t2;
  switch (e ??= [], j(e) && (e = [e]), e[0]?.[0]?.length) {
    case 4:
      s2 ??= true, r4 ??= true;
      break;
    case 3:
      s2 ??= true !== r4, r4 ??= !s2;
      break;
    default:
      s2 ??= false, r4 ??= false;
  }
  return i4 ??= f.WGS84, { ...t2, hasM: r4, hasZ: s2, rings: e, spatialReference: i4 };
}
var P = w = class extends c2 {
  static fromExtent(t2) {
    const e = t2.clone().normalize(), { spatialReference: r4 } = t2;
    let s2 = false, i4 = false;
    for (const o2 of e) o2.hasZ && (s2 = true), o2.hasM && (i4 = true);
    const n2 = { rings: e.map((t3) => {
      const e2 = [[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]];
      if (s2 && t3.hasZ) {
        const r5 = t3.zmin + 0.5 * (t3.zmax - t3.zmin);
        for (let t4 = 0; t4 < e2.length; t4++) e2[t4].push(r5);
      }
      if (i4 && t3.hasM) {
        const r5 = t3.mmin + 0.5 * (t3.mmax - t3.mmin);
        for (let t4 = 0; t4 < e2.length; t4++) e2[t4].push(r5);
      }
      return e2;
    }), spatialReference: r4 };
    return s2 && (n2.hasZ = true), i4 && (n2.hasM = true), new w(n2);
  }
  constructor(t2) {
    super(x2(t2)), this.curveRings = void 0, this.rings = [], this.type = "polygon";
  }
  get cache() {
    return this.commitProperty("curveRings"), this.commitProperty("hasM"), this.commitProperty("hasZ"), this.commitProperty("rings"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t2 = l2(this);
    if (!t2 || isNaN(t2[0]) || isNaN(t2[1]) || this.hasZ && isNaN(t2[2])) return null;
    const e = new _();
    return e.x = t2[0], e.y = t2[1], e.spatialReference = this.spatialReference, this.hasZ && (e.z = t2[2]), e;
  }
  writeCurveRings(t2, e) {
    e.curveRings = a(t2);
  }
  get extent() {
    const t2 = v(this), { spatialReference: e } = this;
    return t2 ? new z({ ...t2, spatialReference: e }) : null;
  }
  get isSelfIntersecting() {
    return c(i.getLogger(this), "isSelfIntersecting", { replacement: "Please use simplifyOperator.isSimple() instead.", version: "4.33", warnOnce: true }), p(this.rings);
  }
  writeRings(t2, e) {
    e.rings = a(this.rings);
  }
  addRing(t2) {
    if (!t2) return;
    const e = this.rings, r4 = e.length;
    if (v2(t2)) {
      const s2 = [];
      for (let e2 = 0, r5 = t2.length; e2 < r5; e2++) s2[e2] = t2[e2].toArray();
      e[r4] = s2;
    } else e[r4] = t2.slice();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t2 = new w();
    return t2.spatialReference = this.spatialReference, t2.rings = a(this.rings), t2.curveRings = a(this.curveRings), t2.hasZ = this.hasZ, t2.hasM = this.hasM, t2;
  }
  equals(t2) {
    if (this === t2) return true;
    if (null == t2) return false;
    const r4 = this.spatialReference, s2 = t2.spatialReference;
    if (null != r4 != (null != s2)) return false;
    if (null != r4 && null != s2 && !r4.equals(s2)) return false;
    if (this.rings.length !== t2.rings.length) return false;
    const i4 = ([t3, e, r5, s3], [i5, n2, o2, a4]) => t3 === i5 && e === n2 && (null == r5 && null == o2 || r5 === o2) && (null == s3 && null == a4 || s3 === a4);
    for (let n2 = 0; n2 < this.rings.length; n2++) {
      const r5 = this.rings[n2], s3 = t2.rings[n2];
      if (!h(r5, s3, i4)) return false;
    }
    return true;
  }
  contains(t2) {
    if (!t2) return false;
    const e = y(t2, this.spatialReference);
    return f2(this, null != e ? e : t2);
  }
  isClockwise(t2) {
    const e = v2(t2) ? t2.map((t3) => this.hasZ ? this.hasM ? [t3.x, t3.y, t3.z, t3.m] : [t3.x, t3.y, t3.z] : [t3.x, t3.y]) : t2;
    return a3(e);
  }
  getPoint(t2, e) {
    if (!this._validateInputs(t2, e)) return null;
    const r4 = this.rings[t2][e], s2 = this.hasZ, i4 = this.hasM;
    return s2 && !i4 ? new _(r4[0], r4[1], r4[2], void 0, this.spatialReference) : i4 && !s2 ? new _(r4[0], r4[1], void 0, r4[2], this.spatialReference) : s2 && i4 ? new _(r4[0], r4[1], r4[2], r4[3], this.spatialReference) : new _(r4[0], r4[1], this.spatialReference);
  }
  insertPoint(t2, e, r4) {
    return this._validateInputs(t2, e, true) ? (h2(this, r4), Array.isArray(r4) || (r4 = r4.toArray()), this.rings[t2].splice(e, 0, r4), this.notifyChange("rings"), this) : this;
  }
  removePoint(t2, e) {
    if (!this._validateInputs(t2, e)) return null;
    const r4 = new _(this.rings[t2].splice(e, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), r4;
  }
  removeRing(t2) {
    if (!this._validateInputs(t2, null)) return null;
    const e = this.rings.splice(t2, 1)[0], r4 = this.spatialReference, s2 = e.map((t3) => new _(t3, r4));
    return this.notifyChange("rings"), s2;
  }
  setPoint(t2, e, r4) {
    return this._validateInputs(t2, e) ? (h2(this, r4), Array.isArray(r4) || (r4 = r4.toArray()), this.rings[t2][e] = r4, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t2, e, r4 = false) {
    if (null == t2 || t2 < 0 || t2 >= this.rings.length) return false;
    if (null != e) {
      const s2 = this.rings[t2];
      if (r4 && (e < 0 || e > s2.length)) return false;
      if (!r4 && (e < 0 || e >= s2.length)) return false;
    }
    return true;
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
};
r([m({ readOnly: true })], P.prototype, "cache", null), r([m({ readOnly: true })], P.prototype, "centroid", null), r([m({ json: { write: true, origins: { "portal-item": { write: false }, "web-map": { write: false }, "web-scene": { write: false } } } })], P.prototype, "curveRings", void 0), r([r2("curveRings")], P.prototype, "writeCurveRings", null), r([m({ readOnly: true })], P.prototype, "extent", null), r([m({ readOnly: true })], P.prototype, "isSelfIntersecting", null), r([m({ type: [[[Number]]], json: { write: { isRequired: true } } })], P.prototype, "rings", void 0), r([r2("rings")], P.prototype, "writeRings", null), P = w = r([a2("esri.geometry.Polygon")], P), P.prototype.toJSON.isDefaultToJSON = true;

export {
  m2 as m,
  t,
  n,
  r3 as r,
  l2 as l,
  o,
  i3 as i,
  I,
  f3 as f,
  P
};
//# sourceMappingURL=chunk-52HWRRRQ.js.map
