{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/LaserlinePath.glsl.js"],
  "sourcesContent": ["/*\r\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\r\nSee https://js.arcgis.com/4.33/esri/copyright.txt for details.\r\n*/\r\nimport{translate as e}from\"../core/libs/gl-matrix-2/math/mat4.js\";import{create as t}from\"../core/libs/gl-matrix-2/factories/mat4f64.js\";import{set as o}from\"../core/libs/gl-matrix-2/math/vec2.js\";import{create as r}from\"../core/libs/gl-matrix-2/factories/vec2f64.js\";import{Laserline as a}from\"../views/3d/webgl-engine/core/shaderLibrary/Laserline.glsl.js\";import{Float2BindUniform as i}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{FloatBindUniform as n}from\"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";import{FloatPassUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{If as l,glsl as d}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{Matrix4BindUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";import{Matrix4PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{VertexAttribute as v}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{ShaderBuilder as p}from\"../views/webgl/ShaderBuilder.js\";function w(t){const r=new p;r.include(a,t);const{vertex:w,fragment:u}=r;w.uniforms.add(new m(\"modelView\",((t,{camera:o})=>e(f,o.viewMatrix,t.origin))),new c(\"proj\",(({camera:e})=>e.projectionMatrix)),new s(\"glowWidth\",((e,{camera:t})=>e.glowWidth*t.pixelRatio)),new i(\"pixelToNDC\",(({camera:e})=>o(g,2/e.fullViewport[2],2/e.fullViewport[3])))),r.attributes.add(v.START,\"vec3\"),r.attributes.add(v.END,\"vec3\"),t.spherical&&(r.attributes.add(v.START_UP,\"vec3\"),r.attributes.add(v.END_UP,\"vec3\")),r.attributes.add(v.EXTRUDE,\"vec2\"),r.varyings.add(\"uv\",\"vec2\"),r.varyings.add(\"vViewStart\",\"vec3\"),r.varyings.add(\"vViewEnd\",\"vec3\"),r.varyings.add(\"vViewSegmentNormal\",\"vec3\"),r.varyings.add(\"vViewStartNormal\",\"vec3\"),r.varyings.add(\"vViewEndNormal\",\"vec3\");const h=!t.spherical;return w.main.add(d`\r\n    vec3 pos = mix(start, end, extrude.x);\r\n\r\n    vec4 viewPos = modelView * vec4(pos, 1);\r\n    vec4 projPos = proj * viewPos;\r\n    vec2 ndcPos = projPos.xy / projPos.w;\r\n\r\n    // in planar we hardcode the up vectors to be Z-up */\r\n    ${l(h,d`vec3 startUp = vec3(0, 0, 1);`)}\r\n    ${l(h,d`vec3 endUp = vec3(0, 0, 1);`)}\r\n\r\n    // up vector corresponding to the location of the vertex, selecting either startUp or endUp */\r\n    vec3 up = extrude.y * mix(startUp, endUp, extrude.x);\r\n    vec3 viewUp = (modelView * vec4(up, 0)).xyz;\r\n\r\n    vec4 projPosUp = proj * vec4(viewPos.xyz + viewUp, 1);\r\n    vec2 projUp = normalize(projPosUp.xy / projPosUp.w - ndcPos);\r\n\r\n    // extrude ndcPos along projUp to the edge of the screen\r\n    vec2 lxy = abs(sign(projUp) - ndcPos);\r\n    ndcPos += length(lxy) * projUp;\r\n\r\n    vViewStart = (modelView * vec4(start, 1)).xyz;\r\n    vViewEnd = (modelView * vec4(end, 1)).xyz;\r\n\r\n    vec3 viewStartEndDir = vViewEnd - vViewStart;\r\n\r\n    vec3 viewStartUp = (modelView * vec4(startUp, 0)).xyz;\r\n\r\n    // the normal of the plane that aligns with the segment and the up vector\r\n    vViewSegmentNormal = normalize(cross(viewStartUp, viewStartEndDir));\r\n\r\n    // the normal orthogonal to the segment normal and the start up vector\r\n    vViewStartNormal = -normalize(cross(vViewSegmentNormal, viewStartUp));\r\n\r\n    // the normal orthogonal to the segment normal and the end up vector\r\n    vec3 viewEndUp = (modelView * vec4(endUp, 0)).xyz;\r\n    vViewEndNormal = normalize(cross(vViewSegmentNormal, viewEndUp));\r\n\r\n    // Add enough padding in the X screen space direction for \"glow\"\r\n    float xPaddingPixels = sign(dot(vViewSegmentNormal, viewPos.xyz)) * (extrude.x * 2.0 - 1.0) * glowWidth;\r\n    ndcPos.x += xPaddingPixels * pixelToNDC.x;\r\n\r\n    // uv is used to read back depth to reconstruct the position at the fragment\r\n    uv = ndcPos * 0.5 + 0.5;\r\n\r\n    gl_Position = vec4(ndcPos, 0, 1);\r\n  `),u.uniforms.add(new n(\"perScreenPixelRatio\",(e=>e.camera.perScreenPixelRatio))),u.code.add(d`float planeDistance(vec3 planeNormal, vec3 planeOrigin, vec3 pos) {\r\nreturn dot(planeNormal, pos - planeOrigin);\r\n}\r\nfloat segmentDistancePixels(vec3 segmentNormal, vec3 startNormal, vec3 endNormal, vec3 pos, vec3 start, vec3 end) {\r\nfloat distSegmentPlane = planeDistance(segmentNormal, start, pos);\r\nfloat distStartPlane = planeDistance(startNormal, start, pos);\r\nfloat distEndPlane = planeDistance(endNormal, end, pos);\r\nfloat dist = max(max(distStartPlane, distEndPlane), abs(distSegmentPlane));\r\nfloat width = fwidth(distSegmentPlane);\r\nfloat maxPixelDistance = length(pos) * perScreenPixelRatio * 2.0;\r\nfloat pixelDist = dist / min(width, maxPixelDistance);\r\nreturn abs(pixelDist);\r\n}`),u.main.add(d`fragColor = vec4(0.0);\r\nvec3 dEndStart = vViewEnd - vViewStart;\r\nif (dot(dEndStart, dEndStart) < 1e-5) {\r\nreturn;\r\n}\r\nvec3 pos;\r\nvec3 normal;\r\nfloat angleCutoffAdjust;\r\nfloat depthDiscontinuityAlpha;\r\nif (!laserlineReconstructFromDepth(pos, normal, angleCutoffAdjust, depthDiscontinuityAlpha)) {\r\nreturn;\r\n}\r\nfloat distance = segmentDistancePixels(\r\nvViewSegmentNormal,\r\nvViewStartNormal,\r\nvViewEndNormal,\r\npos,\r\nvViewStart,\r\nvViewEnd\r\n);\r\nvec4 color = laserlineProfile(distance);\r\nfloat alpha = (1.0 - smoothstep(0.995 - angleCutoffAdjust, 0.999 - angleCutoffAdjust, abs(dot(normal, vViewSegmentNormal))));\r\nfragColor = laserlineOutput(color * alpha * depthDiscontinuityAlpha);`),r}const g=r(),f=t(),u=Object.freeze(Object.defineProperty({__proto__:null,build:w},Symbol.toStringTag,{value:\"Module\"}));export{u as L,w as b};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIokC,SAAS,EAAEA,IAAE;AAAC,QAAM,IAAE,IAAIC;AAAE,IAAE,QAAQ,GAAED,EAAC;AAAE,QAAK,EAAC,QAAOE,IAAE,UAASC,GAAC,IAAE;AAAE,EAAAD,GAAE,SAAS,IAAI,IAAIE,GAAE,aAAa,CAACJ,IAAE,EAAC,QAAOI,GAAC,MAAI,EAAE,GAAEA,GAAE,YAAWJ,GAAE,MAAM,CAAE,GAAE,IAAIA,GAAE,QAAQ,CAAC,EAAC,QAAOK,GAAC,MAAIA,GAAE,gBAAiB,GAAE,IAAI,EAAE,aAAa,CAACA,IAAE,EAAC,QAAOL,GAAC,MAAIK,GAAE,YAAUL,GAAE,UAAW,GAAE,IAAII,GAAE,cAAc,CAAC,EAAC,QAAOC,GAAC,MAAI,EAAE,GAAE,IAAEA,GAAE,aAAa,CAAC,GAAE,IAAEA,GAAE,aAAa,CAAC,CAAC,CAAE,CAAC,GAAE,EAAE,WAAW,IAAIA,GAAE,OAAM,MAAM,GAAE,EAAE,WAAW,IAAIA,GAAE,KAAI,MAAM,GAAEL,GAAE,cAAY,EAAE,WAAW,IAAIK,GAAE,UAAS,MAAM,GAAE,EAAE,WAAW,IAAIA,GAAE,QAAO,MAAM,IAAG,EAAE,WAAW,IAAIA,GAAE,SAAQ,MAAM,GAAE,EAAE,SAAS,IAAI,MAAK,MAAM,GAAE,EAAE,SAAS,IAAI,cAAa,MAAM,GAAE,EAAE,SAAS,IAAI,YAAW,MAAM,GAAE,EAAE,SAAS,IAAI,sBAAqB,MAAM,GAAE,EAAE,SAAS,IAAI,oBAAmB,MAAM,GAAE,EAAE,SAAS,IAAI,kBAAiB,MAAM;AAAE,QAAM,IAAE,CAACL,GAAE;AAAU,SAAOE,GAAE,KAAK,IAAII;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQr1D,EAAE,GAAEA,iCAAgC,CAAC;AAAA,MACrC,EAAE,GAAEA,+BAA8B,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAsCtC,GAAEH,GAAE,SAAS,IAAI,IAAIE,GAAE,uBAAuB,CAAAA,OAAGA,GAAE,OAAO,mBAAoB,CAAC,GAAEF,GAAE,KAAK,IAAIG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAY7F,GAAEH,GAAE,KAAK,IAAIG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sEAsBuD,GAAE;AAAC;AAAC,IAAM,IAAE,EAAE;AAAV,IAAY,IAAE,EAAE;AAAhB,IAAkB,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["t", "i", "w", "u", "o", "e", "n"]
}
