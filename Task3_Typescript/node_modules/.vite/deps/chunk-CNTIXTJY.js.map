{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/materials/PatternStyle.js", "../../@arcgis/core/chunks/Pattern.glsl.js"],
  "sourcesContent": ["/*\r\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\r\nSee https://js.arcgis.com/4.33/esri/copyright.txt for details.\r\n*/\r\nvar a;!function(a){a[a.Horizontal=0]=\"Horizontal\",a[a.Vertical=1]=\"Vertical\",a[a.Cross=2]=\"Cross\",a[a.ForwardDiagonal=3]=\"ForwardDiagonal\",a[a.BackwardDiagonal=4]=\"BackwardDiagonal\",a[a.DiagonalCross=5]=\"DiagonalCross\",a[a.COUNT=6]=\"COUNT\"}(a||(a={}));export{a as Style};\r\n", "/*\r\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\r\nSee https://js.arcgis.com/4.33/esri/copyright.txt for details.\r\n*/\r\nimport{ShaderOutput as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as r}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{ObjectAndLayerIdColor as t}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";import{VertexColor as a}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";import{terrainDepthTest as i}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";import{VisualVariables as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js\";import{ColorConversion as n}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{addProjViewLocalOrigin as c,addCameraPosition as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float4PassUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatBindUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";import{glsl as g,If as p}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{VertexAttribute as m}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{Style as f}from\"../views/3d/webgl-engine/materials/PatternStyle.js\";import{outputColorHighlightOID as u}from\"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";import{ShaderBuilder as w}from\"../views/webgl/ShaderBuilder.js\";const b=.70710678118,h=b,y=.08715574274,S=10,j=1;function x(x){const T=new w,{vertex:P,fragment:R,attributes:V,varyings:D}=T,O=x.output===e.Highlight;c(P,x),T.include(r,x),T.include(a,x),T.include(l,x),T.include(t,x),T.fragment.include(o,x),T.include(u,x),T.include(i,x),x.draped?P.uniforms.add(new v(\"worldToScreenRatio\",(e=>1/e.screenToPCSRatio))):V.add(m.BOUNDINGRECT,\"mat3\"),V.add(m.POSITION,\"vec3\"),V.add(m.UVMAPSPACE,\"vec4\"),x.vvColor&&V.add(m.COLORFEATUREATTRIBUTE,\"float\"),x.hasVertexColors||D.add(\"vColor\",\"vec4\"),D.add(\"vpos\",\"vec3\",{invariant:!0}),D.add(\"vuv\",\"vec2\"),P.uniforms.add(new s(\"uColor\",(e=>e.color)));const A=x.style===f.ForwardDiagonal||x.style===f.BackwardDiagonal||x.style===f.DiagonalCross;return A&&P.code.add(g`\r\n      const mat2 rotate45 = mat2(${g.float(b)}, ${g.float(-.70710678118)},\r\n                                 ${g.float(h)}, ${g.float(b)});\r\n    `),x.draped||(d(P,x),P.uniforms.add(new v(\"worldToScreenPerDistanceRatio\",(e=>1/e.camera.perScreenPixelRatio))),P.code.add(g`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\r\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\r\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\r\n}`),P.code.add(g`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\r\nfloat d = dot(planeNormal, planePoint);\r\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\r\nreturn rayOrigin + t * rayDir;\r\n}`),P.code.add(g`\r\n      float boundingRectDistanceToCamera() {\r\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\r\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\r\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\r\n        vec3 n = normalize(cross(halfU, halfV));\r\n\r\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\r\n\r\n        float viewAngle = dot(viewDir, n);\r\n        float minViewAngle = ${g.float(y)};\r\n\r\n        if (abs(viewAngle) < minViewAngle) {\r\n          // view direction is (almost) parallel to plane -> clamp it to min angle\r\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\r\n          viewDir = normalize(viewDir + normalComponent * n);\r\n        }\r\n\r\n        // intersect view direction with infinite plane that contains bounding rect\r\n        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);\r\n\r\n        // clip to bounds by projecting to u and v line segments individually\r\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\r\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\r\n\r\n        // use to calculate the closest point to camera on bounding rect\r\n        vec3 closestPoint = uProjected + vProjected - center;\r\n\r\n        return length(closestPoint - cameraPosition);\r\n      }\r\n    `)),P.code.add(g`\r\n    vec2 scaledUV() {\r\n      vec2 uv = uvMapSpace.xy ${p(A,\" * rotate45\")};\r\n      vec2 uvCellOrigin = uvMapSpace.zw ${p(A,\" * rotate45\")};\r\n\r\n      ${p(!x.draped,g`float distanceToCamera = boundingRectDistanceToCamera();\r\n               float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;`)}\r\n\r\n      // Logarithmically discretize ratio to avoid jittering\r\n      float step = 0.1;\r\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\r\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\r\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\r\n\r\n      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${g.float(S)});\r\n      return uvOffset + (uv * discreteWorldToScreenRatio);\r\n    }\r\n  `),P.main.add(g`\r\n    vuv = scaledUV();\r\n    vpos = position;\r\n    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);\r\n    forwardNormalizedVertexColor();\r\n    forwardObjectAndLayerIdColor();\r\n    ${x.hasVertexColors?\"vColor *= uColor;\":x.vvColor?\"vColor = uColor * interpolateVVColor(colorFeatureAttribute);\":\"vColor = uColor;\"}\r\n    gl_Position = transformPosition(proj, view, vpos);\r\n  `),R.include(n),x.draped&&R.uniforms.add(new v(\"texelSize\",(e=>1/e.camera.pixelRatio))),O||(R.code.add(g`\r\n      const float lineWidth = ${g.float(j)};\r\n      const float spacing = ${g.float(S)};\r\n      const float spacingINV = ${g.float(1/S)};\r\n\r\n      float coverage(float p, float txlSize) {\r\n        p = mod(p, spacing);\r\n\r\n        float halfTxlSize = txlSize / 2.0;\r\n\r\n        float start = p - halfTxlSize;\r\n        float end = p + halfTxlSize;\r\n\r\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\r\n        coverage -= min(lineWidth, mod(start, spacing));\r\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\r\n\r\n        return coverage / txlSize;\r\n      }\r\n    `),x.draped||R.code.add(g`const int maxSamples = 5;\r\nfloat sampleAA(float p) {\r\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\r\nfloat fwidth = dxdy.x + dxdy.y;\r\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\r\nvec2 invSamples = 1.0 / vec2(samples);\r\nfloat accumulator = 0.0;\r\nfor (int j = 0; j < maxSamples; j++) {\r\nif(j >= samples.y) {\r\nbreak;\r\n}\r\nfor (int i = 0; i < maxSamples; i++) {\r\nif(i >= samples.x) {\r\nbreak;\r\n}\r\nvec2 step = vec2(i,j) * invSamples - 0.5;\r\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\r\n}\r\n}\r\naccumulator /= float(samples.x * samples.y);\r\nreturn accumulator;\r\n}`)),R.main.add(g`\r\n    discardBySlice(vpos);\r\n    discardByTerrainDepth();\r\n    vec4 color = vColor;\r\n    ${p(!O,g`color.a *= ${C(x)};`)}\r\n    outputColorHighlightOID(color, vpos, color.rgb);\r\n  `),T}function C(e){function o(o){return e.draped?g`coverage(vuv.${o}, texelSize)`:g`sampleAA(vuv.${o})`}switch(e.style){case f.ForwardDiagonal:case f.Horizontal:return o(\"y\");case f.BackwardDiagonal:case f.Vertical:return o(\"x\");case f.DiagonalCross:case f.Cross:return g`1.0 - (1.0 - ${o(\"x\")}) * (1.0 - ${o(\"y\")})`;default:return\"0.0\"}}const T=Object.freeze(Object.defineProperty({__proto__:null,build:x},Symbol.toStringTag,{value:\"Module\"}));export{T as P,x as b};\r\n"],
  "mappings": "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",
  "names": ["a", "x", "T", "n", "e", "i", "o"]
}
