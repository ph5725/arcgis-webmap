import {
  A as A2
} from "./chunk-YWGFBTRS.js";
import {
  A,
  I
} from "./chunk-XD64QX5H.js";
import {
  $,
  L,
  N
} from "./chunk-7NMH5MM5.js";
import {
  d
} from "./chunk-2IMSGFJN.js";
import {
  f
} from "./chunk-N3A2BVTW.js";
import {
  s as s2,
  se
} from "./chunk-OXSERRAR.js";
import {
  Dt
} from "./chunk-LQFTAGIV.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";

// node_modules/@arcgis/core/layers/graphics/applyEditsUtils.js
async function m(e, t, r) {
  const { geometry: s3 } = t, i2 = { ...t.attributes };
  if (null != r && "mesh" === s3?.type) {
    const { transformFieldRoles: t2 } = r, { origin: c, spatialReference: p, vertexSpace: m2 } = s3, f3 = s3.transform ?? new A2(), g2 = "local" === m2.type, b2 = e.spatialReference, y2 = b2.isGeographic, R2 = s2(b2, p), h2 = N(p, b2) && L(p, b2);
    if (!(g2 && y2 && h2 || !g2 && !y2 && R2)) return null;
    const I3 = $(c, p, b2);
    if (null == I3) return null;
    if (i2[t2.originX] = I3.x, i2[t2.originY] = I3.y, i2[t2.originZ] = I3.z ?? 0, null != f3) {
      const { translation: e2, scale: r2, rotation: s4 } = f3, o = g2 ? 1 : se(p) / se(b2);
      i2[t2.translationX] = e2[0] * o, i2[t2.translationY] = e2[2] * o, i2[t2.translationZ] = -e2[1] * o, i2[t2.scaleX] = r2[0], i2[t2.scaleY] = r2[2], i2[t2.scaleZ] = r2[1], i2[t2.rotationX] = s4[0], i2[t2.rotationY] = s4[2], i2[t2.rotationZ] = -s4[1], i2[t2.rotationDeg] = s4[3];
    }
    return { attributes: i2 };
  }
  return null == s3 ? { attributes: i2 } : "mesh" === s3.type || "extent" === s3.type ? null : { geometry: s3.toJSON(), attributes: i2 };
}
async function f2(e, t) {
  const r = await Promise.all((t.addAttachments ?? []).map((t2) => g(e, t2))), a = await Promise.all((t.updateAttachments ?? []).map((t2) => g(e, t2))), s3 = t.deleteAttachments ?? [];
  return r.length || a.length || s3.length ? { adds: r, updates: a, deletes: [...s3] } : null;
}
async function g(e, t) {
  const { feature: r, attachment: a } = t, { globalId: o, name: n, contentType: l, data: i2, uploadId: u } = a, d2 = { globalId: o };
  if (r && ("attributes" in r ? d2.parentGlobalId = r.attributes?.[e.globalIdField] : r.globalId && (d2.parentGlobalId = r.globalId)), u) d2.uploadId = u;
  else if (i2) {
    const e2 = await Dt(i2);
    e2 && (d2.contentType = e2.mediaType, d2.data = e2.data), i2 instanceof File && (d2.name = i2.name);
  }
  return n && (d2.name = n), l && (d2.contentType = l), d2;
}
function b(e, t, r) {
  if (!t || 0 === t.length) return [];
  if (r && I(t)) return t.map((e2) => e2.globalId);
  if (A(t)) return t.map((e2) => e2.objectId);
  const a = r ? e.globalIdField : e.objectIdField;
  return a ? t.map((e2) => e2.getAttribute(a)) : [];
}
function y(e) {
  const t = e?.assetMaps;
  if (t) {
    for (const e2 of t.addResults) e2.success || i.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${e2.globalId}.`);
    for (const e2 of t.updateResults) e2.success || i.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${e2.globalId}.`);
  }
  const a = e?.attachments, s3 = { addFeatureResults: e?.addResults?.map(R) ?? [], updateFeatureResults: e?.updateResults?.map(R) ?? [], deleteFeatureResults: e?.deleteResults?.map(R) ?? [], addAttachmentResults: a?.addResults ? a.addResults.map(R) : [], updateAttachmentResults: a?.updateResults ? a.updateResults.map(R) : [], deleteAttachmentResults: a?.deleteResults ? a.deleteResults.map(R) : [] };
  return e?.editMoment && (s3.editMoment = e.editMoment), s3;
}
function R(e) {
  const r = true === e.success ? null : e.error || { code: void 0, description: "Feature edit failed" };
  return { objectId: e.objectId, globalId: e.globalId, error: r ? new s("feature-layer-source:edit-failure", r.description, { code: r.code }) : null };
}
function h(t, r) {
  return new d({ attributes: t.attributes, geometry: f({ ...t.geometry, spatialReference: r }) });
}
function I2(e, t) {
  return { adds: e?.adds?.map((e2) => h(e2, t)) || [], updates: e?.updates?.map((e2) => ({ original: h(e2[0], t), current: h(e2[1], t) })) || [], deletes: e?.deletes?.map((e2) => h(e2, t)) || [], spatialReference: t };
}
function j(e) {
  const t = e.details.raw, r = +t.code, a = +t.extendedCode;
  return 500 === r && (-2147217144 === a || -2147467261 === a);
}

export {
  m,
  f2 as f,
  b,
  y,
  R,
  I2 as I,
  j
};
//# sourceMappingURL=chunk-D3RLCXTB.js.map
