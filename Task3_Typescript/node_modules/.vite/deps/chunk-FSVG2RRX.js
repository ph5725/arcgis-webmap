import {
  c,
  t
} from "./chunk-L3O6KWVI.js";
import {
  A
} from "./chunk-GG4VLKUY.js";
import {
  te
} from "./chunk-UTU6N7VJ.js";
import {
  l as l3,
  p
} from "./chunk-G4PMFSAZ.js";
import {
  a as a5
} from "./chunk-MX5VW6PC.js";
import {
  o as o3
} from "./chunk-OTSYE6UT.js";
import {
  m as m3
} from "./chunk-AGDHKBKD.js";
import {
  m as m2
} from "./chunk-HUVZEBBO.js";
import {
  f,
  g as g2,
  l as l4
} from "./chunk-GH7GZNY6.js";
import {
  x
} from "./chunk-YSCIEMYQ.js";
import {
  q
} from "./chunk-YX2VTIZR.js";
import {
  g2 as g
} from "./chunk-LYSDGL5S.js";
import {
  u
} from "./chunk-HNQNVI5C.js";
import {
  r as r3
} from "./chunk-EOMIFMDH.js";
import {
  o as o2
} from "./chunk-MUKDJQWB.js";
import {
  a as a4
} from "./chunk-TVM3SZJR.js";
import {
  U,
  l as l2
} from "./chunk-A3VAC24F.js";
import {
  o
} from "./chunk-JUAPMINU.js";
import {
  r as r2
} from "./chunk-YFPGM5UE.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a3
} from "./chunk-JUAD7TJ6.js";
import {
  a as a2
} from "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import {
  a,
  e
} from "./chunk-GWNLQRNM.js";
import {
  has
} from "./chunk-FXKORAMT.js";

// node_modules/@arcgis/core/layers/support/ExpressionInfo.js
var p2 = class extends a4.ClonableMixin(l) {
  constructor(r4) {
    super(r4), this.expression = null, this.title = null, this.returnType = null;
  }
};
r([m({ type: String, json: { write: true } })], p2.prototype, "expression", void 0), r([m({ type: String, json: { write: true } })], p2.prototype, "title", void 0), r([m({ type: String, json: { write: true } })], p2.prototype, "returnType", void 0), p2 = r([a3("esri.layers.support.ExpressionInfo")], p2);

// node_modules/@arcgis/core/layers/support/AggregateField.js
var p3;
var _a;
var n = (_a = class extends l {
  constructor(t2) {
    super(t2), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p3({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: a(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
}, p3 = _a, _a);
r([m({ type: Boolean, json: { write: true } })], n.prototype, "isAutoGenerated", void 0), r([m({ type: String, json: { write: true } })], n.prototype, "name", void 0), r([m({ type: String, json: { write: true } })], n.prototype, "alias", void 0), r([m({ type: String, json: { write: true } })], n.prototype, "onStatisticField", void 0), r([m({ type: p2, json: { write: true } })], n.prototype, "onStatisticExpression", void 0), r([m({ type: String, json: { write: true } })], n.prototype, "statisticType", void 0), n = p3 = r([a3("esri.layers.support.AggregateField")], n);

// node_modules/@arcgis/core/layers/support/FeatureReductionBinning.js
var j;
var v = j = class extends t {
  constructor(e2) {
    super(e2), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = null, this.labelingInfo = null, this.labelsVisible = true, this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.size = o2("12px"), this.fields = [], this.renderer = null;
  }
  writeFields(e2, r4, o5) {
    const i2 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    e(o5, i2, r4);
  }
  readRenderer(e2, r4, o5) {
    const t2 = r4.drawingInfo?.renderer;
    return t2 ? o3(t2, r4, o5) ?? void 0 : te(r4, o5);
  }
  clone() {
    return new j({ fields: a(this.fields), fixedBinLevel: this.fixedBinLevel, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, maxScale: this.maxScale, popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate), renderer: a(this.renderer), binType: a(this.binType), size: this.size });
  }
};
r([r3({ binning: "binning" })], v.prototype, "type", void 0), r([r3({ geohash: "geohash", square: "square" }), m({ type: ["geohash", "square"] })], v.prototype, "binType", void 0), r([m({ type: Number, json: { write: true } })], v.prototype, "fixedBinLevel", void 0), r([m({ type: [A], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], v.prototype, "labelingInfo", void 0), r([m(p)], v.prototype, "labelsVisible", void 0), r([m({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], v.prototype, "maxScale", void 0), r([m(l3)], v.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], v.prototype, "popupTemplate", void 0), r([m({ cast: (e2) => "auto" === e2 ? e2 : a2(o2(e2)) })], v.prototype, "size", void 0), r([m({ type: [n], json: { write: true } })], v.prototype, "fields", void 0), r([r2("fields")], v.prototype, "writeFields", null), r([m({ types: m3, json: { write: { target: "drawingInfo.renderer" } } })], v.prototype, "renderer", void 0), r([o("renderer", ["drawingInfo.renderer"])], v.prototype, "readRenderer", null), v = j = r([a3("esri.layers.support.FeatureReductionBinning")], v);

// node_modules/@arcgis/core/layers/support/FeatureReductionCluster.js
var S;
function w(e2) {
  return "simple" === e2.type && !e2.visualVariables?.length;
}
var I = S = class extends l {
  constructor(e2) {
    super(e2), this.type = "cluster", this.clusterRadius = o2("80px"), this.clusterMinSize = o2("12px"), this.clusterMaxSize = o2("50px"), this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = true, this.fields = [];
  }
  readRenderer(e2, r4, t2) {
    const o5 = r4.drawingInfo?.renderer;
    return o5?.authoringInfo?.isAutoGenerated ? null : o5 ? w(o5) ? null : o3(o5, r4, t2) ?? void 0 : te(r4, t2);
  }
  readSymbol(e2, r4, t2) {
    const o5 = r4.drawingInfo?.renderer;
    if (o5?.authoringInfo?.isAutoGenerated) return null;
    if (o5 && w(o5)) {
      const e3 = o3(o5, r4, t2);
      return e3?.symbol;
    }
    return null;
  }
  writeSymbol(e2, r4, t2, o5) {
    const s2 = this.renderer?.authoringInfo?.isAutoGenerated;
    if (!this.renderer || s2) {
      const t3 = new m2({ symbol: e2 });
      r4.drawingInfo = { renderer: t3.write({}, o5) };
    }
  }
  writeFields(e2, r4, t2) {
    const o5 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    e(t2, o5, r4);
  }
  readFields(e2, r4, t2) {
    return e2.filter((e3) => !e3.isAutoGenerated).map((e3) => n.fromJSON(e3));
  }
  clone() {
    return new S({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, fields: a(this.fields), maxScale: this.maxScale, renderer: a(this.renderer), symbol: a(this.symbol), popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate) });
  }
};
r([m({ type: ["cluster"], readOnly: true, json: { write: true } })], I.prototype, "type", void 0), r([m({ cast: (e2) => "auto" === e2 ? e2 : a2(o2(e2)), json: { write: true } })], I.prototype, "clusterRadius", void 0), r([m({ type: Number, cast: o2, json: { write: true } })], I.prototype, "clusterMinSize", void 0), r([m({ type: Number, cast: o2, json: { write: true } })], I.prototype, "clusterMaxSize", void 0), r([m({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], I.prototype, "maxScale", void 0), r([m(l3)], I.prototype, "popupEnabled", void 0), r([m({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], I.prototype, "popupTemplate", void 0), r([m({ types: m3, json: { write: { target: "drawingInfo.renderer" } } })], I.prototype, "renderer", void 0), r([o("renderer", ["drawingInfo.renderer"])], I.prototype, "readRenderer", null), r([m({ types: g })], I.prototype, "symbol", void 0), r([o("symbol", ["drawingInfo.renderer"])], I.prototype, "readSymbol", null), r([r2("symbol")], I.prototype, "writeSymbol", null), r([m({ type: [A], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], I.prototype, "labelingInfo", void 0), r([m(p)], I.prototype, "labelsVisible", void 0), r([m({ type: [n], json: { write: true } })], I.prototype, "fields", void 0), r([r2("fields")], I.prototype, "writeFields", null), r([o("fields")], I.prototype, "readFields", null), I = S = r([a3("esri.layers.support.FeatureReductionCluster")], I);

// node_modules/@arcgis/core/layers/support/featureReductionUtils.js
var o4 = { key: "type", base: t, typeMap: { cluster: I, binning: v } };
var p4 = { types: { key: "type", base: t, typeMap: { selection: c, cluster: I, binning: v } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: true }, origins: { "web-map": { types: o4 }, "portal-item": { types: o4 }, "web-scene": { types: { key: "type", base: t, typeMap: { selection: c } }, name: "layerDefinition.featureReduction", write: { layerContainerTypes: a5 } } } } };

// node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var l5 = () => i.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
var u2 = has("esri-cluster-arcade-enabled");
var p5 = /* @__PURE__ */ new Set(["simple-line", "simple-fill", "picture-fill"]);
function d(e2, r4) {
  let s2 = r4.clone();
  if (!m4(s2)) return s2;
  if (r4.symbols.some((e3) => p5.has(e3.type)) && (s2 = new m2({ symbol: new u() })), s2.authoringInfo || (s2.authoringInfo = new g2()), s2.authoringInfo.isAutoGenerated = true, "visualVariables" in s2) {
    const r5 = (s2.visualVariables || []).filter((e3) => "$view.scale" !== e3.valueExpression);
    r5.forEach((r6) => {
      "rotation" === r6.type ? r6.field ? r6.field = v2(e2, r6.field, "avg_angle", "number") : r6.valueExpression && (r6.field = c2(e2, r6.valueExpression, "avg_angle", "number"), r6.valueExpression = null) : r6.normalizationField ? (r6.field = v2(e2, r6.field, "avg_norm", "number", r6.normalizationField), r6.normalizationField = null) : r6.field ? r6.field = v2(e2, r6.field, "avg", "number") : r6.valueExpression && (r6.field = c2(e2, r6.valueExpression, "avg", "number"), r6.valueExpression = null);
    }), s2.visualVariables = r5;
  }
  switch (s2.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const r5 of s2.attributes) r5.field ? r5.field = v2(e2, r5.field, "sum", "number") : r5.valueExpression && (r5.field = c2(e2, r5.valueExpression, "sum", "number"), r5.valueExpression = null);
      break;
    case "unique-value":
      s2.field ? s2.field = v2(e2, s2.field, "mode", "string") : s2.valueExpression && (s2.field = c2(e2, s2.valueExpression, "mode", "string"), s2.valueExpression = null);
      break;
    case "class-breaks":
      s2.normalizationField ? (s2.field = v2(e2, s2.field, "avg_norm", "number", s2.normalizationField), s2.normalizationField = null) : s2.field ? s2.field = v2(e2, s2.field, "avg", "number") : s2.valueExpression && (s2.field = c2(e2, s2.valueExpression, "avg", "number"), s2.valueExpression = null);
  }
  return s2;
}
var m4 = (r4) => {
  const s2 = (s3) => l5().error(new s("Unsupported-renderer", s3, { renderer: r4 }));
  if (!r4) return false;
  switch (r4.type) {
    case "unique-value":
      if (r4.field2 || r4.field3) return s2("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (r4.normalizationField) {
        const e2 = r4.normalizationType;
        if ("field" !== e2) return s2(`FeatureReductionCluster does not support a normalizationType of ${e2}`), false;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return s2(`FeatureReductionCluster does not support renderers of type ${r4.type}`), false;
  }
  if (!u2) {
    if ("valueExpression" in r4 && r4.valueExpression) return s2("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in r4 && r4.visualVariables || []).some((e2) => !(!("valueExpression" in e2) || !e2.valueExpression))) return s2("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function f2(e2, r4, i2) {
  switch (e2) {
    case "sum":
      return `cluster_sum_${r4}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r4}`;
    case "mode":
      return `cluster_type_${r4}`;
    case "avg_norm": {
      const e3 = i2, n2 = "field", t2 = r4.toLowerCase() + ",norm:" + n2 + "," + e3.toLowerCase();
      return "cluster_avg_" + x(t2);
    }
  }
}
function c2(e2, r4, t2, a6) {
  const o5 = x(r4), l6 = "mode" === t2 ? `cluster_type_${o5}` : "sum" === t2 ? `cluster_sum_${o5}` : `cluster_avg_${o5}`;
  return e2.some((e3) => e3.name === l6) || e2.push(new n({ name: l6, isAutoGenerated: true, onStatisticExpression: new p2({ expression: r4, returnType: a6 }), statisticType: t2 })), l6;
}
function v2(e2, r4, s2, t2, a6) {
  if ("cluster_count" === r4 || e2.some((e3) => e3.name === r4)) return r4;
  const o5 = f2(s2, r4, a6);
  return e2.some((e3) => e3.name === o5) || ("avg_norm" === s2 ? e2.push(new n({ name: o5, isAutoGenerated: true, onStatisticExpression: new p2({ expression: `$feature.${r4} / $feature.${a6}`, returnType: t2 }), statisticType: "avg" })) : e2.push(new n({ name: o5, isAutoGenerated: true, onStatisticField: r4, statisticType: s2 }))), o5;
}

// node_modules/@arcgis/core/layers/mixins/FeatureReductionLayer.js
var d2 = (d3) => {
  let f3 = class extends d3 {
    constructor(...e2) {
      super(...e2), this.addHandles(l2(() => this.renderer, () => {
        if (this.featureReduction) {
          const e3 = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", e3);
        }
      }, U));
    }
    set featureReduction(e2) {
      const r4 = this._normalizeFeatureReduction(e2);
      this._set("featureReduction", r4);
    }
    set renderer(e2) {
    }
    _withClusterVariable(e2, r4, t2) {
      const s2 = e2.clone();
      if ("visualVariables" in s2) {
        s2.visualVariables || (s2.visualVariables = []);
        s2.visualVariables.some((e3) => "size" === e3.type) || s2.visualVariables.push(new f({ field: "cluster_count", stops: [new l4({ value: 1 }), new l4({ useMinValue: true, size: r4 }), new l4({ useMaxValue: true, size: t2 })] }));
      }
      return s2;
    }
    _normalizeFeatureReduction(e2) {
      if ("cluster" !== e2?.type) return e2;
      const r4 = e2.clone(), t2 = [new n({ name: "cluster_count", alias: "cluster_count", isAutoGenerated: true, statisticType: "count" })], s2 = (r4.fields ?? []).filter((e3) => !e3.isAutoGenerated), i2 = e2.renderer && !e2.renderer.authoringInfo?.isAutoGenerated, { clusterMinSize: o5, clusterMaxSize: n2 } = r4;
      if (i2) {
        r4.fields = [...t2, ...s2];
        const e3 = this._withClusterVariable(r4.renderer, o5, n2);
        return r4.effectiveFeatureRenderer = e3, r4.effectiveClusterRenderer = e3, r4;
      }
      if (e2.symbol) {
        if (r4.fields = [...t2, ...s2], r4.renderer = null, !this.renderer) return r4.effectiveFeatureRenderer = null, r4.effectiveClusterRenderer = null, r4;
        const i3 = d(t2, this.renderer), a6 = this._withClusterVariable(i3, o5, n2), l7 = "visualVariables" in a6 && a6.visualVariables ? a6.visualVariables : [], d5 = new m2({ symbol: e2.symbol, visualVariables: l7 });
        return r4.fields = [...t2, ...s2], r4.effectiveFeatureRenderer = a6, r4.effectiveClusterRenderer = d5, r4;
      }
      if (!this.renderer) return e2;
      const l6 = d(t2, this.renderer);
      r4.fields = [...t2, ...s2], r4.renderer = l6;
      const d4 = this._withClusterVariable(l6, o5, n2);
      return r4.effectiveFeatureRenderer = d4, r4.effectiveClusterRenderer = d4, r4;
    }
  };
  return r([m(p4)], f3.prototype, "featureReduction", null), f3 = r([a3("esri.layers.mixins.FeatureReductionLayer")], f3), f3;
};

export {
  n,
  p4 as p,
  d2 as d
};
//# sourceMappingURL=chunk-FSVG2RRX.js.map
