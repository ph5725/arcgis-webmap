import {
  g
} from "./chunk-RV6ZLP5Q.js";
import {
  c,
  i,
  l as l2,
  p,
  r,
  u as u2
} from "./chunk-GULEPNE6.js";
import {
  h,
  m as m2
} from "./chunk-OFHPFWHF.js";
import {
  k
} from "./chunk-MZJEBIXX.js";
import {
  L
} from "./chunk-76QJRCNC.js";
import {
  s
} from "./chunk-XAXNVZUO.js";
import {
  G,
  _,
  w
} from "./chunk-TMC6HYGQ.js";
import {
  S
} from "./chunk-LYSDGL5S.js";
import {
  u
} from "./chunk-HNQNVI5C.js";
import {
  m
} from "./chunk-G34OBNLT.js";
import {
  l
} from "./chunk-KE3WBZYL.js";
import {
  e
} from "./chunk-MUKDJQWB.js";
import {
  a
} from "./chunk-GWNLQRNM.js";

// node_modules/@arcgis/core/smartMapping/renderers/support/referenceSizeUtils.js
var t;
function i2(e2) {
  switch (e2) {
    case "circle":
      return { rings: [[[8.5, 0.2], [7.06, 0.33], [5.66, 0.7], [4.35, 1.31], [3.16, 2.14], [2.14, 3.16], [1.31, 4.35], [0.7, 5.66], [0.33, 7.06], [0.2, 8.5], [0.33, 9.94], [0.7, 11.34], [1.31, 12.65], [2.14, 13.84], [3.16, 14.86], [4.35, 15.69], [5.66, 16.3], [7.06, 16.67], [8.5, 16.8], [9.94, 16.67], [11.34, 16.3], [12.65, 15.69], [13.84, 14.86], [14.86, 13.84], [15.69, 12.65], [16.3, 11.34], [16.67, 9.94], [16.8, 8.5], [16.67, 7.06], [16.3, 5.66], [15.69, 4.35], [14.86, 3.16], [13.84, 2.14], [12.65, 1.31], [11.34, 0.7], [9.94, 0.33], [8.5, 0.2]]] };
    case "square":
      return { rings: [[[0.5, 0.5], [0.5, 16.5], [16.5, 16.5], [16.5, 0.5], [0.5, 0.5]]] };
    case "diamond":
      return { rings: [[[8.5, 0.5], [0.2, 8.5], [8.5, 16.5], [16.5, 8.5], [8.5, 0.5]]] };
    case "hexagon-pointy":
      return { rings: [[[15.86, 12.75], [15.86, 4.25], [8.5, 0], [1.14, 4.25], [1.14, 12.75], [8.5, 17], [15.86, 12.75]]] };
    case "hexagon-flat":
      return { rings: [[[12.75, 15.86], [17, 8.5], [12.75, 1.14], [4.25, 1.14], [0, 8.5], [4.25, 15.86], [12.75, 15.86]]] };
  }
}
function c2(e2) {
  return "CIMVectorMarker" === e2?.type ? e2.markerGraphics?.[0] : void 0;
}
function m3(e2) {
  return "CIMPolygonSymbol" === e2?.symbol?.type ? e2.symbol.symbolLayers?.[0] : void 0;
}
function y(e2, r2) {
  "CIMVectorMarker" === e2?.type && null != r2 && (e2.size = r2);
}
function u3(e2, r2) {
  const n2 = c2(e2);
  n2 && null != r2 && (n2.geometry = i2(r2));
}
function p2(e2, r2) {
  const n2 = m3(c2(e2));
  n2 && null != r2 && (n2.color = r2.toArray());
}
function f(e2, r2, n2) {
  const t2 = m3(c2(e2));
  t2 && null != r2 && n2 && (t2.colorLocked = r2);
}
function v(r2, n2) {
  const { outerRingSize: o, innerDotSize: i3, type: a3, color: l3, colorLocked: s3, primitiveOverrides: c4 } = n2, m4 = "CIMPolygonSymbol" === r2.data.symbol?.type ? r2.data.symbol.symbolLayers : null;
  if (2 === m4?.length) for (const e2 of m4) {
    const r3 = e2.primitiveName === t.OuterRing;
    y(e2, r3 ? o : i3), u3(e2, a3), p2(e2, l3), f(e2, s3, r3);
  }
  return null != o && null != i3 && (r2.data.primitiveOverrides = null), void 0 !== c4 && (r2.data.primitiveOverrides = a(c4)), r2;
}
!function(e2) {
  e2.OuterRing = "reference-size-outer-ring", e2.InnerDot = "reference-size-inner-dot";
}(t || (t = {}));

// node_modules/@arcgis/core/smartMapping/renderers/support/spikeUtils.js
var a2 = "spike-height-override";
var s2 = e(8);
var c3 = e(20);
function d(e2) {
  const { strokeColor: o, strokeWidth: r2, symbolStyle: a3 } = e2, s3 = a3?.includes("solid-fill") || a3?.includes("gradient-fill");
  let c4 = o?.toArray(), f2 = false;
  return a3?.includes("outline") && s3 ? f2 = true : c4 = e2.color?.toArray(), { type: "CIMSolidStroke", effects: y2(a3), enable: true, colorLocked: f2, capStyle: w.Round, joinStyle: G.Round, lineStyle3D: _.Strip, miterLimit: 4, width: r2 ?? e(1), color: c4 };
}
function y2(e2) {
  if (!e2?.includes("closed")) return [{ type: "CIMGeometricEffectAddControlPoints", angleTolerance: 90, primitiveName: "spike-control-points" }, { type: "CIMGeometricEffectSuppress", suppress: true, invert: true, primitiveName: "spike-stroke-suppress" }];
}
function C(e2) {
  const { color: o, symbolStyle: t2 } = e2, r2 = t2?.includes("solid-fill"), i3 = t2?.includes("gradient-fill");
  if (!r2 && !i3 || !o) return;
  if (r2) return { type: "CIMSolidFill", enable: true, colorLocked: false, color: o?.toArray() };
  const l3 = o.clone();
  return l3.a = 0, { type: "CIMGradientFill", enable: true, angle: 90, colorRamp: { type: "CIMMultipartColorRamp", colorRamps: [{ type: "CIMLinearContinuousColorRamp", fromColor: o.toArray(), toColor: l3.toArray() }], weights: [1] }, gradientMethod: "Linear", gradientSize: 70, gradientSizeUnits: "Relative", gradientType: "Continuous" };
}
function v2(t2, r2) {
  const { defaultHeight: i3, baseWidth: l3, color: n2, strokeColor: s3, primitiveOverrides: c4, symbolStyle: f2, strokeWidth: u4 } = r2, m4 = "CIMPointSymbol" === t2.data.symbol?.type ? t2.data.symbol : null, p3 = m4?.symbolLayers;
  if (!p3) return t2;
  const y3 = m4.effects, v4 = y3?.find((e2) => "CIMGeometricEffectTaperedPolygon" === e2.type), $ = y3?.find((e2) => "CIMGeometricEffectRadial" === e2.type && e2.primitiveName === a2);
  null != l3 && v4 && (v4.fromWidth = l3), null != i3 && $ && ($.length = i3);
  const h2 = p3?.find((e2) => "CIMSolidStroke" === e2.type), M2 = p3?.find((e2) => "CIMSolidFill" === e2.type), g3 = p3?.find((e2) => "CIMGradientFill" === e2.type), I2 = "CIMMultipartColorRamp" === g3?.colorRamp?.type && "CIMLinearContinuousColorRamp" === g3.colorRamp.colorRamps[0]?.type ? g3.colorRamp.colorRamps[0] : null;
  if (f2) {
    const o = M2?.color ?? I2?.fromColor ?? h2?.color, t3 = n2 ?? (o ? new l(o) : void 0), i4 = h2?.color ?? o, l4 = s3 ?? (i4 ? new l(i4) : void 0), a3 = f2.includes("solid-fill"), c5 = f2.includes("gradient-fill");
    if (a3 || c5 || S2(p3, M2 ?? g3), t3) {
      if (a3) S2(p3, g3), M2 ? M2.color = t3?.toArray() : p3.push(C({ ...r2, color: t3 }));
      else if (c5) if (S2(p3, M2), g3) {
        if (I2 && n2) {
          const e2 = t3.clone();
          e2.a = 0, I2.fromColor = t3.toArray(), I2.toColor = e2.toArray();
        }
      } else p3.push(C({ ...r2, color: t3 }));
    }
    if (h2) {
      const e2 = d({ ...r2, strokeColor: l4, color: t3 });
      h2.effects = e2.effects, h2.color = e2.color, h2.width = e2.width, h2.colorLocked = e2.colorLocked;
    }
  } else if (h2 && (s3 && (h2.color = s3.toArray()), null != u4 && (h2.width = u4)), M2 && n2 && (M2.color = n2.toArray()), I2 && n2) {
    const e2 = n2.clone();
    e2.a = 0, I2.fromColor = n2.toArray(), I2.toColor = e2.toArray();
  }
  return void 0 !== c4 && (t2.data.primitiveOverrides = a(c4)), t2;
}
function S2(e2, o) {
  if (!o) return;
  const t2 = e2.indexOf(o);
  -1 !== t2 && e2.splice(t2, 1);
}

// node_modules/@arcgis/core/widgets/Legend/support/sizeRampUtils.js
var w2 = 30;
var S3 = 12;
var g2 = 24;
var v3 = [255, 255, 255];
var z = [200, 200, 200];
var k2 = [128, 128, 128];
var j = 20;
var I = 5;
function V2(e2) {
  return "esri.symbols.SimpleMarkerSymbol" === e2.declaredClass;
}
function x(e2) {
  return "esri.symbols.PictureMarkerSymbol" === e2.declaredClass;
}
function M(e2) {
  return "esri.symbols.SimpleLineSymbol" === e2.declaredClass;
}
function U(e2) {
  return "esri.symbols.TextSymbol" === e2.declaredClass;
}
function C2(e2, t2) {
  const l3 = e2.length - 1;
  return e2.map((e3, o) => r(e3, o, l3, t2));
}
async function L2(e2, t2, o, i3, n2, r2, s3) {
  const a3 = t2.legendOptions, u4 = a3?.customValues, m4 = s3 || await B(e2, o), b = t2.stops, d2 = !!m4, h2 = !!u4, w3 = null != t2.minSize && null != t2.maxSize, S4 = b && b.length > 1, v4 = !!t2.target;
  if (!d2 || !h2 && !(w3 || S4 && !v4)) return;
  const z2 = h(m4);
  let k3 = false, j2 = null, I2 = null;
  j2 = z2 && !S4 ? u2([t2.minDataValue, t2.maxDataValue]) : u4 ?? await H(t2, m4, i3, n2?.type);
  const V3 = e2?.authoringInfo, x2 = "univariate-color-size" === V3?.type, M2 = x2 && "above-and-below" === V3?.univariateTheme, U2 = !!c(e2, "reference-size"), L3 = !!c(e2, "spike");
  if (!j2 && S4 && (j2 = b.map((e3) => e3.value), k3 = b.some((e3) => !!e3.label), "flow" === e2.type && (j2 = u2(j2)), k3 && (I2 = b.map((e3) => e3.label))), z2 && null != j2 && j2?.length > 2 && !M2 && (j2 = [j2[0], j2[j2.length - 1]]), !j2) return null;
  x2 && 5 !== j2?.length && (j2 = O({ minSize: j2[0], maxSize: j2[j2.length - 1] }));
  const T2 = z2 ? D(e2, j2) : null, q2 = m2(m4), E2 = k3 ? null : C2(j2, r2), P2 = await Promise.all(j2.map(async (l3, o2) => {
    let r3 = z2 ? T2[o2] : await G2(t2, m4, l3, i3, n2?.type), s4 = r3;
    U2 && (r3 *= g2 / t2.maxSize || 1, s4 = g2);
    const a4 = J(m4, r3, e2, o2);
    L3 && "cim" === a4.type && (s4 = await g(a4));
    return { value: l3, symbol: a4, label: k3 ? I2[o2] : E2[o2], size: s4, outlineSize: q2 };
  }));
  return P2.reverse();
}
function D(e2, t2) {
  const l3 = e2?.authoringInfo, o = "univariate-color-size" === l3?.type;
  let i3 = [S3, w2];
  if (o) {
    const e3 = t2[0], l4 = t2[t2.length - 1], o2 = S3, n2 = w2;
    i3 = t2.map((t3) => o2 + (t3 - e3) / (l4 - e3) * (n2 - o2));
  }
  return o && "below" === l3?.univariateTheme && i3.reverse(), i3;
}
function T(t2, l3, o, i3) {
  const r2 = "class-breaks" === t2.type, s3 = r2 ? t2.classBreakInfos?.[0]?.symbol?.clone() : t2.uniqueValueInfos?.[0]?.symbol?.clone();
  return s3 && "type" in s3 && "cim" === s3.type ? (v(s3, { color: i3 ?? (r2 ? null : new l(z)), innerDotSize: l3 * (g2 / o) || 1, outerRingSize: g2 }), s3) : null;
}
function q(e2, t2) {
  const l3 = e2.classBreakInfos, o = l3.length, i3 = o < 2 || !(t2 >= 2) ? l3[0].symbol.clone() : l3[o - 1].symbol.clone(), n2 = e2.visualVariables?.some((e3) => "color" === e3.type);
  return n2 && (i3.type.includes("3d") ? P(i3) : R(i3)), i3;
}
async function B(l3, o) {
  if ("flow" === l3.type) return p(l3, o);
  if ("pie-chart" === l3.type) return new u({ color: null, outline: l3.outline?.width ? l3.outline : new m() });
  let i3 = null, u4 = null;
  if ("simple" === l3.type) i3 = l3.symbol;
  else if ("class-breaks" === l3.type) {
    const e2 = l3.classBreakInfos;
    i3 = e2 && e2[0] && e2[0].symbol, u4 = e2.length > 1;
  } else if ("unique-value" === l3.type) {
    const e2 = l3.uniqueValueInfos;
    i3 = e2?.[0]?.symbol, u4 = null != e2 && e2.length > 1;
  }
  if (!i3 || E(i3)) return null;
  if (i3 = i3.clone(), o || u4) if (i3.type.includes("3d")) P(i3);
  else if (c(l3, "reference-size") && "cim" === i3.type) v(i3, { color: o ?? ("class-breaks" !== l3.type ? new l(z) : null) });
  else if (c(l3, "spike") && "cim" === i3.type) {
    const l4 = new l(z), n2 = new l(k2), s3 = "CIMPointSymbol" === i3.data.symbol?.type ? i3.data.symbol : null, a3 = !!s3?.symbolLayers?.find(({ type: e2 }) => "CIMSolidStroke" === e2)?.colorLocked;
    let u5, c4 = o ?? void 0;
    if (c4) {
      const e2 = L(c4), o2 = s();
      (!o2 && e2 > 225 || o2 && e2 < 25) && (c4 = l4, u5 = a3 ? n2 : l4);
    } else c4 = l4, u5 = a3 ? n2 : l4;
    v2(i3, { color: c4, strokeColor: u5 });
  } else R(i3);
  return i3;
}
function E(e2) {
  return S(e2) ? e2.symbolLayers?.some((e3) => "fill" === e3?.type) ?? false : e2?.type.includes("fill") ?? false;
}
function P(e2) {
  "line-3d" === e2.type ? e2.symbolLayers.forEach((e3) => {
    e3.material = { color: k2 };
  }) : e2.symbolLayers.forEach((e3) => {
    "icon" !== e3.type || e3.resource?.href ? e3.material = { color: z } : (e3.material = { color: v3 }, e3.outline = { color: k2, size: 1.5 });
  });
}
function R(t2) {
  const l3 = s();
  if ("cim" === t2.type) k(t2, new l(z));
  else if (t2.type.includes("line")) t2.color = k2;
  else if (t2.color = l3 ? k2 : v3, "simple-marker" === t2.type) if (t2.outline) {
    const e2 = t2.outline?.color?.toHex();
    "#ffffff" === e2 && (t2.outline.color = k2);
  } else t2.outline = { color: k2, width: 1.5 };
}
async function H(e2, t2, o, i3) {
  const n2 = (await import("./visualVariableUtils-YHLE7DFA.js")).getSizeRangeAtScale(e2, o, i3), r2 = n2 && O(n2);
  if (!n2 || !r2) return;
  let s3 = r2.map((t3) => A(t3, e2, n2));
  s3 = u2(s3);
  for (let l3 = 1; l3 < s3.length - 1; l3++) {
    const n3 = await F(e2, t2, s3[l3], s3[l3 - 1], o, i3);
    n3 && (s3[l3] = n3[0], r2[l3] = n3[1]);
  }
  return s3;
}
function O(e2) {
  const t2 = e2.minSize, l3 = e2.maxSize, o = I, i3 = (l3 - t2) / (o - 1), n2 = [];
  for (let r2 = 0; r2 < o; r2++) n2.push(t2 + i3 * r2);
  return n2;
}
function A(e2, t2, l3) {
  const o = l3.minSize, i3 = l3.maxSize, n2 = t2.minDataValue, r2 = t2.maxDataValue;
  let s3;
  if (e2 <= o) s3 = n2;
  else if (e2 >= i3) s3 = r2;
  else {
    s3 = (e2 - o) / (i3 - o) * (r2 - n2) + n2;
  }
  return s3;
}
async function F(e2, t2, n2, r2, s3, a3) {
  const u4 = await G2(e2, t2, n2, s3, a3), c4 = await G2(e2, t2, r2, s3, a3), m4 = i(n2), p3 = m4.fractional, f2 = j;
  let y3 = m4.integer, b = null, d2 = null;
  n2 > 0 && n2 < 1 && (b = 10 ** p3, y3 = i(n2 *= b).integer);
  for (let o = y3 - 1; o >= 0; o--) {
    const r3 = 10 ** o;
    let m5 = Math.floor(n2 / r3) * r3, p4 = Math.ceil(n2 / r3) * r3;
    null != b && (m5 /= b, p4 /= b);
    let y4 = (m5 + p4) / 2;
    [, y4] = u2([m5, y4, p4], { indexes: [1] });
    const h2 = await G2(e2, t2, m5, s3, a3), w3 = await G2(e2, t2, p4, s3, a3), S4 = await G2(e2, t2, y4, s3, a3), g3 = l2(u4, h2, c4, null), v4 = l2(u4, w3, c4, null), z2 = l2(u4, S4, c4, null);
    let k3 = g3.previous <= f2, j2 = v4.previous <= f2;
    if (k3 && j2 && (g3.previous <= v4.previous ? (k3 = true, j2 = false) : (j2 = true, k3 = false)), k3 ? d2 = [m5, h2] : j2 ? d2 = [p4, w3] : z2.previous <= f2 && (d2 = [y4, S4]), d2) break;
  }
  return d2;
}
async function G2(e2, t2, l3, o, i3) {
  const { getSize: n2 } = await import("./visualVariableUtils-YHLE7DFA.js");
  return n2(e2, l3, { scale: o, view: i3, shape: "simple-marker" === t2.type ? t2.style : null });
}
function J(e2, t2, l3, o) {
  "univariate-color-size" === l3?.authoringInfo?.type && "above-and-below" === l3?.authoringInfo?.univariateTheme && "class-breaks" === l3.type && (e2 = q(l3, o));
  const i3 = e2.clone();
  if (S(i3)) h(i3) || i3.symbolLayers.forEach((e3) => {
    "fill" !== e3.type && (e3.size = t2);
  });
  else if (V2(i3)) i3.size = t2;
  else if (x(i3)) {
    const e3 = i3.width, l4 = i3.height;
    i3.height = t2, i3.width = t2 * (e3 / l4);
  } else M(i3) ? i3.width = t2 : U(i3) ? i3.font && (i3.font.size = t2) : "cim" === i3.type && c(l3, "reference-size") ? v(i3, { innerDotSize: t2, outerRingSize: g2 }) : "cim" === i3.type && c(l3, "spike") && v2(i3, { defaultHeight: t2, primitiveOverrides: null });
  return i3;
}

export {
  v,
  w2 as w,
  S3 as S,
  L2 as L,
  T
};
//# sourceMappingURL=chunk-GE7JRJOL.js.map
