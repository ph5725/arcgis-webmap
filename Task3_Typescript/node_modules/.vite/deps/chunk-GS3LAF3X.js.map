{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js", "../../@arcgis/core/chunks/LineCallout.glsl.js"],
  "sourcesContent": ["/*\r\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\r\nSee https://js.arcgis.com/4.33/esri/copyright.txt for details.\r\n*/\r\nimport{ReadDepth as e}from\"../output/ReadDepth.glsl.js\";import{glsl as t}from\"../../shaderModules/glsl.js\";import{Texture2DBindUniform as o}from\"../../shaderModules/Texture2DBindUniform.js\";function r(r){r.include(e),r.uniforms.add(new o(\"geometryDepthTexture\",(e=>e.geometryDepth?.attachment))),r.code.add(t`bool geometryDepthTest(vec2 pos, float elementDepth) {\r\nfloat geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos);\r\nreturn (elementDepth < (geometryDepth - 1.0));\r\n}`)}export{r as multipassGeometryTest};\r\n", "/*\r\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\r\nSee https://js.arcgis.com/4.33/esri/copyright.txt for details.\r\n*/\r\nimport{set as e}from\"../core/libs/gl-matrix-2/math/vec2.js\";import{create as i}from\"../core/libs/gl-matrix-2/factories/vec2f64.js\";import{ZEROS as r}from\"../core/libs/gl-matrix-2/factories/vec4f64.js\";import{RejectBySlice as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{AlignPixel as t}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";import{HUD as n}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";import{HUDVisibility as a}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js\";import{multipassGeometryTest as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";import{addScreenSizePerspectiveAlignment as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";import{Float2BindUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{Float2PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4BindUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";import{Float4PassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{If as v,glsl as S}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{VertexAttribute as m}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{ShaderBuilder as w}from\"../views/webgl/ShaderBuilder.js\";function h(i){const h=new w,{vertex:b,fragment:z}=h,{terrainDepthTest:x}=i;return b.include(t),h.include(n,i),h.vertex.include(o,i),h.attributes.add(m.UV0,\"vec2\"),b.uniforms.add(new p(\"viewport\",(e=>e.camera.fullViewport)),new f(\"lineSize\",((e,i)=>e.size>0?Math.max(1,e.size)*i.camera.pixelRatio:0)),new s(\"pixelToNDC\",(i=>e(u,2/i.camera.fullViewport[2],2/i.camera.fullViewport[3]))),new f(\"borderSize\",((e,i)=>e.borderColor?i.camera.pixelRatio:0)),new c(\"screenOffset\",((i,r)=>e(u,i.horizontalScreenOffset*r.camera.pixelRatio,0)))),h.varyings.add(\"coverageSampling\",\"vec4\"),h.varyings.add(\"lineSizes\",\"vec2\"),x&&h.varyings.add(\"depth\",\"float\"),i.occlusionTestEnabled&&h.include(a),i.hasScreenSizePerspective&&d(b),b.main.add(S`\r\n    ProjectHUDAux projectAux;\r\n    vec4 endPoint = projectPositionHUD(projectAux);\r\n\r\n    vec3 vpos = projectAux.posModel;\r\n    if (rejectBySlice(vpos)) {\r\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\r\n      return;\r\n    }\r\n    ${v(i.occlusionTestEnabled,S`if (!testHUDVisibility(endPoint)) {\r\n             gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\r\n             return;\r\n           }`)}\r\n\r\n    ${i.hasScreenSizePerspective?S`vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\r\n               vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);`:\"vec2 screenOffsetScaled = screenOffset;\"}\r\n    // Add view dependent polygon offset to get exact same original starting point. This is mostly used to get the\r\n    // correct depth value\r\n    vec3 posView = (view * vec4(position, 1.0)).xyz;\r\n    ${v(x,\"depth = posView.z;\")}\r\n\r\n    applyHUDViewDependentPolygonOffset(centerOffsetAndDistance.w, projectAux.absCosAngle, posView);\r\n    vec4 startPoint = proj * vec4(posView, 1.0);\r\n\r\n    // Apply screen offset to both start and end point\r\n    vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\r\n    startPoint.xy += screenOffsetNorm * startPoint.w;\r\n    endPoint.xy += screenOffsetNorm * endPoint.w;\r\n\r\n    // Align start and end to pixel origin\r\n    vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\r\n    vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\r\n    ${v(i.hudDepth,i.hudDepthAlignStart?\"endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\":\"startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\")}\r\n    vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\r\n\r\n    // The direction of the line in screen space\r\n    vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\r\n    vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\r\n    ${i.hasScreenSizePerspective?S`float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\r\n               float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);`:S`float lineSizeScaled = lineSize;\r\n               float borderSizeScaled = borderSize;`}\r\n    float halfPixelSize = lineSizeScaled * 0.5;\r\n\r\n    // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\r\n    float padding = 1.0 + borderSizeScaled;\r\n    vec2 ndcOffset = (-halfPixelSize - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\r\n\r\n    // Offset x/y from the center of the line in screen space\r\n    projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\r\n\r\n    // Compute a coverage varying which we can use in the fragment shader to determine\r\n    // how much a pixel is actually covered by the line (i.e. to anti alias the line).\r\n    // This works by computing two coordinates that can be linearly interpolated and then\r\n    // subtracted to find out how far away from the line edge we are.\r\n    float edgeDirection = (uv0.x * 2.0 - 1.0);\r\n\r\n    float halfBorderSize = 0.5 * borderSizeScaled;\r\n    float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\r\n    float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\r\n\r\n    float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\r\n\r\n    coverageSampling = vec4(\r\n      // Edge coordinate\r\n      outerEdgeCoverageSampler,\r\n\r\n      // Border edge coordinate\r\n      outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\r\n\r\n      // Line offset\r\n      halfPixelSize - 0.5,\r\n\r\n      // Border offset\r\n      halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\r\n    );\r\n\r\n    lineSizes = vec2(lineSizeScaled, borderSizeScaled);\r\n    gl_Position = projectedPosition;`),z.uniforms.add(new g(\"uColor\",(e=>e.color??r)),new g(\"borderColor\",(e=>e.borderColor??r))),x&&(z.include(l,i),z.uniforms.add(new s(\"inverseViewport\",(e=>e.inverseViewport)))),z.main.add(S`\r\n    ${v(x,\"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\")}\r\n\r\n    vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\r\n\r\n    float borderAlpha = uColor.a * borderColor.a * coverage.y;\r\n    float colorAlpha = uColor.a * coverage.x;\r\n\r\n    float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\r\n    ${v(!i.hudDepth,S`vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\r\n           fragColor = vec4(finalRgb, finalAlpha);`)}`),h}const u=i(),b=Object.freeze(Object.defineProperty({__proto__:null,build:h},Symbol.toStringTag,{value:\"Module\"}));export{b as L,h as b};\r\n"],
  "mappings": "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",
  "names": ["r", "o", "e", "n", "i", "h", "b", "o", "e", "u", "r", "n"]
}
