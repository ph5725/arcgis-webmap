import {
  m as m2,
  m2 as m3,
  m3 as m4,
  n,
  y
} from "./chunk-U3MD377S.js";
import {
  g
} from "./chunk-2B6XECE5.js";
import {
  p as p2,
  s
} from "./chunk-JMXPE5PE.js";
import {
  u
} from "./chunk-6QTMK7BB.js";
import {
  r as r2
} from "./chunk-EOMIFMDH.js";
import {
  f as f2
} from "./chunk-N3A2BVTW.js";
import {
  l as l2
} from "./chunk-IGYEHOTB.js";
import {
  a as a2
} from "./chunk-TVM3SZJR.js";
import {
  p
} from "./chunk-LMEOPAGQ.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import {
  w
} from "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  o
} from "./chunk-3NBBZ43U.js";
import {
  i2 as i
} from "./chunk-XWG6QGFK.js";

// node_modules/@arcgis/core/rest/support/AttributeBinsQuery.js
var b = new o({ asc: "ascending", desc: "descending" });
var B = { base: y, key: "type", typeMap: { "auto-interval": m2, date: m3, "fixed-boundaries": n, "fixed-interval": m4 } };
var R = class extends a2.ClonableMixin(l) {
  constructor(e) {
    super(e), this.binParameters = null, this.binOrder = "ascending", this.cacheHint = void 0, this.datumTransformation = null, this.defaultSpatialReference = null, this.distance = void 0, this.geometry = null, this.lowerBoundaryAlias = null, this.outSpatialReference = null, this.outStatistics = null, this.returnDistinctValues = null, this.spatialRelationship = "intersects", this.timeExtent = null, this.upperBoundaryAlias = null, this.units = null, this.where = "1=1";
  }
  set outTimeZone(e) {
    this._set("outTimeZone", e), e && !p(e) && i.getLogger(this).warn("#outTimeZone", `the parsed value '${e}' may not be a valid IANA time zone`);
  }
};
r([m({ types: B, json: { name: "bin", write: true } })], R.prototype, "binParameters", void 0), r([r2(b)], R.prototype, "binOrder", void 0), r([m({ type: Boolean, json: { write: true } })], R.prototype, "cacheHint", void 0), r([m({ json: { write: true } })], R.prototype, "datumTransformation", void 0), r([m({ type: f, json: { name: "defaultSR", write: true } })], R.prototype, "defaultSpatialReference", void 0), r([m({ type: Number, json: { write: { overridePolicy: (e) => ({ enabled: e > 0 }) } } })], R.prototype, "distance", void 0), r([m({ types: l2, json: { read: f2, write: true } })], R.prototype, "geometry", void 0), r([m({ type: String, json: { write: true } })], R.prototype, "lowerBoundaryAlias", void 0), r([m({ type: f, json: { name: "outSR", write: true } })], R.prototype, "outSpatialReference", void 0), r([m({ type: [p2], json: { write: { enabled: true, overridePolicy() {
  return { enabled: null != this.outStatistics && this.outStatistics.length > 0 };
} } } })], R.prototype, "outStatistics", void 0), r([m({ value: null, json: { name: "outTimeReference", read: { reader: (e) => e.ianaTimeZone }, write: { writer: (e, t, o2) => {
  e && (t[o2] = { ianaTimeZone: e });
} } } })], R.prototype, "outTimeZone", null), r([m({ type: Boolean, json: { write: true } })], R.prototype, "returnDistinctValues", void 0), r([r2(s, { name: "spatialRel" })], R.prototype, "spatialRelationship", void 0), r([m({ type: u, json: { write: true } })], R.prototype, "timeExtent", void 0), r([m({ type: String, json: { write: true } })], R.prototype, "upperBoundaryAlias", void 0), r([m({ type: String, json: { read: g.read, write: { writer: g.write, overridePolicy(e) {
  return { enabled: null != e && null != this.distance };
} } } })], R.prototype, "units", void 0), r([m({ type: String, json: { write: true } })], R.prototype, "where", void 0), R = r([a("esri.rest.support.AttributeBinsQuery")], R), R.from = w(R);

export {
  R
};
//# sourceMappingURL=chunk-I3A6CJVF.js.map
