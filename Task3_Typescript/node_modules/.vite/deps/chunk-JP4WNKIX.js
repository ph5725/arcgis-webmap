import {
  t
} from "./chunk-VQ6WKTQP.js";
import {
  w2 as w
} from "./chunk-OFHPFWHF.js";
import {
  c as c2
} from "./chunk-AGDHKBKD.js";
import {
  N
} from "./chunk-KJSBBQ22.js";
import {
  u
} from "./chunk-S7IJH524.js";
import {
  c
} from "./chunk-FXKORAMT.js";

// node_modules/@arcgis/core/widgets/Legend/support/heatmapRampUtils.js
function r(r2) {
  if (!r2.colorStops) return [];
  const e = [...r2.colorStops].filter((o) => o.color?.a > 0);
  let t2 = e.length - 1;
  if (e && e[0]) {
    const r3 = e[t2];
    r3 && 1 !== r3.ratio && (e.push(new c2({ ratio: 1, color: r3.color })), t2++);
  }
  return e.map((o, e2) => {
    let l = "";
    return 0 === e2 ? l = r2.legendOptions?.minLabel || "low" : e2 === t2 && (l = r2.legendOptions?.maxLabel || "high"), { color: o.color, label: l, ratio: o.ratio };
  }).reverse();
}

// node_modules/@arcgis/core/renderers/support/utils.js
var v = N("short-date");
async function w2(e, l, t2) {
  u(e, l, () => []).push(...t2);
}
async function x(l) {
  const t2 = /* @__PURE__ */ new Map();
  if (!l) return t2;
  if ("visualVariables" in l && l.visualVariables) {
    for (const e of l.visualVariables) if (D(e)) {
      const l2 = (await t(e) ?? []).map((e2) => e2.color);
      await w2(t2, e.field || e.valueExpression, l2);
    }
  }
  if ("heatmap" === l.type) {
    const e = r(l).map((e2) => e2.color);
    await w2(t2, l.field || l.valueExpression, e);
  } else if ("pie-chart" === l.type) {
    for (const e of l.attributes) await w2(t2, e.field || e.valueExpression, [e.color]);
    await w2(t2, "default", [l?.othersCategory?.color, w(l.backgroundFillSymbol, null)]);
  } else if ("dot-density" === l.type) {
    for (const e of l.attributes) await w2(t2, e.field || e.valueExpression, [e.color]);
    await w2(t2, "default", [l.backgroundColor]);
  } else if ("unique-value" === l.type) if ("predominance" === l.authoringInfo?.type) for (const e of l.uniqueValueInfos ?? []) await w2(t2, e.value.toString(), [w(e.symbol, null)]);
  else {
    const e = (l.uniqueValueInfos ?? []).map((e2) => w(e2.symbol, null)), { field: i2, field2: o, field3: a2, valueExpression: n } = l;
    (i2 || n) && await w2(t2, i2 || n, e), o && await w2(t2, o, e), a2 && await w2(t2, a2, e);
  }
  else if ("class-breaks" === l.type) {
    const e = l.classBreakInfos.map((e2) => w(e2.symbol, null)), { field: i2, valueExpression: o } = l;
    await w2(t2, i2 ?? o, e);
  } else "simple" === l.type && await w2(t2, "default", [w(l.symbol, null)]);
  return "defaultSymbol" in l && l.defaultSymbol && await w2(t2, "default", [w(l.defaultSymbol, null)]), t2.forEach((l2, i2) => {
    const o = c(l2.filter(Boolean), (e, l3) => JSON.stringify(e) === JSON.stringify(l3));
    t2.set(i2, o);
  }), t2;
}
function D(e) {
  return "color" === e.type;
}

export {
  r,
  x
};
//# sourceMappingURL=chunk-JP4WNKIX.js.map
