import {
  u
} from "./chunk-PVI3IOCA.js";
import {
  q,
  s as s3
} from "./chunk-FPSA4NFH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  d
} from "./chunk-OXSERRAR.js";
import {
  s as s4
} from "./chunk-KTUX3OKX.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2
} from "./chunk-JUAD7TJ6.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  o
} from "./chunk-3NBBZ43U.js";
import {
  s as s2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import {
  a
} from "./chunk-GWNLQRNM.js";
import {
  has,
  t
} from "./chunk-FXKORAMT.js";

// node_modules/@arcgis/core/layers/support/SimpleBandStatistics.js
var l2 = class {
  constructor(l5 = null, a6 = null, t2 = null) {
    this.minValue = l5, this.maxValue = a6, this.noDataValue = t2;
  }
};

// node_modules/@arcgis/core/layers/support/PixelBlock.js
var p;
var c = p = class extends l {
  static createEmptyBand(t2, e) {
    return new (p.getPixelArrayConstructor(t2))(e);
  }
  static combineBandMasks(t2) {
    if (t2.length < 2) return t2[0];
    const e = t2[0].length, s7 = new Uint8Array(e).fill(255);
    for (let i5 = 0; i5 < t2.length; i5++) {
      const l5 = t2[i5];
      for (let t3 = 0; t3 < e; t3++) l5[t3] || (s7[t3] = 0);
    }
    return s7;
  }
  static getPixelArrayConstructor(t2) {
    let e;
    switch (t2) {
      case "u1":
      case "u2":
      case "u4":
      case "u8":
        e = Uint8Array;
        break;
      case "u16":
        e = Uint16Array;
        break;
      case "u32":
        e = Uint32Array;
        break;
      case "s8":
        e = Int8Array;
        break;
      case "s16":
        e = Int16Array;
        break;
      case "s32":
        e = Int32Array;
        break;
      case "f32":
      case "c64":
      case "c128":
      case "unknown":
        e = Float32Array;
        break;
      case "f64":
        e = Float64Array;
    }
    return e;
  }
  constructor(t2) {
    super(t2), this.width = null, this.height = null, this.pixelType = "f32", this.validPixelCount = null, this.mask = null, this.maskIsAlpha = false, this.premultiplyAlpha = false, this.statistics = null, this.depthCount = 1;
  }
  castPixelType(t2) {
    if (!t2) return "f32";
    let e = t2.toLowerCase();
    return ["u1", "u2", "u4"].includes(e) ? e = "u8" : ["unknown", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"].includes(e) || (e = "f32"), e;
  }
  getPlaneCount() {
    return this.pixels?.length;
  }
  addData(t2) {
    if (!t2.pixels || t2.pixels.length !== this.width * this.height) throw new s("pixelblock:invalid-or-missing-pixels", "add data requires valid pixels array that has same length defined by pixel block width * height");
    this.pixels || (this.pixels = []), this.statistics || (this.statistics = []), this.pixels.push(t2.pixels), this.statistics.push(t2.statistics ?? new l2());
  }
  getAsRGBA() {
    const t2 = new ArrayBuffer(this.width * this.height * 4);
    switch (this.pixelType) {
      case "s8":
      case "s16":
      case "u16":
      case "s32":
      case "u32":
      case "f32":
      case "f64":
        this._fillFromNon8Bit(t2);
        break;
      default:
        this._fillFrom8Bit(t2);
    }
    return new Uint8ClampedArray(t2);
  }
  getAsRGBAFloat() {
    const t2 = new Float32Array(this.width * this.height * 4);
    return this._fillFrom32Bit(t2), t2;
  }
  updateStatistics() {
    if (!this.pixels) return;
    this.statistics = this.pixels.map((t3) => u2(t3, this.mask));
    const t2 = this.mask;
    let e = 0;
    if (null != t2) for (let s7 = 0; s7 < t2.length; s7++) t2[s7] && e++;
    else e = this.width * this.height;
    this.validPixelCount = e;
  }
  clamp(t2) {
    if (!t2 || "f64" === t2 || "f32" === t2 || !this.pixels) return;
    const [e, s7] = u(t2), i5 = this.pixels, l5 = this.width * this.height, r4 = i5.length;
    let o4, n, a6;
    const c5 = [];
    for (let h4 = 0; h4 < r4; h4++) {
      a6 = p.createEmptyBand(t2, l5), o4 = i5[h4];
      for (let t3 = 0; t3 < l5; t3++) n = o4[t3], a6[t3] = n > s7 ? s7 : n < e ? e : n;
      c5.push(a6);
    }
    this.pixels = c5, this.pixelType = t2;
  }
  extractBands(t2) {
    const { pixels: e, statistics: s7 } = this;
    if (null == t2 || 0 === t2.length || !e || 0 === e.length) return this;
    const i5 = e.length, l5 = t2.some((t3) => t3 >= e.length), r4 = i5 === t2.length && !t2.some((t3, e2) => t3 !== e2);
    if (l5 || r4) return this;
    const o4 = this.bandMasks?.length === i5 ? t2.map((t3) => this.bandMasks[t3]) : void 0;
    let { mask: n, validPixelCount: a6 } = this;
    const { width: h4, height: c5 } = this;
    return o4?.length && (n = p.combineBandMasks(o4), a6 = n.filter((t3) => !!t3).length), new p({ pixelType: this.pixelType, width: h4, height: c5, mask: n, bandMasks: o4, validPixelCount: a6, maskIsAlpha: this.maskIsAlpha, pixels: t2.map((t3) => e[t3]), statistics: s7 && t2.map((t3) => s7[t3]) });
  }
  clone() {
    const t2 = new p({ width: this.width, height: this.height, pixelType: this.pixelType, maskIsAlpha: this.maskIsAlpha, validPixelCount: this.validPixelCount });
    let e;
    null != this.mask && (t2.mask = new Uint8Array(this.mask)), this.bandMasks && (t2.bandMasks = this.bandMasks.map((t3) => new Uint8Array(t3)));
    const s7 = p.getPixelArrayConstructor(this.pixelType);
    if (this.pixels && this.pixels.length > 0) {
      t2.pixels = [];
      const i5 = !!this.pixels[0].slice;
      for (e = 0; e < this.pixels.length; e++) t2.pixels[e] = i5 ? this.pixels[e].slice() : new s7(this.pixels[e]);
    }
    if (this.statistics) for (t2.statistics = [], e = 0; e < this.statistics.length; e++) t2.statistics[e] = a(this.statistics[e]);
    return t2.premultiplyAlpha = this.premultiplyAlpha, t2;
  }
  _fillFrom8Bit(t2) {
    const { mask: e, maskIsAlpha: s7, premultiplyAlpha: i5, pixels: r4 } = this;
    if (!t2 || !r4?.length) return void i.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    let o4, n, a6, h4;
    o4 = n = a6 = r4[0], r4.length >= 3 ? (n = r4[1], a6 = r4[2]) : 2 === r4.length && (n = r4[1]);
    const p5 = new Uint32Array(t2), c5 = this.width * this.height;
    if (o4.length === c5) if (null != e && e.length === c5) if (s7) for (h4 = 0; h4 < c5; h4++) {
      const t3 = e[h4];
      if (t3) {
        const e2 = t3 / 255;
        p5[h4] = i5 ? t3 << 24 | a6[h4] * e2 << 16 | n[h4] * e2 << 8 | o4[h4] * e2 : t3 << 24 | a6[h4] << 16 | n[h4] << 8 | o4[h4];
      }
    }
    else for (h4 = 0; h4 < c5; h4++) e[h4] && (p5[h4] = 255 << 24 | a6[h4] << 16 | n[h4] << 8 | o4[h4]);
    else for (h4 = 0; h4 < c5; h4++) p5[h4] = 255 << 24 | a6[h4] << 16 | n[h4] << 8 | o4[h4];
    else i.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
  }
  _fillFromNon8Bit(t2) {
    const { pixels: e, mask: s7, statistics: i5 } = this;
    if (!t2 || !e?.length) return void i.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    const r4 = this.pixelType;
    let o4 = 1, n = 0, a6 = 1;
    if (i5 && i5.length > 0) {
      for (const t3 of i5) if (null != t3.minValue && (n = Math.min(n, t3.minValue)), null != t3.maxValue && null != t3.minValue) {
        const e2 = t3.maxValue - t3.minValue;
        a6 = Math.max(a6, e2);
      }
      o4 = 255 / a6;
    } else {
      let t3 = 255;
      "s8" === r4 ? (n = -128, t3 = 127) : "u16" === r4 ? t3 = 65535 : "s16" === r4 ? (n = -32768, t3 = 32767) : "u32" === r4 ? t3 = 4294967295 : "s32" === r4 ? (n = -2147483648, t3 = 2147483647) : "f32" === r4 ? (n = -34e38, t3 = 34e38) : "f64" === r4 && (n = -Number.MAX_VALUE, t3 = Number.MAX_VALUE), o4 = 255 / (t3 - n);
    }
    const h4 = new Uint32Array(t2), p5 = this.width * this.height;
    let c5, u6, g4, f4, m5;
    if (c5 = u6 = g4 = e[0], c5.length !== p5) return i.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
    if (e.length >= 2) if (u6 = e[1], e.length >= 3 && (g4 = e[2]), null != s7 && s7.length === p5) for (f4 = 0; f4 < p5; f4++) s7[f4] && (h4[f4] = 255 << 24 | (g4[f4] - n) * o4 << 16 | (u6[f4] - n) * o4 << 8 | (c5[f4] - n) * o4);
    else for (f4 = 0; f4 < p5; f4++) h4[f4] = 255 << 24 | (g4[f4] - n) * o4 << 16 | (u6[f4] - n) * o4 << 8 | (c5[f4] - n) * o4;
    else if (null != s7 && s7.length === p5) for (f4 = 0; f4 < p5; f4++) m5 = (c5[f4] - n) * o4, s7[f4] && (h4[f4] = 255 << 24 | m5 << 16 | m5 << 8 | m5);
    else for (f4 = 0; f4 < p5; f4++) m5 = (c5[f4] - n) * o4, h4[f4] = 255 << 24 | m5 << 16 | m5 << 8 | m5;
  }
  _fillFrom32Bit(t2) {
    const { pixels: e, mask: s7 } = this;
    if (!t2 || !e?.length) return i.getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The input pixel block is empty.");
    let i5, r4, o4, n;
    i5 = r4 = o4 = e[0], e.length >= 3 ? (r4 = e[1], o4 = e[2]) : 2 === e.length && (r4 = e[1]);
    const a6 = this.width * this.height;
    if (i5.length !== a6) return i.getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The pixelblock is invalid.");
    let h4 = 0;
    if (null != s7 && s7.length === a6) for (n = 0; n < a6; n++) t2[h4++] = i5[n], t2[h4++] = r4[n], t2[h4++] = o4[n], t2[h4++] = 1 & s7[n];
    else for (n = 0; n < a6; n++) t2[h4++] = i5[n], t2[h4++] = r4[n], t2[h4++] = o4[n], t2[h4++] = 1;
  }
};
function u2(t2, e) {
  let s7 = 1 / 0, i5 = -1 / 0;
  const l5 = t2.length;
  let r4, o4 = 0;
  if (null != e) for (r4 = 0; r4 < l5; r4++) e[r4] && (o4 = t2[r4], s7 = o4 < s7 ? o4 : s7, i5 = o4 > i5 ? o4 : i5);
  else for (r4 = 0; r4 < l5; r4++) o4 = t2[r4], s7 = o4 < s7 ? o4 : s7, i5 = o4 > i5 ? o4 : i5;
  return new l2(s7, i5);
}
r([m({ json: { write: true } })], c.prototype, "width", void 0), r([m({ json: { write: true } })], c.prototype, "height", void 0), r([m({ json: { write: true } })], c.prototype, "pixelType", void 0), r([s4("pixelType")], c.prototype, "castPixelType", null), r([m({ json: { write: true } })], c.prototype, "validPixelCount", void 0), r([m({ json: { write: true } })], c.prototype, "mask", void 0), r([m({ json: { write: true } })], c.prototype, "maskIsAlpha", void 0), r([m({ json: { write: true } })], c.prototype, "pixels", void 0), r([m()], c.prototype, "premultiplyAlpha", void 0), r([m({ json: { write: true } })], c.prototype, "statistics", void 0), r([m({ json: { write: true } })], c.prototype, "depthCount", void 0), r([m({ json: { write: true } })], c.prototype, "noDataValues", void 0), r([m({ json: { write: true } })], c.prototype, "bandMasks", void 0), c = p = r([a2("esri.layers.support.PixelBlock")], c);

// node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js
var l3;
var i2;
!function(t2) {
  t2[t2.matchAny = 0] = "matchAny", t2[t2.matchAll = 1] = "matchAll";
}(l3 || (l3 = {})), function(t2) {
  t2[t2.bestMatch = 0] = "bestMatch", t2[t2.fail = 1] = "fail";
}(i2 || (i2 = {}));
var o2 = 9;
function r2(t2) {
  return null != t2 && t2.pixels?.length > 0;
}
function a3(t2) {
  if (!t2?.length || t2.some((t3) => !r2(t3))) return null;
  if (1 === t2.length) return t2[0]?.clone() ?? null;
  const n = t2, { width: l5, height: i5, pixelType: o4 } = n[0];
  if (n.some((t3) => t3.width !== l5 || t3.height !== i5)) return null;
  const s7 = n.map(({ mask: t3 }) => t3).filter((t3) => null != t3);
  let a6 = null;
  s7.length && (a6 = new Uint8Array(l5 * i5), a6.set(s7[0]), s7.length > 1 && y(s7.slice(1), a6));
  const h4 = [];
  n.forEach(({ pixels: t3 }) => h4.push(...t3));
  const f4 = n.map(({ statistics: t3 }) => t3).filter((t3) => t3?.length), c5 = [];
  return f4.forEach((t3) => c5.push(...t3)), new c({ pixelType: o4, width: l5, height: i5, mask: a6, pixels: h4, statistics: c5.length ? c5 : null });
}
function h(t2) {
  if (!t2) return;
  const e = t2.colormap;
  if (!e || 0 === e.length) return;
  const n = e.sort((t3, e2) => t3[0] - e2[0]), l5 = n[0][0] < 0 ? n[0][0] : 0, i5 = Math.max(256, n[n.length - 1][0] - l5 + 1), o4 = new Uint8Array(4 * i5), r4 = [], s7 = 5 === n[0].length;
  if (i5 > 65536) return n.forEach((t3) => {
    r4[t3[0] - l5] = s7 ? t3.slice(1) : t3.slice(1).concat([255]);
  }), { indexed2DColormap: r4, offset: l5, alphaSpecified: s7 };
  if (t2.fillUnspecified) {
    let t3 = n[0];
    for (let e2 = t3[0] - l5, r5 = 0; e2 < i5; e2++) o4[4 * e2] = t3[1], o4[4 * e2 + 1] = t3[2], o4[4 * e2 + 2] = t3[3], o4[4 * e2 + 3] = s7 ? t3[4] : 255, e2 === t3[0] - l5 && (t3 = r5 === n.length - 1 ? t3 : n[++r5]);
  } else for (let a6 = 0; a6 < n.length; a6++) {
    const t3 = n[a6], e2 = 4 * (t3[0] - l5);
    o4[e2] = t3[1], o4[e2 + 1] = t3[2], o4[e2 + 2] = t3[3], o4[e2 + 3] = s7 ? t3[4] : 255;
  }
  return { indexedColormap: o4, offset: l5, alphaSpecified: s7 };
}
function f(t2, e) {
  if (!r2(t2)) return t2;
  if (!e || !e.indexedColormap && !e.indexed2DColormap) return t2;
  const n = t2.clone(), l5 = n.pixels;
  let i5 = n.mask;
  const o4 = n.width * n.height;
  if (1 !== l5.length) return t2;
  const { indexedColormap: s7, indexed2DColormap: a6, offset: h4, alphaSpecified: f4 } = e, c5 = l5[0], u6 = new Uint8Array(c5.length), p5 = new Uint8Array(c5.length), x3 = new Uint8Array(c5.length);
  let m5, d5 = 0;
  if (s7) {
    const t3 = s7.length - 1;
    if (null != i5) for (let e2 = 0; e2 < o4; e2++) i5[e2] && (d5 = 4 * (c5[e2] - h4), d5 < h4 || d5 > t3 ? i5[e2] = 0 : (u6[e2] = s7[d5], p5[e2] = s7[d5 + 1], x3[e2] = s7[d5 + 2], i5[e2] = s7[d5 + 3]));
    else {
      i5 = new Uint8Array(o4);
      for (let e2 = 0; e2 < o4; e2++) d5 = 4 * (c5[e2] - h4), d5 < h4 || d5 > t3 ? i5[e2] = 0 : (u6[e2] = s7[d5], p5[e2] = s7[d5 + 1], x3[e2] = s7[d5 + 2], i5[e2] = s7[d5 + 3]);
      n.mask = i5;
    }
  } else if (a6) if (null != i5) for (let r4 = 0; r4 < o4; r4++) i5[r4] && (m5 = a6[c5[r4]], u6[r4] = m5[0], p5[r4] = m5[1], x3[r4] = m5[2], i5[r4] = m5[3]);
  else {
    i5 = new Uint8Array(o4);
    for (let t3 = 0; t3 < o4; t3++) m5 = a6[c5[t3]], u6[t3] = m5[0], p5[t3] = m5[1], x3[t3] = m5[2], i5[t3] = m5[3];
    n.mask = i5;
  }
  return n.pixels = [u6, p5, x3], n.statistics = null, n.pixelType = "u8", n.maskIsAlpha = f4, n;
}
function c2(t2, n) {
  if (!r2(t2)) return null;
  const { pixels: l5, mask: i5 } = t2, o4 = l5.length;
  let s7 = n.lut;
  const { offset: a6 } = n;
  s7 && 1 === s7[0].length && (s7 = l5.map(() => s7));
  const h4 = [], f4 = n.outputPixelType || "u8";
  for (let e = 0; e < o4; e++) {
    const t3 = u3(l5[e], i5, s7[e], a6 || 0, f4);
    h4.push(t3);
  }
  const c5 = new c({ width: t2.width, height: t2.height, pixels: h4, mask: i5, pixelType: f4 });
  return c5.updateStatistics(), c5;
}
function u3(t2, n, l5, i5, o4) {
  const r4 = t2.length, s7 = c.createEmptyBand(o4, r4);
  if (n) for (let e = 0; e < r4; e++) n[e] && (s7[e] = l5[t2[e] - i5]);
  else for (let e = 0; e < r4; e++) s7[e] = l5[t2[e] - i5];
  return s7;
}
function p2(t2, e) {
  if (!r2(t2)) return null;
  const n = t2.clone(), { pixels: l5 } = n, i5 = n.width * n.height, o4 = e.length, s7 = Math.floor(o4 / 2), a6 = e[Math.floor(s7)], h4 = l5[0], f4 = new Uint8Array(i5), c5 = new Uint8Array(i5), u6 = new Uint8Array(i5);
  let p5 = n.mask;
  const x3 = 4 === e[0].mappedColor.length;
  p5 || (p5 = new Uint8Array(i5), p5.fill(x3 ? 255 : 1), n.mask = p5);
  for (let r4 = 0; r4 < i5; r4++) if (p5[r4]) {
    const t3 = h4[r4];
    let n2 = false, l6 = s7, i6 = a6, x4 = 0, m5 = o4 - 1;
    for (; m5 - x4 > 1; ) {
      if (t3 === i6.value) {
        n2 = true;
        break;
      }
      t3 > i6.value ? x4 = l6 : m5 = l6, l6 = Math.floor((x4 + m5) / 2), i6 = e[Math.floor(l6)];
    }
    n2 || (t3 === e[x4].value ? (i6 = e[x4], n2 = true) : t3 === e[m5].value ? (i6 = e[m5], n2 = true) : t3 < e[x4].value ? n2 = false : t3 > e[x4].value && (t3 < e[m5].value ? (i6 = e[x4], n2 = true) : m5 === o4 - 1 ? n2 = false : (i6 = e[m5], n2 = true))), n2 ? (f4[r4] = i6.mappedColor[0], c5[r4] = i6.mappedColor[1], u6[r4] = i6.mappedColor[2], p5[r4] = i6.mappedColor[3]) : f4[r4] = c5[r4] = u6[r4] = p5[r4] = 0;
  }
  return n.pixels = [f4, c5, u6], n.mask = p5, n.pixelType = "u8", n.maskIsAlpha = x3, n;
}
function x(e, n, l5 = false) {
  const i5 = 1e-5, r4 = new Float32Array(3 * o2), s7 = n.length;
  for (let a6 = 0; a6 < o2; a6++) r4[3 * a6] = e[2 * a6] ?? q - 1, r4[3 * a6 + 1] = e[2 * a6 + 1] ?? q, r4[3 * a6 + 2] = n[a6] ?? 0, a6 < s7 && (a6 > 0 && (r4[3 * a6] -= i5), e[2 * a6 + 1] !== e[2 * a6] && (a6 < s7 - 1 || !l5) && (r4[3 * a6 + 1] -= i5));
  return r4;
}
function m2(t2, l5) {
  if (!r2(t2)) return null;
  const { width: i5, height: o4 } = t2, { inputRanges: s7, outputValues: a6, outputPixelType: h4, noDataRanges: f4, allowUnmatched: c5, replacementValue: u6, isLastInputRangeInclusive: p5 } = l5, x3 = t2.pixels[0], m5 = c.createEmptyBand(h4, x3.length), d5 = t2.mask, g4 = new Uint8Array(i5 * o4);
  d5 ? g4.set(d5) : g4.fill(255);
  const y4 = t2.pixelType.startsWith("f") ? 1e-6 : 0, w4 = s7.map((t3) => t3 - y4);
  w4[0] = s7[0], w4[w4.length - 1] = s7[s7.length - 1] + (p5 ? 1e-6 : 0);
  const k3 = s7.length / 2, [M3, A3] = u(h4);
  for (let e = 0; e < o4; e++) for (let t3 = 0; t3 < i5; t3++) {
    const n = e * i5 + t3;
    if (g4[n]) {
      const t4 = x3[n];
      let e2 = false;
      for (let l6 = k3 - 1; l6 >= 0; l6--) if (t4 === s7[2 * l6] || t4 > w4[2 * l6] && t4 < w4[2 * l6 + 1]) {
        m5[n] = a6[l6], e2 = true;
        break;
      }
      e2 || (c5 ? m5[n] = t4 > A3 ? A3 : t4 < M3 ? M3 : u6 ?? t4 : g4[n] = 0);
    }
  }
  const U3 = f4?.length;
  if (U3) for (let e = 0; e < o4; e++) for (let t3 = 0; t3 < i5; t3++) {
    const n = e * i5 + t3;
    if (!d5 || d5[n]) {
      const t4 = x3[n];
      for (let e2 = 0; e2 < U3; e2 += 2) if (t4 >= f4[e2] && t4 <= f4[e2 + 1]) {
        m5[n] = 0, g4[n] = 0;
        break;
      }
    }
  }
  return new c({ width: i5, height: o4, pixelType: h4, pixels: [m5], mask: g4 });
}
function d2(t2, e, n, l5) {
  const i5 = null != n && n.length >= 2 ? new Set(n) : null, o4 = 1 === n?.length ? n[0] : null, r4 = !!e?.length;
  for (let s7 = 0; s7 < t2.length; s7++) if (l5[s7]) {
    const n2 = t2[s7];
    if (r4) {
      let t3 = false;
      for (let l6 = 0; l6 < e.length; l6 += 2) if (n2 >= e[l6] && n2 <= e[l6 + 1]) {
        t3 = true;
        break;
      }
      t3 || (l5[s7] = 0);
    }
    l5[s7] && (n2 === o4 || i5?.has(n2)) && (l5[s7] = 0);
  }
}
function g(t2, e) {
  const n = t2[0].length;
  for (let l5 = 0; l5 < n; l5++) if (e[l5]) {
    let n2 = false;
    for (let e2 = 0; e2 < t2.length; e2++) if (t2[e2][l5]) {
      n2 = true;
      break;
    }
    n2 || (e[l5] = 0);
  }
}
function y(t2, e) {
  const n = t2[0].length;
  for (let l5 = 0; l5 < n; l5++) if (e[l5]) {
    let n2 = false;
    for (let e2 = 0; e2 < t2.length; e2++) if (0 === t2[e2][l5]) {
      n2 = true;
      break;
    }
    n2 && (e[l5] = 0);
  }
}
function w(t2, n) {
  if (!r2(t2)) return null;
  const { width: l5, height: i5, pixels: o4 } = t2, s7 = l5 * i5, a6 = new Uint8Array(s7);
  t2.mask ? a6.set(t2.mask) : a6.fill(255);
  const h4 = o4.length, { includedRanges: f4, noDataValues: c5, outputPixelType: p5, matchAll: x3, lookups: m5 } = n;
  if (m5) {
    const t3 = [];
    for (let e = 0; e < h4; e++) {
      const n2 = m5[e], l6 = u3(o4[e], a6, n2.lut, n2.offset || 0, "u8");
      t3.push(l6);
    }
    1 === t3.length ? a6.set(t3[0]) : x3 ? g(t3, a6) : y(t3, a6);
  } else if (x3) {
    const t3 = [];
    for (let e = 0; e < h4; e++) {
      const n2 = new Uint8Array(s7);
      n2.set(a6), d2(o4[e], f4?.slice(2 * e, 2 * e + 2), c5?.[e], n2), t3.push(n2);
    }
    1 === t3.length ? a6.set(t3[0]) : g(t3, a6);
  } else for (let e = 0; e < h4; e++) d2(o4[e], f4?.slice(2 * e, 2 * e + 2), c5?.[e], a6);
  return new c({ width: l5, height: i5, pixelType: p5, pixels: o4, mask: a6 });
}
function k(t2) {
  const { srcPixelType: l5, inputRanges: i5, outputValues: o4, allowUnmatched: r4, noDataRanges: s7, isLastInputRangeInclusive: a6, outputPixelType: h4 } = t2;
  if ("u8" !== l5 && "s8" !== l5 && "u16" !== l5 && "s16" !== l5) return null;
  const f4 = l5.includes("16") ? 65536 : 256, c5 = l5.includes("s") ? -f4 / 2 : 0, u6 = c.createEmptyBand(h4, f4), p5 = new Uint8Array(f4);
  r4 && p5.fill(255);
  const [x3, m5] = u(h4);
  if (i5?.length && o4?.length) {
    const t3 = 1e-6, e = i5.map((e2) => e2 - t3);
    e[0] = i5[0], a6 && (e[e.length - 1] = i5[i5.length - 1]);
    for (let n = 0; n < e.length; n++) {
      const t4 = o4[n] > m5 ? m5 : o4[n] < x3 ? x3 : o4[n], l6 = Math.ceil(e[2 * n] - c5), r5 = i5[2 * n + 1] === i5[2 * n] ? l6 : Math.floor(e[2 * n + 1] - c5);
      for (let e2 = l6; e2 <= r5; e2++) u6[e2] = t4, p5[e2] = 255;
    }
  }
  if (s7?.length) for (let e = 0; e < s7.length; e++) {
    const t3 = Math.ceil(s7[2 * e] - c5), n = Math.floor(s7[2 * e + 1] - c5);
    for (let e2 = t3; e2 <= n; e2++) p5[e2] = 0;
  }
  return { lut: u6, offset: c5, mask: p5 };
}
function M(t2, e, n) {
  if ("u8" !== t2 && "s8" !== t2 && "u16" !== t2 && "s16" !== t2) return null;
  const l5 = t2.includes("16") ? 65536 : 256, i5 = t2.includes("s") ? -l5 / 2 : 0, o4 = new Uint8Array(l5);
  if (e) for (let r4 = 0; r4 < e.length; r4++) {
    const t3 = Math.ceil(e[2 * r4] - i5), n2 = Math.floor(e[2 * r4 + 1] - i5);
    for (let e2 = t3; e2 <= n2; e2++) o4[e2] = 255;
  }
  else o4.fill(255);
  if (n) for (let r4 = 0; r4 < n.length; r4++) o4[n[r4] - i5] = 0;
  return { lut: o4, offset: i5 };
}
function A(t2, e, n, l5, i5, o4, r4, s7) {
  return { xmin: i5 <= n * t2 ? 0 : i5 < n * t2 + t2 ? i5 - n * t2 : t2, ymin: o4 <= l5 * e ? 0 : o4 < l5 * e + e ? o4 - l5 * e : e, xmax: i5 + r4 <= n * t2 ? 0 : i5 + r4 < n * t2 + t2 ? i5 + r4 - n * t2 : t2, ymax: o4 + s7 <= l5 * e ? 0 : o4 + s7 < l5 * e + e ? o4 + s7 - l5 * e : e };
}
function U(t2, e) {
  if (!t2 || 0 === t2.length) return null;
  const n = t2.find((t3) => t3.pixelBlock);
  if (null == n?.pixelBlock) return null;
  const l5 = (n.extent.xmax - n.extent.xmin) / n.pixelBlock.width, i5 = (n.extent.ymax - n.extent.ymin) / n.pixelBlock.height, o4 = 0.01 * Math.min(l5, i5), r4 = t2.sort((t3, e2) => Math.abs(t3.extent.ymax - e2.extent.ymax) > o4 ? e2.extent.ymax - t3.extent.ymax : Math.abs(t3.extent.xmin - e2.extent.xmin) > o4 ? t3.extent.xmin - e2.extent.xmin : 0), s7 = Math.min.apply(null, r4.map((t3) => t3.extent.xmin)), a6 = Math.min.apply(null, r4.map((t3) => t3.extent.ymin)), h4 = Math.max.apply(null, r4.map((t3) => t3.extent.xmax)), f4 = Math.max.apply(null, r4.map((t3) => t3.extent.ymax)), c5 = { x: Math.round((e.xmin - s7) / l5), y: Math.round((f4 - e.ymax) / i5) }, u6 = { width: Math.round((h4 - s7) / l5), height: Math.round((f4 - a6) / i5) }, p5 = { width: Math.round((e.xmax - e.xmin) / l5), height: Math.round((e.ymax - e.ymin) / i5) };
  if (Math.round(u6.width / n.pixelBlock.width) * Math.round(u6.height / n.pixelBlock.height) !== r4.length || c5.x < 0 || c5.y < 0 || u6.width < p5.width || u6.height < p5.height) return null;
  return { extent: e, pixelBlock: T(r4.map((t3) => t3.pixelBlock), u6, { clipOffset: c5, clipSize: p5 }) };
}
function b(t2, e, n, l5, i5, o4) {
  const { width: r4, height: s7 } = n.block, { x: a6, y: h4 } = n.offset, { width: f4, height: c5 } = n.mosaic, u6 = A(r4, s7, l5, i5, a6, h4, f4, c5);
  let p5 = 0, x3 = 0;
  if (o4) {
    const t3 = o4.hasGCSSShiftTransform ? 360 : o4.halfWorldWidth ?? 0, e2 = r4 * o4.resolutionX, n2 = o4.startX + l5 * e2;
    n2 < t3 && n2 + e2 > t3 ? x3 = o4.rightPadding : n2 >= t3 && (p5 = o4.leftMargin - o4.rightPadding, x3 = 0);
  }
  if (u6.xmax -= x3, "number" != typeof e) for (let m5 = u6.ymin; m5 < u6.ymax; m5++) {
    const n2 = (i5 * s7 + m5 - h4) * f4 + (l5 * r4 - a6) + p5, o5 = m5 * r4;
    for (let l6 = u6.xmin; l6 < u6.xmax; l6++) t2[n2 + l6] = e[o5 + l6];
  }
  else for (let m5 = u6.ymin; m5 < u6.ymax; m5++) {
    const n2 = (i5 * s7 + m5 - h4) * f4 + (l5 * r4 - a6) + p5;
    for (let l6 = u6.xmin; l6 < u6.xmax; l6++) t2[n2 + l6] = e;
  }
}
function T(t2, n, l5 = {}) {
  const { clipOffset: i5, clipSize: o4, alignmentInfo: s7, blockWidths: a6 } = l5;
  if (a6) return v(t2, n, { blockWidths: a6 });
  const h4 = t2.find((t3) => r2(t3));
  if (null == h4) return null;
  const f4 = o4 ? o4.width : n.width, c5 = o4 ? o4.height : n.height, u6 = h4.width, p5 = h4.height, x3 = n.width / u6, m5 = n.height / p5, d5 = { offset: i5 || { x: 0, y: 0 }, mosaic: o4 || n, block: { width: u6, height: p5 } }, g4 = h4.pixelType, y4 = c.getPixelArrayConstructor(g4), w4 = h4.pixels.length, k3 = [];
  let M3, A3;
  for (let e = 0; e < w4; e++) {
    A3 = new y4(f4 * c5);
    for (let n2 = 0; n2 < m5; n2++) for (let l6 = 0; l6 < x3; l6++) {
      const i6 = t2[n2 * x3 + l6];
      r2(i6) && (M3 = i6.pixels[e], b(A3, M3, d5, l6, n2, s7));
    }
    k3.push(A3);
  }
  const U3 = t2.some((t3) => null == t3 || null != t3.mask && t3.mask.length > 0), T2 = t2.some((t3) => t3?.bandMasks && t3.bandMasks.length > 1), B2 = U3 ? new Uint8Array(f4 * c5) : void 0, S3 = T2 ? [] : void 0;
  if (B2) {
    for (let e = 0; e < m5; e++) for (let n2 = 0; n2 < x3; n2++) {
      const l6 = t2[e * x3 + n2], i6 = null != l6 ? l6.mask : null;
      b(B2, null != i6 ? i6 : l6 ? 255 : 0, d5, n2, e, s7);
    }
    if (S3) for (let e = 0; e < w4; e++) {
      const n2 = new Uint8Array(f4 * c5);
      for (let l6 = 0; l6 < m5; l6++) for (let i6 = 0; i6 < x3; i6++) {
        const o5 = t2[l6 * x3 + i6], r4 = o5?.bandMasks?.[e] ?? o5?.mask;
        b(n2, null != r4 ? r4 : o5 ? 255 : 0, d5, i6, l6, s7);
      }
      S3.push(n2);
    }
  }
  const C2 = new c({ width: f4, height: c5, pixels: k3, pixelType: g4, bandMasks: S3, mask: B2 });
  return C2.updateStatistics(), C2;
}
function v(t2, n, l5) {
  const i5 = t2.find((t3) => null != t3);
  if (null == i5) return null;
  const o4 = t2.some((t3) => null == t3 || !!t3.mask), { width: s7, height: a6 } = n, h4 = o4 ? new Uint8Array(s7 * a6) : null, { blockWidths: f4 } = l5, c5 = [], u6 = i5.getPlaneCount(), p5 = c.getPixelArrayConstructor(i5.pixelType);
  if (o4) for (let e = 0, y4 = 0; e < t2.length; y4 += f4[e], e++) {
    const n2 = t2[e];
    if (!r2(n2)) continue;
    const l6 = n2.mask;
    for (let t3 = 0; t3 < a6; t3++) for (let i6 = 0; i6 < f4[e]; i6++) h4[t3 * s7 + i6 + y4] = null == l6 ? 255 : l6[t3 * n2.width + i6];
  }
  const x3 = t2.some((t3) => t3?.bandMasks && t3.bandMasks.length > 1), m5 = x3 ? [] : void 0, d5 = s7 * a6;
  for (let e = 0; e < u6; e++) {
    const n2 = new p5(d5), l6 = x3 ? new Uint8Array(d5) : void 0;
    for (let i6 = 0, o5 = 0; i6 < t2.length; o5 += f4[i6], i6++) {
      const h5 = t2[i6];
      if (!r2(h5)) continue;
      const c6 = h5.pixels[e];
      if (null != c6) {
        for (let t3 = 0; t3 < a6; t3++) for (let e2 = 0; e2 < f4[i6]; e2++) n2[t3 * s7 + e2 + o5] = c6[t3 * h5.width + e2];
        if (l6) {
          const t3 = h5.bandMasks?.[e] ?? h5.mask;
          for (let e2 = 0; e2 < a6; e2++) for (let n3 = 0; n3 < f4[i6]; n3++) l6[e2 * s7 + n3 + o5] = t3 ? t3[e2 * h5.width + n3] : 255;
        }
      }
    }
    c5.push(n2), m5 && l6 && m5.push(l6);
  }
  const g4 = new c({ width: s7, height: a6, mask: h4, bandMasks: m5, pixels: c5, pixelType: i5.pixelType });
  return g4.updateStatistics(), g4;
}
function B(t2, e, n) {
  if (!r2(t2)) return null;
  const { width: l5, height: i5 } = t2, o4 = e.x, s7 = e.y, a6 = n.width + o4, h4 = n.height + s7;
  if (o4 < 0 || s7 < 0 || a6 > l5 || h4 > i5) return t2;
  if (0 === o4 && 0 === s7 && a6 === l5 && h4 === i5) return t2;
  t2.mask || (t2.mask = new Uint8Array(l5 * i5));
  const f4 = t2.mask;
  for (let r4 = 0; r4 < i5; r4++) {
    const t3 = r4 * l5;
    for (let e2 = 0; e2 < l5; e2++) f4[t3 + e2] = r4 < s7 || r4 >= h4 || e2 < o4 || e2 >= a6 ? 0 : 1;
  }
  return t2.updateStatistics(), t2;
}
function S(t2) {
  if (!r2(t2)) return null;
  const e = t2.clone(), { width: n, height: l5, pixels: i5 } = t2, o4 = i5[0], s7 = e.pixels[0], a6 = t2.mask;
  for (let r4 = 2; r4 < l5 - 1; r4++) {
    const t3 = /* @__PURE__ */ new Map();
    for (let l6 = r4 - 2; l6 < r4 + 2; l6++) for (let e3 = 0; e3 < 4; e3++) {
      const i6 = l6 * n + e3;
      _(t3, o4[i6], a6 ? a6[i6] : 1);
    }
    s7[r4 * n] = C(t3), s7[r4 * n + 1] = s7[r4 * n + 2] = s7[r4 * n];
    let e2 = 3;
    for (; e2 < n - 1; e2++) {
      let l6 = (r4 - 2) * n + e2 + 1;
      _(t3, o4[l6], a6 ? a6[l6] : 1), l6 = (r4 - 1) * n + e2 + 1, _(t3, o4[l6], a6 ? a6[l6] : 1), l6 = r4 * n + e2 + 1, _(t3, o4[l6], a6 ? a6[l6] : 1), l6 = (r4 + 1) * n + e2 + 1, _(t3, o4[l6], a6 ? a6[l6] : 1), l6 = (r4 - 2) * n + e2 - 3, P(t3, o4[l6], a6 ? a6[l6] : 1), l6 = (r4 - 1) * n + e2 - 3, P(t3, o4[l6], a6 ? a6[l6] : 1), l6 = r4 * n + e2 - 3, P(t3, o4[l6], a6 ? a6[l6] : 1), l6 = (r4 + 1) * n + e2 - 3, P(t3, o4[l6], a6 ? a6[l6] : 1), s7[r4 * n + e2] = C(t3);
    }
    s7[r4 * n + e2 + 1] = s7[r4 * n + e2];
  }
  for (let r4 = 0; r4 < n; r4++) s7[r4] = s7[n + r4] = s7[2 * n + r4], s7[(l5 - 1) * n + r4] = s7[(l5 - 2) * n + r4];
  return e.updateStatistics(), e;
}
function C(t2) {
  if (0 === t2.size) return 0;
  let e = 0, n = -1, l5 = 0;
  const i5 = t2.keys();
  let o4 = i5.next();
  for (; !o4.done; ) l5 = t2.get(o4.value), l5 > e && (n = o4.value, e = l5), o4 = i5.next();
  return n;
}
function P(t2, e, n) {
  if (0 === n) return;
  const l5 = t2.get(e);
  1 === l5 ? t2.delete(e) : t2.set(e, l5 - 1);
}
function _(t2, e, n) {
  0 !== n && t2.set(e, t2.has(e) ? t2.get(e) + 1 : 1);
}
function W(t2, n, l5) {
  let { x: i5, y: o4 } = n;
  const { width: s7, height: a6 } = l5;
  if (0 === i5 && 0 === o4 && a6 === t2.height && s7 === t2.width) return t2;
  const { width: h4, height: f4 } = t2, c5 = Math.max(0, o4), u6 = Math.max(0, i5), p5 = Math.min(i5 + s7, h4), x3 = Math.min(o4 + a6, f4);
  if (p5 < 0 || x3 < 0 || !r2(t2)) return null;
  i5 = Math.max(0, -i5), o4 = Math.max(0, -o4);
  const { pixels: m5 } = t2, d5 = s7 * a6, g4 = m5.length, y4 = [];
  for (let r4 = 0; r4 < g4; r4++) {
    const n2 = m5[r4], l6 = c.createEmptyBand(t2.pixelType, d5);
    for (let t3 = c5; t3 < x3; t3++) {
      const e = t3 * h4;
      let r5 = (t3 + o4 - c5) * s7 + i5;
      for (let t4 = u6; t4 < p5; t4++) l6[r5++] = n2[e + t4];
    }
    y4.push(l6);
  }
  const w4 = new Uint8Array(d5), k3 = t2.mask;
  for (let e = c5; e < x3; e++) {
    const t3 = e * h4;
    let n2 = (e + o4 - c5) * s7 + i5;
    for (let e2 = u6; e2 < p5; e2++) w4[n2++] = k3 ? k3[t3 + e2] : 1;
  }
  const M3 = new c({ width: l5.width, height: l5.height, pixelType: t2.pixelType, pixels: y4, mask: w4 });
  return M3.updateStatistics(), M3;
}
function E(t2, n = true) {
  if (!r2(t2)) return null;
  const { pixels: l5, width: i5, height: o4, mask: s7, pixelType: a6 } = t2, h4 = [], f4 = Math.round(i5 / 2), c5 = Math.round(o4 / 2), u6 = o4 - 1, p5 = i5 - 1;
  for (let r4 = 0; r4 < l5.length; r4++) {
    const t3 = l5[r4], s8 = c.createEmptyBand(a6, f4 * c5);
    let x4 = 0;
    for (let e = 0; e < o4; e += 2) for (let l6 = 0; l6 < i5; l6 += 2) {
      const o5 = t3[e * i5 + l6];
      if (n) {
        const n2 = l6 === p5 ? o5 : t3[e * i5 + l6 + 1], r5 = e === u6 ? o5 : t3[e * i5 + l6 + i5], a7 = l6 === p5 ? r5 : e === u6 ? n2 : t3[e * i5 + l6 + i5 + 1];
        s8[x4++] = (o5 + n2 + r5 + a7) / 4;
      } else s8[x4++] = o5;
    }
    h4.push(s8);
  }
  let x3 = null;
  if (null != s7) {
    x3 = new Uint8Array(f4 * c5);
    let t3 = 0;
    for (let e = 0; e < o4; e += 2) for (let l6 = 0; l6 < i5; l6 += 2) {
      const o5 = s7[e * i5 + l6];
      if (n) {
        const n2 = l6 === p5 ? o5 : s7[e * i5 + l6 + 1], r4 = e === u6 ? o5 : s7[e * i5 + l6 + i5], a7 = l6 === p5 ? r4 : e === u6 ? n2 : s7[e * i5 + l6 + i5 + 1];
        x3[t3++] = o5 * n2 * r4 * a7 ? 1 : 0;
      } else x3[t3++] = o5;
    }
  }
  return new c({ width: f4, height: c5, pixelType: a6, pixels: h4, mask: x3 });
}
function I(t2, e, n = 0, l5 = true) {
  if (!r2(t2)) return null;
  const { width: i5, height: o4 } = e;
  let { width: s7, height: a6 } = t2;
  const h4 = /* @__PURE__ */ new Map(), f4 = { x: 0, y: 0 }, c5 = 1 + n;
  let u6 = t2;
  for (let r4 = 0; r4 < c5; r4++) {
    const t3 = Math.ceil(s7 / i5), n2 = Math.ceil(a6 / o4);
    for (let l6 = 0; l6 < n2; l6++) {
      f4.y = l6 * o4;
      for (let n3 = 0; n3 < t3; n3++) {
        f4.x = n3 * i5;
        const t4 = W(u6, f4, e);
        h4.set(`${r4}/${l6}/${n3}`, t4);
      }
    }
    r4 < c5 - 1 && (u6 = E(u6, l5)), s7 = Math.round(s7 / 2), a6 = Math.round(a6 / 2);
  }
  return h4;
}
function R(t2) {
  const { pixelBlock: e, tileSize: n, level: l5, row: i5, col: o4, useBilinear: s7 } = t2;
  if (!r2(e)) return null;
  const { width: a6, height: h4 } = n, f4 = 2 ** l5, c5 = f4 * a6, u6 = f4 * h4;
  let p5 = W(e, { y: i5 * u6, x: o4 * c5 }, { width: c5, height: u6 });
  if (!p5) return null;
  for (let r4 = l5; r4 > 0; r4--) p5 = E(p5, s7);
  return p5;
}
function F(t2, e, n, l5, i5 = 0) {
  const { width: o4, height: r4 } = t2, { width: s7, height: a6 } = e, h4 = l5.cols, f4 = l5.rows, c5 = Math.ceil(s7 / h4 - 0.1 / h4), u6 = Math.ceil(a6 / f4 - 0.1 / f4);
  let p5, x3, m5, d5, g4, y4, w4;
  const k3 = c5 * h4, M3 = k3 * u6 * f4, A3 = new Float32Array(M3), U3 = new Float32Array(M3), b3 = new Uint32Array(M3), T2 = new Uint32Array(M3);
  let v3, B2, S3 = 0;
  for (let C2 = 0; C2 < u6; C2++) for (let t3 = 0; t3 < c5; t3++) {
    p5 = 12 * (C2 * c5 + t3), x3 = n[p5], m5 = n[p5 + 1], d5 = n[p5 + 2], g4 = n[p5 + 3], y4 = n[p5 + 4], w4 = n[p5 + 5];
    for (let e2 = 0; e2 < f4; e2++) {
      S3 = (C2 * f4 + e2) * k3 + t3 * h4, B2 = (e2 + 0.5) / f4;
      for (let t4 = 0; t4 < e2; t4++) v3 = (t4 + 0.5) / h4, A3[S3 + t4] = (x3 * v3 + m5 * B2 + d5) * o4 + i5, U3[S3 + t4] = (g4 * v3 + y4 * B2 + w4) * r4 + i5, b3[S3 + t4] = Math.floor(A3[S3 + t4]), T2[S3 + t4] = Math.floor(U3[S3 + t4]);
    }
    p5 += 6, x3 = n[p5], m5 = n[p5 + 1], d5 = n[p5 + 2], g4 = n[p5 + 3], y4 = n[p5 + 4], w4 = n[p5 + 5];
    for (let e2 = 0; e2 < f4; e2++) {
      S3 = (C2 * f4 + e2) * k3 + t3 * h4, B2 = (e2 + 0.5) / f4;
      for (let t4 = e2; t4 < h4; t4++) v3 = (t4 + 0.5) / h4, A3[S3 + t4] = (x3 * v3 + m5 * B2 + d5) * o4 + i5, U3[S3 + t4] = (g4 * v3 + y4 * B2 + w4) * r4 + i5, b3[S3 + t4] = Math.floor(A3[S3 + t4]), T2[S3 + t4] = Math.floor(U3[S3 + t4]);
    }
  }
  return { offsets_x: A3, offsets_y: U3, offsets_xi: b3, offsets_yi: T2, gridWidth: k3 };
}
function j(t2, e) {
  const { coefficients: n, spacing: l5 } = e, { offsets_x: i5, offsets_y: o4, gridWidth: r4 } = F(t2, t2, n, { rows: l5[0], cols: l5[1] }), { width: s7, height: a6 } = t2, h4 = new Float32Array(s7 * a6), f4 = 180 / Math.PI;
  for (let c5 = 0; c5 < a6; c5++) for (let t3 = 0; t3 < s7; t3++) {
    const e2 = c5 * r4 + t3, n2 = 0 === c5 ? e2 : e2 - r4, l6 = c5 === a6 - 1 ? e2 : e2 + r4, u6 = i5[n2] - i5[l6], p5 = o4[l6] - o4[n2];
    if (isNaN(u6) || isNaN(p5)) h4[c5 * s7 + t3] = 90;
    else {
      let e3 = Math.atan2(p5, u6) * f4;
      e3 = (360 + e3) % 360, h4[c5 * s7 + t3] = e3;
    }
  }
  return h4;
}
function D(t2, n, l5, i5, o4 = "nearest") {
  if (!r2(t2)) return null;
  "majority" === o4 && (t2 = S(t2));
  const { pixels: s7, mask: a6, bandMasks: h4, pixelType: f4 } = t2, c5 = t2.width, u6 = t2.height, p5 = c.getPixelArrayConstructor(f4), x3 = s7.length, { width: m5, height: d5 } = n;
  let g4 = false;
  for (let e = 0; e < l5.length; e += 3) -1 === l5[e] && -1 === l5[e + 1] && -1 === l5[e + 2] && (g4 = true);
  const { offsets_x: y4, offsets_y: w4, offsets_xi: k3, offsets_yi: M3, gridWidth: A3 } = F({ width: c5, height: u6 }, n, l5, i5, "majority" === o4 ? 0.5 : 0);
  let U3;
  const b3 = (t3, e, n2, l6) => {
    const i6 = t3 instanceof Float32Array || t3 instanceof Float64Array ? 0 : 0.5;
    for (let o5 = 0; o5 < d5; o5++) {
      U3 = o5 * A3;
      for (let r4 = 0; r4 < m5; r4++) {
        if (y4[U3] < 0 || w4[U3] < 0) t3[o5 * m5 + r4] = 0;
        else if (l6) t3[o5 * m5 + r4] = e[k3[U3] + M3[U3] * c5];
        else {
          const l7 = Math.floor(y4[U3]), s8 = Math.floor(w4[U3]), a7 = Math.ceil(y4[U3]), h5 = Math.ceil(w4[U3]), f5 = y4[U3] - l7, u7 = w4[U3] - s8;
          if (!n2 || n2[l7 + s8 * c5] && n2[a7 + s8 * c5] && n2[l7 + h5 * c5] && n2[a7 + h5 * c5]) {
            const n3 = (1 - f5) * e[l7 + s8 * c5] + f5 * e[a7 + s8 * c5], p6 = (1 - f5) * e[l7 + h5 * c5] + f5 * e[a7 + h5 * c5];
            t3[o5 * m5 + r4] = (1 - u7) * n3 + u7 * p6 + i6;
          } else t3[o5 * m5 + r4] = e[k3[U3] + M3[U3] * c5];
        }
        U3++;
      }
    }
  }, T2 = [];
  let v3;
  const B2 = h4?.length === x3, C2 = [];
  for (let e = 0; e < x3; e++) {
    if (B2) {
      const t3 = new Uint8Array(m5 * d5);
      b3(t3, h4[e], h4[e], true), C2.push(t3);
    }
    v3 = new p5(m5 * d5), b3(v3, s7[e], B2 ? h4[e] : a6, "nearest" === o4 || "majority" === o4), T2.push(v3);
  }
  const P3 = new c({ width: m5, height: d5, pixelType: f4, pixels: T2, bandMasks: B2 ? C2 : void 0 });
  if (null != a6) P3.mask = new Uint8Array(m5 * d5), b3(P3.mask, a6, a6, true);
  else if (g4) {
    P3.mask = new Uint8Array(m5 * d5);
    for (let t3 = 0; t3 < m5 * d5; t3++) P3.mask[t3] = y4[t3] < 0 || w4[t3] < 0 ? 0 : 1;
  }
  return P3.updateStatistics(), P3;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js
var r3 = /* @__PURE__ */ new Map();
r3.set("meter-per-second", 1), r3.set("kilometer-per-hour", 0.277778), r3.set("knots", 0.514444), r3.set("feet-per-second", 0.3048), r3.set("mile-per-hour", 0.44704);
var o3 = 180 / Math.PI;
var i3 = 5;
var s5 = new o({ esriMetersPerSecond: "meter-per-second", esriKilometersPerHour: "kilometer-per-hour", esriKnots: "knots", esriFeetPerSecond: "feet-per-second", esriMilesPerHour: "mile-per-hour" });
function a4(t2, e) {
  return r3.get(t2) / r3.get(e) || 1;
}
function h2(t2) {
  return (450 - t2) % 360;
}
function l4(t2, e = "geographic") {
  const [n, r4] = t2, i5 = Math.sqrt(n * n + r4 * r4);
  let s7 = Math.atan2(r4, n) * o3;
  return s7 = (360 + s7) % 360, "geographic" === e && (s7 = h2(s7)), [i5, s7];
}
function c3(t2, e = "geographic") {
  let n = t2[1];
  "geographic" === e && (n = h2(n)), n %= 360;
  const r4 = t2[0];
  return [r4 * Math.cos(n / o3), r4 * Math.sin(n / o3)];
}
function u4(t2, e, r4, o4 = "geographic") {
  if (!r2(t2) || null == r4) return t2;
  const i5 = "vector-magdir" === e ? t2.clone() : f2(t2, e), s7 = i5.pixels[1];
  for (let n = 0; n < s7.length; n++) s7[n] = "geographic" === o4 ? (s7[n] + r4[n] + 270) % 360 : (s7[n] + 360 - r4[n]) % 360;
  return "vector-magdir" === e ? i5 : f2(i5, "vector-magdir");
}
function f2(t2, r4, o4 = "geographic", i5 = 1) {
  if (!r2(t2)) return t2;
  const { pixels: s7, width: a6, height: h4 } = t2, u6 = a6 * h4, f4 = s7[0], p5 = s7[1], m5 = t2.pixelType.startsWith("f") ? t2.pixelType : "f32", d5 = c.createEmptyBand(m5, u6), g4 = c.createEmptyBand(m5, u6);
  let x3 = 0;
  for (let e = 0; e < h4; e++) for (let t3 = 0; t3 < a6; t3++) "vector-uv" === r4 ? ([d5[x3], g4[x3]] = l4([f4[x3], p5[x3]], o4), d5[x3] *= i5) : ([d5[x3], g4[x3]] = c3([f4[x3], p5[x3]], o4), d5[x3] *= i5, g4[x3] *= i5), x3++;
  const M3 = new c({ pixelType: m5, width: t2.width, height: t2.height, mask: t2.mask, validPixelCount: t2.validPixelCount, maskIsAlpha: t2.maskIsAlpha, pixels: [d5, g4] });
  return M3.updateStatistics(), M3;
}
function p3(t2, e, r4 = 1) {
  if (1 === r4 || !r2(t2)) return t2;
  const o4 = t2.clone(), { pixels: i5, width: s7, height: a6 } = o4, h4 = i5[0], l5 = i5[1];
  let c5 = 0;
  for (let n = 0; n < a6; n++) for (let t3 = 0; t3 < s7; t3++) "vector-uv" === e ? (h4[c5] *= r4, l5[c5] *= r4) : h4[c5] *= r4, c5++;
  return o4.updateStatistics(), o4;
}
function m3(t2, e, n, r4, o4) {
  if (null == o4 || !o4.spatialReference.equals(t2.spatialReference)) return { extent: t2, width: Math.round(e / r4), height: Math.round(n / r4), resolution: t2.width / e };
  const i5 = o4.xmin, s7 = o4.ymax, a6 = (t2.xmax - t2.xmin) / e * r4, h4 = (t2.ymax - t2.ymin) / n * r4, l5 = (a6 + h4) / 2;
  return t2.xmin = i5 + Math.floor((t2.xmin - i5) / a6) * a6, t2.xmax = i5 + Math.ceil((t2.xmax - i5) / a6) * a6, t2.ymin = s7 + Math.floor((t2.ymin - s7) / h4) * h4, t2.ymax = s7 + Math.ceil((t2.ymax - s7) / h4) * h4, { extent: t2, width: Math.round(t2.width / a6), height: Math.round(t2.height / h4), resolution: l5 };
}
var d3 = g2(0, 0, 0);
function g2(t2 = 0, e = 0, n = Math.PI, r4 = true) {
  r4 && (n = (2 * Math.PI - n) % (2 * Math.PI));
  const o4 = r4 ? -1 : 1, i5 = 13 * o4, s7 = -7 * o4, a6 = -2 * o4, h4 = -16 * o4, l5 = 21.75, [c5, u6] = M2(0, e + i5, n, l5), [f4, p5] = M2(t2 - 5.5, e + s7, n, l5), [m5, d5] = M2(t2 + 5.5, e + s7, n, l5), [g4, x3] = M2(t2 - 1.5, e + a6, n, l5), [k3, w4] = M2(t2 + 1.5, e + a6, n, l5), [y4, P3] = M2(t2 - 1.5, e + h4, n, l5), [b3, v3] = M2(t2 + 1.5, e + h4, n, l5);
  return [c5, u6, f4, p5, g4, x3, k3, w4, m5, d5, y4, P3, b3, v3];
}
function x2(t2 = 0, e = Math.PI, n = true) {
  n && (e = (2 * Math.PI - e) % (2 * Math.PI));
  const r4 = 10, o4 = n ? -1 : 1, s7 = 5 * o4, a6 = 20 * o4, h4 = 25 * o4, l5 = 45, c5 = 0, u6 = 0, f4 = 2, p5 = 0, m5 = f4 * o4, d5 = n ? 1 : -1, g4 = r4 / 2 * d5;
  let [x3, k3] = [c5 + g4, u6 - a6], [w4, y4] = [x3 + f4 * d5, k3], [P3, b3] = [w4 - p5 * d5, y4 + m5], [v3, I3] = [c5 - g4, u6 - h4], [A3, _3] = [v3 + p5 * d5, I3 - m5], U3 = Math.ceil(t2 / i3), S3 = Math.floor(U3 / 10);
  U3 -= 8 * S3;
  const D2 = [], F2 = [];
  for (let i5 = 0; i5 < U3 / 2; i5++, S3--) {
    S3 <= 0 && U3 % 2 == 1 && i5 === (U3 - 1) / 2 && (v3 = c5, A3 = v3 + p5 * d5, I3 = (I3 + k3) / 2, _3 = I3 - m5);
    const [t3, n2] = M2(v3, I3, e, l5);
    if (S3 > 0) {
      const [r5, o5] = M2(w4, I3, e, l5), [i6, s8] = M2(x3, k3, e, l5);
      D2.push(r5), D2.push(o5), D2.push(t3), D2.push(n2), D2.push(i6), D2.push(s8);
    } else {
      const [r5, o5] = M2(w4, y4, e, l5), [i6, s8] = M2(P3, b3, e, l5), [a7, h5] = M2(A3, _3, e, l5);
      F2.push(t3), F2.push(n2), F2.push(a7), F2.push(h5), F2.push(i6), F2.push(s8), F2.push(r5), F2.push(o5);
    }
    I3 += s7, k3 += s7, y4 += s7, b3 += s7, _3 += s7;
  }
  const [N, j2] = M2(c5 + g4, u6 + a6, e, l5), J = (r4 / 2 + f4) * d5, [O, q2] = M2(c5 + J, u6 + a6, e, l5), [B2, E2] = M2(c5 + g4, u6 - h4, e, l5), [T2, C2] = M2(c5 + J, u6 - h4, e, l5);
  return { pennants: D2, barbs: F2, shaft: [N, j2, O, q2, B2, E2, T2, C2] };
}
function M2(t2, e, n, r4 = 1) {
  const o4 = Math.sqrt(t2 * t2 + e * e) / r4, i5 = (2 * Math.PI + Math.atan2(e, t2)) % (2 * Math.PI);
  return [o4, (2 * Math.PI + i5 - n) % (2 * Math.PI)];
}
var k2 = [0, 1, 3, 6, 10, 16, 21, 27, 33, 40, 47, 55, 63];
var w2 = [0, 0.5, 1, 1.5, 2];
var y2 = [0, 0.25, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4];
function P2(t2, e, n, r4) {
  const o4 = a4(r4 || "knots", n);
  let i5;
  for (i5 = 1; i5 < e.length; i5++) if (i5 === e.length - 1) {
    if (t2 < e[i5] * o4) break;
  } else if (t2 <= e[i5] * o4) break;
  return Math.min(i5 - 1, e.length - 2);
}
function b2(t2, e, n, r4, o4) {
  let i5 = 0;
  switch (e) {
    case "beaufort_kn":
      i5 = P2(t2, k2, "knots", n);
      break;
    case "beaufort_km":
      i5 = P2(t2, k2, "kilometer-per-hour", n);
      break;
    case "beaufort_ft":
      i5 = P2(t2, k2, "feet-per-second", n);
      break;
    case "beaufort_m":
      i5 = P2(t2, k2, "meter-per-second", n);
      break;
    case "classified_arrow":
      i5 = P2(t2, o4 ?? [], r4, n);
      break;
    case "ocean_current_m":
      i5 = P2(t2, w2, "meter-per-second", n);
      break;
    case "ocean_current_kn":
      i5 = P2(t2, y2, "knots", n);
  }
  return i5;
}
function v2(t2, e) {
  const { style: n, inputUnit: r4, outputUnit: o4, breakValues: i5 } = e, a6 = s5.fromJSON(r4), h4 = s5.fromJSON(o4), l5 = 7 * 6, c5 = 15;
  let u6 = 0, f4 = 0;
  const { width: p5, height: m5, mask: x3 } = t2, M3 = t2.pixels[0], k3 = t2.pixels[1], w4 = null != x3 ? x3.filter((t3) => t3 > 0).length : p5 * m5, y4 = new Float32Array(w4 * l5), P3 = new Uint32Array(c5 * w4), v3 = e.invertDirection ? g2(0, 0, 0, false) : d3;
  for (let s7 = 0; s7 < m5; s7++) for (let t3 = 0; t3 < p5; t3++) {
    const e2 = s7 * p5 + t3;
    if (!x3 || x3[s7 * p5 + t3]) {
      const r5 = (k3[e2] + 360) % 360 / 180 * Math.PI, o5 = b2(M3[e2], n, a6, h4, i5);
      for (let n2 = 0; n2 < v3.length; n2 += 2) y4[u6++] = (t3 + 0.5) / p5, y4[u6++] = (s7 + 0.5) / m5, y4[u6++] = v3[n2], y4[u6++] = v3[n2 + 1] + r5, y4[u6++] = o5, y4[u6++] = M3[e2];
      const c6 = 7 * (u6 / l5 - 1);
      P3[f4++] = c6, P3[f4++] = c6 + 1, P3[f4++] = c6 + 2, P3[f4++] = c6 + 0, P3[f4++] = c6 + 4, P3[f4++] = c6 + 3, P3[f4++] = c6 + 0, P3[f4++] = c6 + 2, P3[f4++] = c6 + 3, P3[f4++] = c6 + 2, P3[f4++] = c6 + 5, P3[f4++] = c6 + 3, P3[f4++] = c6 + 5, P3[f4++] = c6 + 6, P3[f4++] = c6 + 3;
    }
  }
  return { vertexData: y4, indexData: P3 };
}
var I2 = [];
function A2(t2, e) {
  if (0 === I2.length) for (let i5 = 0; i5 < 30; i5++) I2.push(x2(5 * i5, 0, !e.invertDirection));
  const n = a4(s5.fromJSON(e.inputUnit), "knots"), { width: r4, height: o4, mask: h4 } = t2, l5 = t2.pixels[0], c5 = t2.pixels[1], u6 = 6, f4 = [], p5 = [];
  let m5 = 0, d5 = 0;
  for (let s7 = 0; s7 < o4; s7++) for (let t3 = 0; t3 < r4; t3++) {
    const e2 = s7 * r4 + t3, a6 = l5[e2] * n;
    if ((!h4 || h4[s7 * r4 + t3]) && a6 >= i3) {
      const n2 = (c5[e2] + 360) % 360 / 180 * Math.PI, { pennants: i5, barbs: h5, shaft: l6 } = I2[Math.min(Math.floor(a6 / 5), 29)];
      if (i5.length + h5.length === 0) continue;
      let g4 = f4.length / u6;
      const x3 = (t3 + 0.5) / r4, M3 = (s7 + 0.5) / o4;
      for (let t4 = 0; t4 < i5.length; t4 += 2) f4[m5++] = x3, f4[m5++] = M3, f4[m5++] = i5[t4], f4[m5++] = i5[t4 + 1] + n2, f4[m5++] = 0, f4[m5++] = a6;
      for (let t4 = 0; t4 < h5.length; t4 += 2) f4[m5++] = x3, f4[m5++] = M3, f4[m5++] = h5[t4], f4[m5++] = h5[t4 + 1] + n2, f4[m5++] = 0, f4[m5++] = a6;
      for (let t4 = 0; t4 < l6.length; t4 += 2) f4[m5++] = x3, f4[m5++] = M3, f4[m5++] = l6[t4], f4[m5++] = l6[t4 + 1] + n2, f4[m5++] = 0, f4[m5++] = a6;
      for (let t4 = 0; t4 < i5.length / 6; t4++) p5[d5++] = g4, p5[d5++] = g4 + 1, p5[d5++] = g4 + 2, g4 += 3;
      for (let t4 = 0; t4 < h5.length / 8; t4++) p5[d5++] = g4, p5[d5++] = g4 + 1, p5[d5++] = g4 + 2, p5[d5++] = g4 + 1, p5[d5++] = g4 + 2, p5[d5++] = g4 + 3, g4 += 4;
      p5[d5++] = g4 + 0, p5[d5++] = g4 + 1, p5[d5++] = g4 + 2, p5[d5++] = g4 + 1, p5[d5++] = g4 + 3, p5[d5++] = g4 + 2, g4 += 4;
    }
  }
  return { vertexData: new Float32Array(f4), indexData: new Uint32Array(p5) };
}
function _2(t2, e) {
  const n = 4 * 6;
  let r4 = 0, o4 = 0;
  const { width: h4, height: l5, mask: c5 } = t2, u6 = t2.pixels[0], f4 = [], p5 = [], m5 = a4(s5.fromJSON(e.inputUnit), "knots"), d5 = "wind_speed" === e.style ? i3 : Number.MAX_VALUE;
  for (let i5 = 0; i5 < l5; i5++) for (let t3 = 0; t3 < h4; t3++) {
    const e2 = u6[i5 * h4 + t3] * m5;
    if ((!c5 || c5[i5 * h4 + t3]) && e2 < d5) {
      for (let n2 = 0; n2 < 4; n2++) f4[r4++] = (t3 + 0.5) / h4, f4[r4++] = (i5 + 0.5) / l5, f4[r4++] = n2 < 2 ? -0.5 : 0.5, f4[r4++] = n2 % 2 == 0 ? -0.5 : 0.5, f4[r4++] = 0, f4[r4++] = e2;
      const s7 = 4 * (r4 / n - 1);
      p5[o4++] = s7, p5[o4++] = s7 + 1, p5[o4++] = s7 + 2, p5[o4++] = s7 + 1, p5[o4++] = s7 + 2, p5[o4++] = s7 + 3;
    }
  }
  return { vertexData: new Float32Array(f4), indexData: new Uint32Array(p5) };
}
function U2(t2, e) {
  return "simple_scalar" === e.style ? _2(t2, e) : "wind_speed" === e.style ? A2(t2, e) : v2(t2, e);
}
function S2(t2, n, r4, o4 = [0, 0], i5 = 0.5) {
  const { width: s7, height: a6, mask: h4 } = t2, [u6, f4] = t2.pixels, [p5, m5] = o4, d5 = Math.round((s7 - p5) / r4), g4 = Math.round((a6 - m5) / r4), x3 = d5 * g4, M3 = new Float32Array(x3), k3 = new Float32Array(x3), w4 = new Uint8Array(x3), y4 = "vector-uv" === n;
  for (let e = 0; e < g4; e++) for (let t3 = 0; t3 < d5; t3++) {
    let n2 = 0;
    const o5 = e * d5 + t3, g5 = Math.max(0, e * r4 + m5), x4 = Math.max(0, t3 * r4 + p5), P4 = Math.min(a6, g5 + r4), b3 = Math.min(s7, x4 + r4);
    for (let t4 = g5; t4 < P4; t4++) for (let e2 = x4; e2 < b3; e2++) {
      const r5 = t4 * s7 + e2;
      if (!h4 || h4[r5]) {
        n2++;
        const t5 = y4 ? [u6[r5], f4[r5]] : [u6[r5], (360 + f4[r5]) % 360], [e3, i6] = y4 ? t5 : c3(t5);
        M3[o5] += e3, k3[o5] += i6;
      }
    }
    if (n2 >= (P4 - g5) * (b3 - x4) * (1 - i5)) {
      w4[o5] = 1;
      const [t4, e2] = l4([M3[o5] / n2, k3[o5] / n2]);
      M3[o5] = t4, k3[o5] = e2;
    } else w4[o5] = 0, M3[o5] = 0, k3[o5] = 0;
  }
  const P3 = new c({ width: d5, height: g4, pixels: [M3, k3], mask: w4 });
  return P3.updateStatistics(), P3;
}

// node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js
var i4 = () => i.getLogger("esri.views.2d.engine.flow.dataUtils");
var a5 = 10;
async function s6(t2, e, r4, o4) {
  const l5 = performance.now(), s7 = c4(e, r4), f4 = performance.now(), h4 = u5(e, s7, r4.width, r4.height), p5 = performance.now(), g4 = m4(h4, true), y4 = performance.now(), x3 = "Streamlines" === t2 ? d4(g4, a5) : w3(g4), M3 = performance.now();
  return has("esri-2d-profiler") && (i4().info("I.1", "_createFlowFieldFromData (ms)", Math.round(f4 - l5)), i4().info("I.2", "_getStreamlines (ms)", Math.round(p5 - f4)), i4().info("I.3", "createAnimatedLinesData (ms)", Math.round(y4 - p5)), i4().info("I.4", "create{Streamlines|Particles}Mesh (ms)", Math.round(M3 - y4)), i4().info("I.5", "createFlowMesh (ms)", Math.round(M3 - l5)), i4().info("I.6", "Mesh size (bytes)", x3.vertexData.buffer.byteLength + x3.indexData.buffer.byteLength)), await Promise.resolve(), s2(o4), x3;
}
function c4(t2, e) {
  const n = h3(e.data, e.width, e.height, t2.smoothing);
  if (t2.interpolate) {
    return (t3, r4) => {
      const o4 = Math.floor(t3), l5 = Math.floor(r4);
      if (o4 < 0 || o4 >= e.width) return [0, 0];
      if (l5 < 0 || l5 >= e.height) return [0, 0];
      const i5 = t3 - o4, a6 = r4 - l5, s7 = o4, c5 = l5, f4 = o4 < e.width - 1 ? o4 + 1 : o4, u6 = l5 < e.height - 1 ? l5 + 1 : l5, h4 = n[2 * (c5 * e.width + s7)], m5 = n[2 * (c5 * e.width + f4)], d5 = n[2 * (u6 * e.width + s7)], w4 = n[2 * (u6 * e.width + f4)], p5 = n[2 * (c5 * e.width + s7) + 1], g4 = n[2 * (c5 * e.width + f4) + 1];
      return [(h4 * (1 - a6) + d5 * a6) * (1 - i5) + (m5 * (1 - a6) + w4 * a6) * i5, (p5 * (1 - a6) + n[2 * (u6 * e.width + s7) + 1] * a6) * (1 - i5) + (g4 * (1 - a6) + n[2 * (u6 * e.width + f4) + 1] * a6) * i5];
    };
  }
  return (t3, r4) => {
    const o4 = Math.round(t3), l5 = Math.round(r4);
    return o4 < 0 || o4 >= e.width || l5 < 0 || l5 >= e.height ? [0, 0] : [n[2 * (l5 * e.width + o4)], n[2 * (l5 * e.width + o4) + 1]];
  };
}
function f3(t2, e, n, r4, o4, l5, i5, a6, s7) {
  const c5 = [];
  let f4 = n, u6 = r4, h4 = 0, [m5, d5] = e(f4, u6);
  m5 *= t2.velocityScale, d5 *= t2.velocityScale;
  const w4 = Math.sqrt(m5 * m5 + d5 * d5);
  let p5, g4;
  c5.push({ x: f4, y: u6, t: h4, speed: w4 });
  for (let y4 = 0; y4 < t2.verticesPerLine; y4++) {
    let [n2, r5] = e(f4, u6);
    n2 *= t2.velocityScale, r5 *= t2.velocityScale;
    const m6 = Math.sqrt(n2 * n2 + r5 * r5);
    if (m6 < t2.minSpeedThreshold) return c5;
    const d6 = n2 / m6, w5 = r5 / m6;
    f4 += d6 * t2.segmentLength, u6 += w5 * t2.segmentLength;
    if (h4 += t2.segmentLength / m6, Math.acos(d6 * p5 + w5 * g4) > t2.maxTurnAngle) return c5;
    if (t2.collisions) {
      const t3 = Math.round(f4 * s7), e2 = Math.round(u6 * s7);
      if (t3 < 0 || t3 > i5 - 1 || e2 < 0 || e2 > a6 - 1) return c5;
      const n3 = l5[e2 * i5 + t3];
      if (-1 !== n3 && n3 !== o4) return c5;
      l5[e2 * i5 + t3] = o4;
    }
    c5.push({ x: f4, y: u6, t: h4, speed: m6 }), p5 = d6, g4 = w5;
  }
  return c5;
}
function u5(t2, e, n, o4) {
  const l5 = [], i5 = new t(), a6 = 1 / Math.max(t2.lineCollisionWidth, 1), s7 = Math.round(n * a6), c5 = Math.round(o4 * a6), u6 = new Int32Array(s7 * c5);
  for (let r4 = 0; r4 < u6.length; r4++) u6[r4] = -1;
  const h4 = [];
  for (let r4 = 0; r4 < o4; r4 += t2.lineSpacing) for (let e2 = 0; e2 < n; e2 += t2.lineSpacing) h4.push({ x: e2, y: r4, sort: i5.getFloat() });
  h4.sort((t3, e2) => t3.sort - e2.sort);
  for (const { x: r4, y: m5 } of h4) if (i5.getFloat() < t2.density) {
    const n2 = f3(t2, e, r4, m5, l5.length, u6, s7, c5, a6);
    if (n2.length < 2) continue;
    l5.push(n2);
  }
  return l5;
}
function h3(t2, e, n, r4) {
  if (0 === r4) return t2;
  const o4 = Math.round(3 * r4), l5 = new Array(2 * o4 + 1);
  let i5 = 0;
  for (let c5 = -o4; c5 <= o4; c5++) {
    const t3 = Math.exp(-c5 * c5 / (r4 * r4));
    l5[c5 + o4] = t3, i5 += t3;
  }
  for (let c5 = -o4; c5 <= o4; c5++) l5[c5 + o4] /= i5;
  const a6 = new Float32Array(t2.length);
  for (let c5 = 0; c5 < n; c5++) for (let n2 = 0; n2 < e; n2++) {
    let r5 = 0, i6 = 0;
    for (let a7 = -o4; a7 <= o4; a7++) {
      if (n2 + a7 < 0 || n2 + a7 >= e) continue;
      const s8 = l5[a7 + o4];
      r5 += s8 * t2[2 * (c5 * e + (n2 + a7))], i6 += s8 * t2[2 * (c5 * e + (n2 + a7)) + 1];
    }
    a6[2 * (c5 * e + n2)] = r5, a6[2 * (c5 * e + n2) + 1] = i6;
  }
  const s7 = new Float32Array(t2.length);
  for (let c5 = 0; c5 < e; c5++) for (let t3 = 0; t3 < n; t3++) {
    let r5 = 0, i6 = 0;
    for (let s8 = -o4; s8 <= o4; s8++) {
      if (t3 + s8 < 0 || t3 + s8 >= n) continue;
      const f4 = l5[s8 + o4];
      r5 += f4 * a6[2 * ((t3 + s8) * e + c5)], i6 += f4 * a6[2 * ((t3 + s8) * e + c5) + 1];
    }
    s7[2 * (t3 * e + c5)] = r5, s7[2 * (t3 * e + c5) + 1] = i6;
  }
  return s7;
}
function m4(t2, e) {
  const n = new t(), o4 = t2.reduce((t3, e2) => t3 + e2.length, 0), l5 = new Float32Array(4 * o4), i5 = new Array(t2.length);
  let a6 = 0, s7 = 0;
  for (const r4 of t2) {
    const t3 = a6;
    for (const e2 of r4) l5[4 * a6] = e2.x, l5[4 * a6 + 1] = e2.y, l5[4 * a6 + 2] = e2.t, l5[4 * a6 + 3] = e2.speed, a6++;
    i5[s7++] = { startVertex: t3, numberOfVertices: r4.length, totalTime: r4[r4.length - 1].t, timeSeed: e ? n.getFloat() : 0 };
  }
  return { lineVertices: l5, lineDescriptors: i5 };
}
function d4(t2, e) {
  const n = 9, { lineVertices: r4, lineDescriptors: o4 } = t2;
  let l5 = 0, i5 = 0;
  for (const m5 of o4) {
    l5 += 2 * m5.numberOfVertices;
    i5 += 6 * (m5.numberOfVertices - 1);
  }
  const a6 = new Float32Array(l5 * n), s7 = new Uint32Array(i5);
  let c5 = 0, f4 = 0;
  function u6() {
    s7[f4++] = c5 - 2, s7[f4++] = c5, s7[f4++] = c5 - 1, s7[f4++] = c5, s7[f4++] = c5 + 1, s7[f4++] = c5 - 1;
  }
  function h4(t3, e2, r5, o5, l6, i6, s8, f5) {
    const u7 = c5 * n;
    let h5 = 0;
    a6[u7 + h5++] = t3, a6[u7 + h5++] = e2, a6[u7 + h5++] = 1, a6[u7 + h5++] = r5, a6[u7 + h5++] = i6, a6[u7 + h5++] = s8, a6[u7 + h5++] = o5 / 2, a6[u7 + h5++] = l6 / 2, a6[u7 + h5++] = f5, c5++, a6[u7 + h5++] = t3, a6[u7 + h5++] = e2, a6[u7 + h5++] = -1, a6[u7 + h5++] = r5, a6[u7 + h5++] = i6, a6[u7 + h5++] = s8, a6[u7 + h5++] = -o5 / 2, a6[u7 + h5++] = -l6 / 2, a6[u7 + h5++] = f5, c5++;
  }
  for (const m5 of o4) {
    const { totalTime: t3, timeSeed: n2 } = m5;
    let o5 = null, l6 = null, i6 = null, a7 = null, s8 = null, c6 = null;
    for (let f5 = 0; f5 < m5.numberOfVertices; f5++) {
      const d5 = r4[4 * (m5.startVertex + f5)], w4 = r4[4 * (m5.startVertex + f5) + 1], p5 = r4[4 * (m5.startVertex + f5) + 2], g4 = r4[4 * (m5.startVertex + f5) + 3];
      let y4 = null, x3 = null, M3 = null, A3 = null;
      if (f5 > 0) {
        y4 = d5 - o5, x3 = w4 - l6;
        const r5 = Math.sqrt(y4 * y4 + x3 * x3);
        if (y4 /= r5, x3 /= r5, f5 > 1) {
          let t4 = y4 + s8, n3 = x3 + c6;
          const r6 = Math.sqrt(t4 * t4 + n3 * n3);
          t4 /= r6, n3 /= r6;
          const o6 = Math.min(1 / (t4 * y4 + n3 * x3), e);
          t4 *= o6, n3 *= o6, M3 = -n3, A3 = t4;
        } else M3 = -x3, A3 = y4;
        null !== M3 && null !== A3 && (h4(o5, l6, i6, M3, A3, t3, n2, g4), u6());
      }
      o5 = d5, l6 = w4, i6 = p5, s8 = y4, c6 = x3, a7 = g4;
    }
    h4(o5, l6, i6, -c6, s8, t3, n2, a7);
  }
  return { vertexData: a6, indexData: s7 };
}
function w3(t2) {
  const e = 16, n = 1, r4 = 2, { lineVertices: o4, lineDescriptors: l5 } = t2;
  let i5 = 0, a6 = 0;
  for (const U3 of l5) {
    const t3 = U3.numberOfVertices - 1;
    i5 += 4 * t3 * 2, a6 += 6 * t3 * 2;
  }
  const s7 = new Float32Array(i5 * e), c5 = new Uint32Array(a6);
  let f4, u6, h4, m5, d5, w4, p5, g4, y4, x3, M3, A3, I3, V, F2 = 0, v3 = 0;
  function D2() {
    c5[v3++] = F2 - 8, c5[v3++] = F2 - 7, c5[v3++] = F2 - 6, c5[v3++] = F2 - 7, c5[v3++] = F2 - 5, c5[v3++] = F2 - 6, c5[v3++] = F2 - 4, c5[v3++] = F2 - 3, c5[v3++] = F2 - 2, c5[v3++] = F2 - 3, c5[v3++] = F2 - 1, c5[v3++] = F2 - 2;
  }
  function b3(t3, o5, l6, i6, a7, c6, f5, u7, h5, m6, d6, w5, p6, g5) {
    const y5 = F2 * e;
    let x4 = 0;
    for (const e2 of [n, r4]) for (const n2 of [1, 2, 3, 4]) s7[y5 + x4++] = t3, s7[y5 + x4++] = o5, s7[y5 + x4++] = l6, s7[y5 + x4++] = i6, s7[y5 + x4++] = f5, s7[y5 + x4++] = u7, s7[y5 + x4++] = h5, s7[y5 + x4++] = m6, s7[y5 + x4++] = e2, s7[y5 + x4++] = n2, s7[y5 + x4++] = p6, s7[y5 + x4++] = g5, s7[y5 + x4++] = a7 / 2, s7[y5 + x4++] = c6 / 2, s7[y5 + x4++] = d6 / 2, s7[y5 + x4++] = w5 / 2, F2++;
  }
  function S3(t3, e2) {
    let n2 = y4 + M3, r5 = x3 + A3;
    const o5 = Math.sqrt(n2 * n2 + r5 * r5);
    n2 /= o5, r5 /= o5;
    const l6 = y4 * n2 + x3 * r5;
    n2 /= l6, r5 /= l6;
    let i6 = M3 + I3, a7 = A3 + V;
    const s8 = Math.sqrt(i6 * i6 + a7 * a7);
    i6 /= s8, a7 /= s8;
    const c6 = M3 * i6 + A3 * a7;
    i6 /= c6, a7 /= c6, b3(f4, u6, h4, m5, -r5, n2, d5, w4, p5, g4, -a7, i6, t3, e2), D2();
  }
  function k3(t3, e2, n2, r5, o5, l6) {
    if (y4 = M3, x3 = A3, M3 = I3, A3 = V, null == y4 && null == x3 && (y4 = M3, x3 = A3), null != d5 && null != w4) {
      I3 = t3 - d5, V = e2 - w4;
      const n3 = Math.sqrt(I3 * I3 + V * V);
      I3 /= n3, V /= n3;
    }
    null != y4 && null != x3 && S3(o5, l6), f4 = d5, u6 = w4, h4 = p5, m5 = g4, d5 = t3, w4 = e2, p5 = n2, g4 = r5;
  }
  function L(t3, e2) {
    y4 = M3, x3 = A3, M3 = I3, A3 = V, null == y4 && null == x3 && (y4 = M3, x3 = A3), null != y4 && null != x3 && S3(t3, e2);
  }
  for (const U3 of l5) {
    f4 = null, u6 = null, h4 = null, m5 = null, d5 = null, w4 = null, p5 = null, g4 = null, y4 = null, x3 = null, M3 = null, A3 = null, I3 = null, V = null;
    const { totalTime: t3, timeSeed: e2 } = U3;
    for (let n2 = 0; n2 < U3.numberOfVertices; n2++) {
      k3(o4[4 * (U3.startVertex + n2)], o4[4 * (U3.startVertex + n2) + 1], o4[4 * (U3.startVertex + n2) + 2], o4[4 * (U3.startVertex + n2) + 3], t3, e2);
    }
    L(t3, e2);
  }
  return { vertexData: s7, indexData: c5 };
}
function p4(t2, n) {
  const r4 = n.pixels, { width: o4, height: l5 } = n, i5 = new Float32Array(o4 * l5 * 2), a6 = n.mask || new Uint8Array(o4 * l5 * 2);
  if (n.mask || a6.fill(255), "vector-uv" === t2) for (let e = 0; e < o4 * l5; e++) i5[2 * e] = r4[0][e], i5[2 * e + 1] = -r4[1][e];
  else if ("vector-magdir" === t2) for (let s7 = 0; s7 < o4 * l5; s7++) {
    const t3 = r4[0][s7], n2 = s3(r4[1][s7]), o5 = Math.cos(n2 - Math.PI / 2), l6 = Math.sin(n2 - Math.PI / 2);
    i5[2 * s7] = o5 * t3, i5[2 * s7 + 1] = l6 * t3;
  }
  return { data: i5, mask: a6, width: o4, height: l5 };
}
async function g3(t2, e, n, r4, a6, s7) {
  const c5 = performance.now(), f4 = d(e.spatialReference);
  if (!f4) {
    const o4 = await y3(t2, e, n, r4, a6, s7);
    return has("esri-2d-profiler") && i4().info("I.7", "loadImagery, early exit (ms)", Math.round(performance.now() - c5)), has("esri-2d-profiler") && i4().info("I.9", "Number of parts", 1), o4;
  }
  const [u6, h4] = f4.valid, m5 = h4 - u6, d5 = Math.ceil(e.width / m5), w4 = e.width / d5, p5 = Math.round(n / d5);
  let g4 = e.xmin;
  const x3 = [], M3 = performance.now();
  for (let l5 = 0; l5 < d5; l5++) {
    const n2 = new z({ xmin: g4, xmax: g4 + w4, ymin: e.ymin, ymax: e.ymax, spatialReference: e.spatialReference });
    x3.push(y3(t2, n2, p5, r4, a6, s7)), g4 += w4;
  }
  const A3 = await Promise.all(x3);
  has("esri-2d-profiler") && i4().info("I.8", "All calls to _fetchPart (ms)", Math.round(performance.now() - M3)), has("esri-2d-profiler") && i4().info("I.9", "Number of parts", A3.length);
  const I3 = { data: new Float32Array(n * r4 * 2), mask: new Uint8Array(n * r4), width: n, height: r4 };
  let V = 0;
  for (const o4 of A3) {
    for (let t3 = 0; t3 < o4.height; t3++) for (let e2 = 0; e2 < o4.width; e2++) V + e2 >= n || (I3.data[2 * (t3 * n + V + e2)] = o4.data[2 * (t3 * o4.width + e2)], I3.data[2 * (t3 * n + V + e2) + 1] = o4.data[2 * (t3 * o4.width + e2) + 1], I3.mask[t3 * n + V + e2] = o4.mask[t3 * o4.width + e2]);
    V += o4.width;
  }
  return has("esri-2d-profiler") && i4().info("I.10", "loadImagery, general exit (ms)", Math.round(performance.now() - c5)), I3;
}
async function y3(t2, e, n, r4, o4, l5) {
  const i5 = { requestProjectedLocalDirections: true, signal: l5 };
  if (null != o4 && (i5.timeExtent = o4), "imagery" === t2.type) {
    await t2.load({ signal: l5 });
    const o5 = await t2.internalFetchImage(e, n, r4, i5);
    if (null == o5?.pixelData?.pixelBlock) return { data: new Float32Array(n * r4 * 2), mask: new Uint8Array(n * r4), width: n, height: r4 };
    return p4(t2.rasterInfo.dataType, o5.pixelData.pixelBlock);
  }
  await t2.load({ signal: l5 });
  const a6 = await t2.fetchPixels(e, n, r4, i5);
  if (null == a6?.pixelBlock) return { data: new Float32Array(n * r4 * 2), mask: new Uint8Array(n * r4), width: n, height: r4 };
  return p4(t2.serviceRasterInfo.dataType, a6.pixelBlock);
}

export {
  l2 as l,
  c,
  l3 as l2,
  i2 as i,
  o2 as o,
  r2 as r,
  a3 as a,
  h,
  f,
  c2,
  u3 as u,
  p2 as p,
  x,
  m2 as m,
  w,
  k,
  M,
  U,
  T,
  B,
  W,
  I,
  R,
  j,
  D,
  s5 as s,
  a4 as a2,
  l4 as l3,
  u4 as u2,
  f2,
  p3 as p2,
  m3 as m2,
  _2 as _,
  U2,
  S2 as S,
  s6 as s2,
  g3 as g
};
//# sourceMappingURL=chunk-NXHGFG67.js.map
