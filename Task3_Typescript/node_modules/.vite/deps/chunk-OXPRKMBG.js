import {
  i as i2
} from "./chunk-BMFPNVV7.js";
import {
  s as s2
} from "./chunk-HCBZZ3ZP.js";
import {
  o
} from "./chunk-ELSQQIKB.js";
import {
  E,
  i
} from "./chunk-UGXCZZ7N.js";
import {
  k
} from "./chunk-F4KXGA4J.js";
import {
  C
} from "./chunk-6PV45IYU.js";
import {
  s
} from "./chunk-XWG6QGFK.js";

// node_modules/@arcgis/core/layers/save/utils.js
function p(t, r, a) {
  const o2 = a(t);
  if (!o2.isValid) throw new s(`${r}:invalid-parameters`, o2.errorMessage, { layer: t });
}
async function l(e) {
  const { layer: t, errorNamePrefix: r, validateLayer: a } = e;
  await t.load(), p(t, r, a);
}
function m(e, t) {
  return `Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${t}`;
}
function c(t) {
  const { item: r, errorNamePrefix: a, layer: o2, validateItem: i3 } = t;
  if (u(t), i3) {
    const t2 = i3(r);
    if (!t2.isValid) throw new s(`${a}:invalid-parameters`, t2.errorMessage, { layer: o2 });
  }
}
function u(t) {
  const { item: r, itemType: a, additionalItemType: o2, errorNamePrefix: i3, layer: n } = t, s3 = [a];
  if (o2 && s3.push(o2), !s3.includes(r.type)) {
    const t2 = s3.map((e) => `'${e}'`).join(", ");
    throw new s(`${i3}:portal-item-wrong-type`, `Portal item type should be one of: "${t2}"`, { item: r, layer: n });
  }
}
function f(t) {
  const { layer: r, errorNamePrefix: a } = t, { portalItem: o2 } = r;
  if (!o2) throw new s(`${a}:portal-item-not-set`, m(r, "requires the portalItem property to be set"));
  if (!o2.loaded) throw new s(`${a}:portal-item-not-loaded`, m(r, "cannot be saved to a portal item that does not exist or is inaccessible"));
  c({ ...t, item: o2 });
}
function d(e) {
  const { newItem: t, itemType: o2 } = e;
  let i3 = k.from(t);
  return i3.id && (i3 = i3.clone(), i3.id = null), i3.type ??= o2, i3.portal ??= C.getDefault(), c({ ...e, item: i3 }), i3;
}
function y(e) {
  return o(e, "portal-item");
}
async function w(e, t, r) {
  "beforeSave" in e && "function" == typeof e.beforeSave && await e.beforeSave();
  const a = e.write({}, t);
  return await Promise.all(t.resources?.pendingOperations ?? []), s2(t, { errorName: "layer-write:unsupported" }, r), a;
}
function I(e) {
  i(e, E.JSAPI), e.typeKeywords && (e.typeKeywords = e.typeKeywords.filter((e2, t, r) => r.indexOf(e2) === t));
}
async function v(e, t, r) {
  const a = e.portal;
  await a.signIn(), await a.user.addItem({ item: e, data: t, folder: r?.folder });
}
async function P(e, r) {
  const { layer: a, createItemData: o2, createJSONContext: i3, setItemProperties: n, saveResources: s3, supplementalUnsupportedErrors: p2 } = e;
  await l(e), f(e);
  const m2 = a.portalItem, c2 = i3 ? i3(m2) : y(m2), u2 = await w(a, c2, { ...r, supplementalUnsupportedErrors: p2 }), d2 = await o2({ layer: a, layerJSON: u2 }, m2);
  return await n?.(a, m2, d2), I(m2), await m2.update({ data: d2 }), i2(c2), await s3?.(m2, c2), m2;
}
async function $(e, r) {
  const { layer: a, createItemData: o2, createJSONContext: i3, setItemProperties: n, saveResources: s3, supplementalUnsupportedErrors: p2 } = e;
  await l(e);
  const m2 = d(e), c2 = i3 ? i3(m2) : y(m2), u2 = await w(a, c2, { ...r, supplementalUnsupportedErrors: p2 }), f2 = await o2({ layer: a, layerJSON: u2 }, m2);
  return await n(a, m2, f2), I(m2), await v(m2, f2, r), a.portalItem = m2, i2(c2), await s3?.(m2, c2), m2;
}

export {
  p,
  m,
  f,
  d,
  w,
  I,
  v,
  P,
  $
};
//# sourceMappingURL=chunk-OXPRKMBG.js.map
