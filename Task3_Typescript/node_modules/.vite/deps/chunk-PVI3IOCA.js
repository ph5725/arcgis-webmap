// node_modules/@arcgis/core/layers/support/rasterFormats/pixelRangeUtils.js
var t = 9999999e31;
var n = 2e-7;
var e = { u1: [0, 1], u2: [0, 3], u4: [0, 15], u8: [0, 255], s8: [-128, 127], u16: [0, 65535], s16: [-32768, 32767], u32: [0, 4294967295], s32: [-2147483648, 2147483647], f32: [-34028234663852886e22, 34028234663852886e22], f64: [-Number.MAX_VALUE, Number.MAX_VALUE], unknown: void 0, c64: void 0, c128: void 0 };
function u(t2) {
  return e[t2] ?? [-34028234663852886e22, 34028234663852886e22];
}
var s = { u1: 1, u2: 1, u4: 1, u8: 1, s8: 1, u16: 2, s16: 2, u32: 4, s32: 4, f32: 4, f64: 8, unknown: 4, c64: 16, c128: 32 };
function o(t2) {
  return s[t2];
}
function l(t2) {
  return o(t2.pixelType) * t2.bandCount;
}
function i(t2, n2) {
  return null == t2 || null == n2 ? "s32" : t2 < 0 ? t2 >= -128 && n2 < 128 ? "s8" : t2 >= -32768 && n2 < 32768 ? "s16" : "s32" : n2 < 256 ? "u8" : n2 < 65536 ? "u16" : "u32";
}
function r(t2) {
  return (t2?.startsWith("s") || t2?.startsWith("u")) ?? false;
}
function c(t2, n2, e2, s2) {
  let [o2, l2] = u(e2);
  const i2 = r(e2);
  return i2 && (o2 -= 1e-5, l2 += 1e-5), i2 ? e2.startsWith("u") ? a(t2, n2, s2, [o2, l2]) : h(t2, n2, s2, [o2, l2]) : b(t2, n2, s2, [o2, l2]);
}
function f(t2, n2) {
  for (let e2 = 0; e2 < n2.length; e2++) n2[e2] && isNaN(t2[e2]) && (n2[e2] = 0, t2[e2] = 0);
}
function a(t2, n2, e2, u2) {
  const [s2, o2] = u2;
  for (let l2 = 0; l2 < n2.length; l2++) if (n2[l2]) {
    const u3 = t2[l2];
    u3 < s2 || u3 > o2 ? n2[l2] = 0 : e2[l2] = u3 + 0.5 | 0;
  }
}
function h(t2, n2, e2, u2) {
  const [s2, o2] = u2;
  for (let l2 = 0; l2 < n2.length; l2++) if (n2[l2]) {
    const u3 = t2[l2];
    u3 < s2 || u3 > o2 ? n2[l2] = 0 : e2[l2] = u3 + (u3 > 0 ? 0.5 : -0.5) | 0;
  }
}
function b(t2, n2, e2, u2) {
  const [s2, o2] = u2;
  for (let l2 = 0; l2 < n2.length; l2++) if (n2[l2]) {
    const u3 = t2[l2];
    u3 < s2 || u3 > o2 ? n2[l2] = 0 : e2[l2] = u3;
  }
}
function g(e2, s2, o2) {
  if (e2.depthCount && e2.depthCount > 1) return;
  const { pixels: l2, statistics: i2, pixelType: r2 } = e2, c2 = l2[0].length, f2 = e2.bandMasks ?? [], a2 = e2.mask ?? new Uint8Array(c2).fill(255), h2 = "f32" === r2 || "f64" === r2, b2 = u(r2);
  let g2 = false;
  for (let u2 = 0; u2 < l2.length; u2++) {
    const e3 = "number" == typeof s2 ? s2 : s2[u2];
    if (null == e3) continue;
    const c3 = i2?.[u2]?.minValue ?? b2[0], m2 = i2?.[u2]?.maxValue ?? b2[1];
    if (c3 > e3 + Number.EPSILON || m2 < e3 - Number.EPSILON) continue;
    const p = f2[u2] || a2.slice(), d = l2[u2], N = o2?.customFloatTolerance;
    if (h2 && 0 !== N) {
      let u3 = N;
      u3 || (u3 = Math.abs(e3) >= t ? n * Math.abs(e3) : "f32" === r2 ? 2 ** -23 : Number.EPSILON);
      for (let t2 = 0; t2 < d.length; t2++) p[t2] && Math.abs(d[t2] - e3) < u3 && (d[t2] = 0, p[t2] = 0, a2[t2] = 0, g2 = true);
    } else for (let t2 = 0; t2 < d.length; t2++) p[t2] && d[t2] === e3 && (d[t2] = 0, p[t2] = 0, a2[t2] = 0, g2 = true);
    f2[u2] = p;
  }
  if (g2) {
    const t2 = e2.bandMasks || e2.pixels.length > 1 ? f2 : null;
    o2?.matchAllNoData ? e2.mask = t2 && t2.length > 1 ? m(t2) : a2 : (e2.bandMasks = t2, e2.mask = a2);
  }
  function m(t2) {
    if (t2.length < 2) return t2[0];
    const n2 = t2[0].length, e3 = new Uint8Array(n2).fill(0);
    for (let u2 = 0; u2 < t2.length; u2++) {
      const s3 = t2[u2];
      for (let t3 = 0; t3 < n2; t3++) s3[t3] && (e3[t3] = 255);
    }
    return e3;
  }
  g2 && "updateStatistics" in e2 && e2.updateStatistics();
}

export {
  u,
  l,
  i,
  r,
  c,
  f,
  g
};
//# sourceMappingURL=chunk-PVI3IOCA.js.map
