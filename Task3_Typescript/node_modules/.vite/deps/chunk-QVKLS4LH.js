import {
  a
} from "./chunk-2KVNXQA7.js";
import {
  r
} from "./chunk-XDCUZFJX.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import {
  K,
  _,
  x
} from "./chunk-LQFTAGIV.js";
import {
  f
} from "./chunk-GZ2P4SCJ.js";

// node_modules/@arcgis/core/support/basemapUtils.js
function u(e) {
  return "Web Scene" === e.portalItem?.type || e.referenceLayers.some((e2) => "scene" === e2.type);
}
function s(e) {
  return !!e?.portalItem?.tags?.some((e2) => "beta" === e2.toLowerCase());
}
function c(e, r2) {
  const t = e.allLayerViews.find((e2) => e2.uid === r2);
  return t?.layer.parent === e.map?.basemap;
}
var o;
function f2(e) {
  if (o) return o(e);
  let r2 = null;
  const t = v(e), a2 = !t?.baseLayers.length;
  for (const n in a) {
    const e2 = x2(t, R(a[n]), { mustMatchReferences: a2 });
    if ("equal" === e2) {
      r2 = n;
      break;
    }
    "base-layers-equal" === e2 && (r2 = n);
  }
  return r2;
}
function y(e, r2) {
  if (e === r2) return true;
  if (null != e?.portalItem?.id && e.portalItem.id === r2?.portalItem?.id) return true;
  return "equal" === x2(v(e), v(r2), { mustMatchReferences: true });
}
function m(e) {
  return !!e?.baseLayers.concat(e.referenceLayers).some(b);
}
function b(e) {
  if (S(e.url)) return true;
  if ("vector-tile" === e.type) for (const r2 in e.sourceNameToSource) {
    const t = e.sourceNameToSource[r2];
    if (S(t?.sourceUrl)) return true;
  }
  return false;
}
function d(e, r2) {
  if (null == r2 || null == e) return { spatialReference: null, updating: false };
  if ("not-loaded" === r2.loadStatus) return r2.load(), { spatialReference: null, updating: true };
  if (r2.spatialReference) return { spatialReference: r2.spatialReference, updating: false };
  if (0 === r2.baseLayers.length) return { spatialReference: null, updating: false };
  const t = r2.baseLayers.at(0);
  switch (t.loadStatus) {
    case "not-loaded":
      t.load();
    case "loading":
      return { spatialReference: null, updating: true };
    case "failed":
      return { spatialReference: null, updating: false };
  }
  const a2 = (("supportedSpatialReferences" in t ? t.supportedSpatialReferences : null) || ["tileInfo" in t ? t.tileInfo?.spatialReference : t.spatialReference]).filter(Boolean), n = e.spatialReference;
  return n ? { spatialReference: a2.find((e2) => n.equals(e2)) ?? a2[0] ?? null, updating: false } : { spatialReference: a2[0], updating: false };
}
var L = /^(basemaps|ibasemaps).*-api\.arcgis\.com$/i;
function S(e) {
  if (!e) return false;
  const r2 = new x(_(e));
  return !!r2.authority && L.test(r2.authority);
}
function v(e) {
  return e ? !e.loaded && e.resourceInfo ? R(e.resourceInfo.data) : { baseLayers: g(e.baseLayers), referenceLayers: g(e.referenceLayers) } : null;
}
function g(r2) {
  return (V.isCollection(r2) ? r2.toArray() : r2).map(I);
}
function I(e) {
  return { type: e.type, effect: "effect" in e ? e.effect : void 0, url: M("urlTemplate" in e && e.urlTemplate || e.url || "styleUrl" in e && e.styleUrl || ""), minScale: "minScale" in e && null != e.minScale ? e.minScale : 0, maxScale: "maxScale" in e && null != e.maxScale ? e.maxScale : 0, opacity: null != e.opacity ? e.opacity : 1, visible: null == e.visible || !!e.visible, sublayers: "map-image" !== e.type && "wms" !== e.type || null == e.sublayers ? void 0 : e.sublayers?.map((e2) => ({ id: e2.id, visible: e2.visible })), activeLayerId: "wmts" === e.type ? e.activeLayer?.id : void 0 };
}
function h(e) {
  return e.isReference || "ArcGISSceneServiceLayer" === e.layerType;
}
function R(e) {
  return e ? { baseLayers: q((e.baseMapLayers ?? []).filter((e2) => !h(e2))), referenceLayers: q((e.baseMapLayers ?? []).filter((e2) => h(e2))) } : null;
}
function q(e) {
  return e.map((e2) => w(e2));
}
function w(e) {
  let r2;
  switch (e.layerType) {
    case "VectorTileLayer":
      r2 = "vector-tile";
      break;
    case "ArcGISTiledMapServiceLayer":
      r2 = "tile";
      break;
    case "ArcGISSceneServiceLayer":
      r2 = "scene";
      break;
    default:
      r2 = "unknown";
  }
  return { type: r2, effect: e.effect, url: M(e.templateUrl || e.urlTemplate || e.styleUrl || e.url), minScale: e.minScale ?? 0, maxScale: e.maxScale ?? 0, opacity: e.opacity ?? 1, visible: null == e.visibility || !!e.visibility, sublayers: void 0, activeLayerId: void 0 };
}
function x2(e, r2, t) {
  if (null != e != (null != r2)) return "not-equal";
  if (!e || !r2) return "equal";
  if (!T(e.baseLayers, r2.baseLayers)) return "not-equal";
  return T(e.referenceLayers, r2.referenceLayers) ? "equal" : t.mustMatchReferences ? "not-equal" : "base-layers-equal";
}
function T(e, r2) {
  if (e.length !== r2.length) return false;
  for (let t = 0; t < e.length; t++) if (!U(e[t], r2[t])) return false;
  return true;
}
function U(e, r2) {
  if (e.type !== r2.type || e.url !== r2.url || e.minScale !== r2.minScale || e.maxScale !== r2.maxScale || e.visible !== r2.visible || e.opacity !== r2.opacity) return false;
  if (!r(e.effect, r2.effect)) return false;
  if (null != e.activeLayerId || null != r2.activeLayerId) return e.activeLayerId === r2.activeLayerId;
  if (null != e.sublayers || null != r2.sublayers) {
    if (null == e.sublayers || null == r2.sublayers || e.sublayers.length !== r2.sublayers.length) return false;
    for (let t = 0; t < e.sublayers.length; t++) {
      const a2 = e.sublayers.at(t), n = r2.sublayers.at(t);
      if (a2?.id !== n?.id || a2?.visible !== n?.visible) return false;
    }
  }
  return true;
}
function M(e) {
  return e ? K(e).replace(/^\s*https?:/i, "").toLowerCase() : "";
}
function j(e) {
  if (!e) return null;
  const { thumbnailUrl: t } = e;
  if (t) return t;
  const a2 = f2(e);
  return a2 ? a[a2].thumbnailUrl : f(e.baseLayers, k);
}
function k(e) {
  return "portalItem" in e ? e.portalItem?.thumbnailUrl : void 0;
}

export {
  u,
  s,
  c,
  y,
  m,
  b,
  d,
  j
};
//# sourceMappingURL=chunk-QVKLS4LH.js.map
