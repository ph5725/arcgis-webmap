import {
  c as c3
} from "./chunk-6BVAE5VM.js";
import {
  i as i5
} from "./chunk-GCCROLU6.js";
import {
  d as d2
} from "./chunk-Z3OZTRXI.js";
import {
  e as e2
} from "./chunk-XJMFXMGK.js";
import {
  e,
  t as t2
} from "./chunk-EUGUM3DF.js";
import {
  Xe
} from "./chunk-KXFCAOWK.js";
import {
  r as r4
} from "./chunk-RV3SBM2C.js";
import {
  c,
  c2,
  g as g2,
  h,
  i as i4,
  l as l3,
  t
} from "./chunk-SJHAGLIM.js";
import {
  S
} from "./chunk-OTCYHWWG.js";
import {
  R
} from "./chunk-7ZMGKXLG.js";
import {
  k
} from "./chunk-F4KXGA4J.js";
import {
  d
} from "./chunk-2IMSGFJN.js";
import {
  r as r3
} from "./chunk-EOMIFMDH.js";
import {
  l as l2,
  r as r2,
  u as u3
} from "./chunk-BDLVUYG2.js";
import {
  i as i3
} from "./chunk-6QA2BVC5.js";
import {
  g,
  u as u4
} from "./chunk-YBJ5GVXQ.js";
import {
  f as f2
} from "./chunk-N3A2BVTW.js";
import {
  p as p2
} from "./chunk-SRQCQD63.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  b as b2,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  i as i2,
  o
} from "./chunk-3NBBZ43U.js";
import {
  H,
  p2 as p
} from "./chunk-ZWFY3WY5.js";
import {
  I
} from "./chunk-LQFTAGIV.js";
import {
  u
} from "./chunk-S7IJH524.js";
import {
  b,
  u3 as u2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";

// node_modules/@arcgis/core/networks/support/TopologyValidationJobInfo.js
var n = i2()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var l4 = class extends i5 {
  constructor(t3) {
    super(t3), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t3) {
    const s3 = { ...t3, query: { f: "json" } }, { data: r5 } = await H(this.statusUrl, s3);
    return this.read(r5), this.editsResolver && this.editsResolver.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], exceededTransferLimit: true, historicMoment: null }), this;
  }
  async waitForJobCompletion(t3 = {}) {
    const { interval: e3 = 1e3, statusCallback: s3 } = t3;
    return new Promise((t4, o2) => {
      this._clearTimer();
      const i8 = setInterval(() => {
        this._timer || o2(u2()), this.checkJobStatus().then((e4) => {
          const { status: r5 } = e4;
          switch (this.status = r5, r5) {
            case "job-succeeded":
              this._clearTimer(), t4(this);
              break;
            case "job-waiting":
            case "job-executing":
              s3 && s3(this);
          }
        }, (t5) => {
          this._clearTimer(), o2(t5);
        });
      }, e3);
      this._timer = i8;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
r([m()], l4.prototype, "editsResolver", void 0), r([m({ type: String, json: { write: true } })], l4.prototype, "statusUrl", void 0), r([r3(n)], l4.prototype, "status", void 0), r([m({ type: Date, json: { type: Number, write: { writer: (t3, e3) => {
  e3.submissionTime = t3 ? t3.getTime() : null;
} } } })], l4.prototype, "submissionTime", void 0), r([m({ type: Date, json: { type: Number, write: { writer: (t3, e3) => {
  e3.lastUpdatedTime = t3 ? t3.getTime() : null;
} } } })], l4.prototype, "lastUpdatedTime", void 0), l4 = r([a("esri.networks.support.TopologyValidationJobInfo")], l4);
var m2 = l4;

// node_modules/@arcgis/core/networks/support/utils.js
function i6(e3, t3, r5 = "from") {
  const { fromRuleElement: n4, viaRuleElement: o2, toRuleElement: s3 } = f3(e3), u5 = [];
  switch (e3.ruleType) {
    case t2.RTContainment:
    case t2.RTAttachment:
      "from" === r5 && y(t3, n4, false) ? u5.push(s3) : "to" === r5 && y(t3, s3, false) && u5.push(n4);
      break;
    case t2.RTJunctionEdgeConnectivity:
    case t2.RTJunctionJunctionConnectivity:
      y(t3, n4, true) ? u5.push(s3) : y(t3, s3, true) && u5.push(n4);
      break;
    case t2.RTEdgeJunctionEdgeConnectivity:
      o2 && (y(t3, o2, true) ? (u5.push(n4), u5.push(s3)) : (y(t3, n4, true) || y(t3, s3, true)) && u5.push(o2));
      break;
    default:
      return [];
  }
  return u5;
}
function c4(e3, t3, r5) {
  const { fromRuleElement: n4, viaRuleElement: o2, toRuleElement: s3 } = f3(e3);
  switch (e3.ruleType) {
    case t2.RTContainment:
    case t2.RTAttachment:
      return p3(t3, r5, n4, s3, false, false);
    case t2.RTJunctionEdgeConnectivity:
    case t2.RTJunctionJunctionConnectivity:
      return p3(t3, r5, n4, s3, true, true);
    case t2.RTEdgeJunctionEdgeConnectivity:
      return p3(t3, r5, n4, o2, true, true) || p3(t3, r5, s3, o2, true, true);
    default:
      return false;
  }
}
function p3(e3, t3, r5, n4, o2, a3) {
  if (!r5 || !n4) return false;
  const s3 = y(e3, r5, a3), u5 = y(t3, n4, a3);
  if (o2) {
    const o3 = y(e3, n4, a3), l5 = y(t3, r5, a3);
    return s3 && u5 || o3 && l5;
  }
  return s3 && u5;
}
function m3(e3, t3) {
  const r5 = e3.terminal?.terminalId, n4 = t3.terminalId;
  return null == r5 && null == n4 || (1 === r5 ? null == n4 || 1 === n4 : r5 === n4);
}
function y(e3, t3, r5) {
  const { assetGroupCode: n4, assetTypeCode: o2 } = e3;
  return ("layerId" in e3 ? e3.layerId === t3.networkSource?.layerId : e3.networkSourceId === t3.networkSource?.sourceId) && (null == n4 || n4 === t3.assetGroup?.assetGroupCode) && (null == o2 || o2 === t3.assetType?.assetTypeCode) && (!r5 || !("terminalId" in e3) || m3(t3, e3));
}
function f3(e3) {
  return { fromRuleElement: { networkSource: e3.fromNetworkSource, assetGroup: e3.fromAssetGroup, assetType: e3.fromAssetType, terminal: e3.fromTerminal }, viaRuleElement: e3.viaNetworkSource ? { networkSource: e3.viaNetworkSource, assetGroup: e3.viaAssetGroup, assetType: e3.viaAssetType, terminal: e3.viaTerminal } : void 0, toRuleElement: { networkSource: e3.toNetworkSource, assetGroup: e3.toAssetGroup, assetType: e3.toAssetType, terminal: e3.toTerminal } };
}
function d3(e3) {
  let t3 = null, r5 = null, o2 = null;
  if (i3(e3)) t3 = w(e3), [r5, o2] = I2(e3);
  else if (g(e3)) {
    t3 = e3.parent?.layerId ?? null;
    const [n4] = T(e3);
    n4 === e3.subtypeField && (r5 = e3.subtypeCode);
  } else t3 = e3.layerId ?? null;
  return { layerId: t3, assetGroupCode: r5, assetTypeCode: o2 };
}
function w(e3) {
  const { sourceLayer: t3 } = e3;
  let r5;
  return u4(t3) ? r5 = t3.layerId : g(t3) && (r5 = t3.parent?.layerId), r5 ?? null;
}
function I2(e3) {
  const [t3, r5] = T(e3.sourceLayer);
  return [t3 ? e3.attributes[t3] : null, r5 ? e3.attributes[r5] : null];
}
function T(e3) {
  if (!e3 || !("fieldsIndex" in e3)) return [null, null];
  return [e3.fieldsIndex.normalizeFieldName("assetGroup") ?? null, e3.fieldsIndex.normalizeFieldName("assetType") ?? null];
}
async function k2(e3, t3) {
  if ("Utility Network Layer" === e3) {
    const { default: e4 } = await import("./UtilityNetwork-2OAOAIPL.js");
    return new e4({ layerUrl: t3 });
  }
  return null;
}
async function v(r5) {
  let n4 = "portalItem" in r5 ? r5 : { portalItem: r5 };
  !n4.portalItem || n4.portalItem instanceof k || (n4 = { ...n4, portalItem: new k(n4.portalItem) });
  const o2 = n4.portalItem;
  if (await o2.load(), "Feature Service" !== o2.type) throw new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: o2.type });
  const a3 = o2.url, u5 = await H(a3, { responseType: "json", query: { f: "json" } }), l5 = "Network Layer";
  if (u5.data.type?.includes(l5)) return k2(u5.data.type, a3);
  if (u5.data.layers) {
    const e3 = u5.data.layers.find((e4) => e4.type.includes(l5));
    if (e3) {
      const t3 = `${a3}/${e3.id}`;
      return k2(e3.type, t3);
    }
  }
  return null;
}

// node_modules/@arcgis/core/networks/Network.js
var U = class extends S(p2) {
  static fromPortalItem(e3) {
    return v(e3);
  }
  constructor(e3) {
    super(e3), this.id = null, this.title = null, this.layerUrl = null, this.dataElement = null, this.fullExtent = null, this.spatialReference = null, this.type = null, this.sourceJSON = null, this.gdbVersion = null, this.historicMoment = null, this._sourceIdByLayerId = /* @__PURE__ */ new Map(), this._layerIdBySourceId = /* @__PURE__ */ new Map(), this._applyEditsHandler = (e4) => {
      const { serviceUrl: t3, gdbVersion: r5, result: o2 } = e4, s3 = t3 === this.featureServiceUrl, i8 = g2(t3, r5, this.gdbVersion);
      s3 && i8 && o2.then((e5) => {
        c(t3, r5) && (this.historicMoment = e5.historicMoment);
      });
    }, this._updateMomentHandler = (e4) => {
      const { serviceUrl: t3, gdbVersion: r5, moment: o2 } = e4, s3 = t3 === this.featureServiceUrl, i8 = g2(t3, r5, this.gdbVersion);
      s3 && i8 && (this.historicMoment = o2);
    }, this.when().then(() => {
      this.addHandles([l3(this._applyEditsHandler), h(this._updateMomentHandler)]);
    }, () => {
    });
  }
  initialize() {
    this.when().catch((e3) => {
      b(e3) || i.getLogger(this).error("#load()", `Failed to load layer (title: '${this.title ?? "no title"}', id: '${this.id ?? "no id"}')`, { error: e3 });
    });
  }
  get datasetName() {
    return this.dataElement?.name ?? null;
  }
  get owner() {
    return this.dataElement?.userIdentity ?? null;
  }
  get schemaGeneration() {
    return this.dataElement?.schemaGeneration ?? null;
  }
  get parsedUrl() {
    return I(this.layerUrl);
  }
  get featureServiceUrl() {
    return p(this.parsedUrl.path).url.path;
  }
  get networkServiceUrl() {
    return this.featureServiceUrl.replace(/\/FeatureServer/i, "/UtilityNetworkServer");
  }
  get layerId() {
    return p(this.parsedUrl.path).sublayer;
  }
  get networkSystemLayers() {
    return null;
  }
  async load(e3) {
    return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl, this.layerId.toString(), e3)), this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl, e3)), this;
  }
  getLayerIdBySourceId(e3) {
    if (!this.dataElement) return null;
    const t3 = this._layerIdBySourceId.get(e3);
    if (null != t3) return t3;
    const r5 = this.dataElement.domainNetworks, o2 = this._traverseNetworkSources(r5, this._layerIdBySourceId, "sourceId", "layerId", e3);
    return o2 >= 0 ? o2 : null;
  }
  getSourceIdByLayerId(e3) {
    if (!this.dataElement) return null;
    const t3 = this._sourceIdByLayerId.get(e3);
    if (null != t3) return t3;
    const r5 = this.dataElement.domainNetworks, o2 = this._traverseNetworkSources(r5, this._sourceIdByLayerId, "layerId", "sourceId", e3);
    return o2 >= 0 ? o2 : null;
  }
  getObjectIdsFromElements(e3) {
    const t3 = [], r5 = /* @__PURE__ */ new Map();
    for (const s3 of e3) {
      const e4 = this.getLayerIdBySourceId(s3.networkSourceId);
      if (null == e4) continue;
      let t4 = r5.get(e4);
      void 0 === t4 && (t4 = []), t4.push(s3.objectId), r5.set(e4, t4);
    }
    const o2 = this.featureServiceUrl;
    return r5.forEach((e4, r6) => t3.push({ layerUrl: `${o2}/${r6}`, objectIds: e4 })), t3;
  }
  async queryNamedTraceConfigurations(e3, t3) {
    const [{ queryNamedTraceConfigurations: r5 }, { default: o2 }] = await Promise.all([import("./queryNamedTraceConfigurations-EBA2MDZ4.js"), import("./QueryNamedTraceConfigurationsParameters-Y5ZNVHIC.js")]), s3 = this.networkServiceUrl, i8 = o2.from(e3);
    return (await r5(s3, i8, { ...t3 }))?.namedTraceConfigurations;
  }
  async validateTopology(e3, t3) {
    if (!e3.validateArea) throw new s("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    const [{ validateNetworkTopology: r5 }, { default: s3 }] = await Promise.all([import("./validateNetworkTopology-MFBR4PPN.js"), import("./ValidateNetworkTopologyParameters-B4URLLTI.js")]), i8 = s3.from(e3);
    c(this.featureServiceUrl, this.gdbVersion || null) ? (i8.sessionID = t, await i4(this.featureServiceUrl, this.gdbVersion, true)) : i8.sessionID = null, i8.gdbVersion = this.gdbVersion;
    const a3 = this.networkServiceUrl, n4 = this.featureServiceUrl, l5 = c2(n4, null, this.gdbVersion, true), d4 = await r5(a3, i8, { ...t3 });
    if (d4?.serviceEdits) {
      const e4 = [];
      for (const t4 of d4.serviceEdits) {
        const { editedFeatures: r6 } = t4, o2 = r6?.spatialReference ? new f(r6.spatialReference) : null;
        e4.push({ layerId: t4.layerId, editedFeatures: { adds: r6?.adds?.map((e5) => k3(e5, o2)) || [], updates: r6?.updates?.map((e5) => ({ original: k3(e5[0], o2), current: k3(e5[1], o2) })) || [], deletes: r6?.deletes?.map((e5) => k3(e5, o2)) || [], spatialReference: o2 } });
      }
      l5.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], editedFeatures: e4, exceededTransferLimit: false, historicMoment: d4.moment });
    }
    return d4;
  }
  async submitTopologyValidationJob(e3, t3) {
    let s3 = null;
    if (!e3.validateArea) throw new s("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    if (!this.gdbVersion) {
      const e4 = this.layerUrl.replace(/\/FeatureServer/i, "/VersionManagementServer").replace(/\/\d*$/, "");
      s3 = (await H(e4, { responseType: "json", query: { f: "json" } })).data.defaultVersionName;
    }
    const [{ submitValidateNetworkTopologyJob: i8 }, { default: a3 }] = await Promise.all([import("./validateNetworkTopology-MFBR4PPN.js"), import("./ValidateNetworkTopologyParameters-B4URLLTI.js")]), n4 = a3.from(e3);
    c(this.featureServiceUrl, this.gdbVersion || null) ? (n4.sessionID = t, await i4(this.featureServiceUrl, this.gdbVersion, true)) : n4.sessionID = null, n4.gdbVersion = this.gdbVersion || s3;
    const l5 = this.networkServiceUrl, d4 = this.featureServiceUrl ? c2(this.featureServiceUrl, null, this.gdbVersion, true) : void 0, u5 = await i8(l5, n4, { ...t3 });
    return new m2({ statusUrl: u5, editsResolver: d4 });
  }
  getSourceTypeById(e3) {
    if (!this.dataElement) return null;
    for (const t3 of this.dataElement.domainNetworks) for (const r5 of [t3.edgeSources ?? [], t3.junctionSources ?? []]) for (const o2 of r5) if (o2.sourceId === e3) return r5 === t3.edgeSources ? "edge" : "junction";
    return null;
  }
  _traverseNetworkSources(e3, t3, r5, o2, s3) {
    for (const i8 of e3) for (const e4 of [i8.edgeSources ?? [], i8.junctionSources ?? []]) for (const i9 of e4) if (i9[r5] === s3) return t3.set(s3, i9[o2]), i9[o2];
    return -1;
  }
  async _fetchLayerMetaData(e3, t3) {
    const o2 = await H(e3, { responseType: "json", query: { f: "json" }, ...t3 });
    this.sourceJSON = o2.data, this.read(o2.data, { origin: "service" });
  }
  async _fetchDataElement(e3, t3, o2) {
    if (this.dataElement) return;
    const s3 = await H(`${e3}/queryDataElements`, { responseType: "json", query: { layers: JSON.stringify([t3]), f: "json" }, ...o2 }).then((e4) => e4.data.layerDataElements?.[0]);
    s3 && this.read(s3, { origin: "service" });
  }
};
function k3(e3, r5) {
  return new d({ attributes: e3.attributes, geometry: f2({ ...e3.geometry, spatialReference: r5 }) });
}
r([m({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: true } }, read: false } })], U.prototype, "id", void 0), r([m({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: { source: "name" } } }, read: false } })], U.prototype, "title", void 0), r([m({ type: String, nonNullable: true, json: { origins: { "web-map": { read: { source: "url" }, write: { target: "url", isRequired: true } } }, read: false } })], U.prototype, "layerUrl", void 0), r([m({ type: Object, json: { origins: { service: { read: true } }, read: false } })], U.prototype, "dataElement", void 0), r([m({ type: z, json: { origins: { service: { read: { source: "extent" } } }, read: false } })], U.prototype, "fullExtent", void 0), r([m({ type: f, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, read: false } })], U.prototype, "spatialReference", void 0), r([m({ type: ["utility", "trace"], readOnly: true, json: { read: false, write: false } })], U.prototype, "type", void 0), r([m({ readOnly: true })], U.prototype, "datasetName", null), r([m({ readOnly: true })], U.prototype, "owner", null), r([m({ readOnly: true })], U.prototype, "schemaGeneration", null), r([m({ readOnly: true })], U.prototype, "parsedUrl", null), r([m({ readOnly: true })], U.prototype, "featureServiceUrl", null), r([m({ readOnly: true })], U.prototype, "networkServiceUrl", null), r([m({ readOnly: true })], U.prototype, "layerId", null), r([m()], U.prototype, "sourceJSON", void 0), r([m({ readOnly: true })], U.prototype, "networkSystemLayers", null), r([m()], U.prototype, "gdbVersion", void 0), r([m({ type: Date })], U.prototype, "historicMoment", void 0), U = r([a("esri.networks.Network")], U);
var N = U;

// node_modules/@arcgis/core/networks/RulesTable.js
var m4 = class extends l.JSONSupportMixin(p2) {
  constructor(e3) {
    super(e3), this.rulesCategorized = { attachment: [], containment: [], connectivity: [] }, this.request = H;
  }
  initialize() {
  }
  async load(e3) {
    const t3 = this.rulesLayer.load(e3).then(() => this._initializeRulesTable());
    return this.addResolvingPromise(t3), this;
  }
  getFeaturesCanAssociateWithClause(e3, t3, s3) {
    const o2 = /* @__PURE__ */ new Map(), [i8, a3] = T(e3.sourceLayer);
    if (!i8 || !a3) return "";
    const c5 = d3(e3), u5 = d3(t3);
    s3.forEach((e4) => {
      const { type: t4, direction: s4 } = e4;
      this._getRulesForAssociationType(t4).forEach((e5) => {
        i6(e5, c5, s4).filter((e6) => e6.networkSource?.layerId === u5.layerId).forEach((e6) => {
          const t5 = e6.assetGroup?.assetGroupCode, s5 = e6.assetType?.assetTypeCode;
          if (null != t5 && null != s5) {
            const e7 = o2.get(t5) ?? /* @__PURE__ */ new Set();
            e7.add(s5), o2.set(t5, e7);
          }
        });
      });
    });
    let y2 = [];
    return this._mergeAssetCodes(o2).forEach((e4, t4) => {
      const s4 = `${i8} IN (${t4})`, o3 = l2(a3, [...e4]);
      s4 && o3 && y2.push(r2(s4, o3));
    }), y2.length > 1 && (y2 = y2.map((e4) => `(${e4})`)), y2.join(" OR ");
  }
  getFeaturesCanAssociateWith(e3, t3, s3) {
    return null == w(e3) ? [] : t3.filter((t4) => this.canAssociateFeatures(e3, t4, s3));
  }
  canAssociateFeatures(e3, t3, s3) {
    if (!this._canSupportAssociations([e3, t3])) return false;
    const o2 = d3(e3), r5 = d3(t3);
    return s3.some((e4) => {
      const { type: t4, direction: s4 } = e4;
      return this._getRulesForAssociationType(t4).some((e5) => "to" === s4 ? c4(e5, r5, o2) : c4(e5, o2, r5));
    });
  }
  getLayersCanAssociateWith(e3, t3, s3) {
    return null == w(e3) ? [] : t3.filter((t4) => this.canAssociateFeatureToLayer(e3, t4, s3));
  }
  canAssociateFeatureToLayer(e3, t3, s3) {
    if (!this._canSupportAssociations([e3, t3])) return false;
    const o2 = d3(e3), r5 = d3(t3);
    return s3.some((e4) => {
      const { type: t4, direction: s4 } = e4;
      return this._getRulesForAssociationType(t4).some((e5) => "to" === s4 ? c4(e5, r5, o2) : c4(e5, o2, r5));
    });
  }
  getFeatureSQL(e3, t3) {
    const s3 = e3.layerId.toString(), o2 = e3.fieldsIndex?.normalizeFieldName("assetGroup"), r5 = e3.fieldsIndex?.normalizeFieldName("assetType"), n4 = o2 ? t3.attributes[o2] : null, i8 = r5 ? t3.attributes[r5] : null, a3 = this.rulesHash[s3];
    if (a3) {
      const e4 = a3.assetGroupHash[n4];
      if (e4) {
        return e4.assetTypeHash[i8] || null;
      }
    }
    return null;
  }
  async _initializeRulesTable() {
    const e3 = {};
    let t3;
    !function(e4) {
      e4[e4.from = 0] = "from", e4[e4.to = 1] = "to", e4[e4.via = 2] = "via";
    }(t3 || (t3 = {}));
    const s3 = [{ networkSourceId: "fromNetworkSource", assetGroupId: "fromAssetGroup", assetTypeId: "fromAssetType" }, { networkSourceId: "toNetworkSource", assetGroupId: "toAssetGroup", assetTypeId: "toAssetType" }, { networkSourceId: "viaNetworkSource", assetGroupId: "viaAssetGroup", assetTypeId: "viaAssetType" }];
    this.rulesCategorized = { attachment: [], containment: [], connectivity: [] };
    for (const o2 of this.rules) {
      if (o2.ruleType === t2.RTAttachment) {
        this.rulesCategorized.attachment.push(o2);
        continue;
      }
      if (o2.ruleType === t2.RTContainment) {
        this.rulesCategorized.containment.push(o2);
        continue;
      }
      if (o2.ruleType === t2.RTJunctionJunctionConnectivity) {
        this.rulesCategorized.connectivity.push(o2);
        continue;
      }
      this.rulesCategorized.connectivity.push(o2);
      let r5 = [[t3.from, t3.to], [t3.to, t3.from]];
      o2.ruleType === t2.RTEdgeJunctionEdgeConnectivity && (r5 = [[t3.from, t3.via], [t3.via, t3.from], [t3.to, t3.via], [t3.via, t3.to]]);
      for (const a3 of r5) {
        const r6 = a3.shift(), c5 = a3.shift();
        let p5 = false;
        switch (o2.ruleType) {
          case t2.RTEdgeJunctionEdgeConnectivity:
            p5 = r6 === t3.from || r6 === t3.to;
            break;
          case t2.RTJunctionEdgeConnectivity:
            p5 = r6 === t3.to;
        }
        const l5 = s3[r6], d4 = o2[l5.networkSourceId]?.layerId.toString() ?? "", y2 = o2[l5.assetGroupId]?.assetGroupCode?.toString(), h2 = o2[l5.assetTypeId], f4 = h2?.assetTypeCode?.toString(), m6 = s3[c5], g5 = o2[m6.networkSourceId]?.layerId.toString() ?? "", T2 = o2[m6.assetGroupId]?.assetGroupCode?.toString(), v2 = o2[m6.assetTypeId], C = v2?.assetTypeCode?.toString(), S2 = e3[d4] ?? { assetGroupHash: {} };
        if (!(y2 && f4 && T2 && C)) continue;
        const A = S2.assetGroupHash[y2] ?? { assetTypeHash: {} }, I3 = A.assetTypeHash[f4] ?? {};
        if (I3[g5] = I3[g5] ?? {}, p5) {
          I3[d4] = I3[d4] ?? {};
          const e4 = r2(`assetgroup = ${y2}`, `assettype = ${f4}`);
          "esriNECPEndVertex" === v2?.connectivityPolicy ? I3[d4].endVertex = I3[d4]?.endVertex ? `${I3[d4].endVertex}` : `(${e4})` : I3[d4].anyVertex = I3[d4].anyVertex ? `${I3[d4].anyVertex}` : `(${e4})`;
        }
        const j = r2(`assetgroup = ${T2}`, `assettype = ${C}`);
        "esriNECPEndVertex" === v2?.connectivityPolicy ? I3[g5].endVertex = I3[g5]?.endVertex ? u3(I3[g5].endVertex, j) : `(${j})` : I3[g5].anyVertex = I3[g5]?.anyVertex ? u3(I3[g5].anyVertex, j) : `(${j})`, A.assetTypeHash[f4] = I3, S2.assetGroupHash[y2] = A, e3[d4] = S2;
      }
    }
    this._set("rulesHash", e3);
  }
  _getRulesForAssociationType(e3) {
    const { rulesCategorized: t3 } = this;
    switch (e3) {
      case "attachment":
        return t3.attachment;
      case "containment":
        return t3.containment;
      case "connectivity":
      case "junction-junction-connectivity":
        return t3.connectivity.filter((e4) => e4.ruleType === t2.RTJunctionJunctionConnectivity);
      case "junction-edge-from-connectivity":
      case "junction-edge-midspan-connectivity":
      case "junction-edge-to-connectivity":
        return t3.connectivity.filter((e4) => e4.ruleType === t2.RTJunctionEdgeConnectivity || e4.ruleType === t2.RTEdgeJunctionEdgeConnectivity);
      default:
        return [];
    }
  }
  _areSetsEqual(e3, t3) {
    if (e3.size !== t3.size) return false;
    for (const s3 of e3) if (!t3.has(s3)) return false;
    return true;
  }
  _mergeAssetCodes(e3) {
    const t3 = /* @__PURE__ */ new Map(), s3 = /* @__PURE__ */ new Set();
    for (const [o2, r5] of e3) {
      const n4 = /* @__PURE__ */ new Set([o2]);
      for (const [t4, a3] of e3) o2 !== t4 && !s3.has(t4) && this._areSetsEqual(r5, a3) && (n4.add(t4), s3.add(t4));
      const i8 = Array.from(n4).sort().join(",");
      t3.set(i8, r5);
    }
    return t3;
  }
  _canSupportAssociations(e3) {
    return e3.every((e4) => {
      const t3 = i3(e4) ? e4.sourceLayer : e4, [s3, o2] = T(t3);
      return null != s3 && null != o2;
    });
  }
};
r([m({ constructOnly: true })], m4.prototype, "rulesLayer", void 0), r([m({ constructOnly: true })], m4.prototype, "rules", void 0), r([m({ readOnly: true })], m4.prototype, "rulesHash", void 0), r([m()], m4.prototype, "rulesCategorized", void 0), r([m({ constructOnly: true })], m4.prototype, "request", void 0), m4 = r([a("esri.networks.RulesTable")], m4);

// node_modules/@arcgis/core/networks/support/NetworkSystemLayers.js
var i7 = class extends b2 {
  constructor(s3) {
    super(s3), this.rulesTableId = null, this.rulesTableUrl = null, this.subnetworksTableId = null, this.subnetworksTableUrl = null, this.dirtyAreasLayerId = null, this.dirtyAreasLayerUrl = null, this.associationsTable = null, this.associationsTableId = null, this.associationsTableUrl = null;
  }
  destroy() {
    this.associationsTable?.destroy();
  }
  async loadAssociationsTable() {
    if (!this.associationsTable) {
      const { associationsTableUrl: s3 } = this;
      if (!s3) throw new s("utility-network-system-layers:missing-associations-table-url", "Unable to load the associations table, as the `associationsTableUrl` is not set.");
      this.associationsTable = new Xe({ url: s3 });
    }
    return await this.associationsTable.load(), this.associationsTable;
  }
};
r([m({ constructOnly: true })], i7.prototype, "rulesTableId", void 0), r([m({ constructOnly: true })], i7.prototype, "rulesTableUrl", void 0), r([m({ constructOnly: true })], i7.prototype, "subnetworksTableId", void 0), r([m({ constructOnly: true })], i7.prototype, "subnetworksTableUrl", void 0), r([m({ constructOnly: true })], i7.prototype, "dirtyAreasLayerId", void 0), r([m({ constructOnly: true })], i7.prototype, "dirtyAreasLayerUrl", void 0), r([m()], i7.prototype, "associationsTable", void 0), r([m({ constructOnly: true })], i7.prototype, "associationsTableId", void 0), r([m({ constructOnly: true })], i7.prototype, "associationsTableUrl", void 0), i7 = r([a("esri.networks.support.NetworkSystemLayers")], i7);

// node_modules/@arcgis/core/networks/support/Terminal.js
var s2 = class extends l {
  constructor(r5) {
    super(r5), this.id = null, this.name = null;
  }
};
r([m({ type: Number, json: { read: { source: "terminalId" }, write: { target: "terminalId" } } })], s2.prototype, "id", void 0), r([m({ type: String, json: { read: { source: "terminalName" }, write: { target: "terminalName" } } })], s2.prototype, "name", void 0), r([m({ type: Boolean, json: { write: true } })], s2.prototype, "isUpstreamTerminal", void 0), s2 = r([a("esri.networks.support.Terminal")], s2);
var p4 = s2;

// node_modules/@arcgis/core/networks/support/TerminalConfiguration.js
var a2 = new o({ esriUNTMBidirectional: "bidirectional", esriUNTMDirectional: "directional" });
var n2 = class extends l {
  constructor(r5) {
    super(r5), this.defaultConfiguration = null, this.id = null, this.name = null, this.terminals = [], this.traversabilityModel = null;
  }
};
r([m({ type: String, json: { write: true } })], n2.prototype, "defaultConfiguration", void 0), r([m({ type: Number, json: { read: { source: "terminalConfigurationId" }, write: { target: "terminalConfigurationId" } } })], n2.prototype, "id", void 0), r([m({ type: String, json: { read: { source: "terminalConfigurationName" }, write: { target: "terminalConfigurationName" } } })], n2.prototype, "name", void 0), r([m({ type: [p4], json: { write: true } })], n2.prototype, "terminals", void 0), r([m({ type: a2.apiValues, json: { type: a2.jsonValues, read: a2.read, write: a2.write } })], n2.prototype, "traversabilityModel", void 0), n2 = r([a("esri.networks.support.TerminalConfiguration")], n2);

// node_modules/@arcgis/core/networks/support/TraceJobInfo.js
var m5 = i2()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var n3 = class extends c3 {
  constructor(t3) {
    super(t3), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t3) {
    const s3 = { ...t3, query: { f: "json" } }, { data: r5 } = await H(this.statusUrl, s3), o2 = r5.traceResults ? { ...r5.traceResults, ...r5 } : r5;
    return this.read(o2), this;
  }
  async waitForJobCompletion(t3 = {}) {
    const { interval: e3 = 1e3, statusCallback: s3 } = t3;
    return new Promise((t4, o2) => {
      this._clearTimer();
      const i8 = setInterval(() => {
        this._timer || o2(u2()), this.checkJobStatus().then((e4) => {
          const { status: r5 } = e4;
          switch (this.status = r5, r5) {
            case "job-succeeded":
              this._clearTimer(), t4(this);
              break;
            case "job-waiting":
            case "job-executing":
              s3 && s3(this);
          }
        }, (t5) => {
          this._clearTimer(), o2(t5);
        });
      }, e3);
      this._timer = i8;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
r([m({ type: String, json: { write: true } })], n3.prototype, "statusUrl", void 0), r([r3(m5)], n3.prototype, "status", void 0), r([m({ type: Date, json: { type: Number, write: { writer: (t3, e3) => {
  e3.submissionTime = t3 ? t3.getTime() : null;
} } } })], n3.prototype, "submissionTime", void 0), r([m({ type: Date, json: { type: Number, write: { writer: (t3, e3) => {
  e3.lastUpdatedTime = t3 ? t3.getTime() : null;
} } } })], n3.prototype, "lastUpdatedTime", void 0), n3 = r([a("esri.networks.support.TraceJobInfo")], n3);

// node_modules/@arcgis/core/networks/UtilityNetwork.js
var g4 = class extends N {
  constructor(e3) {
    super(e3), this.sharedNamedTraceConfigurations = [], this.type = "utility", this._terminalById = /* @__PURE__ */ new Map(), this._circuitManagerMap = /* @__PURE__ */ new Map(), this._unitIdentifierManager = null;
  }
  get serviceTerritoryFeatureLayerId() {
    return this.dataElement?.serviceTerritoryFeatureLayerId ?? null;
  }
  get networkSystemLayers() {
    return new i7({ rulesTableId: this.sourceJSON?.systemLayers.rulesTableId, rulesTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${this.sourceJSON?.systemLayers.rulesTableId}` : null, subnetworksTableId: this.sourceJSON?.systemLayers.subnetworksTableId, subnetworksTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${this.sourceJSON?.systemLayers.subnetworksTableId}` : null, dirtyAreasLayerId: this.sourceJSON?.systemLayers.dirtyAreasLayerId, dirtyAreasLayerUrl: this.sourceJSON ? `${this.featureServiceUrl}/${this.sourceJSON?.systemLayers.dirtyAreasLayerId}` : null, associationsTableId: this.sourceJSON?.systemLayers.associationsTableId, associationsTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${this.sourceJSON?.systemLayers.associationsTableId}` : null });
  }
  get terminalConfigurations() {
    return this.dataElement?.terminalConfigurations.map((e3) => n2.fromJSON(e3)) || [];
  }
  get domainNetworkNames() {
    return this.dataElement?.domainNetworks.map((e3) => e3.domainNetworkName) || [];
  }
  get _utilityLayerList() {
    const e3 = /* @__PURE__ */ new Set();
    return this.dataElement?.domainNetworks?.map((t3) => {
      t3?.edgeSources?.map(({ layerId: t4, sourceId: r5 }) => {
        this._layerIdBySourceId.set(r5, t4), this._sourceIdByLayerId.set(t4, r5), e3.add(t4);
      }), t3?.junctionSources?.map(({ layerId: t4, sourceId: r5 }) => {
        this._layerIdBySourceId.set(r5, t4), this._sourceIdByLayerId.set(t4, r5), e3.add(t4);
      });
    }), e3;
  }
  get hasTelecomNetwork() {
    return this.dataElement?.domainNetworks.some((e3) => e3.isTelecomNetwork) ?? false;
  }
  async load(e3) {
    return this.addResolvingPromise(super.load(e3)), this.addResolvingPromise(this._loadNamedTraceConfigurationsFromNetwork(e3)), this;
  }
  getTerminalConfiguration(e3) {
    let t3 = null, r5 = null;
    const s3 = e3.sourceLayer;
    let i8 = null;
    if ("feature" === s3?.type) {
      if (i8 = s3.layerId, null === i8) return null;
    } else {
      if ("subtype-sublayer" !== s3?.type) return null;
      if (i8 = s3?.parent?.layerId ?? null, null === i8) return null;
    }
    const a3 = e3.attributes;
    if (null == a3) return null;
    for (const l5 of Object.keys(a3)) "ASSETGROUP" === l5.toUpperCase() && (t3 = e3.getAttribute(l5)), "ASSETTYPE" === l5.toUpperCase() && (r5 = e3.getAttribute(l5));
    if (!this.dataElement) return null;
    let o2 = null;
    const n4 = this.dataElement.domainNetworks;
    for (const l5 of n4) {
      const e4 = l5.junctionSources?.find((e5) => e5.layerId === i8);
      if (e4) {
        const s4 = e4.assetGroups?.find((e5) => e5.assetGroupCode === t3);
        if (s4) {
          const e5 = s4.assetTypes?.find((e6) => e6.assetTypeCode === r5);
          if (e5?.isTerminalConfigurationSupported) {
            o2 = e5.terminalConfigurationId;
            break;
          }
        }
      }
    }
    if (null != o2) {
      const e4 = this.dataElement.terminalConfigurations, t4 = e4?.find((e5) => e5.terminalConfigurationId === o2);
      return t4 ? n2.fromJSON(t4) : null;
    }
    return null;
  }
  getTierNames(e3) {
    const t3 = this.dataElement?.domainNetworks.find((t4) => t4.domainNetworkName === e3);
    return t3?.tiers?.map((e4) => e4.name) || [];
  }
  async getRulesTable() {
    return this._sharedRulesTable || (this._sharedRulesTable = this._createRulesTable()), await this._sharedRulesTable;
  }
  async getCircuitManager(e3) {
    if (!this.hasTelecomNetwork) return null;
    const t3 = this.dataElement?.domainNetworks.find((t4) => t4.domainNetworkName === e3 && t4.isTelecomNetwork);
    if (!t3) return null;
    const { default: s3 } = await import("./CircuitManager-DIKHRQ6Q.js");
    return u(this._circuitManagerMap, e3, () => new s3({ utilityNetwork: this, telecomDomainNetwork: t3 }));
  }
  async getUnitIdentifierManager() {
    if (!this.hasTelecomNetwork) return null;
    if (this._unitIdentifierManager) return this._unitIdentifierManager;
    const { default: e3 } = await import("./UnitIdentifierManager-A3ZTQGO6.js");
    return this._unitIdentifierManager = new e3({ utilityNetwork: this }), this._unitIdentifierManager;
  }
  getTerminalById(e3) {
    if (!this.dataElement || null == e3) return null;
    const t3 = this._terminalById.get(e3);
    return null != t3 ? t3 : (this.terminalConfigurations.forEach((e4) => {
      e4.terminals.forEach((e5) => {
        this._terminalById.set(e5.id, e5);
      });
    }), this._terminalById.get(e3));
  }
  isUtilityLayer(e3) {
    return "layerId" in e3 ? this._utilityLayerList.has(e3?.layerId) && (e3.url?.startsWith(this.featureServiceUrl) ?? false) : !("subtype-sublayer" !== e3.type || !e3.parent) && (this._utilityLayerList.has(e3.parent.layerId) && (e3.parent.url?.startsWith(this.featureServiceUrl) ?? false));
  }
  async queryAssociations(e3, t3) {
    const [{ queryAssociations: r5 }, { default: s3 }] = await Promise.all([import("./queryAssociations-YE3WTZLA.js"), import("./QueryAssociationsParameters-POLUPSHR.js")]), i8 = s3.from(e3);
    i8.gdbVersion = this.gdbVersion, i8.moment = this.historicMoment;
    return (await r5(this.networkServiceUrl, i8, t3)).associations;
  }
  async synthesizeAssociationGeometries(e3) {
    const [{ synthesizeAssociationGeometries: t3 }, { default: r5 }] = await Promise.all([import("./synthesizeAssociationGeometries-4C2JGEPU.js"), import("./SynthesizeAssociationGeometriesParameters-ZA6IFR6J.js")]), s3 = r5.from(e3);
    return s3.gdbVersion = this.gdbVersion, s3.moment = this.historicMoment, t3(this.networkServiceUrl, s3);
  }
  async trace(e3) {
    const [{ trace: t3 }, { default: r5 }] = await Promise.all([import("./trace-RIJG4H7H.js"), import("./TraceParameters-JHRSWJJP.js")]), s3 = r5.from(e3);
    return s3.gdbVersion = this.gdbVersion, s3.moment = this.historicMoment, t3(this.networkServiceUrl, s3);
  }
  async submitTraceJob(e3) {
    const [{ submitTraceJob: t3 }, { default: r5 }] = await Promise.all([import("./trace-RIJG4H7H.js"), import("./TraceParameters-JHRSWJJP.js")]), s3 = r5.from(e3);
    s3.gdbVersion = this.gdbVersion, s3.moment = this.historicMoment;
    const i8 = await t3(this.networkServiceUrl, s3);
    return new n3({ statusUrl: i8 });
  }
  async canAddAssociation(e3) {
    const t3 = await this.getRulesTable();
    if (!t3) return false;
    const { fromNetworkElement: r5, toNetworkElement: s3 } = e3;
    if (!r5 || !s3) return false;
    await t3.load();
    let i8 = null;
    switch (e3.associationType) {
      case "containment":
        i8 = t3.rulesCategorized.containment;
        break;
      case "attachment":
        i8 = t3.rulesCategorized.attachment;
        break;
      default:
        i8 = t3.rulesCategorized.connectivity;
    }
    return i8.some((e4) => c4(e4, r5, s3));
  }
  generateAddAssociations(e3) {
    const { associationsTable: r5 } = this.networkSystemLayers, { fromNetworkSourceId: s3, fromGlobalId: i8, fromTerminalId: a3, toNetworkSourceId: o2, toGlobalId: n4, toTerminalId: l5, associationType: u5, isContentVisible: m6, percentAlong: c5, globalId: y2 } = e2(r5);
    return { addFeatures: e3.map((e4) => new d({ attributes: { [s3]: e4.fromNetworkElement?.networkSourceId, [i8]: e4.fromNetworkElement?.globalId, [a3]: e4.fromNetworkElement?.terminalId, [o2]: e4.toNetworkElement?.networkSourceId, [n4]: e4.toNetworkElement?.globalId, [l5]: e4.toNetworkElement?.terminalId, [u5]: e[e4.associationType], [m6]: null == e4.isContentVisible ? void 0 : e4.isContentVisible ? 1 : 0, [c5]: e4.percentAlong, [y2]: e4.globalId } })), id: this.networkSystemLayers.associationsTableId, identifierFields: { globalIdField: r5?.globalIdField ?? "globalid", objectIdField: r5?.objectIdField ?? "objectid" } };
  }
  generateDeleteAssociations(e3) {
    const { associationsTable: t3, associationsTableId: r5 } = this.networkSystemLayers;
    return { deleteFeatures: e3.map((e4) => ({ globalId: e4.globalId })), id: r5, identifierFields: { globalIdField: t3?.globalIdField ?? "globalid", objectIdField: t3?.objectIdField ?? "objectid" } };
  }
  async loadAssociationsTable() {
    return this.networkSystemLayers.loadAssociationsTable();
  }
  async _loadNamedTraceConfigurationsFromNetwork(e3) {
    if (0 === this.sharedNamedTraceConfigurations?.length) return;
    const t3 = this.sharedNamedTraceConfigurations.map((e4) => e4.globalId), r5 = await this.queryNamedTraceConfigurations({ globalIds: t3 }, e3);
    for (const s3 of this.sharedNamedTraceConfigurations) {
      const e4 = r5?.find((e5) => e5.globalId === s3.globalId);
      if (e4) {
        const t4 = e4.write({}, { origin: "service" });
        s3.read(t4, { origin: "service" });
      }
    }
  }
  async _createRulesTable() {
    const e3 = this.networkSystemLayers.rulesTableUrl, t3 = new Xe({ url: e3 });
    await t3.load();
    const r5 = this.dataElement?.domainNetworks;
    if (!r5) return null;
    const s3 = r5.flatMap((e4) => [...e4.edgeSources || [], ...e4.junctionSources || []]), i8 = (await b3(t3)).map((e4) => this._hydrateRuleInfo(t3, s3, e4));
    return new m4({ rulesLayer: t3, rules: i8 });
  }
  _hydrateRuleInfo(e3, t3, r5) {
    const s3 = e3.fieldsIndex, i8 = s3.get("RULETYPE"), a3 = s3.get("CREATIONDATE"), o2 = s3.get("FROMNETWORKSOURCEID"), n4 = s3.get("FROMASSETGROUP"), l5 = s3.get("FROMASSETTYPE"), u5 = s3.get("FROMTERMINALID"), d4 = s3.get("TONETWORKSOURCEID"), m6 = s3.get("TOASSETGROUP"), c5 = s3.get("TOASSETTYPE"), y2 = s3.get("TOTERMINALID"), p5 = s3.get("VIANETWORKSOURCEID"), h2 = s3.get("VIAASSETGROUP"), I3 = s3.get("VIAASSETTYPE"), g5 = s3.get("VIATERMINALID"), b4 = r5.attributes[i8.name], w3 = new Date(r5.attributes[a3.name]), T2 = [{ networkSourceId: r5.attributes[o2.name], assetGroupId: r5.attributes[n4.name], assetTypeId: r5.attributes[l5.name], terminalId: r5.attributes[u5.name] }, { networkSourceId: r5.attributes[d4.name], assetGroupId: r5.attributes[m6.name], assetTypeId: r5.attributes[c5.name], terminalId: r5.attributes[y2.name] }, { networkSourceId: r5.attributes[p5.name], assetGroupId: r5.attributes[h2.name], assetTypeId: r5.attributes[I3.name], terminalId: r5.attributes[g5.name] }];
    let k4;
    !function(e4) {
      e4[e4.from = 0] = "from", e4[e4.to = 1] = "to", e4[e4.via = 2] = "via";
    }(k4 || (k4 = {}));
    const N2 = { ruleType: b4, creationDate: w3 };
    for (const S2 of [k4.from, k4.to, k4.via]) {
      if (b4 !== t2.RTEdgeJunctionEdgeConnectivity && S2 === k4.via) continue;
      const e4 = T2[S2], r6 = t3.find((t4) => t4.sourceId === e4.networkSourceId), s4 = r6?.assetGroups.find((t4) => t4.assetGroupCode === e4.assetGroupId), i9 = s4?.assetTypes.find((t4) => t4.assetTypeCode === e4.assetTypeId), a4 = this._getTerminal(i9, e4);
      let o3 = "";
      switch (S2) {
        case k4.from:
          o3 = "from";
          break;
        case k4.to:
          o3 = "to";
          break;
        case k4.via:
          o3 = "via";
      }
      N2[`${o3}NetworkSource`] = r6, N2[`${o3}AssetGroup`] = s4, N2[`${o3}AssetType`] = i9, N2[`${o3}Terminal`] = a4?.toJSON();
    }
    return N2;
  }
  _getTerminal(e3, t3) {
    const r5 = e3?.terminalConfigurationId, s3 = this.terminalConfigurations?.find((e4) => e4.id === r5);
    return s3?.terminals?.find((e4) => e4.id === t3.terminalId) ?? null;
  }
};
async function b3(e3) {
  const t3 = new R({ where: "1=1", outFields: ["*"] });
  return (await r4(e3, t3)).features;
}
r([m({ type: [d2], json: { origins: { "web-map": { read: { source: "traceConfigurations" }, write: { target: "traceConfigurations" } }, service: { read: { source: "traceConfigurations" } } }, read: false } })], g4.prototype, "sharedNamedTraceConfigurations", void 0), r([m({ type: ["utility"], readOnly: true, json: { read: false, write: false } })], g4.prototype, "type", void 0), r([m({ readOnly: true })], g4.prototype, "serviceTerritoryFeatureLayerId", null), r([m({ readOnly: true })], g4.prototype, "networkSystemLayers", null), r([m({ readOnly: true })], g4.prototype, "terminalConfigurations", null), r([m({ readOnly: true })], g4.prototype, "domainNetworkNames", null), r([m({ readOnly: true })], g4.prototype, "hasTelecomNetwork", null), g4 = r([a("esri.networks.UtilityNetwork")], g4);
var w2 = g4;

export {
  w2 as w
};
//# sourceMappingURL=chunk-RY4ZYEZD.js.map
