import {
  c2 as c,
  f2,
  f3,
  h,
  i,
  i2 as i4
} from "./chunk-DAJMNP5A.js";
import {
  L,
  f as f4,
  t as t3,
  v
} from "./chunk-EMBDDCJP.js";
import {
  c as c2,
  h as h2
} from "./chunk-MDCTPMKN.js";
import {
  a,
  m,
  n2,
  n3 as n4,
  t2 as t4
} from "./chunk-KQMSRGRD.js";
import {
  e as e3
} from "./chunk-XLYBLHTD.js";
import {
  d as d2,
  o
} from "./chunk-4TBDRMZ4.js";
import {
  d,
  u3 as u2
} from "./chunk-RS3I6DPK.js";
import {
  s2 as s3
} from "./chunk-KCTSIZOP.js";
import {
  n as n3
} from "./chunk-5JV4N5AU.js";
import {
  i as i3
} from "./chunk-QY6CN52R.js";
import {
  o2
} from "./chunk-VT5VIQO4.js";
import {
  p
} from "./chunk-4D63UIH5.js";
import {
  d as d3,
  f
} from "./chunk-ENL2JUSP.js";
import {
  e as e4
} from "./chunk-7KQYSRGY.js";
import {
  s as s2
} from "./chunk-R2Q57RB2.js";
import {
  s
} from "./chunk-PEF2Q5HH.js";
import {
  i as i2
} from "./chunk-A4KKV2O6.js";
import {
  t as t2
} from "./chunk-3ECQNGV5.js";
import {
  u
} from "./chunk-ZPAWXU2P.js";
import {
  e as e2
} from "./chunk-FYCLQ3SU.js";
import {
  n,
  t
} from "./chunk-6EOJZ6DP.js";
import {
  e
} from "./chunk-UZRZVWLE.js";

// node_modules/@arcgis/core/chunks/RealisticTree.glsl.js
function R(R2) {
  const _2 = new i2(), { attributes: z, vertex: k, fragment: G, varyings: U } = _2, { output: W, offsetBackfaces: H, instancedColor: q, pbrMode: J, snowCover: K, spherical: Q, hasBloom: X } = R2, Y = J === n2.Normal || J === n2.Schematic;
  if (f(k, R2), z.add(e.POSITION, "vec3"), U.add("vpos", "vec3", { invariant: true }), _2.include(n3, R2), _2.include(f2, R2), _2.include(s3, R2), _2.include(i3, R2), u(W) && (d3(_2.vertex, R2), _2.include(t2, R2), _2.include(o, R2), H && _2.include(c), q && _2.attributes.add(e.INSTANCECOLOR, "vec4"), U.add("vNormalWorld", "vec3"), U.add("localvpos", "vec3", { invariant: true }), _2.include(d, R2), _2.include(d2, R2), _2.include(i, R2), _2.include(e3, R2), k.uniforms.add(new e4("externalColor", (e5) => e5.externalColor)), U.add("vcolorExt", "vec4"), k.main.add(n`
      forwardNormalizedVertexColor();
      vcolorExt = externalColor;
      ${t(q, "vcolorExt *= instanceColor * 0.003921568627451;")}
      vcolorExt *= vvColor();
      vcolorExt *= getSymbolColor();
      forwardColorMixMode();

      bool alphaCut = vcolorExt.a < ${n.float(o2)};
      vpos = getVertexInLocalOriginSpace();
      localvpos = vpos - view[3].xyz;
      vpos = subtractOrigin(vpos);
      vNormalWorld = dpNormal(vvLocalNormal(normalModel()));
      vpos = addVerticalOffset(vpos, localOrigin);
      vec4 basePosition = transformPosition(proj, view, vpos);

      forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
      forwardLinearDepth();
      forwardTextureCoordinates();

      gl_Position = alphaCut ? vec4(1e38, 1e38, 1e38, 1.0) :
      ${t(H, "offsetBackfacingClipPosition(basePosition, vpos, vNormalWorld, cameraPosition);", "basePosition;")}
    `)), u(W)) {
    const { hasColorTexture: e5, hasColorTextureTransform: o3, receiveShadows: r } = R2;
    _2.include(L, R2), G.include(t3, R2), _2.include(f3, R2), _2.include(R2.instancedDoublePrecision ? c2 : h2, R2), G.include(p, R2), _2.include(u2, R2), d3(G, R2), t4(G), v(G), f4(G), G.uniforms.add(k.uniforms.get("localOrigin"), k.uniforms.get("view"), new e2("ambient", (e6) => e6.ambient), new e2("diffuse", (e6) => e6.diffuse), new s("opacity", (e6) => e6.opacity), new s("layerOpacity", (e6) => e6.layerOpacity)), e5 && G.uniforms.add(new s2("tex", (e6) => e6.texture)), _2.include(m, R2), G.include(n4, R2), G.include(i4), a(G), G.main.add(n`
      discardBySlice(vpos);
      discardByTerrainDepth();
      vec4 texColor = ${e5 ? `texture(tex, ${o3 ? "colorUV" : "vuv0"})` : " vec4(1.0)"};
      ${t(e5, `${t(R2.textureAlphaPremultiplied, "texColor.rgb /= texColor.a;")}
        discardOrAdjustAlpha(texColor);`)}
      vec3 viewDirection = normalize(vpos - cameraPosition);
      applyPBRFactors();
      float ssao = evaluateAmbientOcclusionInverse();
      ssao *= getBakedOcclusion();

      float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
      float shadow = ${r ? "max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))" : Q ? "lightingGlobalFactor * (1.0 - additionalAmbientScale)" : "0.0"};
      vec3 matColor = max(ambient, diffuse);
      ${R2.hasVertexColors ? n`vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
             float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));` : n`vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
             float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}
      ${t(K, "albedo = mix(albedo, vec3(1), 0.9);")}
      ${n`vec3 shadingNormal = normalize(vNormalWorld);
             albedo *= 1.2;
             vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);
             float alignmentLightView = clamp(dot(viewForward, -mainLightDirection), 0.0, 1.0);
             float transmittance = 1.0 - clamp(dot(viewForward, shadingNormal), 0.0, 1.0);
             float treeRadialFalloff = vColor.r;
             float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);
             additionalLight += backLightFactor * mainLightIntensity;`}
      ${t(Y, `vec3 normalGround = ${Q ? "normalize(vpos + localOrigin)" : "vec3(0.0, 0.0, 1.0)"};`)}
      ${Y ? n`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
                 ${t(K, n`mrr = applySnowToMRR(mrr, 1.0)`)}
            vec4 emission = ${K || X ? "vec4(0.0)" : "getEmissions(albedo)"};
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);` : n`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
      vec4 finalColor = vec4(shadedColor, opacity_);
      outputColorHighlightOID(finalColor, vpos, albedo ${t(K, ", 1.0")});`);
  }
  return _2.include(h, R2), _2;
}
var _ = Object.freeze(Object.defineProperty({ __proto__: null, build: R }, Symbol.toStringTag, { value: "Module" }));

export {
  R,
  _
};
//# sourceMappingURL=chunk-TEFCZNLX.js.map
