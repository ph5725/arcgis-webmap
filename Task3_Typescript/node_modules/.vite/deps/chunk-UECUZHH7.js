import {
  e
} from "./chunk-KSRBNZJ2.js";
import {
  l as l6
} from "./chunk-CL7PETHS.js";
import {
  v
} from "./chunk-CAZNHUEV.js";
import {
  l as l3,
  l2 as l4,
  t as t2
} from "./chunk-3LRL7HAL.js";
import {
  l as l2
} from "./chunk-4OESBQFK.js";
import {
  l as l7,
  m as m2,
  p as p3
} from "./chunk-6U2RA2A3.js";
import {
  O
} from "./chunk-UGHHK55N.js";
import {
  t
} from "./chunk-5SRIFOTG.js";
import {
  l as l5
} from "./chunk-KE3WBZYL.js";
import {
  r as r3
} from "./chunk-EOMIFMDH.js";
import {
  n as n3,
  r as r4
} from "./chunk-45ILJ6ZH.js";
import {
  n as n2
} from "./chunk-65K4DQAH.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import {
  a as a3
} from "./chunk-TVM3SZJR.js";
import {
  n
} from "./chunk-HCYE6OE4.js";
import {
  o as o3
} from "./chunk-YIV2QKTZ.js";
import {
  p as p2
} from "./chunk-SRQCQD63.js";
import {
  o as o2
} from "./chunk-JUAPMINU.js";
import {
  r as r2
} from "./chunk-YFPGM5UE.js";
import {
  s as s3
} from "./chunk-KTUX3OKX.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  b as b2,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2
} from "./chunk-JUAD7TJ6.js";
import {
  w,
  x
} from "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  H,
  p
} from "./chunk-ZWFY3WY5.js";
import {
  b,
  s as s2,
  u2 as u
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import {
  a
} from "./chunk-GWNLQRNM.js";
import {
  o
} from "./chunk-FXKORAMT.js";

// node_modules/@arcgis/core/ground/NavigationConstraint.js
var p4;
var c = p4 = class extends l {
  constructor(o4) {
    super(o4), this.type = "none";
  }
  clone() {
    return new p4({ type: this.type });
  }
};
r([r3({ none: "none", stayAbove: "stay-above" }), m({ json: { write: { isRequired: true } } })], c.prototype, "type", void 0), c = p4 = r([a2("esri.ground.NavigationConstraint")], c);

// node_modules/@arcgis/core/support/groundInstanceUtils.js
var n4 = Symbol("GroundInstance");

// node_modules/@arcgis/core/Ground.js
var C;
var I;
var _a;
var L = I = (_a = class extends l.JSONSupportMixin(p2) {
  constructor(r5) {
    super(r5), this[C] = true, this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new V();
    const e2 = (r6) => {
      r6.parent && r6.parent !== this && "remove" in r6.parent && r6.parent.remove(r6), r6.parent = this, "elevation" !== r6.type && "base-elevation" !== r6.type && i.getLogger(this).error(`Layer '${r6.title}, id:${r6.id}' of type '${r6.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, t4 = (r6) => {
      r6.parent = null;
    };
    this.addHandles([this.layers.on("after-add", (r6) => e2(r6.item)), this.layers.on("after-remove", (r6) => t4(r6.item))]);
  }
  initialize() {
    this.when().catch((r5) => {
      b(r5) || i.getLogger(this).error("#load()", "Failed to load ground", r5);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const r5 = this.layers.removeAll();
    for (const e2 of r5) u(e2);
    this.layers.destroy();
  }
  normalizeCtorArgs(r5) {
    return r5 && "resourceInfo" in r5 && (this._set("resourceInfo", r5.resourceInfo), delete (r5 = { ...r5 }).resourceInfo), r5;
  }
  get layers() {
    return this._get("layers");
  }
  set layers(r5) {
    this._set("layers", n2(r5, this._get("layers")));
  }
  writeLayers(r5, e2, o4, t4) {
    const i4 = [];
    r5 ? (t4 = { ...t4, layerContainerType: "ground" }, r5.forEach((r6) => {
      if ("write" in r6) {
        const e3 = {};
        o(r6)().write(e3, t4) && i4.push(e3);
      } else t4?.messages && t4.messages.push(new s("layer:unsupported", `Layers (${r6.title}, ${r6.id}) of type '${r6.declaredClass}' cannot be persisted in the ground`, { layer: r6 }));
    }), e2.layers = i4) : e2.layers = i4;
  }
  load(r5) {
    return this.addResolvingPromise(this._loadFromSource(r5)), Promise.resolve(this);
  }
  loadAll() {
    return t(this, (r5) => {
      r5(this.layers);
    });
  }
  async queryElevation(r5, e2) {
    await this.load({ signal: e2?.signal });
    const { ElevationQuery: o4 } = await import("./ElevationQuery-CKIMOXQG.js");
    s2(e2);
    const t4 = new o4(), s4 = this.layers.filter(A).toArray();
    return t4.queryAll(s4, r5, e2);
  }
  async createElevationSampler(r5, e2) {
    await this.load({ signal: e2?.signal });
    const { ElevationQuery: o4 } = await import("./ElevationQuery-CKIMOXQG.js");
    s2(e2);
    const t4 = new o4(), s4 = this.layers.filter(A).toArray();
    return t4.createSamplerAll(s4, r5, e2);
  }
  clone() {
    const r5 = { opacity: this.opacity, surfaceColor: a(this.surfaceColor), navigationConstraint: a(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r5.loadStatus = "loaded"), new I({ resourceInfo: this.resourceInfo }).set(r5);
  }
  read(r5, e2) {
    this.resourceInfo || this._set("resourceInfo", { data: r5, context: e2 }), super.read(r5, e2);
  }
  _loadFromSource(r5) {
    const e2 = this.resourceInfo;
    return e2 ? this._loadLayersFromJSON(e2.data, e2.context, r5) : Promise.resolve();
  }
  async _loadLayersFromJSON(r5, e2, o4) {
    const t4 = e2?.origin || "web-scene", s4 = e2?.portal || null, a6 = e2?.url || null, { populateOperationalLayers: i4 } = await import("./layersCreator-NB7JC7SG.js");
    s2(o4);
    const n5 = [];
    if (r5.layers && Array.isArray(r5.layers)) {
      const e3 = { context: { origin: t4, url: a6, portal: s4, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
      n5.push(i4(this.layers, r5.layers, e3));
    }
    await Promise.allSettled(n5);
  }
}, C = n4, _a);
function b3(r5) {
  return r5 && "createElevationSampler" in r5;
}
function A(r5) {
  return "elevation" === r5.type || b3(r5);
}
r([m({ json: { read: false, write: { isRequired: true } } })], L.prototype, "layers", null), r([r2("layers")], L.prototype, "writeLayers", null), r([m({ readOnly: true })], L.prototype, "resourceInfo", void 0), r([m({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: x, read: { reader: r4, source: "transparency" }, write: { writer: (r5, e2) => {
  e2.transparency = n3(r5);
}, target: "transparency" } } })], L.prototype, "opacity", void 0), r([m({ type: l5, json: { type: [x], write: (r5, e2) => {
  e2.surfaceColor = r5.toJSON().slice(0, 3);
} } })], L.prototype, "surfaceColor", void 0), r([m({ type: c, json: { write: true } })], L.prototype, "navigationConstraint", void 0), L = I = r([a2("esri.Ground")], L);
var E = L;

// node_modules/@arcgis/core/effects/FocusAreaOutline.js
var i2 = class extends a3.ClonableMixin(l) {
  constructor(o4) {
    super(o4), this.color = null;
  }
};
r([m({ type: l5, json: { type: [x], write: true } })], i2.prototype, "color", void 0), i2 = r([a2("esri.effects.FocusAreaOutline")], i2);
var m3 = i2;

// node_modules/@arcgis/core/effects/FocusArea.js
var u2 = class extends l.JSONSupportMixin(a3) {
  constructor(e2) {
    super(e2), this.id = `focusarea-${n()}`, this.title = null, this.enabled = true, this.outline = null, this.geometries = new l6();
  }
  readGeometries(e2, o4, r5) {
    Array.isArray(e2) ? this.geometries = l6.fromJSON(e2, r5) : r5.hooks?.onAfterLoad?.(() => this._loadGeometries(p(e2, r5), r5));
  }
  async _loadGeometries(e2, r5) {
    const t4 = await H(e2, { responseType: "json" });
    this.geometries = l6.fromJSON(t4.data, r5);
  }
};
r([m({ type: String, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } }), m()], u2.prototype, "id", void 0), r([m({ type: String, json: { write: true } })], u2.prototype, "title", void 0), r([m({ type: Boolean, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } })], u2.prototype, "enabled", void 0), r([m({ type: m3, json: { write: true } })], u2.prototype, "outline", void 0), r([m({ type: l6, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } }, clonable: (e2) => new l6(e2.items.map((e3) => e3.clone())) }), v({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], u2.prototype, "geometries", void 0), r([o2(["web-scene", "portal-item"], "geometries")], u2.prototype, "readGeometries", null), u2 = r([a2("esri.effects.FocusArea")], u2);
var d = u2;

// node_modules/@arcgis/core/effects/FocusAreas.js
var c2 = class extends l.JSONSupportMixin(a3) {
  constructor(o4) {
    super(o4), this.areas = new V(), this.style = "bright";
  }
};
r([m({ type: V.ofType(d), nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } }, clonable: (o4) => new V(o4.items.map((o5) => o5.clone())) })], c2.prototype, "areas", void 0), r([m({ type: ["bright", "dark"], nonNullable: true, json: { write: true } })], c2.prototype, "style", void 0), c2 = r([a2("esri.effects.FocusAreas")], c2);
var a4 = c2;

// node_modules/@arcgis/core/support/groundUtils.js
var i3 = { "world-elevation": { id: "worldElevation", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function t3(t4) {
  let a6 = null;
  if ("string" == typeof t4) if (t4 in i3) {
    const r5 = i3[t4];
    a6 = new E({ resourceInfo: { data: { layers: [r5] } } });
  } else i.getLogger("esri.support.groundUtils").warn(`Unable to find ground definition for: ${t4}. Try "world-elevation"`);
  else a6 = w(E, t4);
  return a6;
}

// node_modules/@arcgis/core/Map.js
var g = class extends l4(l3(o3.EventedMixin(b2))) {
  constructor(e2) {
    super(e2), this.allLayers = new l2({ getCollections: () => [this.basemap?.baseLayers, this.ground?.layers, this.layers, this.basemap?.referenceLayers], getChildrenFunction: (e3) => "layers" in e3 ? e3.layers : null }), this.focusAreas = new a4(), this.allTables = t2(this), this.basemap = null, this.editableLayers = new l2({ getCollections: () => [this.allLayers], itemFilterFunction: e }), this.ground = new E(), this._basemapCache = p3();
  }
  destroy() {
    l7(this._basemapCache), this._basemapCache = null, this.focusAreas.destroy(), this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), this.basemap = u(this.basemap), u(this.ground), this._set("ground", null);
  }
  castBasemap(e2) {
    return m2(e2, this._basemapCache);
  }
  castGround(e2) {
    const s4 = t3(e2);
    return s4 ?? this._get("ground");
  }
  findLayerById(e2) {
    return this.allLayers.find((s4) => s4.id === e2);
  }
  findTableById(e2) {
    return this.allTables.find((s4) => s4.id === e2);
  }
};
r([m({ readOnly: true, dependsOn: [] })], g.prototype, "allLayers", void 0), r([m({ type: a4, nonNullable: true, json: { write: { overridePolicy: (e2) => ({ enabled: e2.areas.length > 0, ignoreOrigin: true }) } } })], g.prototype, "focusAreas", void 0), r([m({ readOnly: true })], g.prototype, "allTables", void 0), r([m({ type: O, json: { read: { source: "baseMap" }, write: { target: "baseMap" } } })], g.prototype, "basemap", void 0), r([s3("basemap")], g.prototype, "castBasemap", null), r([m({ readOnly: true })], g.prototype, "editableLayers", void 0), r([m({ type: E, nonNullable: true })], g.prototype, "ground", void 0), r([s3("ground")], g.prototype, "castGround", null), r([m()], g.prototype, "undoRedo", void 0), g = r([a2("esri.Map")], g);
var L2 = g;

// node_modules/@arcgis/core/webmap/background/ColorBackground.js
var p5;
var a5 = p5 = class extends l {
  constructor(o4) {
    super(o4), this.color = new l5([0, 0, 0, 1]);
  }
  clone() {
    return new p5(a({ color: this.color }));
  }
};
r([m({ type: l5, json: { write: true } })], a5.prototype, "color", void 0), a5 = p5 = r([a2("esri.webmap.background.ColorBackground")], a5);
var m4 = a5;

export {
  L2 as L,
  m4 as m
};
//# sourceMappingURL=chunk-UECUZHH7.js.map
