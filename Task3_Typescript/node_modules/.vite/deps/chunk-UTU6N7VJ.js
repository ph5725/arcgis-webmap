import {
  r as r3
} from "./chunk-RV3SBM2C.js";
import {
  n
} from "./chunk-4GXVCEW4.js";
import {
  c
} from "./chunk-7WKBQS4R.js";
import {
  m as m2
} from "./chunk-HUVZEBBO.js";
import {
  $
} from "./chunk-VLPG2W66.js";
import {
  R
} from "./chunk-7ZMGKXLG.js";
import {
  i,
  p
} from "./chunk-6TS2ZJL4.js";
import {
  D
} from "./chunk-LYSDGL5S.js";
import {
  Fe,
  ye
} from "./chunk-VCRP2PLV.js";
import {
  e as e2
} from "./chunk-BDLVUYG2.js";
import {
  b
} from "./chunk-HPGYEHVI.js";
import {
  B,
  P
} from "./chunk-YBJ5GVXQ.js";
import {
  e
} from "./chunk-HCYE6OE4.js";
import {
  r as r2
} from "./chunk-YFPGM5UE.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2,
  u
} from "./chunk-JUAD7TJ6.js";
import {
  w
} from "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  o
} from "./chunk-3NBBZ43U.js";
import {
  s as s2
} from "./chunk-ZWFY3WY5.js";
import {
  s
} from "./chunk-XWG6QGFK.js";
import {
  a
} from "./chunk-GWNLQRNM.js";

// node_modules/@arcgis/core/rest/support/AttachmentQuery.js
var a3;
var _a;
var p2 = (_a = class extends l {
  constructor(t) {
    super(t), this.attachmentTypes = null, this.attachmentsWhere = null, this.cacheHint = void 0, this.keywords = null, this.globalIds = null, this.name = null, this.num = null, this.objectIds = null, this.orderByFields = null, this.returnMetadata = false, this.size = null, this.start = null, this.where = null;
  }
  writeStart(t, e3) {
    e3.resultOffset = this.start, e3.resultRecordCount = this.num || 10;
  }
  clone() {
    return new a3(a({ attachmentTypes: this.attachmentTypes, attachmentsWhere: this.attachmentsWhere, cacheHint: this.cacheHint, keywords: this.keywords, where: this.where, globalIds: this.globalIds, name: this.name, num: this.num, objectIds: this.objectIds, orderByFields: this.orderByFields, returnMetadata: this.returnMetadata, size: this.size, start: this.start }));
  }
}, a3 = _a, _a);
r([m({ type: [String], json: { write: true } })], p2.prototype, "attachmentTypes", void 0), r([m({ type: String, json: { read: { source: "attachmentsDefinitionExpression" }, write: { target: "attachmentsDefinitionExpression" } } })], p2.prototype, "attachmentsWhere", void 0), r([m({ type: Boolean, json: { write: true } })], p2.prototype, "cacheHint", void 0), r([m({ type: [String], json: { write: true } })], p2.prototype, "keywords", void 0), r([m({ type: [String], json: { write: true } })], p2.prototype, "globalIds", void 0), r([m({ json: { write: true } })], p2.prototype, "name", void 0), r([m({ type: Number, json: { read: { source: "resultRecordCount" } } })], p2.prototype, "num", void 0), r([m({ type: [Number], json: { write: true } })], p2.prototype, "objectIds", void 0), r([m({ type: [String], json: { write: true } })], p2.prototype, "orderByFields", void 0), r([m({ type: Boolean, json: { default: false, write: true } })], p2.prototype, "returnMetadata", void 0), r([m({ type: [Number], json: { write: true } })], p2.prototype, "size", void 0), r([m({ type: Number, json: { read: { source: "resultOffset" } } })], p2.prototype, "start", void 0), r([r2("start"), r2("num")], p2.prototype, "writeStart", null), r([m({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], p2.prototype, "where", void 0), p2 = a3 = r([a2("esri.rest.support.AttachmentQuery")], p2), p2.from = w(p2);

// node_modules/@arcgis/core/layers/support/featureLayerUtils.js
var j = new o({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" });
async function F(e3, t, n2, o2) {
  const i2 = await $2(e3);
  if (await x(e3, t, o2), !i2.addAttachment) throw new s(o2, "Layer source does not support addAttachment capability");
  return i2.addAttachment(t, n2);
}
function x(e3, t, n2) {
  const { attributes: o2 } = t, { objectIdField: i2 } = e3;
  return e3.capabilities?.data?.supportsAttachment ? t ? o2 ? i2 && o2[i2] ? Promise.resolve() : Promise.reject(new s(n2, `feature is missing the identifying attribute ${i2}`)) : Promise.reject(new s(n2, "'attributes' are required on a feature to query attachments")) : Promise.reject(new s(n2, "A feature is required to add/delete/update attachments")) : Promise.reject(new s(n2, "this layer doesn't support attachments"));
}
async function P2(e3, t, n2, o2, i2) {
  const s3 = await $2(e3);
  if (await x(e3, t, i2), !s3.updateAttachment) throw new s(i2, "Layer source does not support updateAttachment capability");
  return s3.updateAttachment(t, n2, o2);
}
async function q(e3, t, r4) {
  const { applyEdits: n2 } = await import("./editingSupport-PKXMF3HO.js"), o2 = await e3.load();
  let i2 = r4;
  return "feature" === o2.type && o2.infoFor3D && null != t.deleteFeatures && null != o2.globalIdField && (i2 = { ...i2, globalIdToObjectId: await ne(o2, t.deleteFeatures, o2.globalIdField) }), n2(o2, o2.source, t, r4);
}
async function S(e3, t, r4) {
  const { uploadAssets: n2 } = await import("./editingSupport-PKXMF3HO.js"), o2 = await e3.load();
  return n2(o2, o2.source, t, r4);
}
async function v(e3, t, n2, o2) {
  const i2 = await $2(e3);
  if (await x(e3, t, o2), !i2.deleteAttachments) throw new s(o2, "Layer source does not support deleteAttachments capability");
  return i2.deleteAttachments(t, n2);
}
async function O(e3, t, n2) {
  const o2 = (await e3.load({ signal: t?.signal })).source;
  if (!o2.fetchRecomputedExtents) throw new s(n2, "Layer source does not support fetchUpdates capability");
  return o2.fetchRecomputedExtents(t);
}
async function A(e3, t, n2, o2) {
  t = p2.from(t), await e3.load();
  const i2 = e3.source, s3 = e3.capabilities;
  if (!s3?.data?.supportsAttachment) throw new s(o2, "this layer doesn't support attachments");
  const { attachmentTypes: a4, objectIds: u2, globalIds: c2, num: l2, size: p3, start: d, where: f } = t;
  if (!s3?.operations?.supportsQueryAttachments) {
    if (a4?.length > 0 || c2?.length > 0 || p3?.length > 0 || l2 || d || f) throw new s(o2, "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", t);
  }
  if (!(u2?.length || c2?.length || f)) throw new s(o2, "'objectIds', 'globalIds', or 'where' are required to perform attachment query", t);
  if (!i2.queryAttachments) throw new s(o2, "Layer source does not support queryAttachments capability", t);
  return !s3?.attachment?.supportsOrderByFields && t.orderByFields?.length && ((t = t.clone()).orderByFields = null), i2.queryAttachments(t);
}
async function L(e3, t, n2, o2) {
  const i2 = await $2(e3);
  if (!i2.queryObjectIds) throw new s(o2, "Layer source does not support queryObjectIds capability");
  return i2.queryObjectIds(R.from(t) ?? e3.createQuery(), n2);
}
async function E(e3, t, n2, o2) {
  const i2 = await $2(e3);
  if (!i2.queryFeatureCount) throw new s(o2, "Layer source does not support queryFeatureCount capability");
  return i2.queryFeatureCount(R.from(t) ?? e3.createQuery(), n2);
}
async function D2(e3, t, n2, o2) {
  const i2 = await $2(e3);
  if (!i2.queryExtent) throw new s(o2, "Layer source does not support queryExtent capability");
  return i2.queryExtent(R.from(t) ?? e3.createQuery(), n2);
}
async function T(e3, t, n2, o2) {
  const i2 = await $2(e3);
  if (!i2.queryRelatedFeatures) throw new s(o2, "Layer source does not support queryRelatedFeatures capability");
  return i2.queryRelatedFeatures(c.from(t), n2);
}
async function C(e3, t, n2, o2) {
  const i2 = await $2(e3);
  if (!i2.queryRelatedFeaturesCount) throw new s(o2, "Layer source does not support queryRelatedFeaturesCount capability");
  return i2.queryRelatedFeaturesCount(c.from(t), n2);
}
async function B2(e3) {
  const t = e3.source;
  if (t?.refresh) try {
    const { dataChanged: r4, updates: n2 } = await t.refresh();
    if (null != n2 && (e3.sourceJSON = { ...e3.sourceJSON, ...n2 }, e3.read(n2, { origin: "service", url: e3.parsedUrl })), r4) return true;
  } catch {
  }
  if (e3.definitionExpression) try {
    return (await e2(e3.definitionExpression, e3.fieldsIndex)).hasDateFunctions;
  } catch {
  }
  return false;
}
function R2(e3) {
  const t = new R();
  t.historicMoment = e3.historicMoment, t.gdbVersion = e3.gdbVersion, t.returnGeometry = true, t.outFields = ["*"], t.multipatchOption = "multipatch" === e3.geometryType ? "xyFootprint" : null;
  const r4 = e3.capabilities?.query;
  r4 && (t.compactGeometryEnabled = r4.supportsCompactGeometry, t.defaultSpatialReferenceEnabled = r4.supportsDefaultSpatialReference);
  const n2 = e3.capabilities?.data;
  n2?.supportsZ && null != e3.returnZ && (t.returnZ = e3.returnZ), n2?.supportsM && null != e3.returnM && (t.returnM = e3.returnM);
  const { timeOffset: o2, timeExtent: i2 } = e3;
  return t.timeExtent = null != o2 && null != i2 ? i2.offset(-o2.value, o2.unit) : i2 || null, t;
}
function M(e3) {
  const { globalIdField: t, fields: r4 } = e3;
  if (t) return t;
  if (r4) {
    for (const n2 of r4) if ("esriFieldTypeGlobalID" === n2.type) return n2.name;
  }
}
function k(e3) {
  const { objectIdField: t, fields: r4 } = e3;
  if (t) return t;
  if (r4) {
    for (const n2 of r4) if ("esriFieldTypeOID" === n2.type) return n2.name;
  }
}
function z(e3) {
  return e3.currentVersion ? e3.currentVersion : e3.hasOwnProperty("capabilities") || e3.hasOwnProperty("drawingInfo") || e3.hasOwnProperty("hasAttachments") || e3.hasOwnProperty("htmlPopupType") || e3.hasOwnProperty("relationships") || e3.hasOwnProperty("timeInfo") || e3.hasOwnProperty("typeIdField") || e3.hasOwnProperty("types") ? 10 : 9.3;
}
function N(e3, t, r4, n2) {
  const o2 = r4?.feature, i2 = !!e3.subtypes?.length;
  if (i2 && !r4?.excludeImpliedDomains) {
    const r5 = U(e3, t);
    if (r5) return r5;
  }
  const s3 = i2 && Q(e3, o2);
  if (s3) {
    const e4 = s3?.domains?.[t];
    return "inherited" === e4?.type ? n2 : e4;
  }
  const a4 = oe(e3.types, e3.typeIdField, o2);
  if (a4) {
    const e4 = a4.domains && a4.domains[t];
    if (e4 && "inherited" !== e4?.type) return e4;
  }
  if (n2) return n2;
  if (!r4?.excludeImpliedDomains) {
    const r5 = V(e3, t);
    if (r5) return r5;
  }
  return null;
}
function Q(e3, t) {
  const { subtypes: r4, subtypeField: n2 } = e3;
  if (!t?.attributes || !r4?.length || !n2) return null;
  const o2 = t.attributes[n2];
  return null == o2 ? null : r4.find((e4) => e4.code === o2);
}
function U(e3, t) {
  const { fieldsIndex: r4, subtypeField: n2 } = e3, { name: o2, type: i2 } = r4.get(t) ?? {};
  if (!o2) return null;
  if ((n2 && r4.get(n2)?.name) === o2 && e3.subtypes?.length) {
    const t2 = e3.subtypes.map((e4) => new p({ code: G(e4.code, i2), name: e4.name }));
    if (t2?.length) return new i({ codedValues: t2 });
  }
  return null;
}
function V(e3, t) {
  const { fieldsIndex: r4 } = e3, { name: n2, type: o2 } = r4.get(t) ?? {};
  if (!n2) return null;
  if (("typeIdField" in e3 ? r4.get(e3.typeIdField)?.name : null) === n2 && "types" in e3 && e3.types?.length) {
    const t2 = e3.types.map((e4) => new p({ code: G(e4.id, o2), name: e4.name }));
    return new i({ codedValues: t2 });
  }
  return null;
}
function G(e3, t) {
  return t ? Fe({ type: t }) && "number" == typeof e3 ? `${e3}` : ye({ type: t }) && "string" == typeof e3 ? Number.parseInt(e3, 10) : e3 : e3;
}
async function $2(e3) {
  return (await e3.load()).source;
}
async function J(t, r4) {
  if (!s2) return;
  const n2 = s2.findCredential(t);
  if (n2) return n2.userId;
  let o2;
  try {
    const n3 = await B(t, r4);
    n3 && (o2 = await s2.checkSignInStatus(`${n3}/sharing`));
  } catch (i2) {
  }
  return o2 ? o2.userId : null;
}
async function Z(t, r4) {
  if (!s2) return;
  if (s2.findCredential(t)) return;
  let n2;
  try {
    const o2 = await B(t, r4);
    o2 && (n2 = await s2.checkSignInStatus(`${o2}/sharing`));
  } catch (o2) {
  }
  if (n2) try {
    const n3 = null != r4 ? r4.signal : null;
    await s2.getCredential(t, { signal: n3 });
  } catch (o2) {
  }
}
async function H(e3, t, r4) {
  const n2 = e3.parsedUrl?.path;
  n2 && e3.authenticationTriggerEvent === t && await Z(n2, r4);
}
async function W(e3) {
  const t = e3.parsedUrl?.path;
  t && _(e3) && await Z(t);
}
function _(e3) {
  return K(e3) && ("serviceDefinitionExpression" in e3 && X(e3.serviceDefinitionExpression) || "definitionExpression" in e3 && X(e3.definitionExpression));
}
function K(e3) {
  return !(!P(e3) || !e3.capabilities?.query.supportsCurrentUser);
}
function X(e3) {
  return !!e3?.toLowerCase().includes("current_user");
}
function Y(e3) {
  return !ie(e3) && (e3.userHasUpdateItemPrivileges || e3.editingEnabled);
}
var ee = u({ types: D });
function te(e3, t) {
  if (e3.defaultSymbol) return e3.types?.length ? new $({ defaultSymbol: ee(e3.defaultSymbol, e3, t), field: e3.typeIdField, uniqueValueInfos: e3.types.map((e4) => ({ id: e4.id, symbol: ee(e4.symbol, e4, t) })) }) : new m2({ symbol: ee(e3.defaultSymbol, e3, t) });
}
function re(e3) {
  let t = e3.sourceJSON?.cacheMaxAge;
  if (!t) return false;
  const r4 = e3.editingInfo?.lastEditDate?.getTime();
  return null == r4 || (t *= 1e3, Date.now() - r4 < t);
}
async function ne(e3, r4, n2) {
  if (null == r4) return null;
  const o2 = [], { objectIdField: s3 } = e3;
  if (r4.forEach((e4) => {
    let t = null;
    if ("attributes" in e4) {
      const { attributes: r5 } = e4;
      t = { globalId: r5[n2], objectId: null != r5[s3] && -1 !== r5[s3] ? r5[s3] : null };
    } else t = { globalId: e4.globalId, objectId: null != e4.objectId && -1 !== e4.objectId ? e4.objectId : null };
    null != t.globalId && (null != t.objectId && -1 !== t.objectId || o2.push(t.globalId));
  }), 0 === o2.length) return null;
  const a4 = e3.createQuery();
  a4.where = o2.map((e4) => `${n2}='${e4}'`).join(" OR "), a4.returnGeometry = false, a4.outFields = [s3, n2], a4.cacheHint = false;
  const u2 = await b(r3(e3, a4));
  if (!u2.ok) return null;
  const l2 = /* @__PURE__ */ new Map(), p3 = u2.value.features;
  for (const t of p3) {
    const e4 = t.attributes[n2], r5 = t.attributes[s3];
    null != e4 && null != r5 && -1 !== r5 && l2.set(e(e4), r5);
  }
  return l2;
}
function oe(e3, t, r4) {
  if (!t || !r4 || !e3) return null;
  const n2 = r4.getAttribute(t);
  return null == n2 ? null : e3.find((e4) => {
    const { id: t2 } = e4;
    return null != t2 && t2.toString() === n2.toString();
  }) ?? null;
}
function ie(e3) {
  return e3.sourceJSON?.isMultiServicesView || se(e3);
}
function se(e3) {
  return !!e3.sourceJSON?.capabilities?.toLowerCase().split(",").map((e4) => e4.trim()).includes("map");
}
function ae(e3, t, n2) {
  const o2 = t?.queryAttributeBins;
  if (!t?.operations?.supportsQueryBins || !o2) throw new s(n2, "Layer source does not support binning");
  switch (e3.binParameters.type) {
    case "auto-interval":
      if (!o2.supportsAutoInterval) throw new s(n2, "Layer source does not support auto-interval binning");
      if (e3.binParameters.normalizationType && (!o2.supportsNormalization || !ue(e3.binParameters.normalizationType, o2.supportedNormalizationTypes))) throw new s(n2, "Layer source does not support normalization binning");
      break;
    case "date":
      if (!o2.supportsDate) throw new s(n2, "Layer source does not support date binning");
      if (e3.binParameters.snapToData && !o2.supportsSnapToData) throw new s(n2, "Layer source does not support snapToData binning");
      if (e3.binParameters.returnFullIntervalBin && !o2.supportsReturnFullIntervalBin) throw new s(n2, "Layer source does not support returnFullIntervalBin binning");
      break;
    case "fixed-boundaries":
      if (!o2.supportsFixedBoundaries) throw new s(n2, "Layer source does not support fixed-boundaries binning");
      break;
    case "fixed-interval":
      if (!o2.supportsFixedInterval) throw new s(n2, "Layer source does not support fixed-interval binning");
      if (e3.binParameters.normalizationType && (!o2.supportsNormalization || !ue(e3.binParameters.normalizationType, o2.supportedNormalizationTypes))) throw new s(n2, "Layer source does not support normalization binning");
  }
  if (e3.binParameters.stackBy && !o2.supportsStackBy) throw new s(n2, "Layer source does not support stackBy binning");
  if (e3.binParameters.splitBy && !o2.supportsSplitBy) throw new s(n2, "Layer source does not support splitBy binning");
  if (e3.binParameters.firstDayOfWeek && !o2.supportsFirstDayOfWeek) throw new s(n2, "Layer source does not support firstDayOfWeek binning");
  const i2 = o2?.supportedStatistics;
  if (e3.outStatistics && i2) {
    const t2 = /* @__PURE__ */ new Map([["count", "count"], ["sum", "sum"], ["min", "min"], ["max", "max"], ["avg", "avg"], ["stddev", "stddev"], ["var", "var"], ["percentile-continuous", "percentileContinuous"], ["percentile-discrete", "percentileDiscrete"], ["centroid-aggregate", "centroid"], ["convex-hull-aggregate", "convexHull"], ["envelope-aggregate", "envelope"]]);
    for (const { statisticType: o3 } of e3.outStatistics) {
      const e4 = t2.get(o3);
      if (e4 && !i2[e4]) throw new s(n2, `Layer source does not support ${o3} statistic type`);
    }
  }
}
function ue(e3, t) {
  return null != e3 && !!t?.[n.toJSON(e3)];
}

export {
  p2 as p,
  j,
  F,
  P2 as P,
  q,
  S,
  v,
  O,
  A,
  L,
  E,
  D2 as D,
  T,
  C,
  B2 as B,
  R2 as R,
  M,
  k,
  z,
  N,
  Q,
  U,
  J,
  H,
  W,
  X,
  Y,
  te,
  re,
  ne,
  oe,
  ie,
  ae
};
//# sourceMappingURL=chunk-UTU6N7VJ.js.map
