import {
  f
} from "./chunk-UGXCZZ7N.js";
import {
  k
} from "./chunk-F4KXGA4J.js";
import {
  _
} from "./chunk-HPGYEHVI.js";
import {
  B
} from "./chunk-YBJ5GVXQ.js";
import {
  C,
  u as u2
} from "./chunk-6PV45IYU.js";
import {
  o
} from "./chunk-JUAPMINU.js";
import {
  r as r2
} from "./chunk-YFPGM5UE.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  H,
  s as s4
} from "./chunk-ZWFY3WY5.js";
import {
  D,
  K,
  W
} from "./chunk-LQFTAGIV.js";
import {
  a as a2,
  b,
  s as s3,
  u2 as u
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s as s2
} from "./chunk-XWG6QGFK.js";
import {
  s
} from "./chunk-GWNLQRNM.js";

// node_modules/@arcgis/core/layers/mixins/PortalLayer.js
var j = (j2) => {
  let E = class extends j2 {
    constructor() {
      super(...arguments), this.resourceReferences = { portalItem: null, paths: [] }, this.userHasEditingPrivileges = true, this.userHasFullEditingPrivileges = false, this.userHasUpdateItemPrivileges = false;
    }
    destroy() {
      this.portalItem = u(this.portalItem), this.resourceReferences.portalItem = null, this.resourceReferences.paths.length = 0;
    }
    set portalItem(e) {
      e !== this._get("portalItem") && (this.removeOrigin("portal-item"), this._set("portalItem", e));
    }
    readPortalItem(e, t, r3) {
      if (t.itemId) return new k({ id: t.itemId, portal: r3?.portal });
    }
    writePortalItem(e, t) {
      e?.id && (t.itemId = e.id);
    }
    async loadFromPortal(e, t) {
      if (this.portalItem?.id) try {
        const { load: r3 } = await import("./layersLoader-KCNTTM4O.js");
        return s3(t), await r3({ instance: this, supportedTypes: e.supportedTypes, validateItem: e.validateItem, supportsData: e.supportsData, layerModuleTypeMap: e.layerModuleTypeMap, populateGroupLayer: e.populateGroupLayer }, t);
      } catch (r3) {
        throw b(r3) || i.getLogger(this).warn(`Failed to load layer (${this.title}, ${this.id}) portal item (${this.portalItem.id})
  ${r3}`), r3;
      }
    }
    async finishLoadEditablePortalLayer(e) {
      this._set("userHasEditingPrivileges", await this._fetchUserHasEditingPrivileges(e).catch((e2) => (a2(e2), true)));
    }
    async setUserPrivileges(e, r3) {
      if (!s.userPrivilegesApplied) return this.finishLoadEditablePortalLayer(r3);
      if (this.url) try {
        const { features: { edit: t, fullEdit: s5 }, content: { updateItem: i2 } } = await this._fetchUserPrivileges(e, r3);
        this._set("userHasEditingPrivileges", t), this._set("userHasFullEditingPrivileges", s5), this._set("userHasUpdateItemPrivileges", i2);
      } catch (s5) {
        a2(s5);
      }
    }
    async _fetchUserPrivileges(e, t) {
      let s5 = this.portalItem;
      if (!e || !s5 || !s5.loaded || s5.sourceUrl) return this._fetchFallbackUserPrivileges(t);
      const i2 = !s4?.findCredential(this.url), o2 = e === s5.id;
      if (o2 && s5.portal.user) return this._getUserPrivileges(s5, i2);
      let a3, l;
      if (o2) a3 = s5.portal.url;
      else try {
        a3 = await B(this.url, t);
      } catch (m2) {
        a2(m2);
      }
      if (!a3 || !W(a3, s5.portal.url)) return this._fetchFallbackUserPrivileges(t);
      try {
        const e2 = null != t ? t.signal : null;
        l = await s4?.getCredential(`${a3}/sharing`, { prompt: false, signal: e2 });
      } catch (m2) {
        a2(m2);
      }
      const n = true, p = false, d = false;
      if (!l) return { features: { edit: n, fullEdit: p }, content: { updateItem: d } };
      try {
        if (o2 ? await s5.reload() : (s5 = new k({ id: e, portal: { url: a3 } }), await s5.load(t)), s5.portal.user) return this._getUserPrivileges(s5, i2);
      } catch (m2) {
        a2(m2);
      }
      return { features: { edit: n, fullEdit: p }, content: { updateItem: d } };
    }
    _getUserPrivileges(e, t) {
      const r3 = f(e);
      return t && (r3.features.edit = true), r3;
    }
    async _fetchFallbackUserPrivileges(e) {
      let t = true;
      try {
        t = await this._fetchUserHasEditingPrivileges(e);
      } catch (r3) {
        a2(r3);
      }
      return { features: { edit: t, fullEdit: false }, content: { updateItem: false } };
    }
    async _fetchUserHasEditingPrivileges(e) {
      const t = this.url ? s4?.findCredential(this.url) : null;
      if (!t) return true;
      const s5 = _2.credential === t ? _2.user : await this._fetchEditingUser(e);
      return _2.credential = t, _2.user = s5, null == s5?.privileges || s5.privileges.includes("features:user:edit");
    }
    async _fetchEditingUser(e) {
      const t = this.portalItem?.portal?.user;
      if (t) return t;
      const o2 = s4?.findServerInfo(this.url ?? "");
      if (!o2?.owningSystemUrl) return null;
      const a3 = `${o2.owningSystemUrl}/sharing/rest`, l = C.getDefault();
      if (l && l.loaded && K(l.restUrl) === K(a3)) return l.user;
      const n = `${a3}/community/self`, p = null != e ? e.signal : null, u3 = await _(H(n, { authMode: "no-prompt", query: { f: "json" }, signal: p }));
      return u3.ok ? u2.fromJSON(u3.value.data) : null;
    }
    read(e, t) {
      t && (t.layer = this), super.read(e, t);
    }
    write(e, t) {
      const r3 = t?.portal, s5 = this.portalItem?.id && (this.portalItem.portal || C.getDefault());
      return r3 && s5 && !D(s5.restUrl, r3.restUrl) ? (t.messages && t.messages.push(new s2("layer:cross-portal", `The layer '${this.title} (${this.id})' cannot be persisted because it refers to an item on a different portal than the one being saved to. To save, set layer.portalItem to null or save to the same portal as the item associated with the layer`, { layer: this })), null) : super.write(e, { ...t, layer: this });
    }
  };
  return r([m({ type: k })], E.prototype, "portalItem", null), r([o("web-document", "portalItem", ["itemId"])], E.prototype, "readPortalItem", null), r([r2("web-document", "portalItem", { itemId: { type: String } })], E.prototype, "writePortalItem", null), r([m({ clonable: false })], E.prototype, "resourceReferences", void 0), r([m({ type: Boolean, readOnly: true })], E.prototype, "userHasEditingPrivileges", void 0), r([m({ type: Boolean, readOnly: true })], E.prototype, "userHasFullEditingPrivileges", void 0), r([m({ type: Boolean, readOnly: true })], E.prototype, "userHasUpdateItemPrivileges", void 0), E = r([a("esri.layers.mixins.PortalLayer")], E), E;
};
var _2 = { credential: null, user: null };

export {
  j
};
//# sourceMappingURL=chunk-VGIEH4HM.js.map
