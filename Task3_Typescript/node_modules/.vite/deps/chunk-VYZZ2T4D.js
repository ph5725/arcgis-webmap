import {
  I,
  R as R2,
  b,
  f as f2,
  j,
  m as m2,
  y
} from "./chunk-D3RLCXTB.js";
import {
  S
} from "./chunk-ULQQXQG7.js";
import {
  s as s3
} from "./chunk-YB2E6SEN.js";
import {
  u as u2
} from "./chunk-7TPOIM4Y.js";
import {
  v
} from "./chunk-I7UBWPZD.js";
import {
  t as t2
} from "./chunk-3SJIVSAT.js";
import {
  i as i4
} from "./chunk-HXR4TQII.js";
import {
  i as i2
} from "./chunk-YOMN3PFE.js";
import {
  H as H2
} from "./chunk-UTU6N7VJ.js";
import {
  c,
  i as i3,
  o as o2,
  t
} from "./chunk-SJHAGLIM.js";
import {
  h
} from "./chunk-Z6OMEWWC.js";
import {
  R
} from "./chunk-7ZMGKXLG.js";
import {
  u
} from "./chunk-6QTMK7BB.js";
import {
  r as r2
} from "./chunk-HCYE6OE4.js";
import {
  l
} from "./chunk-A3VAC24F.js";
import {
  p
} from "./chunk-SRQCQD63.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  f
} from "./chunk-PK2ZR2SJ.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  o
} from "./chunk-3NBBZ43U.js";
import {
  H,
  g2 as g
} from "./chunk-ZWFY3WY5.js";
import {
  V
} from "./chunk-LQFTAGIV.js";
import {
  A,
  a as a2,
  k
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s as s2
} from "./chunk-XWG6QGFK.js";
import {
  e,
  s
} from "./chunk-GWNLQRNM.js";
import {
  G,
  L,
  has
} from "./chunk-FXKORAMT.js";

// node_modules/@arcgis/core/layers/graphics/sources/FeatureLayerSource.js
var V2 = new o({ originalAndCurrentFeatures: "original-and-current-features", none: "none" });
var $ = new o({ Started: "published", Publishing: "publishing", Stopped: "unavailable" });
var G2 = class extends p {
  constructor(e2) {
    super(e2), this.type = "feature-layer", this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table", "Catalog Layer"]), this.refresh = k(async () => {
      await this.load();
      const e3 = this.sourceJSON.editingInfo?.lastEditDate;
      if (null == e3) return { dataChanged: true, updates: {} };
      try {
        await this._fetchService(null);
      } catch {
        return { dataChanged: true, updates: {} };
      }
      const t3 = e3 !== this.sourceJSON.editingInfo?.lastEditDate;
      return { dataChanged: t3, updates: t3 ? { editingInfo: this.sourceJSON.editingInfo, extent: this.sourceJSON.extent } : null };
    }), this._ongoingAssetUploads = /* @__PURE__ */ new Map();
  }
  load(e2) {
    const t3 = this.layer.sourceJSON, s4 = this._fetchService(t3, { ...e2 }).then(() => this.layer.setUserPrivileges(this.sourceJSON.serviceItemId, e2)).then(() => this._ensureLatestMetadata(e2));
    return this.addResolvingPromise(s4), Promise.resolve(this);
  }
  initialize() {
    this.addHandles([l(() => {
      const e2 = this.layer;
      return e2 && "lastEditsEventDate" in e2 ? e2.lastEditsEventDate : null;
    }, (e2) => this._handleLastEditsEventChange(e2))]);
  }
  destroy() {
    this._removeEditInterceptor();
  }
  get queryTask() {
    const { capabilities: e2, parsedUrl: t3, gdbVersion: s4, spatialReference: r3, fieldsIndex: a3, uniqueIdFields: i5 } = this.layer, n = "infoFor3D" in this.layer ? this.layer.infoFor3D : null, o3 = "dynamicDataSource" in this.layer ? this.layer.dynamicDataSource : null, u3 = has("featurelayer-pbf") && e2?.query.supportsFormatPBF && null == n;
    return new S({ dynamicDataSource: o3, fieldsIndex: a3, gdbVersion: s4, infoFor3D: n, pbfSupported: u3, queryAttachmentsSupported: e2?.operations?.supportsQueryAttachments ?? false, sourceSpatialReference: r3, uniqueIdFields: i5, url: t3.path });
  }
  async addAttachment(e2, t3) {
    await this.load();
    const { layer: r3 } = this;
    await H2(r3, "editing");
    const a3 = e2.attributes[r3.objectIdField], i5 = r3.parsedUrl.path + "/" + a3 + "/addAttachment", n = this._getLayerRequestOptions(), o3 = this._getFormDataForAttachment(t3, n.query);
    try {
      const e3 = await H(i5, { body: o3 });
      return R2(e3.data.addAttachmentResult);
    } catch (u3) {
      throw this._createAttachmentErrorResult(a3, u3);
    }
  }
  async updateAttachment(e2, t3, r3) {
    await this.load();
    const { layer: a3 } = this;
    await H2(a3, "editing");
    const i5 = e2.attributes[a3.objectIdField], n = a3.parsedUrl.path + "/" + i5 + "/updateAttachment", o3 = this._getLayerRequestOptions({ query: { attachmentId: t3 } }), u3 = this._getFormDataForAttachment(r3, o3.query);
    try {
      const e3 = await H(n, { body: u3 });
      return R2(e3.data.updateAttachmentResult);
    } catch (l2) {
      throw this._createAttachmentErrorResult(i5, l2);
    }
  }
  async applyEdits(e2, t3) {
    await this.load();
    const { layer: a3 } = this;
    await H2(a3, "editing");
    const n = "infoFor3D" in a3 ? a3.infoFor3D : null, o3 = null != n, u3 = o3 || (t3?.globalIdUsed ?? false), l2 = o3 ? await this._uploadMeshesAndGetAssetMapEditsJSON(e2) : null, c2 = e2.addFeatures?.map((e3) => m2(this.layer, e3, n)) ?? [], d = (await Promise.all(c2)).filter(L), p2 = e2.updateFeatures?.map((e3) => m2(this.layer, e3, n)) ?? [], y2 = (await Promise.all(p2)).filter(L), h2 = b(this.layer, e2.deleteFeatures, u3);
    i2(d, y2, a3.spatialReference);
    const m3 = await f2(this.layer, e2), f3 = a3.capabilities.editing.supportsAsyncApplyEdits && o3, g2 = t3?.gdbVersion || a3.gdbVersion, w = { gdbVersion: g2, rollbackOnFailure: t3?.rollbackOnFailureEnabled, useGlobalIds: u3, returnEditMoment: t3?.returnEditMoment, usePreviousEditMoment: t3?.usePreviousEditMoment, async: f3 };
    await i3(this.layer.url, g2, true);
    const q = c(this.layer.url, g2 || null);
    if (await o2(a3.url, g2, a3.historicMoment)) throw new s2("feature-layer-source:historic-version", "Editing a historic version is not allowed");
    t3?.returnServiceEditsOption ? (w.edits = JSON.stringify([{ id: a3.layerId, adds: d.length ? d : null, updates: y2.length ? y2 : null, deletes: h2.length ? h2 : null, attachments: m3, assetMaps: l2 }]), w.returnServiceEditsOption = V2.toJSON(t3?.returnServiceEditsOption), w.returnServiceEditsInSourceSR = t3?.returnServiceEditsInSourceSR) : (w.adds = d.length ? JSON.stringify(d) : null, w.updates = y2.length ? JSON.stringify(y2) : null, w.deletes = h2.length ? u3 ? JSON.stringify(h2) : h2.join(",") : null, w.attachments = m3 && JSON.stringify(m3), w.assetMaps = null != l2 ? JSON.stringify(l2) : void 0);
    const S2 = this._getLayerRequestOptions({ method: "post", query: w });
    q && (S2.authMode = "immediate", S2.query.returnEditMoment = true, S2.query.sessionId = t);
    const E = t3?.returnServiceEditsOption ? a3.url : a3.parsedUrl.path;
    let O;
    try {
      O = f3 ? await this._asyncApplyEdits(E + "/applyEdits", S2) : await H(E + "/applyEdits", S2);
    } catch (_) {
      if (!j(_)) throw _;
      S2.authMode = "immediate", O = f3 ? await this._asyncApplyEdits(E + "/applyEdits", S2) : await H(E + "/applyEdits", S2);
    }
    return this._createEditsResult(O);
  }
  async deleteAttachments(e2, t3) {
    await this.load();
    const { layer: r3 } = this;
    await H2(r3, "editing");
    const a3 = e2.attributes[r3.objectIdField], i5 = r3.parsedUrl.path + "/" + a3 + "/deleteAttachments";
    try {
      return (await H(i5, this._getLayerRequestOptions({ query: { attachmentIds: t3.join(",") }, method: "post" }))).data.deleteAttachmentResults.map(R2);
    } catch (n) {
      throw this._createAttachmentErrorResult(a3, n);
    }
  }
  fetchRecomputedExtents(e2 = {}) {
    const t3 = e2.signal;
    return this.load({ signal: t3 }).then(async () => {
      const t4 = this._getLayerRequestOptions({ ...e2, query: { returnUpdates: true } }), { layerId: r3, url: a3 } = this.layer, { data: i5 } = await H(`${a3}/${r3}`, t4), { id: n, extent: o3, fullExtent: u3, timeExtent: l2 } = i5, c2 = o3 || u3;
      return { id: n, fullExtent: c2 && z.fromJSON(c2), timeExtent: l2 && u.fromJSON({ start: l2[0], end: l2[1] }) };
    });
  }
  async queryAttachments(e2, t3 = {}) {
    await this.load();
    const s4 = this._getLayerRequestOptions(t3);
    return this.queryTask.executeAttachmentQuery(e2, s4);
  }
  async queryFeatures(e2, t3) {
    await this.load();
    const s4 = await this.queryTask.execute(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
    if (e2.outStatistics?.length && s4.features.length) {
      const t4 = /* @__PURE__ */ new Map();
      if (s4.features.forEach((s5) => {
        const r3 = s5.attributes;
        e2.outStatistics?.forEach(({ outStatisticFieldName: e3 }) => {
          if (e3) {
            const s6 = e3.toLowerCase();
            s6 && s6 in r3 && e3 !== s6 && (r3[e3] = r3[s6], delete r3[s6], t4.set(s6, e3));
          }
        });
      }), null != s4.fields) for (const e3 of s4.fields) {
        const s5 = t4.get(e3.name.toLowerCase());
        null != s5 && (e3.name = s5);
      }
    }
    return s4;
  }
  async queryFeaturesJSON(e2, t3) {
    return await this.load(), this.queryTask.executeJSON(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryObjectIds(e2, t3) {
    return await this.load(), this.queryTask.executeForIds(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryFeatureCount(e2, t3) {
    return await this.load(), this.queryTask.executeForCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryExtent(e2, t3) {
    return await this.load(), this.queryTask.executeForExtent(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryRelatedFeatures(e2, t3) {
    return await this.load(), this.queryTask.executeRelationshipQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryRelatedFeaturesCount(e2, t3) {
    return await this.load(), this.queryTask.executeRelationshipQueryForCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopFeatures(e2, t3) {
    return await this.load(), this.queryTask.executeTopFeaturesQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryAttributeBins(e2, t3) {
    return await this.load(), this.queryTask.executeAttributeBinsQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopObjectIds(e2, t3) {
    return await this.load(), this.queryTask.executeForTopIds(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopExtents(e2, t3) {
    return await this.load(), this.queryTask.executeForTopExtents(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopCount(e2, t3) {
    return await this.load(), this.queryTask.executeForTopCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async fetchPublishingStatus() {
    if (!g(this.layer.url)) return "unavailable";
    const e2 = V(this.layer.url, "status"), t3 = await H(e2, { query: { f: "json" } });
    return $.fromJSON(t3.data.status);
  }
  async uploadAssets(e2, t3) {
    const { uploadAssets: s4 } = await import("./uploadAssets-GEMKIIIF.js");
    return s4(e2, { layer: this.layer, ongoingUploads: this._ongoingAssetUploads }, t3);
  }
  _handleLastEditsEventChange(e2) {
    const t3 = this.layer;
    if (null == e2 || !("capabilities" in t3) || !("effectiveCapabilities" in t3)) return;
    if (!(!t3.capabilities?.operations?.supportsEditing && t3.effectiveCapabilities?.operations?.supportsEditing)) return;
    const s4 = t3.url;
    if (null == s4) return;
    "layerId" in t3 && V(s4, t3.layerId.toString());
    this._getOrCreateEditInterceptor(s4).before = (t4) => {
      const s5 = t4.requestOptions.method ?? "auto";
      if ("auto" === s5 || "head" === s5) {
        const s6 = t4.requestOptions.query ?? {};
        s6._ts = e2.getTime(), t4.requestOptions.query = s6;
      }
    };
  }
  _getOrCreateEditInterceptor(e2) {
    return null == this._editInterceptor && (this._editInterceptor = { urls: e2 }, s.request.internalInterceptors.push(this._editInterceptor)), this._editInterceptor;
  }
  _removeEditInterceptor() {
    null != this._editInterceptor && (G(s.request.internalInterceptors, this._editInterceptor), this._editInterceptor = null);
  }
  async _asyncApplyEdits(e2, t3) {
    const r3 = (await H(e2, t3)).data.statusUrl;
    for (; ; ) {
      const e3 = (await H(r3, { query: { f: "json" }, responseType: "json" })).data;
      switch (e3.status) {
        case "Completed":
          return H(e3.resultUrl, { query: { f: "json" }, responseType: "json" });
        case "CompletedWithErrors":
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed.");
        case "Failed ImportChanges":
        case "InProgress":
        case "Pending":
        case "ExportAttachments":
        case "ExportChanges":
        case "ExportingData":
        case "ExportingSnapshot":
        case "ImportAttachments":
        case "ProvisioningReplica":
        case "UnRegisteringReplica":
          break;
        default:
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed (undefined response status)");
      }
      await A(H3);
    }
  }
  _createRequestQueryOptions(e2) {
    const t3 = { ...this.layer.customParameters, token: this.layer.apiKey, ...e2?.query };
    return this.layer.datesInUnknownTimezone && (t3.timeReferenceUnknownClient = true), t3;
  }
  async _fetchService(e2, t3) {
    if (!e2) {
      const r4 = {};
      has("featurelayer-advanced-symbols") && (r4.returnAdvancedSymbols = true), t3?.cacheBust && (r4._ts = Date.now());
      const { data: a3 } = await H(this.layer.parsedUrl.path, this._getLayerRequestOptions({ query: r4, signal: t3?.signal }));
      e2 = a3;
    }
    this.layer.applyPreferredHost(e2), this.sourceJSON = await this._patchServiceJSON(e2, t3?.signal);
    const r3 = e2.type;
    if (!this.supportedSourceTypes.has(r3)) throw new s2("feature-layer-source:unsupported-type", `Source type "${r3}" is not supported`);
  }
  async _patchServiceJSON(e2, t3) {
    if ("Table" !== e2.type && e2.geometryType && !e2?.drawingInfo?.renderer && !e2.defaultSymbol) {
      const t4 = u2(e2.geometryType).renderer;
      e("drawingInfo.renderer", t4, e2);
    }
    if ("esriGeometryMultiPatch" === e2.geometryType && e2.infoFor3D && (e2.geometryType = "mesh"), null == e2.extent) try {
      const { data: r3 } = await H(this.layer.url, this._getLayerRequestOptions({ signal: t3 }));
      r3.spatialReference && (e2.extent = { xmin: 0, ymin: 0, xmax: 0, ymax: 0, spatialReference: r3.spatialReference });
    } catch (r3) {
      a2(r3);
    }
    return e2;
  }
  async _ensureLatestMetadata(e2) {
    if (this.layer.userHasUpdateItemPrivileges && this.sourceJSON.cacheMaxAge > 0) return this._fetchService(null, { ...e2, cacheBust: true });
  }
  async _uploadMeshesAndGetAssetMapEditsJSON(e2) {
    const { addAssetFeatures: t3 } = e2;
    if (!t3?.length) return null;
    if (await this._areAllAssetsAlreadyMapped(t3)) return null;
    const s4 = e2.addFeatures.filter((e3) => e3.geometry);
    if (t3.length !== s4.length + e2.updateFeatures.length) throw new s2("feature-layer-source:unsupported-mesh-edits", "Mixing attribute only edits with mesh geometry edits is not currently supported");
    const r3 = new Array(), a3 = /* @__PURE__ */ new Map();
    for (const i5 of t3) {
      const { geometry: e3 } = i5, { vertexSpace: t4 } = e3;
      if (t2(t4)) r3.push(e3);
      else {
        const t5 = e3.origin, { convertMeshVertexSpace: s5 } = await import("./convertMeshVertexSpace-CX7ZSYIS.js"), n = await s5(e3, new i4({ origin: [t5.x, t5.y, t5.z ?? 0] }));
        a3.set(n, e3), i5.geometry = n, r3.push(n);
      }
    }
    await this.uploadAssets(r3);
    for (const [i5, n] of a3) n.addExternalSources(i5.metadata.externalSources.items);
    return { adds: this._getAssetMapEditsJSON(t3), updates: [], deletes: [] };
  }
  _getAssetMapEditsJSON(e2) {
    const t3 = new Array(), s4 = this.layer.globalIdField, r3 = this.layer.parsedUrl;
    for (const a3 of e2) {
      const e3 = a3.geometry, { metadata: i5 } = e3, n = i5.getExternalSourcesOnService(r3), o3 = a3.getAttribute(s4);
      if (0 === n.length) {
        i.getLogger(this).error(`Skipping feature ${o3}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);
        continue;
      }
      const { source: l2 } = n.find(v) ?? n[0];
      for (const s5 of l2.assets) 1 === s5.parts.length ? t3.push({ globalId: r2(), parentGlobalId: o3, assetName: s5.assetName, assetHash: s5.parts[0].partHash, flags: [] }) : i.getLogger(this).error(`Skipping asset ${s5.assetName}. It does not have exactly one part, so we cannot map it to a feature.`);
    }
    return t3;
  }
  _createEditsResult(e2) {
    const t3 = e2.data, { layerId: s4 } = this.layer, r3 = [];
    let a3 = null;
    if (Array.isArray(t3)) for (const n of t3) r3.push({ id: n.id, editedFeatures: n.editedFeatures }), n.id === s4 && (a3 = { addResults: n.addResults ?? [], updateResults: n.updateResults ?? [], deleteResults: n.deleteResults ?? [], attachments: n.attachments, editMoment: n.editMoment });
    else a3 = t3;
    const i5 = y(a3);
    if (r3.length > 0) {
      i5.editedFeatureResults = [];
      for (const e3 of r3) {
        const { editedFeatures: t4 } = e3, s5 = t4?.spatialReference ? new f(t4.spatialReference) : null;
        i5.editedFeatureResults.push({ layerId: e3.id, editedFeatures: I(t4, s5) });
      }
    }
    return i5;
  }
  _createAttachmentErrorResult(e2, t3) {
    const s4 = t3.details.messages?.[0] || t3.message, r3 = t3.details.httpStatus || t3.details.messageCode;
    return { objectId: e2, globalId: null, error: new s2("feature-layer-source:attachment-failure", s4, { code: r3 }) };
  }
  _getFormDataForAttachment(e2, t3) {
    const s4 = e2 instanceof FormData ? e2 : e2 && e2.elements ? new FormData(e2) : null;
    if (s4) for (const r3 in t3) {
      const e3 = t3[r3];
      null != e3 && (s4.set ? s4.set(r3, e3) : s4.append(r3, e3));
    }
    return s4;
  }
  _getLayerRequestOptions(e2 = {}) {
    const { layer: t3, layer: { parsedUrl: s4, gdbVersion: r3 } } = this;
    return { ...e2, query: { gdbVersion: r3, layer: "dynamicDataSource" in t3 && t3.dynamicDataSource ? JSON.stringify({ source: t3.dynamicDataSource }) : void 0, ...s4.query, f: "json", ...this._createRequestQueryOptions(e2) }, responseType: "json" };
  }
  async _areAllAssetsAlreadyMapped(e2) {
    const { layer: t3 } = this, { globalIdField: s4, parsedUrl: a3 } = t3, i5 = "infoFor3D" in t3 ? t3.infoFor3D : null;
    if (null == i5 || null == s4) return false;
    const n = h(i5);
    if (null == n) return false;
    const o3 = V(a3.path, `../${n.id}`), u3 = new Array();
    for (const r3 of e2) {
      if (!(r3.geometry.metadata.getExternalSourcesOnService(a3).length > 0)) return false;
      u3.push(r3);
    }
    const l2 = u3.map((e3) => e3.getAttribute(s4)).filter(L);
    if (0 === l2.length) return false;
    const { assetMapFieldRoles: { parentGlobalId: c2, assetHash: d } } = i5, p2 = new R({ where: `${c2} IN (${l2.map((e3) => `'${e3}'`)})`, outFields: [d, c2], returnGeometry: false }), y2 = await s3(o3, p2), { features: m3 } = y2;
    return 0 !== m3.length && !u3.some((e3) => {
      const t4 = e3.getAttribute(s4);
      if (!t4) return true;
      const { metadata: r3 } = e3.geometry, i6 = m3.filter((e4) => e4.getAttribute(c2) === t4);
      if (0 === i6.length) return true;
      const n2 = i6.map((e4) => e4.getAttribute(d));
      return r3.getExternalSourcesOnService(a3).flatMap(({ source: e4 }) => e4.assets.flatMap((e5) => e5.parts.map((e6) => e6.partHash))).some((e4) => n2.every((t5) => e4 !== t5));
    });
  }
};
r([m()], G2.prototype, "type", void 0), r([m({ constructOnly: true })], G2.prototype, "layer", void 0), r([m({ constructOnly: true })], G2.prototype, "supportedSourceTypes", void 0), r([m({ readOnly: true })], G2.prototype, "queryTask", null), G2 = r([a("esri.layers.graphics.sources.FeatureLayerSource")], G2);
var H3 = 1e3;

export {
  G2 as G
};
//# sourceMappingURL=chunk-VYZZ2T4D.js.map
