import {
  x as x3
} from "./chunk-2OTCLWRN.js";
import {
  s as s2,
  t
} from "./chunk-XZOH57EG.js";
import {
  n as n4
} from "./chunk-LSL2QL5U.js";
import {
  $,
  $s,
  $t,
  A,
  A2,
  As,
  B,
  B2,
  Bs,
  Bt,
  C,
  Ct,
  D,
  D2,
  Ds,
  Dt,
  Et,
  F,
  Ft,
  G,
  G2,
  Gs,
  Gt,
  H,
  Hs,
  Ht,
  I,
  I2,
  It,
  J,
  Js,
  Jt,
  K,
  Kt,
  L,
  L2,
  Ls,
  Lt,
  N,
  O,
  Os,
  Ot,
  P,
  P2,
  Ps,
  Pt,
  Q,
  Qs,
  Qt,
  R,
  R2,
  Rt,
  S,
  Ss,
  St,
  T,
  U,
  U2,
  Us,
  Ut,
  V,
  Vs,
  Vt,
  Ws,
  Wt,
  Xs,
  Xt,
  Y,
  Ys,
  Yt,
  Zs,
  Zt,
  _s,
  _t,
  a,
  ai,
  b,
  bs,
  cs,
  ct,
  ds,
  ei,
  f,
  fs,
  ft,
  g,
  gt,
  h,
  hi,
  ii,
  j,
  j2,
  js,
  jt,
  k,
  k2,
  kt,
  l,
  ls,
  m,
  mi,
  n as n2,
  n2 as n3,
  ni,
  oi,
  p,
  p2,
  qs,
  qt,
  rs,
  si,
  st,
  v,
  vs,
  vt,
  w,
  w2,
  wt,
  x,
  x2,
  y,
  z,
  z2,
  zs,
  zt
} from "./chunk-DDDUQRA2.js";
import {
  e
} from "./chunk-XOMXNJJG.js";
import {
  n,
  s
} from "./chunk-5TPMG26T.js";

// node_modules/@arcgis/core/chunks/Envelope.js
var C2 = [0, 0, Number.NaN, 0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0];
var T2 = [2, 1, 1, 1, 3, 1, 2, 3, 2, 4, 1, 1, 2, 1];
var R3 = [1, 1, 1, 0, 2, 1, 1, 1, 0, 0, 0, 0, 0, 1];
var A3 = [1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 4, 2, 2, 1];
var q = [4, 8, 4, 8, 1];
var w3 = 25;
function B3() {
  return Yt(w3, Number.NaN);
}
var z3 = class s3 {
  getAttributeCount() {
    return this.m_attributeCount;
  }
  getSemantics(t3) {
    return this.m_indexToSemantics[t3];
  }
  getSemanticsBitArray() {
    return this.m_semanticsBitArray;
  }
  getAttributeIndex(t3) {
    return this.m_semanticsToIndexMap[t3];
  }
  static getInterpolation(t3) {
    return R3[t3];
  }
  static getPersistence(t3) {
    return A3[t3];
  }
  static getPersistenceSize(t3) {
    return q[t3];
  }
  static getPersistenceSizeFromSemantics(t3) {
    return s3.getPersistenceSize(s3.getPersistence(t3)) * s3.getComponentCount(t3);
  }
  static getComponentCount(t3) {
    return T2[t3];
  }
  static maxComponentCount() {
    return 4;
  }
  static isInteger(t3) {
    return 2 === t3 || 3 === t3 || 4 === t3;
  }
  static isIntegerSemantics(t3) {
    return s3.isInteger(s3.getPersistence(t3));
  }
  static isTexture(t3) {
    return 5 === t3 || 6 === t3 || 7 === t3;
  }
  hasAttribute(t3) {
    return !!(this.m_semanticsBitArray & 1 << t3);
  }
  hasAttributesFrom(t3) {
    return (this.m_semanticsBitArray & t3.m_semanticsBitArray) === t3.m_semanticsBitArray;
  }
  hasZ() {
    return this.hasAttribute(1);
  }
  hasM() {
    return this.hasAttribute(2);
  }
  hasID() {
    return this.hasAttribute(3);
  }
  getTotalComponentCount() {
    return this.m_totalComponentCount;
  }
  static getDefaultValue(t3) {
    return C2[t3];
  }
  static isDefaultValue(e5, s4) {
    return ls(C2[e5], s4);
  }
  equals(t3) {
    return this === t3;
  }
  getDefaultPointAttributes() {
    return this.m_defaultPointAttributes;
  }
  getPointAttributeOffset(t3) {
    return this.m_pointAttributeOffsets[t3];
  }
  constructor(t3) {
    this.m_semanticsBitArray = t3, this.m_attributeCount = 0, this.m_totalComponentCount = 0, this.m_semanticsToIndexMap = new Int32Array(14), this.m_indexToSemantics = new Int32Array(14), this.m_pointAttributeOffsets = new Int32Array(14), this.m_defaultPointAttributes = Yt(w3, Number.NaN), this.m_semanticsToIndexMap.fill(-1), this.m_indexToSemantics.fill(-1);
    let i2 = 0, n6 = 1, r = 14;
    for (; i2 < r; i2++) t3 & n6 && (this.m_semanticsToIndexMap[i2] = this.m_attributeCount, this.m_indexToSemantics[this.m_attributeCount] = i2, this.m_attributeCount++, this.m_totalComponentCount += s3.getComponentCount(i2)), n6 <<= 1;
    let h2 = 0;
    for (i2 = 0, r = this.getAttributeCount(); i2 < r; i2++) {
      const t4 = this.getSemantics(i2), e5 = s3.getComponentCount(t4), n7 = s3.getDefaultValue(t4);
      this.m_pointAttributeOffsets[i2] = h2;
      for (let s4 = 0; s4 < e5; s4++) this.m_defaultPointAttributes[h2] = n7, h2++;
    }
  }
};
var L3 = z3;
function S2() {
  return Yt(14, 0);
}
var F2 = class _F {
  static getInstance() {
    return _F.s_thisInstance;
  }
  constructor() {
    this.m_map = /* @__PURE__ */ new Map(), this.m_vd2D = new L3(1), this.m_map.set(1, this.m_vd2D), this.m_vd3D = new L3(3), this.m_map.set(3, this.m_vd2D);
  }
  GetVD2D() {
    return this.m_vd2D;
  }
  GetVD3D() {
    return this.m_vd3D;
  }
  FindOrAdd(t3) {
    if (1 === t3) return this.GetVD2D();
    if (3 === t3) return this.GetVD3D();
    const e5 = this.m_map.get(t3);
    if (e5) return e5;
    const s4 = new L3(t3);
    return this.m_map.set(t3, s4), s4;
  }
};
function P3(t3) {
  return F2.getInstance().FindOrAdd(t3);
}
function H2(t3, e5) {
  if (!t3 || !e5) return e5 || t3;
  const s4 = t3.getSemanticsBitArray() | e5.getSemanticsBitArray();
  return (s4 & t3.getSemanticsBitArray()) === s4 ? t3 : (s4 & e5.getSemanticsBitArray()) === s4 ? e5 : P3(s4);
}
function V2(t3, e5) {
  const s4 = t3.getSemanticsBitArray() | 1 << e5;
  return (s4 & t3.getSemanticsBitArray()) === s4 ? t3 : P3(s4);
}
function k3(t3, e5) {
  const s4 = (t3.getSemanticsBitArray() | 1 << e5) - (1 << e5);
  return s4 === t3.getSemanticsBitArray() ? t3 : P3(s4);
}
function M() {
  return F2.getInstance().GetVD2D();
}
function O2() {
  return F2.getInstance().GetVD3D();
}
function Y2(t3, e5, s4) {
  if (s4.fill(-1), null !== t3 && null !== e5) for (let i2 = 0, n6 = t3.getAttributeCount(); i2 < n6; i2++) s4[i2] = e5.getAttributeIndex(t3.getSemantics(i2));
}
F2.s_thisInstance = new F2();
var X = class _X {
  static construct(t3, e5, s4) {
    return new _X(t3, e5, s4);
  }
  constructor(t3, e5, s4) {
    void 0 !== t3 ? (this.x = t3, this.y = e5, this.z = s4) : this.x = this.y = this.z = Number.NaN;
  }
  get 0() {
    return this.x;
  }
  get 1() {
    return this.y;
  }
  get 2() {
    return this.z;
  }
  set 0(t3) {
    this.x = t3;
  }
  set 1(t3) {
    this.y = t3;
  }
  set 2(t3) {
    this.z = t3;
  }
  clone() {
    return new _X(this.x, this.y, this.z);
  }
  assign(t3) {
    return this.x = t3.x, this.y = t3.y, this.z = t3.z, this;
  }
  setCoords(t3, e5, s4) {
    return this.x = t3, this.y = e5, this.z = s4, this;
  }
  setCoordsPoint2DZ(t3, e5) {
    return this.setCoords(t3.x, t3.y, e5);
  }
  setCoordsPoint3D(t3) {
    this.x = t3.x, this.y = t3.y, this.z = t3.z;
  }
  setZero() {
    this.x = 0, this.y = 0, this.z = 0;
  }
  setNormalized(t3) {
    this.assign(t3), this.normalizeThis();
  }
  normalizeThis() {
    const t3 = this.length();
    return t3 ? (this.x /= t3, this.y /= t3, this.z /= t3) : (this.x = 1, this.y = 0, this.z = 0), this;
  }
  getUnitVector() {
    const t3 = new _X();
    return t3.setNormalized(this), t3;
  }
  sqrLength() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  lengthXY() {
    return n2(0), 0;
  }
  static sqrDistance(t3, e5) {
    return H(t3.x - e5.x) + H(t3.y - e5.y) + H(t3.z - e5.z);
  }
  static sqrDistanceCoords(t3, e5, i2, n6, r, h2) {
    return H(t3 - n6) + H(e5 - r) + H(i2 - h2);
  }
  static distance(t3, e5) {
    return Math.sqrt(_X.sqrDistance(t3, e5));
  }
  isEqual(t3, e5) {
    return void 0 === e5 && (e5 = 0), Math.abs(this.x - t3.x) <= e5 && Math.abs(this.y - t3.y) <= e5 && cs(this.z, t3.z, e5);
  }
  static compareByLength(t3, e5, s4, i2) {
    return n2(0), 0;
  }
  isEqualCoords(t3, e5, s4, i2) {
    return n2(0), this.x === t3 && this.y === e5 && this.z === s4;
  }
  isEqualsTols(t3, e5, s4) {
    return n2(0), false;
  }
  isEqualCoordsTols(t3, e5, s4, i2, n6) {
    return n2(0), false;
  }
  static st_isEqual(t3, e5, s4, i2) {
    return n2(0), false;
  }
  equals(t3, e5) {
    return this.isEqual(t3, e5);
  }
  equalsTols(t3, e5, s4) {
    return n2(0), false;
  }
  divThis(t3) {
    return this.x /= t3, this.y /= t3, this.z /= t3, this;
  }
  subThis(t3) {
    return this.x -= t3.x, this.y -= t3.y, this.z -= t3.z, this;
  }
  setSub(t3, e5) {
    return this.x = t3.x - e5.x, this.y = t3.y - e5.y, this.z = t3.z - e5.z, this;
  }
  sub(t3) {
    return _X.construct(this.x - t3.x, this.y - t3.y, this.z - t3.z);
  }
  addThis(t3) {
    return this.x += t3.x, this.y += t3.y, this.z += t3.z, this;
  }
  add(t3) {
    return this.clone().addThis(t3);
  }
  setAdd(t3, e5) {
    return this.x = t3.x + e5.x, this.y = t3.y + e5.y, this.z = t3.z + e5.z, this;
  }
  mul(t3) {
    return _X.construct(this.x * t3, this.y * t3, this.z * t3);
  }
  dotProduct(t3) {
    return this.x * t3.x + this.y * t3.y + this.z * t3.z;
  }
  crossProductVector(t3) {
    const e5 = this.y * t3.z - t3.y * this.z, s4 = t3.x * this.z - this.x * t3.z, i2 = this.x * t3.y - t3.x * this.y;
    return new _X(e5, s4, i2);
  }
  setCrossProductVector(t3, e5) {
    const s4 = t3.y * e5.z - e5.y * t3.z, i2 = e5.x * t3.z - t3.x * e5.z, n6 = t3.x * e5.y - e5.x * t3.y;
    return this.x = s4, this.y = i2, this.z = n6, this;
  }
  setScaled(t3, e5) {
    return this.x = t3 * e5.x, this.y = t3 * e5.y, this.z = t3 * e5.z, this;
  }
  scaleThis(t3) {
    return this.x *= t3, this.y *= t3, this.z *= t3, this;
  }
  scaleZThis(t3) {
    return this.z *= t3, this;
  }
  setNAN() {
    return n2(0), this;
  }
  isNAN() {
    return Number.isNaN(this.x) || Number.isNaN(this.y) || Number.isNaN(this.z);
  }
  static getNAN() {
    return _X.construct(Number.NaN, Number.NaN, Number.NaN);
  }
  isFinite() {
    return n2(0), false;
  }
  isZero() {
    return 0 === this.x && 0 === this.y && 0 === this.z;
  }
  norm(t3) {
    return n2(0), 0;
  }
  sqrDistanceFromCenterToSpheroidSurface(t3, e5) {
    return n2(0), 0;
  }
  distanceFromCenterToSpheroidSurface(t3, e5) {
    return Math.sqrt(this.sqrDistanceFromCenterToSpheroidSurface(t3, e5));
  }
  static getClosestCoordinate(t3, e5, s4, i2 = false) {
    return n2(0), 0;
  }
  compare(t3) {
    return this.y < t3.y ? -1 : this.y > t3.y ? 1 : this.x < t3.x ? -1 : this.x > t3.x ? 1 : this.z < t3.z ? -1 : this.z > t3.z ? 1 : 0;
  }
  compareXYZ(t3) {
    return n2(0), 0;
  }
  negateThis() {
    this.x = -this.x, this.y = -this.y, this.z = -this.z;
  }
  static averageFast(t3, e5) {
    return n2(0), {};
  }
  static average(t3, e5) {
    return n2(0), {};
  }
  static size() {
    return _X.dimensions;
  }
  static lerp(t3, e5, s4) {
    const i2 = new _X();
    return j2(t3, e5, s4, i2), i2;
  }
  static slerp(t3, e5, s4) {
    return n2(0), {};
  }
  static compareVectors(t3, e5) {
    return n2(0), 0;
  }
  static selectRightHandedBasisFromNormal(t3, e5, s4) {
    const i2 = t3.getUnitVector(), n6 = i2.createAPerpendicular(), r = new _X();
    r.setCrossProductVector(i2, n6), r.normalizeThis(), e5.setCoordsPoint3D(n6), s4.setCoordsPoint3D(r);
  }
  createAPerpendicular() {
    const t3 = [this.crossProductVector(new _X(0, 0, 1)), this.crossProductVector(new _X(1, 0, 0)), this.crossProductVector(new _X(0, 1, 0))], e5 = [t3[0].sqrLength(), t3[1].sqrLength(), t3[2].sqrLength()], s4 = t3[e5.reduce((t4, s5, i2) => e5[t4] > e5[i2] ? t4 : i2, 0)];
    return s4.normalizeThis(), s4;
  }
  calculateAngle(t3) {
    return n2(0), 0;
  }
  static crossDotSign(t3, e5, s4) {
    return n2(0), 0;
  }
  static isBisectorRobust(t3, e5, s4) {
    return n2(0), 0;
  }
  static compareZOrder(t3, e5) {
    return n2(0), false;
  }
};
X.dimensions = 3;
var G3 = class _G {
  static constructEmpty() {
    return new _G(Number.NaN, Number.NaN, Number.NaN, Number.NaN, Number.NaN, Number.NaN);
  }
  constructor(t3, e5, s4, i2, n6, r) {
    this.m_EnvelopeType = 3, this.xmin = t3, this.ymin = e5, this.zmin = s4, this.xmax = i2, this.ymax = n6, this.zmax = r, this.normalize();
  }
  inflate(t3) {
    this.inflateCoords(t3, t3, t3);
  }
  inflateCoords(t3, e5, s4) {
    n2(0);
  }
  getEnvelope2D() {
    return new n4(this.xmin, this.ymin, this.xmax, this.ymax);
  }
  getEnvelopeZs() {
    return new x2(this.zmin, this.zmax);
  }
  setEmptyZ() {
    this.zmin = Number.NaN, this.zmax = Number.NaN;
  }
  normalize() {
    let t3 = false;
    this.xmin <= this.xmax || (this.xmax = Pt(this.xmin, this.xmin = this.xmax), t3 = true), this.ymin <= this.ymax || (this.ymax = Pt(this.ymin, this.ymin = this.ymax), t3 = true), !t3 || this.xmin <= this.xmax && this.ymin <= this.ymax ? this.zmin <= this.zmax || (this.zmax = Pt(this.zmin, this.zmin = this.zmax), this.zmin <= this.zmax || this.setEmptyZ()) : this.setEmpty();
  }
  isEmpty() {
    return Number.isNaN(this.xmin) || Number.isNaN(this.ymin) || Number.isNaN(this.xmax) || Number.isNaN(this.ymax);
  }
  isEmptyZ() {
    return Number.isNaN(this.zmin) || Number.isNaN(this.zmax);
  }
  setEmpty() {
    this.xmin = Number.NaN, this.ymin = Number.NaN, this.zmin = Number.NaN, this.xmax = Number.NaN, this.ymax = Number.NaN, this.zmax = Number.NaN;
  }
  mergeEnv3D(t3) {
    t3.isEmpty() || (this.mergeCoords(t3.xmin, t3.ymin, t3.zmin), this.mergeCoords(t3.xmax, t3.ymax, t3.zmax));
  }
  mergeNe(t3) {
    this.mergeNeCoords(t3.x, t3.y, t3.z);
  }
  mergeNeCoords(t3, e5, s4) {
    this.xmin > t3 ? this.xmin = t3 : this.xmax < t3 && (this.xmax = t3), this.ymin > e5 ? this.ymin = e5 : this.ymax < e5 && (this.ymax = e5), this.zmin > s4 ? this.zmin = s4 : this.zmax < s4 && (this.zmax = s4);
  }
  mergeCoords(t3, e5, s4) {
    this.isEmpty() ? (this.xmin = t3, this.xmax = t3, this.ymin = e5, this.ymax = e5, this.zmin = s4, this.zmax = s4) : (this.isEmptyZ() && (this.zmin = s4, this.zmax = s4), this.mergeNeCoords(t3, e5, s4));
  }
  setCoords(t3, e5, s4, i2, n6, r) {
    this.xmin = t3, this.ymin = e5, this.zmin = s4, this.xmax = i2, this.ymax = n6, this.zmax = r, this.normalize();
  }
  sqrDistanceEnvelope3DAndPoints(t3, e5, s4, i2 = 1) {
    return n2(0), 0;
  }
  sqrMaxDistance(t3, e5 = 1) {
    return n2(0), 0;
  }
};
var U3 = -559038737;
var Z = z3;
function Q2(t3, e5, s4) {
  switch (t3) {
    case 0:
      return new it(e5, s4);
    case 1:
      return new nt(e5, s4);
    case 2:
      return new st2(e5, s4);
    case 3:
      throw new Error("64 bit int attribute stream not implemented");
    case 4:
      return new et(e5, s4);
    default:
      P("");
  }
}
function j3(t3, e5) {
  const s4 = Z.getComponentCount(t3);
  return Q2(Z.getPersistence(t3), e5 * s4, Z.getDefaultValue(t3));
}
function W(t3, e5) {
  const s4 = Z.getComponentCount(t3);
  return Q2(Z.getPersistence(t3), e5 * s4);
}
function J2(t3, e5) {
  return new st2(t3, e5);
}
function K2(t3, e5) {
  return new et(t3, e5);
}
function $2(t3, e5) {
  return new nt(t3, e5);
}
var tt = class _tt {
  size() {
    return this.m_size;
  }
  checkResize(t3, e5) {
    t3 > this.m_size && this.resize(t3, e5);
  }
  resize(t3, e5) {
    if ((t3 = Math.trunc(t3)) === this.m_size) return;
    const s4 = !!e5 || Number.isNaN(e5);
    if (t3 < this.m_a.length) this.m_a.length > _tt.s_resizeMin && 1.25 * t3 < this.m_a.length && (this.m_a = this.m_a.slice(0, t3)), s4 && t3 > this.m_size && this.m_a.fill(e5, this.m_size, t3);
    else if (t3 >= this.m_a.length) {
      const i2 = 1.25 * t3, n6 = new this.m_a.constructor(i2);
      n6.set(this.m_a), this.m_a = n6, s4 && this.m_a.fill(e5, this.m_size, t3);
    }
    this.m_size = t3;
  }
  resizeRounded(t3, e5) {
    return this.resize(t3, e5);
  }
  reserve(t3) {
  }
  read(t3) {
    return this.m_a[t3];
  }
  readAsDbl(t3) {
    return this.read(t3);
  }
  write(t3, e5) {
    this.m_a[t3] = e5;
  }
  writeAsDbl(t3, e5) {
    this.write(t3, e5);
  }
  setRange(t3, e5, s4) {
    (e5 < 0 || s4 < 0 || s4 + e5 > this.size()) && P(), this.m_a.fill(t3, e5, e5 + s4);
  }
  add(t3) {
    this.resize(this.m_size + 1), this.m_a[this.m_size - 1] = t3;
  }
  addArray(t3, e5) {
    const s4 = this.m_size;
    void 0 === e5 ? (this.resize(this.m_size + t3.length), this.m_a.set(t3, s4)) : (this.resize(this.m_size + e5), this.m_a.set(t3.slice(0, e5), s4));
  }
  equals(t3, e5, s4, i2) {
    if (this.getPersistence() !== t3.getPersistence()) return false;
    return rt(this, t3, e5, s4, i2);
  }
  insertRange(t3, e5, s4, i2) {
    const n6 = this.m_size;
    this.checkResize(Math.max(0, i2) + s4), this.m_a.copyWithin(t3 + s4, t3, i2 >= 0 ? i2 : n6), this.m_a.fill(e5, t3, t3 + s4);
  }
  readRange(t3, e5) {
    return this.m_a.slice(t3, t3 + e5);
  }
  insertRangeFromStream(t3, e5, s4, i2, n6, r, h2) {
    n2(this.getPersistence() === e5.getPersistence());
    const o = e5, a2 = this.m_size;
    i2 && this.checkResize(Math.max(0, h2) + i2), this.m_a.copyWithin(t3 + i2, t3, h2 >= 0 ? h2 : a2), this.m_a.set(o.readRange(s4, i2), t3), n6 || this.reverseRange(t3, i2, r);
  }
  writeRange(t3, e5, s4, i2, n6, r) {
    n2(this.getPersistence() === s4.getPersistence());
    const h2 = s4;
    if ((t3 < 0 || e5 < 0 || i2 < 0) && P(), h2.size() < i2 + e5 && P(), 0 === e5) return;
    this.size() < e5 + t3 && this.resize(e5 + t3);
    const o = h2.m_a.subarray(i2, i2 + e5);
    ht(this.m_a, t3, e5, o);
  }
  insertAttributes(t3, e5, s4, i2) {
    const n6 = Z.getComponentCount(s4);
    this.m_a.copyWithin(t3 + n6, t3, i2 >= 0 ? i2 : this.m_size);
    for (let r = 0; r < n6; r++) this.m_a[t3 + r] = e5.getAttributeAsDbl(s4, r);
  }
  insertAttributesFromPoints(t3, e5, s4, i2, n6) {
    n2(Z.getPersistence(i2) === this.getPersistence());
    const r = Z.getComponentCount(i2), h2 = this.m_size;
    if (this.checkResize(Math.max(0, n6) + r * s4), this.m_a.copyWithin(t3 + r * s4, t3, n6 >= 0 ? n6 : h2), 0 === i2) {
      const i3 = new mi();
      for (let n7 = t3, r2 = 0; r2 < s4; r2++, n7 += 2) e5[r2].queryXY(i3), this.m_a[n7] = i3.x, this.m_a[n7 + 1] = i3.y;
    } else if (1 === r) for (let o = t3, a2 = 0; a2 < s4; a2++, o++) this.m_a[o] = e5[a2].getAttributeAsDbl(i2, 0);
    else for (let o = t3, a2 = 0; a2 < s4; a2++, o += r) for (let t4 = 0; t4 < r; t4++) this.m_a[o + t4] = e5[a2].getAttributeAsDbl(i2, t4);
  }
  eraseRange(t3, e5, s4) {
    this.m_size < t3 + e5 && P(), this.m_a.copyWithin(t3, t3 + e5), this.m_size -= e5;
  }
  reverseRange(t3, e5, s4) {
    if ((s4 < 1 || e5 % s4 !== 0) && P(), this.m_a.subarray(t3, t3 + e5).reverse(), s4 > 1) for (let i2 = t3, n6 = t3 + e5; i2 < n6; i2 += s4) {
      let t4 = i2, e6 = i2 + s4 - 1;
      for (; t4 < e6; ) {
        const s5 = this.m_a[t4];
        this.m_a[t4] = this.m_a[e6], this.m_a[e6] = s5, t4++, e6--;
      }
    }
  }
  rotate(t3, e5, s4) {
    (e5 < t3 || e5 > s4 || t3 > s4) && A("rotate"), e5 !== t3 && e5 !== s4 && (this.reverseRange(t3, e5 - t3, 1), this.reverseRange(e5, s4 - e5, 1), this.reverseRange(t3, s4 - t3, 1));
  }
  sort(t3, e5, s4) {
    this.m_a.subarray(t3, e5).sort(s4);
  }
  constructor(t3) {
    if (t3.move) this.m_a = t3.move.m_a, this.m_size = t3.move.m_size, t3.move.m_a = t3.move.m_a.slice(0, 0), t3.move.m_size = 0;
    else if (t3.copy) this.m_size = t3.copy.m_size, t3.maxSize && (this.m_size = Math.min(t3.maxSize, this.m_size)), this.m_a = t3.copy.m_a.slice(0, this.m_size);
    else {
      const e5 = Math.max(t3.size, _tt.s_constructMin);
      this.m_a = new t3.ctor(e5), (t3.defaultValue || Number.isNaN(t3.defaultValue)) && this.m_a.fill(t3.defaultValue), this.m_size = t3.size;
    }
  }
};
tt.s_constructMin = 2, tt.s_resizeMin = 30;
var et = class _et extends tt {
  setBits(t3, e5) {
    this.m_a[t3] |= e5;
  }
  clearBits(t3, e5) {
    this.m_a[t3] &= ~e5;
  }
  getPersistence() {
    return 4;
  }
  clone() {
    return new _et({ ctor: Int8Array, copy: this });
  }
  restrictedClone(t3) {
    return new _et({ ctor: Int8Array, copy: this, maxSize: t3 });
  }
  constructor(t3, e5) {
    super("number" == typeof t3 ? { ctor: Int8Array, size: t3, defaultValue: e5 } : t3);
  }
};
var st2 = class _st extends tt {
  getPersistence() {
    return 2;
  }
  clone() {
    return new _st({ ctor: Int32Array, copy: this });
  }
  restrictedClone(t3) {
    return new _st({ ctor: Int32Array, copy: this, maxSize: t3 });
  }
  write(t3, e5) {
    n2(e5 <= ds()), super.write(t3, e5);
  }
  constructor(t3, e5) {
    super("number" == typeof t3 ? { ctor: Int32Array, size: t3, defaultValue: e5 } : t3);
  }
};
var it = class _it extends tt {
  getPersistence() {
    return 0;
  }
  clone() {
    return new _it({ ctor: Float32Array, copy: this });
  }
  restrictedClone(t3) {
    return new _it({ ctor: Float32Array, copy: this, maxSize: t3 });
  }
  constructor(t3, e5) {
    super("number" == typeof t3 ? { ctor: Float32Array, size: t3, defaultValue: e5 } : t3);
  }
};
var nt = class _nt extends tt {
  getPersistence() {
    return 1;
  }
  getArray() {
    return this.m_a;
  }
  applyTransformation(t3, e5, s4) {
    (1 & e5 || e5 + 2 * s4 > this.size()) && P();
    const i2 = 0 === e5 ? this.m_a : this.m_a.subarray(e5);
    t3.transformInterleavedPoints(i2, s4, i2);
  }
  readPoint2D(t3) {
    const e5 = this.m_a[t3], s4 = this.m_a[t3 + 1];
    return new mi(e5, s4);
  }
  queryPoint2D(t3, e5) {
    return e5.x = this.m_a[t3], e5.y = this.m_a[t3 + 1], e5;
  }
  writePoint2D(t3, e5) {
    this.write(t3, e5.x), this.write(t3 + 1, e5.y);
  }
  insert(t3, e5, s4) {
    this.checkResize(s4 + 2), this.m_a.copyWithin(t3 + 2, t3, s4), this.m_a[t3] = e5.x, this.m_a[t3 + 1] = e5.y;
  }
  insertRangeFromPoints(t3, e5, s4, i2, n6, r) {
    const h2 = this.m_size;
    if (this.checkResize(Math.max(r, 0) + 2 * i2), this.m_a.copyWithin(t3 + 2 * i2, t3, r >= 0 ? r : h2), n6) for (let o = s4, a2 = t3, m3 = 0; m3 < i2; ++m3, ++o) {
      const t4 = e5[o];
      this.m_a[a2++] = t4.x, this.m_a[a2++] = t4.y;
    }
    else for (let o = s4 + i2 - 1, a2 = t3, m3 = 0; m3 < i2; ++m3, --o) {
      const t4 = e5[o];
      this.m_a[a2++] = t4.x, this.m_a[a2++] = t4.y;
    }
  }
  queryRange(t3, e5, s4, i2, n6) {
    if ((t3 < 0 || e5 < 0) && P(), !i2 && (n6 <= 0 || e5 % n6 !== 0) && P(), 0 === e5) return;
    if (1 === e5) return void (s4[0] = this.m_a[t3]);
    const r = this.m_a.subarray(t3, t3 + e5);
    s4.set(r);
  }
  writeRangeFromArray(t3, e5, s4, i2, n6) {
    if ((t3 < 0 || e5 < 0) && P(), 0 === e5) return;
    if (1 === e5) return void (this.m_a[t3] = s4[0]);
    let r = s4;
    e5 < s4.length && (r = s4.subarray(0, e5)), this.m_a.set(r, t3);
  }
  clone() {
    return new _nt({ ctor: Float64Array, copy: this });
  }
  restrictedClone(t3) {
    return new _nt({ ctor: Float64Array, copy: this, maxSize: t3 });
  }
  constructor(t3, e5) {
    super("number" == typeof t3 ? { ctor: Float64Array, size: t3, defaultValue: e5 } : t3);
  }
};
function rt(t3, e5, s4, n6, r) {
  if (t3.getPersistence() !== e5.getPersistence()) return false;
  const h2 = t3.getPersistence() <= 1, o = t3.size(), a2 = e5.size();
  if (n6 > o || n6 > a2) return false;
  if (r) if (h2) {
    for (let m3 = s4; m3 < n6; m3++) if (!cs(t3.read(m3), e5.read(m3), r)) return false;
  } else for (let i2 = s4; i2 < n6; i2++) {
    let s5 = t3.read(i2) - e5.read(i2);
    if (s5 < 0 && (s5 = -s5), s5 > r) return false;
  }
  else for (let i2 = s4; i2 < n6; i2++) {
    const s5 = t3.read(i2), n7 = e5.read(i2);
    if (s5 !== n7) {
      if (h2 && Number.isNaN(s5) && Number.isNaN(n7)) continue;
      return false;
    }
  }
  return true;
}
function ht(t3, e5, s4, i2, n6, r) {
  if ((e5 < 0 || s4 < 0) && P(), 0 === s4) return;
  if (1 === s4) return void (t3[e5] = i2[0]);
  let h2 = i2;
  s4 < i2.length && (h2 = i2.subarray(0, s4)), t3.set(h2, e5);
}
var ot = class _ot {
  constructor() {
    this.m_minValue = -1, this.m_maxValue = -1, this.m_dy = Number.NaN, this.m_buckets = new st2(0), this.m_bucketedIndices = new st2(0);
  }
  static sortEx(t3, e5, s4, i2, n6 = 32) {
    if (s4 - e5 <= n6) return void i2.userSort(e5, s4, t3);
    new _ot().sort(t3, e5, s4, i2, n6);
  }
  sort(t3, e5, s4, i2, n6 = 32) {
    if (s4 - e5 <= n6) return void i2.userSort(e5, s4, t3);
    let r = true, h2 = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY;
    for (let m3 = e5; m3 < s4; m3++) {
      const e6 = i2.getValue(t3.read(m3));
      e6 < h2 && (h2 = e6), e6 > o && (o = e6);
    }
    if (this.reset(s4 - e5, h2, o, s4 - e5)) {
      for (let r2 = e5; r2 < s4; r2++) {
        const s5 = t3.read(r2), n8 = i2.getValue(s5), h3 = this.getBucket(n8);
        this.m_buckets.write(h3, this.m_buckets.read(h3) + 1), this.m_bucketedIndices.write(r2 - e5, s5);
      }
      let n7 = this.m_buckets.read(0);
      this.m_buckets.write(0, 0);
      for (let t4 = 1, e6 = this.m_buckets.size(); t4 < e6; t4++) {
        const e7 = this.m_buckets.read(t4);
        this.m_buckets.write(t4, n7), n7 += e7;
      }
      for (let r2 = e5; r2 < s4; r2++) {
        const s5 = this.m_bucketedIndices.read(r2 - e5), n8 = i2.getValue(s5), h3 = this.getBucket(n8), o2 = this.m_buckets.read(h3);
        t3.write(o2 + e5, s5), this.m_buckets.write(h3, o2 + 1);
      }
      r = false;
    }
    if (r) return void i2.userSort(e5, s4, t3);
    let a2 = 0;
    for (let m3 = 0, _ = this.m_buckets.size(); m3 < _; m3++) {
      const s5 = a2;
      a2 = this.m_buckets.read(m3), a2 > s5 && i2.userSort(e5 + s5, e5 + a2, t3);
    }
    this.m_buckets.size() > 100 && (this.m_buckets.resize(0), this.m_bucketedIndices.resize(0));
  }
  reset(t3, e5, s4, i2) {
    if (t3 < 2 || s4 === e5) return false;
    const n6 = Math.min(_ot.c_maxBuckets, t3);
    return this.m_buckets.resize(n6), this.m_buckets.setRange(0, 0, this.m_buckets.size()), this.m_minValue = e5, this.m_maxValue = s4, this.m_bucketedIndices.resize(i2), this.m_dy = (s4 - e5) / (n6 - 1), true;
  }
  getBucket(t3) {
    return Math.trunc((t3 - this.m_minValue) / this.m_dy);
  }
  getBucketCount() {
    return this.m_buckets.size();
  }
};
ot.c_maxBuckets = 65536;
var at = class {
  capacity() {
    return this.capacity_;
  }
  constructor(t3) {
    this.m_buffer = new Int32Array(0), this.m_firstFree = -1, this.m_last = 0, this.size_ = 0, this.capacity_ = 0, this.stride = t3;
  }
  size() {
    return this.size_;
  }
  deleteElement(t3) {
    t3 < this.m_last ? (this.m_buffer[t3 * this.stride] = this.m_firstFree, this.m_firstFree = t3) : this.m_last--, this.size_--;
  }
  getField(t3, e5) {
    return this.m_buffer[t3 * this.stride + e5];
  }
  setField(t3, e5, s4) {
    this.m_buffer[t3 * this.stride + e5] = s4;
  }
  elementToIndex(t3) {
    return t3;
  }
  newElement() {
    let t3 = this.m_firstFree;
    if (-1 === t3) {
      if (this.m_last === this.capacity_) {
        let t4 = 0 !== this.capacity_ ? Math.trunc(3 * (this.capacity_ + 1) / 2) : 1;
        if (t4 > Number.MAX_SAFE_INTEGER && (t4 = Number.MAX_SAFE_INTEGER), t4 === this.capacity_) throw new Error("index out of bounds");
        this.grow_(t4);
      }
      t3 = this.m_last, this.m_last++;
    } else this.m_firstFree = this.m_buffer[t3 * this.stride];
    this.size_++;
    for (let e5 = t3 * this.stride; e5 < t3 * this.stride + this.stride; e5++) this.m_buffer[e5] = -1;
    return t3;
  }
  newElementPset(t3) {
    let e5 = this.m_firstFree;
    if (-1 === e5) {
      if (this.m_last === this.capacity_) {
        let t4 = 0 !== this.capacity_ ? Math.trunc(3 * (this.capacity_ + 1) / 2) : 1;
        if (t4 > Number.MAX_SAFE_INTEGER && (t4 = Number.MAX_SAFE_INTEGER), t4 === this.capacity_) throw new Error("index out of bounds");
        this.grow_(t4);
      }
      e5 = this.m_last, this.m_last++;
    } else this.m_firstFree = this.m_buffer[e5 * this.stride];
    this.size_++;
    const s4 = e5 * this.stride;
    for (let i2 = 0; i2 < t3.length; i2++) this.m_buffer[s4 + i2] = t3[i2];
    return e5;
  }
  deleteAll(t3) {
    this.m_firstFree = -1, this.m_last = 0, this.size_ = 0, t3 && (this.m_buffer = new Int32Array(0), this.capacity_ = 0);
  }
  setCapacity(t3) {
    t3 > this.capacity_ && this.grow_(t3);
  }
  swap(t3, e5) {
    const s4 = t3 * this.stride, i2 = e5 * this.stride;
    for (let n6 = 0; n6 < this.stride; n6++) {
      const t4 = this.m_buffer[i2 + n6];
      this.m_buffer[i2 + n6] = this.m_buffer[s4 + n6], this.m_buffer[s4 + n6] = t4;
    }
  }
  swapField(t3, e5, s4) {
    const i2 = this.m_buffer[this.stride * e5 + s4];
    this.m_buffer[this.stride * e5 + s4] = this.m_buffer[this.stride * t3 + s4], this.m_buffer[this.stride * t3 + s4] = i2;
  }
  static impossibleIndex2() {
    return -2;
  }
  static impossibleIndex3() {
    return -3;
  }
  static isValidElement(t3) {
    return t3 >= 0;
  }
  grow_(t3) {
    null == this.m_buffer && (this.m_buffer = new Int32Array(0));
    const e5 = this.stride * t3, s4 = new Int32Array(e5);
    s4.set(this.m_buffer, 0), this.m_buffer = s4, this.capacity_ = t3;
  }
};
function mt(t3, e5) {
  return { element: t3, box: e5.clone() };
}
var _t2 = class __t {
  constructor(t3, e5, s4) {
    this.m_extent = new n4(), this.m_dataExtent = new n4(), this.m_childExtents = [new n4(), new n4(), new n4(), new n4()], this.m_elementNodes = new at(4), this.m_data = [], this.m_freeData = [], this.m_root = -1, this.m_height = 8, void 0 === s4 && (s4 = false), this.m_quadTreeNodes = new at(s4 ? 11 : 10), this.m_bStoreDuplicates = s4, this.reset_(t3, e5);
  }
  reset(t3, e5) {
    this.m_quadTreeNodes.deleteAll(false), this.m_elementNodes.deleteAll(false), this.m_data.length = 0, this.m_freeData.length = 0, this.reset_(t3, e5);
  }
  insert(t3, e5) {
    if (-1 === this.m_root && this.createRoot_(), this.m_bStoreDuplicates) {
      const s5 = this.insertDuplicates_(t3, e5, 0, this.m_extent, this.m_root, false, -1);
      return -1 !== s5 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e5 }) : this.m_dataExtent.mergeEnvelope2D(e5)), s5;
    }
    const s4 = this.insert_(t3, e5, 0, this.m_extent, this.m_root, false, -1);
    return -1 !== s4 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e5 }) : this.m_dataExtent.mergeEnvelope2D(e5)), s4;
  }
  insertEx(t3, e5, s4) {
    if (-1 === this.m_root && this.createRoot_(), this.m_bStoreDuplicates) {
      const s5 = this.insertDuplicates_(t3, e5, 0, this.m_extent, this.m_root, false, -1);
      return -1 !== s5 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e5 }) : this.m_dataExtent.mergeEnvelope2D(e5)), s5;
    }
    let i2;
    i2 = -1 === s4 ? this.m_root : this.getQuad_(s4);
    const n6 = this.getHeight(i2), r = this.getExtent(i2), h2 = this.insert_(t3, e5, n6, r, i2, false, -1);
    return -1 !== h2 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e5 }) : this.m_dataExtent.mergeEnvelope2D(e5)), h2;
  }
  removeElement(t3) {
    n2(0);
  }
  getElement(t3) {
    return this.getElementValue_(this.getData_(t3));
  }
  getElementAtIndex(t3) {
    return n2(0), 0;
  }
  getElementExtent(t3) {
    const e5 = this.getData_(t3);
    return this.getBoundingBoxValue_(e5).clone();
  }
  getElementExtentAtIndex(t3) {
    return n2(0), {};
  }
  getDataExtent() {
    return this.m_dataExtent.clone();
  }
  getQuadTreeExtent() {
    return n2(0), {};
  }
  getHeight(t3) {
    return this.m_quadTreeNodes.getField(t3, 6) >> __t.m_heightBitShift;
  }
  getMaxHeight() {
    return this.m_height;
  }
  getExtent(t3) {
    const e5 = new n4();
    if (e5.setCoords({ env2D: this.m_extent }), t3 === this.m_root) return e5;
    const s4 = [];
    let i2 = t3;
    do {
      s4.push(this.getQuadrant_(i2)), i2 = this.getParent_(i2);
    } while (i2 !== this.m_root);
    const n6 = s4.length;
    for (let r = 0; r < n6; r++) {
      const t4 = s4.at(-1);
      s4.pop(), 0 === t4 ? (e5.xmin = 0.5 * (e5.xmin + e5.xmax), e5.ymin = 0.5 * (e5.ymin + e5.ymax)) : 1 === t4 ? (e5.xmax = 0.5 * (e5.xmin + e5.xmax), e5.ymin = 0.5 * (e5.ymin + e5.ymax)) : 2 === t4 ? (e5.xmax = 0.5 * (e5.xmin + e5.xmax), e5.ymax = 0.5 * (e5.ymin + e5.ymax)) : (e5.xmin = 0.5 * (e5.xmin + e5.xmax), e5.ymax = 0.5 * (e5.ymin + e5.ymax));
    }
    return e5;
  }
  getQuad(t3) {
    return this.getQuad_(t3);
  }
  getElementCount() {
    return -1 === this.m_root ? 0 : this.getSubTreeElementCount_(this.m_root);
  }
  getSubTreeElementCount(t3) {
    return this.getSubTreeElementCount_(t3);
  }
  getContainedSubTreeElementCount(t3) {
    return this.m_bStoreDuplicates ? this.getContainedSubTreeElementCount_(t3) : this.getSubTreeElementCount_(t3);
  }
  getIntersectionCount(t3, e5, s4) {
    if (-1 === this.m_root) return 0;
    const i2 = new n4();
    i2.setCoords({ env2D: t3 }), i2.inflateCoords(e5, e5);
    const n6 = [], r = [];
    n6.push(this.m_root), r.push(this.m_extent.clone());
    const h2 = Ot(n4, 4);
    let o = 0;
    for (; n6.length > 0; ) {
      let t4 = false;
      const e6 = n6.at(-1), a2 = r.at(-1);
      if (n6.pop(), r.pop(), i2.containsEnvelope(a2)) {
        if (o += this.getSubTreeElementCount(e6), s4 > 0 && o >= s4) return s4;
      } else if (i2.isIntersecting(a2)) {
        for (let t5 = this.getFirstElement_(e6); -1 !== t5; t5 = this.getNextElement_(t5)) {
          const e7 = this.getData_(t5);
          if (this.getBoundingBoxValue_(e7).isIntersecting(i2) && (o++, s4 > 0 && o >= s4)) return s4;
        }
        t4 = this.getHeight(e6) + 1 <= this.m_height;
      }
      if (t4) {
        __t.setChildExtents_(a2, h2);
        for (let t5 = 0; t5 < 4; t5++) {
          const s5 = this.getChild_(e6, t5);
          if (-1 !== s5 && this.getSubTreeElementCount_(s5) > 0) {
            i2.isIntersecting(h2[t5]) && (n6.push(s5), r.push(h2[t5].clone()));
          }
        }
      }
    }
    return o;
  }
  hasData(t3, e5) {
    return this.getIntersectionCount(t3, e5, 1) >= 1;
  }
  getIterator(t3, e5) {
    return new lt(this, t3, e5);
  }
  getIteratorForQT() {
    return new lt(this);
  }
  getSortedIterator(t3, e5) {
    return new ut(this.getIterator(t3, e5));
  }
  getSortedIteratorForQT() {
    return new ut(this.getIteratorForQT());
  }
  visitLeavesNearest(t3, e5, s4, i2) {
    n2(0);
  }
  reset_(t3, e5) {
    (e5 < 0 || e5 > 127) && P("invalid height"), this.m_height = e5, this.m_extent.setCoords({ env2D: t3 }), this.m_dataExtent.setEmpty(), this.m_root = -1;
  }
  insert_(t3, e5, s4, i2, n6, r, h2) {
    if (!i2.containsEnvelope(e5)) return 0 === s4 ? -1 : this.insert_(t3, e5, 0, this.m_extent, this.m_root, r, h2);
    if (!r) for (let _ = n6; -1 !== _; _ = this.getParent_(_)) this.setSubTreeElementCount_(_, this.getSubTreeElementCount_(_) + 1);
    const o = new n4();
    o.setCoords({ env2D: i2 });
    let a2, m3 = n6;
    for (a2 = s4; a2 < this.m_height && this.canPushDown_(m3); a2++) {
      __t.setChildExtents_(o, this.m_childExtents);
      let t4 = false;
      for (let s5 = 0; s5 < 4; s5++) if (this.m_childExtents[s5].containsEnvelope(e5)) {
        t4 = true;
        let e6 = this.getChild_(m3, s5);
        -1 === e6 && (e6 = this.createChild_(m3, s5)), this.setSubTreeElementCount_(e6, this.getSubTreeElementCount_(e6) + 1), m3 = e6, o.setCoords({ env2D: this.m_childExtents[s5] });
        break;
      }
      if (!t4) break;
    }
    return this.insertAtQuad_(t3, e5, a2, o, m3, r, n6, h2, -1);
  }
  insertDuplicates_(t3, e5, s4, i2, n6, r, h2) {
    if (!r) {
      if (!i2.containsEnvelope(e5)) return -1;
      this.setSubTreeElementCount_(n6, this.getSubTreeElementCount_(n6) + 1), this.setContainedSubTreeElementCount_(n6, this.getContainedSubTreeElementCount_(n6) + 1);
    }
    const o = Math.max(e5.width(), e5.height());
    let a2 = -1;
    const m3 = [], _ = [], l2 = [];
    m3.push(n6), _.push(i2.clone()), l2.push(s4);
    const u = Ot(n4, 4);
    for (; m3.length > 0; ) {
      let s5 = false;
      const i3 = m3.at(-1), d2 = _.at(-1), c = l2.at(-1);
      if (m3.pop(), _.pop(), l2.pop(), c + 1 < this.m_height && this.canPushDown_(i3)) {
        o <= Math.max(d2.width(), d2.height()) / 2 && (s5 = true);
      }
      if (s5) {
        __t.setChildExtents_(d2, u);
        let t4 = false;
        for (let s6 = 0; s6 < 4; s6++) if (t4 = u[s6].containsEnvelope(e5), t4) {
          let t5 = this.getChild_(i3, s6);
          -1 === t5 && (t5 = this.createChild_(i3, s6)), m3.push(t5), _.push(u[s6].clone()), l2.push(c + 1), this.setSubTreeElementCount_(t5, this.getSubTreeElementCount_(t5) + 1), this.setContainedSubTreeElementCount_(t5, this.getContainedSubTreeElementCount_(t5) + 1);
          break;
        }
        if (!t4) for (let s6 = 0; s6 < 4; s6++) {
          if (u[s6].isIntersecting(e5)) {
            let t5 = this.getChild_(i3, s6);
            -1 === t5 && (t5 = this.createChild_(i3, s6)), m3.push(t5), _.push(u[s6].clone()), l2.push(c + 1), this.setSubTreeElementCount_(t5, this.getSubTreeElementCount_(t5) + 1);
          }
        }
      } else a2 = this.insertAtQuad_(t3, e5, c, d2, i3, r, n6, h2, a2), r = false;
    }
    return 0;
  }
  insertAtQuad_(t3, e5, s4, i2, n6, r, h2, o, a2) {
    this.getFirstElement_(n6);
    const m3 = this.getLastElement_(n6);
    let _ = -1;
    if (r) {
      if (n6 === h2) return o;
      this.disconnectElementHandle_(o), _ = o;
    } else -1 === a2 ? (_ = this.createElement_(), this.setDataValues_(this.getData_(_), t3, e5)) : _ = this.createElementFromDuplicate_(a2);
    return this.setQuad_(_, n6), -1 !== m3 ? (this.setPrevElement_(_, m3), this.setNextElement_(m3, _)) : this.setFirstElement_(n6, _), this.setLastElement_(n6, _), this.setLocalElementCount_(n6, this.getLocalElementCount_(n6) + 1), this.canFlush_(n6) && this.flush_(s4, i2, n6), _;
  }
  static setChildExtents_(t3, e5) {
    const s4 = 0.5 * (t3.xmin + t3.xmax), i2 = 0.5 * (t3.ymin + t3.ymax);
    e5[0].setCoords({ xmin: s4, ymin: i2, xmax: t3.xmax, ymax: t3.ymax }), e5[1].setCoords({ xmin: t3.xmin, ymin: i2, xmax: s4, ymax: t3.ymax }), e5[2].setCoords({ xmin: t3.xmin, ymin: t3.ymin, xmax: s4, ymax: i2 }), e5[3].setCoords({ xmin: s4, ymin: t3.ymin, xmax: t3.xmax, ymax: i2 });
  }
  disconnectElementHandle_(t3) {
    const e5 = this.getQuad_(t3), s4 = this.getFirstElement_(e5), i2 = this.getLastElement_(e5), n6 = this.getPrevElement_(t3), r = this.getNextElement_(t3);
    s4 === t3 ? (-1 !== r ? this.setPrevElement_(r, -1) : this.setLastElement_(e5, -1), this.setFirstElement_(e5, r)) : i2 === t3 ? (this.setNextElement_(n6, -1), this.setLastElement_(e5, n6)) : (this.setPrevElement_(r, n6), this.setNextElement_(n6, r)), this.setPrevElement_(t3, -1), this.setNextElement_(t3, -1), this.setLocalElementCount_(e5, this.getLocalElementCount_(e5) - 1);
  }
  canFlush_(t3) {
    return this.getLocalElementCount_(t3) === __t.m_flushingCount && !this.hasChildren_(t3);
  }
  flush_(t3, e5, s4) {
    let i2;
    const n6 = new n4();
    let r = this.getFirstElement_(s4), h2 = -1, o = -1;
    do {
      o = this.getData_(r), i2 = this.getElementValue_(o), n6.setCoords({ env2D: this.getBoundingBoxValue_(o) }), h2 = this.getNextElement_(r), this.m_bStoreDuplicates ? this.insertDuplicates_(i2, n6, t3, e5, s4, true, r) : this.insert_(i2, n6, t3, e5, s4, true, r), r = h2;
    } while (-1 !== r);
  }
  canPushDown_(t3) {
    return this.getLocalElementCount_(t3) >= __t.m_flushingCount || this.hasChildren_(t3);
  }
  hasChildren_(t3) {
    return -1 !== this.getChild_(t3, 0) || -1 !== this.getChild_(t3, 1) || -1 !== this.getChild_(t3, 2) || -1 !== this.getChild_(t3, 3);
  }
  createChild_(t3, e5) {
    const s4 = this.m_quadTreeNodes.newElement();
    return this.setChild_(t3, e5, s4), this.setSubTreeElementCount_(s4, 0), this.setLocalElementCount_(s4, 0), this.setParent_(s4, t3), this.setHeightAndQuadrant_(s4, this.getHeight_(t3) + 1, e5), this.m_bStoreDuplicates && this.setContainedSubTreeElementCount_(s4, 0), s4;
  }
  createRoot_() {
    this.m_root = this.m_quadTreeNodes.newElement(), this.setSubTreeElementCount_(this.m_root, 0), this.setLocalElementCount_(this.m_root, 0), this.setHeightAndQuadrant_(this.m_root, 0, 0), this.m_bStoreDuplicates && this.setContainedSubTreeElementCount_(this.m_root, 0);
  }
  createElement_() {
    const t3 = this.m_elementNodes.newElement();
    let e5;
    return this.m_freeData.length > 0 ? (e5 = this.m_freeData.at(-1), this.m_freeData.pop()) : (e5 = this.m_data.length, this.m_data.length = e5 + 1), this.setData_(t3, e5), t3;
  }
  createElementFromDuplicate_(t3) {
    const e5 = this.m_elementNodes.newElement(), s4 = this.getData_(t3);
    return this.setData_(e5, s4), e5;
  }
  freeElementAndBoxNode_(t3) {
    n2(0);
  }
  getChild_(t3, e5) {
    return this.m_quadTreeNodes.getField(t3, e5);
  }
  setChild_(t3, e5, s4) {
    this.m_quadTreeNodes.setField(t3, e5, s4);
  }
  getFirstElement_(t3) {
    return this.m_quadTreeNodes.getField(t3, 4);
  }
  setFirstElement_(t3, e5) {
    this.m_quadTreeNodes.setField(t3, 4, e5);
  }
  getLastElement_(t3) {
    return this.m_quadTreeNodes.getField(t3, 5);
  }
  setLastElement_(t3, e5) {
    this.m_quadTreeNodes.setField(t3, 5, e5);
  }
  getQuadrant_(t3) {
    return this.m_quadTreeNodes.getField(t3, 6) & __t.m_quadrantMask;
  }
  getHeight_(t3) {
    return this.m_quadTreeNodes.getField(t3, 6) >> __t.m_heightBitShift;
  }
  setHeightAndQuadrant_(t3, e5, s4) {
    const i2 = e5 << __t.m_heightBitShift | s4;
    this.m_quadTreeNodes.setField(t3, 6, i2);
  }
  getLocalElementCount_(t3) {
    return this.m_quadTreeNodes.getField(t3, 7);
  }
  setLocalElementCount_(t3, e5) {
    this.m_quadTreeNodes.setField(t3, 7, e5);
  }
  getSubTreeElementCount_(t3) {
    return this.m_quadTreeNodes.getField(t3, 8);
  }
  setSubTreeElementCount_(t3, e5) {
    this.m_quadTreeNodes.setField(t3, 8, e5);
  }
  getParent_(t3) {
    return this.m_quadTreeNodes.getField(t3, 9);
  }
  setParent_(t3, e5) {
    this.m_quadTreeNodes.setField(t3, 9, e5);
  }
  getContainedSubTreeElementCount_(t3) {
    return this.m_quadTreeNodes.getField(t3, 10);
  }
  setContainedSubTreeElementCount_(t3, e5) {
    this.m_quadTreeNodes.setField(t3, 10, e5);
  }
  getData_(t3) {
    return this.m_elementNodes.getField(t3, 0);
  }
  setData_(t3, e5) {
    this.m_elementNodes.setField(t3, 0, e5);
  }
  getPrevElement_(t3) {
    return this.m_elementNodes.getField(t3, 1);
  }
  getNextElement_(t3) {
    return this.m_elementNodes.getField(t3, 2);
  }
  setPrevElement_(t3, e5) {
    this.m_elementNodes.setField(t3, 1, e5);
  }
  setNextElement_(t3, e5) {
    this.m_elementNodes.setField(t3, 2, e5);
  }
  getQuad_(t3) {
    return this.m_elementNodes.getField(t3, 3);
  }
  setQuad_(t3, e5) {
    this.m_elementNodes.setField(t3, 3, e5);
  }
  getElementValue_(t3) {
    return this.m_data[t3].element;
  }
  getBoundingBoxValue_(t3) {
    return this.m_data[t3].box;
  }
  setDataValues_(t3, e5, s4) {
    this.m_data[t3] = mt(e5, s4);
  }
};
_t2.m_quadrantMask = 3, _t2.m_heightBitShift = 2, _t2.m_flushingCount = 5;
var lt = class {
  constructor(t3, e5, s4) {
    this.m_bLinear = false, this.m_queryStart = new mi(), this.m_queryEnd = new mi(), this.m_queryBox = new n4(), this.m_tolerance = 0, this.m_currentElementHandle = -1, this.m_nextElementHandle = -1, this.m_quadsStack = [], this.m_extentsStack = [], this.m_childExtents = [new n4(), new n4(), new n4(), new n4()], this.m_quadTree = t3, e5 && this.resetIterator(e5, s4);
  }
  resetIterator(t3, e5) {
    if (void 0 === e5 && (e5 = 0), t3 instanceof n4) return this.m_quadsStack.length = 0, this.m_extentsStack.length = 0, this.m_currentElementHandle = -1, this.m_queryBox.setCoords({ env2D: t3 }), this.m_queryBox.inflateCoords(e5, e5), this.m_tolerance = Number.NaN, void (-1 !== this.m_quadTree.m_root && this.m_queryBox.isIntersecting(this.m_quadTree.m_extent) ? (this.m_quadsStack.push(this.m_quadTree.m_root), this.m_extentsStack.push(this.m_quadTree.m_extent.clone()), this.m_nextElementHandle = this.m_quadTree.getFirstElement_(this.m_quadTree.m_root), this.m_bLinear = false) : this.m_nextElementHandle = -1);
    if (this.m_quadsStack.length = 0, this.m_extentsStack.length = 0, this.m_currentElementHandle = -1, t3.queryLooseEnvelope(this.m_queryBox), this.m_queryBox.inflateCoords(e5, e5), -1 !== this.m_quadTree.m_root && this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)) {
      const s4 = t3.getGeometryType();
      if (this.m_bLinear = s4 === a.enumLine, this.m_bLinear) {
        const s5 = t3;
        this.m_queryStart.assign(s5.getStartXY()), this.m_queryEnd.assign(s5.getEndXY()), this.m_tolerance = e5;
      } else this.m_tolerance = Number.NaN;
      this.m_quadsStack.push(this.m_quadTree.m_root), this.m_extentsStack.push(this.m_quadTree.m_extent.clone()), this.m_nextElementHandle = this.m_quadTree.getFirstElement_(this.m_quadTree.m_root);
    } else this.m_nextElementHandle = -1;
  }
  next() {
    if (0 === this.m_quadsStack.length) return -1;
    this.m_currentElementHandle = this.m_nextElementHandle;
    const t3 = new mi(), e5 = new mi(), s4 = new n4();
    let i2 = false;
    for (; !i2; ) {
      for (; -1 !== this.m_currentElementHandle; ) {
        const n6 = this.m_quadTree.getData_(this.m_currentElementHandle);
        if (s4.setCoords({ env2D: this.m_quadTree.getBoundingBoxValue_(n6) }), s4.isIntersecting(this.m_queryBox)) {
          if (!this.m_bLinear) {
            i2 = true;
            break;
          }
          if (t3.setCoordsPoint2D(this.m_queryStart), e5.setCoordsPoint2D(this.m_queryEnd), s4.inflateCoords(this.m_tolerance, this.m_tolerance), s4.clipLine(t3, e5) > 0) {
            i2 = true;
            break;
          }
        }
        this.m_currentElementHandle = this.m_quadTree.getNextElement_(this.m_currentElementHandle);
      }
      if (-1 === this.m_currentElementHandle) {
        const s5 = this.m_quadsStack.at(-1), i3 = this.m_extentsStack.at(-1);
        _t2.setChildExtents_(i3, this.m_childExtents), this.m_quadsStack.pop(), this.m_extentsStack.pop();
        for (let n6 = 0; n6 < 4; n6++) {
          const i4 = this.m_quadTree.getChild_(s5, n6);
          if (-1 !== i4 && this.m_quadTree.getSubTreeElementCount(i4) > 0 && this.m_childExtents[n6].isIntersecting(this.m_queryBox)) if (this.m_bLinear) {
            t3.setCoordsPoint2D(this.m_queryStart), e5.setCoordsPoint2D(this.m_queryEnd);
            const s6 = new n4();
            s6.setCoords({ env2D: this.m_childExtents[n6] }), s6.inflateCoords(this.m_tolerance, this.m_tolerance), s6.clipLine(t3, e5) > 0 && (this.m_quadsStack.push(i4), this.m_extentsStack.push(this.m_childExtents[n6].clone()));
          } else this.m_quadsStack.push(i4), this.m_extentsStack.push(this.m_childExtents[n6].clone());
        }
        if (0 === this.m_quadsStack.length) return -1;
        this.m_currentElementHandle = this.m_quadTree.getFirstElement_(this.m_quadsStack.at(-1));
      }
    }
    return this.m_nextElementHandle = this.m_quadTree.getNextElement_(this.m_currentElementHandle), this.m_currentElementHandle;
  }
  clone() {
    return n2(0), {};
  }
};
var ut = class {
  constructor(t3) {
    this.m_bucketSort = new ot(), this.m_sortedHandles = new st2(0), this.m_index = -1, this.m_quadTreeIteratorImpl = t3;
  }
  resetIterator(t3, e5) {
    this.m_quadTreeIteratorImpl.resetIterator(t3, e5), this.m_sortedHandles.resize(0), this.m_index = -1;
  }
  next() {
    if (-1 === this.m_index) {
      let t3 = -1;
      for (; -1 !== (t3 = this.m_quadTreeIteratorImpl.next()); ) this.m_sortedHandles.add(t3);
      const e5 = this, s4 = { userSort(t4, s5, i2) {
        i2.sort(t4, s5, (t5, s6) => e5.m_quadTreeIteratorImpl.m_quadTree.getElement(t5) - e5.m_quadTreeIteratorImpl.m_quadTree.getElement(s6));
      }, getValue: (t4) => e5.m_quadTreeIteratorImpl.m_quadTree.getElement(t4) };
      this.m_bucketSort.sort(this.m_sortedHandles, 0, this.m_sortedHandles.size(), s4);
    }
    return this.m_index === this.m_sortedHandles.size() - 1 ? -1 : (this.m_index++, this.m_sortedHandles.read(this.m_index));
  }
  clone() {
    return n2(0), {};
  }
};
var dt = class {
  constructor(t3 = false) {
    this.m_bNotifyOnActions = t3;
  }
  onDelete(t3) {
  }
  onSet(t3) {
  }
  onEndSearch(t3) {
  }
  onAddUniqueElementFailed(t3) {
  }
  onDeleteImpl(t3, e5) {
    this.m_bNotifyOnActions && this.onDelete(t3.getElement(e5));
  }
  onSetImpl(t3, e5) {
    this.m_bNotifyOnActions && this.onSet(t3.getElement(e5));
  }
  onAddUniqueElementFailedImpl(t3) {
    this.m_bNotifyOnActions && this.onAddUniqueElementFailed(t3);
  }
  onEndSearchImpl(t3) {
    this.m_bNotifyOnActions && this.onEndSearch(t3);
  }
};
var ct2 = class _ct {
  static st_nullNode() {
    return -1;
  }
  constructor() {
    this.m_defaultTreap = -1, this.m_random = 124234251, this.m_comparator = null, this.m_treapData = new at(7), this.m_treapCount = 0, this.m_maxDepthEver = 0, this.m_bBalancing = true;
  }
  setComparator(t3) {
    this.m_comparator = t3;
  }
  getComparator() {
    return this.m_comparator;
  }
  disableBalancing() {
    this.m_bBalancing = false;
  }
  enableBalancing() {
    this.m_bBalancing || (n2(this.m_treapCount <= 1), this.rebalance(-1), this.m_bBalancing = true);
  }
  isAutoBalancing() {
    return this.m_bBalancing;
  }
  rebalance(t3) {
    if (this.m_bBalancing) return;
    if (-1 === t3 && (t3 = this.m_defaultTreap), 0 === this.size(t3)) return;
    const e5 = [];
    for (let s4 = this.getFirst(t3); -1 !== s4; s4 = this.getNext(s4)) e5.push(s4), this.setParent_(s4, -1), this.setRight_(s4, -1), this.setLeft_(s4, -1);
    this.setRoot_(-1, t3), this.setFirst_(-1, t3), this.setLast_(-1, t3), this.setSize_(0, t3), this.m_bBalancing = true;
    for (const s4 of e5) this.addBiggestElement_(s4, t3);
    this.m_bBalancing = false;
  }
  setCapacity(t3) {
    this.m_treapData.setCapacity(t3);
  }
  createTreap(t3) {
    const e5 = this.m_treapData.newElement();
    return this.setSize_(0, e5), this.setTreapData_(t3, e5), this.m_treapCount++, e5;
  }
  deleteTreap(t3) {
    this.m_treapData.deleteElement(t3), this.m_treapCount--;
  }
  addElement(t3, e5 = -1) {
    return -1 === e5 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e5 = this.m_defaultTreap), this.addElement_(t3, 0, e5);
  }
  addUniqueElement(t3, e5 = -1) {
    return -1 === e5 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e5 = this.m_defaultTreap), this.addElement_(t3, 1, e5);
  }
  addBiggestElement(t3, e5 = -1) {
    -1 === e5 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e5 = this.m_defaultTreap);
    const s4 = this.newNode_(t3);
    return this.addBiggestElement_(s4, e5), s4;
  }
  addElementAtPosition(t3, e5, s4, i2, n6, r = -1) {
    if (-1 === r && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), r = this.m_defaultTreap), this.getRoot_(r) === _ct.st_nullNode()) {
      const t4 = this.newNode_(s4);
      return this.setRoot_(t4, r), this.addToList_(-1, t4, r), t4;
    }
    let h2, o, a2, m3, _;
    if (n6 ? (h2 = e5 !== _ct.st_nullNode() ? this.m_comparator.compare(this, s4, e5) : -1, o = t3 !== _ct.st_nullNode() ? this.m_comparator.compare(this, s4, t3) : 1) : (h2 = -1, o = 1), i2 && (0 === h2 || 0 === o)) {
      this.m_comparator.onAddUniqueElementFailedImpl(s4);
      const i3 = 0 === h2 ? e5 : t3;
      return this.setDuplicateElement_(i3, r), -1;
    }
    _ = e5 !== _ct.st_nullNode() && t3 !== _ct.st_nullNode() ? this.m_random > Ss(this.m_random) >> 1 : e5 !== _ct.st_nullNode(), _ ? (m3 = h2, a2 = e5) : (m3 = o, a2 = t3);
    let u = -1, d2 = -1, c = true;
    for (; ; ) {
      if (m3 < 0) {
        const t4 = this.getLeft(a2);
        if (t4 === _ct.st_nullNode()) {
          d2 = a2, u = this.newNode_(s4), this.setLeft_(a2, u), this.setParent_(u, a2);
          break;
        }
        a2 = t4;
      } else {
        const t4 = this.getRight(a2);
        if (t4 === _ct.st_nullNode()) {
          d2 = this.getNext(a2), u = this.newNode_(s4), this.setRight_(a2, u), this.setParent_(u, a2);
          break;
        }
        a2 = t4;
      }
      c && (m3 *= -1, c = false);
    }
    return this.bubbleUp_(u), this.getParent(u) === _ct.st_nullNode() && this.setRoot_(u, r), this.addToList_(d2, u, r), u;
  }
  replaceElementAtPosition(t3, e5, s4, i2, n6 = -1) {
    if (i2) {
      const i3 = this.getNext(t3);
      let r = -1;
      i3 !== _ct.st_nullNode() && (r = this.m_comparator.compare(this, e5, i3));
      const h2 = this.getPrev(t3);
      let o = -1;
      if (h2 !== _ct.st_nullNode() && (o = this.m_comparator.compare(this, e5, h2)), s4 && (0 === r || 0 === o)) {
        this.m_comparator.onAddUniqueElementFailedImpl(e5);
        const t4 = 0 === r ? i3 : h2;
        return n6 === _ct.st_nullNode() && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), n6 = this.m_defaultTreap), this.setDuplicateElement_(t4, n6), -1;
      }
    }
    return this.setElement_(t3, e5), t3;
  }
  getDuplicateElement(t3 = -1) {
    return -1 === t3 ? this.getDuplicateElement_(this.m_defaultTreap) : this.getDuplicateElement_(t3);
  }
  deleteNode(t3, e5 = -1) {
    this.m_comparator && this.m_comparator.onDeleteImpl(this, t3), -1 === e5 && (e5 = this.m_defaultTreap), this.m_bBalancing ? this.deleteNode_(t3, e5) : this.unbalancedDelete_(t3, e5);
  }
  search(t3, e5 = -1) {
    let s4 = this.getRoot(e5);
    for (; s4 !== _ct.st_nullNode(); ) {
      const e6 = this.m_comparator.compare(this, t3, s4);
      if (!e6) return s4;
      s4 = e6 < 0 ? this.getLeft(s4) : this.getRight(s4);
    }
    return this.m_comparator.onEndSearchImpl(t3), _ct.st_nullNode();
  }
  searchLowerBound(t3, e5 = -1) {
    let s4 = this.getRoot(e5), i2 = -1;
    for (; s4 !== _ct.st_nullNode(); ) {
      const e6 = t3.compare(this, s4);
      if (!e6) return s4;
      e6 < 0 ? s4 = this.getLeft(s4) : (i2 = s4, s4 = this.getRight(s4));
    }
    return i2;
  }
  searchUpperBound(t3, e5 = -1) {
    let s4 = this.getRoot(e5), i2 = -1;
    for (; s4 !== _ct.st_nullNode(); ) {
      const e6 = t3.compare(this, s4);
      if (!e6) return s4;
      e6 < 0 ? (i2 = s4, s4 = this.getLeft(s4)) : s4 = this.getRight(s4);
    }
    return i2;
  }
  getElement(t3) {
    return this.m_treapData.getField(t3, 3);
  }
  getLeft(t3) {
    return this.m_treapData.getField(t3, 0);
  }
  getRight(t3) {
    return this.m_treapData.getField(t3, 1);
  }
  getParent(t3) {
    return this.m_treapData.getField(t3, 2);
  }
  getNext(t3) {
    return this.m_treapData.getField(t3, 6);
  }
  getPrev(t3) {
    return this.m_treapData.getField(t3, 5);
  }
  getFirst(t3 = -1) {
    return -1 === t3 ? this.getFirst_(this.m_defaultTreap) : this.getFirst_(t3);
  }
  getLast(t3 = -1) {
    return -1 === t3 ? this.getLast_(this.m_defaultTreap) : this.getLast_(t3);
  }
  getTreapData(t3 = -1) {
    return -1 === t3 ? this.getTreapData_(this.m_defaultTreap) : this.getTreapData_(t3);
  }
  setElement(t3, e5) {
    null !== this.m_comparator && this.m_comparator.onSetImpl(this, t3), this.setElement_(t3, e5);
  }
  getRoot(t3 = -1) {
    return -1 === t3 ? this.getRoot_(this.m_defaultTreap) : this.getRoot_(t3);
  }
  clear() {
    this.m_treapData.deleteAll(false), this.m_defaultTreap = _ct.st_nullNode(), this.m_treapCount = 0, this.m_maxDepthEver = 0;
  }
  addToList_(t3, e5, s4) {
    let i2;
    -1 !== t3 ? (i2 = this.getPrev(t3), this.setPrev_(t3, e5)) : i2 = this.getLast_(s4), this.setPrev_(e5, i2), -1 !== i2 && this.setNext_(i2, e5), this.setNext_(e5, t3), t3 === this.getFirst_(s4) && this.setFirst_(e5, s4), -1 === t3 && this.setLast_(e5, s4), this.setSize_(this.getSize_(s4) + 1, s4);
  }
  size(t3 = -1) {
    return -1 === t3 ? this.getSize_(this.m_defaultTreap) : this.getSize_(t3);
  }
  getMaxDepth(t3 = -1) {
    return this.getMaxDepthHelper_(this.getRoot(t3));
  }
  getMaxDepthEver() {
    return this.m_maxDepthEver;
  }
  static st_isValidNode(t3) {
    return at.isValidElement(t3);
  }
  dbgCheck_(t3) {
  }
  getPriority_(t3) {
    return this.m_treapData.getField(t3, 4);
  }
  bubbleDown_(t3) {
    let e5 = this.getLeft(t3), s4 = this.getRight(t3);
    const i2 = this.getPriority_(t3);
    for (; e5 !== _ct.st_nullNode() || s4 !== _ct.st_nullNode(); ) {
      const n6 = e5 !== _ct.st_nullNode() ? this.getPriority_(e5) : vs(), r = s4 !== _ct.st_nullNode() ? this.getPriority_(s4) : vs();
      if (i2 <= Math.min(n6, r)) return;
      n6 <= r ? this.rotateRight_(e5) : this.rotateLeft_(t3), e5 = this.getLeft(t3), s4 = this.getRight(t3);
    }
  }
  bubbleUp_(t3) {
    if (!this.m_bBalancing) return;
    const e5 = this.getPriority_(t3);
    let s4 = this.getParent(t3);
    for (; s4 !== _ct.st_nullNode() && this.getPriority_(s4) > e5; ) this.getLeft(s4) === t3 ? this.rotateRight_(t3) : this.rotateLeft_(s4), s4 = this.getParent(t3);
  }
  rotateLeft_(t3) {
    const e5 = t3, s4 = this.getRight(t3);
    let i2;
    this.setParent_(s4, this.getParent(e5)), this.setParent_(e5, s4), i2 = this.getLeft(s4), this.setRight_(e5, i2), i2 !== _ct.st_nullNode() && this.setParent_(i2, e5), this.setLeft_(s4, e5), i2 = this.getParent(s4), i2 !== _ct.st_nullNode() && (this.getLeft(i2) === e5 ? this.setLeft_(i2, s4) : this.setRight_(i2, s4));
  }
  rotateRight_(t3) {
    const e5 = this.getParent(t3), s4 = t3;
    let i2;
    this.setParent_(s4, this.getParent(e5)), this.setParent_(e5, s4), i2 = this.getRight(s4), this.setLeft_(e5, i2), i2 !== _ct.st_nullNode() && this.setParent_(i2, e5), this.setRight_(s4, e5), i2 = this.getParent(s4), i2 !== _ct.st_nullNode() && (this.getLeft(i2) === e5 ? this.setLeft_(i2, s4) : this.setRight_(i2, s4));
  }
  setParent_(t3, e5) {
    this.m_treapData.setField(t3, 2, e5);
  }
  setLeft_(t3, e5) {
    this.m_treapData.setField(t3, 0, e5);
  }
  setRight_(t3, e5) {
    this.m_treapData.setField(t3, 1, e5);
  }
  setPriority_(t3, e5) {
    this.m_treapData.setField(t3, 4, e5);
  }
  setPrev_(t3, e5) {
    this.m_treapData.setField(t3, 5, e5);
  }
  setNext_(t3, e5) {
    this.m_treapData.setField(t3, 6, e5);
  }
  setRoot_(t3, e5) {
    this.m_treapData.setField(e5, 0, t3);
  }
  setFirst_(t3, e5) {
    this.m_treapData.setField(e5, 1, t3);
  }
  setLast_(t3, e5) {
    this.m_treapData.setField(e5, 2, t3);
  }
  setDuplicateElement_(t3, e5) {
    this.m_treapData.setField(e5, 3, t3);
  }
  setSize_(t3, e5) {
    this.m_treapData.setField(e5, 4, t3);
  }
  setTreapData_(t3, e5) {
    this.m_treapData.setField(e5, 5, t3);
  }
  getRoot_(t3) {
    return -1 === t3 ? _ct.st_nullNode() : this.m_treapData.getField(t3, 0);
  }
  getFirst_(t3) {
    return -1 === t3 ? _ct.st_nullNode() : this.m_treapData.getField(t3, 1);
  }
  getLast_(t3) {
    return -1 === t3 ? _ct.st_nullNode() : this.m_treapData.getField(t3, 2);
  }
  getDuplicateElement_(t3) {
    return -1 === t3 ? _ct.st_nullNode() : this.m_treapData.getField(t3, 3);
  }
  getSize_(t3) {
    return -1 === t3 ? 0 : this.m_treapData.getField(t3, 4);
  }
  getTreapData_(t3) {
    return this.m_treapData.getField(t3, 5);
  }
  newNode_(t3) {
    const e5 = this.m_treapData.newElement();
    return this.setPriority_(e5, this.generatePriority_()), this.setElement_(e5, t3), e5;
  }
  freeNode_(t3, e5) {
    t3 !== _ct.st_nullNode() && this.m_treapData.deleteElement(t3);
  }
  generatePriority_() {
    return this.m_random = Ss(this.m_random), this.m_random & vs() >> 1;
  }
  maxPriority() {
    return n2(0), 0;
  }
  getMaxDepthHelper_(t3) {
    return t3 === _ct.st_nullNode() ? 0 : 1 + Math.max(this.getMaxDepthHelper_(this.getLeft(t3)), this.getMaxDepthHelper_(this.getRight(t3)));
  }
  addElement_(t3, e5, s4) {
    if (this.getRoot(s4) === _ct.st_nullNode()) {
      const e6 = this.newNode_(t3);
      return this.setRoot_(e6, s4), this.addToList_(-1, e6, s4), this.m_maxDepthEver = Math.max(this.m_maxDepthEver, 1), e6;
    }
    let i2 = this.getRoot_(s4), n6 = -1, r = -1, h2 = 1;
    for (; ; ) {
      const o = -1 === e5 ? 1 : this.m_comparator.compare(this, t3, i2);
      if (o < 0) {
        const e6 = this.getLeft(i2);
        if (e6 === _ct.st_nullNode()) {
          r = i2, n6 = this.newNode_(t3), this.setLeft_(i2, n6), this.setParent_(n6, i2);
          break;
        }
        i2 = e6;
      } else {
        if (1 === e5 && 0 === o) return this.m_comparator.onAddUniqueElementFailedImpl(t3), this.setDuplicateElement_(i2, s4), -1;
        const h3 = this.getRight(i2);
        if (h3 === _ct.st_nullNode()) {
          r = this.getNext(i2), n6 = this.newNode_(t3), this.setRight_(i2, n6), this.setParent_(n6, i2);
          break;
        }
        i2 = h3;
      }
      h2++;
    }
    return this.bubbleUp_(n6), this.getParent(n6) === _ct.st_nullNode() && this.setRoot_(n6, s4), this.addToList_(r, n6, s4), this.m_maxDepthEver = Math.max(h2, this.m_maxDepthEver), n6;
  }
  removeFromList_(t3, e5) {
    const s4 = this.getPrev(t3), i2 = this.getNext(t3);
    -1 !== s4 ? this.setNext_(s4, i2) : this.setFirst_(i2, e5), -1 !== i2 ? this.setPrev_(i2, s4) : this.setLast_(s4, e5), this.setSize_(this.getSize_(e5) - 1, e5);
  }
  unbalancedDelete_(t3, e5) {
    this.removeFromList_(t3, e5);
    let s4 = this.getLeft(t3), i2 = this.getRight(t3), n6 = this.getParent(t3), r = t3;
    if (-1 !== s4 && -1 !== i2) {
      let h3;
      this.m_random = Ss(this.m_random), h3 = this.m_random > vs() >> 1 ? this.getNext(t3) : this.getPrev(t3);
      const o = this.getParent(h3) === t3;
      this.m_treapData.swapField(t3, h3, 0), this.m_treapData.swapField(t3, h3, 1), this.m_treapData.swapField(t3, h3, 2), -1 !== n6 ? this.getLeft(n6) === t3 ? this.setLeft_(n6, h3) : this.setRight_(n6, h3) : this.setRoot_(h3, e5), o ? (s4 === h3 ? (this.setLeft_(h3, t3), this.setParent_(i2, h3)) : i2 === h3 && (this.setRight_(h3, t3), this.setParent_(s4, h3)), this.setParent_(t3, h3), n6 = h3) : (this.setParent_(s4, h3), this.setParent_(i2, h3), n6 = this.getParent(t3), r = h3), s4 = this.getLeft(t3), i2 = this.getRight(t3), -1 !== s4 && this.setParent_(s4, t3), -1 !== i2 && this.setParent_(i2, t3);
    }
    const h2 = -1 !== s4 ? s4 : i2;
    -1 === n6 ? this.setRoot_(h2, e5) : this.getLeft(n6) === r ? this.setLeft_(n6, h2) : this.setRight_(n6, h2), -1 !== h2 && this.setParent_(h2, n6), this.freeNode_(t3, e5);
  }
  deleteNode_(t3, e5) {
    this.setPriority_(t3, vs());
    let s4 = _ct.st_nullNode(), i2 = _ct.st_nullNode();
    const n6 = this.getRoot_(e5), r = n6 === t3;
    if (r && (s4 = this.getLeft(n6), i2 = this.getRight(n6), s4 === _ct.st_nullNode() && i2 === _ct.st_nullNode())) return this.removeFromList_(n6, e5), this.freeNode_(n6, e5), void this.setRoot_(_ct.st_nullNode(), e5);
    this.bubbleDown_(t3);
    const h2 = this.getParent(t3);
    h2 !== _ct.st_nullNode() && (this.getLeft(h2) === t3 ? this.setLeft_(h2, _ct.st_nullNode()) : this.setRight_(h2, _ct.st_nullNode())), this.removeFromList_(t3, e5), this.freeNode_(t3, e5), r && this.setRoot_(s4 === _ct.st_nullNode() || this.getParent(s4) !== _ct.st_nullNode() ? i2 : s4, e5);
  }
  setElement_(t3, e5) {
    this.m_treapData.setField(t3, 3, e5);
  }
  addBiggestElement_(t3, e5) {
    if (this.getRoot_(e5) === _ct.st_nullNode()) return this.setRoot_(t3, e5), void this.addToList_(-1, t3, e5);
    const s4 = this.getLast_(e5);
    this.setRight_(s4, t3), this.setParent_(t3, s4), this.bubbleUp_(t3), this.getParent(t3) === _ct.st_nullNode() && this.setRoot_(t3, e5), this.addToList_(-1, t3, e5);
  }
};
var pt = class _pt {
  constructor(t3) {
    this.m_lists = new at(6), this.m_listOfLists = _pt.st_nullNode(), void 0 === t3 ? (this.m_listNodes = new at(3), this.m_bStoreListIndexWithNode = false) : (this.m_listNodes = new at(t3 ? 4 : 3), this.m_bStoreListIndexWithNode = t3);
  }
  freeNode_(t3) {
    this.m_listNodes.deleteElement(t3);
  }
  newNode_() {
    return this.m_listNodes.newElement();
  }
  freeList_(t3) {
    n2(0);
  }
  newList_() {
    return this.m_lists.newElement();
  }
  setPrev_(t3, e5) {
    this.m_listNodes.setField(t3, 1, e5);
  }
  setNext_(t3, e5) {
    this.m_listNodes.setField(t3, 2, e5);
  }
  setData_(t3, e5) {
    n2(0);
  }
  setList_(t3, e5) {
    return this.m_listNodes.setField(t3, 3, e5);
  }
  setListSize_(t3, e5) {
    this.m_lists.setField(t3, 4, e5);
  }
  setNextList_(t3, e5) {
    n2(0);
  }
  setPrevList_(t3, e5) {
    this.m_lists.setField(t3, 2, e5);
  }
  createList(t3) {
    const e5 = this.newList_();
    return this.m_lists.setField(e5, 3, this.m_listOfLists), this.m_lists.setField(e5, 4, 0), this.m_lists.setField(e5, 5, t3), this.m_listOfLists !== _pt.st_nullNode() && this.setPrevList_(this.m_listOfLists, e5), this.m_listOfLists = e5, e5;
  }
  deleteList(t3) {
    this.clear(t3);
    const e5 = this.m_lists.getField(t3, 2), s4 = this.m_lists.getField(t3, 3);
    return e5 !== _pt.st_nullNode() ? this.setNextList_(e5, s4) : this.m_listOfLists = s4, s4 !== _pt.st_nullNode() && this.setPrevList_(s4, e5), this.freeList_(t3), s4;
  }
  reserveLists(t3) {
    n2(0);
  }
  getListData(t3) {
    return this.m_lists.getField(t3, 5);
  }
  getList(t3) {
    return n2(0), 0;
  }
  setListData(t3, e5) {
    this.m_lists.setField(t3, 5, e5);
  }
  addElement(t3, e5) {
    return this.insertElement(t3, -1, e5);
  }
  insertElement(t3, e5, s4) {
    const i2 = this.newNode_();
    let n6 = -1;
    e5 !== _pt.st_nullNode() && (n6 = this.getPrev(e5), this.setPrev_(e5, i2)), this.setNext_(i2, e5), n6 !== _pt.st_nullNode() && this.setNext_(n6, i2);
    if (e5 === this.m_lists.getField(t3, 0) && this.m_lists.setField(t3, 0, i2), e5 === _pt.st_nullNode()) {
      const e6 = this.m_lists.getField(t3, 1);
      this.setPrev_(i2, e6), -1 !== e6 && this.setNext_(e6, i2), this.m_lists.setField(t3, 1, i2);
    }
    return this.setData(i2, s4), this.setListSize_(t3, this.getListSize(t3) + 1), this.m_bStoreListIndexWithNode && this.setList_(i2, t3), i2;
  }
  deleteElement(t3, e5) {
    const s4 = this.getPrev(e5), i2 = this.getNext(e5);
    return s4 !== _pt.st_nullNode() ? this.setNext_(s4, i2) : this.m_lists.setField(t3, 0, i2), i2 !== _pt.st_nullNode() ? this.setPrev_(i2, s4) : this.m_lists.setField(t3, 1, s4), this.freeNode_(e5), this.setListSize_(t3, this.getListSize(t3) - 1), i2;
  }
  reserveNodes(t3) {
    this.m_listNodes.setCapacity(t3);
  }
  getData(t3) {
    return this.m_listNodes.getField(t3, 0);
  }
  getElement(t3) {
    return this.getData(t3);
  }
  setData(t3, e5) {
    this.m_listNodes.setField(t3, 0, e5);
  }
  getNext(t3) {
    return this.m_listNodes.getField(t3, 2);
  }
  getPrev(t3) {
    return this.m_listNodes.getField(t3, 1);
  }
  getFirst(t3) {
    return this.m_lists.getField(t3, 0);
  }
  getLast(t3) {
    return this.m_lists.getField(t3, 1);
  }
  static st_nullNode() {
    return -1;
  }
  clear(t3) {
    if (void 0 !== t3) {
      let e5 = this.getLast(t3);
      for (; e5 !== _pt.st_nullNode(); ) {
        const t4 = e5;
        e5 = this.getPrev(t4), this.freeNode_(t4);
      }
      return this.m_lists.setField(t3, 0, -1), this.m_lists.setField(t3, 1, -1), void this.setListSize_(t3, 0);
    }
    for (let e5 = this.getFirstList(); -1 !== e5; ) e5 = this.deleteList(e5);
  }
  isEmpty(t3) {
    return n2(0), false;
  }
  getNodeCount() {
    return this.m_listNodes.size();
  }
  getListCount() {
    return this.m_lists.size();
  }
  getListSize(t3) {
    return this.m_lists.getField(t3, 4);
  }
  getFirstList() {
    return this.m_listOfLists;
  }
  getNextList(t3) {
    return this.m_lists.getField(t3, 3);
  }
};
var gt2 = class extends dt {
  constructor(t3) {
    super(), this.m_intervalTree = t3;
  }
  compare(t3, e5, s4) {
    const i2 = t3.getElement(s4), n6 = this.m_intervalTree.getValue_(e5), r = this.m_intervalTree.getValue_(i2);
    return n6 < r ? -1 : n6 === r ? ft2.isLeft_(e5) && ft2.isRight_(i2) ? -1 : ft2.isLeft_(i2) && ft2.isRight_(e5) ? 1 : 0 : 1;
  }
};
var ft2 = class _ft {
  constructor(t3) {
    this.m_bEnvelopesRef = false, this.m_intervals = [], this.m_envelopesRef = null, this.m_intervalNodes = new at(3), this.m_intervalHandles = [], this.m_endIndicesUnique = [], this.m_cCount = -1, this.m_root = -1, this.m_bSortIntervals = false, this.m_bConstructing = false, this.m_bConstructionEnded = false, this.m_bOfflineDynamic = t3, this.m_tertiaryNodes = new at(this.m_bOfflineDynamic ? 5 : 4), this.m_secondaryTreaps = new ct2(), this.m_secondaryTreaps.setComparator(new gt2(this)), this.m_secondaryLists = new pt();
  }
  addEnvelopesRef(t3) {
    this.reset_(true, true), this.m_bEnvelopesRef = true, this.m_envelopesRef = t3, this.m_bConstructing = false, this.m_bConstructionEnded = true, this.m_bOfflineDynamic || (this.insertIntervalsStatic_(), this.m_cCount = this.m_envelopesRef.length);
  }
  startConstruction() {
    this.reset_(true, false);
  }
  addInterval(t3) {
    this.m_bConstructing || C(""), this.m_intervals.push(t3.clone());
  }
  addIntervalCoords(t3, e5) {
    n2(0);
  }
  endConstruction() {
    this.m_bConstructing || C(""), this.m_bConstructing = false, this.m_bConstructionEnded = true, this.m_bOfflineDynamic || (this.insertIntervalsStatic_(), this.m_cCount = this.m_intervals.length);
  }
  insert(t3) {
    if (this.m_bOfflineDynamic && this.m_bConstructionEnded || C(""), -1 === this.m_root) {
      const t4 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length;
      if (this.m_bSortIntervals) {
        const e6 = new st2(0);
        this.querySortedEndPointIndices_(e6), this.m_endIndicesUnique.length = 0, this.querySortedDuplicatesRemoved_(e6), this.m_intervalHandles.length = t4, this.m_intervalHandles.fill(-1), this.m_bSortIntervals = false;
      } else this.m_intervalHandles.fill(-1, 0, t4);
      this.m_root = this.createRoot_();
    }
    const e5 = this.insertIntervalEnd_(t3 << 1, this.m_root), s4 = this.getSecondaryFromInterval_(e5), i2 = this.m_secondaryTreaps.addElement(1 + (t3 << 1), s4);
    this.setRightEnd_(e5, i2), this.m_intervalHandles[t3] = e5, this.m_cCount++;
  }
  remove(t3) {
    this.m_bOfflineDynamic && this.m_bConstructionEnded || C("");
    const e5 = this.m_intervalHandles[t3];
    let s4;
    -1 === e5 && P("the interval does not exist in the interval tree"), this.m_intervalHandles[t3] = -1, this.m_cCount--;
    let i2 = this.getSecondaryFromInterval_(e5), n6 = -1;
    n6 = this.m_secondaryTreaps.getTreapData(i2), this.m_secondaryTreaps.deleteNode(this.getLeftEnd_(e5), i2), this.m_secondaryTreaps.deleteNode(this.getRightEnd_(e5), i2), s4 = this.m_secondaryTreaps.size(i2), 0 === s4 && (this.m_secondaryTreaps.deleteTreap(i2), this.setSecondaryToTertiary_(n6, -1)), this.m_intervalNodes.deleteElement(e5);
    let r = this.getPptr_(n6), h2 = this.getLptr_(n6), o = this.getRptr_(n6);
    for (; !(s4 > 0 || n6 === this.m_root || -1 !== h2 && -1 !== o); ) n6 === this.getLptr_(r) ? -1 !== h2 ? (this.setLptr_(r, h2), this.setPptr_(h2, r), this.setLptr_(n6, -1), this.setPptr_(n6, -1)) : -1 !== o ? (this.setLptr_(r, o), this.setPptr_(o, r), this.setRptr_(n6, -1), this.setPptr_(n6, -1)) : (this.setLptr_(r, -1), this.setPptr_(n6, -1)) : -1 !== h2 ? (this.setRptr_(r, h2), this.setPptr_(h2, r), this.setLptr_(n6, -1), this.setPptr_(n6, -1)) : -1 !== o ? (this.setRptr_(r, o), this.setPptr_(o, r), this.setRptr_(n6, -1), this.setPptr_(n6, -1)) : (this.setRptr_(r, -1), this.setPptr_(n6, -1)), this.m_tertiaryNodes.deleteElement(n6), n6 = r, i2 = this.getSecondaryFromTertiary_(n6), s4 = -1 !== i2 ? this.m_secondaryTreaps.size(i2) : 0, h2 = this.getLptr_(n6), o = this.getRptr_(n6), r = this.getPptr_(n6);
  }
  size() {
    return this.m_cCount;
  }
  getIteratorQuery(t3, e5) {
    return t3 instanceof x2 ? new vt2(this, t3, e5) : (n2(0), {});
  }
  getIterator() {
    return new vt2(this);
  }
  querySortedEndPointIndices_(t3) {
    const e5 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length;
    for (let s4 = 0; s4 < 2 * e5; s4++) t3.add(s4);
    this.sortEndIndices_(t3, 0, 2 * e5);
  }
  querySortedDuplicatesRemoved_(t3) {
    let e5 = Number.NaN;
    for (let s4 = 0; s4 < t3.size(); s4++) {
      const i2 = t3.read(s4), n6 = this.getValue_(i2);
      n6 !== e5 && (this.m_endIndicesUnique.push(i2), e5 = n6);
    }
  }
  insertIntervalsStatic_() {
    const t3 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length, s4 = new st2(0);
    this.querySortedEndPointIndices_(s4), this.m_endIndicesUnique.length = 0, this.querySortedDuplicatesRemoved_(s4), this.m_intervalNodes.setCapacity(t3), this.m_secondaryLists.reserveNodes(2 * t3);
    const i2 = Yt(t3, -1);
    this.m_root = this.createRoot_();
    for (let e5 = 0; e5 < s4.size(); e5++) {
      const t4 = s4.read(e5);
      let n6 = i2[t4 >> 1];
      if (-1 !== n6) {
        const e6 = this.getSecondaryFromInterval_(n6);
        this.setRightEnd_(n6, this.m_secondaryLists.addElement(e6, t4));
      } else n6 = this.insertIntervalEnd_(t4, this.m_root), i2[t4 >> 1] = n6;
    }
  }
  createRoot_() {
    const t3 = this.calculateDiscriminantIndex1_(0, this.m_endIndicesUnique.length - 1);
    return this.createTertiaryNode_(t3);
  }
  insertIntervalEnd_(t3, e5) {
    let s4 = -1, i2 = e5, n6 = -1, r = -1, h2 = 0, o = this.m_endIndicesUnique.length - 1, a2 = 0;
    const m3 = t3 >> 1;
    let _ = Number.NaN, l2 = Number.NaN, u = true;
    const d2 = this.getMin_(m3), c = this.getMax_(m3);
    let p3 = -1;
    for (; u; ) {
      a2 = h2 + (o - h2 >> 1), p3 = this.calculateDiscriminantIndex1_(h2, o);
      const e6 = this.getDiscriminantFromIndex1_(p3);
      if (c < e6) {
        if (-1 !== i2) {
          if (p3 === this.getDiscriminantIndex1_(i2)) s4 = i2, _ = e6, i2 = this.getLptr_(i2), l2 = -1 !== i2 ? this.getDiscriminant_(i2) : Number.NaN;
          else if (l2 > e6) {
            const t4 = this.createTertiaryNode_(p3);
            e6 < _ ? this.setLptr_(s4, t4) : this.setRptr_(s4, t4), this.setRptr_(t4, i2), this.m_bOfflineDynamic && (this.setPptr_(t4, s4), this.setPptr_(i2, t4)), s4 = t4, _ = e6, i2 = -1, l2 = Number.NaN;
          }
        }
        o = a2;
        continue;
      }
      if (d2 > e6) {
        if (-1 !== i2) {
          if (p3 === this.getDiscriminantIndex1_(i2)) s4 = i2, _ = e6, i2 = this.getRptr_(i2), l2 = -1 !== i2 ? this.getDiscriminant_(i2) : Number.NaN;
          else if (l2 < e6) {
            const t4 = this.createTertiaryNode_(p3);
            e6 < _ ? this.setLptr_(s4, t4) : this.setRptr_(s4, t4), this.setLptr_(t4, i2), this.m_bOfflineDynamic && (this.setPptr_(t4, s4), this.setPptr_(i2, t4)), s4 = t4, _ = e6, i2 = -1, l2 = Number.NaN;
          }
        }
        h2 = a2 + 1;
        continue;
      }
      let m4 = -1;
      m4 = -1 === i2 || p3 !== this.getDiscriminantIndex1_(i2) ? this.createTertiaryNode_(p3) : i2, n6 = this.getSecondaryFromTertiary_(m4), -1 === n6 && (n6 = this.createSecondary_(m4), this.setSecondaryToTertiary_(m4, n6));
      const g2 = this.addEndIndex_(n6, t3);
      r = this.createIntervalNode_(), this.setSecondaryToInterval_(r, n6), this.setLeftEnd_(r, g2), -1 !== i2 && p3 === this.getDiscriminantIndex1_(i2) || (e6 < _ ? this.setLptr_(s4, m4) : this.setRptr_(s4, m4), this.m_bOfflineDynamic && this.setPptr_(m4, s4), -1 !== i2 && (l2 < e6 ? this.setLptr_(m4, i2) : this.setRptr_(m4, i2), this.m_bOfflineDynamic && this.setPptr_(i2, m4))), u = false;
      break;
    }
    return r;
  }
  createTertiaryNode_(t3) {
    const e5 = this.m_tertiaryNodes.newElement();
    return this.setDiscriminantIndex1_(e5, t3), e5;
  }
  createSecondary_(t3) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.createTreap(t3) : this.m_secondaryLists.createList(t3);
  }
  createIntervalNode_() {
    return this.m_intervalNodes.newElement();
  }
  reset() {
    this.m_bOfflineDynamic && this.m_bConstructionEnded || C(""), this.reset_(false, this.m_bEnvelopesRef);
  }
  reset_(t3, e5) {
    t3 ? (this.m_bEnvelopesRef = false, this.m_envelopesRef = null, this.m_bSortIntervals = true, this.m_bConstructing = true, this.m_bConstructionEnded = false, this.m_endIndicesUnique.length = 0, e5 ? (this.m_intervals.length = 0, this.m_bEnvelopesRef = true) : this.m_intervals.length = 0) : this.m_bSortIntervals = false, this.m_bOfflineDynamic ? this.m_secondaryTreaps.clear() : this.m_secondaryLists.clear(), this.m_intervalNodes.deleteAll(false), this.m_tertiaryNodes.deleteAll(false), this.m_root = -1, this.m_cCount = 0;
  }
  getDiscriminant_(t3) {
    const e5 = this.getDiscriminantIndex1_(t3);
    return this.getDiscriminantFromIndex1_(e5);
  }
  getDiscriminantFromIndex1_(t3) {
    if (-1 === t3) return Number.NaN;
    if (t3 > 0) {
      const e6 = t3 - 2, s5 = this.m_endIndicesUnique[e6], i2 = this.m_endIndicesUnique[e6 + 1];
      return 0.5 * (this.getValue_(s5) + this.getValue_(i2));
    }
    const e5 = -t3 - 2, s4 = this.m_endIndicesUnique[e5];
    return this.getValue_(s4);
  }
  calculateDiscriminantIndex1_(t3, e5) {
    let s4;
    if (t3 < e5) {
      s4 = t3 + (e5 - t3 >> 1) + 2;
    } else s4 = -(t3 + 2);
    return s4;
  }
  setDiscriminantIndex1_(t3, e5) {
    this.m_tertiaryNodes.setField(t3, 0, e5);
  }
  setSecondaryToTertiary_(t3, e5) {
    this.m_tertiaryNodes.setField(t3, 1, e5);
  }
  setLptr_(t3, e5) {
    this.m_tertiaryNodes.setField(t3, 2, e5);
  }
  setRptr_(t3, e5) {
    this.m_tertiaryNodes.setField(t3, 3, e5);
  }
  setPptr_(t3, e5) {
    this.m_tertiaryNodes.setField(t3, 4, e5);
  }
  setSecondaryToInterval_(t3, e5) {
    this.m_intervalNodes.setField(t3, 0, e5);
  }
  addEndIndex_(t3, e5) {
    let s4 = -1;
    return s4 = this.m_bOfflineDynamic ? this.m_secondaryTreaps.addElement(e5, t3) : this.m_secondaryLists.addElement(t3, e5), s4;
  }
  setLeftEnd_(t3, e5) {
    this.m_intervalNodes.setField(t3, 1, e5);
  }
  setRightEnd_(t3, e5) {
    this.m_intervalNodes.setField(t3, 2, e5);
  }
  getFirst_(t3) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.getFirst(t3) : this.m_secondaryLists.getFirst(t3);
  }
  getLast_(t3) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.getLast(t3) : this.m_secondaryLists.getLast(t3);
  }
  static isLeft_(t3) {
    return !(1 & t3);
  }
  static isRight_(t3) {
    return !(1 & ~t3);
  }
  getDiscriminantIndex1_(t3) {
    return this.m_tertiaryNodes.getField(t3, 0);
  }
  getSecondaryFromTertiary_(t3) {
    return this.m_tertiaryNodes.getField(t3, 1);
  }
  getLptr_(t3) {
    return this.m_tertiaryNodes.getField(t3, 2);
  }
  getRptr_(t3) {
    return this.m_tertiaryNodes.getField(t3, 3);
  }
  getPptr_(t3) {
    return this.m_tertiaryNodes.getField(t3, 4);
  }
  getSecondaryFromInterval_(t3) {
    return this.m_intervalNodes.getField(t3, 0);
  }
  getLeftEnd_(t3) {
    return this.m_intervalNodes.getField(t3, 1);
  }
  getRightEnd_(t3) {
    return this.m_intervalNodes.getField(t3, 2);
  }
  getMin_(t3) {
    return this.m_bEnvelopesRef ? this.m_envelopesRef[t3].xmin : this.m_intervals[t3].vmin;
  }
  getMax_(t3) {
    return this.m_bEnvelopesRef ? this.m_envelopesRef[t3].xmax : this.m_intervals[t3].vmax;
  }
  sortEndIndices_(t3, e5, s4) {
    const i2 = this, n6 = { userSort(t4, e6, s5) {
      i2.sortEndIndicesHelper_(s5, t4, e6);
    }, getValue: (t4) => i2.getValue_(t4) };
    new ot().sort(t3, e5, s4, n6);
  }
  sortEndIndicesHelper_(t3, e5, s4) {
    t3.sort(e5, s4, (t4, e6) => {
      const s5 = this.getValue_(t4), i2 = this.getValue_(e6);
      return s5 < i2 || s5 === i2 && _ft.isLeft_(t4) && _ft.isRight_(e6) ? -1 : 1;
    });
  }
  getValue_(t3) {
    if (!this.m_bEnvelopesRef) {
      const e6 = this.m_intervals[t3 >> 1];
      return _ft.isLeft_(t3) ? e6.vmin : e6.vmax;
    }
    const e5 = this.m_envelopesRef[t3 >> 1];
    return _ft.isLeft_(t3) ? e5.xmin : e5.xmax;
  }
};
var vt2 = class {
  constructor(t3, e5, s4) {
    this.m_query = x2.constructEmpty(), this.m_tertiaryHandle = -1, this.m_nextTertiaryHandle = -1, this.m_forkedHandle = -1, this.m_currentEndHandle = -1, this.m_nextEndHandle = -1, this.m_tertiaryStack = [], this.m_functionIndex = 0, this.m_intervalTree = t3, this.m_functionStack = new Array(2), this.m_functionStack[0] = this.nullFunc_, this.m_functionStack[1] = this.nullFunc_, void 0 !== e5 && this.resetIterator(e5, s4);
  }
  nullFunc_() {
    return b("should not be called"), false;
  }
  resetIterator(t3, e5) {
    if ("number" == typeof t3) {
      const s4 = new x2();
      s4.setCoords(t3, t3), this.resetIterator(s4, e5);
    } else void 0 === e5 && (e5 = 0), this.m_query.vmin = t3.vmin - e5, this.m_query.vmax = t3.vmax + e5, this.m_tertiaryStack.length = 0, this.m_functionIndex = 0, this.m_functionStack[0] = this.initialize_;
  }
  next() {
    if (this.m_intervalTree.m_bConstructionEnded || C(""), this.m_functionIndex < 0) return -1;
    for (; this.m_fi = this.m_functionStack[this.m_functionIndex], this.m_fi(); ) ;
    return -1 !== this.m_currentEndHandle ? this.getCurrentEndIndex_() >> 1 : -1;
  }
  initialize_() {
    return this.m_tertiaryHandle = -1, this.m_nextTertiaryHandle = -1, this.m_forkedHandle = -1, this.m_currentEndHandle = -1, this.m_intervalTree.m_tertiaryNodes.size() > 0 ? (this.m_functionStack[0] = this.pIn_, this.m_nextTertiaryHandle = this.m_intervalTree.m_root, true) : (this.m_functionIndex = -1, false);
  }
  pIn_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionIndex = -1, this.m_currentEndHandle = -1, false;
    const t3 = this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);
    if (this.m_query.vmax < t3) {
      const t4 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t4 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t4), this.m_functionStack[++this.m_functionIndex] = this.left_), true;
    }
    if (t3 < this.m_query.vmin) {
      const t4 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== t4 && (this.m_nextEndHandle = this.m_intervalTree.getLast_(t4), this.m_functionStack[++this.m_functionIndex] = this.right_), true;
    }
    this.m_functionStack[this.m_functionIndex] = this.pL_, this.m_forkedHandle = this.m_tertiaryHandle;
    const e5 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== e5 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(e5), this.m_functionStack[++this.m_functionIndex] = this.all_), true;
  }
  pL_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionStack[this.m_functionIndex] = this.pR_, this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_forkedHandle), true;
    if (this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle) < this.m_query.vmin) {
      const t4 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== t4 && (this.m_nextEndHandle = this.m_intervalTree.getLast_(t4), this.m_functionStack[++this.m_functionIndex] = this.right_), true;
    }
    const t3 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t3 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t3), this.m_functionStack[++this.m_functionIndex] = this.all_);
    const e5 = this.m_intervalTree.getRptr_(this.m_tertiaryHandle);
    return -1 !== e5 && this.m_tertiaryStack.push(e5), true;
  }
  pR_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionStack[this.m_functionIndex] = this.pT_, true;
    const t3 = this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);
    if (this.m_query.vmax < t3) {
      const t4 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t4 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t4), this.m_functionStack[++this.m_functionIndex] = this.left_), true;
    }
    const e5 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== e5 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(e5), this.m_functionStack[++this.m_functionIndex] = this.all_);
    const s4 = this.m_intervalTree.getLptr_(this.m_tertiaryHandle);
    return -1 !== s4 && this.m_tertiaryStack.push(s4), true;
  }
  pT_() {
    if (0 === this.m_tertiaryStack.length) return this.m_functionIndex = -1, this.m_currentEndHandle = -1, false;
    this.m_tertiaryHandle = this.m_tertiaryStack.at(-1), this.m_tertiaryStack.pop();
    const t3 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    return -1 !== t3 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t3), this.m_functionStack[++this.m_functionIndex] = this.all_), -1 !== this.m_intervalTree.getLptr_(this.m_tertiaryHandle) && this.m_tertiaryStack.push(this.m_intervalTree.getLptr_(this.m_tertiaryHandle)), -1 !== this.m_intervalTree.getRptr_(this.m_tertiaryHandle) && this.m_tertiaryStack.push(this.m_intervalTree.getRptr_(this.m_tertiaryHandle)), true;
  }
  left_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isLeft_(this.getCurrentEndIndex_()) && this.m_intervalTree.getValue_(this.getCurrentEndIndex_()) <= this.m_query.vmax ? (this.m_nextEndHandle = this.getNext_(), false) : (this.m_functionIndex--, true);
  }
  right_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isRight_(this.getCurrentEndIndex_()) && this.m_intervalTree.getValue_(this.getCurrentEndIndex_()) >= this.m_query.vmin ? (this.m_nextEndHandle = this.getPrev_(), false) : (this.m_functionIndex--, true);
  }
  all_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isLeft_(this.getCurrentEndIndex_()) ? (this.m_nextEndHandle = this.getNext_(), false) : (this.m_functionIndex--, true);
  }
  getNext_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getNext(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getNext(this.m_currentEndHandle);
  }
  getPrev_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getPrev(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getPrev(this.m_currentEndHandle);
  }
  getCurrentEndIndex_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getElement(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getData(this.m_currentEndHandle);
  }
};
var yt = class {
  constructor() {
    this.m_tolerance = 0, this.m_sweepIndexRed = -1, this.m_sweepIndexBlue = -1, this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_intervalTreeRed = null, this.m_intervalTreeBlue = null, this.m_iteratorRed = null, this.m_iteratorBlue = null, this.m_envelopesRed = [], this.m_envelopesBlue = [], this.m_elementsRed = [], this.m_elementsBlue = [], this.m_sortedEndIndicesRed = new st2(0), this.m_sortedEndIndicesBlue = new st2(0), this.m_queuedListRed = -1, this.m_queuedListBlue = -1, this.m_queuedEnvelopes = new pt(), this.m_queuedIndicesRed = [], this.m_queuedIndicesBlue = [], this.m_bAddRed = false, this.m_bAddBlue = false, this.m_bAddRedRed = false, this.m_bDone = true, this.m_function = this.nullFunc_, this.reset_();
  }
  startConstruction() {
    this.reset_(), this.m_bAddRedRed = true, this.m_elementsRed.length = 0, this.m_envelopesRed.length = 0;
  }
  addEnvelope(t3, e5) {
    this.m_bAddRedRed || C(""), this.m_elementsRed.push(t3), this.m_envelopesRed.push(new n4(e5));
  }
  endConstruction() {
    this.m_bAddRedRed || C(""), this.m_bAddRedRed = false, this.m_envelopesRed.length > 0 && (this.m_function = this.initialize_, this.m_bDone = false);
  }
  startRedConstruction() {
    this.reset_(), this.m_bAddRed = true, this.m_elementsRed.length = 0, this.m_envelopesRed.length = 0;
  }
  addRedEnvelope(t3, e5) {
    this.m_bAddRed || C(""), this.m_elementsRed.push(t3), this.m_envelopesRed.push(e5.clone());
  }
  endRedConstruction() {
    this.m_bAddRed || C(""), this.m_bAddRed = false, this.m_envelopesRed.length > 0 && this.m_envelopesBlue.length > 0 && (this.m_function === this.nullFunc_ || this.m_function === this.initializeBlue_ ? this.m_function = this.initializeRedBlue_ : this.m_function !== this.initializeRedBlue_ && (this.m_function = this.initializeRed_), this.m_bDone = false);
  }
  startBlueConstruction() {
    this.reset_(), this.m_bAddBlue = true, this.m_elementsBlue.length = 0, this.m_envelopesBlue.length = 0;
  }
  addBlueEnvelope(t3, e5) {
    this.m_bAddBlue || C(""), this.m_elementsBlue.push(t3), this.m_envelopesBlue.push(e5.clone());
  }
  endBlueConstruction() {
    this.m_bAddBlue || C(""), this.m_bAddBlue = false, this.m_envelopesRed.length > 0 && this.m_envelopesBlue.length > 0 && (this.m_function === this.nullFunc_ || this.m_function === this.initializeRed_ ? this.m_function = this.initializeRedBlue_ : this.m_function !== this.initializeRedBlue_ && (this.m_function = this.initializeBlue_), this.m_bDone = false);
  }
  next() {
    if (this.m_bDone) return false;
    for (; this.m_function(); ) ;
    return !this.m_bDone;
  }
  getHandleA() {
    return this.m_envelopeHandleA;
  }
  getHandleB() {
    return this.m_envelopeHandleB;
  }
  setTolerance(t3) {
    this.m_tolerance = t3;
  }
  getElement(t3) {
    return this.m_elementsRed[t3];
  }
  getRedEnvelope(t3) {
    return this.m_envelopesRed[t3];
  }
  getBlueEnvelope(t3) {
    return this.m_envelopesBlue[t3];
  }
  getRedElement(t3) {
    return this.m_elementsRed[t3];
  }
  getBlueElement(t3) {
    return this.m_elementsBlue[t3];
  }
  isTop_(t3) {
    return !(1 & ~t3);
  }
  isBottom_(t3) {
    return !(1 & t3);
  }
  reset_() {
    this.m_bAddRed = false, this.m_bAddBlue = false, this.m_bAddRedRed = false, this.m_sweepIndexRed = -1, this.m_sweepIndexBlue = -1, this.m_queuedListRed = -1, this.m_queuedListBlue = -1, this.m_bDone = true;
  }
  initialize_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), this.m_sortedEndIndicesRed.resize(0);
    for (let t3 = 0; t3 < 2 * this.m_envelopesRed.length; t3++) this.m_sortedEndIndicesRed.add(t3);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, 2 * this.m_envelopesRed.length, true), this.m_sweepIndexRed = 2 * this.m_envelopesRed.length, this.m_function = this.sweep_, true;
  }
  initializeRed_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), this.m_sortedEndIndicesRed.resize(0);
    for (let t3 = 0; t3 < 2 * this.m_envelopesRed.length; t3++) this.m_sortedEndIndicesRed.add(t3);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, this.m_sortedEndIndicesRed.size(), true), this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), this.m_function = this.sweepRedBlue_, this.resetBlue_();
  }
  initializeBlue_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeBlue || (this.m_intervalTreeBlue = new ft2(true)), this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue), null == this.m_iteratorBlue && (this.m_iteratorBlue = this.m_intervalTreeBlue.getIterator()), this.m_sortedEndIndicesBlue.resize(0);
    for (let t3 = 0; t3 < 2 * this.m_envelopesBlue.length; t3++) this.m_sortedEndIndicesBlue.add(t3);
    return this.sortYEndIndices_(this.m_sortedEndIndicesBlue, 0, this.m_sortedEndIndicesBlue.size(), false), this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_function = this.sweepRedBlue_, this.resetRed_();
  }
  initializeRedBlue_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeBlue || (this.m_intervalTreeBlue = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), null === this.m_iteratorBlue && (this.m_iteratorBlue = this.m_intervalTreeBlue.getIterator()), this.m_sortedEndIndicesRed.resize(0), this.m_sortedEndIndicesBlue.resize(0);
    for (let t3 = 0; t3 < 2 * this.m_envelopesRed.length; t3++) this.m_sortedEndIndicesRed.add(t3);
    for (let t3 = 0; t3 < 2 * this.m_envelopesBlue.length; t3++) this.m_sortedEndIndicesBlue.add(t3);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, this.m_sortedEndIndicesRed.size(), true), this.sortYEndIndices_(this.m_sortedEndIndicesBlue, 0, this.m_sortedEndIndicesBlue.size(), false), this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_function = this.sweepRedBlue_, true;
  }
  sweep_() {
    const t3 = this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed), e5 = t3 >> 1;
    if (this.isBottom_(t3)) return this.m_intervalTreeRed.remove(e5), 0 !== this.m_sweepIndexRed || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    const s4 = x2.construct(this.m_envelopesRed[e5].xmin, this.m_envelopesRed[e5].xmax);
    return this.m_iteratorRed.resetIterator(s4, this.m_tolerance), this.m_envelopeHandleA = e5, this.m_function = this.iterate_, true;
  }
  sweepBruteForce_() {
    return -1 === --this.m_sweepIndexRed ? (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false) : (this.m_envelopeHandleA = this.m_sweepIndexRed, this.m_sweepIndexBlue = this.m_sweepIndexRed, this.m_function = this.iterateBruteForce_, true);
  }
  sweepRedBlueBruteForce_() {
    return -1 === --this.m_sweepIndexRed ? (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false) : (this.m_envelopeHandleA = this.m_sweepIndexRed, this.m_sweepIndexBlue = this.m_envelopesBlue.length, this.m_function = this.iterateRedBlueBruteForce_, true);
  }
  sweepRedBlue_() {
    const t3 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed - 1), e5 = this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue - 1), s4 = this.getAdjustedValue_(t3, true), i2 = this.getAdjustedValue_(e5, false);
    return s4 > i2 ? this.sweepRed_() : s4 < i2 ? this.sweepBlue_() : this.isTop_(t3) ? this.sweepRed_() : this.isTop_(e5) ? this.sweepBlue_() : this.sweepRed_();
  }
  sweepRed_() {
    const t3 = this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed), e5 = t3 >> 1;
    if (this.isBottom_(t3)) return -1 !== this.m_queuedListRed && -1 !== this.m_queuedIndicesRed[e5] ? (this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed, this.m_queuedIndicesRed[e5]), this.m_queuedIndicesRed[e5] = -1) : this.m_intervalTreeRed.remove(e5), 0 !== this.m_sweepIndexRed || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    if (-1 !== this.m_queuedListBlue && this.m_queuedEnvelopes.getListSize(this.m_queuedListBlue) > 0) {
      let t4 = this.m_queuedEnvelopes.getFirst(this.m_queuedListBlue);
      for (; -1 !== t4; ) {
        const e6 = this.m_queuedEnvelopes.getData(t4);
        this.m_intervalTreeBlue.insert(e6), this.m_queuedIndicesBlue[e6] = -1;
        const s4 = this.m_queuedEnvelopes.getNext(t4);
        this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue, t4), t4 = s4;
      }
    }
    if (this.m_intervalTreeBlue.size() > 0) {
      const t4 = x2.construct(this.m_envelopesRed[e5].xmin, this.m_envelopesRed[e5].xmax);
      this.m_iteratorBlue.resetIterator(t4, this.m_tolerance), this.m_envelopeHandleA = e5, this.m_function = this.iterateBlue_;
    } else -1 === this.m_queuedListRed && (Ft(this.m_queuedIndicesRed, this.m_envelopesRed.length, -1), this.m_queuedListRed = this.m_queuedEnvelopes.createList(1)), this.m_queuedIndicesRed[e5] = this.m_queuedEnvelopes.addElement(this.m_queuedListRed, e5), this.m_function = this.sweepRedBlue_;
    return true;
  }
  sweepBlue_() {
    const t3 = this.m_sortedEndIndicesBlue.read(--this.m_sweepIndexBlue), e5 = t3 >> 1;
    if (this.isBottom_(t3)) return -1 !== this.m_queuedListBlue && -1 !== this.m_queuedIndicesBlue[e5] ? (this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue, this.m_queuedIndicesBlue[e5]), this.m_queuedIndicesBlue[e5] = -1) : this.m_intervalTreeBlue.remove(e5), 0 !== this.m_sweepIndexBlue || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    if (-1 !== this.m_queuedListRed && this.m_queuedEnvelopes.getListSize(this.m_queuedListRed) > 0) {
      let t4 = this.m_queuedEnvelopes.getFirst(this.m_queuedListRed);
      for (; -1 !== t4; ) {
        const e6 = this.m_queuedEnvelopes.getData(t4);
        this.m_intervalTreeRed.insert(e6), this.m_queuedIndicesRed[e6] = -1;
        const s4 = this.m_queuedEnvelopes.getNext(t4);
        this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed, t4), t4 = s4;
      }
    }
    if (this.m_intervalTreeRed.size() > 0) {
      const t4 = x2.construct(this.m_envelopesBlue[e5].xmin, this.m_envelopesBlue[e5].xmax);
      this.m_iteratorRed.resetIterator(t4, this.m_tolerance), this.m_envelopeHandleB = e5, this.m_function = this.iterateRed_;
    } else -1 === this.m_queuedListBlue && (Ft(this.m_queuedIndicesBlue, this.m_envelopesBlue.length, -1), this.m_queuedListBlue = this.m_queuedEnvelopes.createList(0)), this.m_queuedIndicesBlue[e5] = this.m_queuedEnvelopes.addElement(this.m_queuedListBlue, e5), this.m_function = this.sweepRedBlue_;
    return true;
  }
  iterate_() {
    if (this.m_envelopeHandleB = this.m_iteratorRed.next(), -1 !== this.m_envelopeHandleB) return false;
    const t3 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed) >> 1;
    return this.m_intervalTreeRed.insert(t3), this.m_function = this.sweep_, true;
  }
  iterateRed_() {
    if (this.m_envelopeHandleA = this.m_iteratorRed.next(), -1 !== this.m_envelopeHandleA) return false;
    this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1;
    const t3 = this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue) >> 1;
    return this.m_intervalTreeBlue.insert(t3), this.m_function = this.sweepRedBlue_, true;
  }
  iterateBlue_() {
    if (this.m_envelopeHandleB = this.m_iteratorBlue.next(), -1 !== this.m_envelopeHandleB) return false;
    const t3 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed) >> 1;
    return this.m_intervalTreeRed.insert(t3), this.m_function = this.sweepRedBlue_, true;
  }
  iterateBruteForce_() {
    if (-1 === --this.m_sweepIndexBlue) return this.m_function = this.sweepBruteForce_, true;
    const t3 = this.m_envelopesRed[this.m_sweepIndexRed].clone(), e5 = this.m_envelopesRed[this.m_sweepIndexBlue];
    return t3.inflateCoords(this.m_tolerance, this.m_tolerance), !t3.isIntersecting(e5) || (this.m_envelopeHandleB = this.m_sweepIndexBlue, false);
  }
  iterateRedBlueBruteForce_() {
    if (-1 === --this.m_sweepIndexBlue) return this.m_function = this.sweepRedBlueBruteForce_, true;
    const t3 = this.m_envelopesRed[this.m_sweepIndexRed].clone(), e5 = this.m_envelopesBlue[this.m_sweepIndexBlue];
    return t3.inflateCoords(this.m_tolerance, this.m_tolerance), !t3.isIntersecting(e5) || (this.m_envelopeHandleB = this.m_sweepIndexBlue, false);
  }
  resetRed_() {
    return this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), this.m_intervalTreeRed.size() > 0 && this.m_intervalTreeRed.reset(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), this.m_bDone = false, true;
  }
  resetBlue_() {
    return this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), this.m_intervalTreeBlue.size() > 0 && this.m_intervalTreeBlue.reset(), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_bDone = false, true;
  }
  nullFunc_() {
    return b("should not be called"), false;
  }
  sortYEndIndices_(t3, e5, s4, i2) {
    const n6 = this, r = { userSort(t4, e6, s5) {
      n6.sortYEndIndicesHelper_(s5, t4, e6, i2);
    }, getValue: (t4) => n6.getAdjustedValue_(t4, i2) };
    new ot().sort(t3, e5, s4, r);
  }
  sortYEndIndicesHelper_(t3, e5, s4, i2) {
    t3.sort(e5, s4, (t4, e6) => {
      const s5 = this.getAdjustedValue_(t4, i2), n6 = this.getAdjustedValue_(e6, i2);
      return s5 < n6 || s5 === n6 && this.isBottom_(t4) && this.isTop_(e6) ? -1 : 1;
    });
  }
  getAdjustedValue_(t3, e5) {
    const s4 = 0.5 * this.m_tolerance;
    if (e5) {
      const e6 = this.m_envelopesRed[t3 >> 1];
      return this.isBottom_(t3) ? e6.ymin - s4 : e6.ymax + s4;
    }
    const i2 = this.m_envelopesBlue[t3 >> 1];
    return this.isBottom_(t3) ? i2.ymin - s4 : i2.ymax + s4;
  }
};
var xt = z3;
var Et2 = class _Et {
  constructor(t3, e5) {
    this.tolerance = void 0 !== t3 ? t3 : Number.NaN, this.resolution = void 0 !== e5 ? e5 : Number.NaN;
  }
  add(t3) {
    return new _Et(this.tolerance + t3, this.resolution);
  }
  scale(t3) {
    return new _Et(this.tolerance * t3, this.resolution * t3);
  }
  total() {
    return this.tolerance + this.resolution;
  }
};
function bt(t3, e5, i2, n6, r) {
  const h2 = n6 * n6, o = t3.sub(e5), a2 = i2.sub(e5), m3 = o.sqrLength(), _ = a2.sqrLength();
  if (m3 <= h2 || _ <= h2) return true;
  const l2 = H(o.crossProduct(a2));
  if (l2 <= h2 * m3 || l2 <= h2 * _) {
    return o.dotProduct(a2) >= 0;
  }
  return false;
}
function Nt(t3, e5, s4) {
  return (i2) => 0 === s4 ? (i2 + t3) * e5 : 1 * (i2 - t3 * e5) / e5;
}
function Dt2(t3, e5) {
  const s4 = new n4();
  return t3.queryLooseEnvelope(s4), s4.mergeEnvelope2D(e5), s4;
}
function It2(t3, e5) {
  const s4 = n4.constructEmpty();
  t3.queryLooseEnvelope(s4);
  const i2 = n4.constructEmpty();
  return e5.queryLooseEnvelope(i2), s4.mergeEnvelope2D(i2), s4;
}
function Ct2(t3, e5) {
  return (Number.isFinite(t3) || Number.isNaN(t3)) && (Number.isFinite(e5) || Number.isNaN(e5));
}
function Tt(t3, e5) {
  return Number.isFinite(t3) && Number.isFinite(e5);
}
function Rt2(t3, e5, s4) {
  const i2 = n4.constructEmpty();
  i2.setFromPoints(t3, e5);
  return St2(0, null, i2.calculateToleranceFromEnvelope(), s4, false);
}
function At(t3, e5, s4) {
  return St2(0, t3, e5.calculateToleranceFromEnvelope(), s4, false);
}
function qt2(t3, e5, s4) {
  return St2(1, t3, e5.calculateToleranceFromEnvelope(), s4, false);
}
function wt2(t3, e5, s4) {
  return qt2(t3, e5.queryInterval(1, 0), s4);
}
function Bt2(t3, e5, s4) {
  const i2 = n4.constructEmpty();
  return e5.queryEnvelope(i2), At(t3, i2, s4);
}
function zt2(t3, e5, s4 = false) {
  return St2(0, t3, e5.calculateToleranceFromEnvelope(), s4, true).total();
}
function Lt2(t3, e5, s4) {
  const i2 = n4.constructEmpty();
  return e5.queryEnvelope(i2), zt2(t3, i2, s4);
}
function St2(t3, e5, s4, i2, n6) {
  const r = new Et2(0, 0);
  if (null !== e5 && (r.tolerance = e5.getTolerance(t3), (!n6 || i2) && null !== e5)) {
    const s5 = e5.getResolution(t3);
    r.resolution = s5, i2 && (r.resolution *= 2);
  }
  i2 && (s4 *= 4, r.tolerance *= 1.01, r.resolution *= 1.01);
  return r.total() < s4 ? new Et2(s4, 0) : r;
}
function Ft2(t3) {
  return Math.sqrt(2) * (2 * t3.tolerance + t3.resolution);
}
function Pt2(t3) {
  return Math.sqrt(2) * (t3.tolerance + t3.resolution);
}
function Ht2(t3) {
  return t3 >= 3;
}
function Vt2(t3, e5) {
  const s4 = [0];
  return t3.getImpl().getIsSimple(e5, s4) >= 3;
}
function kt2(t3, e5) {
  t3.getImpl().setIsSimple(3, e5);
}
function Mt(t3, e5, n6, r) {
  if (H(e5.x - t3.x) + H(e5.y - t3.y) <= n6 * n6) {
    const s4 = t3.z, n7 = e5.z;
    return cs(s4, n7, r);
  }
  return false;
}
function Ot2(t3) {
  return t3 >= 4;
}
function Yt2(t3, e5) {
  return t3 === a.enumPolygon ? Ht2(e5) : e5 >= 1;
}
function Xt2(t3, e5, s4) {
  const i2 = n4.constructEmpty(), n6 = n4.constructEmpty();
  t3.queryLooseEnvelope(i2), e5.queryLooseEnvelope(n6), i2.inflateCoords(s4, s4), n6.inflateCoords(s4, s4);
  const r = n4.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n6);
  const h2 = t3.querySegmentIterator(), o = e5.querySegmentIterator(), a2 = n4.constructEmpty(), m3 = n4.constructEmpty(), _ = new yt();
  _.setTolerance(s4);
  let l2 = false;
  for (_.startRedConstruction(); h2.nextPath(); ) for (; h2.hasNextSegment(); ) {
    h2.nextSegment().queryLooseEnvelope(a2), a2.isIntersecting(r) && (l2 = true, _.addRedEnvelope(h2.getStartPointIndex(), a2));
  }
  if (_.endRedConstruction(), !l2) return null;
  let u = false;
  for (_.startBlueConstruction(); o.nextPath(); ) for (; o.hasNextSegment(); ) {
    o.nextSegment().queryLooseEnvelope(m3), m3.isIntersecting(r) && (u = true, _.addBlueEnvelope(o.getStartPointIndex(), m3));
  }
  return _.endBlueConstruction(), u ? _ : null;
}
function Gt2(t3, e5, s4, i2, n6) {
  t3.getGeometryType(), e5.getGeometryType();
  const r = n4.constructEmpty(), h2 = n4.constructEmpty();
  t3.queryLooseEnvelope(r), e5.queryLooseEnvelope(h2), r.inflateCoords(s4, s4), h2.inflateCoords(s4, s4);
  const o = n4.constructEmpty();
  o.setCoords({ env2D: r }), o.intersect(h2);
  const a2 = new yt();
  a2.setTolerance(s4);
  let m3 = false;
  a2.startRedConstruction();
  for (let l2 = 0, u = t3.getPathCount(); l2 < u; l2++) t3.queryLoosePathEnvelope(l2, r), r.isIntersecting(o) && (m3 = true, a2.addRedEnvelope(l2, r));
  if (a2.endRedConstruction(), !m3) return null;
  let _ = false;
  a2.startBlueConstruction();
  for (let l2 = 0, u = e5.getPathCount(); l2 < u; l2++) e5.queryLoosePathEnvelope(l2, h2), h2.isIntersecting(o) && (_ = true, a2.addBlueEnvelope(l2, h2));
  return a2.endBlueConstruction(), _ ? a2 : null;
}
function Ut2(t3, e5, s4) {
  const i2 = n4.constructEmpty(), n6 = n4.constructEmpty();
  t3.queryLooseEnvelope(i2), e5.queryEnvelope(n6), i2.inflateCoords(s4, s4), n6.inflateCoords(s4, s4);
  const r = n4.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n6);
  const h2 = t3.querySegmentIterator(), o = new yt();
  o.setTolerance(s4);
  let a2 = false;
  for (o.startRedConstruction(); h2.nextPath(); ) for (; h2.hasNextSegment(); ) {
    h2.nextSegment().queryLooseEnvelope(i2), i2.isIntersecting(r) && (a2 = true, o.addRedEnvelope(h2.getStartPointIndex(), i2));
  }
  if (o.endRedConstruction(), !a2) return null;
  let m3 = false;
  o.startBlueConstruction();
  for (let _ = 0, l2 = e5.getPointCount(); _ < l2; _++) {
    const t4 = e5.getXY(_);
    r.contains(t4) && (m3 = true, o.addBlueEnvelope(_, n4.construct(t4.x, t4.y, t4.x, t4.y)));
  }
  return o.endBlueConstruction(), m3 ? o : null;
}
function Zt2(t3, e5, s4) {
  const i2 = n4.constructEmpty(), n6 = n4.constructEmpty();
  t3.queryEnvelope(i2), e5.queryEnvelope(n6), i2.inflateCoords(s4, s4), n6.inflateCoords(s4, s4);
  const r = n4.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n6);
  const h2 = new yt();
  h2.setTolerance(s4);
  let a2 = false;
  h2.startRedConstruction();
  const m3 = new mi();
  for (let o = 0, u = t3.getPointCount(); o < u; o++) t3.queryXY(o, m3), r.contains(m3) && (a2 = true, h2.addRedEnvelope(o, n4.construct(m3.x, m3.y, m3.x, m3.y)));
  if (h2.endRedConstruction(), !a2) return null;
  let _ = false;
  h2.startBlueConstruction();
  const l2 = new mi();
  for (let o = 0, u = e5.getPointCount(); o < u; o++) e5.queryXY(o, l2), r.contains(l2) && (_ = true, h2.addBlueEnvelope(o, n4.construct(l2.x, l2.y, l2.x, l2.y)));
  return h2.endBlueConstruction(), _ ? h2 : null;
}
function Qt2(t3) {
  const e5 = new n4();
  return t3.queryLooseEnvelope(e5), e5.inflateCoords(1, 1), jt2(t3, e5);
}
function jt2(t3, e5, s4) {
  const i2 = new n4();
  if (t3.queryLooseEnvelope(i2), i2.isEmpty()) return null;
  t3.getGeometryType();
  const n6 = new _t2(i2, 8);
  let r = -1;
  const h2 = new n4();
  let o = false;
  do {
    for (let s5 = 0, a2 = t3.getPathCount(); s5 < a2; s5++) if (t3.queryLoosePathEnvelope(s5, h2), h2.isIntersecting(e5)) {
      if (r = n6.insertEx(s5, h2, r), -1 === r) {
        o && b("build_quad_tree_for_paths"), i2.assign(t3.calculateEnvelope2D(false)), o = true, n6.reset(i2, 8);
        break;
      }
      o = false;
    }
  } while (o);
  return n6;
}
function Wt2(t3, e5) {
  if (!e5) {
    const e6 = new n4();
    t3.queryLooseEnvelope(e6);
    const s5 = new _t2(e6, 8);
    let i3 = -1;
    const n7 = new n4(), r2 = t3.querySegmentIterator();
    let h3 = false;
    for (; r2.nextPath(); ) for (; r2.hasNextSegment(); ) {
      const o2 = r2.nextSegment(), a2 = r2.getStartPointIndex();
      if (o2.queryLooseEnvelope(n7), i3 = s5.insertEx(a2, n7, i3), -1 === i3) {
        h3 && b(""), e6.assign(t3.calculateEnvelope2D(false)), h3 = true, s5.reset(e6, 8), r2.resetToFirstPath();
        break;
      }
    }
    return s5;
  }
  const s4 = new n4();
  t3.queryLooseEnvelope(s4);
  const i2 = new _t2(s4, 8);
  let n6 = -1;
  const r = new n4(), h2 = t3.querySegmentIterator();
  let o = false;
  for (; h2.nextPath(); ) for (; h2.hasNextSegment(); ) {
    const a2 = h2.nextSegment(), m3 = h2.getStartPointIndex();
    if (a2.queryLooseEnvelope(r), r.isIntersecting(e5) && (n6 = i2.insertEx(m3, r, n6), -1 === n6)) {
      o && b(""), s4.assign(t3.calculateEnvelope2D(false)), o = true, i2.reset(s4, 8), h2.resetToFirstPath();
      break;
    }
  }
  return i2;
}
function Jt2(t3, e5) {
  if (e5) {
    const s4 = new _t2(e5, 8), i2 = new mi(), n6 = new n4();
    let r = false;
    for (let h2 = 0; h2 < t3.getPointCount(); h2++) {
      if (i2.setCoordsPoint2D(t3.getXY(h2)), !e5.contains(i2)) continue;
      n6.setCoords({ pt: i2 });
      -1 !== s4.insert(h2, n6) || (r && b(""), r = true, s4.reset(t3.calculateEnvelope2D(), 8), h2 = -1);
    }
    return s4;
  }
  return z("no-extent version not yet impl"), null;
}
function Kt2(t3, e5, s4, i2, n6) {
  let r = false;
  const h2 = n6.vmin, o = n6.vmax;
  for (let a2 = s4; a2 < e5; a2 += i2) {
    const e6 = t3.read(a2);
    e6 < h2 ? (r = true, t3.write(a2, h2)) : e6 > o && (r = true, t3.write(a2, o));
  }
  return r;
}
function $t2(t3, e5, s4, i2) {
  if (!t3.hasAttribute(s4)) return false;
  const n6 = t3.getGeometryType();
  if (n6 === a.enumGeometryCollection) {
    const n7 = t3, r = n7.getGeometryCount();
    let h2 = 0;
    for (let t4 = 0; t4 < r; ++t4) {
      h2 |= $t2(n7.getGeometry(t4), e5, s4, i2) ? 1 : 0;
    }
    return !!h2;
  }
  if (y(n6)) {
    const n7 = t3, r = xt.getPersistence(s4), h2 = xt.getComponentCount(s4), o = n7.getPointCount();
    if (1 === r) {
      const t4 = Kt2(n7.getAttributeStreamRef(s4), o * h2, i2, h2, e5);
      return t4 && n7.notifyModified(), t4;
    }
    if (2 === r) {
      const t4 = Kt2(n7.getAttributeStreamRef(s4), o * h2, i2, h2, e5);
      return t4 && n7.notifyModified(), t4;
    }
    b("snap_coordinate not implemented");
  }
  if (n6 === a.enumEnvelope) {
    const n7 = t3, r = n7.queryInterval(s4, i2);
    let h2 = false;
    return r.vmin < e5.vmin && (h2 = true, r.vmin = e5.vmin), r.vmax > e5.vmax && (h2 = true, r.vmax = e5.vmax), h2 && n7.setIntervalEnvelope(s4, i2, r), h2;
  }
  if (n6 === a.enumPoint) {
    const n7 = t3;
    let r = n7.getAttributeAsDbl(s4, i2), h2 = false;
    return r < e5.vmin && (h2 = true, r = e5.vmin), r > e5.vmax && (h2 = true, r = e5.vmax), h2 && n7.setAttributeBasic(s4, i2, r), h2;
  }
  if (f(n6)) {
    const n7 = t3;
    let r = n7.getStartAttributeAsDbl(s4, i2), h2 = false;
    return r < e5.vmin && (h2 = true, r = e5.vmin), r > e5.vmax && (h2 = true, r = e5.vmax), h2 && n7.setStartAttribute(s4, i2, r), r = n7.getEndAttributeAsDbl(s4, i2), r < e5.vmin && (h2 = true, r = e5.vmin), r > e5.vmax && (h2 = true, r = e5.vmax), h2 && n7.setEndAttribute(s4, i2, r), h2;
  }
  b("snap_coordinate not implemented");
}
var te = z3;
var ee = class _ee {
  constructor(t3) {
    if (this.m_description = null, this.x = Number.NaN, this.y = Number.NaN, this.m_attribs = null, t3) {
      if (!t3.copy) return t3.move ? (this.m_description = t3.move.m_description, t3.move.m_description = null, this.m_attribs = t3.move.m_attribs, t3.move.m_attribs = null, this.x = t3.move.x, void (this.y = t3.move.y)) : t3.vd ? (this.m_description = t3.vd, void (t3.attribBuffer ? (this.m_attribs = t3.attribBuffer, t3.initDefaultValues && this.setDefaultAttributeValues()) : this.ensureAttributes())) : t3.pt ? (this.m_description = M(), void this.setXY(t3.pt)) : void ("x" in t3 && ("z" in t3 ? (this.m_description = O2(), this.ensureAttributes(), this.setXYZ(new X(t3.x, t3.y, t3.z))) : (this.m_description = M(), this.setXYCoords(t3.x, t3.y))));
      t3.copy.copyTo(this);
    } else this.m_description = M();
  }
  assignCopy(t3) {
    return this.m_attribs = null, t3.copyTo(this), this;
  }
  assignMove(t3) {
    return this.m_attribs = null, t3.copyTo(this), t3.setEmpty(), this;
  }
  getXY() {
    return new mi(this.x, this.y);
  }
  queryXY(t3) {
    t3.x = this.x, t3.y = this.y;
  }
  setXY(t3) {
    this.x = t3.x, this.y = t3.y;
  }
  setXYCoords(t3, e5) {
    this.x = t3, this.y = e5;
  }
  getXYZ() {
    const t3 = new X();
    return t3.x = this.x, t3.y = this.y, t3.z = this.getZ(), t3;
  }
  setXYZ(t3) {
    this.addAttribute(1), this.x = t3.x, this.y = t3.y, this.m_attribs[0] = t3.z;
  }
  getX() {
    return this.x;
  }
  setX(t3) {
    this.x = t3;
  }
  getY() {
    return this.y;
  }
  setY(t3) {
    this.y = t3;
  }
  getZ() {
    return this.m_description.hasZ() ? this.m_attribs[0] : te.getDefaultValue(1);
  }
  setZ(t3) {
    this.addAttribute(1), this.m_attribs[0] = t3;
  }
  getM() {
    return this.getAttributeAsDbl(2, 0);
  }
  setM(t3) {
    this.addAttribute(2), this.m_description.hasZ() ? this.m_attribs[1] = t3 : this.m_attribs[0] = t3;
  }
  getID() {
    return this.getAttributeAsInt(3, 0);
  }
  setID(t3) {
    this.setAttributeBasic(3, 0, t3);
  }
  isEqualXY(t3, e5) {
    return void 0 === e5 && (e5 = 0), Math.abs(t3.x - this.x) <= e5 && Math.abs(t3.y - this.y) <= e5;
  }
  isEqualXYCoords(t3, e5, s4) {
    return void 0 === s4 && (s4 = 0), Math.abs(t3 - this.x) <= s4 && Math.abs(e5 - this.y) <= s4;
  }
  getAttributeAsDbl(t3, e5) {
    if (0 === t3) {
      if (0 === e5) return this.x;
      if (1 === e5) return this.y;
      A("");
    }
    const s4 = te.getComponentCount(t3);
    (e5 < 0 || e5 >= s4) && A("");
    const i2 = this.m_description.getAttributeIndex(t3);
    return i2 >= 0 ? this.m_attribs[this.m_description.getPointAttributeOffset(i2) - 2 + e5] : te.getDefaultValue(t3);
  }
  getAttributeAsInt(t3, e5) {
    return Math.trunc(this.getAttributeAsDbl(t3, e5));
  }
  setAttributeBasic(t3, e5, s4) {
    if (0 === t3) return void (0 === e5 ? this.x = s4 : 1 === e5 ? this.y = s4 : A(""));
    const i2 = te.getComponentCount(t3);
    (e5 < 0 || e5 >= i2) && A("");
    let n6 = this.m_description.getAttributeIndex(t3);
    n6 < 0 && (this.addAttribute(t3), n6 = this.m_description.getAttributeIndex(t3)), this.m_attribs[this.m_description.getPointAttributeOffset(n6) - 2 + e5] = s4;
  }
  copyAttributesFrom(t3, e5) {
    if (this === t3) return;
    const s4 = t3.getDescription();
    for (let i2 = e5 && s4.hasZ() ? 2 : 1, n6 = s4.getAttributeCount(); i2 < n6; ++i2) {
      const e6 = s4.getSemantics(i2), n7 = te.getComponentCount(e6);
      for (let s5 = 0; s5 < n7; ++s5) {
        const i3 = t3.getAttributeAsDbl(e6, s5);
        this.setAttributeBasic(e6, s5, i3);
      }
    }
  }
  getAttributeArray() {
    return this.m_attribs;
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t3) {
    this.m_description !== t3 && this.assignVertexDescriptionImpl(t3);
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e5 = V2(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e5 = k3(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  getGeometryType() {
    return a.enumPoint;
  }
  getDimension() {
    return 0;
  }
  queryEnvelope(t3) {
    if (t3 instanceof re) return t3.setEmpty(), t3.assignVertexDescription(this.m_description), void t3.merge(this);
    if (t3 instanceof G3) {
      if (this.isEmpty()) return void t3.setEmpty();
      const e5 = this.getXYZ();
      return t3.xmin = e5.x, t3.ymin = e5.y, t3.zmin = e5.z, t3.xmax = e5.x, t3.ymax = e5.y, void (t3.zmax = e5.z);
    }
    this.isEmpty() ? t3.setEmpty() : (t3.xmin = this.x, t3.ymin = this.y, t3.xmax = this.x, t3.ymax = this.y);
  }
  queryLooseEnvelope(t3) {
    this.queryEnvelope(t3);
  }
  queryInterval(t3, e5) {
    const s4 = new x2();
    if (this.isEmpty()) return s4.setEmpty(), s4;
    const i2 = this.getAttributeAsDbl(t3, e5);
    return s4.vmin = i2, s4.vmax = i2, s4;
  }
  applyTransformation(t3) {
    if (!this.isEmpty()) {
      if (1 === t3.m_TransformationType) {
        const e5 = this.getXY();
        return t3.transformInPlace(e5), void this.setXY(e5);
      }
      z("3d not impl");
    }
  }
  transformAttribute(t3, e5, s4, i2, n6) {
    if (this.isEmpty()) return;
    this.addAttribute(t3);
    const r = this.getAttributeAsDbl(t3, e5), h2 = Nt(s4, i2, n6);
    this.setAttributeBasic(t3, e5, h2(r));
  }
  createInstance() {
    return new _ee({ vd: this.m_description });
  }
  copyTo(t3) {
    if (this === t3) return;
    t3.getGeometryType() !== a.enumPoint && P();
    const e5 = t3;
    e5.x = this.x, e5.y = this.y, this.m_attribs ? (e5.assignVertexDescription(this.m_description), e5.m_attribs = this.m_attribs.slice()) : (e5.releaseAttributes(), e5.assignVertexDescription(this.m_description));
  }
  isEmpty() {
    return Number.isNaN(this.x) || Number.isNaN(this.y);
  }
  setEmpty() {
    this.m_description || (this.m_description = M(), this.releaseAttributes()), this.x = Number.NaN, this.y = Number.NaN, this.m_attribs && Dt(this.m_attribs, this.m_description.getDefaultPointAttributes(), 0, 2, this.m_description.getTotalComponentCount() - 2);
  }
  calculateArea2D() {
    return 0;
  }
  calculateLength2D() {
    return 0;
  }
  calculateLength3D(t3) {
    return 0;
  }
  equals(t3, e5) {
    if (t3 === this) return true;
    if (t3.getGeometryType() !== a.enumPoint) return false;
    const s4 = t3;
    if (this.m_description !== s4.m_description) return false;
    if (this.isEmpty() !== s4.isEmpty()) return false;
    if (this.isEmpty()) return true;
    if (void 0 === e5 && (e5 = 0), Math.abs(this.x - s4.x) > e5) return false;
    if (Math.abs(this.y - s4.y) > e5) return false;
    for (let n6 = 0, r = this.m_description.getTotalComponentCount() - 2; n6 < r; n6++) if (!cs(this.m_attribs[n6], s4.m_attribs[n6], e5)) return false;
    return true;
  }
  getBoundary() {
    return null;
  }
  clone() {
    const t3 = new _ee({ vd: this.m_description });
    return this.copyTo(t3), t3;
  }
  swap(t3) {
    if (this === t3) return;
    t3.getGeometryType() !== a.enumPoint && P("wrong geometry type");
    const e5 = t3;
    e5.m_description = Pt(this.m_description, this.m_description = e5.m_description), e5.x = Pt(this.x, this.x = e5.x), e5.y = Pt(this.y, this.y = e5.y), e5.m_attribs = Pt(this.m_attribs, this.m_attribs = e5.m_attribs);
  }
  replaceNaNs(t3, e5) {
    if (this.addAttribute(t3), this.isEmpty()) return;
    const s4 = te.getComponentCount(t3);
    for (let i2 = 0; i2 < s4; i2++) {
      const s5 = this.getAttributeAsDbl(t3, i2);
      Number.isNaN(s5) && this.setAttributeBasic(t3, i2, e5);
    }
  }
  lerp(t3, e5, s4) {
    if (t3.getDescription() !== e5.getDescription() && P("Point.lerp"), this.assignVertexDescription(t3.getDescription()), t3.isEmpty() || e5.isEmpty()) return this.setEmpty(), this;
    this.ensureAttributes();
    const i2 = B3();
    t3.queryValues(i2, i2.length);
    const n6 = B3();
    e5.queryValues(n6, n6.length);
    const r = B3();
    let h2 = i2, o = n6;
    const a2 = r;
    let m3 = 0;
    for (let l2 = 0, u = this.m_description.getAttributeCount(); l2 < u; l2++) {
      const t4 = this.m_description.getSemantics(l2), e6 = te.getInterpolation(t4), i3 = te.getComponentCount(t4), n7 = te.getDefaultValue(t4);
      wt(e6, h2, o, a2, m3, i3, s4, n7), h2 = h2.slice(i3), o = o.slice(i3), m3 += i3;
    }
    return this.setValues(r, m3), this;
  }
  static lerp(t3, e5, s4, i2) {
    i2.lerp(t3, e5, s4);
  }
  setDefaultAttributeValues() {
    const t3 = this.m_description.getTotalComponentCount() - 2;
    t3 > 0 && (this.m_attribs ? Dt(this.m_attribs, this.m_description.getDefaultPointAttributes(), 0, 2, t3) : this.m_attribs = this.m_description.getDefaultPointAttributes().slice(2));
  }
  static sqrDistance2D(t3, e5) {
    return mi.sqrDistanceCoords(t3.x, t3.y, e5.x, e5.y);
  }
  getImpl() {
    return this;
  }
  mergeVertexDescriptionImpl(t3) {
    const e5 = H2(this.getDescription(), t3);
    this.assignVertexDescription(e5);
  }
  releaseAttributes() {
    this.m_attribs = null;
  }
  assignVertexDescriptionImpl(t3) {
    this.m_description || (this.m_description = M());
    const e5 = S2();
    Y2(t3, this.m_description, e5);
    let s4 = null;
    t3.getTotalComponentCount() - 2 > 0 && (s4 = t3.getDefaultPointAttributes().slice(2));
    for (let i2 = 1, n6 = t3.getAttributeCount(); i2 < n6; i2++) {
      const n7 = e5[i2];
      if (-1 !== n7) {
        const e6 = this.m_description.getPointAttributeOffset(n7) - 2, r = t3.getPointAttributeOffset(i2) - 2, h2 = te.getComponentCount(t3.getSemantics(i2));
        for (let t4 = 0; t4 < h2; t4++) s4[r + t4] = this.m_attribs[e6 + t4];
      }
    }
    this.m_attribs = s4, this.m_description = t3;
  }
  ensureAttributes() {
    this.m_description.getTotalComponentCount() - 2 > 0 && null === this.m_attribs && (this.m_attribs = this.m_description.getDefaultPointAttributes().slice(2));
  }
  queryValues(t3, e5) {
    const s4 = this.m_description.getTotalComponentCount();
    n2(s4 <= e5), t3[0] = this.x, t3[1] = this.y, Dt(t3, this.m_attribs, 2, 0, s4 - 2);
  }
  copyCommonAttributesTo(t3) {
    t3.x = this.x, t3.y = this.y;
    const e5 = t3.getDescription();
    if (e5 === this.m_description) this.m_attribs && Dt(t3.m_attribs, this.m_attribs, 0, 0, this.m_description.getTotalComponentCount() - 2);
    else {
      let s4 = 0;
      for (let i2 = 1, n6 = e5.getAttributeCount(); i2 < n6; i2++) {
        const n7 = e5.getSemantics(i2);
        let r = te.getComponentCount(n7);
        if (this.m_description.hasAttribute(n7)) {
          let e6 = this.m_description.getPointAttributeOffset(this.m_description.getAttributeIndex(n7)) - 2;
          for (; 0 !== r; ) t3.m_attribs[s4++] = this.m_attribs[e6++], r--;
        } else {
          const e6 = te.getDefaultValue(n7);
          for (; 0 !== r; ) t3.m_attribs[s4++] = e6, r--;
        }
      }
    }
  }
  setValues(t3, e5) {
    const s4 = this.m_description.getTotalComponentCount();
    n2(s4 <= e5), this.x = t3[0], this.y = t3[1], Dt(this.m_attribs, t3, 0, 2, s4 - 2);
  }
  dbgDefaultAttribs() {
  }
};
ee.type = a.enumPoint;
var se = z3;
function ie(t3, e5) {
  return e5 * (t3.getTotalComponentCount() - 2);
}
var ne = class {
  constructor(t3) {
    if (this.m_attributes = null, t3) if (void 0 !== t3.xmin) this.m_envelope2D = new n4(t3.xmin, t3.ymin, t3.xmax, t3.ymax);
    else if (void 0 !== t3.env2D) this.m_envelope2D = new n4(t3.env2D);
    else if (t3.move) this.m_envelope2D = new n4(t3.move.m_envelope2D), this.m_attributes = t3.move.m_attributes, t3.move.m_attributes = null;
    else {
      if (!t3.moveEnv) throw new Error("unrecognized EnvelopeData constructor options");
      {
        const e5 = t3.moveEnv.accessEnvelopeData();
        this.m_envelope2D = new n4(e5.m_envelope2D), this.m_attributes = e5.m_attributes, e5.m_attributes = null;
      }
    }
    else this.m_envelope2D = n4.constructEmpty();
  }
  ensureAttributes(t3) {
    const s4 = t3.getTotalComponentCount() - 2;
    !this.m_attributes && s4 && (this.m_attributes = Yt(2 * s4, Number.NaN), this.m_attributes.fill(Number.NaN));
  }
  copyTo(t3, s4) {
    const i2 = s4, n6 = t3.getTotalComponentCount() - 2;
    if (i2.m_description !== t3 && (i2.releaseAttributes_(), i2.m_description = t3, n6 && (i2.m_data.m_attributes = Yt(2 * n6, Number.NaN))), n6) {
      n2(this.m_attributes && i2.m_data.m_attributes);
      const t4 = 2 * n6;
      Dt(i2.m_data.m_attributes, this.m_attributes, 0, 0, t4);
    }
    i2.m_data.m_envelope2D = new n4(this.m_envelope2D);
  }
  copyToIfNotNull(t3, e5) {
    e5.m_envelope2D = new n4(this.m_envelope2D), e5.releaseAttributes();
    t3.getTotalComponentCount() - 2 && this.m_attributes && (e5.m_attributes = this.m_attributes.slice());
  }
  releaseAttributes() {
    this.m_attributes = null;
  }
  isEmpty() {
    return this.m_envelope2D.isEmpty();
  }
  transformAttribute(t3, e5, s4, i2, n6) {
    n2(0);
  }
  queryInterval(t3, e5, s4, i2) {
    if (this.isEmpty()) return void i2.setEmpty();
    if (0 === e5) return void (0 === s4 ? this.m_envelope2D.queryIntervalX(i2) : 1 === s4 ? this.m_envelope2D.queryIntervalY(i2) : A(""));
    const n6 = se.getComponentCount(e5);
    (s4 < 0 || s4 >= n6) && A("");
    const r = t3.getAttributeIndex(e5);
    if (r >= 0) return i2.vmin = this.m_attributes[ie(t3, 0) + t3.getPointAttributeOffset(r) - 2 + s4], void (i2.vmax = this.m_attributes[ie(t3, 1) + t3.getPointAttributeOffset(r) - 2 + s4]);
    {
      const t4 = se.getDefaultValue(e5);
      return void i2.setCoords(t4, t4);
    }
  }
  queryEnvelope3D(t3, e5) {
    const s4 = new x2();
    this.queryInterval(t3, 1, 0, s4), e5.setCoords(this.m_envelope2D.xmin, this.m_envelope2D.ymin, s4.vmin, this.m_envelope2D.xmax, this.m_envelope2D.ymax, s4.vmax);
  }
  setEmpty(t3) {
    this.m_envelope2D.setEmpty();
    const s4 = t3.getTotalComponentCount() - 2;
    s4 && (this.m_attributes ? this.dbgAssertSize(s4) : this.m_attributes = Yt(2 * s4, Number.NaN), this.m_attributes.fill(Number.NaN));
  }
  dbgAssertSize(t3) {
  }
};
var re = class t2 {
  constructor(t3) {
    if (this.m_EnvelopeType = 4, this.m_description = M(), void 0 === t3) this.m_data = new ne();
    else if (void 0 !== t3.vd) this.m_description = t3.vd, this.m_data = new ne(), this.ensureAttributes_();
    else if (t3?.env2D) this.m_data = new ne({ env2D: t3.env2D });
    else if (void 0 !== t3.xmin) this.m_data = new ne({ xmin: t3.xmin, ymin: t3.ymin, xmax: t3.xmax, ymax: t3.ymax });
    else if (t3.copy) this.m_data = new ne(), t3.copy.copyTo(this);
    else if (t3.move) this.m_description = t3.move.m_description, t3.move.m_description = null, this.m_data = new ne({ move: t3.move.m_data });
    else {
      if (!t3.centerPoint) throw new Error("unrecognized Envelope constructor options");
      this.m_description = t3.centerPoint.getDescription(), this.m_data = new ne(), this.ensureAttributes_(), this.setFromPoint(t3.centerPoint, t3.width, t3.height);
    }
  }
  accessEnvelopeData() {
    return this.m_description = null, this.m_data;
  }
  assignMove(t3) {
    return this === t3 || (this.m_description = t3.m_description, t3.m_description = null, this.m_data = new ne({ move: t3.m_data })), this;
  }
  assignCopy(t3) {
    return this === t3 || t3.copyTo(this), this;
  }
  transformAttribute(t3, e5, s4, i2, n6) {
    n2(0);
  }
  setAttributeBasic(t3, e5, s4) {
    if (this.addAttribute(t3), this.m_data.isEmpty()) return;
    const i2 = this.queryInterval(t3, e5);
    i2.vmin = s4, i2.vmax = s4, this.setIntervalEnvelope(t3, e5, i2);
  }
  mergeVertexDescriptionImpl(t3) {
    const e5 = H2(this.getDescription(), t3);
    this.assignVertexDescription(e5);
  }
  asEnvelope2D() {
    return new n4(this.m_data.m_envelope2D);
  }
  assignVertexDescription(t3) {
    this.m_description !== t3 && this.assignVertexDescriptionImpl(t3);
  }
  getGeometryType() {
    return a.enumEnvelope;
  }
  getDimension() {
    return 2;
  }
  getXMin() {
    return this.m_data.m_envelope2D.xmin;
  }
  getYMin() {
    return this.m_data.m_envelope2D.ymin;
  }
  getXMax() {
    return this.m_data.m_envelope2D.xmax;
  }
  getYMax() {
    return this.m_data.m_envelope2D.ymax;
  }
  width() {
    return this.m_data.isEmpty() ? Number.NaN : this.m_data.m_envelope2D.width();
  }
  height() {
    return this.m_data.isEmpty() ? Number.NaN : this.m_data.m_envelope2D.height();
  }
  getCenterXY() {
    return this.m_data.isEmpty() ? new mi() : this.m_data.m_envelope2D.getCenter();
  }
  getCenter(t3) {
    if (t3.assignVertexDescription(this.m_description), this.m_data.isEmpty()) return void t3.setEmpty();
    const e5 = this.m_description.getAttributeCount();
    for (let s4 = 1; s4 < e5; s4++) {
      const e6 = this.m_description.getSemantics(s4), i2 = se.getComponentCount(e6);
      for (let s5 = 0; s5 < i2; s5++) {
        const i3 = 0.5 * (this.getAttributeAsDblImpl(0, e6, s5) + this.getAttributeAsDblImpl(1, e6, s5));
        t3.setAttributeBasic(e6, s5, i3);
      }
    }
    t3.setXY(this.m_data.m_envelope2D.getCenter());
  }
  setCoords(t3, e5, s4, i2) {
    this.m_data.m_envelope2D.setCoords({ xmin: t3, ymin: e5, xmax: s4, ymax: i2 });
  }
  setEnvelope(t3) {
    if (t3 instanceof n4) this.m_data.m_envelope2D = new n4(t3), this.m_data.m_envelope2D.normalize();
    else {
      this.addAttribute(1), this.m_data.m_envelope2D = t3.getEnvelope2D(), this.m_data.m_envelope2D.normalize();
      const e5 = x2.constructEmpty();
      e5.setCoords(t3.zmin, t3.zmax), this.setInterval(1, 0, e5.vmin, e5.vmax);
    }
  }
  merge(e5) {
    if (e5 instanceof n4) return e5.isValid() || P(""), void this.m_data.m_envelope2D.mergeEnvelope2D(e5);
    if (e5 instanceof t2) {
      if (e5.m_data.isEmpty()) return;
      const t3 = e5.getDescription();
      this.mergeVertexDescription(t3), this.m_data.m_envelope2D.mergeEnvelope2D(e5.m_data.m_envelope2D);
      for (let s4 = 1, i2 = t3.getAttributeCount(); s4 < i2; s4++) {
        const i3 = t3.getSemantics(s4), n6 = se.getComponentCount(i3);
        for (let t4 = 0; t4 < n6; t4++) {
          const s5 = e5.queryInterval(i3, t4), n7 = this.queryInterval(i3, t4);
          n7.merge(s5), this.setIntervalEnvelope(i3, t4, n7);
        }
      }
    } else if (e5 instanceof ee) {
      const t3 = e5;
      if (t3.isEmpty()) return;
      const s4 = t3.getDescription();
      if (this.mergeVertexDescription(s4), this.m_data.isEmpty()) return void this.setFromPoint(t3);
      this.m_data.m_envelope2D.merge(t3.getXY());
      for (let e6 = 1, i2 = s4.getAttributeCount(); e6 < i2; e6++) {
        const i3 = s4.getSemantics(e6), n6 = se.getComponentCount(i3);
        for (let e7 = 0; e7 < n6; e7++) {
          const s5 = t3.getAttributeAsDbl(i3, e7), n7 = this.queryInterval(i3, e7);
          n7.mergeCoordinate(s5), this.setIntervalEnvelope(i3, e7, n7);
        }
      }
    } else z("unrecognized type for envelope.merge");
  }
  intersect(t3) {
    if (!this.m_data.m_envelope2D.intersect(t3.m_data.m_envelope2D)) return this.setEmpty(), false;
    const e5 = t3.getDescription();
    this.mergeVertexDescription(e5);
    for (let s4 = 1, i2 = this.m_description.getAttributeCount(); s4 < i2; s4++) {
      const e6 = this.m_description.getSemantics(s4), i3 = se.getComponentCount(e6);
      for (let s5 = 0; s5 < i3; s5++) {
        const i4 = t3.queryInterval(e6, s5), n6 = this.queryInterval(e6, s5);
        n6.intersect(i4), this.setIntervalEnvelope(e6, s5, n6);
      }
    }
    return true;
  }
  intersectCommonAttributes(t3) {
    if (!this.m_data.m_envelope2D.intersect(t3.m_data.m_envelope2D)) return this.setEmpty(), false;
    const e5 = t3.getDescription();
    for (let s4 = 1, i2 = this.m_description.getAttributeCount(); s4 < i2; s4++) {
      const i3 = this.m_description.getSemantics(s4);
      if (!e5.hasAttribute(i3)) continue;
      const n6 = se.getComponentCount(i3);
      for (let e6 = 0; e6 < n6; e6++) {
        const s5 = t3.queryInterval(i3, e6), n7 = this.queryInterval(i3, e6);
        n7.intersect(s5), this.setIntervalEnvelope(i3, e6, n7);
      }
    }
    return true;
  }
  move(t3, e5) {
    this.m_data.m_envelope2D.move(t3, e5);
  }
  centerAt(t3, e5) {
    this.m_data.m_envelope2D.centerAtCoords(t3, e5);
  }
  centerAtPoint(t3) {
    this.m_data.m_envelope2D.centerAt(t3);
  }
  reaspect(t3, e5) {
    this.m_data.m_envelope2D.reaspect(t3, e5);
  }
  inflateCoords(t3, e5) {
    this.m_data.m_envelope2D.inflateCoords(t3, e5);
  }
  containsCoords(t3, e5) {
    return this.m_data.m_envelope2D.containsCoords(t3, e5);
  }
  contains(t3) {
    return this.m_data.m_envelope2D.contains(t3);
  }
  containsPoint(t3) {
    return !t3.isEmpty() && this.m_data.m_envelope2D.contains(t3.getXY());
  }
  containsEnvelope(t3) {
    return this.m_data.m_envelope2D.containsEnvelope(t3.m_data.m_envelope2D);
  }
  setIntervalEnvelope(t3, e5, s4) {
    if (this.addAttribute(t3), this.m_data.isEmpty()) return;
    const i2 = new x2(s4);
    if (i2.normalize(), 0 === t3) {
      if (i2.isEmpty()) return void this.setEmpty();
      0 === e5 ? (this.m_data.m_envelope2D.xmin = i2.vmin, this.m_data.m_envelope2D.xmax = i2.vmax) : 1 === e5 ? (this.m_data.m_envelope2D.ymin = i2.vmin, this.m_data.m_envelope2D.ymax = i2.vmax) : A("");
    } else this.setAttributeAsDblImpl(0, t3, e5, i2.vmin), this.setAttributeAsDblImpl(1, t3, e5, i2.vmax);
  }
  setInterval(t3, e5, s4, i2) {
    this.setIntervalEnvelope(t3, e5, new x2(s4, i2));
  }
  queryInterval(t3, e5) {
    const s4 = new x2();
    return this.m_data.queryInterval(this.m_description, t3, e5, s4), s4;
  }
  queryEnvelope(t3) {
    2 !== t3.m_EnvelopeType ? 3 !== t3.m_EnvelopeType ? 4 !== t3.m_EnvelopeType ? z("unrecognized type for queryEnveloper") : this.copyTo(t3) : this.m_data.queryEnvelope3D(this.m_description, t3) : t3.setCoords({ env2D: this.m_data.m_envelope2D });
  }
  applyTransformation(t3) {
    1 !== t3.m_TransformationType ? n2(0) : t3.transformEnvInPlace(this.m_data.m_envelope2D);
  }
  createInstance() {
    return new t2({ vd: this.m_description });
  }
  copyTo(t3) {
    t3 !== this && this.m_data.copyTo(this.m_description, t3);
  }
  isEmpty() {
    return this.m_data.isEmpty();
  }
  setEmpty() {
    this.m_description || (this.m_description = M()), this.m_data.setEmpty(this.m_description);
  }
  calculateArea2D() {
    return this.m_data.m_envelope2D.getArea();
  }
  calculateLength2D() {
    return this.m_data.m_envelope2D.getLength();
  }
  calculateLength3D(t3) {
    return n2(0), 0;
  }
  equals(t3, e5) {
    if (t3 === this) return true;
    const s4 = t3;
    if (this.m_description !== s4.m_description) return false;
    if (this.m_data.isEmpty() !== s4.m_data.isEmpty()) return false;
    if (this.m_data.isEmpty()) return true;
    if (void 0 === e5 && (e5 = 0), Math.abs(this.m_data.m_envelope2D.xmin - s4.m_data.m_envelope2D.xmin) > e5) return false;
    if (Math.abs(this.m_data.m_envelope2D.ymin - s4.m_data.m_envelope2D.ymin) > e5) return false;
    if (Math.abs(this.m_data.m_envelope2D.xmax - s4.m_data.m_envelope2D.xmax) > e5) return false;
    if (Math.abs(this.m_data.m_envelope2D.ymax - s4.m_data.m_envelope2D.ymax) > e5) return false;
    for (let n6 = 0, r = 2 * (this.m_description.getTotalComponentCount() - 2); n6 < r; n6++) if (!cs(this.m_data.m_attributes[n6], s4.m_data.m_attributes[n6], e5)) return false;
    return true;
  }
  getBoundary() {
    return z("getBoundary not available in this context. Use the boundary operator with an envelope parameter"), null;
  }
  clone() {
    return new t2({ copy: this });
  }
  swap(t3) {
    if (this === t3) return;
    t3.getGeometryType() !== a.enumEnvelope && P("wrong geometry type");
    const e5 = t3;
    e5.m_description = Pt(this.m_description, this.m_description = e5.m_description), e5.m_data.m_envelope2D = Pt(this.m_data.m_envelope2D, this.m_data.m_envelope2D = e5.m_data.m_envelope2D), e5.m_data.m_attributes = Pt(this.m_data.m_attributes, this.m_data.m_attributes = e5.m_data.m_attributes);
  }
  queryCoordinates(t3) {
    this.m_data.isEmpty() && P(""), this.m_data.m_envelope2D.queryCorners(t3);
  }
  queryCornerByVal(t3, e5) {
    (t3 < 0 || t3 > 3) && A(""), e5.assignVertexDescription(this.m_description);
    const s4 = this.getDescription().getAttributeCount();
    for (let i2 = 1; i2 < s4; i2++) {
      const s5 = this.m_description.getSemantics(i2), n6 = se.getComponentCount(s5);
      for (let i3 = 0; i3 < n6; i3++) e5.setAttributeBasic(s5, i3, this.getAttributeAsDblImpl(t3 % 2, s5, i3));
    }
    e5.setXY(this.m_data.m_envelope2D.queryCorner(t3));
  }
  queryCorner(t3, e5) {
    e5.assign(this.m_data.m_envelope2D.queryCorner(t3));
  }
  getDescription() {
    return this.m_description;
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description && this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e5 = V2(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e5 = k3(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  queryLooseEnvelope(t3) {
    this.queryEnvelope(t3);
  }
  replaceNaNs(t3, e5) {
    if (this.addAttribute(t3), this.m_data.isEmpty()) return;
    const s4 = se.getComponentCount(t3);
    for (let i2 = 0; i2 < s4; i2++) {
      const s5 = this.queryInterval(t3, i2);
      s5.isEmpty() && (s5.vmin = e5, s5.vmax = e5, this.setIntervalEnvelope(t3, i2, s5));
    }
  }
  getImpl() {
    return this;
  }
  setFromPoint(t3, e5, s4) {
    this.m_data.m_envelope2D.setCoords({ center: t3.getXY(), width: e5 ?? 0, height: s4 ?? 0 });
    const i2 = t3.getDescription();
    for (let n6 = 1, r = i2.getAttributeCount(); n6 < r; n6++) {
      const e6 = i2.getSemantics(n6), s5 = se.getComponentCount(e6);
      for (let i3 = 0; i3 < s5; i3++) {
        const s6 = t3.getAttributeAsDbl(e6, i3);
        this.setInterval(e6, i3, s6, s6);
      }
    }
  }
  assignVertexDescriptionImpl(t3) {
    const s4 = S2();
    Y2(t3, this.m_description, s4);
    let i2 = null;
    const n6 = t3.getTotalComponentCount() - 2, r = this.m_description ? this.m_description.getTotalComponentCount() - 2 : 0;
    n6 > 0 && (i2 = Yt(2 * n6, Number.NaN));
    for (let e5 = 1; e5 < t3.getAttributeCount(); e5++) {
      const h2 = s4[e5];
      if (-1 !== h2) {
        const s5 = t3.getPointAttributeOffset(e5) - 2, o = se.getComponentCount(t3.getSemantics(e5)), a2 = this.m_description.getPointAttributeOffset(h2) - 2;
        Dt(i2, this.m_data.m_attributes, s5, a2, o), Dt(i2, this.m_data.m_attributes, n6 + s5, r + a2, o);
      }
    }
    this.releaseAttributes_(), this.m_data.m_attributes = i2, this.m_description = t3;
  }
  getAttributeAsDblImpl(t3, e5, s4) {
    if (this.m_data.isEmpty() && x(""), 0 === e5) return t3 ? s4 ? this.m_data.m_envelope2D.ymax : this.m_data.m_envelope2D.xmax : s4 ? this.m_data.m_envelope2D.ymin : this.m_data.m_envelope2D.xmin;
    s4 >= se.getComponentCount(e5) && A("");
    const i2 = this.m_description.getAttributeIndex(e5);
    return i2 >= 0 ? this.m_data.m_attributes[ie(this.m_description, t3) + this.m_description.getPointAttributeOffset(i2) - 2 + s4] : z3.getDefaultValue(e5);
  }
  setAttributeAsDblImpl(t3, e5, s4, i2) {
    0 === e5 && (t3 ? 1 === s4 ? this.m_data.m_envelope2D.ymax = i2 : 0 === s4 ? this.m_data.m_envelope2D.xmax = i2 : A("") : 1 === s4 ? this.m_data.m_envelope2D.ymin = i2 : 0 === s4 ? this.m_data.m_envelope2D.xmin = i2 : A(""));
    const n6 = se.getComponentCount(e5);
    (s4 < 0 || s4 >= n6) && A(""), this.addAttribute(e5);
    const r = this.m_description.getAttributeIndex(e5);
    this.m_data.m_attributes[ie(this.m_description, t3) + this.m_description.getPointAttributeOffset(r) - 2 + s4] = i2;
  }
  releaseAttributes_() {
    this.m_data.releaseAttributes();
  }
  ensureAttributes_() {
    this.m_data.ensureAttributes(this.m_description);
  }
};
re.type = a.enumEnvelope;
var he = Object.freeze(Object.defineProperty({ __proto__: null, Envelope: re, EnvelopeData: ne }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/MultiPathImpl.js
var ge = class {
  constructor() {
    this.posStream = null, this.streams = null;
  }
  get(t3) {
    return t3 > 0 ? this.streams[t3 - 1] : this.posStream;
  }
  set(t3, e5) {
    t3 > 0 ? this.streams[t3 - 1] = e5 : this.posStream = e5;
  }
  destroyAndSetSize(t3) {
    if (this.streams = null, t3 > 1) {
      this.streams = new Array(t3 - 1);
      for (let e5 = 0; e5 < t3 - 1; ++e5) this.streams[e5] = null;
    }
    this.posStream = null;
  }
  swap(t3) {
    [this.streams, t3.streams] = [t3.streams, this.streams], [this.posStream, t3.posStream] = [t3.posStream, this.posStream];
  }
  empty() {
    return null === this.posStream && null === this.streams;
  }
};
function de(t3, s4, n6, i2, r) {
  (s4 < 0 || n6 < 0 || i2 < 1 || s4 + i2 * (n6 - 1) + 1 > t3.size()) && P("Index out of bound");
  for (let e5 = s4, o = s4 + i2 * (n6 - 1) + 1; e5 < o; e5 += i2) t3.writeAsDbl(e5, r(t3.readAsDbl(e5)));
}
function _e(t3, e5, s4) {
  if (t3) for (let n6 = e5.length - 1; n6 >= 0; --n6) s4(e5[n6]);
  else e5.forEach(s4);
}
function pe(t3, e5) {
  let s4 = Ss(t3);
  const n6 = e5.length / ds();
  for (let i2 = 0; i2 < e5.length; ++i2) {
    const t4 = Math.trunc(s4 * n6);
    s4 = Ss(s4);
    const i3 = Math.trunc(s4 * n6), r = e5[t4];
    e5[t4] = e5[i3], e5[i3] = r;
  }
}
function Ce(t3, e5, s4) {
  const n6 = t3.getDescription().getTotalComponentCount();
  t3.setX(e5[0]), t3.setY(e5[1]), Dt(t3.getAttributeArray(), e5, 0, 2, n6 - 2);
}
var ve = z3;
var be = "can not assign an empty point to a vertex";
var Se = class {
  constructor(t3) {
    if (this.m_accelerators = null, void 0 !== t3 && t3.move) this.m_description = t3.move.m_description, t3.move.m_description = M(), this.m_vertexAttributes = t3.move.m_vertexAttributes, t3.move.m_vertexAttributes = new ge(), this.m_envelopeData = t3.move.m_envelopeData, t3.move.m_envelopeData = new ne(), this.m_pointCount = t3.move.m_pointCount, this.m_reservedPointCount = t3.move.m_reservedPointCount, this.m_flags = t3.move.m_flags, this.m_bFillRule = t3.move.m_bFillRule, this.m_bPathStarted = t3.move.m_bPathStarted, this.m_bPolygon = t3.move.m_bPolygon, this.m_simpleTolerance = t3.move.m_simpleTolerance;
    else {
      const e5 = void 0 !== t3 && t3.vd ? t3.vd : M();
      this.m_description = e5, this.m_vertexAttributes = new ge(), this.m_envelopeData = new ne(), this.m_pointCount = 0, this.m_reservedPointCount = -1, this.m_flags = 4063, this.m_bFillRule = this.m_bPathStarted = this.m_bPolygon = false, this.m_simpleTolerance = 0, void 0 !== t3 && t3.copy && t3.copy.copyTo(this);
    }
  }
  equalsBase(e5, s4) {
    if (!y(e5.getGeometryType())) return false;
    const n6 = e5;
    if (this === n6) return true;
    if (!this.m_description.equals(n6.getDescription())) return false;
    if (this.isEmptyImpl() !== n6.isEmptyImpl()) return false;
    if (this.isEmptyImpl()) return true;
    const i2 = this.getPointCount();
    if (i2 !== n6.getPointCount()) return false;
    for (let t3 = 0; t3 < this.m_description.getAttributeCount(); t3++) {
      const e6 = this.m_description.getSemantics(t3), r = this.getAttributeStreamRef(e6), o = n6.getAttributeStreamRef(e6), a2 = ve.getComponentCount(e6);
      if (!r.equals(o, 0, i2 * a2, s4)) return false;
    }
    if (s4) {
      if (!this.equalsImplTol(e5, s4)) return false;
    } else if (!this.equalsImpl(e5)) return false;
    return true;
  }
  transformAttribute(t3, s4, n6, i2, r) {
    if (this.addAttribute(t3), !this.isEmpty() && (0 !== n6 || 1 !== i2)) {
      if (0 === t3) {
        const t4 = new x3();
        return 0 === r ? 0 === s4 ? (t4.setShiftCoords(n6, 0), t4.scale(i2, 1)) : 1 === s4 ? (t4.setShiftCoords(0, n6), t4.scale(1, i2)) : P("") : 0 === s4 ? (t4.setScaleCoords(1 / i2, 1), t4.shiftCoords(-n6, 0)) : 1 === s4 ? (t4.setScaleCoords(1, 1 / i2), t4.shiftCoords(0, -n6)) : P(""), void this.applyTransformation(t4);
      }
      de(this.getAttributeStreamRef(t3), s4, this.getPointCount(), ve.getComponentCount(t3), Nt(n6, i2, r)), this.notifyModified();
    }
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t3) {
    this.m_description !== t3 && this.assignVertexDescriptionImpl(t3);
  }
  mergeVertexDescriptionImpl(t3) {
    const e5 = this.getDescription(), s4 = H2(e5, t3);
    this.assignVertexDescription(s4);
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e5 = V2(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e5 = k3(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  getAttributeStreamRef(t3) {
    this.throwIfEmpty(), this.m_description.hasAttribute(t3) || P("AttributeStream : Geometry does not have the attribute");
    const s4 = this.m_description.getAttributeIndex(t3);
    return this.m_vertexAttributes.get(s4);
  }
  setAttributeStreamRef(t3, s4) {
    s4 || P("stream"), s4 && ve.getPersistence(t3) !== s4.getPersistence() && P(""), this.addAttribute(t3);
    const n6 = this.m_description.getAttributeIndex(t3);
    this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), this.m_vertexAttributes.set(n6, s4), this.notifyModifiedFlags(2001);
  }
  notifyModifiedFlags(t3) {
    65535 === t3 && (this.m_reservedPointCount = -1, this.notifyModifiedAllImpl()), this.setDirtyFlagProtected(t3, true), this.clearAccelerators(), 32 & t3 && this.verifyAllStreamsAfterSizeChange();
  }
  notifyModified() {
    this.notifyModifiedFlags(2001);
  }
  getPointCount() {
    return this.m_pointCount;
  }
  getPointByVal(t3, e5) {
    const s4 = e5;
    s4.assignVertexDescription(this.m_description);
    for (let n6 = 0; n6 < this.m_description.getAttributeCount(); n6++) {
      const e6 = this.m_description.getSemantics(n6);
      for (let i2 = 0, r = ve.getComponentCount(e6); i2 < r; i2++) {
        const o = this.m_vertexAttributes.get(n6).readAsDbl(r * t3 + i2);
        s4.setAttributeBasic(e6, i2, o);
      }
    }
  }
  setPointByValNoCurves(t3, s4) {
    const n6 = s4;
    n6.isEmpty() && P(be);
    const i2 = n6.getDescription();
    i2 !== this.m_description && this.mergeVertexDescription(i2);
    const r = this.m_vertexAttributes.get(0);
    r.write(2 * t3, n6.getX()), r.write(2 * t3 + 1, n6.getY());
    for (let e5 = 1, o = this.m_description.getAttributeCount(); e5 < o; e5++) {
      const s5 = this.m_description.getSemantics(e5), i3 = ve.getComponentCount(s5);
      for (let r2 = 0; r2 < i3; r2++) {
        const o2 = n6.getAttributeAsDbl(s5, r2);
        this.m_vertexAttributes.get(e5).writeAsDbl(t3 * i3 + r2, o2);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  setPointByValFromArrayNoCurves(t3, e5, n6, i2) {
    n2(0);
  }
  getPointByValAsArray(t3, e5, n6, i2) {
    n2(0);
  }
  isEmpty() {
    return this.isEmptyImpl();
  }
  isEmptyImpl() {
    return 0 === this.m_pointCount;
  }
  getAttributeAsDbl(t3, e5, s4) {
    const i2 = ve.getComponentCount(t3);
    s4 >= i2 && A("");
    const r = this.m_description.getAttributeIndex(t3);
    return r >= 0 ? this.m_vertexAttributes.get(r).readAsDbl(e5 * i2 + s4) : ve.getDefaultValue(t3);
  }
  queryAttributeAsDbl(t3, e5, s4, i2) {
    const r = ve.getComponentCount(t3);
    i2 < r && A("");
    const o = this.m_description.getAttributeIndex(t3);
    if (o >= 0) {
      const t4 = e5 * r, n6 = this.m_vertexAttributes.get(o);
      for (let e6 = 0; e6 < r; e6++) s4[e6] = n6.readAsDbl(t4 + e6);
    } else {
      const e6 = ve.getDefaultValue(t3);
      for (let t4 = 0; t4 < r; t4++) s4[t4] = e6;
    }
  }
  getAttributeAsInt(t3, e5, s4) {
    return Math.trunc(this.getAttributeAsDbl(t3, e5, s4));
  }
  queryAttributeAsInt(t3, e5, n6, i2) {
    n2(0);
  }
  setAttributeNoCurves(t3, e5, s4, i2) {
    const r = ve.getComponentCount(t3);
    s4 >= r && A(""), this.addAttribute(t3);
    const o = this.m_description.getAttributeIndex(t3);
    this.notifyModifiedFlags(2001), this.m_vertexAttributes.get(o).writeAsDbl(e5 * r + s4, i2);
  }
  setAttributeFromArrayNoCurves(t3, e5, s4, i2) {
    (e5 < 0 || e5 >= this.m_pointCount) && A("");
    const r = ve.getComponentCount(t3);
    i2 < r && A(""), this.addAttribute(t3);
    const o = this.m_description.getAttributeIndex(t3);
    this.notifyModifiedFlags(2001);
    const a2 = this.m_vertexAttributes.get(o);
    for (let n6 = 0; n6 < r; ++n6) a2.writeAsDbl(e5 * r + n6, s4[n6]);
  }
  getXY(t3) {
    return this.m_vertexAttributes.get(0).readPoint2D(2 * t3);
  }
  queryXY(t3, e5) {
    return this.m_vertexAttributes.get(0).queryPoint2D(2 * t3, e5);
  }
  setXYNoCurves(t3, e5) {
    this.m_vertexAttributes.get(0).writePoint2D(2 * t3, e5), this.notifyModifiedFlags(2001);
  }
  setXYCoordsNoCurves(t3, e5, s4) {
    const n6 = this.m_vertexAttributes.get(0);
    n6.write(2 * t3, e5), n6.write(2 * t3 + 1, s4), this.notifyModifiedFlags(2001);
  }
  getXYZ(t3) {
    const e5 = this.m_vertexAttributes.get(0), s4 = X.getNAN();
    return s4.x = e5.read(2 * t3), s4.y = e5.read(2 * t3 + 1), this.m_description.hasAttribute(1) ? s4.z = this.m_vertexAttributes.get(1).read(t3) : s4.z = ve.getDefaultValue(1), s4;
  }
  setXYZNoCurves(t3, e5) {
    this.addAttribute(1), this.notifyModifiedFlags(2001);
    const s4 = this.m_vertexAttributes.get(0);
    s4.write(2 * t3, e5.x), s4.write(2 * t3 + 1, e5.y);
    this.m_vertexAttributes.get(1).write(t3, e5.z);
  }
  queryEnvelope(t3) {
    t3 instanceof n4 || t3 instanceof G3 ? this.updateEnvelope(t3) : (this.updateAllDirtyIntervals(true), this.m_envelopeData.copyTo(this.m_description, t3));
  }
  queryLooseEnvelope(t3) {
    this.updateLooseEnvelope(t3);
  }
  queryInterval(t3, e5) {
    const s4 = x2.constructEmpty();
    return this.isEmptyImpl() || (this.updateAllDirtyIntervals(true), this.m_envelopeData.queryInterval(this.m_description, t3, e5, s4)), s4;
  }
  setAttributeBasic(t3, e5, s4) {
    this.setAttributeImpl(t3, e5, s4);
  }
  setAttributeImpl(t3, e5, s4) {
    if (this.addAttribute(t3), this.isEmpty()) return;
    let n6 = false;
    const i2 = ve.getComponentCount(t3), r = this.getAttributeStreamRef(t3), o = Number.isNaN(s4);
    if (1 === r.getPersistence()) {
      const t4 = r;
      for (let r2 = e5, a2 = this.m_pointCount * i2; r2 < a2; r2 += i2) {
        const e6 = t4.read(r2);
        (o || e6 === s4) && Number.isNaN(e6) || (t4.write(r2, s4), n6 = true);
      }
    } else for (let a2 = e5, h2 = this.m_pointCount * i2; a2 < h2; a2 += i2) {
      r.readAsDbl(a2) !== s4 && (r.writeAsDbl(a2, s4), n6 = true);
    }
    n6 && this.notifyModifiedFlags(2001);
  }
  replaceNaNs(t3, e5) {
    if (this.addAttribute(t3), this.isEmpty()) return;
    let s4 = false;
    const n6 = ve.getComponentCount(t3), i2 = this.getAttributeStreamRef(t3);
    for (let r = 0; r < n6; r++) if (1 === i2.getPersistence()) {
      const t4 = i2;
      for (let i3 = 0, r2 = this.m_pointCount * n6; i3 < r2; i3++) {
        const n7 = t4.read(i3);
        Number.isNaN(n7) && (t4.write(i3, e5), s4 = true);
      }
    } else for (let t4 = 0, o = this.m_pointCount * n6; t4 < o; t4++) {
      const n7 = i2.readAsDbl(t4);
      Number.isNaN(n7) && (i2.writeAsDbl(t4, e5), s4 = true);
    }
    s4 && this.notifyModifiedFlags(2001);
  }
  calculateLength3D(t3) {
    return n2(0), 0;
  }
  setEnvelopeForImport(t3) {
    this.m_description.equals(t3.getDescription()) || P(""), this.m_envelopeData = new ne({ moveEnv: t3 }), this.setDirtyFlagProtected(192, false);
  }
  copyTo(t3) {
    t3.getGeometryType() !== this.getGeometryType() && P(""), this !== t3 && this.copyToUnchecked(t3, false);
  }
  queryCoordinates(t3, s4, n6, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n6 + s4), (n6 < 0 || r < n6 || this.m_pointCount > 0 && n6 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o = this.getAttributeStreamRef(0);
    for (let e5 = 2 * n6, a2 = 2 * r, h2 = 0; e5 < a2; e5 += 2, h2++) o.queryPoint2D(e5, t3[h2]);
    return r;
  }
  queryCoordinates3D(t3, s4, n6, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n6 + s4), (n6 < 0 || r < n6 || this.m_pointCount > 0 && n6 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o = this.getAttributeStreamRef(0);
    let a2 = null;
    const h2 = ve.getDefaultValue(1), u = this.m_description.hasAttribute(1);
    u && (a2 = this.getAttributeStreamRef(1));
    let m3 = 0;
    for (let e5 = n6; e5 < r; e5++, m3++) t3[m3].x = o.read(2 * e5), t3[m3].y = o.read(2 * e5 + 1), t3[m3].z = u ? a2.read(e5) : h2;
    return r;
  }
  clearAndSetDirtyFlagProtected(t3, e5) {
    let s4 = 0;
    const n6 = t3 & ~e5, i2 = e5 | n6;
    s4 = this.m_flags, (s4 & i2) !== e5 && (this.m_flags = s4 & ~n6 | e5);
  }
  getIsSimple(t3, e5) {
    e5[0] = 0;
    let s4 = -1;
    const n6 = this.m_flags, i2 = this.m_simpleTolerance;
    if (!(1 & n6)) {
      s4 = (14 & n6) >> 1, e5[0] = i2, i2 < t3 && (s4 = -1);
    }
    return s4;
  }
  setIsSimple(t3, e5, n6 = false) {
    if (2 === t3 ? n2(this.getGeometryType() === a.enumPolyline) : 1 === t3 ? n2(this.getGeometryType() === a.enumMultiPoint || this.getGeometryType() === a.enumPolyline) : 3 === t3 && n2(this.getGeometryType() === a.enumPolygon), -1 === t3) this.setDirtyFlagProtected(17, true);
    else {
      let s4 = t3 << 1;
      n6 || (s4 |= 16);
      const i2 = 31;
      this.clearAndSetDirtyFlagProtected(i2, s4), this.m_simpleTolerance !== e5 && (this.m_simpleTolerance = e5);
    }
  }
  attributeStreamIsAllocated(t3) {
    this.throwIfEmpty();
    const e5 = this.m_description.getAttributeIndex(t3);
    return e5 >= 0 && null !== this.m_vertexAttributes.get(e5);
  }
  capacity() {
    return -1 === this.m_reservedPointCount && 0 === this.m_pointCount ? 0 : this.m_reservedPointCount;
  }
  getDescriptionImpl() {
    return this.m_description;
  }
  copyToUnchecked(t3, e5 = false) {
    e5 && this.hasDirtyFlag(32) && T("Cannot do shallow clone on unprepared geometry");
    const n6 = t3, o = this.getGeometryType(), a2 = n6.getGeometryType();
    n2(o === a2 || o === a.enumPolygon && a2 === a.enumPolyline, "failure in copyToUnchcked"), n6.clearAccelerators(), n6.m_description = this.m_description, n6.m_vertexAttributes.destroyAndSetSize(0), n6.m_envelopeData.releaseAttributes();
    const h2 = this.m_description.getAttributeCount(), u = new ge();
    if (!this.m_vertexAttributes.empty()) {
      u.destroyAndSetSize(h2);
      for (let t4 = 0; t4 < h2; t4++) if (this.m_vertexAttributes.get(t4)) if (e5) u.set(t4, this.m_vertexAttributes.get(t4));
      else {
        const e6 = ve.getComponentCount(this.m_description.getSemantics(t4));
        u.set(t4, this.m_vertexAttributes.get(t4).restrictedClone(this.getPointCount() * e6));
      }
    }
    if (this.m_envelopeData.copyToIfNotNull(this.m_description, n6.m_envelopeData), n6.m_flags = this.m_flags, n6.m_simpleTolerance = this.m_simpleTolerance, o !== a2) {
      const t4 = [Number.NaN];
      n6.getIsSimple(0, t4) >= 3 ? n6.setIsSimple(1, t4[0]) : n6.setIsSimple(-1, 0);
    }
    n6.m_vertexAttributes.swap(u), u.destroyAndSetSize(0), n6.m_pointCount = this.m_pointCount, n6.hasDirtyFlag(32) || n6.m_vertexAttributes.empty() ? (n2(!e5 || 0 === n6.m_pointCount), n6.m_reservedPointCount = -1) : n6.m_reservedPointCount = n6.m_pointCount;
    try {
      this.copyToImpl(n6, e5);
    } catch (m3) {
      throw n6.setEmpty(), m3;
    }
    n6.verifyAllStreamsAfterSizeChange();
  }
  buildRasterizedGeometryAccelerator(t3, e5) {
    return false;
  }
  getAccelerators() {
    return this.m_accelerators;
  }
  clearAccelerators() {
    this.m_accelerators && this.m_accelerators.release(), this.m_accelerators = null;
  }
  ensureUniqueAccelerators() {
    if (this.m_accelerators && !this.m_accelerators.uniqueUse()) {
      const t3 = this.m_accelerators.clone();
      this.m_accelerators.release(), this.m_accelerators = t3;
    }
  }
  interpolateTwoVertices(t3, e5, i2, r) {
    (t3 < 0 || t3 >= this.m_pointCount) && A(""), (e5 < 0 || e5 >= this.m_pointCount) && A(""), r.assignVertexDescription(this.m_description);
    const o = Yt(ve.maxComponentCount(), Number.NaN), a2 = Yt(ve.maxComponentCount(), Number.NaN), h2 = B3();
    let u = 0;
    for (let n6 = 0; n6 < this.m_description.getAttributeCount(); n6++) {
      const r2 = this.m_description.getSemantics(n6), m3 = ve.getInterpolation(r2), l2 = ve.getComponentCount(r2), c = ve.getDefaultValue(r2);
      this.queryAttributeAsDbl(r2, t3, o, l2), this.queryAttributeAsDbl(r2, e5, a2, l2), n2(u + l2 <= w3), wt(m3, o, a2, h2, u, l2, i2, c), u += l2;
    }
    Ce(r, h2);
  }
  getShortestDistance(t3, e5) {
    return mi.distance(this.getXY(t3), this.getXY(e5));
  }
  getShortestSqrDistance(t3, e5) {
    return mi.sqrDistance(this.getXY(t3), this.getXY(e5));
  }
  resizeImpl(t3) {
    if (t3 < 0 && P(), (t3 = Math.ceil(t3)) === this.m_pointCount) return;
    this.m_pointCount = t3;
    const s4 = this.m_pointCount <= this.m_reservedPointCount ? 2001 : 4095;
    this.notifyModifiedFlags(s4);
  }
  assignVertexDescriptionImpl(t3) {
    if (!this.m_vertexAttributes.empty()) {
      const e5 = S2();
      Y2(t3, this.m_description, e5);
      const s4 = new ge();
      s4.destroyAndSetSize(t3.getAttributeCount());
      for (let n6 = 0; n6 < t3.getAttributeCount(); n6++) {
        const t4 = e5[n6];
        -1 !== t4 ? s4.set(n6, this.m_vertexAttributes.get(t4)) : this.m_reservedPointCount = -1;
      }
      s4.swap(this.m_vertexAttributes);
    }
    this.m_description = t3, this.m_envelopeData.releaseAttributes(), this.notifyModifiedFlags(4095);
  }
  hasDirtyFlag(t3) {
    return 0 !== (this.m_flags & t3);
  }
  setDirtyFlagProtected(t3, e5) {
    e5 ? this.m_flags |= t3 : this.m_flags &= ~t3;
  }
  notifyModifiedAllImpl() {
  }
  verifyAllStreamsAfterSizeChange() {
    this.hasDirtyFlag(32) && this.verifyAllStreamsAfterSizeChangeImpl();
  }
  verifyAllStreamsAfterSizeChangeImpl() {
    if (this.hasDirtyFlag(32)) {
      if (this.m_reservedPointCount < this.m_pointCount) {
        this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), this.m_reservedPointCount = -1;
        let t3 = Number.MAX_SAFE_INTEGER, e5 = 0;
        e5 = this.m_pointCount < 4 ? 3 : this.m_pointCount <= 128 ? 2 * this.m_pointCount : Math.trunc((4 * this.m_pointCount + 2) / 3);
        for (let s4 = 0; s4 < this.m_description.getAttributeCount(); s4++) {
          const n6 = this.m_description.getSemantics(s4);
          let i2 = 0;
          if (null !== this.m_vertexAttributes.get(s4)) {
            const t4 = ve.getComponentCount(n6);
            i2 = this.m_vertexAttributes.get(s4).size() / t4, i2 < this.m_pointCount && (this.m_vertexAttributes.get(s4).resize(e5 * t4, ve.getDefaultValue(n6)), i2 = e5);
          } else this.m_vertexAttributes.set(s4, j3(n6, e5)), i2 = e5;
          i2 < t3 && (t3 = i2);
        }
        this.m_reservedPointCount = t3;
      }
      this.verifyStreamsAfterSizeChangeExtraImpl(), this.setDirtyFlagProtected(32, false);
    }
  }
  verifyStreamsAfterSizeChangeExtraImpl() {
  }
  updateAllDirtyIntervals(t3) {
    if (t3 ? this.hasDirtyFlag(192) : this.hasDirtyFlag(128)) {
      if (this.isEmpty()) return this.hasDirtyFlag(192) && this.m_envelopeData.setEmpty(this.m_description), void this.setDirtyFlagProtected(192, false);
      const e5 = this.updateXYImpl(t3), s4 = new re({ vd: this.m_description });
      s4.setEnvelope(e5);
      for (let t4 = 1; t4 < this.m_description.getAttributeCount(); t4++) {
        const e6 = this.m_description.getSemantics(t4), n6 = ve.getComponentCount(e6), i2 = this.m_vertexAttributes.get(t4);
        for (let t5 = 0; t5 < n6; t5++) {
          const r = new x2();
          r.setEmpty();
          for (let e7 = 0; e7 < this.m_pointCount; e7++) {
            const s5 = i2.readAsDbl(e7 * n6 + t5);
            r.mergeCoordinate(s5);
          }
          s4.setIntervalEnvelope(e6, t5, r);
        }
      }
      (t3 ? this.hasDirtyFlag(192) : this.hasDirtyFlag(128)) && (this.m_envelopeData = new ne({ moveEnv: s4 }), this.clearDirtyIntervalsFlag(t3));
    }
  }
  updateXYImpl(t3) {
    const e5 = n4.constructEmpty(), s4 = this.m_vertexAttributes.get(0);
    return e5.mergePointsInterleaved(s4, 0, this.m_pointCount), e5;
  }
  updateEnvelope3D(t3) {
    n2(0);
  }
  updateLooseEnvelope(t3) {
    this.updateAllDirtyIntervals(false), t3 instanceof n4 ? t3.assign(this.m_envelopeData.m_envelope2D) : this.m_envelopeData.queryEnvelope3D(this.m_description, t3);
  }
  updateEnvelope(t3) {
    this.updateAllDirtyIntervals(true), t3.assign(this.m_envelopeData.m_envelope2D);
  }
  setEmptyImpl() {
    this.m_pointCount = 0, this.m_reservedPointCount = -1, this.m_vertexAttributes.destroyAndSetSize(0), this.notifyModifiedFlags(4095);
  }
  clearDirtyIntervalsFlag(t3) {
    this.setDirtyFlagProtected(192, false);
  }
  reserveImpl(t3, s4) {
    if (t3 < 0 && P(""), 0 === t3) return;
    let n6 = t3 = Math.ceil(t3);
    if (this.m_reservedPointCount < n6) {
      this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), s4 ? (null === this.m_vertexAttributes.get(0) && this.m_vertexAttributes.set(0, W(0, 0)), this.m_vertexAttributes.get(0).resizeRounded(2 * n6), n6 = this.m_vertexAttributes.get(0).size() >> 1) : null === this.m_vertexAttributes.get(0) ? this.m_vertexAttributes.set(0, W(0, n6)) : this.m_vertexAttributes.get(0).resize(2 * n6);
      for (let t4 = 1; t4 < this.m_description.getAttributeCount(); t4++) {
        const e5 = this.m_description.getSemantics(t4), s5 = ve.getComponentCount(e5);
        null !== this.m_vertexAttributes.get(t4) ? this.m_vertexAttributes.get(t4).resize(n6 * s5) : this.m_vertexAttributes.set(t4, W(e5, n6));
      }
      this.reserveImplImpl(n6, s4), this.m_reservedPointCount = n6;
    }
  }
  reserveRounded(t3) {
    t3 < 0 && P(), t3 = Math.ceil(t3), this.reserveImpl(t3, true);
  }
  reserveImplImpl(t3, e5) {
  }
  throwIfEmpty() {
    this.isEmptyImpl() && x("");
  }
};
var Ee = class _Ee extends Se {
  constructor(t3) {
    super(t3), t3 && (t3.points ? this.addPoints2D(t3.points, t3.pointsSize, 0, -1) : t3.point && this.add(t3.point));
  }
  assignCopy(t3) {
    return t3.copyTo(this), this;
  }
  assignMove(t3) {
    return t3.copyTo(this), t3.setEmpty(), this;
  }
  insertPoint2D(t3, s4) {
    t3 > this.getPointCount() && P("invalid point index"), t3 < 0 && (t3 = this.getPointCount());
    const n6 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + 1);
    for (let e5 = 0, i2 = this.m_description.getAttributeCount(); e5 < i2; e5++) {
      const i3 = this.m_description.getSemantics(e5), r = z3.getComponentCount(i3);
      if (0 === i3) this.m_vertexAttributes.get(e5).insert(r * t3, s4, r * n6);
      else {
        const s5 = z3.getDefaultValue(i3);
        this.m_vertexAttributes.get(e5).insertRange(r * t3, s5, r, r * n6);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoint(t3, s4) {
    s4.isEmpty() && P(be), t3 < 0 && (t3 = this.getPointCount()), this.mergeVertexDescription(s4.getDescription());
    const n6 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + 1);
    for (let e5 = 0, i2 = this.m_description.getAttributeCount(); e5 < i2; e5++) {
      const i3 = this.m_description.getSemantics(e5), r = z3.getComponentCount(i3);
      if (s4.hasAttribute(i3)) this.m_vertexAttributes.get(e5).insertAttributes(r * t3, s4, i3, r * n6);
      else {
        const s5 = z3.getDefaultValue(i3);
        this.m_vertexAttributes.get(e5).insertRange(r * t3, s5, r, r * n6);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoints(t3, e5, s4) {
    if ((t3 > this.getPointCount() || s4 < 0) && A(""), t3 < 0 && (t3 = this.getPointCount()), 0 === s4) return;
    const i2 = e5[0].getDescription();
    this.mergeVertexDescription(i2);
    const r = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + s4);
    for (let n6 = 0, o = this.m_description.getAttributeCount(); n6 < o; n6++) {
      const o2 = this.m_description.getSemantics(n6), a2 = z3.getComponentCount(o2);
      if (this.m_vertexAttributes.get(n6)) if (i2.hasAttribute(o2)) this.m_vertexAttributes.get(n6).insertAttributesFromPoints(t3 * a2, e5, s4, o2, r * a2);
      else {
        const e6 = z3.getDefaultValue(o2);
        this.m_vertexAttributes.get(n6).insertRange(a2 * t3, e6, a2 * s4, a2 * r);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoints2D(t3, s4, n6) {
    if ((t3 > this.getPointCount() || n6 < 0) && P("invalid point index"), t3 < 0 && (t3 = this.getPointCount()), 0 === n6) return;
    const i2 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + n6);
    for (let e5 = 0, r = this.m_description.getAttributeCount(); e5 < r; e5++) {
      const r2 = this.m_description.getSemantics(e5), o = z3.getComponentCount(r2);
      if (this.m_vertexAttributes.get(e5)) if (0 === r2) this.m_vertexAttributes.get(e5).insertRangeFromPoints(o * t3, s4, 0, n6, true, o * i2);
      else {
        const s5 = z3.getDefaultValue(r2);
        this.m_vertexAttributes.get(e5).insertRange(o * t3, s5, o, o * i2);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  removePoints(t3, e5) {
    if ((t3 < 0 || e5 < 0 || t3 + e5 > this.getPointCount()) && A("remove_points"), 0 !== e5) {
      for (let s4 = 0, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) if (this.m_vertexAttributes.get(s4)) {
        const n7 = this.m_description.getSemantics(s4), i2 = z3.getComponentCount(n7);
        this.m_vertexAttributes.get(s4).eraseRange(i2 * t3, i2 * e5, i2 * this.m_pointCount);
      }
      this.m_pointCount -= e5, this.m_reservedPointCount > 0 && (this.m_reservedPointCount -= e5), this.notifyModifiedFlags(2001);
    }
  }
  removePoint(t3) {
    for (let e5 = 0, s4 = this.m_description.getAttributeCount(); e5 < s4; e5++) if (this.m_vertexAttributes.get(e5)) {
      const s5 = this.m_description.getSemantics(e5), n6 = z3.getComponentCount(s5);
      this.m_vertexAttributes.get(e5).eraseRange(n6 * t3, n6, n6 * this.m_pointCount);
    }
    this.m_pointCount--, this.m_reservedPointCount > 0 && this.m_reservedPointCount--, this.notifyModifiedFlags(2001);
  }
  calculateEnvelope2D() {
    return this.updateXYImpl(true);
  }
  resizeNoInit(t3) {
    this.resizeImpl(t3);
  }
  resizeAndInitNonPositionAttributes(t3) {
    const e5 = this.m_pointCount;
    if (this.resizeImpl(t3), this.m_pointCount > e5) for (let s4 = 1, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) {
      const t4 = this.m_description.getSemantics(s4), n7 = z3.getDefaultValue(t4), i2 = z3.getComponentCount(t4);
      this.m_vertexAttributes.get(s4).insertRange(i2 * e5, n7, i2 * (this.m_pointCount - e5), i2 * e5);
    }
  }
  queryCoordinates3D(t3, s4, n6, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n6 + s4), (n6 < 0 || r < n6 || this.m_pointCount > 0 && n6 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o = this.getAttributeStreamRef(0);
    let a2 = null;
    const h2 = z3.getDefaultValue(1), u = this.m_description.hasAttribute(1);
    u && (a2 = this.getAttributeStreamRef(1));
    let m3 = 0;
    for (let e5 = n6; e5 < r; e5++, m3++) t3[m3].x = o.read(2 * e5), t3[m3].y = o.read(2 * e5 + 1), t3[m3].z = u ? a2.read(e5) : h2;
    return r;
  }
  queryAttributeAsInt(t3, e5, n6, i2) {
    n2(0);
  }
  add(t3) {
    t3.isEmpty() && P(be), this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1), this.setPointByValNoCurves(this.m_pointCount - 1, t3);
  }
  addXY(t3, e5) {
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1);
    const s4 = new mi(t3, e5);
    this.setXYNoCurves(this.m_pointCount - 1, s4);
  }
  addXYZ(t3, e5, s4) {
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1);
    const n6 = new X();
    n6.setCoords(t3, e5, s4), this.setXYZNoCurves(this.m_pointCount - 1, n6);
  }
  addPoint2D(t3) {
    this.addXY(t3.x, t3.y);
  }
  addPoint3D(t3) {
    this.addXYZ(t3.x, t3.y, t3.z);
  }
  addPoints(t3, s4, n6) {
    this === t3 && P("Multi_point_impl.add");
    const i2 = n6 < 0 ? t3.getPointCount() : n6;
    if ((s4 < 0 || s4 > t3.getPointCount() || i2 < s4) && P(""), s4 === i2) return;
    const r = t3.getDescription();
    this.mergeVertexDescription(r);
    const o = i2 - s4, a2 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + o);
    for (let e5 = 0, h2 = this.m_description.getAttributeCount(); e5 < h2; e5++) {
      const n7 = this.m_description.getSemantics(e5), i3 = z3.getComponentCount(n7), h3 = this.getAttributeStreamRef(n7);
      if (r.hasAttribute(n7)) {
        const e6 = t3.getAttributeStreamRef(n7);
        h3.insertRangeFromStream(a2 * i3, e6, s4 * i3, o * i3, true, 1, a2 * i3);
      } else {
        const t4 = z3.getDefaultValue(n7);
        h3.insertRange(a2 * i3, t4, o * i3, a2 * i3);
      }
    }
  }
  addPoints2D(t3, s4, n6, i2) {
    let r = s4;
    const o = i2 < 0 ? r : i2;
    if ((r < 0 || n6 < 0 || n6 > r || o < n6) && P(""), n6 === o) return;
    r = o - n6;
    const a2 = this.m_pointCount;
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + r);
    const h2 = this.getAttributeStreamRef(0);
    for (let e5 = 0; e5 < r; ++e5) h2.writePoint2D(2 * (a2 + e5), t3[n6 + e5]);
    this.notifyModifiedFlags(2001);
  }
  addPoints3D(t3, s4, n6, i2) {
    let r = s4;
    const o = i2 < 0 ? r : i2;
    if ((r < 0 || n6 < 0 || n6 > r || o < n6) && P(""), this.addAttribute(1), n6 === o) return;
    r = o - n6;
    const a2 = this.m_pointCount;
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + r);
    const h2 = this.getAttributeStreamRef(0), u = new mi();
    for (let e5 = 0; e5 < r; e5++) u.x = t3[n6 + e5].x, u.y = t3[n6 + e5].y, h2.writePoint2D(2 * (a2 + e5), u);
    const m3 = this.getAttributeStreamRef(1);
    for (let e5 = 0; e5 < r; e5++) m3.write(a2 + e5, t3[n6 + e5].z);
    this.notifyModifiedFlags(2001);
  }
  setPointByVal(t3, e5) {
    this.setPointByValNoCurves(t3, e5);
  }
  setXY(t3, e5) {
    this.setXYNoCurves(t3, e5);
  }
  setXYCoords(t3, e5, s4) {
    this.setXYCoordsNoCurves(t3, e5, s4);
  }
  setXYZ(t3, e5) {
    this.setXYZNoCurves(t3, e5);
  }
  setAttribute(t3, e5, s4, n6) {
    this.setAttributeNoCurves(t3, e5, s4, n6);
  }
  getGeometryType() {
    return a.enumMultiPoint;
  }
  getDimension() {
    return 0;
  }
  createInstance() {
    return new _Ee({ vd: this.getDescription() });
  }
  setEmpty() {
    this.setEmptyImpl();
  }
  applyTransformation(t3) {
    if (this.isEmpty()) return;
    if (t3.isIdentity()) return;
    const e5 = this.m_vertexAttributes.get(0);
    1 === t3.m_TransformationType ? e5.applyTransformation(t3, 0, this.m_pointCount) : z("3d xform not impl"), this.notifyModifiedFlags(2001);
  }
  calculateArea2D() {
    return 0;
  }
  calculateLength2D() {
    return 0;
  }
  calculateLength3D(t3) {
    return 0;
  }
  equals(t3, e5) {
    return t3.getGeometryType() === a.enumMultiPoint && this.equalsBase(t3, e5);
  }
  queryEnvelope(t3) {
    4 === t3.m_EnvelopeType ? (this.updateAllDirtyIntervals(true), this.m_envelopeData.copyTo(this.m_description, t3)) : 2 === t3.m_EnvelopeType ? this.updateEnvelope(t3) : z("");
  }
  getImpl() {
    return this;
  }
  getBoundary() {
    return null;
  }
  reserve(t3) {
    this.reserveImpl(t3);
  }
  clone() {
    const t3 = this.createInstance();
    return this.copyTo(t3), t3;
  }
  swap(t3) {
    n2(0);
  }
  buildQuadTreeAccelerator(t3) {
    return false;
  }
  getHashCodeImpl() {
    return n2(0), 0;
  }
  equalsImpl(t3) {
    return true;
  }
  equalsImplTol(t3, e5) {
    return true;
  }
  copyToImpl(t3, e5) {
  }
};
Ee.type = a.enumMultiPoint;
var De = class _De {
  constructor() {
    this.m_EnvelopeType = 5, this.envAabb = n4.constructEmpty(), this.envRot = n4.constructEmpty();
  }
  static constructEmpty() {
    return new _De();
  }
  width() {
    return this.envAabb.width();
  }
  height() {
    return this.envAabb.height();
  }
  maxDim() {
    return Math.max(this.width(), this.height());
  }
  setEmpty() {
    this.envAabb.setEmpty(), this.envRot.setEmpty();
  }
  setCoords(t3) {
    this.envAabb.setCoords(t3), this.envRot.setCoords({ x: Te(t3), y: Ie(t3) });
  }
  setFromPoints(t3, e5) {
    this.setEmpty(), this.mergePoints(t3, e5);
  }
  mergeNe(t3) {
    this.envAabb.mergeNe(t3), this.envRot.mergeNeCoords(Te(t3), Ie(t3));
  }
  mergePoints(t3, e5) {
    this.envAabb.mergePoints(t3, e5);
    for (let s4 = 0; s4 < e5; ) {
      if (!this.envRot.isEmpty()) {
        for (let n6 = s4; n6 < e5; n6++) {
          const e6 = Te(t3[n6]), s5 = Ie(t3[n6]);
          this.envRot.mergeNeCoords(e6, s5);
        }
        break;
      }
      {
        const e6 = Te(t3[s4]), n6 = Ie(t3[s4]);
        this.envRot.setCoords({ x: e6, y: n6 }), s4++;
      }
    }
  }
  isIntersectingPoint2D(t3) {
    return !(!this.envAabb.contains(t3) || !this.envRot.containsCoords(Te(t3), Ie(t3)));
  }
  isIntersectingW(t3) {
    return this.envAabb.isIntersecting(t3.envAabb) && this.envRot.isIntersecting(t3.envRot);
  }
  containsW(t3) {
    return !(!this.envAabb.containsEnvelope(t3.envAabb) || !this.envRot.containsEnvelope(t3.envRot));
  }
  containsPoint2D(t3) {
    return this.isIntersectingPoint2D(t3);
  }
  intersectW(t3) {
    const e5 = this.envAabb.intersect(t3.envAabb), s4 = this.envRot.intersect(t3.envRot);
    return e5 && !s4 && this.envAabb.setEmpty(), s4 && !e5 && this.envRot.setEmpty(), e5 && s4;
  }
  inflate(t3) {
    this.envAabb.inflateCoords(t3, t3);
    const e5 = t3 * Gs();
    this.envRot.inflateCoords(e5, e5), e5 < 0 && _De.st_reduceEmpty(this);
  }
  static st_reduceEmpty(t3) {
    const e5 = t3.envAabb.isEmpty(), s4 = t3.envRot.isEmpty();
    e5 && !s4 ? t3.envRot.setEmpty() : s4 && !e5 && t3.envAabb.setEmpty();
  }
  sqrMaxMinDistance(t3) {
    const e5 = this.envAabb.sqrMaxMinDistance(t3), s4 = this.envRot.sqrMaxMinDistance(Me(t3)) / 2;
    return Math.max(e5, s4);
  }
  sqrMinDistance(t3) {
    const e5 = this.envAabb.sqrMinDistance(t3), s4 = this.envRot.sqrMinDistance(Me(t3)) / 2;
    return Math.max(e5, s4);
  }
  sqrMaxDistance(t3) {
    const e5 = this.envAabb.sqrMaxDistance(t3), s4 = this.envRot.sqrMaxDistance(Me(t3)) / 2;
    return Math.max(e5, s4);
  }
  getEnvelope2D() {
    return this.envAabb;
  }
  getRotatedEnvelope2D() {
    return this.envRot;
  }
  xyRot(t3, e5) {
    const s4 = we(t3.x, t3.y), n6 = Ae(t3.x, t3.y);
    e5.setCoords(s4, n6);
  }
};
function we(t3, e5) {
  return t3 - e5;
}
function Ae(t3, e5) {
  return t3 + e5;
}
function Te(t3) {
  return t3.x - t3.y;
}
function Ie(t3) {
  return t3.x + t3.y;
}
function Me(t3) {
  return new mi(Te(t3), Ie(t3));
}
var Ye = class _Ye {
  constructor() {
    this.x = p2.getNAN(), this.y = p2.getNAN();
  }
  static getNAN() {
    return new _Ye();
  }
  static constructPoint2D(t3) {
    const e5 = new _Ye();
    return e5.x.set(t3.x), e5.y.set(t3.y), e5;
  }
  static constructCoords(t3, e5) {
    const s4 = new _Ye();
    return s4.x.set(t3), s4.y.set(e5), s4;
  }
  static constructCoordsE(t3, e5) {
    const s4 = new _Ye();
    return s4.setCoordsE(t3, e5), s4;
  }
  get 0() {
    return this.x.clone();
  }
  set 0(t3) {
    this.x.setE(t3);
  }
  get 1() {
    return this.y.clone();
  }
  set 1(t3) {
    this.y.setE(t3);
  }
  clone() {
    return new _Ye().setE(this);
  }
  scaleThis(t3) {
    return this.x.mulThisE(t3), this.y.mulThisE(t3), this;
  }
  setCoords(t3, e5) {
    return this.x.set(t3), this.y.set(e5), this;
  }
  setCoordsE(t3, e5) {
    return this.x.setE(t3), this.y.setE(e5), this;
  }
  set(t3) {
    return this.x.set(t3.x), this.y.set(t3.y), this;
  }
  setE(t3) {
    return this.x.setE(t3.x), this.y.setE(t3.y), this;
  }
  setWithEps(t3, e5) {
    return this.x.setWithEps(t3.x, e5), this.y.setWithEps(t3.y, e5), this;
  }
  getUnitVector() {
    const t3 = this.clone();
    return t3.normalize(), t3;
  }
  sqrLength() {
    return this.x.sqr().addE(this.y.sqr());
  }
  length() {
    return this.sqrLength().sqrt();
  }
  mulE(t3) {
    const e5 = new _Ye();
    return e5.setCoordsE(this.x.mulE(t3), this.y.mulE(t3)), e5;
  }
  mul(t3) {
    const e5 = new _Ye();
    return e5.setCoordsE(this.x.mul(t3), this.y.mul(t3)), e5;
  }
  mulThis(t3) {
    return this.x.mulThis(t3), this.y.mulThis(t3), this;
  }
  mulThisE(t3) {
    return this.x.mulThisE(t3), this.y.mulThisE(t3), this;
  }
  divE(t3) {
    return this.clone().divThisE(t3);
  }
  divThisE(t3) {
    return this.x.divThisE(t3), this.y.divThisE(t3), this;
  }
  normalize() {
    const t3 = this.length();
    0 === t3.value() ? (this.x = w2.clone(), this.y = I2.clone()) : (this.x.divThisE(t3), this.y.divThisE(t3));
  }
  addE(t3) {
    return this.clone().addThisE(t3);
  }
  addThisE(t3) {
    return this.x.addThisE(t3.x), this.y.addThisE(t3.y), this;
  }
  subE(t3) {
    return this.clone().subThisE(t3);
  }
  subThisE(t3) {
    return this.x.subThisE(t3.x), this.y.subThisE(t3.y), this;
  }
  static distance(t3, e5) {
    return t3.subE(e5).length();
  }
  negateThis() {
    return this.x.negateThis(), this.y.negateThis(), this;
  }
  eq(t3) {
    return this.x.eq(t3.x) && this.y.eq(t3.y);
  }
  isZero() {
    return this.x.isZero() && this.y.isZero();
  }
  isTrueZero() {
    return !this.x.value() && !this.y.value();
  }
  rotateDirect(t3, e5) {
    const s4 = this.x.mulE(t3).subThisE(this.y.mulE(e5)), n6 = this.x.mulE(e5).addThisE(this.y.mulE(t3));
    return this.x.setE(s4), this.y.setE(n6), this;
  }
  rotateReverse(t3, e5) {
    const s4 = this.x.mulE(t3).addThisE(this.y.mulE(e5)), n6 = this.x.negate().mulThisE(e5).addThisE(this.y.mulE(t3));
    return this.x.setE(s4), this.y.setE(n6), this;
  }
  dotProduct(t3) {
    return this.x.mulE(t3.x).addE(this.y.mulE(t3.y));
  }
  crossProduct(t3) {
    return this.x.mulE(t3.y).subE(this.y.mulE(t3.x));
  }
  value() {
    return mi.construct(this.x.value(), this.y.value());
  }
};
var Ne = class _Ne {
  constructor() {
    this.a11 = new p2(1), this.a12 = new p2(0), this.a21 = new p2(0), this.a22 = new p2(1);
  }
  clone() {
    const t3 = new _Ne();
    return t3.a11.setE(this.a11), t3.a12.setE(this.a12), t3.a21.setE(this.a21), t3.a22.setE(this.a22), t3;
  }
  assign(t3) {
    return this.a11.setE(t3.a11), this.a12.setE(t3.a12), this.a21.setE(t3.a21), this.a22.setE(t3.a22), this;
  }
  mulThis(t3) {
    const e5 = this.a11.mulE(t3.a11).addThisE(this.a12.mulE(t3.a21)), s4 = this.a11.mulE(t3.a12).addThisE(this.a12.mulE(t3.a22)), n6 = this.a21.mulE(t3.a11).addThisE(this.a22.mulE(t3.a21)), i2 = this.a21.mulE(t3.a12).addThisE(this.a22.mulE(t3.a22));
    return this.a11 = e5, this.a12 = s4, this.a21 = n6, this.a22 = i2, this;
  }
  mulLeftThis(t3) {
    const e5 = t3.clone();
    return this.assign(e5.mulThis(this)), this;
  }
  det() {
    return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21));
  }
  invertThis() {
    const t3 = this.det();
    if (0 !== t3.value()) {
      const e5 = this.a22.divE(t3), s4 = this.a12.negate().divThisE(t3), n6 = this.a21.negate().divThisE(t3), i2 = this.a11.divE(t3);
      this.a11 = e5, this.a12 = s4, this.a21 = n6, this.a22 = i2;
    } else this.setZero();
    return !t3.isZero();
  }
  transposeThis() {
    return this.a21 = Pt(this.a12, this.a12 = this.a21), this;
  }
  eigenSymmetric(t3, e5) {
    const s4 = this.a12.clone();
    s4.addThisE(this.a21), s4.mulThisByPower2(0.5);
    let n6 = new p2(1), i2 = new p2(0);
    if (s4.isZero()) t3[0].setE(this.a11), t3[1].setE(this.a22);
    else {
      const e6 = new p2(1);
      if (this.a11.ne(this.a22)) {
        const r = this.a11.subE(this.a22).divE(s4);
        r.mulThisByPower2(0.5);
        const o = r.sqr();
        e6.setE(r), e6.absThis(), e6.subThisE(o.add(1).sqrtThis()), r.gt(I2) && e6.negateThis();
        const a2 = e6.sqr().addThis(1).sqrtThis().invThis();
        i2 = e6.mulE(a2), n6.setE(a2);
        const h2 = e6.mulE(s4);
        t3[0] = this.a11.addE(h2), t3[1] = this.a22.subE(h2);
      } else n6 = new p2(1 / Math.sqrt(2)), i2 = n6.clone(), t3[0] = this.a11.addE(s4), t3[1] = this.a22.subE(s4);
    }
    e5[0].x = n6.toDouble(), e5[0].y = i2.toDouble(), e5[1].x = i2.negate().toDouble(), e5[1].y = n6.toDouble(), Math.abs(t3[0].toDouble()) > Math.abs(t3[1].toDouble()) && (t3[1] = Pt(t3[0], t3[0] = t3[1]), e5[1] = Pt(e5[0], e5[0] = e5[1]));
  }
  setZero() {
    this.a11.set(0), this.a21.set(0), this.a12.set(0), this.a22.set(0);
  }
};
var Xe = class _Xe {
  static constructPoint2D(t3) {
    return new _Xe(si.constructDouble(t3.x), si.constructDouble(t3.y));
  }
  constructor(t3, e5) {
    if (void 0 === t3) return this.x = new si().setNAN(), void (this.y = new si().setNAN());
    this.x = t3.clone(), this.y = e5.clone();
  }
  assignPoint2D(t3) {
    return this.x.setDouble(t3.x), this.y.setDouble(t3.y), this;
  }
  setCoords(t3, e5) {
    return this.x.setThis(t3), this.y.setThis(e5), this;
  }
  asPoint2D() {
    return new mi(this.x.value(), this.y.value());
  }
  crossProduct(t3) {
    return this.x.mul(t3.y).sub(this.y.mul(t3.x));
  }
  leftPerpendicularThis() {
    const t3 = this.x.clone();
    this.x = this.y.clone().negate(), this.y = t3;
  }
  clone() {
    return new _Xe(this.x, this.y);
  }
  dotProduct(t3) {
    return this.x.mul(t3.x).add(this.y.mul(t3.y));
  }
  add(t3) {
    return new _Xe(this.x.add(t3.x), this.y.add(t3.y));
  }
  sub(t3) {
    return new _Xe(this.x.sub(t3.x), this.y.sub(t3.y));
  }
  sqrLength() {
    return this.x.sqr().addThis(this.y.sqr());
  }
  mulThis(t3) {
    return this.x.mulThis(t3), this.y.mulThis(t3), this;
  }
  mul(t3) {
    return this.clone().mulThis(t3);
  }
  subThis(t3) {
    return this.x.subThis(t3.x), this.y.subThis(t3.y), this;
  }
  addThis(t3) {
    return this.x.addThis(t3.x), this.y.addThis(t3.y), this;
  }
};
var qe = z3;
function Fe(t3) {
  let e5 = false;
  for (let s4 = 0; s4 < 2; s4++) {
    const n6 = fs(t3[0][s4], t3[3][s4]);
    n6 > 0 ? (fs(t3[0][s4], t3[1][s4]) < 0 && (t3[1][s4] = t3[0][s4], e5 = true), fs(t3[1][s4], t3[3][s4]) < 0 && (t3[1][s4] = t3[3][s4], e5 = true), fs(t3[0][s4], t3[2][s4]) < 0 && (t3[2][s4] = t3[0][s4], e5 = true), fs(t3[2][s4], t3[3][s4]) < 0 && (t3[2][s4] = t3[3][s4], e5 = true), fs(t3[1][s4], t3[2][s4]) < 0 && (t3[2][s4] = t3[1][s4], e5 = true)) : n6 < 0 ? (fs(t3[0][s4], t3[1][s4]) > 0 && (t3[1][s4] = t3[0][s4], e5 = true), fs(t3[1][s4], t3[3][s4]) > 0 && (t3[1][s4] = t3[3][s4], e5 = true), fs(t3[0][s4], t3[2][s4]) > 0 && (t3[2][s4] = t3[0][s4], e5 = true), fs(t3[2][s4], t3[3][s4]) > 0 && (t3[2][s4] = t3[3][s4], e5 = true), fs(t3[1][s4], t3[2][s4]) > 0 && (t3[2][s4] = t3[1][s4], e5 = true)) : t3[1][s4] === t3[0][s4] && t3[2][s4] === t3[0][s4] || (t3[1][s4] = t3[0][s4], t3[2][s4] = t3[0][s4], e5 = true);
  }
  return e5;
}
function Ve(t3) {
  const e5 = fs(t3[0].y, t3[1].y), s4 = fs(t3[1].y, t3[2].y), n6 = fs(t3[2].y, t3[3].y);
  if (e5 >= 0 && s4 >= 0 && n6 >= 0 || e5 <= 0 && s4 <= 0 && n6 <= 0) {
    const e6 = fs(t3[0].x, t3[1].x), s5 = fs(t3[1].x, t3[2].x), n7 = fs(t3[2].x, t3[3].x);
    if (e6 >= 0 && s5 >= 0 && n7 >= 0 || e6 <= 0 && s5 <= 0 && n7 <= 0) return true;
  }
  return false;
}
function Le(t3, e5) {
  const s4 = t3.getStartXY();
  if (s4.equals(e5.getStartXY())) return true;
  if (s4.equals(e5.getEndXY())) return true;
  const n6 = t3.getEndXY();
  return !!n6.equals(e5.getStartXY()) || !!n6.equals(e5.getEndXY());
}
function Re(t3, e5) {
  let s4 = t3.calculateLowerLength2D();
  return !(s4 > e5) && (!!t3.isLine() || (s4 = t3.calculateUpperLength2D(), s4 <= e5 || 0 !== e5 && t3.calculateLength2D() <= e5));
}
function ze(t3, e5, s4) {
  const n6 = Ot(mi, 4);
  let r = t3.queryControlPointsHelper(n6);
  const o = Ot(mi, 4);
  let a2 = e5.queryControlPointsHelper(o);
  n6[0].equals(o[0]) || k("");
  const h2 = t3.getGeometryType();
  if (h2 === e5.getGeometryType() && n6.map((t4, e6) => o[e6].equals(t4)).reduce((t4, e6) => t4 && e6)) {
    if (h2 !== a.enumRationalBezier2) return 0;
    {
      const s5 = e5, n7 = [0, 0, 0], i2 = [0, 0, 0];
      if (t3.queryWeights(n7), s5.queryWeights(i2), n7.map((t4, e6) => i2[e6] === t4).reduce((t4, e6) => t4 && e6)) return 0;
    }
  }
  for (; r > 2 && n6[1].equals(n6[0]); ) n6.splice(1, 1), r--;
  for (; a2 > 2 && o[1].equals(o[0]); ) o.splice(1, 1), a2--;
  (n6[1].equals(n6[0]) || o[1].equals(n6[0])) && k("");
  const m3 = mi.compareVectorsOrigin(n6[0], n6[1], o[1]);
  if (0 === m3) {
    const s5 = Xe.constructPoint2D(n6[0]), i2 = new Xe();
    t3.queryCoord2DMP(1e-16, i2), i2.sub(s5);
    const r2 = new Xe();
    e5.queryCoord2DMP(1e-16, r2), r2.sub(s5);
    return r2.crossProduct(i2).sign();
  }
  return m3;
}
function Be(t3, e5, n6, i2, r, o, a2, h2) {
  let u = t3.calculateUpperLength2D(), m3 = e5.calculateUpperLength2D(), l2 = t3, c = e5, g2 = false;
  u > m3 && (c = Pt(l2, l2 = c), i2 = Pt(n6, n6 = i2), m3 = Pt(u, u = m3), g2 = true);
  const d2 = 0 === n6;
  {
    a2[0] = d2 ? 1 : 0;
    const t4 = l2.getCoord2D(a2[0]);
    h2[0] = c.getClosestCoordinate(t4, false);
    const e6 = c.getCoord2D(h2[0]);
    if (mi.distance(t4, e6) <= r) {
      const e7 = [0.5, 0.75, 0.25, 0.1, 0.9];
      let s4 = true;
      for (let n7 = 0; n7 < e7.length; n7++) if (t4.assign(l2.getCoord2D(e7[n7])), !c.isCloserThanDistance(t4, new x2(0, 1), r)) {
        s4 = false;
        break;
      }
      if (s4) return g2 && (h2[0] = Pt(a2[0], a2[0] = h2[0])), 1;
    }
  }
  if (u <= 3 * r) return 0;
  let _ = Us(Math.max(r / u, 0.1), 0, 0.5), p3 = 0.01 * r, f3 = 0, P5 = 0, y2 = _, x4 = -1, C3 = 0, v3 = 1 / 32;
  for (let b2 = 0; ; b2++) {
    n2(b2 < 4095);
    const t4 = d2 ? _ : 1 - _, e6 = l2.getCoord2D(t4), n7 = c.getClosestCoordinate(e6, false);
    if (n7 === i2) return C3;
    const u2 = c.getCoord2D(n7), m4 = mi.distance(e6, u2);
    if (0 === b2 && (x4 = m4), m4 <= p3 ? (v3 = 0.5, P5 = m4, f3 = _) : (y2 = _, x4 = m4), Math.abs(P5 - x4) > 0.1 * p3 && y2 - f3 > 1e-16) _ = Q(f3, y2, v3);
    else {
      if (a2[C3] = t4, h2[C3] = n7, g2 && (h2[C3] = Pt(a2[C3], a2[C3] = h2[C3])), 1 === o || 1 === C3) return 1 === C3 && a2[0] > a2[1] && (a2[1] = Pt(a2[0], a2[0] = a2[1]), h2[1] = Pt(h2[0], h2[0] = h2[1])), C3 + 1;
      C3++, f3 = y2, P5 = x4, y2 = 0.8, x4 = -1, _ = 0.8, v3 = 1 / 32, p3 = 10 * r, b2 = 0;
    }
  }
}
function ke(t3, e5, s4, n6, i2, r, o, a2, h2) {
  if (Vs(s4, 0, 1) && Vs(n6, 0, 1)) {
    if (0 === mi.distance(t3.getCoord2D(s4), e5.getCoord2D(n6))) {
      const h3 = 1e-12, u = new Ye(), m3 = Qs();
      if (t3.queryDerivative(new p2(s4, m3), u), u.isTrueZero()) {
        const e6 = 1 === s4 ? -1e-12 : h3;
        t3.queryDerivative(new p2(s4, m3).add(e6), u);
      }
      1 === s4 && u.negateThis();
      const l2 = new Ye();
      if (e5.queryDerivative(new p2(n6, m3), l2), l2.isTrueZero()) {
        const t4 = 1 === s4 ? -1e-12 : h3;
        e5.queryDerivative(new p2(n6, m3).add(t4), l2);
      }
      1 === n6 && l2.negateThis(), u.isZero() || u.normalize(), l2.isZero() || l2.normalize();
      const c = u.dotProduct(l2), g2 = u.crossProduct(l2);
      g2.scaleError(3);
      const d2 = () => {
        {
          const s5 = t3.calculateUpperLength2D(), n7 = e5.calculateUpperLength2D();
          return Math.min(0.01 * i2 / Math.min(s5, n7), 1e-10);
        }
      };
      if (c.ge(I2) && (g2.isZero() || Math.abs(g2.value()) < d2())) {
        return Be(t3, e5, s4, n6, i2, r, o, a2);
      }
    }
  }
  return 0;
}
function Ge(t3, e5, n6) {
  if (n2(t3.isCurve() || e5.isCurve()), t3.getStartXY().equals(e5.getStartXY())) {
    if (ke(t3, e5, 0, 0, n6, 2, [0, 0], [0, 0])) return true;
  }
  if (t3.getEndXY().equals(e5.getEndXY())) {
    if (ke(t3, e5, 1, 1, n6, 2, [0, 0], [0, 0])) return true;
  }
  if (t3.getStartXY().equals(e5.getEndXY())) {
    if (ke(t3, e5, 0, 1, n6, 2, [0, 0], [0, 0])) return true;
  }
  if (t3.getEndXY().equals(e5.getStartXY())) {
    if (ke(t3, e5, 1, 0, n6, 2, [0, 0], [0, 0])) return true;
  }
  return false;
}
function We(t3, e5) {
  t3.m_XStart = e5.x, t3.m_YStart = e5.y;
}
function je(t3, e5, s4) {
  t3.m_XStart = e5, t3.m_YStart = s4;
}
function Ze(t3, e5) {
  t3.m_XEnd = e5.x, t3.m_YEnd = e5.y;
}
function He(t3, e5, s4) {
  t3.m_XEnd = e5, t3.m_YEnd = s4;
}
function Ue(t3, e5, s4) {
  e5 ? t3.m_XEnd === s4.x && t3.m_YEnd === s4.y || (t3.m_XEnd = s4.x, t3.m_YEnd = s4.y, t3.endPointModified()) : t3.m_XStart === s4.x && t3.m_YStart === s4.y || (t3.m_XStart = s4.x, t3.m_YStart = s4.y, t3.endPointModified());
}
function Oe(t3, e5) {
  const s4 = new X();
  return e5 ? (s4.x = t3.m_XEnd, s4.y = t3.m_YEnd) : (s4.x = t3.m_XStart, s4.y = t3.m_YStart), s4.z = Qe(t3, e5), s4;
}
function Qe(t3, e5) {
  return t3.m_description.hasZ() ? t3.m_attributes[e5 * (t3.m_description.getTotalComponentCount() - 2)] : qe.getDefaultValue(1);
}
function Je(t3, e5, s4) {
  t3.m_description.hasZ() || t3.addAttribute(1), e5 ? t3.m_XEnd === s4.x && t3.m_YEnd === s4.y || (t3.m_XEnd = s4.x, t3.m_YEnd = s4.y, t3.endPointModified()) : t3.m_XStart === s4.x && t3.m_YStart === s4.y || (t3.m_XStart = s4.x, t3.m_YStart = s4.y, t3.endPointModified()), t3.m_attributes[(t3.m_description.getTotalComponentCount() - 2) * e5] = s4.z;
}
function Ke(t3, e5, s4) {
  s4.assignVertexDescription(t3.m_description);
  const n6 = 0 === e5 ? t3.m_XStart : t3.m_XEnd, i2 = 0 === e5 ? t3.m_YStart : t3.m_YEnd;
  s4.setXYCoords(n6, i2);
  for (let r = 1; r < t3.m_description.getAttributeCount(); r++) {
    const n7 = t3.m_description.getSemantics(r);
    for (let i3 = 0, r2 = qe.getComponentCount(n7); i3 < r2; i3++) {
      const r3 = ts(t3, e5, n7, i3);
      s4.setAttributeBasic(n7, i3, r3);
    }
  }
}
function $e(t3, e5, s4) {
  s4.isEmpty() && x(""), Ue(t3, e5, s4.getXY());
  const n6 = s4.getDescription();
  n6 !== t3.m_description && t3.mergeVertexDescription(n6);
  for (let i2 = 1, r = n6.getAttributeCount(); i2 < r; i2++) {
    const r2 = n6.getSemantics(i2), o = qe.getComponentCount(r2);
    for (let n7 = 0; n7 < o; n7++) {
      es(t3, e5, r2, n7, s4.getAttributeAsDbl(r2, n7));
    }
  }
}
function ts(t3, e5, s4, i2) {
  if ((e5 < 0 || e5 > 1) && A(""), 0 === s4) return (i2 < 0 || i2 >= 2) && A(""), 0 === e5 ? 0 === i2 ? t3.m_XStart : t3.m_YStart : 0 === i2 ? t3.m_XEnd : t3.m_YEnd;
  const r = qe.getComponentCount(s4);
  (i2 < 0 || i2 >= r) && A("");
  const o = t3.m_description.getAttributeIndex(s4);
  return o >= 0 ? t3.m_attributes[e5 * (t3.m_description.getTotalComponentCount() - 2) + t3.m_description.getPointAttributeOffset(o) - 2 + i2] : qe.getDefaultValue(s4);
}
function es(t3, e5, s4, i2, r) {
  if ((e5 < 0 || e5 > 1) && A(""), 0 === s4) return 0 === e5 ? 0 === i2 ? t3.m_XStart = r : 1 === i2 ? t3.m_YStart = r : A("") : 1 === e5 ? 0 === i2 ? t3.m_XEnd = r : 1 === i2 ? t3.m_YEnd = r : A("") : A(""), void t3.endPointModified();
  const o = qe.getComponentCount(s4);
  (i2 < 0 || i2 >= o) && A("");
  let a2 = t3.m_description.getAttributeIndex(s4);
  a2 < 0 && (t3.addAttribute(s4), a2 = t3.m_description.getAttributeIndex(s4)), t3.m_attributes[e5 * (t3.m_description.getTotalComponentCount() - 2) + t3.m_description.getPointAttributeOffset(a2) - 2 + i2] = r;
}
function ss(t3, e5) {
  if (t3 === e5) return;
  e5.isEmpty() && x("");
  const s4 = e5.getDescription();
  s4 !== t3.m_description && t3.mergeVertexDescription(s4);
  for (let n6 = 1, i2 = s4.getAttributeCount(); n6 < i2; n6++) {
    const i3 = s4.getSemantics(n6), r = qe.getComponentCount(i3);
    for (let s5 = 0; s5 < r; s5++) {
      let n7 = ts(e5, 0, i3, s5);
      es(t3, 0, i3, s5, n7), n7 = ts(e5, 1, i3, s5), es(t3, 1, i3, s5, n7);
    }
  }
}
function ns(t3, e5) {
  const s4 = S2();
  Y2(e5, t3.m_description, s4);
  let n6 = null;
  const i2 = e5.getTotalComponentCount() - 2, r = t3.m_description ? t3.m_description.getTotalComponentCount() - 2 : 0;
  if (i2 > 0 && (n6 = Yt(2 * i2, Number.NaN), Dt(n6, e5.getDefaultPointAttributes(), 0, 2, i2), Dt(n6, e5.getDefaultPointAttributes(), i2, 2, i2), null !== t3.m_description)) for (let o = 1; o < e5.getAttributeCount(); o++) {
    const a2 = s4[o];
    if (-1 !== a2) {
      const s5 = t3.m_description.getPointAttributeOffset(a2) - 2, h2 = e5.getPointAttributeOffset(o) - 2, u = qe.getComponentCount(e5.getSemantics(o));
      for (let e6 = 0; e6 < u; ++e6) n6[h2] = t3.m_attributes[s5], n6[i2 + h2] = t3.m_attributes[r + s5];
    }
  }
  t3.m_attributes = n6, t3.m_description = e5;
}
function is(t3) {
  return t3.absNorm() * Ls();
}
function rs2(t3, e5) {
  return Math.max(t3.absNorm(), e5.absNorm()) * Ls();
}
function os(t3, e5, s4) {
  const n6 = new De();
  t3.queryEnvelopeW(x2.unit(), n6);
  const i2 = new De();
  return e5.queryEnvelopeW(x2.unit(), i2), i2.inflate(s4), !n6.isIntersectingW(i2);
}
function as(t3, e5, s4) {
  const n6 = Qt(t3, s4), i2 = Qt(e5, s4);
  n6.sort((t4, e6) => t4.compare(e6)), i2.sort((t4, e6) => t4.compare(e6));
  for (let r = 0; r < 3; r++) {
    if (n6[r].compare(i2[r]) < 0) return -1;
    if (0 !== n6[r].compare(i2[r])) return 1;
  }
  return 0;
}
var hs = z3;
var us = class {
  constructor(t3) {
    if (t3.copy) {
      if (this.m_XStart = t3.copy.m_XStart, this.m_YStart = t3.copy.m_YStart, this.m_XEnd = t3.copy.m_XEnd, this.m_YEnd = t3.copy.m_YEnd, this.m_description = t3.copy.m_description, this.m_attributes = null, this.m_description) {
        this.m_description.getTotalComponentCount() - 2 && (this.m_attributes = t3.copy.m_attributes.slice());
      }
    } else {
      if (t3.move) return this.m_description = t3.move.m_description, t3.move.m_description = null, this.m_attributes = t3.move.m_attributes, t3.move.m_attributes = null, this.m_XStart = t3.move.m_XStart, this.m_YStart = t3.move.m_YStart, this.m_XEnd = t3.move.m_XEnd, void (this.m_YEnd = t3.move.m_YEnd);
      if (void 0 !== t3.XStart) return this.m_XStart = t3.XStart, this.m_YStart = t3.YStart, this.m_XEnd = t3.XEnd, this.m_YEnd = t3.YEnd, this.m_attributes = null, this.m_description = t3.vd ? t3.vd : M(), void (t3.vd && this.setDefaultAttributeValues());
      if (void 0 !== t3.ZStart) return this.m_XStart = t3.XStart, this.m_YStart = t3.YStart, this.m_XEnd = t3.XEnd, this.m_YEnd = t3.YEnd, this.m_description = t3.vd ? t3.vd : O2(), void (t3.vd ? (this.setDefaultAttributeValues(), this.addAttribute(1), this.m_attributes[0] = t3.ZStart, this.m_attributes[this.m_description.getTotalComponentCount() - 2] = t3.ZEnd) : this.m_attributes = [t3.ZStart, t3.ZEnd]);
      if (t3.start) return this.m_XStart = t3.start.x, this.m_YStart = t3.start.y, this.m_XEnd = t3.end.x, this.m_YEnd = t3.end.y, this.m_attributes = null, void (this.m_description = M());
      if (t3.start3D) return this.m_XStart = t3.start3D.x, this.m_YStart = t3.start3D.y, this.m_XEnd = t3.end3D.x, this.m_YEnd = t3.end3D.y, this.m_description = t3.vd ? t3.vd : O2(), void (t3.vd ? (this.setDefaultAttributeValues(), this.addAttribute(1), this.m_attributes[0] = t3.start3D.z, this.m_attributes[this.m_description.getTotalComponentCount() - 2] = t3.end3D.z) : this.m_attributes = [t3.start3D.z, t3.end3D.z]);
      b("bad constructor params"), this.m_XStart = this.m_YStart = this.m_XEnd = this.m_YEnd = Number.NaN;
    }
  }
  setDefaultAttributeValues() {
    const t3 = this.m_description.getTotalComponentCount() - 2;
    t3 > 0 && (null === this.m_attributes && (this.m_attributes = Yt(2 * t3, Number.NaN)), Dt(this.m_attributes, this.m_description.getDefaultPointAttributes(), 0, 2, t3), Dt(this.m_attributes, this.m_description.getDefaultPointAttributes(), t3, 2, t3));
  }
  absNormXYZ(t3) {
    return z("not implemented"), 0;
  }
  queryWeights(t3) {
  }
  snapControlPoints3D() {
    return z("not implemented"), false;
  }
  setCoordsForIntersector3D(t3, e5, s4) {
    z("not implemented");
  }
  transformAttribute(t3, e5, s4, n6, i2) {
    z("");
  }
  mergeVertexDescriptionImpl(t3) {
    const e5 = this.getDescription(), s4 = H2(e5, t3);
    this.assignVertexDescription(s4);
  }
  changeEndPoints(t3, e5) {
    const s4 = t3.getXY(), n6 = e5.getXY();
    this.changeEndPoints2D(s4, n6);
    let i2 = t3.getDescription();
    i2 !== this.getDescription() && this.mergeVertexDescription(i2), i2 = e5.getDescription(), i2 !== this.getDescription() && this.mergeVertexDescription(i2);
    for (let r = 1, o = i2.getAttributeCount(); r < o; r++) {
      const s5 = i2.getSemantics(r), n7 = hs.getComponentCount(s5);
      for (let i3 = 0; i3 < n7; i3++) {
        es(this, 0, s5, i3, t3.getAttributeAsDbl(s5, i3));
        es(this, 1, s5, i3, e5.getAttributeAsDbl(s5, i3));
      }
    }
  }
  getStartXY() {
    return new mi(this.m_XStart, this.m_YStart);
  }
  setStartXY(t3) {
    this.m_XStart = t3.x, this.m_YStart = t3.y, this.endPointModified();
  }
  setStartXYCoords(t3, e5) {
    this.m_XStart = t3, this.m_YStart = e5, this.endPointModified();
  }
  getStartXYZ() {
    return Oe(this, 0);
  }
  setStartXYZ(t3) {
    Je(this, 0, t3);
  }
  setStartXYZCoords(t3, e5, s4) {
    Je(this, 0, X.construct(t3, e5, s4));
  }
  queryStart(t3) {
    Ke(this, 0, t3);
  }
  setStart(t3) {
    $e(this, 0, t3);
  }
  setStart2D(t3) {
    this.setStartXY(t3);
  }
  getStartAttributeAsDbl(t3, e5) {
    return ts(this, 0, t3, e5);
  }
  getStartAttributeAsInt(t3, e5) {
    return n2(0), 0;
  }
  setStartAttribute(t3, e5, s4) {
    es(this, 0, t3, e5, s4);
  }
  setStartAttributesFromPoint(t3, e5) {
    const s4 = t3.getDescription();
    for (let n6 = e5 && s4.hasZ() ? 2 : 1, i2 = s4.getAttributeCount(); n6 < i2; ++n6) {
      const e6 = s4.getSemantics(n6), i3 = hs.getComponentCount(e6);
      for (let s5 = 0; s5 < i3; ++s5) {
        const n7 = t3.getAttributeAsDbl(e6, s5);
        this.setStartAttribute(e6, s5, n7);
      }
    }
  }
  setEndAttributesFromPoint(t3, e5) {
    const s4 = t3.getDescription();
    for (let n6 = e5 && s4.hasZ() ? 2 : 1, i2 = s4.getAttributeCount(); n6 < i2; ++n6) {
      const e6 = s4.getSemantics(n6), i3 = hs.getComponentCount(e6);
      for (let s5 = 0; s5 < i3; ++s5) {
        const n7 = t3.getAttributeAsDbl(e6, s5);
        this.setEndAttribute(e6, s5, n7);
      }
    }
  }
  getStartX() {
    return this.m_XStart;
  }
  getStartY() {
    return this.m_YStart;
  }
  getStartZ() {
    return n2(0), 0;
  }
  getEndX() {
    return this.m_XEnd;
  }
  getEndY() {
    return this.m_YEnd;
  }
  getEndZ() {
    return n2(0), 0;
  }
  getEndXY() {
    return new mi(this.m_XEnd, this.m_YEnd);
  }
  setEndXY(t3) {
    this.m_XEnd = t3.x, this.m_YEnd = t3.y, this.endPointModified();
  }
  setEndXYCoords(t3, e5) {
    this.m_XEnd = t3, this.m_YEnd = e5, this.endPointModified();
  }
  getEndXYZ() {
    return Oe(this, 1);
  }
  setEndXYZ(t3) {
    Je(this, 1, t3);
  }
  setEndXYZCoords(t3, e5, s4) {
    Je(this, 1, X.construct(t3, e5, s4));
  }
  queryEnd(t3) {
    Ke(this, 1, t3);
  }
  setEnd(t3) {
    $e(this, 1, t3);
  }
  setEnd2D(t3) {
    this.setEndXY(t3);
  }
  getEndAttributeAsDbl(t3, e5) {
    return ts(this, 1, t3, e5);
  }
  getEndAttributeAsInt(t3, e5) {
    return n2(0), Math.trunc(0);
  }
  setEndAttribute(t3, e5, s4) {
    es(this, 1, t3, e5, s4);
  }
  getDimension() {
    return 1;
  }
  copyTo(t3) {
    if (this === t3) return;
    t3.getGeometryType() !== this.getGeometryType() && P("");
    const s4 = t3;
    s4.assignVertexDescription(this.m_description), s4.m_attributes && Dt(s4.m_attributes, this.m_attributes, 0, 0, 2 * (this.m_description.getTotalComponentCount() - 2)), s4.m_XStart = this.m_XStart, s4.m_YStart = this.m_YStart, s4.m_XEnd = this.m_XEnd, s4.m_YEnd = this.m_YEnd, this.copyToImpl(s4);
  }
  isEmpty() {
    return this.isEmptyImpl();
  }
  isClosed() {
    return this.m_XStart === this.m_XEnd && this.m_YStart === this.m_YEnd;
  }
  setEmpty() {
  }
  calculateArea2D() {
    return 0;
  }
  queryInterval(t3, e5) {
    const s4 = x2.constructEmpty();
    return s4.vmin = ts(this, 0, t3, e5), s4.vmax = s4.vmin, s4.mergeNeCoordinate(ts(this, 1, t3, e5)), s4;
  }
  calculateLength3D(t3) {
    return n2(0), 0;
  }
  getCoord3D(t3) {
    return n2(0), {};
  }
  getCoord2D(t3) {
    const e5 = mi.getNAN();
    return this.queryCoord2D(t3, e5), e5;
  }
  queryCoord3D(t3, e5) {
    n2(0);
  }
  getCoordZ(t3) {
    return n2(0), 0;
  }
  queryCoord(t3, e5) {
    e5.assignVertexDescription(this.m_description), e5.setXY(this.getCoord2D(t3));
    for (let s4 = 1, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) {
      const n7 = this.m_description.getSemantics(s4), i2 = hs.getComponentCount(n7);
      for (let s5 = 0; s5 < i2; s5++) {
        const i3 = this.getAttributeAsDbl(t3, n7, s5);
        e5.setAttributeBasic(n7, s5, i3);
      }
    }
  }
  isCloserThanDistance(t3, e5, s4) {
    const n6 = n4.constructEmpty();
    this.queryLooseEnvelopeOnInterval(e5, n6);
    if (n6.distance(t3) > s4) return false;
    const i2 = this.getClosestCoordinateOnInterval(t3, e5, s4);
    return !Number.isNaN(i2) && mi.distance(t3, this.getCoord2D(i2)) <= s4;
  }
  isMonotoneQuickAndDirty() {
    return false;
  }
  isTrue3D() {
    return false;
  }
  getReversed() {
    const t3 = this.clone();
    return t3.reverse(), t3;
  }
  reverse() {
    this.m_XEnd = Pt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Pt(this.m_YStart, this.m_YStart = this.m_YEnd), this.reverseImpl();
    for (let t3 = 1, e5 = this.m_description.getAttributeCount(); t3 < e5; t3++) {
      const e6 = this.m_description.getSemantics(t3);
      for (let t4 = 0, s4 = hs.getComponentCount(e6); t4 < s4; t4++) {
        const s5 = ts(this, 0, e6, t4);
        es(this, 0, e6, t4, ts(this, 1, e6, t4)), es(this, 1, e6, t4, s5);
      }
    }
    return this.afterCompletedModification(), this;
  }
  isEmptyImpl() {
    return false;
  }
  isCircular() {
    return false;
  }
  distance(t3, e5, n6, i2) {
    if (!e5 && this.isIntersecting(t3, 0, false)) {
      if (null !== n6 || null !== i2) {
        const e6 = Yt(9, Number.NaN), r2 = Yt(9, Number.NaN), o2 = this.intersect(t3, null, e6, r2, 0);
        n2(o2 <= 9), 0 === o2 && b(""), null !== n6 && (n6[0] = e6[0]), null !== i2 && (i2[0] = r2[0]);
      }
      return 0;
    }
    let r, o = Number.MAX_VALUE, a2 = -1, u = o;
    return r = this.getStartXY(), a2 = t3.getClosestCoordinate(r, false), r.subThis(t3.getCoord2D(a2)), u = r.length(), u < o && (o = u, null !== i2 && (i2[0] = a2), null !== n6 && (n6[0] = 0)), r = this.getEndXY(), a2 = t3.getClosestCoordinate(r, false), r.subThis(t3.getCoord2D(a2)), u = r.length(), u < o && (o = u, null !== i2 && (i2[0] = a2), null !== n6 && (n6[0] = 1)), r = t3.getStartXY(), a2 = this.getClosestCoordinate(r, false), r.subThis(this.getCoord2D(a2)), u = r.length(), u < o && (o = u, null !== n6 && (n6[0] = a2), null !== i2 && (i2[0] = 0)), r = t3.getEndXY(), a2 = this.getClosestCoordinate(r, false), r.subThis(this.getCoord2D(a2)), u = r.length(), u < o && (o = u, null !== n6 && (n6[0] = a2), null !== i2 && (i2[0] = 1)), o;
  }
  calculateSubLengthFromStart(t3) {
    return this.tToLength(t3);
  }
  calculateSubLength(t3, e5) {
    return e5 === t3 ? 0 : this.tToLength(e5) - this.tToLength(t3);
  }
  static recalculateParentT(t3, e5, s4) {
    return Q(t3, e5, s4);
  }
  moveTo(t3) {
    const e5 = this.isClosed(), s4 = new x3();
    s4.setShift(t3.sub(this.getStartXY())), this.applyTransformation(s4), e5 ? this.changeEndPoints2D(t3, t3) : this.changeEndPoints2D(t3, this.getEndXY());
  }
  moveTo3D(t3) {
    n2(0);
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t3) {
    ns(this, t3);
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e5 = V2(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e5 = k3(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  swap(t3) {
    if (this === t3) return;
    t3.getGeometryType() !== this.getGeometryType() && P("wrong geometry type");
    const s4 = t3;
    s4.m_description = Pt(this.m_description, this.m_description = s4.m_description), s4.m_XStart = Pt(this.m_XStart, this.m_XStart = s4.m_XStart), s4.m_YStart = Pt(this.m_YStart, this.m_YStart = s4.m_YStart), s4.m_XEnd = Pt(this.m_XEnd, this.m_XEnd = s4.m_XEnd), s4.m_YEnd = Pt(this.m_YEnd, this.m_YEnd = s4.m_YEnd), s4.m_attributes = Pt(this.m_attributes, this.m_attributes = s4.m_attributes), this.swapImpl(s4);
  }
  equals(t3, e5) {
    if (this.getGeometryType() !== t3.getGeometryType()) return false;
    const s4 = void 0 === e5;
    s4 && (e5 = 0);
    const n6 = t3;
    if (this === n6) return true;
    if (this.m_description !== n6.m_description) return false;
    if (Math.abs(this.m_XStart - n6.m_XStart) > e5 || Math.abs(this.m_XEnd - n6.m_XEnd) > e5 || Math.abs(this.m_YStart - n6.m_YStart) > e5 || Math.abs(this.m_YEnd - n6.m_YEnd) > e5) return false;
    for (let i2 = 0, r = 2 * (this.m_description.getTotalComponentCount() - 2); i2 < r; i2++) if (!cs(this.m_attributes[i2], n6.m_attributes[i2], e5)) return false;
    return s4 ? this.equalsImpl(n6) : this.equalsImplTol(n6, e5);
  }
  getImpl() {
    return this;
  }
  setAttributeBasic(t3, s4, n6) {
    if (this.addAttribute(t3), 0 === t3 && this.isCurve()) {
      (s4 < 0 || s4 > 1) && P("");
      const t4 = new x3(), i2 = 0 === s4 ? n6 : 0, r = 1 === s4 ? n6 : 0;
      t4.setShiftCoords(i2, r), 0 === s4 ? t4.xx = 0 : t4.yy = 0, this.applyTransformation(t4);
    } else this.setStartAttribute(t3, s4, n6), this.setEndAttribute(t3, s4, n6);
  }
  replaceNaNs(t3, e5) {
    if (this.addAttribute(t3), this.isEmpty()) return;
    const s4 = hs.getComponentCount(t3);
    for (let n6 = 0; n6 < s4; n6++) {
      const s5 = this.getStartAttributeAsDbl(t3, n6);
      Number.isNaN(s5) && this.setStartAttribute(t3, n6, e5);
      const i2 = this.getEndAttributeAsDbl(t3, n6);
      Number.isNaN(i2) && this.setEndAttribute(t3, n6, e5);
    }
  }
};
us.s_maxMonotonicPartParams = 8;
var ms = class extends t {
  constructor(t3, e5) {
    super(), this.m_index = -1, this.gc = t3, this.dim = e5;
  }
  next() {
    for (; ; ) {
      if (this.m_index >= this.gc.getGeometryCount()) return null;
      if (this.m_index++, this.m_index === this.gc.getGeometryCount()) return null;
      const t3 = this.gc.getGeometry(this.m_index);
      if (-1 === this.dim || 1 << t3.getDimension() & this.dim) return t3;
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
var ls2 = class _ls {
  constructor(t3) {
    this.m_geoms = [], this.m_description = M(), t3 && (t3.vd ? this.m_description = t3.vd : t3.copy ? t3.copy.copyTo(this) : P("constructor argument not recognized"));
  }
  getGeometryCount() {
    return this.m_geoms.length;
  }
  reserve(t3) {
  }
  addGeometry(t3) {
    if (t3.getGeometryType() === a.enumGeometryCollection) {
      const e5 = t3;
      for (let t4 = 0, s4 = e5.getGeometryCount(); t4 < s4; t4++) this.addGeometry(e5.getGeometry(t4));
    } else this.m_geoms.push(t3.clone()), this.mergeVertexDescription(t3.getDescription());
  }
  addCursor(t3) {
    for (let e5 = t3.next(); null !== e5; e5 = t3.next()) this.addGeometry(e5);
  }
  getGeometry(t3) {
    return (t3 < 0 || t3 >= this.m_geoms.length) && P("Geometry_collection.get_geometry"), this.m_geoms[t3];
  }
  modifiedElementIndex(t3) {
    this.mergeVertexDescription(this.getGeometry(t3).getDescription());
  }
  modifiedElement(t3) {
    this.mergeVertexDescription(t3.getDescription());
  }
  getGeometryType() {
    return a.enumGeometryCollection;
  }
  getDimension() {
    let t3 = 0;
    for (const e5 of this.m_geoms) t3 = Math.max(t3, e5.getDimension());
    return t3;
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t3) {
    this.m_description !== t3 && this.assignVertexDescriptionImpl(t3);
  }
  assignVertexDescriptionImpl(t3) {
    for (const e5 of this.m_geoms) e5.assignVertexDescription(t3);
    this.m_description = t3;
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e5 = V2(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e5 = k3(this.m_description, t3);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  queryInterval(t3, e5) {
    let s4 = new x2();
    const n6 = new x2();
    n6.setEmpty();
    for (const i2 of this.m_geoms) s4 = i2.queryInterval(t3, e5), n6.merge(s4);
    return n6;
  }
  queryEnvelope(t3) {
    if (4 === t3.m_EnvelopeType) {
      const e5 = new re();
      t3.setEmpty(), t3.assignVertexDescription(this.m_description);
      for (const s4 of this.m_geoms) s4.queryEnvelope(e5), t3.merge(e5);
    } else if (2 === t3.m_EnvelopeType) {
      const e5 = new n4();
      t3.setEmpty();
      for (const s4 of this.m_geoms) s4.queryEnvelope(e5), t3.mergeEnvelope2D(e5);
    }
    z("3d envelope case not implemented");
  }
  queryLooseEnvelope(t3) {
    if (2 === t3.m_EnvelopeType) {
      const e5 = new n4();
      t3.setEmpty();
      for (const s4 of this.m_geoms) s4.queryLooseEnvelope(e5), t3.mergeEnvelope2D(e5);
    }
    z("3d not impl");
  }
  isEmpty() {
    return 0 === this.m_geoms.length;
  }
  setEmpty() {
    this.m_geoms.length = 0;
  }
  applyTransformation(t3) {
    if (1 === t3.m_TransformationType) for (const e5 of this.m_geoms) e5.applyTransformation(t3);
    z("3d xform not impl");
  }
  transformAttribute(t3, e5, s4, n6, i2) {
    for (const r of this.m_geoms) r.transformAttribute(t3, e5, s4, n6, i2);
  }
  createInstance() {
    return new _ls({ vd: this.getDescription() });
  }
  copyTo(t3) {
    t3.getGeometryType() !== a.enumGeometryCollection && P("");
    const s4 = t3;
    if (s4 !== this) {
      s4.m_geoms.length = 0, s4.assignVertexDescription(this.m_description);
      for (const t4 of this.m_geoms) s4.m_geoms.push(t4.clone());
    }
  }
  calculateArea2D() {
    const t3 = new n3(0);
    for (const e5 of this.m_geoms) t3.pe(e5.calculateArea2D());
    return t3.getResult();
  }
  calculateLength2D() {
    const t3 = new n3(0);
    for (const e5 of this.m_geoms) t3.pe(e5.calculateLength2D());
    return t3.getResult();
  }
  calculateLength3D(t3) {
    return n2(0), 0;
  }
  getBoundary() {
    const t3 = this.createInstance(), e5 = t3;
    for (const s4 of this.m_geoms) {
      const t4 = s4.getBoundary();
      t4 && e5.m_geoms.push(t4);
    }
    return t3;
  }
  clone() {
    return new _ls({ copy: this });
  }
  equals(t3, e5) {
    if (t3 === this) return true;
    if (t3.getGeometryType() !== a.enumGeometryCollection) return false;
    const s4 = t3;
    if (this.m_description !== s4.m_description) return false;
    if (this.m_geoms.length !== s4.m_geoms.length) return false;
    for (let n6 = 0; n6 < this.m_geoms.length; ++n6) if (!this.m_geoms[n6].equals(s4.m_geoms[n6], e5)) return false;
    return true;
  }
  swap(t3) {
    t3.getGeometryType() !== a.enumGeometryCollection && P("");
    const s4 = t3;
    s4 !== this && (this.m_geoms = Pt(s4.m_geoms, s4.m_geoms = this.m_geoms));
  }
  setAttributeBasic(t3, e5, s4) {
    for (const n6 of this.m_geoms) n6.setAttributeBasic(t3, e5, s4);
  }
  replaceNaNs(t3, e5) {
    for (const s4 of this.m_geoms) s4.replaceNaNs(t3, e5);
  }
  getImpl() {
    return this;
  }
  mergeVertexDescriptionImpl(t3) {
    const e5 = this.getDescription(), s4 = H2(e5, t3);
    this.assignVertexDescription(s4);
  }
};
function cs2(t3, e5 = -1) {
  return new ms(t3, e5);
}
ls2.type = a.enumGeometryCollection;
var gs = class extends us {
  constructor(t3) {
    super(t3);
  }
};
var ds2 = class extends gs {
  isTrue3D() {
    return true;
  }
  constructor(t3) {
    super(t3);
  }
};
function _s2(t3, e5, s4) {
  ps(e5, t3.getStartXY(), t3.getEndXY(), s4);
}
function ps(t3, e5, s4, n6) {
  Y(e5, s4, t3, n6);
}
function fs2(t3, e5) {
  return Q(t3.m_XStart, t3.m_XEnd, e5);
}
function Ps2(t3, e5) {
  return Q(t3.m_YStart, t3.m_YEnd, e5);
}
function ys(t3, e5) {
  const s4 = t3.getStartZ(), n6 = t3.getEndZ();
  return Q(s4, n6, e5);
}
function xs(t3, e5, s4) {
  const n6 = Ye.constructPoint2D(t3.getStartXY()), i2 = Ye.constructPoint2D(t3.getEndXY());
  s4.setCoordsE(i2.x.subE(n6.x), i2.y.subE(n6.y));
}
function Cs(t3, e5, s4) {
  e5.value() <= 0.5 ? O(2, Ye.constructPoint2D(t3.getStartXY()), Ye.constructPoint2D(t3.getEndXY()), e5, s4) : G2(2, Ye.constructPoint2D(t3.getStartXY()), Ye.constructPoint2D(t3.getEndXY()), e5, s4);
}
function vs2(t3, e5, s4) {
  t3.m_XStart = e5.x, t3.m_YStart = e5.y, t3.m_XEnd = s4.x, t3.m_YEnd = s4.y, t3.afterCompletedModification();
}
function bs2(t3, e5) {
  const s4 = t3.getStartXYZ();
  s4.z *= e5;
  const n6 = t3.getEndXYZ();
  return n6.z *= e5, s4.norm(1) + n6.norm(1);
}
function Ss2(t3) {
  if (t3.m_YEnd < t3.m_YStart || t3.m_YEnd === t3.m_YStart && t3.m_XEnd < t3.m_XStart) {
    t3.m_XEnd = Pt(t3.m_XStart, t3.m_XStart = t3.m_XEnd), t3.m_YEnd = Pt(t3.m_YStart, t3.m_YStart = t3.m_YEnd);
    for (let e5 = 0, s4 = t3.m_description.getTotalComponentCount() - 2; e5 < s4; e5++) t3.m_attributes[e5 + s4] = Pt(t3.m_attributes[e5], t3.m_attributes[e5] = t3.m_attributes[e5 + s4]);
  }
}
function Es(t3, e5, s4, n6) {
  let i2 = 0;
  if ((t3.m_XStart === e5.m_XStart && t3.m_YStart === e5.m_YStart || t3.m_XStart === e5.m_XEnd && t3.m_YStart === e5.m_YEnd) && (i2++, !n6)) return 1;
  if (t3.m_XEnd === e5.m_XStart && t3.m_YEnd === e5.m_YStart || t3.m_XEnd === e5.m_XEnd && t3.m_YEnd === e5.m_YEnd) {
    if (i2++, 2 === i2) return 2;
    if (!n6) return 1;
  }
  return e5.isIntersectingPoint(t3.getStartXY(), s4, true) || e5.isIntersectingPoint(t3.getEndXY(), s4, true) || t3.isIntersectingPoint(e5.getStartXY(), s4, true) || t3.isIntersectingPoint(e5.getEndXY(), s4, true) ? 4 : n6 && i2 ? 0 : As2(t3, e5) ? 4 : 0;
}
function Ds2(t3, e5, s4, n6, i2, r, o, a2) {
  null !== n6 && Ft(n6, 2, Number.NaN), null !== i2 && Ft(i2, 2, Number.NaN), null !== s4 && Lt(s4, mi, 2);
  const h2 = ws(t3, e5, 2, s4, n6, i2, r, o, a2);
  return n6 && (n6.length = h2), i2 && (i2.length = h2), s4 && (s4.length = h2), h2;
}
function ws(t3, e5, s4, n6, i2, r, o, a2, h2) {
  const u = Is(t3, e5.getStartXY(), o, false), m3 = Is(t3, e5.getEndXY(), o, false), l2 = Is(e5, t3.getStartXY(), o, false), c = Is(e5, t3.getEndXY(), o, false);
  let g2 = 0, d2 = 0;
  if (!Number.isNaN(u)) {
    let s5 = false;
    a2 && Vs(u, 0, 1) && t3.getCoord2D(u).isEqualPoint2D(e5.getStartXY()) && (g2++, s5 = true), s5 || (i2 && (i2[d2] = u), r && (r[d2] = 0), n6 && n6[d2].setCoords(e5.m_XStart, e5.m_YStart), d2++);
  }
  if (!Number.isNaN(m3)) {
    let o2 = false;
    a2 && Vs(m3, 0, 1) && t3.getCoord2D(m3).isEqualPoint2D(e5.getEndXY()) && (g2++, o2 = true), o2 || (s4 > d2 && (i2 && (i2[d2] = m3), r && (r[d2] = 1), n6 && n6[d2].setCoords(e5.m_XEnd, e5.m_YEnd)), d2++);
  }
  if (2 !== d2 && !Number.isNaN(l2) && !(0 === u && 0 === l2 || 0 === m3 && 1 === l2)) {
    let o2 = false;
    a2 && Vs(l2, 0, 1) && e5.getCoord2D(l2).isEqualPoint2D(t3.getStartXY()) && (g2++, o2 = true), o2 || (s4 > d2 && (i2 && (i2[d2] = 0), r && (r[d2] = l2), n6 && n6[d2].setCoords(t3.m_XStart, t3.m_YStart)), d2++);
  }
  if (2 !== d2 && !Number.isNaN(c) && !(1 === u && 0 === c || 1 === m3 && 1 === c)) {
    let o2 = false;
    a2 && Vs(c, 0, 1) && e5.getCoord2D(c).isEqualPoint2D(t3.getEndXY()) && (g2++, o2 = true), o2 || (s4 > d2 && (i2 && (i2[d2] = 1), r && (r[d2] = c), n6 && n6[d2].setCoords(e5.m_XEnd, e5.m_YEnd)), d2++);
  }
  if (d2 > 0) return h2 && (r = Pt(i2, i2 = r)), 2 === d2 && s4 >= 2 && i2 && i2[0] > i2[1] && (i2[1] = Pt(i2[0], i2[0] = i2[1]), r && (r[1] = Pt(r[0], r[0] = r[1])), n6 && (n6[1] = Pt(n6[0], n6[0] = n6[1]))), d2;
  if (g2 > 0) return 0;
  const _ = qs2(t3, e5, o);
  return Number.isNaN(_.x) ? 0 : (n6 && (n6[0] = t3.getCoord2D(_.x)), i2 && (i2[0] = _.x), r && (r[0] = _.y), 1);
}
function As2(t3, e5) {
  const s4 = Ms(t3, e5.m_XStart, e5.m_YStart), n6 = Ms(t3, e5.m_XEnd, e5.m_YEnd);
  if (s4 < 0 && n6 < 0 || s4 > 0 && n6 > 0) return false;
  const i2 = Ms(e5, t3.m_XStart, t3.m_YStart), r = Ms(e5, t3.m_XEnd, t3.m_YEnd);
  if (i2 < 0 && r < 0 || i2 > 0 && r > 0) return false;
  return Xs2(t3) > Xs2(e5) ? Ns(t3, e5) : Ns(e5, t3);
}
function Is(t3, e5, s4, n6) {
  const i2 = mi.getNAN(), r = mi.getNAN();
  let o = false;
  t3.m_YEnd < t3.m_YStart || t3.m_YEnd === t3.m_YStart && t3.m_XEnd < t3.m_XStart ? (i2.setCoords(t3.m_XEnd, t3.m_YEnd), r.setCoords(t3.m_XStart, t3.m_YStart), o = true) : (i2.setCoords(t3.m_XStart, t3.m_YStart), r.setCoords(t3.m_XEnd, t3.m_YEnd));
  const a2 = o ? 1 : 0, h2 = o ? 0 : 1, u = mi.getNAN();
  u.setSub(e5, i2);
  let m3 = u.length(), l2 = 3 * m3 * Qs();
  if (m3 <= Math.max(s4, l2)) return n6 && 0 === m3 ? Number.NaN : a2;
  if (u.setSub(e5, r), m3 = u.length(), l2 = 3 * m3 * Qs(), m3 <= Math.max(s4, l2)) return n6 && 0 === m3 ? Number.NaN : h2;
  u.setCoords(r.x - i2.x, r.y - i2.y);
  const c = u.length();
  if (c > 0) {
    const t4 = 1 / c;
    u.scale(t4);
    const n7 = mi.getNAN();
    n7.setSub(e5, i2);
    const m4 = n7.dotProduct(u), l3 = 8 * n7.dotProductAbs(u) * Qs();
    u.leftPerpendicularThis();
    const g2 = n7.dotProduct(u), d2 = 8 * n7.dotProductAbs(u) * Qs(), _ = Math.max(s4, l3);
    if (m4 < -_ || m4 > c + _) return Number.NaN;
    const p3 = Math.max(s4, d2);
    if (Math.abs(g2) <= p3) {
      let n8 = m4 * t4;
      n8 = Us(n8, 0, 1);
      const u2 = mi.getNAN();
      if (ps(n8, i2, r, u2), mi.distance(u2, e5) <= s4) {
        if (n8 < 0.5) {
          if (mi.distance(u2, i2) <= s4 && mi.distance(e5, i2) <= s4) return a2;
        } else if (mi.distance(u2, r) <= s4 && mi.distance(e5, r) <= s4) return h2;
        return o ? 1 - n8 : n8;
      }
    }
  }
  return Number.NaN;
}
function Ms(t3, e5, s4) {
  const n6 = mi.getNAN();
  n6.setCoords(e5, s4), n6.subThis(t3.getStartXY());
  const i2 = mi.getNAN();
  i2.setSub(t3.getEndXY(), t3.getStartXY());
  const r = i2.crossProduct(n6), o = 4 * Qs() * (Math.abs(i2.x * n6.y) + Math.abs(i2.y * n6.x));
  return r > o ? -1 : r < -o ? 1 : 0;
}
function Ys2(t3, e5, s4, n6) {
  const i2 = n6 ? t3.m_XStart : t3.m_XEnd, r = n6 ? t3.m_YStart : t3.m_YEnd, o = mi.getNAN();
  o.x = e5.getEndX() - i2, o.y = e5.getEndY() - r;
  if (s4.dotProduct(o) > 3 * Qs() * s4.dotProductAbs(o)) {
    o.x = e5.getStartX() - i2, o.y = e5.getStartY() - r;
    return s4.dotProduct(o) <= 3 * Qs() * s4.dotProductAbs(o);
  }
  return true;
}
function Ns(t3, e5) {
  const s4 = mi.getNAN();
  return s4.x = t3.m_XEnd - t3.m_XStart, s4.y = t3.m_YEnd - t3.m_YStart, !!Ys2(t3, e5, s4, false) && (s4.negateThis(), !!Ys2(t3, e5, s4, true));
}
function Xs2(t3) {
  const e5 = t3.m_XStart - t3.m_XEnd, s4 = t3.m_YStart - t3.m_YEnd;
  return e5 * e5 + s4 * s4;
}
function qs2(t3, e5, s4) {
  const n6 = t3.m_XEnd - t3.m_XStart, i2 = t3.m_YEnd - t3.m_YStart, r = e5.m_XEnd - e5.m_XStart, o = e5.m_YEnd - e5.m_YStart, a2 = r * i2 - n6 * o;
  if (0 === a2) return mi.getNAN();
  const h2 = 4 * Qs() * (Math.abs(r * i2) + Math.abs(n6 * o)), u = e5.m_XStart - t3.m_XStart, m3 = e5.m_YStart - t3.m_YStart, l2 = r * m3 - u * o, c = 4 * Qs() * (Math.abs(r * m3) + Math.abs(u * o)), g2 = l2 / a2, d2 = Math.abs(a2), _ = (c * d2 + h2 * Math.abs(l2)) / (a2 * a2) + Qs() * Math.abs(g2);
  if (g2 < -_ || g2 > 1 + _) return mi.getNAN();
  const p3 = n6 * m3 - u * i2, f3 = p3 / a2, P5 = (4 * Qs() * (Math.abs(n6 * m3) + Math.abs(u * i2)) * d2 + h2 * Math.abs(p3)) / (a2 * a2) + Qs() * Math.abs(f3);
  if (f3 < -P5 || f3 > 1 + P5) return mi.getNAN();
  let y2 = Us(g2, 0, 1), x4 = Us(f3, 0, 1);
  const C3 = mi.getNAN();
  _s2(t3, y2, C3);
  const v3 = mi.getNAN();
  if (_s2(e5, x4, v3), !s4 || mi.distance(C3, v3) > s4) {
    const n7 = mi.getNAN();
    Y(C3, v3, 0.5, n7), y2 = t3.getClosestCoordinate(n7, false), x4 = e5.getClosestCoordinate(n7, false);
    const i3 = mi.getNAN();
    _s2(t3, y2, i3);
    const r2 = mi.getNAN();
    _s2(e5, x4, r2), i3.subThis(r2);
    const o2 = i3.length(), a3 = (t3.absNorm() + e5.absNorm()) * Ls();
    if (o2 > Math.max(s4, a3)) return mi.getNAN();
  }
  return new mi(y2, x4);
}
var Fs = class {
  constructor(t3) {
    if (this.m_segFlagStream = null, this.m_xyStream = null, this.m_bCirculator = false, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_nextPathIndex = 0, this.m_currentPathIndex = -1, this.m_parent = t3.parent, this.m_buffer = new this.m_parent.m_segmentBufferCTor(), this.m_description = t3.parent.getDescription(), this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex), void 0 !== t3.pointIndex) {
      (t3.pointIndex < 0 || t3.pointIndex >= t3.parent.getPointCount()) && A("");
      const e5 = t3.parent.getPathIndexFromPointIndex(t3.pointIndex);
      this.m_currentPathIndex = e5, this.m_nextPathIndex = e5 + 1, this.m_nextSegmentIndex = t3.pointIndex - t3.parent.getPathStart(e5), this.m_segmentCount = this.getSegmentCount(this.m_currentPathIndex);
    } else if (void 0 !== t3.pathIndex) {
      (t3.pathIndex < 0 || t3.pathIndex >= t3.parent.getPathCount() || t3.segmentIndex < 0) && A("");
      const e5 = t3.parent.isClosedPath(t3.pathIndex) ? 0 : 1;
      t3.segmentIndex >= t3.parent.getPathSize(t3.pathIndex) - e5 && A(""), this.m_nextSegmentIndex = t3.segmentIndex, this.m_currentPathIndex = t3.pathIndex, this.m_nextPathIndex = this.m_nextSegmentIndex + 1, this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex);
    }
    this.prepare(), this.m_pathBegin = -1, this.m_bCurrentPathClosed = false, this.m_bStripAttributes = false, this.m_prevPathIndex = -1, this.m_prevSegmentIndex = -1, this.m_bNeedsUpdate = false, this.m_currentPathIndex > -1 && (this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex));
  }
  stripAttributes() {
    this.m_bStripAttributes = true;
  }
  prepare() {
    this.m_bCirculator = false, this.m_parent.isEmptyImpl() ? (this.m_segFlagStream = null, this.m_xyStream = null) : (this.m_segFlagStream = this.m_parent.getSegmentFlagsStreamRef(), this.m_xyStream = this.m_parent.getAttributeStreamRef(0));
  }
  nextPath() {
    return this.m_currentPathIndex = this.m_nextPathIndex, !(this.m_currentPathIndex >= this.m_parent.getPathCount()) && (this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_segmentCount = this.getSegmentCount(this.m_currentPathIndex), this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex), this.m_nextPathIndex++, true);
  }
  previousPath() {
    return 0 !== this.m_nextPathIndex && (this.m_nextPathIndex--, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex), this.m_currentPathIndex = this.m_nextPathIndex, this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex), this.resetToLastSegment(), true);
  }
  getSegmentCount(t3) {
    return this.m_parent.isEmptyImpl() ? 0 : this.m_parent.getSegmentCountPath(t3);
  }
  resetToFirstPath() {
    this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_nextPathIndex = 0, this.m_currentPathIndex = -1, this.m_pathBegin = -1, this.m_bCurrentPathClosed = false;
  }
  resetToLastPath() {
    this.m_nextPathIndex = this.m_parent.getPathCount(), this.m_currentPathIndex = -1, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_pathBegin = -1;
  }
  resetToPath(t3) {
    (t3 < 0 || t3 > this.m_parent.getPathCount()) && A(""), this.m_nextPathIndex = t3, this.m_currentPathIndex = -1, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_pathBegin = -1, this.m_bCurrentPathClosed = false;
  }
  isLastPath() {
    return this.m_currentPathIndex === this.m_parent.getPathCount() - 1;
  }
  isFirstSegmentInPath() {
    return 0 === this.m_currentSegmentIndex;
  }
  isLastSegmentInPath() {
    return this.m_currentSegmentIndex === this.m_segmentCount - 1;
  }
  resetToFirstSegment() {
    this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0;
  }
  resetToLastSegment() {
    this.m_nextSegmentIndex = this.m_segmentCount, this.m_currentSegmentIndex = -1;
  }
  resetTo(t3) {
    this.m_parent !== t3.m_parent && C(""), this.m_currentSegmentIndex = t3.m_currentSegmentIndex, this.m_nextSegmentIndex = t3.m_nextSegmentIndex, this.m_currentPathIndex = t3.m_currentPathIndex, this.m_nextPathIndex = t3.m_nextPathIndex, this.m_segmentCount = t3.m_segmentCount, this.m_bCirculator = t3.m_bCirculator, this.m_pathBegin = t3.m_pathBegin, this.m_bCurrentPathClosed = t3.m_bCurrentPathClosed, this.m_bStripAttributes = t3.m_bStripAttributes, this.m_description = t3.m_description;
  }
  resetToVertex(t3, e5) {
    if (this.m_currentPathIndex >= 0 && this.m_currentPathIndex < this.m_parent.getPathCount()) {
      const e6 = this.getPathBegin();
      if (t3 >= e6 && t3 < this.m_parent.getPathEnd(this.m_currentPathIndex)) return this.m_currentSegmentIndex = -1, void (this.m_nextSegmentIndex = t3 - e6);
    }
    let s4;
    s4 = e5 >= 0 && e5 < this.m_parent.getPathCount() && t3 >= this.m_parent.getPathStart(e5) && t3 < this.m_parent.getPathEnd(e5) ? e5 : this.m_parent.getPathIndexFromPointIndex(t3), this.m_nextPathIndex = s4 + 1, this.m_currentPathIndex = s4, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = t3 - this.m_parent.getPathStart(s4), this.m_segmentCount = this.getSegmentCount(s4), this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex);
  }
  hasNextSegment() {
    return this.m_nextSegmentIndex < this.m_segmentCount;
  }
  hasPreviousSegment() {
    return this.m_nextSegmentIndex > 0;
  }
  nextSegment() {
    return this.m_currentSegmentIndex !== this.m_nextSegmentIndex && this.updateSegment(), this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : (this.m_nextSegmentIndex === this.m_segmentCount && A("Segment_iterator_impl::next_segment"), this.m_nextSegmentIndex++), this.m_buffer.get();
  }
  previousSegment() {
    return this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_segmentCount + this.m_nextSegmentIndex - 1) % this.m_segmentCount : (0 === this.m_nextSegmentIndex && A(""), this.m_nextSegmentIndex--), this.m_nextSegmentIndex !== this.m_currentSegmentIndex && this.updateSegment(), this.m_buffer.get();
  }
  nextCurve() {
    if (!this.m_parent.hasNonLinearSegments()) return this.resetToLastSegment(), null;
    let t3 = 0;
    for (; ; ) {
      if (this.m_nextSegmentIndex === this.m_segmentCount || t3 === this.m_segmentCount) return null;
      const e5 = this.getPathBegin() + this.m_nextSegmentIndex;
      if (1 !== (31 & this.m_segFlagStream.read(e5))) {
        this.updateSegment();
        break;
      }
      this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : this.m_nextSegmentIndex++, t3++;
    }
    return this.m_currentSegmentIndex !== this.m_nextSegmentIndex && this.updateSegment(), this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : (this.m_nextSegmentIndex === this.m_segmentCount && A(""), this.m_nextSegmentIndex++), this.m_buffer.get();
  }
  getPathBegin() {
    return this.m_pathBegin;
  }
  getPathIndex() {
    return this.m_currentPathIndex;
  }
  getStartPointIndex() {
    return this.getPathBegin() + this.m_currentSegmentIndex;
  }
  getEndPointIndex() {
    return this.isClosingSegment() ? this.getPathBegin() : this.getStartPointIndex() + 1;
  }
  updateSegment() {
    (this.m_nextSegmentIndex < 0 || this.m_nextSegmentIndex >= this.m_segmentCount || this.m_currentPathIndex < 0) && A(""), this.m_currentSegmentIndex = this.m_nextSegmentIndex, this.m_parent.getSegmentFromPath(this.m_currentPathIndex, this.m_currentSegmentIndex, this.m_buffer, this.m_bStripAttributes);
  }
  isClosingSegment() {
    return this.m_bCurrentPathClosed && this.m_currentSegmentIndex === this.m_segmentCount - 1;
  }
  isCurve() {
    if (null !== this.m_segFlagStream) {
      return 1 !== (31 & this.m_segFlagStream.read(this.m_currentSegmentIndex));
    }
    return false;
  }
  isPathClosed() {
    return this.m_bCurrentPathClosed;
  }
  setCirculator(t3) {
    this.m_bCirculator = t3;
  }
  getImpl() {
    return this;
  }
};
var Vs2 = class _Vs {
  constructor(t3) {
    this.m_rasterizedGeometry = null, this.m_quadTree = null, this.m_quadTreeForPaths = null, this.m_refCount = 1, t3 && t3.copyTo(this);
  }
  getRasterizedGeometry() {
    return this.m_rasterizedGeometry;
  }
  copyTo(t3) {
    t3 !== this && (n2(t3.uniqueUse()), t3.m_quadTree = this.m_quadTree, t3.m_quadTreeForPaths = this.m_quadTreeForPaths, t3.m_rasterizedGeometry = this.m_rasterizedGeometry);
  }
  clone() {
    const t3 = new _Vs();
    return this.copyTo(t3), t3;
  }
  uniqueUse() {
    return 1 === this.m_refCount;
  }
  addRef() {
    ++this.m_refCount;
  }
  release() {
    0 === --this.m_refCount && (this.m_rasterizedGeometry = null, this.m_quadTree = null, this.m_quadTreeForPaths = null);
  }
  setRasterizedGeometry(t3) {
    n2(this.uniqueUse());
  }
  setQuadTree(t3) {
    n2(this.uniqueUse()), this.m_quadTree = t3;
  }
  setQuadTreeForPaths(t3) {
    n2(this.uniqueUse()), this.m_quadTreeForPaths = t3;
  }
  getQuadTree() {
    return this.m_quadTree;
  }
  getQuadTreeForPaths() {
    return this.m_quadTreeForPaths;
  }
};
function Ls2(t3) {
  return !(t3.isEmpty() || t3.getGeometryType() !== a.enumPolyline && t3.getGeometryType() !== a.enumPolygon) && !(t3.getPointCount() < 20);
}
function Rs(t3) {
  return !(t3.isEmpty() || t3.getGeometryType() !== a.enumPolyline && t3.getGeometryType() !== a.enumPolygon) && !(t3.getPointCount() < 20);
}
function zs2(t3, e5) {
  return t3.readPoint2D(e5 + 4);
}
function Bs2(t3) {
  const e5 = t3.getGeometryType();
  return e5 === a.enumEllipticArc ? 10 : e5 === a.enumBezier ? 4 : e5 === a.enumRationalBezier2 ? 5 : e5 === a.enumBezier2 ? 2 : void b("");
}
function ks(t3) {
  const e5 = 31 & t3;
  return 4 === e5 ? 10 : 2 === e5 ? 4 : 8 === e5 ? 5 : 16 === e5 ? 2 : 0;
}
function Gs2(t3, e5, s4, n6) {
  const i2 = t3.getPathStart(e5), r = t3.getPathEnd(e5);
  if (r - i2 < 3) return;
  const o = 2 * i2, a2 = mi.getNAN();
  s4.queryPoint2D(o, a2);
  const h2 = a2.x, u = a2.y, m3 = mi.getNAN();
  s4.queryPoint2D(o + 2, m3);
  const l2 = mi.getNAN();
  for (let c = o + 4, g2 = 2 * r; c < g2; c += 2) s4.queryPoint2D(c, l2), n6.pe((l2.x - a2.x) * (m3.y - u)), a2.setCoordsPoint2D(m3), m3.setCoordsPoint2D(l2);
  n6.pe((h2 - a2.x) * (m3.y - u));
}
function Ws2(t3, e5, s4) {
  for (; e5.hasNextSegment(); ) {
    const t4 = e5.nextCurve();
    if (null === t4) break;
    s4.pe(2 * t4.calculateArea2DHelper());
  }
}
var js2 = z3;
var Zs2 = class {
  static toSegType(t3) {
    let e5 = 0;
    switch (t3) {
      case a.enumLine:
        e5 = 1;
        break;
      case a.enumBezier:
        e5 = 2;
        break;
      case a.enumEllipticArc:
        e5 = 4;
        break;
      case a.enumRationalBezier2:
        e5 = 8;
        break;
      case a.enumBezier2:
        e5 = 16;
        break;
      default:
        b("");
    }
    return e5;
  }
  constructor() {
    this.m_segmentFlags = null, this.m_segmentParamIndex = null, this.m_segmentParams = null, this.m_curveCount = 0, this.m_bezierCount = 0, this.m_arcCount = 0, this.m_rbezier2Count = 0, this.m_bezier2Count = 0, this.m_curveParamWritePoint = 0;
  }
  assignCopy(t3) {
    return this.m_segmentFlags = t3.m_segmentFlags, this.m_segmentParamIndex = t3.m_segmentParamIndex, this.m_segmentParams = t3.m_segmentParams, this.m_curveCount = t3.m_curveCount, this.m_bezierCount = t3.m_bezierCount, this.m_arcCount = t3.m_arcCount, this.m_rbezier2Count = t3.m_rbezier2Count, this.m_bezier2Count = t3.m_bezier2Count, this.m_curveParamWritePoint = t3.m_curveParamWritePoint, this;
  }
};
var Hs2 = class _Hs extends Se {
  constructor(t3) {
    super(t3), this.m_cachedRingAreas2D = null, this.m_paths = null, this.m_pathFlags = null, this.m_curveData = null, t3.move ? (this.m_bPolygon = t3.move.m_bPolygon, this.m_cachedLength2D = t3.move.m_cachedLength2D, this.m_cachedArea2D = t3.move.m_cachedArea2D, this.m_currentPathIndex = t3.move.m_currentPathIndex, this.m_cachedRingAreas2D = t3.move.m_cachedRingAreas2D, this.m_paths = t3.move.m_paths, this.m_pathFlags = t3.move.m_pathFlags, this.m_curveData = t3.move.m_curveData, t3.move.m_curveData = null, t3.move.setEmpty()) : (this.m_bPolygon = t3.bPolygon, this.m_cachedLength2D = 0, this.m_cachedArea2D = 0, this.m_currentPathIndex = 0);
  }
  getGeometryType() {
    return this.m_bPolygon ? a.enumPolygon : a.enumPolyline;
  }
  getDimension() {
    return this.m_bPolygon ? 2 : 1;
  }
  changeRingStartPoint(t3) {
    n2(this.m_bPolygon);
    const n6 = this.getPathIndexFromPointIndex(t3), i2 = this.getPathStart(n6);
    if (i2 === t3) return;
    const r = this.getPathEnd(n6);
    (t3 >= r || t3 < i2) && P("change_ring_start_point");
    for (let e5 = 0, s4 = this.m_description.getAttributeCount(); e5 < s4; e5++) {
      const s5 = this.m_description.getSemantics(e5), n7 = js2.getComponentCount(s5);
      this.m_vertexAttributes.get(e5).rotate(i2 * n7, t3 * n7, r * n7);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.rotate(i2, t3, r), this.m_curveData.m_segmentParamIndex.rotate(i2, t3, r));
  }
  setFillRule(t3) {
    this.m_bFillRule = 1 === t3;
  }
  getFillRule() {
    return this.m_bFillRule ? 1 : 0;
  }
  isExteriorRingOGC(t3) {
    return !!this.m_bPolygon && (this.updateOGCFlagsProtected(), !!(8 & this.m_pathFlags.read(t3)));
  }
  isExteriorRing(t3) {
    return this.calculateRingArea2D(t3) > 0;
  }
  calculateRingArea2D(t3) {
    return this.m_bPolygon ? (this.updateRingAreas2DProtected(), this.m_cachedRingAreas2D.read(t3)) : 0;
  }
  updateRingAreas2DProtected() {
    if (!this.hasDirtyFlag(1024)) return;
    const t3 = this.getPathCount();
    if (0 === t3) return this.hasDirtyFlag(1024) && (this.m_cachedArea2D = 0), void this.setDirtyFlagProtected(1024, false);
    const e5 = new nt(t3), s4 = new n3(0), n6 = new n3(0);
    if (0 !== this.m_pointCount) {
      const i2 = this.getAttributeStreamRef(0);
      if (this.hasNonLinearSegments()) {
        const t4 = new Fs({ parent: this });
        for (t4.stripAttributes(); t4.nextPath(); ) {
          n6.reset();
          const r = t4.getPathIndex();
          Gs2(this, r, i2, n6), Ws2(this, t4, n6);
          const o = 0.5 * n6.getResult();
          s4.add(o), e5.write(r, o);
        }
      } else for (let r = 0; r < t3; r++) {
        n6.reset(), Gs2(this, r, i2, n6);
        const t4 = 0.5 * n6.getResult();
        s4.add(t4), e5.write(r, t4);
      }
    }
    this.hasDirtyFlag(1024) && (this.m_cachedArea2D = s4.getResult(), this.m_cachedRingAreas2D = e5, this.setDirtyFlagProtected(1024, false));
  }
  getOGCPolygonCount() {
    if (!this.m_bPolygon) return 0;
    this.updateOGCFlagsProtected();
    let t3 = 0;
    const e5 = this.getPathCount();
    for (let s4 = 0; s4 < e5; s4++) 8 & this.m_pathFlags.read(s4) && t3++;
    return t3;
  }
  getHashCodeImpl() {
    return n2(0), 0;
  }
  equalsImpl(t3) {
    const e5 = t3, s4 = this.getPathCount();
    if (s4 !== e5.getPathCount()) return false;
    const n6 = this.hasNonLinearSegments();
    if (n6 !== e5.hasNonLinearSegments()) return false;
    if (n6) {
      if (this.m_curveData.m_curveCount !== e5.m_curveData.m_curveCount) return false;
      if (this.m_curveData.m_bezierCount !== e5.m_curveData.m_bezierCount) return false;
    }
    if (this.m_paths && !this.m_paths.equals(e5.m_paths, 0, s4 + 1)) return false;
    if (this.m_bFillRule !== e5.m_bFillRule) return false;
    if (!this.m_bPolygon && this.m_pathFlags && !this.m_pathFlags.equals(e5.m_pathFlags, 0, s4)) return false;
    if (this.hasNonLinearSegments()) {
      if (!this.m_curveData.m_segmentFlags.equals(e5.m_curveData.m_segmentFlags, 0, this.getPointCount())) return false;
      for (let t4 = 0, s5 = this.getPointCount(); t4 < s5; t4++) {
        const s6 = this.m_curveData.m_segmentFlags.read(t4);
        if (!_Hs.isNonLinearSegmentFlag(s6)) continue;
        const n7 = this.m_curveData.m_segmentParamIndex.read(t4), i2 = e5.m_curveData.m_segmentParamIndex.read(t4), r = ks(s6);
        for (let t5 = 0; t5 < r; t5++) {
          const s7 = this.m_curveData.m_segmentParams.read(n7 + t5), r2 = e5.m_curveData.m_segmentParams.read(i2 + t5);
          if (!ls(s7, r2)) return false;
        }
      }
    }
    return true;
  }
  equalsImplTol(t3, e5) {
    const s4 = t3, n6 = this.getPathCount();
    if (n6 !== s4.getPathCount()) return false;
    const i2 = this.hasNonLinearSegments();
    if (i2 !== s4.hasNonLinearSegments()) return false;
    if (i2) {
      if (this.m_curveData.m_curveCount !== s4.m_curveData.m_curveCount) return false;
      if (this.m_curveData.m_bezierCount !== s4.m_curveData.m_bezierCount) return false;
    }
    if (this.m_paths && !this.m_paths.equals(s4.m_paths, 0, n6 + 1)) return false;
    if (this.m_bFillRule !== s4.m_bFillRule) return false;
    if (!this.m_bPolygon && this.m_pathFlags && !this.m_pathFlags.equals(s4.m_pathFlags, 0, n6)) return false;
    if (!i2) return true;
    if (!this.m_curveData.m_segmentFlags.equals(s4.m_curveData.m_segmentFlags, 0, this.getPointCount())) return false;
    const r = this.querySegmentIterator(), o = s4.querySegmentIterator();
    for (; r.nextPath(); ) {
      if (!o.nextPath()) return false;
      for (; r.hasNextSegment(); ) {
        const t4 = r.nextCurve(), s5 = o.nextCurve();
        if (!(t4 && s5 && t4.equals(s5, e5))) {
          if (!t4 && !s5) break;
          return false;
        }
      }
    }
    return true;
  }
  reserveImplImpl(t3, e5) {
    this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.resize(t3, 1), this.m_curveData.m_segmentParamIndex.resize(t3, -1), this.checkCompactSegmentParams());
  }
  verifyStreamsAfterSizeChangeExtraImpl() {
    this.m_paths || (this.m_paths = J2(1, 0), this.m_pathFlags = K2(1, 0)), this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount, 1), this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount, -1), this.checkCompactSegmentParams());
  }
  copyToImpl(t3, e5) {
    const s4 = t3;
    s4.m_bPathStarted = false, s4.m_bFillRule = this.m_bFillRule, this.m_paths ? s4.m_paths = e5 ? this.m_paths : this.m_paths.clone() : s4.m_paths = null, this.m_pathFlags ? s4.m_pathFlags = e5 ? this.m_pathFlags : this.m_pathFlags.clone() : s4.m_pathFlags = null, this.m_curveData && (s4.m_curveData || (s4.m_curveData = new Zs2()), s4.m_curveData.assignCopy(this.m_curveData), s4.m_curveData.m_curveCount = 0, s4.updateCurveCounter(this.m_curveData.m_curveCount), e5 || (this.m_curveData.m_segmentParamIndex ? s4.m_curveData.m_segmentParamIndex = this.m_curveData.m_segmentParamIndex.clone() : s4.m_curveData.m_segmentParamIndex = null, this.m_curveData.m_segmentFlags ? s4.m_curveData.m_segmentFlags = this.m_curveData.m_segmentFlags.clone() : s4.m_curveData.m_segmentFlags = null, this.m_curveData.m_segmentParams ? s4.m_curveData.m_segmentParams = this.m_curveData.m_segmentParams.clone() : s4.m_curveData.m_segmentParams = null)), s4.hasDirtyFlag(512) || (s4.m_cachedLength2D = this.m_cachedLength2D), s4.m_cachedRingAreas2D = null, s4.hasDirtyFlag(1024) || (s4.m_cachedArea2D = this.m_cachedArea2D, null !== this.m_cachedRingAreas2D && (s4.m_cachedRingAreas2D = e5 ? this.m_cachedRingAreas2D : this.m_cachedRingAreas2D.clone()));
  }
  calculateArea2D() {
    return this.m_bPolygon ? (this.updateRingAreas2DProtected(), this.m_cachedArea2D) : 0;
  }
  calculateLength2D() {
    if (!this.hasDirtyFlag(512)) return this.m_cachedLength2D;
    const t3 = this.querySegmentIterator(), e5 = new n3(0);
    for (; t3.nextPath(); ) for (; t3.hasNextSegment(); ) e5.add(t3.nextSegment().calculateLength2D());
    return this.hasDirtyFlag(512) && (this.m_cachedLength2D = e5.getResult()), this.setDirtyFlagProtected(512, false), e5.getResult();
  }
  calculatePathLength2D(t3) {
    const e5 = this.querySegmentIteratorAtVertex(this.getPathStart(t3)), s4 = new n3(0);
    for (; e5.hasNextSegment(); ) s4.add(e5.nextSegment().calculateLength2D());
    return s4.getResult();
  }
  calculateLength3D(t3) {
    return n2(0), 0;
  }
  calculatePathLength3D(t3, e5) {
    return n2(0), 0;
  }
  copyTo(t3) {
    h(t3.getGeometryType()) || P(""), this !== t3 && super.copyTo(t3);
  }
  swap(t3) {
    n2(0);
  }
  setPointByVal(t3, e5) {
    this.setPointByValWithCurves(t3, e5);
  }
  setPointByValWithCurves(t3, e5) {
    if (this.hasNonLinearSegments()) {
      const s4 = e5.getXY();
      if (this.setXYCoordsWithCurves(t3, s4.x, s4.y), 1 === this.m_description.getAttributeCount()) return;
    }
    this.setPointByValNoCurves(t3, e5);
  }
  setXYCoordsWithCurves(t3, e5, s4) {
    if (this.hasNonLinearSegments()) {
      const n6 = _Hs.getPathIndexFromPointIndexImpl(this.m_paths, this.getPathCount(), t3, this.m_currentPathIndex);
      this.m_currentPathIndex = n6;
      const i2 = this.getPrevSegmentTypeFromPath(n6, t3), r = this.getNextSegmentType(t3);
      if (1 !== i2 || 1 !== r) {
        let o = t3 - 1;
        const a2 = new fm();
        if (1 !== i2) {
          if (this.isClosedPath(n6) && t3 === this.getPathStart(n6)) {
            o = this.getPathEnd(n6) - 1;
          }
          this.getSegmentBuffer(o, a2, true);
        }
        const h2 = new fm();
        1 !== r && this.getSegmentBuffer(t3, h2, true);
        const u = t3 + 1;
        this.setXYCoordsNoCurves(t3, e5, s4);
        const m3 = new mi(e5, s4);
        return 1 !== i2 && (a2.get().changeEndPoints2D(a2.get().getStartXY(), m3), this.replaceSegmentImpl(o, t3, a2.get(), true)), void (1 !== r && (h2.get().changeEndPoints2D(m3, h2.get().getEndXY()), this.replaceSegmentImpl(t3, u, h2.get(), true)));
      }
    }
    this.setXYCoordsNoCurves(t3, e5, s4);
  }
  setXYZWithCurves(t3, e5) {
    this.hasNonLinearSegments() ? (this.setXYCoordsWithCurves(t3, e5.x, e5.y), this.setAttributeNoCurves(1, t3, 0, e5.z)) : this.setXYZNoCurves(t3, e5);
  }
  setAttributeWithCurves(t3, e5, s4, n6) {
    if (0 === t3 && this.hasNonLinearSegments()) {
      const t4 = this.getXY(e5);
      0 === s4 ? t4.x = n6 : t4.y = n6, this.setXYCoordsWithCurves(e5, t4.x, t4.y);
    } else this.setAttributeNoCurves(t3, e5, s4, n6);
  }
  setXY(t3, e5) {
    this.setXYCoordsWithCurves(t3, e5.x, e5.y);
  }
  setXYCoords(t3, e5, s4) {
    this.setXYCoordsWithCurves(t3, e5, s4);
  }
  setXYZ(t3, e5) {
    this.setXYZWithCurves(t3, e5);
  }
  setAttribute(t3, e5, s4, n6) {
    this.setAttributeWithCurves(t3, e5, s4, n6);
  }
  setAttributeWithCurvesFromArray(t3, e5, s4, i2) {
    if (0 === t3 && this.hasNonLinearSegments()) {
      i2 < 2 && A("");
      const t4 = this.getXY(e5);
      t4.x = s4[0], t4.y = s4[1], this.setXYCoordsWithCurves(e5, t4.x, t4.y);
    } else this.setAttributeFromArrayNoCurves(t3, e5, s4, i2);
  }
  setAttributeFromArray(t3, e5, s4, n6) {
    this.setAttributeWithCurvesFromArray(t3, e5, s4, n6);
  }
  hasNonLinearSegments() {
    return 0 !== this.getCurveCount();
  }
  getSegmentCount() {
    let t3 = this.getPointCount();
    if (!this.m_bPolygon) {
      t3 -= this.getPathCount();
      for (let e5 = 0, s4 = this.getPathCount(); e5 < s4; e5++) this.isClosedPath(e5) && t3++;
    }
    return t3;
  }
  getSegmentCountPath(t3) {
    let e5 = this.getPathSize(t3);
    return !this.isClosedPath(t3) && e5 > 0 && e5--, e5;
  }
  add(t3, s4) {
    this === t3 && P("Multi_path_impl::add");
    for (let e5 = 0, n6 = t3.getPathCount(); e5 < n6; e5++) this.addPath(t3, e5, !s4);
  }
  addPath(t3, e5, s4) {
    this.insertPath(-1, t3, e5, s4);
  }
  addPathPoint2D(t3, e5, s4) {
    this.insertPath2D(-1, t3, 0, e5, s4);
  }
  addPathMultiPoint(t3, e5, s4, n6) {
    s4 < 0 && (s4 = t3.getPointCount() - e5), this.insertPointsFromMultipoint(-1, 0, t3, e5, s4, n6);
  }
  addSegmentsFromPath(t3, s4, i2, r, o) {
    if (this === t3 && P("Multi_path_impl.add_segments_from_path"), o || 0 !== this.getPathCount() || (o = true), s4 < 0 && (s4 = t3.getPathCount() - 1), (s4 >= t3.getPathCount() || i2 < 0 || r < 0 || i2 + r > t3.getSegmentCountPath(s4)) && A("add_segments_from_path"), 0 === r) return;
    const a2 = t3.getPathStart(s4), h2 = t3.isClosedPath(s4) && i2 + r === t3.getSegmentCountPath(s4);
    this.m_bPathStarted = false, this.mergeVertexDescription(t3.getDescription());
    let u = r;
    const m3 = a2 + i2;
    let l2 = m3 + 1;
    o && (u++, l2--), !o && t3.hasNonLinearSegments() && 1 !== t3.m_curveData.m_segmentFlags.read(m3) && (t3.getXY(m3).equals(this.getXY(this.m_pointCount - 1)) || P("add_segments_from_path: start point mismatch"));
    const c = this.m_pointCount;
    if (this.resizeImpl(this.m_pointCount + u), this.verifyAllStreamsAfterSizeChange(), o) {
      if (0 === u) return;
      this.m_paths.add(this.m_pointCount);
      let e5 = t3.m_pathFlags.read(s4);
      this.m_bPolygon && (e5 |= 1), this.m_pathFlags.write(this.m_pathFlags.size() - 1, e5), this.m_pathFlags.add(0);
    } else this.m_paths.write(this.m_pathFlags.size() - 1, this.m_pointCount);
    const g2 = h2 ? u - 1 : u;
    for (let e5 = 0, n6 = this.m_description.getAttributeCount(); e5 < n6; e5++) {
      const s5 = this.m_description.getSemantics(e5), n7 = js2.getComponentCount(s5), i3 = t3.m_description.getAttributeIndex(s5);
      if (g2 > 0) {
        if (i3 < 0 || !t3.m_vertexAttributes.get(i3)) {
          const t4 = js2.getDefaultValue(s5);
          this.m_vertexAttributes.get(e5).insertRange(n7 * c, t4, g2 * n7, n7 * c), h2 && this.m_vertexAttributes.get(e5).insertRange(n7 * c + g2 * n7, t4, n7, n7 * c);
          continue;
        }
        this.m_vertexAttributes.get(e5).insertRangeFromStream(n7 * c, t3.m_vertexAttributes.get(i3), n7 * l2, g2 * n7, true, n7, n7 * c);
      }
      h2 && this.m_vertexAttributes.get(e5).insertRangeFromStream(n7 * (c + g2), t3.m_vertexAttributes.get(i3), n7 * a2, n7, true, n7, n7 * (c + g2));
    }
    if (this.hasNonLinearSegments() && this.initSegmentData(0), t3.hasNonLinearSegments()) {
      let e5 = 0;
      for (let s5 = 0, n6 = m3; s5 < r; s5++) {
        e5 += ks(t3.m_curveData.m_segmentFlags.read(n6)), n6++;
      }
      if (e5 > 0) {
        this.initSegmentData(e5);
        let s5 = m3, n6 = c - (o ? 0 : 1), i3 = 0;
        for (let e6 = 0; e6 < r; e6++) {
          const e7 = t3.m_curveData.m_segmentFlags.read(s5);
          if (this.m_curveData.m_segmentFlags.write(n6, e7), _Hs.isNonLinearSegmentFlag(e7)) {
            i3++;
            let r2 = t3.m_curveData.m_segmentParamIndex.read(s5);
            const o2 = ks(e7);
            this.m_curveData.m_segmentParamIndex.write(n6, this.m_curveData.m_curveParamWritePoint);
            for (let e8 = 0; e8 < o2; e8++) {
              const e9 = t3.m_curveData.m_segmentParams.read(r2);
              this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint, e9), this.m_curveData.m_curveParamWritePoint++, r2++;
            }
            this.incCurveType(e7, 1);
          } else this.m_curveData.m_segmentParamIndex.write(n6, -1);
          n6++, s5++;
        }
        this.modifyCurveCounter(i3);
      }
    }
    if (h2) {
      const t4 = this.getPathCount() - 1, e5 = this.getPathStart(t4), s5 = this.getPathEnd(t4) - 1, n6 = this.getXY(e5), i3 = this.getXY(s5);
      n6.isEqualPoint2D(i3) && (--this.m_pointCount, this.m_paths.write(t4 + 1, this.m_pointCount));
    }
    this.notifyModifiedFlags(2001);
  }
  reverseAllPaths() {
    for (let t3 = 0, e5 = this.getPathCount(); t3 < e5; t3++) this.reversePath(t3);
  }
  reversePath(t3) {
    t3 >= this.getPathCount() && P("");
    const s4 = this.getPathSize(t3);
    if (0 === s4) return;
    const n6 = this.getPathStart(t3), i2 = this.isClosedPath(t3);
    if (this.hasNonLinearSegments()) {
      let t4 = n6;
      const e5 = new this.m_segmentBufferCTor();
      let r2 = false;
      for (let n7 = 0; n7 < s4; n7++, t4++) {
        const s5 = this.m_curveData.m_segmentFlags.read(t4);
        if (!_Hs.isNonLinearSegmentFlag(s5)) continue;
        r2 = true, this.querySegment(t4, e5, true), e5.get().reverse();
        const n8 = this.m_curveData.m_segmentParamIndex.read(t4);
        e5.get().writeInBufferStream(this.m_curveData.m_segmentParams, n8);
      }
      if (r2) {
        const t5 = i2 ? 0 : 1;
        this.m_curveData.m_segmentFlags.reverseRange(n6, s4 - t5, 1), this.m_curveData.m_segmentParamIndex.reverseRange(n6, s4 - t5, 1);
      }
    }
    const r = i2 ? 1 : 0;
    for (let e5 = 0, a2 = this.m_description.getAttributeCount(); e5 < a2; e5++) if (this.m_vertexAttributes.get(e5)) {
      const t4 = this.m_description.getSemantics(e5), i3 = js2.getComponentCount(t4);
      this.m_vertexAttributes.get(e5).reverseRange(i3 * (n6 + r), i3 * (s4 - r), i3);
    }
    const o = 6 & this.m_pathFlags.read(t3);
    if (o) {
      let e5 = 0;
      4 & o && (e5 |= 2), 2 & o && (e5 |= 4), this.m_pathFlags.clearBits(t3, 6), this.m_pathFlags.setBits(t3, e5);
    }
    this.notifyModifiedFlags(1233);
  }
  removePath(t3) {
    const s4 = this.getPathCount();
    t3 < 0 && (t3 = s4 - 1), t3 >= s4 && P("");
    const n6 = this.getPathStart(t3), i2 = this.getPathSize(t3);
    for (let e5 = 0, r = this.m_description.getAttributeCount(); e5 < r; e5++) if (this.m_vertexAttributes.get(e5)) {
      const t4 = this.m_description.getSemantics(e5), s5 = js2.getComponentCount(t4);
      this.m_vertexAttributes.get(e5).eraseRange(s5 * n6, s5 * i2, s5 * this.m_pointCount);
    }
    if (this.hasNonLinearSegments()) {
      let t4 = 0;
      for (let e5 = n6, s5 = n6 + i2; e5 < s5; e5++) {
        const s6 = this.m_curveData.m_segmentFlags.read(e5);
        _Hs.isNonLinearSegmentFlag(s6) && (this.incCurveType(s6, -1), t4++);
      }
      this.modifyCurveCounter(-t4), this.m_curveData.m_segmentFlags.eraseRange(n6, i2, this.m_pointCount), this.m_curveData.m_segmentParamIndex.eraseRange(n6, i2, this.m_pointCount);
    }
    for (let e5 = t3 + 1; e5 <= s4; e5++) {
      const t4 = this.m_paths.read(e5);
      this.m_paths.write(e5 - 1, t4 - i2);
    }
    if (this.m_pathFlags) for (let e5 = t3 + 1; e5 <= s4; e5++) {
      const t4 = this.m_pathFlags.read(e5);
      this.m_pathFlags.write(e5 - 1, t4);
    }
    this.m_paths.resize(s4), this.m_pathFlags.resize(s4), this.m_pointCount -= i2, this.m_reservedPointCount -= i2, t3 === s4 - 1 && (this.m_bPathStarted = false), this.notifyModifiedFlags(2001), this.checkCompactSegmentParams(), this.dbgVerifyCurves();
  }
  dbgVerifyCurves() {
  }
  insertPath(t3, s4, n6, i2) {
    this === s4 && P("Multi_path_impl::insert_path");
    const r = this.getPathCount();
    if (!i2 && s4.hasNonLinearSegmentsPath(n6)) return t3 = this.insertPath(t3, s4, n6, true), this.reversePath(t3), t3;
    n6 >= s4.getPathCount() && P(""), t3 > r && P(""), t3 < 0 && (t3 = r), n6 < 0 && (n6 = s4.getPathCount() - 1), this.m_bPathStarted = false, this.mergeVertexDescription(s4.getDescription());
    const o = s4.getPathStart(n6), a2 = s4.getPathSize(n6);
    if (0 === a2) return this.insertPath2D(t3, null, 0, 0, true);
    const h2 = this.m_pointCount, u = s4.isClosedPath(n6) && !i2 ? 1 : 0;
    this.resizeImpl(this.m_pointCount + a2), this.verifyAllStreamsAfterSizeChange();
    const m3 = t3 < r ? this.getPathStart(t3) : h2;
    for (let e5 = 0, g2 = this.m_description.getAttributeCount(); e5 < g2; e5++) {
      const t4 = this.m_description.getSemantics(e5), n7 = s4.getDescription().getAttributeIndex(t4), r2 = js2.getComponentCount(t4);
      if (n7 >= 0 && s4.m_vertexAttributes.get(n7)) 0 !== u && this.m_vertexAttributes.get(e5).insertRangeFromStream(m3 * r2, s4.m_vertexAttributes.get(n7), r2 * o, r2, true, r2, r2 * h2), this.m_vertexAttributes.get(e5).insertRangeFromStream((m3 + u) * r2, s4.m_vertexAttributes.get(n7), r2 * (o + u), r2 * (a2 - u), i2, r2, r2 * (h2 + u));
      else {
        const s5 = js2.getDefaultValue(t4);
        this.m_vertexAttributes.get(e5).insertRange(m3 * r2, s5, r2 * a2, r2 * h2);
      }
    }
    const l2 = h2 + a2;
    this.m_paths.add(l2);
    for (let e5 = r; e5 >= t3 + 1; e5--) {
      const t4 = this.m_paths.read(e5 - 1);
      this.m_paths.write(e5, t4 + a2);
    }
    this.m_pathFlags.add(0);
    for (let e5 = r - 1; e5 >= t3 + 1; e5--) {
      let t4 = this.m_pathFlags.read(e5);
      t4 &= -9, this.m_pathFlags.write(e5 + 1, t4);
    }
    let c = s4.getPathFlagsStreamRef().read(n6);
    if (c &= -9, this.m_bPolygon && (c |= 1), this.m_pathFlags.write(t3, c), s4.hasNonLinearSegments()) {
      this.initSegmentData(0);
      let t4 = o, e5 = 0;
      for (let n7 = 0; n7 < a2; n7++) {
        e5 += ks(s4.m_curveData.m_segmentFlags.read(t4)), t4++;
      }
      if (e5 > 0) {
        null === this.m_curveData.m_segmentFlags ? (this.m_curveData.m_segmentFlags = K2(this.m_pointCount, 1), this.m_curveData.m_segmentParamIndex = J2(this.m_pointCount, -1)) : (this.m_curveData.m_segmentFlags.insertRange(m3, 1, a2, h2), this.m_curveData.m_segmentParamIndex.insertRange(m3, -1, a2, h2)), this.m_curveData.m_segmentParams ? this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint + e5) : this.m_curveData.m_segmentParams = $2(e5), t4 = o;
        let n7 = m3, i3 = 0;
        for (let e6 = 0; e6 < a2; e6++) {
          const e7 = s4.m_curveData.m_segmentFlags.read(t4);
          if (_Hs.isNonLinearSegmentFlag(e7)) {
            this.m_curveData.m_segmentFlags.write(n7, e7), this.m_curveData.m_segmentParamIndex.write(n7, this.m_curveData.m_curveParamWritePoint);
            const r2 = ks(e7);
            let o2 = s4.m_curveData.m_segmentParamIndex.read(t4);
            for (let t5 = 0; t5 < r2; t5++) {
              const t6 = s4.m_curveData.m_segmentParams.read(o2);
              this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint, t6), this.m_curveData.m_curveParamWritePoint++, o2++;
            }
            i3++, this.incCurveType(e7, 1);
          }
          t4++, n7++;
        }
        this.modifyCurveCounter(i3);
      }
    }
    return this.notifyModifiedFlags(2001), t3;
  }
  insertPath2D(t3, s4, n6, i2, r) {
    const o = this.getPathCount();
    (t3 > o || n6 < 0) && P(""), t3 < 0 && (t3 = o), this.m_bPathStarted = false;
    const a2 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + i2), 0 === i2 && this.notifyModifiedFlags(32), this.verifyAllStreamsAfterSizeChange();
    const h2 = t3 < o ? this.getPathStart(t3) : a2;
    if (s4) this.m_vertexAttributes.get(0).insertRangeFromPoints(2 * h2, s4, n6, i2, r, 2 * a2);
    else {
      const t4 = js2.getDefaultValue(0);
      this.m_vertexAttributes.get(0).insertRange(2 * h2, t4, 2 * i2, 2 * a2);
    }
    for (let e5 = 1, u = this.m_description.getAttributeCount(); e5 < u; e5++) {
      const t4 = this.m_description.getSemantics(e5), s5 = js2.getComponentCount(t4), n7 = js2.getDefaultValue(t4);
      this.m_vertexAttributes.get(e5).insertRange(h2 * s5, n7, s5 * i2, s5 * a2);
    }
    this.m_paths.add(this.m_pointCount);
    for (let e5 = o; e5 >= t3 + 1; e5--) {
      const t4 = this.m_paths.read(e5 - 1);
      this.m_paths.write(e5, t4 + i2);
    }
    this.m_pathFlags.add(0);
    for (let e5 = o - 1; e5 >= t3 + 1; e5--) {
      let t4 = this.m_pathFlags.read(e5);
      t4 &= -9, this.m_pathFlags.write(e5 + 1, t4);
    }
    return this.m_bPolygon && this.m_pathFlags.write(t3, 1), this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(h2, 1, i2, a2), this.m_curveData.m_segmentParamIndex.insertRange(h2, -1, i2, a2)), this.notifyModifiedFlags(2001), t3;
  }
  insertPathFromMultipoint(t3, s4, n6, i2, r) {
    const o = s4.getImpl(), a2 = this.getPathCount();
    (t3 > a2 || n6 < 0) && P("");
    const h2 = i2 < 0 ? o.getPointCount() - n6 : i2;
    if (h2 > o.getPointCount() && P(""), n6 >= o.getPointCount() && P("pointsOffset"), t3 < 0 && (t3 = a2), this.m_bPathStarted = false, this.mergeVertexDescription(o.getDescription()), 0 === h2) return void this.insertPath2D(t3, null, 0, 0, true);
    const u = this.m_pointCount, m3 = n6;
    this.resizeImpl(this.m_pointCount + h2), this.verifyAllStreamsAfterSizeChange();
    const l2 = t3 < a2 ? this.getPathStart(t3) : u;
    for (let e5 = 0, d2 = this.m_description.getAttributeCount(); e5 < d2; e5++) {
      const t4 = this.m_description.getSemantics(e5), s5 = o.getDescription().getAttributeIndex(t4), n7 = js2.getComponentCount(t4);
      if (s5 >= 0) {
        const s6 = o.getAttributeStreamRef(t4);
        this.m_vertexAttributes.get(e5).insertRangeFromStream(l2 * n7, s6, n7 * m3, n7 * h2, r, n7, n7 * u);
      } else {
        const s6 = js2.getDefaultValue(t4);
        this.m_vertexAttributes.get(e5).insertRange(l2 * n7, s6, n7 * h2, n7 * u);
      }
    }
    const c = u + h2;
    this.m_paths.add(c);
    for (let e5 = a2; e5 >= t3 + 1; e5--) {
      const t4 = this.m_paths.read(e5 - 1);
      this.m_paths.write(e5, t4 + h2);
    }
    this.m_pathFlags.add(0);
    for (let e5 = a2 - 1; e5 >= t3 + 1; e5--) {
      let t4 = this.m_pathFlags.read(e5);
      t4 &= -9, this.m_pathFlags.write(e5 + 1, t4);
    }
    let g2 = 0;
    this.m_bPolygon && (g2 |= 1), this.m_pathFlags.write(t3, g2), this.notifyModifiedFlags(2001);
  }
  insertPoints(t3, s4, i2, r, o, a2, h2) {
    if (this === i2 && P("Multi_path_impl.insert_points"), t3 < 0 && (t3 = this.getPathCount()), r < 0 && (r = i2.getPathCount() - 1), (t3 > this.getPathCount() || s4 >= 0 && s4 > this.getPathSize(t3) || r >= i2.getPathCount() || a2 > i2.getPathSize(r)) && A(""), !a2) return;
    if (this.mergeVertexDescription(i2.m_description), t3 === this.getPathCount()) {
      this.m_paths.add(this.m_pointCount);
      let t4 = i2.m_pathFlags.read(r);
      t4 &= -9, this.m_bPolygon ? this.m_pathFlags.add(1 | t4) : this.m_pathFlags.add(t4);
    }
    s4 < 0 && (s4 = this.getPathSize(t3));
    const u = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + a2), this.verifyAllStreamsAfterSizeChange();
    const m3 = this.getPathStart(t3), l2 = m3 + s4;
    a2 < 0 && (a2 = i2.getPathSize(r));
    const c = i2.getPathStart(r), g2 = c + a2;
    for (let e5 = 0, n6 = this.m_description.getAttributeCount(); e5 < n6; e5++) {
      const t4 = this.m_description.getSemantics(e5), n7 = js2.getComponentCount(t4), r2 = i2.m_description.getAttributeIndex(t4);
      if (r2 < 0 || !i2.m_vertexAttributes.get(r2)) {
        const s5 = js2.getDefaultValue(t4);
        this.m_vertexAttributes.get(e5).insertRange(n7 * l2, s5, g2 * n7, n7 * u);
      } else this.m_vertexAttributes.get(e5)?.insertRangeFromStream(n7 * (m3 + s4), i2.m_vertexAttributes.get(r2), n7 * (c + o), a2 * n7, h2, n7, n7 * u);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(m3 + s4, 1, a2, u), this.m_curveData.m_segmentParamIndex.insertRange(m3 + s4, -1, a2, u), s4 > 0 && this.isNonLinearSegment(m3 + s4 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(m3 + s4 - 1), -1), this.m_curveData.m_segmentFlags.write(m3 + s4 - 1, 1), this.m_curveData.m_segmentParamIndex.write(m3 + s4 - 1, -1), this.modifyCurveCounter(-1)));
    for (let e5 = t3 + 1, n6 = this.getPathCount(); e5 <= n6; e5++) {
      const t4 = this.m_paths.read(e5);
      this.m_paths.write(e5, t4 + a2);
    }
    this.notifyModifiedFlags(2001);
  }
  insertPointsFromPoints(t3, e5, s4, i2, r, o) {
    if (t3 < 0 && (t3 = this.getPathCount()), (t3 > this.getPathCount() || e5 > this.getPathSize(t3) || i2 < 0) && A(""), !r) return;
    t3 === this.getPathCount() && (this.m_paths.add(this.m_pointCount), this.m_bPolygon ? this.m_pathFlags.add(1) : this.m_pathFlags.add(0)), e5 < 0 && (e5 = this.getPathSize(t3));
    const a2 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + r), this.verifyAllStreamsAfterSizeChange();
    const h2 = this.getPathStart(t3);
    this.m_vertexAttributes.get(0).insertRangeFromPoints(2 * (h2 + e5), s4, i2, r, o, 2 * a2);
    for (let n6 = 1, u = this.m_description.getAttributeCount(); n6 < u; n6++) {
      const t4 = this.m_description.getSemantics(n6), s5 = js2.getComponentCount(t4), i3 = js2.getDefaultValue(t4);
      this.m_vertexAttributes.get(n6).insertRange((h2 + e5) * s5, i3, s5 * r, s5 * a2);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(h2 + e5, 1, r, a2), this.m_curveData.m_segmentParamIndex.insertRange(h2 + e5, -1, r, a2), e5 > 0 && this.isNonLinearSegment(h2 + e5 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(h2 + e5 - 1), -1), this.m_curveData.m_segmentFlags.write(h2 + e5 - 1, 1), this.m_curveData.m_segmentParamIndex.write(h2 + e5 - 1, -1), this.modifyCurveCounter(-1)));
    for (let n6 = t3 + 1, u = this.getPathCount(); n6 <= u; n6++) this.m_paths.write(n6, this.m_paths.read(n6) + r);
    this.notifyModifiedFlags(2001);
  }
  insertPointsFromMultipoint(t3, e5, s4, i2, r, o) {
    const a2 = s4.getImpl(), h2 = this.getPathCount();
    t3 < 0 && (t3 = this.getPathCount());
    const u = a2.getPointCount();
    if ((i2 < 0 || i2 > u) && A(""), (r < 0 || i2 + r > u) && (r = u - i2), e5 < 0 && (e5 = t3 < h2 ? this.getPathSize(t3) : 0), (t3 > h2 || t3 < h2 && e5 > this.getPathSize(t3) || t3 === h2 && e5 > 0 || r < 0) && A(""), !r) return;
    if (this.mergeVertexDescription(a2.getDescription()), t3 === h2) {
      this.m_paths.add(this.m_pointCount);
      const t4 = 0;
      this.m_bPolygon ? this.m_pathFlags.add(1 | t4) : this.m_pathFlags.add(t4);
    }
    e5 < 0 && (e5 = this.getPathSize(t3));
    const m3 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + r), this.verifyAllStreamsAfterSizeChange();
    const l2 = this.getPathStart(t3), c = l2 + e5, g2 = 0, d2 = g2 + r;
    for (let n6 = 0, _ = this.m_description.getAttributeCount(); n6 < _; n6++) {
      const t4 = this.m_description.getSemantics(n6), s5 = js2.getComponentCount(t4);
      if (a2.getDescription().getAttributeIndex(t4) < 0) {
        const e6 = js2.getDefaultValue(t4);
        this.m_vertexAttributes.get(n6).insertRange(s5 * c, e6, d2 * s5, s5 * m3);
        continue;
      }
      const h3 = a2.getAttributeStreamRef(t4);
      this.m_vertexAttributes.get(n6).insertRangeFromStream(s5 * (l2 + e5), h3, s5 * (g2 + i2), r * s5, o, s5, s5 * m3);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(l2 + e5, 1, r, m3), this.m_curveData.m_segmentParamIndex.insertRange(l2 + e5, -1, r, m3), e5 > 0 && this.isNonLinearSegment(l2 + e5 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(l2 + e5 - 1), -1), this.m_curveData.m_segmentFlags.write(l2 + e5 - 1, 1), this.m_curveData.m_segmentParamIndex.write(l2 + e5 - 1, -1), this.modifyCurveCounter(-1)));
    for (let n6 = t3 + 1, _ = this.getPathCount(); n6 <= _; n6++) {
      const t4 = this.m_paths.read(n6);
      this.m_paths.write(n6, t4 + r);
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoint2D(t3, e5, s4) {
    const i2 = this.getPathCount();
    t3 < 0 && (t3 = i2), (t3 > i2 || t3 < i2 && e5 > this.getPathSize(t3)) && A(""), t3 === i2 && this.addPathPoint2D(null, 0, true);
    const r = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
    const o = this.getPathStart(t3), a2 = e5 < 0 ? this.getPathSize(t3) + o : e5 + o, h2 = this.m_vertexAttributes.get(0);
    if (a2 === r) this.m_paths.write(t3 + 1, r + 1), h2.writePoint2D(2 * a2, s4);
    else {
      h2.insert(2 * a2, s4, 2 * r);
      for (let t4 = 1, e6 = this.m_description.getAttributeCount(); t4 < e6; t4++) {
        const e7 = this.m_description.getSemantics(t4), s5 = js2.getComponentCount(e7), n6 = js2.getDefaultValue(e7);
        this.m_vertexAttributes.get(t4).insertRange(s5 * a2, n6, s5, s5 * r);
      }
      this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.insertRange(a2, 1, 1, r), this.m_curveData.m_segmentParamIndex.insertRange(a2, -1, 1, r));
      for (let e6 = t3 + 1, s5 = i2; e6 <= s5; e6++) this.m_paths.write(e6, this.m_paths.read(e6) + 1);
    }
    this.m_curveData && this.m_curveData.m_segmentFlags && a2 > o && this.isNonLinearSegment(a2 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(a2 - 1), -1), this.modifyCurveCounter(-1), this.m_curveData.m_segmentFlags.write(a2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(a2 - 1, -1)), this.notifyModifiedFlags(2001);
  }
  insertPoint(t3, e5, s4) {
    const i2 = this.getPathCount();
    t3 < 0 && (t3 = i2), (t3 > i2 || t3 < i2 && e5 > this.getPathSize(t3)) && A(""), t3 === i2 && this.addPathPoint2D(null, 0, true);
    const r = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
    const o = this.getPathStart(t3), a2 = e5 < 0 ? this.getPathSize(t3) + o : e5 + o;
    if (a2 === r) this.m_paths.write(t3 + 1, r + 1), this.setPointByValNoCurves(a2, s4);
    else {
      const e6 = s4.getDescription();
      this.m_description !== e6 && this.mergeVertexDescription(e6);
      for (let t4 = 0, n6 = this.m_description.getAttributeCount(); t4 < n6; t4++) {
        const n7 = this.m_description.getSemantics(t4), i3 = js2.getComponentCount(n7);
        if (e6.hasAttribute(n7)) this.m_vertexAttributes.get(t4).insertAttributes(i3 * a2, s4, n7, i3 * r);
        else {
          const e7 = js2.getDefaultValue(n7);
          this.m_vertexAttributes.get(t4).insertRange(i3 * a2, e7, i3, i3 * r);
        }
      }
      this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.insertRange(a2, 1, 1, r), this.m_curveData.m_segmentParamIndex.insertRange(a2, -1, 1, r));
      for (let s5 = t3 + 1, n6 = i2; s5 <= n6; s5++) this.m_paths.write(s5, this.m_paths.read(s5) + 1);
    }
    this.m_curveData && this.m_curveData.m_segmentFlags && a2 > o && this.isNonLinearSegment(a2 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(a2 - 1), -1), this.modifyCurveCounter(-1), this.m_curveData.m_segmentFlags.write(a2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(a2 - 1, -1)), this.notifyModifiedFlags(2001);
  }
  removePointFromPath(t3, e5) {
    const s4 = this.getPathCount();
    t3 < 0 && (t3 = s4 - 1), (t3 >= s4 || e5 >= this.getPathSize(t3)) && A("Multi_path.remove_point");
    const i2 = this.getPathStart(t3), r = this.isClosedPath(t3);
    e5 < 0 && (e5 = this.getPathSize(t3) - 1), e5 < 0 && A("Multi_path.remove_point");
    const o = i2 + e5;
    for (let n6 = 0, a2 = this.m_description.getAttributeCount(); n6 < a2; n6++) if (this.m_vertexAttributes.get(n6)) {
      const t4 = this.m_description.getSemantics(n6), e6 = js2.getComponentCount(t4);
      this.m_vertexAttributes.get(n6).eraseRange(e6 * o, e6, e6 * this.m_pointCount);
    }
    if (this.m_curveData && this.m_curveData.m_segmentFlags) {
      this.checkCompactSegmentParams();
      let e6 = 0;
      if (o > i2 && this.isNonLinearSegment(o - 1)) e6 += 1, this.incCurveType(this.m_curveData.m_segmentFlags.read(o - 1), -1), this.m_curveData.m_segmentFlags.write(o - 1, 1), this.m_curveData.m_segmentParamIndex.write(o - 1, -1);
      else {
        const s5 = this.getPathEnd(t3);
        r && i2 + 1 < s5 && this.isNonLinearSegment(s5 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(s5 - 1), -1), this.m_curveData.m_segmentFlags.write(s5 - 1, 1), this.m_curveData.m_segmentParamIndex.write(s5 - 1, -1), e6 += 1);
      }
      this.isNonLinearSegment(o) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(o), -1), e6 += 1), e6 > 0 && this.modifyCurveCounter(-e6), this.m_curveData.m_segmentFlags.eraseRange(o, 1, this.m_pointCount), this.m_curveData.m_segmentParamIndex.eraseRange(o, 1, this.m_pointCount);
    }
    for (let n6 = s4; n6 >= t3 + 1; n6--) {
      const t4 = this.m_paths.read(n6);
      this.m_paths.write(n6, t4 - 1);
    }
    this.m_pointCount--, this.m_reservedPointCount--, this.notifyModifiedFlags(2001);
  }
  removePoint(t3) {
    let e5;
    e5 = t3 < 0 ? this.getPathCount() - 1 : this.getPathIndexFromPointIndex(t3), this.removePointFromPath(e5, t3 - this.getPathStart(e5));
  }
  getNextSegmentType(t3) {
    return this.hasNonLinearSegments() ? this.m_curveData.m_segmentFlags.read(t3) : 1;
  }
  getPrevSegmentTypeFromPath(t3, e5) {
    if (!this.hasNonLinearSegments()) return 1;
    const s4 = this.getPathStart(t3);
    if (e5 > s4) return this.m_curveData.m_segmentFlags.read(e5 - 1);
    if (e5 === s4) {
      if (this.isClosedPath(t3)) {
        const e6 = this.getPathEnd(t3);
        return this.m_curveData.m_segmentFlags.read(e6 - 1);
      }
      return 1;
    }
    b("");
  }
  getNumberOfCurves(t3) {
    if (!this.hasNonLinearSegments()) return 0;
    let e5 = 0;
    for (let s4 = this.getPathStart(t3), n6 = this.getPathEnd(t3); s4 < n6; s4++) _Hs.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s4)) && ++e5;
    return e5;
  }
  getPathCount() {
    return this.m_paths ? this.m_paths.size() - 1 : 0;
  }
  getPathSize(t3) {
    return this.m_paths.read(t3 + 1) - this.m_paths.read(t3);
  }
  getPathStart(t3) {
    return this.m_paths.read(t3);
  }
  getPathEnd(t3) {
    return this.m_paths.read(t3 + 1);
  }
  getPathIndexFromPointIndex(t3, e5 = -1) {
    -1 === e5 && (e5 = this.m_currentPathIndex);
    const s4 = this.getPathCount(), n6 = _Hs.getPathIndexFromPointIndexImpl(this.m_paths, s4, t3, e5);
    return this.m_currentPathIndex = n6, n6;
  }
  startPathCoords(t3, e5) {
    this.startPathPoint(new ee({ x: t3, y: e5 }));
  }
  startPath(t3) {
    this.startPathPoint(new ee({ pt: t3 }));
  }
  startPath3D(t3) {
    this.startPathPoint(new ee({ x: t3.x, y: t3.y, z: t3.z }));
  }
  startPath3DCoords(t3, e5, s4) {
    this.startPathPoint(new ee({ x: t3, y: e5, z: s4 }));
  }
  startPathPoint(t3) {
    t3.isEmpty() && P("");
    const s4 = t3.getDescription();
    let n6;
    if (this.m_description !== s4) {
      this.mergeVertexDescription(s4);
      const e5 = new ee({ vd: this.m_description });
      t3.copyCommonAttributesTo(e5), n6 = e5;
    } else n6 = t3;
    this.m_bPathStarted ? this.setPointByValNoCurves(this.m_pointCount - 1, n6) : (this.insertPoint(-1, -1, n6), this.m_bPathStarted = true);
  }
  beforeNewSegmentHelper2() {
    this.m_paths = J2(2), this.m_paths.write(0, 0), this.m_pathFlags = K2(2, 0), this.m_bPolygon && this.m_pathFlags.write(0, 1);
  }
  beforeNewSegmentHelper1() {
    null !== this.m_paths ? (this.m_paths.add(0), this.m_pathFlags.add(0), this.m_bPolygon && this.m_pathFlags.write(this.m_pathFlags.size() - 2, 1)) : this.beforeNewSegmentHelper2();
  }
  beforeNewSegment(t3) {
    0 !== this.m_pointCount || this.m_bPathStarted || this.startPathCoords(0, 0);
    const e5 = this.m_pointCount, s4 = this.m_paths.size() - 1, n6 = e5 + t3;
    this.m_paths.write(s4, n6), this.resizeImpl(n6), this.m_bPathStarted && (this.m_bPathStarted = false);
  }
  finishLineTo() {
    if (this.hasNonLinearSegments()) {
      const t3 = this.m_curveData.m_segmentFlags.read(this.m_pointCount - 1);
      1 !== t3 && (this.m_curveData.m_segmentFlags.write(this.m_pointCount - 1, 1), this.m_curveData.m_segmentParamIndex.write(this.m_pointCount - 1, -1), this.modifyCurveCounter(-1), this.incCurveType(t3, -1));
    }
  }
  lineToCoords(t3, e5) {
    if (this.beforeNewSegment(1), 1 === this.m_description.getAttributeCount()) this.setXYCoordsNoCurves(this.m_pointCount - 1, t3, e5);
    else {
      const s4 = B3(), n6 = new ee({ vd: this.m_description, attribBuffer: s4, initDefaultValues: true });
      n6.setXYCoords(t3, e5), this.setPointByValNoCurves(this.m_pointCount - 1, n6);
    }
    this.finishLineTo();
  }
  lineTo(t3) {
    this.lineToCoords(t3.x, t3.y);
  }
  lineTo3D(t3) {
    this.beforeNewSegment(1);
    const e5 = H2(this.m_description, O2()), s4 = B3(), n6 = new ee({ vd: e5, attribBuffer: s4, initDefaultValues: true });
    n6.setXYZ(t3), this.setPointByValNoCurves(this.m_pointCount - 1, n6), this.finishLineTo();
  }
  lineTo3DCoords(t3, e5, s4) {
    this.lineTo3D(new X(t3, e5, s4));
  }
  lineToPoint(t3) {
    if (this.beforeNewSegment(1), this.m_description === t3.getDescription()) this.setPointByValNoCurves(this.m_pointCount - 1, t3);
    else {
      this.mergeVertexDescription(t3.getDescription());
      const e5 = B3(), s4 = new ee({ vd: this.m_description, attribBuffer: e5, initDefaultValues: false });
      t3.copyCommonAttributesTo(s4), this.setPointByValNoCurves(this.m_pointCount - 1, s4);
    }
    this.finishLineTo();
  }
  openPathAndDuplicateStartVertex(t3) {
    this.m_bPolygon && b("");
    const s4 = this.getPathCount();
    if (t3 > s4 && P(""), !this.isClosedPath(t3)) return;
    this.m_pathFlags || b("");
    const n6 = this.m_pointCount, i2 = this.getPathStart(t3), r = this.getPathEnd(t3);
    if (r - i2 !== 0) {
      this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
      for (let t4 = 0, e5 = this.m_description.getAttributeCount(); t4 < e5; t4++) if (this.m_vertexAttributes.get(t4)) {
        const e6 = this.m_description.getSemantics(t4), s5 = js2.getComponentCount(e6);
        this.m_vertexAttributes.get(t4).insertRangeFromStream(s5 * r, this.m_vertexAttributes.get(t4), s5 * i2, s5, true, 1, s5 * n6);
      }
      for (let e5 = s4; e5 > t3; e5--) {
        const t4 = this.m_paths.read(e5);
        this.m_paths.write(e5, t4 + 1);
      }
      this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(r, 1, 1, n6), this.m_curveData.m_segmentParamIndex.insertRange(r, -1, 1, n6)), this.m_pathFlags.clearBits(t3, 1);
    }
  }
  openPath(t3) {
    this.m_bPolygon && b(""), t3 > this.getPathCount() && P(""), this.m_pathFlags || b(""), this.m_pathFlags.clearBits(t3, 1);
  }
  isStrongPathStart(t3) {
    return !!(2 & this.m_pathFlags.read(t3));
  }
  setStrongPathStart(t3, e5) {
    e5 ? this.m_pathFlags.setBits(t3, 2) : this.m_pathFlags.clearBits(t3, 2);
  }
  isStrongPathEnd(t3) {
    return !!(4 & this.m_pathFlags.read(t3));
  }
  setStrongPathEnd(t3, e5) {
    e5 ? this.m_pathFlags.setBits(t3, 4) : this.m_pathFlags.clearBits(t3, 4);
  }
  clearStrongPathEnds() {
    for (let t3 = 0, e5 = this.getPathCount(); t3 < e5; ++t3) this.m_pathFlags.clearBits(t3, 6);
  }
  openAllPathsAndDuplicateStartVertex() {
    if (this.m_bPolygon && b(""), this.isEmpty()) return;
    this.m_pathFlags || b("");
    let t3 = 0;
    const e5 = this.getPathCount();
    for (let h2 = 0; h2 < e5; h2++) this.isClosedPath(h2) && (this.getPathSize(h2) > 0 ? t3++ : this.m_pathFlags.clearBits(h2, 1));
    if (0 === t3) return;
    const s4 = this.hasNonLinearSegments();
    let n6 = 0;
    const i2 = this.getPathCount(), r = this.m_description.getAttributeCount(), o = new Array(r);
    let a2 = null, u = null;
    for (let h2 = 0; h2 < i2; ++h2) {
      const e6 = this.getPathStart(h2), i3 = this.getPathSize(h2), m3 = this.isClosedPath(h2);
      if (i3 > 0) {
        const h3 = e6 + n6;
        for (let s5 = 0; s5 < r; s5++) if (this.m_vertexAttributes.get(s5)) {
          const n7 = this.m_description.getSemantics(s5), r2 = js2.getComponentCount(n7);
          if (!o[s5]) {
            const e7 = r2 * (this.m_pointCount + t3), i4 = W(n7, e7);
            o[s5] = i4;
          }
          o[s5].writeRange(h3 * r2, i3 * r2, this.m_vertexAttributes.get(s5), e6 * r2, true, 1), m3 && o[s5].writeRange((h3 + i3) * r2, r2, this.m_vertexAttributes.get(s5), e6 * r2, true, 1);
        }
        if (s4) {
          if (null === a2) {
            const e7 = this.m_pointCount + t3;
            a2 = K2(e7), u = J2(e7);
          }
          a2.writeRange(h3, i3, this.m_curveData.m_segmentFlags, e6, true, 1), u.writeRange(h3, i3, this.m_curveData.m_segmentParamIndex, e6, true, 1), m3 && (a2.write(h3 + i3, 1), u.write(h3 + i3, -1));
        }
      }
      this.m_paths.write(h2, e6 + n6), m3 && (this.m_pathFlags.clearBits(h2, 1), ++n6);
    }
    this.m_paths.write(i2, this.m_pointCount + t3), this.m_pathFlags.clearBits(i2, 1);
    for (let h2 = 0; h2 < r; h2++) this.m_vertexAttributes.get(h2) && this.m_vertexAttributes.set(h2, o[h2]);
    s4 && (this.m_curveData.m_segmentFlags = a2, this.m_curveData.m_segmentParamIndex = u), this.m_pointCount += t3, this.m_reservedPointCount > 0 && (this.m_reservedPointCount = this.m_pointCount);
  }
  closePathWithLine(t3) {
    void 0 === t3 && (t3 = this.getPathCount() - 1), this.throwIfEmpty(), (t3 < 0 || t3 >= this.getPathCount()) && P("close_path_with_line"), t3 === this.getPathCount() - 1 && (this.m_bPathStarted = false);
    const s4 = this.m_pathFlags.read(t3);
    if (1 & s4 || this.m_pathFlags.write(t3, 1 | s4), this.m_curveData && this.m_curveData.m_segmentFlags) {
      const e5 = this.getPathEnd(t3) - 1, s5 = this.m_curveData.m_segmentFlags.read(e5);
      1 !== s5 && (this.m_curveData.m_segmentFlags.write(e5, 1), this.m_curveData.m_segmentParamIndex.write(e5, -1), this.incCurveType(s5, -1), this.modifyCurveCounter(-1));
    }
    this.notifyModifiedFlags(2001);
  }
  closeLastPathWithSegment(t3) {
    this.closePathWithSegment(this.getPathCount() - 1, t3);
  }
  closePathWithSegment(t3, s4) {
    if (this.throwIfEmpty(), (t3 < 0 || t3 >= this.getPathCount()) && P("close_path_with_line"), s4.getEndXY().equals(this.getXY(this.getPathStart(t3))) || P("close_path_with_segment: end point mismatch"), t3 === this.getPathCount() - 1) this.m_bPathStarted = false, this.addSegment(s4, false), --this.m_pointCount, this.m_paths.write(t3 + 1, this.m_pointCount);
    else {
      this.mergeVertexDescription(s4.getDescription());
      const n7 = s4.getStartXY(), r = this.getPathEnd(t3) - 1;
      n7.equals(this.getXY(r)) || P("close_path_with_segment: start point mismatch");
      const o = s4.getGeometryType();
      if (o === a.enumLine) return void this.closePathWithLine(t3);
      {
        const t4 = Bs2(s4);
        this.initSegmentData(t4);
        const e5 = Zs2.toSegType(o), n8 = this.m_curveData.m_segmentFlags.read(r);
        if (n8 !== e5) this.m_curveData.m_segmentParamIndex.write(r, this.m_curveData.m_curveParamWritePoint), s4.writeInBufferStream(this.m_curveData.m_segmentParams, this.m_curveData.m_curveParamWritePoint), this.m_curveData.m_curveParamWritePoint += t4, this.incCurveType(e5, 1), 1 !== n8 ? this.incCurveType(n8, -1) : this.modifyCurveCounter(1);
        else {
          const t5 = this.m_curveData.m_segmentParamIndex.read(r);
          s4.writeInBufferStream(this.m_curveData.m_segmentParams, t5);
        }
        this.m_curveData.m_segmentFlags.write(r, e5);
      }
    }
    const n6 = this.m_pathFlags.read(t3);
    1 & n6 || this.m_pathFlags.write(t3, 1 | n6), this.notifyModifiedFlags(2001);
  }
  closeAllPaths() {
    if (this.m_bPolygon || this.isEmptyImpl()) return;
    this.m_bPathStarted = false;
    let t3 = false;
    for (let e5 = 0, s4 = this.m_paths.size() - 1; e5 < s4; e5++) {
      if (this.isClosedPath(e5)) continue;
      const s5 = this.m_pathFlags.read(e5);
      this.m_pathFlags.write(e5, 1 | s5), t3 = true;
    }
    t3 && this.notifyModifiedFlags(512);
  }
  isClosedPath(t3) {
    return !!(1 & this.m_pathFlags.read(t3));
  }
  isClosedPathInXYPlane(t3) {
    if (this.isClosedPath(t3)) return true;
    const e5 = this.getPathStart(t3), s4 = this.getPathEnd(t3) - 1;
    if (e5 > s4) return false;
    const n6 = this.getXY(e5), i2 = this.getXY(s4);
    return n6.isEqualPoint2D(i2);
  }
  isClosedPathIn3D(t3) {
    return n2(0), false;
  }
  hasNonLinearSegmentsPath(t3) {
    if (!this.hasNonLinearSegments()) return false;
    for (let e5 = this.getPathStart(t3), s4 = this.getPathEnd(t3); e5 < s4; e5++) if (_Hs.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e5))) return true;
    return false;
  }
  isNonLinearSegment(t3) {
    return !(1 & this.getSegmentFlags(t3));
  }
  addEnvelope(t3, e5) {
    if (t3.isEmpty()) return;
    const s4 = 0 === this.m_pointCount;
    if (t3 instanceof n4) this.startPathCoords(t3.xmin, t3.ymin), e5 ? (this.lineToCoords(t3.xmax, t3.ymin), this.lineToCoords(t3.xmax, t3.ymax), this.lineToCoords(t3.xmin, t3.ymax)) : (this.lineToCoords(t3.xmin, t3.ymax), this.lineToCoords(t3.xmax, t3.ymax), this.lineToCoords(t3.xmax, t3.ymin));
    else {
      const s5 = t3.getDescription(), n6 = B3(), i2 = new ee({ vd: s5, attribBuffer: n6, initDefaultValues: false });
      for (let r = 0, o = 4; r < o; r++) {
        const s6 = e5 ? o - r - 1 : r;
        t3.queryCornerByVal(s6, i2), 0 === r ? this.startPathPoint(i2) : this.lineToPoint(i2);
      }
    }
    this.closePathWithLine(), this.m_bPathStarted = false, s4 && !e5 && (this.setDirtyFlagProtected(256, false), this.m_bPolygon && Math.min(t3.width(), t3.height()) > 0 && this.setIsSimple(3, 0));
  }
  addPathFromClosedSegment(t3, s4) {
    if (t3.isClosed() || P("add_path_from_closedSegment: segment must be closed"), s4) {
      const e5 = t3.getReversed(), s5 = new ee();
      e5.queryStart(s5), this.startPathPoint(s5), this.closeLastPathWithSegment(e5);
    } else {
      const e5 = new ee();
      t3.queryStart(e5), this.startPathPoint(e5), this.closeLastPathWithSegment(t3);
    }
  }
  addSegment_(t3, s4) {
    const n6 = t3.getDescription();
    this.mergeVertexDescription(n6);
    const r = B3(), o = new ee({ vd: n6, attribBuffer: r, initDefaultValues: false }), a2 = t3.getGeometryType();
    if (a2 === a.enumLine) (s4 || this.isEmptyImpl()) && (t3.queryStart(o), this.startPathPoint(o)), t3.queryEnd(o), this.lineToPoint(o);
    else {
      let n7 = false;
      if ((s4 || this.isEmptyImpl()) && (n7 = true), !n7) {
        t3.getStartXY().equals(this.getXY(this.m_pointCount - 1)) || P("add_segment: start point mismatch");
      }
      if (n7 && (t3.queryStart(o), this.startPathPoint(o)), this.beforeNewSegment(1), t3.queryEnd(o), o.getDescription() === this.m_description) this.setPointByVal(this.m_pointCount - 1, o);
      else {
        const t4 = B3(), e5 = new ee({ vd: this.m_description, attribBuffer: t4, initDefaultValues: false });
        o.copyCommonAttributesTo(e5), this.setPointByVal(this.m_pointCount - 1, e5);
      }
      const i2 = Bs2(t3);
      this.initSegmentData(i2), this.m_curveData.m_segmentParamIndex.write(this.m_pointCount - 2, this.m_curveData.m_curveParamWritePoint), t3.writeInBufferStream(this.m_curveData.m_segmentParams, this.m_curveData.m_curveParamWritePoint), this.m_curveData.m_curveParamWritePoint += i2;
      const r2 = Zs2.toSegType(a2);
      this.incCurveType(r2, 1), this.modifyCurveCounter(1), this.m_curveData.m_segmentFlags.write(this.m_pointCount - 2, r2);
    }
  }
  addSegment(t3, e5, s4) {
    s4 ? e5 ? this.addPathFromClosedSegment(t3, false) : this.closeLastPathWithSegment(t3) : this.addSegment_(t3, e5);
  }
  interpolateAttributesRange(t3, s4, n6, i2) {
    for (let a2 = t3; a2 < n6 - 1; a2++) this.isClosedPath(a2) && P("cannot interpolate across closed paths");
    const r = this.m_description.getAttributeCount();
    if (1 === r) return;
    const o = this.calculateSubLength2D(t3, s4, n6, i2);
    if (0 !== o) for (let e5 = 1; e5 < r; e5++) {
      const r2 = this.m_description.getSemantics(e5);
      this.interpolateAttributesSemanticsImpl(r2, t3, s4, n6, i2, o);
    }
  }
  interpolateAttributesSemantics(t3, s4, n6, i2, r) {
    if (0 === t3) return;
    this.hasAttribute(t3) || P("does not have the given attribute");
    2 === js2.getInterpolation(t3) && P("angular interpolation");
    for (let a2 = s4; a2 < i2 - 1; a2++) this.isClosedPath(a2) && P("cannot interpolate across closed paths");
    const o = this.calculateSubLength2D(s4, n6, i2, r);
    0 !== o && this.interpolateAttributesSemanticsImpl(t3, s4, n6, i2, r, o);
  }
  interpolateAttributesPath(t3, e5, s4) {
    const n6 = this.m_description.getAttributeCount();
    if (1 === n6) return;
    if (e5 === s4) return;
    const i2 = this.calculatePathSubLength2D(t3, e5, s4);
    for (let r = 1; r < n6; r++) {
      const n7 = this.m_description.getSemantics(r);
      this.interpolateAttributesSemanticsPathImpl(n7, t3, e5, s4, i2);
    }
  }
  interpolateAttributesSemanticsPath(t3, s4, n6, i2) {
    if (0 === t3) return;
    this.hasAttribute(t3) || P("does not have the given attribute");
    2 === js2.getInterpolation(t3) && P("angular interpolation");
    const r = this.calculatePathSubLength2D(s4, n6, i2);
    0 !== r && this.interpolateAttributesSemanticsPathImpl(t3, s4, n6, i2, r);
  }
  interpolateAttributesSemanticsImpl(t3, e5, s4, n6, i2, r) {
    const o = this.querySegmentIterator(), a2 = this.getPathStart(e5) + s4, h2 = this.getPathStart(n6) + i2, u = js2.getComponentCount(t3), m3 = Yt(js2.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t3, a2, m3, u);
    const l2 = Yt(js2.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t3, h2, l2, u);
    const c = Yt(js2.maxComponentCount(), Number.NaN);
    Dt(c, m3, 0, 0, u);
    let g2 = 0;
    const d2 = js2.getDefaultValue(t3), _ = js2.getInterpolation(t3);
    o.resetToVertex(a2, e5);
    do {
      if (o.hasNextSegment()) {
        if (o.nextSegment(), o.getStartPointIndex() === h2) return;
        this.setAttributeFromArray(t3, o.getStartPointIndex(), c, u), o.previousSegment();
        do {
          const e6 = o.nextSegment();
          if (o.getEndPointIndex() === h2) return;
          g2 += e6.calculateLength2D();
          wt(_, m3, l2, c, 0, u, g2 / r, d2), o.isClosingSegment() || this.setAttributeFromArray(t3, o.getEndPointIndex(), c, u);
        } while (o.hasNextSegment());
      }
    } while (o.nextPath());
  }
  interpolateAttributesSemanticsPathImpl(t3, e5, n6, i2, r) {
    n2(0 !== t3);
    const o = this.querySegmentIterator(), a2 = js2.getInterpolation(t3), h2 = this.getPathStart(e5) + n6, u = this.getPathStart(e5) + i2;
    if (u === h2) return;
    const m3 = js2.getComponentCount(t3), l2 = Yt(js2.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t3, h2, l2, m3);
    const c = Yt(js2.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t3, u, c, m3);
    const g2 = new n3(0);
    o.resetToVertex(h2, e5), o.setCirculator(this.isClosedPath(e5));
    const d2 = js2.getDefaultValue(t3), _ = Yt(js2.maxComponentCount(), Number.NaN);
    Dt(_, l2, 0, 0, m3);
    const p3 = 0 === r;
    let f3 = 0.5;
    do {
      const e6 = o.nextSegment();
      if (this.setAttributeFromArrayNoCurves(t3, o.getStartPointIndex(), _, m3), !p3) {
        const t4 = e6.calculateLength2D();
        g2.pe(t4), f3 = g2.getResult() / r;
      }
      wt(a2, l2, c, _, 0, m3, f3, d2);
    } while (o.getEndPointIndex() !== u);
  }
  querySegment(t3, s4, n6) {
    const i2 = this.getPathIndexFromPointIndex(t3), r = t3 - this.getPathStart(i2);
    r >= this.getSegmentCountPath(i2) && P("get_segment"), this.getSegmentFromPath(i2, r, s4, n6);
  }
  getSegment(t3, e5) {
    const s4 = new this.m_segmentBufferCTor();
    return this.getSegmentBuffer(t3, s4, e5), s4.releaseSegment();
  }
  getSegmentType(t3) {
    const s4 = this.getPathIndexFromPointIndex(t3), n6 = t3 - this.getPathStart(s4);
    return n6 >= this.getSegmentCountPath(s4) && P("get_segment"), this.getSegmentTypeFromPath(s4, n6);
  }
  getSegmentFromPath(t3, e5, s4, n6) {
    const i2 = this.getPathStart(t3) + e5, r = this.getSegmentFlagsStreamRef();
    let o = 1;
    switch (r && (o = 31 & r.read(i2)), o) {
      case 1:
        s4.createLine();
        break;
      case 2:
        s4.createCubicBezier();
        break;
      case 4:
        s4.createEllipticArc();
        break;
      case 8:
        s4.createQuadraticRationalBezier();
        break;
      case 16:
        s4.createQuadraticBezier();
        break;
      default:
        b("");
    }
    const a2 = s4.get();
    let u, m3 = null;
    n6 ? (m3 = M(), a2.assignVertexDescription(m3)) : a2.assignVertexDescription(this.m_description), u = i2 === this.getPathEnd(t3) - 1 && this.isClosedPath(t3) ? this.getPathStart(t3) : i2 + 1;
    We(a2, this.getXY(i2));
    if (Ze(a2, this.getXY(u)), !n6) for (let h2 = 1, l2 = this.m_description.getAttributeCount(); h2 < l2; h2++) {
      const t4 = this.m_description.getSemantics(h2), e6 = js2.getComponentCount(t4);
      for (let s5 = 0; s5 < e6; s5++) {
        const e7 = this.getAttributeAsDbl(t4, i2, s5);
        a2.setStartAttribute(t4, s5, e7);
        const n7 = this.getAttributeAsDbl(t4, u, s5);
        a2.setEndAttribute(t4, s5, n7);
      }
    }
    if (_Hs.isNonLinearSegmentFlag(o)) {
      const t4 = this.m_curveData.m_segmentParamIndex.read(i2);
      a2.readFromBufferStream(this.m_curveData.m_segmentParams, t4);
    }
  }
  replaceLinearEllipticalArcsWithTrueLines() {
    if (!this.hasNonLinearSegments()) return false;
    if (0 === this.m_curveData.m_arcCount) return false;
    let t3 = false;
    for (let e5 = 0, s4 = this.getPointCount(); e5 < s4; e5++) {
      if (4 === this.m_curveData.m_segmentFlags.read(e5)) {
        const s5 = this.m_curveData.m_segmentParamIndex.read(e5);
        zs2(this.m_curveData.m_segmentParams, s5).isNAN() && (this.m_curveData.m_segmentFlags.write(e5, 1), this.m_curveData.m_segmentParamIndex.write(e5, -1), this.incCurveType(4, -1), this.modifyCurveCounter(-1), t3 = true);
      }
    }
    return t3 && this.checkCompactSegmentParams(), t3;
  }
  queryPointAlongPath(t3, s4, n6, i2 = false) {
    const r = { iSegment: -1 }, o = i2 ? r : { tSegment: 0 };
    if (n6.setEmpty(), this.isEmpty()) return r;
    if ((t3 < 0 || t3 >= this.getPathCount()) && P("query_point_along_path"), s4 < 0) return r;
    const a2 = this.getPathSize(t3);
    if (0 === a2) return r;
    if (1 === a2) return this.getPointByVal(this.getPathStart(t3), n6), o.tSegment = 0, r.iSegment = this.getPathStart(t3), r;
    const h2 = this.querySegmentIteratorAtVertex(this.getPathStart(t3)), u = new n3(0);
    for (; h2.hasNextSegment(); ) {
      const t4 = h2.nextSegment(), e5 = t4.calculateLength2D(), i3 = u.getResult();
      if (u.add(e5), u.getResult() >= s4) {
        let a3 = s4 - i3;
        a3 > e5 && (a3 = e5);
        const u2 = t4.lengthToT(a3);
        return t4.queryCoord(u2, n6), o.tSegment = u2, r.iSegment = h2.getStartPointIndex(), r;
      }
    }
    if (this.isClosedPath(t3)) {
      const e5 = this.getPathStart(t3);
      return this.getPointByVal(e5, n6), o.tSegment = 1, r.iSegment = this.getPathEnd(t3) - 1, r;
    }
    {
      const e5 = this.getPathEnd(t3) - 1;
      return this.getPointByVal(e5, n6), this.getPathSize(t3) > 1 ? (o.tSegment = 1, r.iSegment = this.getPathEnd(t3) - 2, r) : (o.tSegment = 0, r.iSegment = this.getPathStart(t3), r);
    }
  }
  queryPointsAlongPath(t3, s4, n6, i2, r, o) {
    {
      let t4 = 0;
      for (let a3 = 0; a3 < s4; ++a3) i2 && i2[a3].setEmpty(), r && (r[a3] = -1), o && (o[a3] = 0), t4 > n6[a3] && P("query_points_along"), t4 = n6[a3];
    }
    const a2 = this.getPathSize(t3);
    if (0 === s4 || 0 === a2) return 0;
    if (1 === a2) {
      const e5 = this.getPathStart(t3);
      return i2 && this.getPointByVal(e5, i2[0]), o && (o[0] = 0), r && (r[0] = e5), 1;
    }
    const h2 = this.getPathStart(t3), u = new n3(0), m3 = this.querySegmentIteratorAtVertex(h2);
    let l2 = 0, c = 0, g2 = n6[l2];
    for (; m3.hasNextSegment(); ) {
      const t4 = m3.nextSegment(), e5 = t4.calculateLength2D(), a3 = u.getResult();
      for (u.add(e5); u.getResult() >= g2; ) {
        let h3 = g2 - a3;
        h3 > e5 && (h3 = e5);
        const u2 = t4.lengthToT(h3);
        if (i2 && t4.queryCoord(u2, i2[c]), o && (o[c] = u2), r && (r[c] = m3.getStartPointIndex()), c++, l2++, g2 = n6[l2], l2 === s4) return c;
      }
    }
    if (this.isClosedPath(t3)) {
      const e5 = this.getPathStart(t3), s5 = 0;
      i2 && this.getPointByVal(e5, i2[c]), o && (o[c] = s5), r && (r[c] = e5), c++;
    } else if (this.getPathSize(t3) > 1) {
      const e5 = this.getPathEnd(t3) - 2, s5 = 1;
      i2 && this.getPointByVal(e5 + 1, i2[c]), o && (o[c] = s5), r && (r[c] = e5), c++;
    }
    return c;
  }
  queryPointsAlong(t3, s4, n6, i2, r) {
    {
      let o2 = 0;
      for (let a3 = 0; a3 < t3; ++a3) n6 && n6[a3].setEmpty(), i2 && (i2[a3] = -1), r && (r[a3] = 0), o2 > s4[a3] && P("query_points_along"), o2 = s4[a3];
    }
    if (0 === t3) return 0;
    const o = new n3(0), a2 = this.querySegmentIterator();
    let h2 = -1, u = 0, m3 = 0, l2 = s4[u];
    for (; a2.nextPath(); ) for (; a2.hasNextSegment(); ) {
      h2 = a2.getPathIndex();
      const e5 = a2.nextSegment(), c = e5.calculateLength2D(), g2 = o.getResult();
      for (o.add(c); o.getResult() >= l2; ) {
        let o2 = l2 - g2;
        o2 > c && (o2 = c);
        const h3 = e5.lengthToT(o2);
        if (n6 && e5.queryCoord(h3, n6[m3]), r && (r[m3] = h3), i2 && (i2[m3] = a2.getStartPointIndex()), m3++, u++, l2 = s4[u], u === t3) return m3;
      }
    }
    if (h2 < 0) return 0;
    if (this.isClosedPath(h2)) {
      const t4 = this.getPathStart(h2), e5 = 0;
      n6 && this.getPointByVal(t4, n6[m3]), r && (r[m3] = e5), i2 && (i2[m3] = t4), m3++;
    } else if (this.getPathSize(h2) > 1) {
      const t4 = this.getPathEnd(h2) - 2, e5 = 1;
      n6 && this.getPointByVal(t4 + 1, n6[m3]), r && (r[m3] = e5), i2 && (i2[m3] = t4), m3++;
    }
    return m3;
  }
  querySegmentIterator() {
    return new Fs({ parent: this });
  }
  querySegmentIteratorAtVertex(t3) {
    return new Fs({ parent: this, pointIndex: t3 });
  }
  queryPathEnvelope(t3, e5) {
    this.queryPathEnvelopeImpl(t3, e5, true);
  }
  queryLoosePathEnvelope(t3, e5) {
    this.queryPathEnvelopeImpl(t3, e5, false);
  }
  queryPathEnvelopeImpl(t3, n6, i2) {
    if (n6 instanceof re && n2(0, "not implemented for Envelope"), n6 instanceof G3 && n2(0, "not implemented for Envelope3D"), (t3 >= this.getPathCount() || t3 < 0) && P(""), this.isEmpty()) return void n6.setEmpty();
    const r = this.getAttributeStreamRef(0), o = n4.constructEmpty();
    o.setEmpty();
    for (let e5 = 2 * this.getPathStart(t3), a2 = 2 * this.getPathEnd(t3); e5 < a2; ) {
      const t4 = a2 - e5;
      n2(!(1 & t4)), o.mergePointsInterleaved(r, e5 / 2, t4 / 2), e5 += t4;
    }
    if (n6.setCoords({ env2D: o }), this.hasNonLinearSegmentsPath(t3)) {
      const e5 = this.querySegmentIterator();
      if (e5.resetToPath(t3), e5.nextPath()) for (; e5.hasNextSegment(); ) {
        const t4 = e5.nextCurve();
        if (!t4) break;
        {
          const e6 = n4.constructEmpty();
          i2 ? t4.queryEnvelope(e6) : t4.queryLooseEnvelope(e6), n6.mergeEnvelope2D(e6);
        }
      }
      else n2(0);
    }
  }
  checkCompactSegmentParams() {
    if (!this.m_curveData || null === this.m_curveData.m_segmentParams) return false;
    if (this.m_curveData.m_segmentParams.size() <= this.m_vertexAttributes.get(0).size()) return false;
    const t3 = 10, e5 = ks(4) * this.m_curveData.m_arcCount + ks(2) * this.m_curveData.m_bezierCount + ks(8) * this.m_curveData.m_rbezier2Count + ks(16) * this.m_curveData.m_bezier2Count;
    return this.m_curveData.m_segmentParams.size() > Math.max(3 * e5 >> 1, t3) ? (this.forceCompactSegmentParams(), true) : (0 === this.m_pointCount && (this.m_curveData.m_curveParamWritePoint = 0), false);
  }
  forceCompactSegmentParams() {
    let t3 = 0;
    for (let n6 = 0, i2 = this.getPointCount(); n6 < i2; n6++) {
      const e6 = this.m_curveData.m_segmentFlags.read(n6);
      if (_Hs.isNonLinearSegmentFlag(e6)) {
        t3 += ks(e6);
      }
    }
    const e5 = $2(t3);
    let s4 = 0;
    for (let n6 = 0, i2 = this.getPointCount(); n6 < i2; n6++) {
      const t4 = this.m_curveData.m_segmentFlags.read(n6);
      if (_Hs.isNonLinearSegmentFlag(t4)) {
        let i3 = this.m_curveData.m_segmentParamIndex.read(n6);
        this.m_curveData.m_segmentParamIndex.write(n6, s4);
        const r = ks(t4);
        for (let t5 = 0; t5 < r; t5++) e5.write(s4, this.m_curveData.m_segmentParams.read(i3)), s4++, i3++;
      }
    }
    this.m_curveData.m_segmentParams = e5, this.m_curveData.m_curveParamWritePoint = s4;
  }
  setEmpty() {
    this.m_curveData && (this.removeAllCurvesFromGlobalCounter(), this.m_curveData = null), this.m_bPathStarted = false, this.m_paths = null, this.m_pathFlags = null, this.setEmptyImpl();
  }
  applyTransformation(t3) {
    this.applyTransformationToPath(t3, -1);
  }
  applyTransformation3D(t3) {
    n2(0);
  }
  getImpl() {
    return this;
  }
  reserve(t3) {
    this.reserveImpl(t3), t3 > 0 && !this.m_paths && (this.m_paths = J2(0), this.m_pathFlags = K2(0), this.m_paths.reserve(2), this.m_pathFlags.reserve(2), this.m_paths.resize(1, 0), this.m_pathFlags.resize(1, this.m_bPolygon ? 1 : 0));
  }
  reserveParts(t3, e5) {
    this.reserveImpl(t3), e5 > 0 && (this.m_paths ? (this.m_paths.reserve(e5 + 1), this.m_pathFlags.reserve(e5 + 1)) : (this.m_paths = J2(0), this.m_pathFlags = K2(0), this.m_paths.reserve(e5 + 1), this.m_pathFlags.reserve(e5 + 1), this.m_paths.resize(1, 0), this.m_pathFlags.resize(1, this.m_bPolygon ? 1 : 0)));
  }
  clone() {
    const t3 = this.createInstance();
    return this.copyTo(t3), t3;
  }
  queryLimitedSegmentIterator(t3) {
    return new Us2(this, t3);
  }
  getPathStreamRef() {
    return this.throwIfEmpty(), this.m_paths;
  }
  setPathStreamRef(t3) {
    this.m_paths = t3;
  }
  getSegmentFlagsStreamRef() {
    return this.throwIfEmpty(), null != this.m_curveData ? this.m_curveData.m_segmentFlags : null;
  }
  getPathFlagsStreamRef() {
    return this.throwIfEmpty(), this.m_pathFlags;
  }
  setPathFlagsStreamRef(t3) {
    this.m_pathFlags = t3;
  }
  getSegmentIndexStreamRef() {
    return this.throwIfEmpty(), null !== this.m_curveData ? this.m_curveData.m_segmentParamIndex : null;
  }
  getSegmentDataStreamRef() {
    return this.throwIfEmpty(), null !== this.m_curveData ? this.m_curveData.m_segmentParams : null;
  }
  setSegmentData(t3, e5, s4, n6) {
    this.m_curveData || (this.m_curveData = new Zs2()), this.m_curveData.m_segmentFlags = s4, this.m_curveData.m_segmentParams = e5, this.m_curveData.m_segmentParamIndex = t3, this.m_curveData.m_curveParamWritePoint = n6;
  }
  static getPathIndexFromPointIndexImpl(t3, e5, s4, n6) {
    if (n6 >= 0 && n6 < e5) {
      if (s4 >= t3.read(n6)) {
        if (s4 < t3.read(n6 + 1)) return n6;
        n6++;
      } else n6--;
      if (n6 >= 0 && n6 < e5 && s4 >= t3.read(n6) && s4 < t3.read(n6 + 1)) return n6;
    }
    if (e5 < 5) {
      for (let n7 = 0; n7 < e5; n7++) if (s4 < t3.read(n7 + 1)) return n7;
      v("");
    }
    let i2 = 0, r = e5 - 1;
    for (; r > i2; ) {
      const e6 = i2 + (r - i2 >> 1);
      if (s4 < t3.read(e6)) r = e6 - 1;
      else {
        if (!(s4 >= t3.read(e6 + 1))) return e6;
        i2 = e6 + 1;
      }
    }
    return i2;
  }
  getHighestPointIndex(t3) {
    n2(t3 >= 0 && t3 < this.getPathCount());
    const e5 = this.getAttributeStreamRef(0), n6 = this.getPathEnd(t3), i2 = this.getPathStart(t3);
    let r = -1;
    const o = new mi();
    o.y = Number.NEGATIVE_INFINITY, o.x = Number.NEGATIVE_INFINITY;
    for (let s4 = i2 + 0; s4 < n6; s4++) {
      const t4 = e5.readPoint2D(2 * s4);
      -1 === o.compare(t4) && (r = s4, o.setCoordsPoint2D(t4));
    }
    return r;
  }
  applyTransformationToPath(t3, s4) {
    if (s4 >= this.getPathCount() && P("apply_transformation"), this.isEmpty()) return;
    if (t3.isIdentity()) return;
    const n6 = this.m_vertexAttributes.get(0);
    if (!(s4 < 0 ? this.hasNonLinearSegments() : this.hasNonLinearSegmentsPath(s4))) {
      let e5, i3;
      return s4 < 0 ? (e5 = 0, i3 = this.m_pointCount) : (e5 = this.getPathStart(s4), i3 = this.getPathEnd(s4)), n6.applyTransformation(t3, 2 * e5, i3 - e5), void this.notifyModifiedFlags(2001);
    }
    const i2 = new this.m_segmentBufferCTor(), r = this.getPathCount();
    let o = s4 < 0 ? 0 : s4;
    do {
      const e5 = this.getPathStart(o), r2 = this.getPathEnd(o), a2 = this.isClosedPath(o), h2 = n6.readPoint2D(2 * e5);
      if (!this.hasNonLinearSegmentsPath(o)) {
        n6.applyTransformation(t3, 2 * e5, r2 - e5);
        continue;
      }
      const u = mi.getNAN();
      for (let s5 = e5; s5 < r2; ++s5) {
        if (1 !== (31 & this.m_curveData.m_segmentFlags.read(s5))) {
          const o3 = a2 && s5 + 1 === r2;
          o3 && n6.writePoint2D(2 * e5, h2), this.getSegmentBuffer(s5, i2, true), i2.get().applyTransformation(t3);
          const u2 = this.m_curveData.m_segmentParamIndex.read(s5);
          i2.get().writeInBufferStream(this.m_curveData.m_segmentParams, u2), n6.writePoint2D(2 * s5, i2.get().getStartXY()), o3 && n6.writePoint2D(2 * e5, i2.get().getEndXY());
          continue;
        }
        const o2 = 2 * s5;
        n6.queryPoint2D(o2, u), t3.transformInPlace(u), n6.writePoint2D(o2, u);
      }
      if (o === s4) break;
    } while (++o < r);
    this.notifyModifiedFlags(2001);
  }
  calculateSubLength2D(t3, e5, s4, n6) {
    const i2 = this.getPathStart(t3) + e5, r = this.getPathStart(s4) + n6;
    (r < i2 || i2 < 0 || r > this.getPointCount() - 1) && C("");
    const o = this.querySegmentIterator();
    let a2 = 0;
    o.resetToVertex(i2, t3);
    do {
      for (; o.hasNextSegment(); ) {
        const t4 = o.nextSegment();
        if (o.getStartPointIndex() === r) break;
        a2 += t4.calculateLength2D();
      }
      if (o.getStartPointIndex() === r) break;
    } while (o.nextPath());
    return a2;
  }
  calculatePathSubLength2D(t3, s4, n6) {
    const i2 = this.getPathStart(t3) + s4, r = this.getPathStart(t3) + n6;
    (i2 < 0 || r > this.getPointCount() - 1) && C("");
    const o = this.querySegmentIterator();
    if (i2 > r && (this.isClosedPath(t3) || P("cannot iterate across an open path"), o.setCirculator(true)), i2 === r) return 0;
    let a2 = 0, h2 = 0;
    o.resetToVertex(i2, t3);
    do {
      h2 += a2;
      a2 = o.nextSegment().calculateLength2D();
    } while (o.getStartPointIndex() !== r);
    return h2;
  }
  calculateEnvelope2D(t3) {
    return this.updateXYImpl(t3);
  }
  updateXYImpl(t3) {
    const e5 = super.updateXYImpl(t3);
    if (this.hasNonLinearSegments()) {
      const s4 = n4.constructEmpty(), n6 = this.querySegmentIterator();
      for (; n6.nextPath(); ) for (; n6.hasNextSegment(); ) {
        const i2 = n6.nextCurve();
        if (!i2) break;
        t3 ? i2.queryEnvelope(s4) : i2.queryLooseEnvelope(s4), e5.mergeEnvelope2D(s4);
      }
    }
    return e5;
  }
  notifyModifiedAllImpl() {
    null !== this.m_paths && this.m_paths.size() ? this.m_pointCount = this.m_paths.read(this.m_paths.size() - 1) : this.m_pointCount = 0;
  }
  setDirtyOGCFlags(t3) {
    this.setDirtyFlagProtected(16, t3);
  }
  hasDirtyOGCStartFlags() {
    return this.hasDirtyFlag(16);
  }
  setDirtyRingAreas2D(t3) {
    this.setDirtyFlagProtected(1024, t3);
  }
  hasDirtyRingAreas2D() {
    return this.hasDirtyFlag(1024);
  }
  static isNonLinearSegmentFlag(t3) {
    return !(1 & t3);
  }
  addAndExplicitlyOpenAllPaths(t3, s4) {
    this === t3 && P("Multi_path_impl::add");
    let n6 = this.getPathCount();
    for (let e5 = 0, i2 = t3.getPathCount(); e5 < i2; e5++) this.addPath(t3, e5, !s4), this.openPathAndDuplicateStartVertex(n6), n6++;
  }
  getSegmentFlags(t3) {
    return null !== this.m_curveData && null !== this.m_curveData.m_segmentFlags ? this.m_curveData.m_segmentFlags.read(t3) : 1;
  }
  getSegmentBuffer(t3, s4, n6) {
    const i2 = this.getPathIndexFromPointIndex(t3), r = t3 - this.getPathStart(i2);
    r >= this.getSegmentCountPath(i2) && P("getSegmentBuffer"), this.getSegmentFromPath(i2, r, s4, n6);
  }
  getSegmentTypeFromPath(t3, e5) {
    const s4 = this.getPathStart(t3) + e5, n6 = this.getSegmentFlagsStreamRef();
    let r = 1;
    switch (n6 && (r = 31 & n6.read(s4)), r) {
      case 1:
        return a.enumLine;
      case 2:
        return a.enumBezier;
      case 4:
        return a.enumEllipticArc;
      case 8:
        return a.enumRationalBezier2;
      case 16:
        return a.enumBezier2;
      default:
        b("");
    }
  }
  ensureXYMonotoneSegments() {
    if (!this.m_curveData) return false;
    let t3 = false;
    for (let e5 = 0, s4 = this.getPathCount(); e5 < s4; e5++) {
      const s5 = this.getPathStart(e5), n6 = this.getPathEnd(e5), i2 = n6 - s5;
      for (let e6 = s5; e6 < n6; e6++) {
        const n7 = 31 & this.m_curveData.m_segmentFlags.read(e6);
        if (1 === n7) continue;
        2 !== n7 && z("ensure_xy_monotone_segments");
        const r = (e6 - s5 + 1) % i2 + s5, o = this.m_curveData.m_segmentParamIndex.read(e6), h2 = Ot(mi, 4);
        h2[0] = this.getXY(e6), h2[3] = this.getXY(r), h2[1].x = this.m_curveData.m_segmentParams.read(o), h2[1].y = this.m_curveData.m_segmentParams.read(o + 1), h2[2].x = this.m_curveData.m_segmentParams.read(o + 2), h2[2].y = this.m_curveData.m_segmentParams.read(o + 3), Fe(h2) && (t3 = true, this.m_curveData.m_segmentParams.write(o, h2[1].x), this.m_curveData.m_segmentParams.write(o + 1, h2[1].y), this.m_curveData.m_segmentParams.write(o + 2, h2[2].x), this.m_curveData.m_segmentParams.write(o + 3, h2[2].y));
      }
    }
    return t3 && this.notifyModifiedFlags(2001), t3;
  }
  buildRasterizedGeometryAccelerator(t3, e5) {
    return false;
  }
  buildQuadTreeAccelerator(t3) {
    if (this.m_accelerators || (this.m_accelerators = new Vs2()), null !== this.m_accelerators.getQuadTree()) return true;
    this.ensureUniqueAccelerators(), this.m_accelerators.setQuadTree(null);
    const e5 = Wt2(this);
    return this.m_accelerators.setQuadTree(e5), true;
  }
  buildQuadTreeForPathsAccelerator(t3) {
    if (this.m_accelerators || (this.m_accelerators = new Vs2()), null !== this.m_accelerators.getQuadTreeForPaths()) return true;
    this.ensureUniqueAccelerators(), this.m_accelerators.setQuadTreeForPaths(null);
    const e5 = Qt2(this);
    return this.m_accelerators.setQuadTreeForPaths(e5), true;
  }
  updateCurveCounter(t3) {
    this.modifyCurveCounter(t3 - this.getCurveCount());
  }
  removeAllCurvesFromGlobalCounter() {
    this.m_curveData && (_Hs.st_totalCurveCount -= this.m_curveData.m_curveCount, this.m_curveData.m_curveCount = 0, this.m_curveData.m_bezierCount = 0, this.m_curveData.m_arcCount = 0, this.m_curveData.m_bezier2Count = 0, this.m_curveData.m_rbezier2Count = 0, this.m_curveData.m_curveParamWritePoint = 0);
  }
  modifyCurveCounter(t3) {
    t3 && (this.m_curveData || (this.m_curveData = new Zs2()), _Hs.st_totalCurveCount += t3, this.m_curveData.m_curveCount += t3);
  }
  getCurveCount() {
    return this.m_curveData ? this.m_curveData.m_curveCount : 0;
  }
  incCurveType(t3, e5) {
    this.m_curveData || (this.m_curveData = new Zs2()), 2 & t3 ? this.m_curveData.m_bezierCount += e5 : 4 & t3 ? this.m_curveData.m_arcCount += e5 : 8 & t3 ? this.m_curveData.m_rbezier2Count += e5 : 16 & t3 && (this.m_curveData.m_bezier2Count += e5);
  }
  getCurveWritePoint() {
    return null !== this.m_curveData ? this.m_curveData.m_curveParamWritePoint : 0;
  }
  initSegmentData(t3) {
    null === this.m_curveData && (this.m_curveData = new Zs2());
    const e5 = this.m_reservedPointCount > 0 ? this.m_reservedPointCount : this.m_pointCount;
    null === this.m_curveData.m_segmentParamIndex && (this.m_curveData.m_segmentFlags = K2(e5, 1), this.m_curveData.m_segmentParamIndex = J2(e5, -1));
    const s4 = this.m_curveData.m_curveParamWritePoint + t3;
    null === this.m_curveData.m_segmentParams ? this.m_curveData.m_segmentParams = $2(s4) : s4 !== this.m_curveData.m_segmentParams.size() && this.m_curveData.m_segmentParams.resize(s4, 0), this.m_curveData.m_segmentFlags.size() < e5 && (this.m_curveData.m_segmentFlags.resize(e5, 1), this.m_curveData.m_segmentParamIndex.resize(e5, -1));
  }
  updateCurveWritePoint(t3) {
    null === this.m_curveData && (this.m_curveData = new Zs2()), this.m_curveData.m_curveParamWritePoint = t3;
  }
  updateOGCFlagsHelper() {
    const t3 = this.getPathCount();
    if (0 === t3) return;
    const e5 = this.m_pathFlags;
    let s4 = 0;
    for (let n6 = 0; n6 < t3; n6++) {
      const t4 = this.m_cachedRingAreas2D.read(n6);
      0 === s4 && (s4 = K(t4)), t4 * s4 > 0 || 0 === s4 ? e5.setBits(n6, 8) : e5.clearBits(n6, 8);
    }
  }
  updateOGCFlagsProtected() {
    this.hasDirtyFlag(16) && (this.updateRingAreas2DProtected(), this.updateOGCFlagsHelper(), this.setDirtyFlagProtected(16, false));
  }
  replaceSegment(t3, n6, i2) {
    (t3 < 0 || t3 >= this.getPointCount()) && P("Multi_path_impl.replace_segment"), n2(n6.isCurve());
    const r = this.getPathIndexFromPointIndex(t3), o = this.getPathStart(r), a2 = (t3 - o + 1) % this.getPathSize(r) + o;
    {
      const e5 = this.getXY(t3), i3 = this.getXY(a2), r2 = !e5.isEqualPoint2D(n6.getStartXY()) || !i3.isEqualPoint2D(n6.getEndXY());
      n2(!r2);
    }
    this.replaceSegmentImpl(t3, a2, n6, i2);
  }
  replaceSegmentImpl(t3, e5, n6, i2) {
    const r = n6.getDescription();
    this.mergeVertexDescription(r);
    const o = Yt(32, Number.NaN), a2 = new ee({ vd: r, attribBuffer: o, initDefaultValues: false }), h2 = null === this.m_curveData ? 1 : 31 & this.m_curveData.m_segmentFlags.read(t3), u = ks(h2), m3 = Bs2(n6);
    let l2, c = false;
    u >= m3 ? (n2(null !== this.m_curveData), c = true, l2 = this.m_curveData.m_segmentParamIndex.read(t3)) : (this.initSegmentData(m3), c = false, l2 = this.m_curveData.m_curveParamWritePoint);
    const g2 = n6.getGeometryType(), d2 = Zs2.toSegType(g2);
    i2 || (n6.queryStart(a2), this.setPointByValNoCurves(t3, a2), n6.queryEnd(a2), this.setPointByValNoCurves(e5, a2)), this.m_curveData.m_segmentParamIndex.write(t3, 1 !== d2 ? l2 : -1), this.m_curveData.m_segmentFlags.write(t3, d2), 1 !== d2 && n6.writeInBufferStream(this.m_curveData.m_segmentParams, l2), c || (this.m_curveData.m_curveParamWritePoint += m3), h2 !== d2 && (this.incCurveType(h2, -1), this.incCurveType(d2, 1), this.modifyCurveCounter(1 === h2 ? 1 : -1));
  }
  setAttributeImpl(t3, s4, n6) {
    if (this.addAttribute(t3), !this.isEmpty()) if (this.hasNonLinearSegments() && 0 === t3) {
      (s4 < 0 || s4 > 1) && P("");
      const t4 = new x3(), i2 = 0 === s4 ? n6 : 0, r = 0 === s4 ? 0 : 1;
      t4.setShiftCoords(i2, r), 0 === s4 ? t4.xx = 0 : t4.yy = 0, this.applyTransformation(t4);
    } else super.setAttributeImpl(t3, s4, n6);
  }
};
Hs2.st_totalCurveCount = 0;
var Us2 = class {
  constructor(t3, e5) {
    this.m_segIter = null, this.m_quadTree = null, this.m_qtIter = null, this.m_extentOfInterest = new n4(e5), this.m_bfirst = true, this.m_prevIndex = -100, this.m_parent = t3;
  }
  nextSegment() {
    return this.m_bfirst && this.prepare_(), this.m_quadTree ? this.nextSegmentQt() : this.nextSegmentNoQt();
  }
  getPathIndex() {
    return this.m_segIter.getPathIndex();
  }
  getStartPointIndex() {
    return this.m_segIter.getStartPointIndex();
  }
  getEndPointIndex() {
    return this.m_segIter.getEndPointIndex();
  }
  isClosingSegment() {
    return this.m_segIter.isClosingSegment();
  }
  isPathClosed() {
    return this.m_segIter.isPathClosed();
  }
  prepare_() {
    const t3 = this.m_parent.getAccelerators();
    t3 && (this.m_quadTree = t3.getQuadTree(), this.m_quadTree && (this.m_qtIter = this.m_quadTree.getSortedIterator(this.m_extentOfInterest, 0))), this.m_segIter = this.m_parent.querySegmentIterator();
  }
  nextSegmentQt() {
    this.m_bfirst = false;
    const t3 = this.m_qtIter.next();
    if (-1 === t3) return null;
    const e5 = this.m_quadTree.getElement(t3);
    (e5 !== this.m_prevIndex + 1 || this.m_segIter.isLastSegmentInPath()) && (this.m_segIter.resetToVertex(e5, this.m_segIter.getPathIndex()), this.m_prevIndex = e5);
    return this.m_segIter.nextSegment();
  }
  nextSegmentNoQt() {
    for (; ; ) {
      if (!this.m_bfirst && this.m_segIter.hasNextSegment()) {
        const t3 = this.m_segIter.nextSegment(), e5 = n4.constructEmpty();
        if (t3.queryLooseEnvelope(e5), !e5.isIntersecting(this.m_extentOfInterest)) continue;
        return t3;
      }
      if (this.m_bfirst = false, !this.m_segIter.nextPath()) return null;
    }
  }
};
var Os2 = class _Os extends Hs2 {
  constructor(t3) {
    t3 ? t3.vd ? (super({ vd: t3.vd, bPolygon: false }), this.m_segmentBufferCTor = fm) : t3.copy ? (super({ vd: t3.copy.getDescription(), bPolygon: false }), this.m_segmentBufferCTor = fm, t3.copy.copyTo(this)) : t3.move ? (super({ move: t3.move }), this.m_segmentBufferCTor = fm) : t3.start ? (super({ vd: t3.start.getDescription(), bPolygon: false }), this.m_segmentBufferCTor = fm, this.startPathPoint(t3.start), this.lineToPoint(t3.end)) : t3.path ? (super({ bPolygon: false }), this.m_segmentBufferCTor = fm, this.addPathPoint2D(t3.path, t3.pointCount, t3.bForward)) : b("bad constructor arg") : (super({ bPolygon: false }), this.m_segmentBufferCTor = fm);
  }
  getBoundary() {
    return Ks(this);
  }
  assignCopy(t3) {
    return this !== t3 && t3.copyTo(this), this;
  }
  assignMove(t3) {
    return t3.copyTo(this), this;
  }
  getGeometryType() {
    return _Os.type;
  }
  getDimension() {
    return 1;
  }
  createInstance() {
    return new _Os({ vd: this.getDescription() });
  }
  equals(t3, e5) {
    return this.equalsBase(t3, e5);
  }
};
Os2.type = a.enumPolyline;
var Qs2 = a;
function Js2(t3, e5) {
  if (t3.isEmpty()) return false;
  const s4 = t3.getGeometryType();
  if (s4 === Qs2.enumPolygon) return 0 !== t3.calculateArea2D();
  if (s4 === Qs2.enumPolyline) return $s2(t3.getImpl(), e5, true).bNotEmpty;
  if (s4 === Qs2.enumEnvelope) return true;
  if (f(s4)) return !!t3.isClosed();
  if (l(s4)) return false;
  if (s4 === Qs2.enumGeometryCollection) {
    const s5 = t3;
    for (let t4 = 0, n6 = s5.getGeometryCount(); t4 < n6; t4++) if (Js2(s5.getGeometry(t4), e5)) return true;
    return false;
  }
  z("");
}
function Ks(t3, e5) {
  const s4 = t3.getGeometryType();
  if (s4 === Qs2.enumPolygon) {
    const e6 = new Os2({ vd: t3.getDescription() });
    return t3.isEmpty() || t3.copyToUnchecked(e6), e6;
  }
  if (s4 === Qs2.enumPolyline) return $s2(t3.getImpl(), e5, false).boundary;
  if (s4 === Qs2.enumEnvelope) {
    const e6 = new Os2({ vd: t3.getDescription() });
    return t3.isEmpty() || e6.addEnvelope(t3, false), e6;
  }
  if (f(s4)) {
    const e6 = new Ee({ vd: t3.getDescription() });
    if (!t3.isEmpty() && !t3.isClosed()) {
      const s5 = new ee();
      e6.reserve(2), t3.queryStart(s5), e6.add(s5), t3.queryEnd(s5), e6.add(s5);
    }
    return e6;
  }
  if (s4 === Qs2.enumGeometryCollection) {
    const s5 = t3;
    let n6 = null;
    for (let i2 = 0, r = s5.getGeometryCount(); i2 < r; i2++) {
      const r2 = Ks(s5.getGeometry(i2), e5);
      if (null !== r2) {
        null === n6 && (n6 = t3.createInstance());
        const e6 = r2;
        n6.addGeometry(e6);
      }
    }
    return n6;
  }
  if (l(s4)) return new ee({ vd: t3.getDescription() });
  z("");
}
function $s2(t3, e5, s4) {
  const n6 = false, i2 = t3;
  let r = null;
  if (s4 || (r = new Ee({ vd: i2.getDescription() })), !i2.isEmpty()) {
    const t4 = new st2(0);
    for (let e6 = 0, s5 = i2.getPathCount(); e6 < s5; e6++) {
      if (i2.getPathSize(e6) > 0 && !i2.isClosedPathInXYPlane(e6)) {
        const s6 = i2.getPathStart(e6);
        t4.add(s6);
        const n7 = i2.getPathEnd(e6) - 1;
        t4.add(n7);
      }
    }
    if (t4.size() > 0) {
      const e6 = new ot(), n7 = i2.getAttributeStreamRef(0), o = { userSort(t5, e7, s5) {
        const i3 = mi.getNAN(), r2 = mi.getNAN();
        s5.sort(t5, e7, (t6, e8) => (n7.queryPoint2D(2 * t6, i3), n7.queryPoint2D(2 * e8, r2), i3.compare(r2)));
      }, getValue: (t5) => n7.read(2 * t5 + 1) };
      e6.sort(t4, 0, t4.size(), o);
      let a2 = n7.readPoint2D(2 * t4.read(0)), h2 = 0, u = 1;
      const m3 = new ee();
      for (let i3 = 1, r2 = t4.size(); i3 < r2; i3++) {
        const e7 = n7.readPoint2D(2 * t4.read(i3));
        if (e7.isEqualPoint2D(a2)) t4.read(h2) > t4.read(i3) ? (t4.write(h2, vs()), h2 = i3) : t4.write(i3, vs()), u++;
        else {
          if (1 & u) {
            if (s4) return { bNotEmpty: true, boundary: new Ee({}) };
          } else t4.write(h2, vs());
          a2 = e7, h2 = i3, u = 1;
        }
      }
      if (1 & u) {
        if (s4) return { bNotEmpty: true, boundary: new Ee({}) };
      } else t4.write(h2, vs());
      if (!s4) {
        t4.sort(0, t4.size());
        for (let e7 = 0, s5 = t4.size(); e7 < s5 && t4.read(e7) !== vs(); e7++) i2.getPointByVal(t4.read(e7), m3), r.add(m3);
      }
    }
  }
  return s4 ? { bNotEmpty: n6, boundary: new Ee({}) } : { bNotEmpty: n6, boundary: r };
}
function tn(t3, e5, n6, i2) {
  const r = 4 * Qs() * (Math.abs(e5.vmin) + Math.abs(e5.vmax)), o = Qs();
  if (1 === t3.getMaxDerivative()) {
    n2(n6 > 0);
    const o2 = hn(t3, 0, e5, Qs(), r);
    return i2[0] = o2.root, o2.cRoots;
  }
  let a2, h2 = [];
  const u = new x2(e5.vmin - r, e5.vmax + r);
  h2.push(new mi(u.vmin, u.vmax));
  let m3 = 0;
  for (let s4 = t3.getMaxDerivative() - 1; s4 >= 0; s4--) {
    a2 = h2, h2 = [];
    for (let u2 = 0, l2 = a2.length; u2 < l2; u2++) {
      if (a2[u2][0] < a2[u2][1]) {
        let l3, c, g2;
        if (s4 === t3.getMaxDerivative() - 1 ? { root: l3, funcAtRoot: c, cRoots: g2 } = hn(t3, s4, x2.construct(a2[u2][0], a2[u2][1]), o, 0.5 * r) : { root: l3, funcAtRoot: c, cRoots: g2 } = un(t3, s4, x2.construct(a2[u2][0], a2[u2][1]), o, 0.5 * r), 1 === g2) {
          if (0 === s4) {
            if (m3 < n6) {
              if (a2[u2][0] <= e5.vmin && a2[u2][1] >= e5.vmin && l3 !== e5.vmin) {
                0 === t3.getValue(0, e5.vmin) && (l3 = e5.vmin);
              }
              if (a2[u2][0] <= e5.vmax && a2[u2][1] >= e5.vmax && l3 !== e5.vmax) {
                0 === t3.getValue(0, e5.vmax) && (l3 = e5.vmax);
              }
              i2[m3] = e5.snapClip(l3), m3 > 0 ? i2[m3] - i2[m3 - 1] > r && m3++ : m3++;
            }
          } else {
            const t4 = mi.getNAN();
            t4[0] = a2[u2][0], t4[1] = l3, h2.push(t4);
            const e6 = mi.getNAN();
            e6[0] = l3, e6[1] = a2[u2][1], h2.push(e6);
          }
          continue;
        }
      }
      h2.push(a2[u2]);
    }
  }
  return m3;
}
function en(t3, e5, s4, n6) {
  const i2 = new p2(), r = cn(new p2(t3), new p2(e5), s4, i2);
  return n6[0] = i2.value(), r;
}
function sn(t3, e5, s4, n6, i2, r) {
  const o = Ot(p2, 2), a2 = gn(new p2(t3), new p2(e5), new p2(s4), n6, i2, o);
  return r[0] = o[0].value(), r[1] = o[1].value(), a2;
}
function nn(t3, e5, s4, n6, i2, r, o) {
  const a2 = Ot(p2, 3), h2 = dn(new p2(t3), new p2(e5), new p2(s4), new p2(n6), i2, r, a2);
  return o[0] = a2[0].value(), o[1] = a2[1].value(), o[2] = a2[2].value(), h2;
}
function rn(t3, e5, s4, n6, i2, r, o, a2) {
  return an(t3, e5, s4, n6, i2, r, o, a2);
}
function on(t3, e5, s4, n6, i2, r) {
  return ln(t3, e5, s4, n6, i2, r);
}
function an(t3, e5, s4, n6, i2, r, o, a2) {
  const h2 = Yt(s4 * s4, Number.NaN);
  h2.fill(0), Dt(a2, n6, 0, 0, s4);
  const u = Yt(s4, Number.NaN), m3 = Yt(s4, Number.NaN), l2 = Yt(s4, Number.NaN);
  let c = t3(a2, s4, e5);
  const g2 = 100;
  let d2 = 0;
  for (d2 = 0; d2 < g2; d2++) {
    const n7 = c;
    for (let t4 = 0; t4 < s4; ++t4) m3[t4] = a2[t4];
    if (d2 % s4 === 0) {
      h2.fill(0);
      for (let t4 = 0; t4 < s4; t4++) h2[t4 * s4 + t4] = 1;
    }
    let o2 = 0, g3 = 0;
    for (let m4 = 0; m4 < s4; ++m4) {
      for (let t4 = 0; t4 < s4; ++t4) u[t4] = h2[m4 * s4 + t4];
      const n8 = c;
      c = mn(t3, e5, a2, u, i2, r, s4);
      const l3 = n8 - c;
      l3 > o2 && (g3 = m4, o2 = l3);
    }
    for (let t4 = 0; t4 < s4; t4++) u[t4] = a2[t4] - m3[t4], l2[t4] = a2[t4] + (a2[t4] - m3[t4]);
    const _ = t3(l2, s4, e5);
    if (_ < n7) {
      if (2 * (n7 - 2 * c + _) * H(n7 - c - o2) < H(n7 - _) * o2) {
        c = mn(t3, e5, a2, u, i2, r, s4);
        for (let t4 = 0; t4 < s4; ++t4) h2[g3 * s4 + t4] = h2[(s4 - 1) * s4 + t4], h2[(s4 - 1) * s4 + t4] = u[t4];
      }
    }
    if (n7 <= c) return t3(a2, s4, e5);
  }
  return c;
}
function hn(t3, e5, s4, n6, i2) {
  const r = { root: 0, funcAtRoot: 0, cRoots: 0 };
  let o = s4.vmin, a2 = s4.vmax, u = 0, m3 = Number.MAX_VALUE, l2 = t3.getValue(e5, o), c = t3.getValue(e5, a2), g2 = 0, d2 = 0, _ = 0;
  if (l2 >= 0 && c >= 0 || l2 <= 0 && c <= 0) return Math.abs(l2) < Math.abs(c) ? (r.funcAtRoot = l2, r.root = o, r.cRoots = 0 === l2 ? 1 : 0, r) : (r.funcAtRoot = c, r.root = a2, r.cRoots = 0 === c ? 1 : 0, r);
  Math.abs(l2) < Math.abs(c) && (a2 = Pt(o, o = a2), c = Pt(l2, l2 = c)), u = o, g2 = l2;
  let p3 = true, f3 = 0;
  for (; 0 !== c && Math.abs(o - a2) > n6 * Math.abs(a2) + i2; f3++) {
    let s5 = f3 > 64;
    if (!s5) {
      d2 = l2 !== g2 && c !== g2 ? o * c * g2 / ((l2 - c) * (l2 - g2)) + a2 * l2 * g2 / ((c - l2) * (c - g2)) + u * l2 * c / ((g2 - l2) * (g2 - c)) : a2 - c * (a2 - o) / (c - l2);
      const t4 = (3 * o + a2) / 4;
      if (s5 = !(d2 > t4 && d2 < a2 || d2 > a2 && d2 < t4), !s5) {
        const t5 = n6 * Math.abs(a2) + i2;
        if (p3) {
          const e6 = Math.abs(a2 - u);
          s5 = Math.abs(d2 - a2) >= 0.5 * e6 || e6 < t5;
        } else {
          const e6 = Math.abs(u - m3);
          s5 = Math.abs(d2 - a2) >= 0.5 * e6 || e6 < t5;
        }
      }
    }
    if (s5 ? (d2 = (o + a2) / 2, p3 = true) : p3 = false, _ = t3.getValue(e5, d2), 0 === _) return r.root = d2, r.funcAtRoot = _, r.cRoots = 1, r;
    if (!s5) {
      const s6 = o - d2, n7 = d2 - a2;
      if (Math.abs(s6) > 10 * Math.abs(n7)) {
        let s7 = a2 + 3 * n7;
        for (let n8 = 0; n8 < 2; n8++) {
          const n9 = t3.getValue(e5, s7);
          K(l2) * K(n9) > 0 ? (o = s7, l2 = n9) : s7 = Q(o, a2, 0.75);
        }
      } else if (Math.abs(n7) > 10 * Math.abs(s6)) {
        let n8 = o - 3 * s6;
        for (let s7 = 0; s7 < 2; ++s7) {
          const s8 = t3.getValue(e5, n8);
          K(c) * K(s8) > 0 ? (a2 = n8, c = s8) : n8 = Q(o, a2, 0.25);
        }
      }
    }
    m3 = u, u = a2, g2 = c, K(l2) * K(_) < 0 ? (a2 = d2, c = _) : (o = d2, l2 = _), Math.abs(l2) < Math.abs(c) && (a2 = Pt(o, o = a2), c = Pt(l2, l2 = c)), 128 === f3 && b("Root_finder iterations exceeded");
  }
  return r.root = a2, r.funcAtRoot = c, r.cRoots = 1, r;
}
function un(t3, e5, s4, n6, i2) {
  const r = { root: 0, funcAtRoot: 0, cRoots: 0 };
  let o = s4.vmin, a2 = t3.getValue(e5, o), u = s4.vmax, m3 = t3.getValue(e5, u);
  if (a2 >= 0 && m3 >= 0 || a2 <= 0 && m3 <= 0) return Math.abs(a2) < Math.abs(m3) ? (r.funcAtRoot = a2, r.root = o, r.cRoots = 0 === a2 ? 1 : 0, r) : (r.funcAtRoot = m3, r.root = u, r.cRoots = 0 === m3 ? 1 : 0, r);
  m3 < 0 && (m3 = Pt(a2, a2 = m3), u = Pt(o, o = u));
  let l2 = 0.5 * (o + u), c = Math.abs(u - o), g2 = c, d2 = t3.getValue(e5, l2), _ = t3.getValue(e5 + 1, l2);
  const p3 = 1, f3 = 4;
  let P5 = f3;
  const y2 = 2;
  let x4 = 1, C3 = 0, v3 = 0, b2 = p3;
  const S3 = 32;
  let E2 = 0;
  for (; ++E2 < 100; ) {
    let s5;
    E2 > S3 || 0 === _ || b2 === y2 && C3 > 1 || b2 === p3 && P5 < f3 ? (b2 = p3, x4 > 1 && x4--) : (b2 = y2, v3 > 1 && Math.abs(2 * d2) > Math.abs(c * _) && x4++), c = g2;
    let n7 = false;
    if (b2 === p3) do {
      if (v3 > 2) {
        const t4 = 16 * Math.abs(c);
        if (0.5 * Math.abs(o - u) > t4) {
          const e6 = Math.min(o, u), n8 = Math.max(o, u);
          if (l2 === e6) {
            s5 = l2, l2 = e6 + t4, g2 = l2 - s5;
            break;
          }
          if (l2 === n8) {
            s5 = l2, l2 = n8 - t4, g2 = l2 - s5;
            break;
          }
        }
      }
      g2 = 0.5 * (u - o), s5 = l2, l2 = o + g2, n7 = o === l2 || u === l2;
    } while (0);
    else for (; ; ) {
      g2 = x4 * d2 / _, s5 = l2, l2 -= g2, n7 = l2 === s5;
      const t4 = Math.min(o, u), e6 = Math.max(o, u);
      if (l2 < t4) {
        if (x4 > 1) {
          l2 = s5, x4--;
          continue;
        }
        g2 = s5 - t4, l2 = t4;
      } else if (l2 > e6) {
        if (x4 > 1) {
          l2 = s5, x4--;
          continue;
        }
        g2 = s5 - e6, l2 = e6;
      }
      break;
    }
    if (n7 || Math.abs(g2) < i2) {
      s5 !== l2 && (d2 = t3.getValue(e5, l2));
      break;
    }
    d2 = t3.getValue(e5, l2), _ = t3.getValue(e5 + 1, l2);
    const r2 = o, h2 = u;
    d2 < 0 ? (a2 = d2, o = l2) : (m3 = d2, u = l2), b2 === y2 && (o === r2 && u === h2 || v3 > 1 && Math.abs(g2) >= 0.5001 * Math.abs(c)) ? C3++ : C3 = 0, b2 === p3 ? (P5++, v3 = 0) : (P5 = 0, v3++);
  }
  return 100 === E2 && b("Root_finder iterations exceeded"), r.root = l2, r.funcAtRoot = d2, r.cRoots = 1, r;
}
function mn(t3, e5, s4, n6, i2, r, o) {
  const a2 = n6.slice(0, o);
  let h2 = 0;
  for (let f3 = 0; f3 < o; f3++) h2 += n6[f3] * n6[f3];
  if (h2 = Math.sqrt(h2), h2 > 0) for (let f3 = 0; f3 < o; f3++) a2[f3] /= h2;
  let u = Number.NEGATIVE_INFINITY, m3 = Number.POSITIVE_INFINITY;
  {
    const t4 = Yt(o, 0);
    for (let e6 = 0; e6 < o; e6++) t4[e6] = e6;
    t4.sort((t5, e6) => {
      const s5 = Math.abs(a2[t5]), n7 = Math.abs(a2[e6]);
      return s5 < n7 ? -1 : s5 > n7 ? 1 : 0;
    });
    for (let e6 = 0; e6 < o; e6++) {
      const n7 = t4[e6];
      if (0 === a2[n7]) continue;
      let o2 = (i2[n7] - s4[n7]) / a2[n7], h3 = (r[n7] - s4[n7]) / a2[n7];
      h3 < o2 && (h3 = Pt(o2, o2 = h3)), o2 > u && (u = o2), h3 < m3 && (m3 = h3);
    }
  }
  let l2 = 0;
  const c = (Math.abs(u) + Math.abs(m3)) * Qs() * 100, g2 = Yt(o, Number.NaN), d2 = a2.slice();
  function _(n7, i3) {
    for (let t4 = 0, e6 = o; t4 < e6; t4++) g2[t4] = s4[t4] + n7 * d2[t4];
    return t3(g2, o, e5);
  }
  c > 0 && (l2 = on(_, null, u, 0, m3, c));
  const p3 = _(l2);
  for (let f3 = 0, P5 = o; f3 < P5; f3++) s4[f3] = Us(g2[f3], i2[f3], r[f3]);
  return p3;
}
function ln(t3, e5, s4, n6, i2, r) {
  const o = Os();
  let a2 = n6, h2 = t3(a2, e5), u = s4, m3 = i2, l2 = t3(u, e5), c = t3(m3, e5);
  h2 > l2 && (h2 = l2, a2 = u), h2 > c && (h2 = c, a2 = m3);
  let g2 = u, d2 = m3, _ = l2, p3 = c;
  _ > p3 && (_ = Pt(p3, p3 = _), d2 = Pt(g2, g2 = d2));
  let f3 = a2 - g2, P5 = g2 - d2;
  const y2 = 0.5 * Math.min(r, m3 - u), x4 = 2 * y2, C3 = 100;
  let v3, b2 = 0;
  for (v3 = 0; v3 < C3 && !(m3 - u <= x4); ++v3) {
    const s5 = u + 0.5 * (m3 - u);
    let n7 = b2 > 0;
    if (!n7 && Math.abs(P5) <= y2 && (n7 = true, b2 = 3), !n7) {
      const t4 = a2 - g2, e6 = a2 - d2, s6 = t4 * (h2 - p3);
      let i4 = e6 * (h2 - _), r3 = e6 * i4 - t4 * s6;
      i4 = 2 * (i4 - s6), i4 > 0 && (r3 = -r3), i4 = Math.abs(i4), 0 === i4 || Math.abs(r3) >= Math.abs(i4 * P5 / 2) || r3 <= i4 * (u - a2) || r3 >= i4 * (m3 - a2) ? (n7 = true, b2 = 3) : (P5 = f3, f3 = r3 / i4);
    }
    n7 && (P5 = a2 >= s5 ? u - a2 : m3 - a2, f3 = o * P5, b2--);
    let i3 = a2 + f3;
    i3 < u + y2 ? i3 = u + y2 : i3 > m3 - y2 && (i3 = m3 - y2);
    const r2 = t3(i3, e5);
    r2 < h2 ? (i3 >= a2 ? (u = a2, l2 = h2) : (m3 = a2, c = h2), d2 = g2, g2 = a2, a2 = i3, p3 = _, _ = h2, h2 = r2) : (i3 < a2 ? (u = i3, l2 = r2) : (m3 = i3, c = r2), r2 <= _ || g2 === a2 ? (d2 = g2, g2 = i3, p3 = _, _ = r2) : (r2 <= p3 || d2 === a2 || d2 === g2) && (d2 = i3, p3 = r2));
  }
  return a2;
}
function cn(t3, e5, s4, n6) {
  return t3.isZero() ? e5.isZero() ? -1 : 0 : (n6.setE(e5.clone().negateThis().divThisE(t3)), s4.containsCoordinate(n6.value()) ? 1 : 0);
}
function gn(t3, e5, s4, n6, i2, r) {
  if (0 === t3.value()) {
    if (i2) return r[0].set(1), n6.containsCoordinate(r[0].value()) ? 1 : 0;
    return cn(e5, s4, n6, r[0]);
  }
  if (i2) {
    let e6 = 2;
    return r[0].set(1), r[1].setE(s4).divThisE(t3), r[1].eq(r[0]) && (r[1].set(1), e6 = 1), n6.containsCoordinate(r[1].value()) || (e6 = 1), n6.containsCoordinate(r[0].value()) || (e6--, r[0].setE(r[1])), 2 === e6 && r[0].value() > r[1].value() && (r[1] = Pt(r[0], r[0] = r[1])), e6;
  }
  const o = e5.clone().sqrThis().subThisE(t3.clone().mulThisE(s4).mulThisE(D2));
  if (o.lt(I2)) return 0;
  const a2 = new p2(e5.value() >= 0 ? 1 : -1), h2 = o.clone().sqrtThis(), u = new p2(-0.5).mulThisE(e5.clone().addThisE(a2.clone().mulThisE(h2)));
  let m3 = 0;
  r[0].setE(u.divE(t3));
  const l2 = new p2(r[0].value()), c = new p2(t3.value()).mulE(l2).addE(new p2(e5.value()).mulE(l2).addE(new p2(s4.value())));
  return c.isZero() || Cn(r[0], t3, e5, s4, r[0]), n6.containsCoordinate(r[0].value()) && m3++, 0 !== h2.value() && 0 !== u.value() ? (r[m3].assign(s4.divE(u)), l2.set(r[m3].value()), c.assign(new p2(t3.value()).mulE(l2).addE(new p2(e5.value()).mulE(l2).addE(new p2(s4.value())))), c.isZero() || Cn(r[m3], t3, e5, s4, r[m3]), n6.containsCoordinate(r[m3].value()) && m3++, 2 === m3 && r[0].value() > r[1].value() && (r[1] = Pt(r[0], r[0] = r[1])), m3) : m3;
}
function dn(t3, e5, s4, n6, i2, r, o) {
  if (0 === t3.value()) {
    return gn(e5, s4, n6, i2, r, o);
  }
  if (r) {
    let s5 = 1;
    o[0].set(1);
    const r2 = o.slice(s5), a2 = gn(t3, e5.addE(t3), n6.negate(), i2, false, r2);
    if (a2 > 0) {
      s5 += a2;
      for (let t4 = 1; t4 < s5; t4++) o[t4].eq(w2) && (o[s5 - 1] = Pt(o[t4], o[t4] = o[s5 - 1]), s5--);
    }
    const h2 = o.slice(0, s5);
    h2.sort((t4, e6) => t4.value() < e6.value() ? -1 : t4.value() > e6.value() ? 1 : 0);
    for (let t4 = 0; t4 < s5; ++t4) o[t4] = h2[t4];
    return s5;
  }
  return vn(t3, e5, s4, n6, i2, o);
}
function _n(t3, s4, n6, i2, r, o) {
  return (o < s4 || s4 < 0) && P("nth_degree_real_roots"), bn(t3, s4, n6, i2, r);
}
function pn(t3, e5, s4, n6) {
  return { coef0: t3.clone(), coef1: e5.clone(), coef2: s4.clone(), coef3: n6.clone(), calcF(t4) {
    return this.coef0.clone().mulThis(t4).addThisE(this.coef1).mulThis(t4).addThisE(this.coef2).mulThis(t4).addThisE(this.coef3);
  }, calcDF(t4) {
    return this.coef0.clone().mulThis(3).mulThis(t4).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(t4).addThisE(this.coef2);
  }, estimateError(t4) {
    const e6 = Math.abs(t4), s5 = ((this.coef0.eps() * e6 + this.coef1.eps()) * e6 + this.coef2.eps()) * e6 + this.coef3.eps() + this.calcF(t4).eps(), n7 = this.coef0.clone().mulThis(t4).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(t4).addThisE(this.coef2);
    if (n7.isZero()) {
      const e7 = this.coef0.clone().mulThis(t4).mulThis(6).addThisE(this.coef1.clone().mulThis(2));
      if (e7.isZero()) {
        const t5 = this.coef0.clone().mulThis(6);
        return Math.pow(6 * s5 / Math.abs(t5.value()), 1 / 3);
      }
      return Math.sqrt(2 * s5 / Math.abs(e7.value()));
    }
    return s5 / Math.abs(n7.value());
  } };
}
var fn = class {
  updateCoefs(t3) {
    if (this.lastDeriv1 === t3) return this.curCoefs = this.derivCoefs1, void (this.lastUsed = 1);
    if (this.lastDeriv2 === t3) return this.curCoefs = this.derivCoefs2, void (this.lastUsed = 2);
    let e5;
    1 === this.lastUsed ? (e5 = this.derivCoefs2, this.lastDeriv2 = t3, this.lastUsed = 2) : (e5 = this.derivCoefs1, this.lastDeriv1 = t3, this.lastUsed = 1), e5.length = 0;
    for (let s4 = 0, n6 = this.truePower - t3; s4 <= n6; ++s4) {
      e5.push(this.coefs[s4 + t3].clone());
      let n7 = s4 + t3, i2 = n7--;
      for (let e6 = 1; e6 < t3; e6++) i2 *= n7--;
      e5[s4].mulThis(i2);
    }
    this.curCoefs = e5;
  }
  constructor(t3, e5, s4, n6) {
    this.derivCoefs1 = [], this.derivCoefs2 = [], this.lastDeriv1 = -1, this.lastDeriv2 = -1, this.lastUsed = -1, this.curCoefs = null, this.coefs = t3, this.power = e5, this.truePower = 0;
    for (let i2 = e5; i2 >= 1; i2--) if (0 !== this.coefs[i2].value()) {
      this.truePower = i2;
      break;
    }
  }
  getMaxDerivative() {
    return this.truePower + 1;
  }
  getValue(t3, e5) {
    let s4 = this.coefs;
    0 === t3 ? s4 = this.coefs : (this.updateCoefs(t3), s4 = this.curCoefs);
    const n6 = new n3(0);
    let i2 = 1;
    for (let r = 0, o = this.truePower - t3; r <= o; ++r) n6.pe(i2 * s4[r].value()), i2 *= e5;
    return n6.getResult();
  }
  getError(t3) {
    const e5 = Math.abs(t3), s4 = new n3(0), n6 = new p2(1), i2 = new p2(0);
    for (let o = 0, a2 = this.power; o <= a2; ++o) i2.addThisE(this.coefs[o].mulE(n6)), s4.pe(n6.value() * this.coefs[o].eps()), n6.mulThis(e5);
    s4.pe(i2.eps());
    let r = 1;
    for (let o = 1; o <= this.truePower; ++o) {
      r *= o, this.updateCoefs(o);
      const e6 = new p2(1), n7 = new p2(0);
      for (let s5 = 0, i3 = this.truePower - o; s5 <= i3; ++s5) n7.addThisE(this.curCoefs[s5].mulE(e6)), e6.mulThis(t3);
      if (!n7.isZero()) return Math.pow(r * s4.getResult() / Math.abs(n7.value()), 1 / o);
    }
    return 0;
  }
};
function Pn(t3, e5, s4, n6, i2, r) {
  let o = t3, a2 = e5, h2 = a2 - o;
  if (!r) {
    let s5 = n6.calcF(t3).value(), i3 = n6.calcF(e5).value();
    if ((s5 > 0 || s5 > i3) && (a2 = Pt(o, o = a2), i3 = Pt(s5, s5 = i3)), s5 >= 0 || i3 <= 0) return false;
  }
  let u, m3 = false, l2 = s4, c = 0;
  for (; c < 100; c++) {
    const t4 = n6.calcF(l2);
    if (u = n6.calcDF(l2), u.isZero()) return false;
    if (!t4.value() || c > 3 && t4.isZero()) {
      m3 = true;
      break;
    }
    r || (t4.value() < 0 ? o = l2 : a2 = l2);
    const e6 = t4.value() / u.value(), s5 = l2 - e6;
    r || (s5 >= o && s5 <= a2 || s5 >= a2 && s5 <= o) && Math.abs(e6) <= 0.5 * h2 ? (l2 = s5, h2 = Math.abs(e6)) : (h2 = Math.abs(0.5 * (a2 - o)), l2 = 0.5 * (o + a2));
  }
  return !!m3 && (i2.set(l2, n6.estimateError(l2)), true);
}
function yn(t3, e5, s4, n6, i2, r, o, a2) {
  return Pn(t3, e5, s4.value(), pn(n6, i2, r, o), a2, false);
}
var xn = class {
  constructor(t3, e5, s4) {
    this.coefs = Ot(p2, 3), this.coefs[0].setE(t3), this.coefs[1].setE(e5), this.coefs[2].setE(s4);
  }
  calcF(t3) {
    const e5 = new p2(t3);
    return this.coefs[0].mulE(e5).addE(this.coefs[1]).mulE(e5).addE(this.coefs[2]);
  }
  calcDF(t3) {
    const e5 = new p2(t3);
    return p2.st_mulByPower2(this.coefs[0], 2).mulE(e5).addE(this.coefs[1]);
  }
  estimateError(t3) {
    const e5 = Math.abs(t3), s4 = (this.coefs[0].eps() * e5 + this.coefs[1].eps()) * e5 + this.coefs[2].eps() + this.calcF(t3).eps(), n6 = new p2(2).mulE(this.coefs[0]).mul(t3).addE(this.coefs[1]);
    if (n6.isZero()) {
      const t4 = this.coefs[0].value();
      return Math.sqrt(s4 / Math.abs(t4));
    }
    return s4 / Math.abs(n6.value());
  }
};
function Cn(t3, e5, s4, n6, i2) {
  return Pn(0, 0, t3.value(), new xn(e5, s4, n6), i2, true);
}
function vn(t3, e5, s4, n6, i2, r) {
  const o = Ot(p2, 3);
  let a2 = 0;
  const u = e5.negate().divThisE(t3.clone().mulThis(3));
  i2.containsCoordinate(u.value()) && (o[0].setE(u), a2 = 1);
  const m3 = Ot(p2, 2), l2 = gn(t3.mul(3), e5.mul(2), s4, i2, false, m3);
  if (l2 < 0) return n6.isZero() ? -1 : 0;
  for (let h2 = 0; h2 < l2; h2++) i2.containsCoordinate(m3[h2].value()) && o[a2++].setE(m3[h2]);
  Zt(o, 0, a2, (t4, e6) => t4.value() < e6.value() ? -1 : t4.value() > e6.value() ? 1 : 0);
  const c = Ot(p2, 5);
  c[0].set(i2.vmin);
  for (let h2 = 0; h2 < a2; h2++) c[1 + h2].setE(o[h2]);
  c[1 + a2].set(i2.vmax);
  const g2 = a2 + 2;
  let d2 = 1, _ = 0;
  {
    const i3 = c[0].clone();
    if (t3.clone().mulThisE(i3).addThisE(e5).mulThisE(i3).addThisE(s4).mulThisE(i3).addThisE(n6).isZero()) {
      const o2 = pn(t3, e5, s4, n6);
      i3.setError(o2.estimateError(i3.value())), r[_] = i3, _++, d2++;
    }
  }
  for (let p3 = d2; p3 < g2; p3++) {
    const o2 = c[p3].clone(), a3 = t3.clone().mulThisE(o2).addThisE(e5).mulThisE(o2).addThisE(s4).mulThisE(o2).addThisE(n6).isZero();
    if (a3 || !c[p3].eq(c[p3 - 1])) {
      if (a3 || yn(c[p3 - 1].value(), c[p3].value(), c[p3 - 1].clone().addThisE(c[p3]).divThisByPower2(2), t3, e5, s4, n6, o2)) {
        if (_ > 0 && o2.eq(r[_ - 1])) continue;
        if (_ >= 3 && b("cubic_polynomial_solver_too_many_roots"), a3) {
          const i3 = pn(t3, e5, s4, n6);
          o2.setError(i3.estimateError(o2.value()));
        }
        r[_] = o2, _++;
      }
      if (c[p3].value() === i2.vmax) break;
      a3 && p3++;
    }
  }
  return _;
}
function bn(t3, e5, s4, n6, i2, r) {
  const o = new fn(t3, e5, s4, Qs());
  let a2 = 0;
  if (2 === o.truePower) a2 = gn(t3[2], t3[1], t3[0], s4, n6, i2);
  else if (1 === o.truePower) a2 = cn(t3[1], t3[0], s4, i2[0]);
  else {
    if (0 === o.truePower) return t3[0].value() ? 0 : -1;
    {
      const t4 = [];
      t4.length = e5, a2 = tn(o, s4, e5, t4);
      for (let e6 = 0; e6 < a2; e6++) i2[e6].set(t4[e6]);
    }
  }
  for (let h2 = 0; h2 < a2; h2++) i2[h2].setError(o.getError(i2[h2].value()));
  return a2;
}
var Sn = z3;
var En = class _En extends gs {
  constructor(t3) {
    return void 0 === t3 || jt(t3, "vd") ? (super({ vd: t3?.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = new mi(0, 0), void (this.m_weights = [1, 0, 1])) : (t3.fromPoint && t3.weight ? t3 = { fromPoint: t3.fromPoint, controlPoint1: t3.controlPoint1, toPoint: t3.toPoint, weight0: 1, weight1: t3.weight, weight2: 1 } : t3.points && t3.weight ? t3 = { fromPoint: t3.points[0], controlPoint1: t3.points[1], toPoint: t3.points[2], weight0: 1, weight1: t3.weight, weight2: 1 } : t3.points && t3.weights && (t3 = { fromPoint: t3.points[0], controlPoint1: t3.points[1], toPoint: t3.points[2], weight0: t3.weights[0], weight1: t3.weights[1], weight2: t3.weights[2] }), t3.fromPoint && t3.weight0 ? (super({ start: t3.fromPoint, end: t3.toPoint }), (t3.weight0 <= 0 || t3.weight1 < 0 || t3.weight2 <= 0) && P("weights"), this.m_cp = t3.controlPoint1.clone(), void (this.m_weights = [t3.weight0, t3.weight1, t3.weight2])) : t3.copy ? (super(t3), this.m_cp = t3.copy.m_cp.clone(), void (this.m_weights = t3.copy.m_weights.slice())) : t3.move ? (super(t3), this.m_cp = t3.move.m_cp.clone(), void (this.m_weights = t3.move.m_weights.slice())) : void z("unexpected constructor param"));
  }
  getBoundary() {
    return Ks(this);
  }
  assignMove(t3) {
    return this;
  }
  assignCopy(t3) {
    return t3.copyTo(this), this;
  }
  construct(t3, e5, s4, n6) {
    this.dropAllAttributes(), this.setCpsAndWeights(t3, e5, s4, 1, n6, 1), la(this);
  }
  constructWeights(t3, e5, s4, n6, i2, r) {
    this.dropAllAttributes(), this.setCpsAndWeights(t3, e5, s4, n6, i2, r), la(this);
  }
  constructArray(t3, e5) {
    this.construct(t3[0], t3[1], t3[2], e5);
  }
  constructArrayWeights(t3, e5) {
    this.dropAllAttributes(), this.setCpsAndWeightsArray(t3, e5), la(this);
  }
  convertToStandardForm() {
  }
  getStandardFormWeight() {
    return this.m_weights[1] / Math.sqrt(this.m_weights[0] * this.m_weights[2]);
  }
  getGeometryType() {
    return a.enumRationalBezier2;
  }
  queryEnvelope(t3) {
    if (t3 instanceof n4) {
      if (t3.setCoords(this.getStartXY()), t3.mergeNe(this.getEndXY()), t3.contains(this.m_cp)) return;
      const e5 = Va(this);
      if (null !== e5) {
        const s4 = new mi();
        for (const n6 of e5.specialPoints) this.queryCoord2D(n6, s4), t3.mergeNe(s4);
      } else {
        const e6 = [], s4 = Ot(mi, 3);
        this.queryControlPoints(s4), da(s4, this.m_weights, e6);
        const n6 = new mi();
        for (const i2 of e6) this.queryCoord2D(i2, n6), t3.mergeNe(n6);
      }
    }
  }
  applyTransformation(t3) {
    if (t3 instanceof x3) {
      const e5 = Ot(mi, 3);
      return this.queryControlPoints(e5), t3.transformPoints2D(e5, 3, e5), this.setStartXY(e5[0]), this.m_cp.assign(e5[1]), this.setEndXY(e5[2]), void this.afterCompletedModification();
    }
  }
  createInstance() {
    return new _En({ vd: this.m_description });
  }
  calculateLength2D() {
    return _a(this, 1, false);
  }
  calculateLowerLength2D() {
    return mi.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return this.calculateUpperLength2D_();
  }
  calculateUpperLength2D_() {
    if (this.m_weights[1] > 0) {
      return mi.distance(this.getStartXY(), this.m_cp) + mi.distance(this.getEndXY(), this.m_cp);
    }
    return mi.distance(this.getStartXY(), this.getEndXY());
  }
  queryCoord2D(t3, e5) {
    return this.queryCoord2DExtension(t3, e5, true);
  }
  queryCoord2DE(t3, e5) {
    lh(this, t3, e5);
  }
  queryCoord2DExtension(t3, e5, s4) {
    if (s4) {
      if (t3 < 0) {
        return void _s2(new pm({ start: this.getStartXY(), end: this.getStartXY().add(this.getTangent(0).getUnitVector()) }), t3, e5);
      }
      if (t3 > 1) {
        return void _s2(new pm({ start: this.getEndXY(), end: this.getEndXY().add(this.getTangent(1).getUnitVector()) }), t3 - 1, e5);
      }
    }
    const n6 = Ot(mi, 3);
    this.queryControlPoints(n6), _h(n6, this.m_weights, t3, e5);
  }
  getCoordX(t3) {
    const e5 = new mi();
    return this.queryCoord2DExtension(t3, e5, true), e5.x;
  }
  getCoordY(t3) {
    const e5 = new mi();
    return this.queryCoord2DExtension(t3, e5, true), e5.y;
  }
  cut(t3, e5, s4) {
    const n6 = new fm();
    return this.queryCut(t3, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t3, e5, s4, n6) {
    const i2 = s4.createQuadraticRationalBezier();
    if (this.cutBezierIgnoreAttributes(t3, e5, i2), n6) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e6 = 1; e6 < r; e6++) {
        const s5 = this.m_description.getSemantics(e6), n7 = Sn.getComponentCount(s5);
        for (let e7 = 0; e7 < n7; e7++) {
          const n8 = this.getAttributeAsDbl(t3, s5, e7);
          i2.setStartAttribute(s5, e7, n8);
        }
      }
      for (let t4 = 1; t4 < r; t4++) {
        const s5 = this.m_description.getSemantics(t4), n7 = Sn.getComponentCount(s5);
        for (let t5 = 0; t5 < n7; t5++) {
          const n8 = this.getAttributeAsDbl(e5, s5, t5);
          i2.setEndAttribute(s5, t5, n8);
        }
      }
    }
  }
  queryDerivative(t3, e5) {
    Ea(this, t3, e5);
  }
  cutBezierIgnoreAttributes(t3, s4, n6) {
    (t3 < 0 || s4 > 1 || t3 > s4) && P("Quadratic_rational_bezier.cut_bezier_ignore_attributes");
    const i2 = Ot(mi, 3);
    this.queryControlPoints(i2);
    const r = [0, 0, 0];
    Qa(i2, this.m_weights, t3, s4, i2, r), n6.setControlPointsAndWeights(i2, r);
  }
  splitBezierIgnoreAttributes(t3, e5, s4) {
  }
  getAttributeAsDbl(t3, e5, s4) {
    if (0 === e5) return 0 === s4 ? this.getCoordX(t3) : this.getCoordY(t3);
    const n6 = this.calculateLength2D(), i2 = n6 > 0 ? this.tToLength(t3) / n6 : 0, r = Sn.getInterpolation(e5), o = this.getStartAttributeAsDbl(e5, s4), a2 = this.getEndAttributeAsDbl(e5, s4);
    return It(r, o, a2, i2, Sn.getDefaultValue(e5));
  }
  getClosestCoordinate(t3, e5) {
    return Ra(this, t3, x2.unit(), e5, -1);
  }
  getClosestCoordinateOnInterval(t3, e5, s4 = -1) {
    return Ra(this, t3, e5, false, s4);
  }
  getYMonotonicParts(t3, e5) {
    return this.getMonotonicParts(t3, e5);
  }
  getMonotonicParts(t3, n6) {
    t3.length < 2 && P("");
    const i2 = ga(this);
    let r = 0;
    if (2 === i2.specialPointsCount()) return 0;
    n2(t3.length >= i2.specialPointsCount() - 1);
    for (let e5 = 1, s4 = i2.specialPointsCount(); e5 < s4; ++e5) this.queryCut(i2.specialPoints[e5 - 1], i2.specialPoints[e5], t3[r], n6), r++;
    for (let e5 = 0; e5 < r; ++e5) {
      Za(t3[e5].get());
    }
    return r;
  }
  intersectionWithAxis2D(t3, e5, s4, n6) {
    s4 && (s4.length = 9), n6 && (n6.length = 9);
    const i2 = new Array(3), r = Ot(p2, 2), o = new x2(0, 1);
    let a2 = 0;
    const h2 = Ot(mi, 3);
    if (this.queryControlPoints(h2), t3) {
      if (i2[0] = new p2(h2[0].y).sub(e5).mul(this.m_weights[0]), i2[1] = new p2(h2[1].y).sub(e5).mul(this.m_weights[1]), i2[2] = i2[0].subE(i2[1].mul(2)).addE(new p2(h2[2].y).sub(e5).mul(this.m_weights[2])), i2[1] = i2[1].subE(i2[0]).mulThisByPower2(2), a2 = gn(i2[2], i2[1], i2[0], o, false, r), s4) for (let u = 0; u < a2; u++) s4[u] = this.getCoordX(r[u].value());
    } else if (i2[0] = new p2(h2[0].x).sub(e5).mul(this.m_weights[0]), i2[1] = new p2(h2[1].x).sub(e5).mul(this.m_weights[1]), i2[2] = i2[0].subE(i2[1].mul(2)).addE(new p2(h2[2].x).sub(e5).mul(this.m_weights[2])), i2[1] = i2[1].subE(i2[0]).mulThisByPower2(2), a2 = gn(i2[2], i2[1], i2[0], o, false, r), s4) for (let u = 0; u < a2; u++) s4[u] = this.getCoordY(r[u].value());
    if (n6) for (let u = 0; u < a2; u++) n6[u] = r[u].value();
    else s4 && Zt(s4, 0, a2, Ct);
    return a2;
  }
  intersectionOfYMonotonicWithAxisX(t3, e5) {
    if (this.m_YStart === this.m_YEnd) return t3 === this.m_YStart ? e5 : Number.NaN;
    if (t3 === this.m_YStart) return this.m_XStart;
    if (t3 === this.m_YEnd) return this.m_XEnd;
    const n6 = [Number.NaN, Number.NaN], i2 = this.intersectionWithAxis2D(true, t3, n6, null);
    return n2(2 !== i2), -1 === i2 ? e5 : n6[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t3) {
    return Re(this, t3);
  }
  isDegenerate3D(t3, e5) {
    return false;
  }
  queryLooseEnvelope(t3) {
    if (t3 instanceof n4) return t3.setCoords({ pt: this.getStartXY() }), t3.mergeNe(this.m_cp), void t3.mergeNe(this.getEndXY());
  }
  clone(t3) {
    const e5 = this.createInstance();
    return this.copyTo(e5), e5;
  }
  queryInterval(t3, e5) {
    if (0 === t3) {
      const t4 = n4.constructEmpty();
      this.queryEnvelope(t4);
      const s4 = x2.constructEmpty();
      return 0 === e5 ? t4.queryIntervalX(s4) : t4.queryIntervalY(s4), s4;
    }
    return super.queryInterval(t3, e5);
  }
  queryLooseEnvelopeOnInterval(t3, e5) {
    const s4 = Ot(mi, 3);
    this.queryControlPoints(s4);
    const n6 = [0, 0, 0];
    Qa(s4, this.m_weights, t3.vmin, t3.vmax, s4, n6), e5.setFromPoints(s4, 3);
  }
  changeEndPoints2D(t3, e5) {
    if (t3.isEqual(this.m_XStart, this.m_YStart) && e5.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s4 = this.m_cp.isEqual(this.m_XStart, this.m_YStart), n6 = this.m_cp.isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t3), this.setEndXY(e5), s4 ? this.m_cp.setCoordsPoint2D(t3) : n6 && this.m_cp.setCoordsPoint2D(e5), this.normalizeAfterEndpointChange();
  }
  tToLength(t3) {
    return _a(this, t3, true);
  }
  lengthToT(t3) {
    return Ta(this, t3);
  }
  calculateWeightedAreaCentroid2D(t3) {
    const e5 = Na(this), s4 = Ia(this);
    return e5.x += (this.getStartX() - t3.x) * s4, e5.y += (this.getStartY() - t3.y) * s4, e5;
  }
  calculateWeightedCentroid2D() {
    const t3 = new mi();
    return this.isDegenerate(0) ? (t3.setCoords(0, 0), t3) : Fa(this) ? (t3.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t3) : (t3.assign(Ua(this, 1)), t3);
  }
  getControlPoint1() {
    return this.m_cp.clone();
  }
  setControlPoint1(t3) {
    this.m_cp.setCoordsPoint2D(t3), this.afterCompletedModification();
  }
  queryWeights(t3) {
    for (let e5 = 0; e5 < 3; ++e5) t3[e5] = this.m_weights[e5];
  }
  queryCoord2DMP(t3, e5) {
    const s4 = Ot(mi, 3);
    return this.queryControlPoints(s4), gh(s4.map((t4) => Xe.constructPoint2D(t4)), this.m_weights.map((t4) => si.constructDouble(t4)), si.constructDouble(t3), e5);
  }
  setWeights(t3) {
  }
  queryControlPoints(t3) {
    t3[0].assign(this.getStartXY()), t3[1].assign(this.m_cp), t3[2].assign(this.getEndXY());
  }
  queryControlPointsHelper(t3) {
    return this.queryControlPoints(t3), 3;
  }
  setControlPointsAndWeights(t3, e5) {
    this.setCpsAndWeightsArray(t3, e5), this.afterCompletedModification();
  }
  getTangent(t3) {
    const e5 = Ot(mi, 3);
    return this.queryControlPoints(e5), wa(e5, this.m_weights, t3);
  }
  getDerivative(t3) {
    const e5 = Us(t3, 0, 1), s4 = Ot(mi, 4);
    return pa(this, 1, e5, s4), s4[1];
  }
  getCurvature(t3) {
    const e5 = Ot(mi, 4);
    pa(this, 2, t3, e5);
    const s4 = e5[1].sqrLength();
    if (0 === s4) return Number.NaN;
    e5[1].divThis(Math.sqrt(s4));
    return e5[1].crossProduct(e5[2]) / s4;
  }
  isIntersecting(t3, e5, s4) {
    return false;
  }
  isIntersectingPoint(t3, e5, s4) {
    return false;
  }
  isIntersectingPoint3D(t3, e5, s4, n6, i2 = 1) {
    return false;
  }
  isMonotoneQuickAndDirty() {
    const t3 = Ot(mi, 3);
    return this.queryControlPoints(t3), ja(t3);
  }
  getMonotonicPartParams(t3, s4) {
    const n6 = ga(this), i2 = n6.specialPointsCount();
    if (!s4) return n6.specialPointsCount();
    t3 < i2 && P("");
    for (let e5 = 0; e5 < i2; e5++) s4[e5] = n6.specialPoints[e5];
    return i2;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Pt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Pt(this.m_YStart, this.m_YStart = this.m_YEnd), this.m_weights[2] = Pt(this.m_weights[0], this.m_weights[0] = this.m_weights[2]);
      for (let t3 = 0, e5 = this.m_description.getTotalComponentCount() - 2; t3 < e5; t3++) this.m_attributes[t3 + e5] = Pt(this.m_attributes[t3], this.m_attributes[t3] = this.m_attributes[t3 + e5]);
      this.m_cachedValues = null;
    }
  }
  isLine() {
    return false;
  }
  isDegenerateToLineHelper(t3) {
    const e5 = Ot(mi, 3);
    this.queryControlPoints(e5);
    const s4 = e5[2].sub(e5[0]), n6 = s4.length();
    if (mi.distance(e5[0], e5[1]) + mi.distance(e5[2], e5[1]) - n6 > t3) return false;
    const i2 = t3, r = e5[1].clone();
    r.subThis(e5[0]);
    return !(Math.abs(r.crossProduct(s4)) / n6 > i2);
  }
  copyIgnoreAttributes(t3) {
    const e5 = Ot(mi, 3);
    this.queryControlPoints(e5);
    const s4 = [0, 0, 0];
    this.queryWeights(s4), t3.setControlPointsAndWeights(e5, s4);
  }
  calculateArea2DHelper() {
    return Ia(this);
  }
  absNorm() {
    return this.getStartXY().norm(1) + this.getEndXY().norm(1) + this.m_cp.norm(1);
  }
  absNormXYZ(t3) {
    return n2(0), 0;
  }
  queryEnvelopeW(t3, e5) {
    Ga(this, t3, e5);
  }
  setSegmentFromCoordsForStitcher(t3, e5) {
    const s4 = [0, 0, 0];
    this.queryWeights(s4), this.constructWeights(t3[0], this.getControlPoint1(), t3[e5 - 1], s4[0], s4[1], s4[2]);
  }
  writeInBufferStream(t3, e5) {
    const s4 = new Float64Array(5);
    return s4[0] = this.m_cp.x, s4[1] = this.m_cp.y, s4[2] = this.m_weights[0], s4[3] = this.m_weights[1], s4[4] = this.m_weights[2], t3.writeRangeFromArray(e5, s4.length, s4, true, 1), e5 + s4.length;
  }
  readFromBufferStream(t3, e5) {
    const s4 = new Float64Array(5);
    t3.queryRange(e5, s4.length, s4, true, 1), this.m_cp.x = s4[0], this.m_cp.y = s4[1], this.m_weights[0] = s4[2], this.m_weights[1] = s4[3], this.m_weights[2] = s4[4], this.m_cachedValues = null;
  }
  snapControlPoints(t3) {
    const e5 = Ot(mi, 3);
    this.queryControlPoints(e5);
    const s4 = mi.sqrDistance(e5[1], e5[0]), n6 = mi.sqrDistance(e5[1], e5[2]);
    let i2 = e5[0].clone(), r = s4;
    s4 > n6 && (i2 = e5[2].clone(), r = n6);
    let o = false;
    return r <= t3 && 0 !== r && (o = true, this.setControlPoint1(i2)), o;
  }
  needsSnapControlPoints(t3) {
    if (!t3) return false;
    const e5 = Ot(mi, 3);
    this.queryControlPoints(e5);
    const s4 = mi.sqrDistance(e5[1], e5[0]), n6 = mi.sqrDistance(e5[1], e5[2]);
    e5[0].clone();
    let i2 = s4;
    return s4 > n6 && (e5[2].clone(), i2 = n6), i2 <= t3 && 0 !== i2;
  }
  calculateSpecialPointsForCracking(t3, e5) {
    return 0;
  }
  ensureXYMonotone() {
    return Za(this);
  }
  setCoordsForIntersector(t3, e5, s4) {
    Ka(this, t3, e5, s4);
  }
  copyToImpl(t3) {
    const e5 = t3;
    e5.m_cp.setCoordsPoint2D(this.m_cp), e5.m_weights[0] = this.m_weights[0], e5.m_weights[1] = this.m_weights[1], e5.m_weights[2] = this.m_weights[2], La(e5, Va(this));
  }
  reverseImpl() {
    this.m_weights[2] = Pt(this.m_weights[0], this.m_weights[0] = this.m_weights[2]);
  }
  equalsImpl(t3) {
    const e5 = t3;
    if (!this.m_cp.equals(e5.m_cp)) return false;
    for (let s4 = 0; s4 < 3; s4++) if (this.m_weights[s4] !== e5.m_weights[s4]) return false;
    return true;
  }
  equalsImplTol(t3, e5) {
    const s4 = t3;
    if (!this.m_cp.isEqualPoint2D(s4.m_cp, e5)) return false;
    const n6 = Ot(mi, 3);
    this.queryControlPoints(n6);
    const i2 = Ot(mi, 3);
    s4.queryControlPoints(i2);
    const r = [s4.m_weights[0], s4.m_weights[1], s4.m_weights[2]];
    for (let o = 0; o < 3; o++) {
      const t4 = new X();
      t4.setCoordsPoint2DZ(n6[o].mul(this.m_weights[o]), this.m_weights[o]);
      const s5 = new X();
      if (s5.setCoordsPoint2DZ(i2[o].mul(r[o]), r[o]), !t4.isEqual(s5, e5)) return false;
    }
    return true;
  }
  swapImpl(t3) {
    const e5 = t3;
    e5.m_cp = Pt(this.m_cp, this.m_cp = e5.m_cp), e5.m_weights = Pt(this.m_weights, this.m_weights = e5.m_weights), ca(this, e5);
  }
  afterCompletedModification() {
    la(this);
  }
  intersect(t3, e5, s4, n6, i2) {
    return um(false, this, t3, e5, s4, n6, i2);
  }
  intersectPoint(t3, e5, s4) {
    return ka(this, t3, e5, s4);
  }
  endPointModified() {
    la(this);
  }
  clearEndPointModified() {
  }
  setCpsAndWeights(t3, s4, n6, i2, r, o) {
    (i2 <= 0 || o <= 0 || r < 0) && P("weights"), (t3.isNAN() || s4.isNAN() || n6.isNAN()) && P("NAN control points in bezier are not supported"), this.setStartXY(t3), this.m_cp.assign(s4), this.m_weights[0] = i2, this.m_weights[1] = r, this.m_weights[2] = o, this.setEndXY(n6);
  }
  setCpsAndWeightsArray(t3, e5) {
    this.setCpsAndWeights(t3[0], t3[1], t3[2], e5[0], e5[1], e5[2]);
  }
};
En.type = a.enumRationalBezier2;
var Dn = z3;
var wn = class _wn extends gs {
  constructor(t3) {
    void 0 === t3 || jt(t3, "vd") ? (super({ vd: t3?.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = new mi(0, 0)) : t3.from ? (super({ XStart: t3.from.x, YStart: t3.from.y, XEnd: t3.to.x, YEnd: t3.to.y, ...t3.vd }), this.m_cp = t3.cp.clone()) : t3.points ? (super({ XStart: t3.points[0].x, YStart: t3.points[0].y, XEnd: t3.points[2].x, YEnd: t3.points[2].y, ...t3.vd }), this.m_cp = t3.points[1].clone()) : t3.copy ? (super(t3), this.m_cp = t3.copy.m_cp.clone()) : b("unexpected constructor args");
  }
  getBoundary() {
    return Ks(this);
  }
  assignCopy(t3) {
    return this !== t3 && t3.copyTo(this), this;
  }
  construct(t3, e5, s4) {
    this.setStartXY(t3), this.m_cp.assign(e5), this.setEndXY(s4), ii2(this);
  }
  constructPoints(t3) {
    this.setStartXY(t3[0]), this.m_cp.assign(t3[1]), this.setEndXY(t3[2]), ii2(this);
  }
  getGeometryType() {
    return a.enumBezier2;
  }
  queryEnvelope(t3) {
    if (2 !== t3.m_EnvelopeType) z("env type not impl");
    else {
      if (t3.setCoords(this.getStartXY()), t3.mergeNe(this.getEndXY()), t3.contains(this.m_cp)) return;
      const e5 = yi(this);
      if (null !== e5) {
        const s4 = new mi();
        for (const n6 of e5.specialPoints) this.queryCoord2D(n6, s4), t3.mergeNe(s4);
      } else {
        const e6 = [];
        ai2(this, e6);
        const s4 = new mi();
        for (const n6 of e6) this.queryCoord2D(n6, s4), t3.mergeNe(s4);
      }
    }
  }
  applyTransformation(t3) {
    if (1 === t3.m_TransformationType) {
      const e5 = Ot(mi, 3);
      return this.queryControlPoints(e5), t3.transformPoints2D(e5, 3, e5), this.setStartXY(e5[0]), this.m_cp.assign(e5[1]), this.setEndXY(e5[2]), void this.afterCompletedModification();
    }
    n2(0);
  }
  createInstance() {
    return new _wn({ vd: this.m_description });
  }
  calculateLength2D() {
    return hi2(this, 1, false);
  }
  calculateLowerLength2D() {
    return mi.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return this.calculateUpperLength2D_();
  }
  calculateUpperLength2D_() {
    return mi.distance(this.getStartXY(), this.m_cp) + mi.distance(this.getEndXY(), this.m_cp);
  }
  queryCoord2D(t3, e5) {
    this.queryCoord2DExtended(t3, e5, false);
  }
  queryCoord2DExtended(t3, e5, s4) {
    const n6 = Ot(mi, 3);
    this.queryControlPoints(n6), ji(n6, t3, e5, s4);
  }
  queryCoord2DE(t3, e5) {
    Zi(this, t3, e5);
  }
  queryCoord2DMP(t3, e5) {
    n2(false, "bernstein polynomials not ported");
  }
  getCoordX(t3) {
    if (t3 < 0 || t3 > 1) {
      const e5 = new mi();
      return this.queryCoord2DExtended(t3, e5, true), e5.x;
    }
    if (t3 <= 0.5) {
      const e5 = V(this.getStartX(), this.m_cp.x, t3), s4 = V(this.m_cp.x, this.getEndX(), t3);
      return V(e5, s4, t3);
    }
    {
      const e5 = U2(this.getStartX(), this.m_cp.x, t3), s4 = U2(this.m_cp.x, this.getEndX(), t3);
      return U2(e5, s4, t3);
    }
  }
  getCoordY(t3) {
    if (t3 < 0 || t3 > 1) {
      const e5 = new mi();
      return this.queryCoord2DExtended(t3, e5, true), e5.y;
    }
    if (t3 <= 0.5) {
      const e5 = V(this.getStartX(), this.m_cp.x, t3), s4 = V(this.m_cp.x, this.getEndX(), t3);
      return V(e5, s4, t3);
    }
    {
      const e5 = U2(this.getStartY(), this.m_cp.y, t3), s4 = U2(this.m_cp.y, this.getEndY(), t3);
      return U2(e5, s4, t3);
    }
  }
  cut(t3, e5, s4) {
    const n6 = new fm();
    return this.queryCut(t3, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t3, e5, s4, n6) {
    const i2 = s4.createQuadraticBezier();
    if (this.cutBezierIgnoreAttributes(t3, e5, i2), n6) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e6 = 1; e6 < r; e6++) {
        const s5 = this.m_description.getSemantics(e6), n7 = Dn.getComponentCount(s5);
        for (let e7 = 0; e7 < n7; e7++) {
          const n8 = this.getAttributeAsDbl(t3, s5, e7);
          i2.setStartAttribute(s5, e7, n8);
        }
      }
      for (let t4 = 1; t4 < r; t4++) {
        const s5 = this.m_description.getSemantics(t4), n7 = Dn.getComponentCount(s5);
        for (let t5 = 0; t5 < n7; t5++) {
          const n8 = this.getAttributeAsDbl(e5, s5, t5);
          i2.setEndAttribute(s5, t5, n8);
        }
      }
    }
  }
  queryDerivative(t3, e5) {
    Ui(this, t3, e5);
  }
  cutBezierIgnoreAttributes(t3, s4, n6) {
    if ((t3 < 0 || s4 > 1 || t3 > s4) && P("Quadratic_bezier.cut_bezier_ignore_attributes"), 0 === t3 && 1 === s4) return n6.setStartXY(this.getStartXY()), n6.m_cp.assign(this.m_cp), void n6.setEndXY(this.getEndXY());
    const i2 = Ot(mi, 3);
    this.queryControlPoints(i2), Mi(i2, t3, s4, i2), n6.constructPoints(i2);
  }
  splitBezierIgnoreAttributes(t3, e5, n6) {
    n2(0);
  }
  getAttributeAsDbl(t3, e5, s4) {
    if (0 === e5) return 0 === s4 ? this.getCoordX(t3) : this.getCoordY(t3);
    const n6 = this.calculateLength2D(), i2 = n6 > 0 ? this.tToLength(t3) / n6 : 0, r = Dn.getInterpolation(e5), o = this.getStartAttributeAsDbl(e5, s4), a2 = this.getEndAttributeAsDbl(e5, s4);
    return It(r, o, a2, i2, Dn.getDefaultValue(e5));
  }
  getClosestCoordinate(t3, e5) {
    return Ci(this, t3, x2.unit(), e5);
  }
  getClosestCoordinateOnInterval(t3, e5, s4 = -1) {
    return Ci(this, t3, e5, false);
  }
  getYMonotonicParts(t3, e5) {
    return this.getMonotonicParts(t3, e5);
  }
  getMonotonicParts(t3, n6) {
    t3.length < 2 && P("");
    const i2 = oi2(this);
    let r = 0;
    if (2 === i2.specialPointsCount()) return 0;
    n2(t3.length >= i2.specialPointsCount() - 1);
    for (let e5 = 1, s4 = i2.specialPointsCount(); e5 < s4; ++e5) this.queryCut(i2.specialPoints[e5 - 1], i2.specialPoints[e5], t3[r], n6), r++;
    for (let e5 = 0; e5 < r; ++e5) {
      wi(t3[e5].get());
    }
    return r;
  }
  intersectionWithAxis2D(t3, e5, s4, n6) {
    const i2 = Ot(p2, 3), r = Ot(p2, 2), o = new x2(0, 1);
    let a2 = 0;
    if (t3) {
      if (i2[0] = new p2(this.getStartY()).sub(e5), i2[1] = new p2(this.m_cp.y).subE(new p2(this.getStartY())).mulThisByPower2(2), i2[2] = new p2(this.getStartY()).add(this.getEndY()).subE(new p2(this.m_cp.y).mulThisByPower2(2)), a2 = gn(i2[2], i2[1], i2[0], o, false, r), s4) for (let h2 = 0; h2 < a2; h2++) s4[h2] = this.getCoordX(r[h2].value());
    } else if (i2[0] = new p2(this.getStartX()).sub(e5), i2[1] = new p2(this.m_cp.x).subE(new p2(this.getStartX())).mulThisByPower2(2), i2[2] = new p2(this.getStartX()).add(this.getEndX()).subE(new p2(this.m_cp.x).mulThisByPower2(2)), a2 = gn(i2[2], i2[1], i2[0], o, false, r), s4) for (let h2 = 0; h2 < a2; h2++) s4[h2] = this.getCoordY(r[h2].value());
    if (n6) for (let h2 = 0; h2 < a2; h2++) n6[h2] = r[h2].value();
    else s4 && zt(s4, a2);
    return a2;
  }
  intersectionOfYMonotonicWithAxisX(t3, e5) {
    if (this.m_YStart === this.m_YEnd) return t3 === this.m_YStart ? e5 : Number.NaN;
    if (t3 === this.m_YStart) return this.m_XStart;
    if (t3 === this.m_YEnd) return this.m_XEnd;
    const n6 = [0, 0], i2 = this.intersectionWithAxis2D(true, t3, n6, null);
    return n2(2 !== i2), -1 === i2 ? e5 : n6[0];
  }
  isCurve() {
    return true;
  }
  isLine() {
    return false;
  }
  isDegenerate(t3) {
    return Re(this, t3);
  }
  isDegenerate3D(t3, e5) {
    return n2(0), false;
  }
  queryLooseEnvelope(t3) {
    if (2 === t3.m_EnvelopeType) return t3.setCoords(this.getStartXY()), t3.mergeNe(this.m_cp), void t3.mergeNe(this.getEndXY());
    n2(0);
  }
  clone(t3) {
    const e5 = this.createInstance();
    return this.copyTo(e5), e5;
  }
  queryInterval(t3, e5) {
    if (0 === t3) {
      const t4 = new n4();
      this.queryEnvelope(t4);
      const s4 = new x2();
      return 0 === e5 ? t4.queryIntervalX(s4) : t4.queryIntervalY(s4), s4;
    }
    return super.queryInterval(t3, e5);
  }
  queryLooseEnvelopeOnInterval(t3, e5) {
    const s4 = Ot(mi, 4);
    this.queryControlPoints(s4), Mi(s4, t3.vmin, t3.vmax, s4), e5.setFromPoints(s4, 4);
  }
  changeEndPoints2D(t3, e5) {
    if (t3.isEqual(this.m_XStart, this.m_YStart) && e5.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s4 = this.m_cp.isEqual(this.m_XStart, this.m_YStart), n6 = this.m_cp.isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t3), this.setEndXY(e5), s4 ? this.m_cp.setCoordsPoint2D(t3) : n6 && this.m_cp.setCoordsPoint2D(e5), this.normalizeAfterEndpointChange();
  }
  tToLength(t3) {
    return hi2(this, t3, true);
  }
  lengthToT(t3) {
    return _i(this, t3);
  }
  calculateWeightedAreaCentroid2D(t3) {
    const e5 = Ot(mi, 3);
    Bi(this, e5);
    const s4 = e5[2], n6 = e5[1], i2 = new mi(), r = s4.y * n6.x - s4.x * n6.y;
    i2.x = -(4 * s4.x + 5 * n6.x) * r / 60, i2.y = -(4 * s4.y + 5 * n6.y) * r / 60;
    const o = pi(this);
    return i2.x += (e5[0].x - t3.x) * o, i2.y += (e5[0].y - t3.y) * o, i2;
  }
  calculateWeightedCentroid2D() {
    const t3 = new mi();
    return this.isDegenerate(0) ? (t3.setCoords(0, 0), t3) : Pi(this) ? (t3.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t3) : (t3.assign(Ti(this, 1)), t3);
  }
  getControlPoint1() {
    return this.m_cp.clone();
  }
  setControlPoint1(t3) {
    this.m_cp.setCoordsPoint2D(t3), this.afterCompletedModification();
  }
  queryControlPoints(t3) {
    t3[0].assign(this.getStartXY()), t3[1].assign(this.m_cp), t3[2].assign(this.getEndXY());
  }
  queryControlPointsHelper(t3) {
    return this.queryControlPoints(t3), 3;
  }
  setControlPoints(t3) {
    for (let s4 = 0; s4 < 3; s4++) t3[s4].isNAN() && P("NaN control points in bezier are not supported");
    this.m_XStart = t3[0].x, this.m_YStart = t3[0].y, this.m_cp.setCoordsPoint2D(t3[1]), this.m_XEnd = t3[2].x, this.m_YEnd = t3[2].y, this.afterCompletedModification();
  }
  getTangent(t3) {
    const e5 = Us(t3, 0, 1);
    let s4 = ci(this, 1, e5);
    return s4.isZero() && (s4 = ci(this, 2, e5), 1 === e5 && s4.negateThis()), s4;
  }
  getDerivative(t3) {
    return ci(this, 1, Us(t3, 0, 1));
  }
  getCurvature(t3) {
    const e5 = ci(this, 1, t3), s4 = ci(this, 2, t3), n6 = e5.sqrLength();
    if (0 === n6) return Number.NaN;
    e5.divThis(Math.sqrt(n6));
    return e5.crossProduct(s4) / n6;
  }
  isIntersecting(t3, e5, s4) {
    return 0 !== rm(false, this, t3, e5, s4);
  }
  isIntersectingPoint(t3, e5, s4) {
    if (s4 && (t3.isEqualPoint2D(this.getStartXY()) || t3.isEqualPoint2D(this.getEndXY()))) return false;
    const n6 = new n4();
    if (this.queryLooseEnvelope(n6), n6.inflateCoords(e5, e5), !n6.contains(t3)) return false;
    const i2 = this.getClosestCoordinate(t3, false), r = new mi();
    this.queryCoord2D(i2, r);
    return mi.distance(r, t3) <= e5;
  }
  isIntersectingPoint3D(t3, e5, n6, i2, r = 1) {
    return n2(0), false;
  }
  isMonotoneQuickAndDirty() {
    return false;
  }
  getMonotonicPartParams(t3, s4) {
    const n6 = oi2(this), i2 = n6.specialPointsCount();
    if (!s4) return n6.specialPointsCount();
    t3 < i2 && P("");
    for (let e5 = 0; e5 < i2; e5++) s4[e5] = n6.specialPoints[e5];
    return i2;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      Pt(this.m_XStart, this.m_XStart = this.m_XEnd), Pt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t3 = 0, e5 = this.m_description.getTotalComponentCount() - 2; t3 < e5; t3++) this.m_attributes[t3 + e5] = Pt(this.m_attributes[t3], this.m_attributes[t3] = this.m_attributes[t3 + e5]);
      this.m_cachedValues = null;
    }
  }
  isDegenerateToLineHelper(t3) {
    const e5 = Ot(mi, 3);
    this.queryControlPoints(e5);
    const s4 = e5[2].sub(e5[0]), n6 = s4.length();
    if (mi.distance(e5[0], e5[1]) + mi.distance(e5[2], e5[1]) - n6 > t3) return false;
    const i2 = t3, r = e5[1].clone();
    r.subThis(e5[0]);
    return !(Math.abs(r.crossProduct(s4)) / n6 > i2);
  }
  copyIgnoreAttributes(t3) {
    const e5 = Ot(mi, 3);
    this.queryControlPoints(e5), t3.setControlPoints(e5);
  }
  calculateArea2DHelper() {
    return pi(this);
  }
  absNorm() {
    return Ni(this);
  }
  queryEnvelopeW(t3, e5) {
    const s4 = Ot(mi, 3);
    this.queryControlPoints(s4), Ei(s4, t3, e5);
  }
  setSegmentFromCoordsForStitcher(t3, e5) {
    this.construct(t3[0], this.getControlPoint1(), t3[e5 - 1]);
  }
  snapControlPoints(t3) {
    return $i(this, t3);
  }
  writeInBufferStream(t3, e5) {
    const s4 = new Float64Array(2);
    return s4[0] = this.m_cp.x, s4[1] = this.m_cp.y, t3.writeRangeFromArray(e5, s4.length, s4, true, 1), e5 + s4.length;
  }
  readFromBufferStream(t3, e5) {
    const s4 = new Float64Array(2);
    t3.queryRange(e5, s4.length, s4, true, 1), this.m_cp.x = s4[0], this.m_cp.y = s4[1], this.m_cachedValues = null;
  }
  needsSnapControlPoints(t3) {
    return tr(this, t3);
  }
  calculateSpecialPointsForCracking(t3, e5) {
    return 0;
  }
  ensureXYMonotone() {
    return wi(this);
  }
  setCoordsForIntersector(t3, e5, s4) {
    Yi(this, t3, e5, s4);
  }
  copyToImpl(t3) {
    const e5 = t3;
    e5.m_cp.setCoordsPoint2D(this.m_cp), xi(e5, yi(this));
  }
  reverseImpl() {
  }
  equalsImplTol(t3, e5) {
    const s4 = t3;
    return !!this.m_cp.isEqualPoint2D(s4.m_cp, e5);
  }
  equalsImpl(t3) {
    const e5 = t3;
    return !!this.m_cp.equals(e5.m_cp);
  }
  swapImpl(t3) {
    const e5 = t3;
    e5.m_cp = Pt(this.m_cp, this.m_cp = e5.m_cp), ri(this, e5);
  }
  afterCompletedModification() {
    ii2(this);
  }
  intersect(t3, e5, s4, n6, i2) {
    return um(false, this, t3, e5, s4, n6, i2);
  }
  intersectPoint(t3, e5, s4) {
    return bi(this, t3, e5.length, e5, s4);
  }
  endPointModified() {
    ii2(this);
  }
  clearEndPointModified() {
  }
};
wn.type = a.enumBezier2;
var An = class {
  constructor(t3) {
    return t3.coefsT ? (this.m_zeroCtor = t3.zeroCtor, this.m_elements = t3.coefsT.map((t4) => t4.clone()), n2(this.m_elements.length === t3.power + 1), void this.updatePower()) : t3.coef0 ? (this.m_zeroCtor = t3.zeroCtor, void (this.m_elements = [t3.coef0.clone()])) : t3.copy ? (this.m_zeroCtor = t3.copy.m_zeroCtor, void (this.m_elements = t3.copy.m_elements.map((t4) => t4.clone()))) : (this.m_zeroCtor = t3.zeroCtor, void (this.m_elements = [new this.m_zeroCtor()]));
  }
  construct(t3, e5) {
    return this.m_elements = t3.map((t4) => t4.clone()), this.updatePower(), this;
  }
  construct0(t3) {
    return this.m_elements.length = 0, this.m_elements.push(t3.clone()), this.updatePower(), this;
  }
  assignCopy(t3) {
    return this.m_elements = t3.m_elements.map((t4) => t4.clone()), this.updatePower(), this;
  }
  assignMove(t3) {
    return this.m_elements = t3.m_elements, t3.m_elements = [], this.updatePower(), this;
  }
  power() {
    return this.m_elements.length - 1;
  }
  addElement(t3) {
    this.m_elements.push(t3.clone());
  }
  scaleRangeToUnitInterval(t3, e5) {
    const s4 = e5;
    s4.subThis(t3);
    const n6 = this.power();
    for (let i2 = 0; i2 <= n6; i2++) {
      const e6 = new this.m_zeroCtor();
      for (let s5 = i2; s5 <= n6; s5++) {
        const n7 = this.m_elements[s5];
        n7.mulDoubleThis(gt(s5, i2));
        const r2 = t3.pow(s5 - i2);
        n7.mulThis(r2), e6.addThis(n7);
      }
      const r = s4.pow(i2);
      e6.mulThis(r), this.m_elements[i2] = e6;
    }
  }
  fmSubThis(t3, e5) {
    return n2(0), this;
  }
  addThis(t3) {
    const e5 = Math.min(this.power(), t3.power());
    for (let n6 = 0; n6 <= e5; ++n6) this.m_elements[n6].addThis(t3.m_elements[n6]);
    const s4 = t3.power();
    this.m_elements.length = Math.max(this.power(), t3.power()) + 1;
    for (let n6 = e5 + 1; n6 <= s4; ++n6) this.m_elements[n6] = t3.m_elements[n6];
    return this.updatePower(), this;
  }
  add0(t3) {
    return this.m_elements[0].addThis(t3), this.updatePower(), this;
  }
  addNumber0(t3) {
    return n2(0), this;
  }
  sub(t3) {
    const e5 = Math.min(this.power(), t3.power());
    for (let n6 = 0; n6 <= e5; ++n6) this.m_elements[n6].subThis(t3.m_elements[n6]);
    const s4 = t3.power();
    this.m_elements.length = Math.max(this.power(), t3.power()) + 1;
    for (let n6 = e5 + 1; n6 <= s4; ++n6) this.m_elements[n6] = t3.m_elements[n6].clone(), this.m_elements[n6].negateThis();
    return this.updatePower(), this;
  }
  sub0(t3) {
    return n2(0), this;
  }
  subNumber0(t3) {
    return n2(0), this;
  }
  subShifted(t3, e5) {
    const s4 = this.power(), n6 = t3.power() + e5, i2 = Math.min(this.power(), n6);
    let r = 0;
    for (let o = e5; o <= i2; ++o) this.m_elements[o].subThis(t3.m_elements[r]), r++;
    if (n6 <= s4) return this.updatePower(), this;
    this.m_elements.length = n6 + 1;
    for (let o = s4 + 1; o < this.m_elements.length; ++o) this.m_elements[o] = new this.m_zeroCtor();
    for (let o = i2 + 1; o <= n6; ++o) this.m_elements[o].subThis(t3.m_elements[r++]);
    return this.updatePower(), this;
  }
  subShiftedWithCoef(t3, e5, s4) {
    const n6 = this.power(), i2 = t3.power() + s4, r = Math.min(this.power(), i2);
    let o = 0;
    for (let a2 = s4; a2 <= r; ++a2) this.m_elements[a2].fmSubThis(t3.m_elements[o], e5), o++;
    if (i2 <= n6) return this.updatePower(), this;
    this.m_elements.length = i2 + 1;
    for (let a2 = n6 + 1; a2 < this.m_elements.length; ++a2) this.m_elements[a2] = new this.m_zeroCtor();
    for (let a2 = r + 1; a2 <= i2; ++a2) this.m_elements[a2].fmSubThis(t3.m_elements[o++], e5);
    return this.updatePower(), this;
  }
  mulThis(t3) {
    if (this.constructor === t3.constructor) {
      const e5 = t3, s4 = [];
      for (let t4 = 0, n6 = this.power(); t4 <= n6; t4++) for (let i2 = 0, r = e5.power(); i2 <= r; i2++) {
        const n7 = this.m_elements[t4].clone();
        n7.mulThis(e5.m_elements[i2]), t4 + i2 < s4.length ? s4[t4 + i2].addThis(n7) : s4.push(n7);
      }
      this.m_elements = s4;
    } else for (let e5 = 0, s4 = this.power(); e5 <= s4; e5++) this.m_elements[e5].mulThis(t3);
    return this.updatePower(), this;
  }
  mulElementThis(t3) {
    for (let e5 = 0, s4 = this.power(); e5 <= s4; e5++) this.m_elements[e5].mulThis(t3);
    return this.updatePower(), this;
  }
  mulDoubleThis(t3) {
    for (let e5 = 0, s4 = this.power(); e5 <= s4; e5++) this.m_elements[e5].mulDoubleThis(t3);
    return this.updatePower(), this;
  }
  mulNumber0(t3) {
    return n2(0), this;
  }
  mulBigint0(t3) {
    return n2(0), this;
  }
  mulBigIntThis(t3) {
    return n2(0), this;
  }
  mulInt320(t3) {
    return n2(0), this;
  }
  div0(t3) {
    return n2(0), this;
  }
  absThis() {
    return n2(0), this;
  }
  div(t3, e5, s4) {
    if (this.power() < t3.power()) return s4.assignCopy(this), void e5.setZero();
    s4.setZero(), e5.setZero();
    const n6 = t3.getElement(t3.power()), i2 = this.clone();
    let r = i2.power();
    const o = i2.power() - t3.power();
    let a2 = o;
    for (e5.m_elements = Ot(e5.m_zeroCtor, o + 1); ; ) {
      if (r < t3.power()) {
        s4.assignMove(i2);
        break;
      }
      if (r === i2.power()) {
        const s5 = i2.getElement(i2.power());
        s5.divThis(n6), i2.subShiftedWithCoef(t3, s5, i2.power() - t3.power()), e5.m_elements[a2] = s5.clone();
      }
      a2--, r--;
    }
    s4.updatePower(), e5.updatePower();
  }
  divThis(t3) {
    return n2(0), this;
  }
  subThis(t3) {
    const e5 = Math.min(this.power(), t3.power());
    for (let n6 = 0; n6 <= e5; ++n6) this.m_elements[n6].subThis(t3.m_elements[n6]);
    const s4 = t3.power();
    this.m_elements.length = Math.max(this.power(), t3.power()) + 1;
    for (let n6 = e5 + 1; n6 <= s4; ++n6) this.m_elements[n6] = t3.m_elements[n6].clone(), this.m_elements[n6].negateThis();
    return this.updatePower(), this;
  }
  sub0This(t3) {
    return this.m_elements[0].subThis(t3), this.updatePower(), this;
  }
  subFrom(t3, e5) {
    n2(0);
  }
  isZero() {
    return 0 === this.power() && this.m_elements[0].isZero();
  }
  negateThis() {
    for (let t3 = this.m_elements.length - 1; t3 >= 0; t3--) this.m_elements[t3].negateThis();
    return this;
  }
  getElement(t3) {
    return this.m_elements[t3].clone();
  }
  setElement(t3, e5) {
    return this.m_elements[t3] = e5.clone(), this;
  }
  evaluate(t3) {
    const e5 = this.power(), s4 = this.m_elements[e5].clone();
    for (let n6 = e5 - 1; n6 >= 0; --n6) s4.mulThis(t3), s4.addThis(this.m_elements[n6]);
    return s4;
  }
  equals(t3) {
    if (this === t3) return true;
    if (this.power() !== t3.power()) return false;
    for (let e5 = this.m_elements.length - 1; e5 >= 0; e5--) if (!this.m_elements[e5].equals(t3.m_elements[e5])) return false;
    return true;
  }
  updatePower() {
    for (let t3 = this.m_elements.length - 1; t3 > 0 && this.m_elements[t3].isZero(); t3--) this.m_elements.pop();
    return this;
  }
  setZero() {
    return this.m_elements.length = 1, this.m_elements[0] = new this.m_zeroCtor(), this.updatePower(), this;
  }
  derivative(t3) {
    if (this.power() < t3) return this.clone().setZero();
    if (0 === t3) return this.clone();
    const e5 = new this.constructor({ coefsT: this.m_elements.slice(t3), power: this.power() - t3 });
    for (let s4 = t3, n6 = this.power(); s4 <= n6; s4++) {
      let n7 = BigInt(s4);
      for (let e6 = s4 - 1, i2 = s4 - t3; e6 > i2; --e6) n7 *= BigInt(e6);
      e5.m_elements[s4 - t3].mulBigIntThis(n7);
    }
    return e5.updatePower(), e5;
  }
  derivative1This() {
    if (this.m_elements.length > 1) {
      this.m_elements = this.m_elements.slice(1);
      for (let t3 = 1, e5 = this.power(); t3 <= e5; t3++) this.m_elements[t3].mulThis(si.constructInt32(t3 + 1));
    } else this.m_elements.length = 0, this.m_elements.push(new this.m_zeroCtor());
    return this;
  }
  limitPrecisionThis(t3) {
    for (let e5 = this.power(); e5 >= 0; --e5) this.m_elements[e5].limitPrecisionThis(t3);
    return this.updatePower(), this;
  }
  hiBitIndex() {
    return this.m_elements.reduce((t3, e5) => {
      const s4 = e5.hiBitIndex();
      return t3 < s4 ? s4 : t3;
    }, 0);
  }
  shiftRight(t3) {
    return this.m_elements.splice(0, t3), this.updatePower(), this;
  }
  evaluateDerivative(t3) {
    const e5 = this.power(), s4 = this.m_elements[e5];
    s4.mulDoubleThis(e5);
    for (let n6 = e5 - 1; n6 >= 1; --n6) {
      s4.mulThis(t3);
      const e6 = this.m_elements[n6];
      e6.mulDoubleThis(n6), s4.addThis(e6);
    }
    return s4;
  }
  static evaluateCoefs(t3, e5, s4) {
    const n6 = t3.power();
    s4.construct0(t3.getElement(0).evaluate(e5));
    for (let i2 = 1; i2 <= n6; ++i2) s4.addElement(t3.getElement(i2).evaluate(e5));
    s4.updatePower();
  }
};
var Tn = class _Tn extends An {
  constructor(t3) {
    super(void 0 === t3 ? { zeroCtor: si } : { ...t3, zeroCtor: si });
  }
  clone() {
    return new _Tn({ copy: this });
  }
  absEvaluate(t3) {
    const e5 = this.power(), s4 = this.m_elements[e5].clone();
    s4.absThis();
    const n6 = t3.clone();
    n6.absThis();
    for (let i2 = e5 - 1; i2 >= 0; --i2) s4.mulThis(n6), s4.addThis(this.m_elements[i2].abs());
    return s4;
  }
};
var In = class _In extends An {
  constructor(t3) {
    super(void 0 === t3 ? { zeroCtor: Tn } : { ...t3, zeroCtor: Tn });
  }
  clone() {
    return new _In({ copy: this });
  }
  constructFromMPValues(t3, e5) {
    this.m_elements.length = 0;
    for (let s4 = 0; s4 <= e5; ++s4) this.m_elements.push(new Tn({ coef0: t3[s4] }));
    return this.updatePower(), this;
  }
};
function Mn() {
  return { polypoly1: new In(), polypoly2: new In(), polyX2: new Tn(), polyY2: new Tn(), polyX2Deriv: new Tn(), polyY2Deriv: new Tn(), polypolyX1: new In(), polypolyY1: new In(), polypolyX1Deriv: new In(), polypolyY1Deriv: new In(), lazyPolypolyD1: new In(), lazyPolypolyD1Deriv: new In(), lazyPolyD2: new Tn(), lazyPolyD2Deriv: null, polypoly11: new In(), polypoly12: new In(), tempPp: new In(), tempPp1: new In(), tempPp2: new In(), tempP: new Tn(), tempP1: new Tn(), tempP2: new Tn() };
}
function Yn(t3, e5, n6, i2, r, o, a2, u, m3, l2, c, g2, d2, _, p3, f3, P5, y2, x4, C3 = false) {
  const v3 = Mn();
  v3.polyX2.construct(a2, u), v3.polyY2.construct(m3, l2), v3.polypolyX1.constructFromMPValues(t3, e5), v3.polypolyY1.constructFromMPValues(n6, i2), v3.polypoly11.assignCopy(v3.polypolyX1), v3.polypoly12.assignCopy(v3.polypolyY1), c && (v3.lazyPolyD2.construct(c, g2), v3.polypoly11.mulElementThis(v3.lazyPolyD2), v3.polypoly12.mulElementThis(v3.lazyPolyD2)), r ? (v3.lazyPolypolyD1.constructFromMPValues(r, o), v3.lazyPolypolyD1Deriv = new In({ copy: v3.lazyPolypolyD1 }), v3.lazyPolypolyD1Deriv.derivative1This(), v3.tempPp.assignCopy(v3.lazyPolypolyD1), v3.tempPp.mulElementThis(v3.polyX2), v3.polypoly11.subThis(v3.tempPp), v3.tempPp.assignCopy(v3.lazyPolypolyD1), v3.tempPp.mulElementThis(v3.polyY2), v3.polypoly12.subThis(v3.tempPp)) : (v3.polypoly11.sub0This(v3.polyX2), v3.polypoly12.sub0This(v3.polyY2)), v3.polypolyX1Deriv.assignCopy(v3.polypolyX1), v3.polypolyX1Deriv.derivative1This(), v3.polypolyY1Deriv.assignCopy(v3.polypolyY1), v3.polypolyY1Deriv.derivative1This(), r && (v3.polypolyX1Deriv.mulThis(v3.lazyPolypolyD1), v3.tempPp2.assignCopy(v3.lazyPolypolyD1Deriv), v3.tempPp2.mulThis(v3.polypolyX1), v3.polypolyX1Deriv.subThis(v3.tempPp2), v3.polypolyY1Deriv.mulThis(v3.lazyPolypolyD1), v3.tempPp2.assignCopy(v3.lazyPolypolyD1Deriv), v3.tempPp2.mulThis(v3.polypolyY1), v3.polypolyY1Deriv.subThis(v3.tempPp2)), v3.polyX2Deriv.assignCopy(v3.polyX2), v3.polyX2Deriv.derivative1This(), v3.polyY2Deriv.assignCopy(v3.polyY2), v3.polyY2Deriv.derivative1This(), c && (n2(null === v3.lazyPolyD2Deriv), v3.lazyPolyD2Deriv = new Tn({ copy: v3.lazyPolyD2 }), v3.lazyPolyD2Deriv.derivative1This(), v3.polyX2Deriv.mulThis(v3.lazyPolyD2), v3.tempP1.assignCopy(v3.lazyPolyD2Deriv), v3.tempP1.mulThis(v3.polyX2), v3.polyX2Deriv.subThis(v3.tempP1), v3.polyY2Deriv.mulThis(v3.lazyPolyD2), v3.tempP1.assignCopy(v3.lazyPolyD2Deriv), v3.tempP1.mulThis(v3.polyY2), v3.polyY2Deriv.subThis(v3.tempP1)), v3.polypoly1.assignCopy(v3.polypoly11), v3.polypoly1.mulElementThis(v3.polyX2Deriv), v3.tempPp.assignCopy(v3.polypoly12), v3.tempPp.mulElementThis(v3.polyY2Deriv), v3.polypoly1.addThis(v3.tempPp), v3.polypoly2.assignCopy(v3.polypolyX1Deriv), v3.polypoly2.mulElementThis(v3.polyY2Deriv), v3.tempPp.assignCopy(v3.polypolyY1Deriv), v3.tempPp.mulElementThis(v3.polyX2Deriv), v3.polypoly2.subThis(v3.tempPp);
  let b2 = [];
  const S3 = [];
  P5 || (P5 = []), f3 || (f3 = []), kn(v3.polypoly11, v3.polypoly12, v3.tempP);
  const E2 = 64, D3 = ii.ldexp(-59).toDouble(), w4 = [];
  let A4 = Gn(v3.tempP, d2, p3, D3, E2, w4, y2, y2);
  if (A4 < 0) return -1;
  for (let Y3 = 0; Y3 < A4; Y3++) {
    const t4 = v3.tempP1, e6 = v3.tempP2;
    Tn.evaluateCoefs(v3.polypoly11, w4[Y3], t4);
    const n7 = Et(t4.m_elements, t4.power() + 1);
    n7.sort((t5, e7) => t5.compare(e7)), Tn.evaluateCoefs(v3.polypoly12, w4[Y3], e6);
    const i3 = Et(e6.m_elements, e6.power() + 1);
    i3.sort((t5, e7) => t5.compare(e7));
    const r2 = n7[0], o2 = n7.at(-1), a3 = i3[0], u2 = i3.at(-1);
    o2.subThis(r2), u2.subThis(a3);
    const m4 = o2.subThis(u2).GEZ(), l3 = 58, c2 = ii.ldexp(-59).toDouble(), g3 = [];
    let p4;
    if (p4 = Gn(m4 ? t4 : e6, d2, _, c2, l3, g3, y2, y2), p4 < 0 && b("mp_curve_proximity"), p4 > 0) {
      const n8 = m4 ? e6 : t4;
      for (let t5 = 0; t5 < p4; t5++) {
        let e7;
        if (m4) {
          const s4 = v3.tempP;
          Tn.evaluateCoefs(v3.polypoly12, w4[Y3].addDouble(Number.EPSILON), s4), e7 = s4.evaluate(g3[t5]);
        } else {
          const s4 = v3.tempP;
          Tn.evaluateCoefs(v3.polypoly11, w4[Y3].addDouble(Number.EPSILON), s4), e7 = s4.evaluate(g3[t5]);
        }
        const i4 = n8.evaluateDerivative(g3[t5]).abs().mulDoubleThis(Number.EPSILON), r3 = n8.evaluate(g3[t5]);
        i4.addThis(e7.sub(r3).absThis()), i4.ldexpThis(3), r3.absThis(), r3.lt(i4) ? S3.push($t(g3[t5].toDouble(), w4[Y3].toDouble())) : n2(r3.gte(i4));
      }
    }
  }
  A4 = S3.length, kn(v3.polypoly1, v3.polypoly2, v3.tempP);
  const T3 = [];
  let I4 = Gn(v3.tempP, d2, p3, D3, E2, T3);
  I4 < 0 && (I4 = 0);
  for (let s4 = 0; s4 < I4; s4++) {
    Tn.evaluateCoefs(v3.polypoly1, T3[s4], v3.tempP1);
    const t4 = [];
    let e6 = Gn(v3.tempP1, d2, _, D3, E2, t4);
    if (0 !== e6) if (Tn.evaluateCoefs(v3.polypoly2, T3[s4], v3.tempP2), e6 < 0) {
      if (e6 = Gn(v3.tempP2, d2, _, D3, E2, t4), e6 < 0) continue;
      for (let n7 = 0; n7 < e6; n7++) b2.push($t(t4[n7].toDouble(), T3[s4].toDouble()));
    } else {
      const n7 = v3.tempP2.absEvaluate(ii);
      n7.mulThis(si.constructDouble(1e-12));
      for (let i3 = 0; i3 < e6; i3++) {
        const e7 = v3.tempP2.evaluate(t4[i3]);
        e7.absThis(), e7.lt(n7) && b2.push($t(t4[i3].toDouble(), T3[s4].toDouble()));
      }
    }
  }
  if (I4 = b2.length, 0 === A4 && 0 === I4) return 0;
  b2 = b2.concat(S3), b2.sort((t4, e6) => C3 ? Ct(t4.second, e6.second) : Ct(t4.first, e6.first));
  const M2 = Bt(b2, (t4, e6) => t4.first === e6.first && t4.second === e6.second);
  b2 = b2.slice(0, M2), f3.length = 0, P5.length = 0;
  for (const s4 of b2) f3.push(s4.first), P5.push(s4.second);
  return n2(f3.length === P5.length), P5.length;
}
function Nn(t3, e5, s4, n6, i2, r, o) {
  if (0 === t3.power()) return t3.isZero() ? -1 : 0;
  const a2 = t3.evaluate(si.constructInt32(1)).isZero();
  if (1 === t3.power()) {
    const s5 = Fn(t3.getElement(1), t3.getElement(0), e5, r.at(0));
    return r[0].limitPrecisionThis(n6), 1 !== s5 ? 0 : (r[0].limitPrecisionThis(n6), 1);
  }
  if (2 === t3.power()) {
    return Vn(t3.getElement(2), t3.getElement(1), t3.getElement(0), n6, e5, a2, r);
  }
  if (3 === t3.power()) {
    return Ln(t3.getElement(3), t3.getElement(2), t3.getElement(1), t3.getElement(0), n6, e5, a2, r);
  }
  if (4 === t3.power()) {
    return Rn(t3.getElement(4), t3.getElement(3), t3.getElement(2), t3.getElement(1), t3.getElement(0), n6, e5, a2, r);
  }
  return Un(t3, e5, s4, n6, a2, i2, r, o);
}
function Xn() {
  return { polyIntersect: new Tn(), polyX1: new Tn(), polyY1: new Tn(), polyX1Deriv: new Tn(), polyY1Deriv: new Tn(), lazyPolyD1: new Tn(), lazyPolyD1Deriv: new Tn(), tempP: new Tn(), tempP1: new Tn(), tempP2: new Tn(), polypoly1Proximity: new In(), polypoly2Proximity: new In() };
}
function qn(t3, e5, s4, n6, i2, r, o, a2, h2, u, m3, l2, c) {
  const g2 = Xn();
  g2.polyX1.construct(t3, e5), g2.polyY1.construct(s4, n6), g2.polyX1Deriv.assignCopy(g2.polyX1), g2.polyX1Deriv.derivative1This(), g2.polyY1Deriv.assignCopy(g2.polyY1), g2.polyY1Deriv.derivative1This(), g2.polyIntersect.assignCopy(g2.polyX1), g2.polyIntersect.mulThis(g2.polyX1), g2.polyIntersect.mulElementThis(o[0]), g2.tempP.assignCopy(g2.polyY1), g2.tempP.mulThis(g2.polyY1), g2.tempP.mulElementThis(o[1]), g2.polyIntersect.addThis(g2.tempP), i2 ? (g2.lazyPolyD1.construct(i2, r), g2.tempP.assignCopy(g2.lazyPolyD1), g2.tempP.mulThis(g2.lazyPolyD1), g2.tempP.mulElementThis(o[2]), g2.polyIntersect.addThis(g2.tempP)) : g2.polyIntersect.add0(o[2]);
  {
    const i3 = o[0].clone(), r2 = i3.clone();
    r2.sqrThis();
    const a3 = o[1].clone(), h3 = a3.clone();
    h3.sqrThis();
    const u2 = o[2].clone(), m4 = i3.clone();
    m4.subThis(a3), g2.polyX1.construct(t3, e5), g2.polyX1Deriv.assignCopy(g2.polyX1), g2.polyX1Deriv.derivative1This(), g2.polyY1.construct(s4, n6), g2.polyY1Deriv.assignCopy(g2.polyY1), g2.polyY1Deriv.derivative1This(), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulThis(g2.polyX1), g2.tempP.mulElementThis(h3), g2.tempP.mulElementThis(u2), g2.polypoly1Proximity.construct0(g2.tempP), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulThis(a3.mul(m4).mul(u2).ldexpThis(1)), g2.polypoly1Proximity.addElement(g2.tempP), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulThis(g2.polyX1), g2.tempP.mulElementThis(i3.mul(h3)), g2.tempP1.assignCopy(g2.polyY1), g2.tempP1.mulThis(g2.polyY1), g2.tempP1.mulElementThis(r2.mul(a3)), g2.tempP.addThis(g2.tempP1), g2.tempP.add0(m4.mul(m4).mul(u2)), g2.polypoly1Proximity.addElement(g2.tempP), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulElementThis(m4.mul(i3).mul(a3).ldexpThis(1)), g2.polypoly1Proximity.addElement(g2.tempP), g2.tempP.construct0(i3.mul(m4).mul(m4)), g2.polypoly1Proximity.addElement(g2.tempP), g2.polypoly1Proximity.updatePower(), g2.tempP.construct0(ei), g2.polypoly2Proximity.construct0(g2.tempP), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulThis(g2.polyX1Deriv), g2.tempP1.assignCopy(g2.polyY1), g2.tempP1.mulThis(g2.polyY1Deriv), g2.tempP.addThis(g2.tempP1), g2.tempP.mulElementThis(i3.mul(a3)), g2.polypoly2Proximity.addElement(g2.tempP), g2.tempP.assignCopy(g2.polyX1Deriv), g2.tempP.mulElementThis(m4.mul(i3)), g2.polypoly2Proximity.addElement(g2.tempP), g2.polypoly2Proximity.updatePower();
  }
  const d2 = [], _ = [];
  null === m3 && (m3 = []);
  let p3 = 2 * g2.polyIntersect.power() + 58;
  const f3 = 0.5 * Number.EPSILON, P5 = [], y2 = Gn(g2.polyIntersect, a2, h2, f3, p3, P5, l2, l2);
  if (y2 < 0) return -1;
  for (const b2 of P5) _.push(b2.toDouble());
  kn(g2.polypoly1Proximity, g2.polypoly2Proximity, g2.tempP), p3 = 2 * g2.tempP.power() + 58, P5.length = 0;
  let x4 = Gn(g2.tempP, a2, h2, f3, p3, P5);
  if (x4 < 0 && (x4 = 0), 0 === y2 && 0 === x4) return 0;
  for (const b2 of P5) d2.push(b2.toDouble());
  const C3 = d2.concat(_);
  m3.length = C3.length, Dt(m3, C3, 0, 0, C3.length), qt(m3);
  const v3 = Bt(m3, (t4, e6) => 0 === Ct(t4, e6));
  return m3.length = v3, m3.length;
}
function Fn(t3, e5, s4, n6) {
  return t3.isZero() ? e5.isZero() ? -1 : 0 : (n6.setThis(e5), n6.negateThis(), n6.divThis(t3), s4.isEmpty() || s4.containsCoordinate(n6.value()) ? 1 : 0);
}
function Vn(t3, e5, s4, n6, i2, r, o) {
  if (t3.isZero()) {
    if (r) return o[0].setInt32(1), i2.containsCoordinate(1) ? 1 : 0;
    return Fn(e5, s4, i2, o[0]);
  }
  if (r) {
    let e6 = 2;
    return o[0].setInt32(1), s4.equals(t3) ? (o[1].setInt32(1), e6 = 1) : o[1].setThis(s4.div(t3)), i2.containsCoordinate(o[1].value()) || (e6 = 1), i2.containsCoordinate(o[0].value()) || (e6--, o[0].setThis(o[1])), 2 === e6 && o[0].value() > o[1].value() && (o[1] = Pt(o[0], o[0] = o[1])), e6;
  }
  const a2 = e5.clone();
  a2.sqrThis();
  const h2 = t3.clone();
  if (h2.mulThis(s4).ldexpThis(2).negateThis().addThis(a2), h2.LZ()) return 0;
  const u = n6 + 2, m3 = si.sqrt(h2, u), l2 = m3.clone();
  e5.LZ() && l2.negateThis(), l2.addThis(e5).limitPrecisionThis(u).ldexpThis(-1).negateThis();
  let c = 0;
  return o[0].setThis(l2).divThis(si.constructAssign(t3, u)).limitPrecisionThis(n6), (i2.isEmpty() || i2.containsCoordinate(o[0].value())) && c++, m3.isZero() || l2.isZero() || (o[c].setThis(s4).divThis(l2).limitPrecisionThis(n6), (i2.isEmpty() || i2.containsCoordinate(o[c].value())) && c++, 2 === c && o[0].gt(o[1]) && (o[1] = Pt(o[0], o[0] = o[1]))), c;
}
function Ln(t3, e5, n6, i2, r, o, a2, h2) {
  if (t3.isZero()) {
    return Vn(e5, n6, i2, r, o, a2, h2);
  }
  const u = (t4, e6) => {
    if (t4 > 0) {
      let s4 = e6 + t4;
      for (let t5 = 1; t5 < s4; t5++) h2[t5].equals(h2[0]) && (h2[s4 - 1] = Pt(h2[t5], h2[t5] = h2[s4 - 1]), s4--);
      e6 = s4;
    }
    return Zt(h2, 0, e6, (t5, e7) => t5.compare(e7)), e6;
  };
  if (i2.isZero()) {
    let s4 = 0;
    o.containsCoordinate(0) && (h2[0].setInt32(0), s4 = 1);
    return u(Vn(t3, e5, n6, r, o, a2, h2.slice(1)), s4);
  }
  if (a2) {
    let s4 = 0;
    o.containsCoordinate(1) && (h2[0].setInt32(1), s4 = 1);
    const n7 = e5.add(t3), a3 = i2.negate(), m4 = t3.add(n7).add(a3).isZero();
    return u(Vn(t3, n7, a3, r, o, m4, h2.slice(s4)), s4);
  }
  const m3 = new si(), l2 = new si(), c = new si(), g2 = e5.clone();
  if (g2.isZero()) l2.setThis(n6), l2.divThis(t3), c.setThis(i2), c.divThis(t3);
  else {
    g2.divThis(t3).divDoubleThis(3).negateThis();
    const s4 = e5.clone();
    s4.sqrThis();
    const r2 = t3.clone();
    r2.sqrThis(), l2.setThis(t3), l2.mulThis(n6).mulDoubleThis(3).subThis(s4).divThis(r2).divDoubleThis(3), c.setThis(s4), c.mulThis(e5), c.ldexpThis(1), m3.setThis(t3), m3.mulThis(e5).mulThis(n6).mulDoubleThis(9), c.subThis(m3), m3.setThis(r2), m3.mulThis(i2).mulDoubleThis(27), c.addThis(m3), c.divThis(r2).divThis(t3).divDoubleThis(27);
  }
  if (l2.isZero()) {
    const t4 = c.clone();
    return t4.negateThis(), t4.isZero() ? (h2[0].setThis(g2), Qn(o, r, h2, 1)) : (h2[0].setThis(si.cubicRoot(t4, r).add(g2)), Qn(o, r, h2, 1));
  }
  const d2 = c.clone();
  if (d2.sqrThis().ldexpThis(-2), m3.setThis(l2.clone()), m3.sqrThis().mulThis(l2).divDoubleThis(27), d2.addThis(m3), d2.isZero()) return h2[0].setThis(c), h2[0].mulDoubleThis(3).divThis(l2), h2[1].setThis(h2[0]), h2[1].negateThis(), h2[1].ldexpThis(-1), h2[0].addThis(g2), h2[1].addThis(g2), Qn(o, r, h2, 2);
  if (d2.GZ()) return d2.setThis(si.sqrt(d2, r + 8)), m3.setThis(c), m3.ldexpThis(-1).negateThis(), m3.addThis(d2), h2[0].setThis(si.cubicRoot(m3, r + 8)), m3.setThis(c), m3.ldexpThis(-1).negateThis(), m3.subThis(d2), h2[0].addThis(si.cubicRoot(m3, r + 8)), h2[0].addThis(g2), Qn(o, r, h2, 1);
  m3.setThis(l2), m3.divDoubleThis(3).negateThis(), n2(m3.GEZ());
  const _ = si.sqrt(m3, r + 8), p3 = _.clone();
  p3.negateThis(), p3.addThis(g2), _.addThis(g2);
  const f3 = si.constructDouble(o.isEmpty() ? -Number.MAX_VALUE : o.vmin), P5 = si.constructDouble(o.isEmpty() ? Number.MAX_VALUE : o.vmax), y2 = new Tn({ zeroCtor: si });
  y2.construct0(i2), y2.addElement(n6), y2.addElement(e5), y2.addElement(t3);
  const x4 = new Tn({ copy: y2 });
  x4.derivative1This();
  let C3 = 0;
  const v3 = Ot(si, 4);
  v3[C3++].setThis(f3), p3.gt(f3) && p3.lt(P5) && v3[C3++].setThis(p3), _.gt(f3) && _.lt(P5) && v3[C3++].setThis(_), v3[C3++].setThis(P5);
  const b2 = 3 * r;
  let S3 = 52, E2 = Number.EPSILON;
  for (; S3 < b2; ) 2 * S3 <= b2 ? (E2 *= E2, S3 *= 2) : (E2 *= Number.EPSILON, S3 += 52);
  S3 += 2;
  let D3 = 0, w4 = false;
  for (let s4 = 1; s4 < C3; s4++) {
    if (Zn(y2, x4, v3[s4 - 1], v3[s4], E2, S3, h2[0])) {
      D3 = 1, w4 = s4 + 1 < C3;
      break;
    }
  }
  if (!D3) return 0;
  if (w4) {
    const t4 = new Tn({ zeroCtor: si, coef0: h2[0] });
    t4.negateThis(), t4.addElement(ii);
    const e6 = new Tn({ zeroCtor: si }), n7 = new Tn({ zeroCtor: si });
    y2.div(t4, e6, n7), n2(2 === e6.power()), n2(0 === n7.power());
    const i3 = Vn(e6.getElement(2), e6.getElement(1), e6.getElement(0), r, o, false, h2.slice(1));
    n2(i3 >= 0 && i3 <= 2), D3 += i3;
  }
  return Qn(o, r, h2, D3);
}
function Rn(t3, e5, s4, n6, i2, r, o, a2, h2) {
  if (t3.isZero()) return Ln(e5, s4, n6, i2, r, o, a2, h2);
  const u = (t4, e6) => {
    if (t4 > 0) {
      let s5 = e6 + t4;
      for (let t5 = 1; t5 < s5; t5++) h2[t5].equals(h2[0]) && (h2[s5 - 1] = Pt(h2[t5], h2[t5] = h2[s5 - 1]), s5--);
      e6 = s5;
    }
    return Zt(h2, 0, e6, (t5, e7) => t5.compare(e7)), e6;
  };
  if (i2.isZero()) {
    let i3 = 0;
    o.containsCoordinate(0) && (h2[0].setInt32(0), i3 = 1);
    return u(Ln(t3, e5, s4, n6, r, o, a2, h2.slice(i3)), i3);
  }
  const m3 = new Tn({ zeroCtor: si, coef0: i2 });
  if (m3.addElement(n6), m3.addElement(s4), m3.addElement(e5), m3.addElement(t3), a2) {
    let t4 = 0;
    o.containsCoordinate(1) && (h2[0].setInt32(1), t4 = 1);
    const e6 = new Tn({ zeroCtor: si, coef0: si.constructInt32(-1) });
    e6.addElement(si.constructInt32(1));
    const s5 = new Tn({ zeroCtor: si }), n7 = new Tn({ zeroCtor: si });
    m3.div(e6, s5, n7);
    return u(Ln(3 === s5.power() ? s5.getElement(3) : ei.clone(), s5.power() >= 2 ? s5.getElement(2) : ei.clone(), s5.power() >= 1 ? s5.getElement(1) : ei.clone(), s5.getElement(0), r, o, s5.evaluate(ii).isZero(), h2.slice(t4)), t4);
  }
  if (m3.getElement(0).isZero()) {
    let t4 = 0;
    for (o.containsCoordinate(0) && (t4 = 1, h2[0].setDouble(0)); m3.getElement(0).isZero() && m3.power() > 0; ) m3.shiftRight(1);
    const e6 = Ln(3 === m3.power() ? m3.getElement(3) : ei.clone(), m3.power() >= 2 ? m3.getElement(2) : ei.clone(), m3.power() >= 1 ? m3.getElement(1) : ei.clone(), m3.getElement(0), r, o, false, h2.slice(t4));
    return e6 > 0 && (t4 += e6), Zt(h2, 0, t4, (t5, e7) => t5.compare(e7)), t4;
  }
  let l2 = 52, c = Number.EPSILON;
  for (; l2 < r; ) 2 * l2 <= r ? (c *= c, l2 *= 2) : (c *= Number.EPSILON, l2 += 52);
  l2 += 2;
  const g2 = On(m3), d2 = si.constructDouble(Math.max(Math.abs(o.vmax), Math.abs(o.vmin)));
  return c = (g2.lt(d2) ? g2 : d2).mul(si.constructDouble(c)).toDouble(), Un(m3, o, c, l2, a2, false, h2, 4);
}
function zn(t3, e5) {
  let s4 = t3, n6 = e5;
  n6.power() > s4.power() && (n6 = Pt(s4, s4 = n6));
  const i2 = s4.power() - n6.power(), r = new Tn({ copy: s4.getElement(s4.power()) });
  s4.mulThis(n6.getElement(n6.power()));
  for (let o = 0, a2 = s4.power(); o < a2; o++) if (o >= i2) {
    const t4 = new Tn({ copy: n6.getElement(o - i2) });
    t4.mulThis(r);
    const e6 = s4.getElement(o).sub(t4);
    s4.setElement(o, e6);
  }
  s4.setElement(s4.power(), s4.getElement(s4.power()).setZero()), s4.updatePower(), Bn(s4);
}
function Bn(t3) {
  let e5 = 0;
  for (; e5 < t3.power() && t3.getElement(e5).isZero(); ) e5++;
  return e5 > 0 && (t3.shiftRight(e5), true);
}
function kn(t3, e5, s4) {
  const n6 = t3.clone(), i2 = e5.clone();
  for (Bn(n6), Bn(i2); 0 !== n6.power() || 0 !== i2.power(); ) zn(n6, i2);
  s4.assignMove(n6.getElement(0));
}
function Gn(t3, e5, s4, n6, i2, r, o = false, a2 = false) {
  r.length = 0;
  const h2 = t3.power(), u = Ot(si, 2 * h2 + 4), m3 = Nn(t3, s4 || x2.unit(), n6, i2, false, u, u.length);
  if (m3 > 0) {
    r.length = 0;
    for (let t4 = 0; t4 < m3; t4++) {
      const e6 = u[t4];
      t4 > 0 && e6.lte(r.at(-1)) || r.push(e6.clone());
    }
    return r.length;
  }
  return m3;
}
function Wn(t3, e5, n6) {
  if (n2(n6 >= 1), 0 === t3.power()) return t3.isZero() ? -1 : 0;
  const i2 = t3.getElement(0);
  return i2.negateThis(), i2.divThis(t3.getElement(1)), e5[0].setThis(i2), 1;
}
function jn(t3, e5, n6, i2) {
  if (t3.power() < 2) return Wn(t3, n6, i2);
  n2(i2 >= 1);
  let r = t3.getElement(1);
  r.mulThis(t3.getElement(1));
  const o = t3.getElement(0);
  if (o.mulThis(t3.getElement(2)), o.ldexpThis(2), r.subThis(o), r.LZ()) return 0;
  if (r.isZero()) {
    const s4 = t3.getElement(1);
    return s4.negateThis(), s4.divThis(t3.getElement(2)), s4.ldexpThis(-1), s4.limitPrecisionThis(e5), n6[0].setThis(s4), 1;
  }
  n2(i2 >= 2), r = si.sqrt(r, e5 + 8);
  const a2 = t3.getElement(1);
  a2.negateThis();
  const h2 = a2.clone();
  h2.subThis(r), h2.divThis(t3.getElement(2)), h2.ldexpThis(-1), h2.limitPrecisionThis(e5);
  const u = a2.clone();
  return u.addThis(r), u.divThis(t3.getElement(2)), u.ldexpThis(-1), u.limitPrecisionThis(e5), h2.lt(u) ? (n6[0].setThis(h2), n6[1].setThis(u)) : (n6[1].setThis(h2), n6[0].setThis(u)), 2;
}
function Zn(t3, e5, s4, n6, i2, r, o) {
  let a2 = s4.clone(), u = n6.clone();
  a2.limitPrecisionThis(r), u.limitPrecisionThis(r);
  let m3 = t3.evaluate(a2);
  m3.limitPrecisionThis(r + 2);
  let l2 = t3.evaluate(u);
  if (l2.limitPrecisionThis(r + 2), m3.GEZ() && l2.GEZ() || m3.LEZ() && l2.LEZ()) return m3.absLessAbs(l2) ? (o = a2, m3.isZero()) : (o = u, l2.isZero());
  const c = l2.LZ();
  c && (l2 = Pt(m3, m3 = l2), u = Pt(a2, a2 = u));
  const g2 = c ? u : a2, d2 = c ? a2 : u, _ = a2.add(u).ldexpThis(-1);
  _.limitPrecisionThis(r);
  const p3 = u.sub(a2);
  p3.limitPrecisionThis(r), p3.absThis();
  const f3 = p3.clone();
  let P5 = t3.evaluate(_), y2 = e5.evaluate(_);
  const x4 = new Tn({ copy: t3 }), C3 = new Tn({ copy: e5 });
  {
    const s5 = Math.max(t3.hiBitIndex(), e5.hiBitIndex()), n7 = ii.clone();
    n7.ldexpThis(-(r + 2));
    for (let i3 = 64; i3 < s5; ) {
      x4.limitPrecisionThis(i3), C3.limitPrecisionThis(i3);
      const r2 = x4.evaluate(_), o2 = C3.evaluate(_), a3 = r2.sub(P5), h2 = o2.sub(y2);
      if (a3.divThis(P5).absThis().lt(n7) && (y2.isZero() || h2.divThis(y2).absThis().lt(n7))) break;
      x4.assignCopy(t3), C3.assignCopy(e5), i3 = Math.min(i3 + 64, s5);
    }
    P5.limitPrecisionThis(r + 2), y2.limitPrecisionThis(r + 2);
  }
  const v3 = 1, b2 = 4;
  let S3 = b2;
  const E2 = 2;
  let D3 = 1, w4 = 0, A4 = 0, T3 = v3;
  const I4 = 32, M2 = si.constructDouble(0.25 * i2), Y3 = si.constructDouble(0.5001);
  let N2 = 0;
  const X3 = 300;
  for (; ++N2 < X3; ) {
    if (N2 > I4 && w4 > 0 || y2.isZero() || T3 === E2 && w4 > 1 || T3 === v3 && S3 < b2) T3 = v3, D3 > 1 && D3--;
    else if (T3 = E2, A4 > 1) {
      const t5 = p3.mul(y2);
      t5.absThis(), t5.ldexpThis(-3), t5.absLessAbs(P5) && D3++;
    }
    p3.setThis(f3);
    const t4 = new si();
    let e6 = false;
    if (T3 === v3) do {
      if (A4 > 2) {
        const e7 = p3.clone();
        if (e7.absThis(), e7.ldexpThis(4), d2.sub(g2).ldexpThis(-1).gt(e7)) {
          if (_.equals(g2)) {
            t4.setThis(_), _.setThis(g2.add(e7)), _.limitPrecisionThis(r), f3.setThis(_.sub(t4));
            break;
          }
          if (_.equals(d2)) {
            t4.setThis(_), _.setThis(d2.sub(e7)), _.limitPrecisionThis(r), f3.setThis(_.sub(t4));
            break;
          }
        }
      }
      f3.setThis(u.sub(a2)), f3.ldexpThis(-1), f3.limitPrecisionThis(r), t4.setThis(_), _.setThis(a2.add(f3)), _.limitPrecisionThis(r), _.lt(g2) ? _.setThis(g2) : _.gt(d2) && _.setThis(d2), e6 = a2.equals(_) || u.equals(_);
    } while (0);
    else for (; ; ) {
      if (f3.setThis(P5.div(y2)), f3.limitPrecisionThis(r), 1 !== D3 && f3.mulDoubleThis(D3), t4.setThis(_), _.subThis(f3), _.limitPrecisionThis(r), e6 = _.equals(t4), _.lt(g2)) {
        if (D3 > 1) {
          _.setThis(t4), D3--;
          continue;
        }
        f3.setThis(t4.sub(g2)), _.setThis(g2);
      } else if (_.gt(d2)) {
        if (D3 > 1) {
          _.setThis(t4), D3--;
          continue;
        }
        f3.setThis(t4.sub(d2)), _.setThis(d2);
      }
      break;
    }
    if (e6 || f3.absLessAbs(M2)) {
      t4.equals(_) || (P5 = x4.evaluate(_), P5.limitPrecisionThis(r + 2));
      break;
    }
    P5 = x4.evaluate(_), P5.limitPrecisionThis(r + 2), y2 = C3.evaluate(_), y2.limitPrecisionThis(r + 2);
    const s5 = a2.clone(), n7 = u.clone();
    P5.LZ() ? (m3.setThis(P5), a2.setThis(_)) : (l2.setThis(P5), u.setThis(_)), T3 === E2 && (a2.equals(s5) && u.equals(n7) || A4 > 1 && !f3.absLessAbs(Y3.mul(p3))) ? w4++ : w4 = 0, T3 === v3 ? (S3++, A4 = 0) : (S3 = 0, A4++);
  }
  return N2 >= X3 && b("Root_finder iterations exceeded"), o.setThis(_), true;
}
function Hn(t3, e5, s4, n6, i2) {
  const r = t3.evaluate(s4);
  if (r.isZero()) return true;
  const o = si.constructDouble(0.5 * n6), a2 = s4.clone();
  a2.subThis(o);
  const h2 = t3.evaluate(a2), u = s4.clone();
  u.addThis(o);
  const m3 = t3.evaluate(u);
  if (h2.LZ() && m3.GZ() || h2.GZ() && m3.LZ()) return true;
  if (r.GZ() ? h2.LEZ() || m3.LEZ() : h2.GEZ() || m3.GEZ()) return true;
  const l2 = h2.LEZ() && m3.LEZ(), c = h2.GEZ() && m3.GEZ();
  let g2 = false;
  return l2 ? r.gt(h2) && r.gt(m3) && (g2 = true) : c && r.lt(h2) && r.lt(m3) && (g2 = true), !!g2 && r.absThis().lt(si.constructDouble(1e-17));
}
function Un(t3, e5, n6, i2, r, o, a2, h2) {
  n2(n6 > 0), n2(h2 >= t3.power());
  const u = a2, m3 = [];
  let l2 = [];
  const c = new Tn({ zeroCtor: t3.m_zeroCtor }), g2 = new Tn({ zeroCtor: t3.m_zeroCtor }), d2 = new Tn({ zeroCtor: t3.m_zeroCtor }), _ = si.constructDouble(n6), p3 = si.constructDouble(e5.vmin), f3 = si.constructDouble(e5.vmax), P5 = p3.sub(_), y2 = f3.add(_), x4 = On(t3), C3 = x4.clone();
  if (C3.negateThis(), P5.lt(C3)) P5.setThis(C3.sub(_));
  else if (P5.gt(x4)) return 0;
  if (y2.gt(x4)) y2.setThis(x4.add(_));
  else if (y2.lt(C3)) return 0;
  let v3 = t3, b2 = null;
  if (r) {
    const e6 = new Tn({ coef0: si.constructInt32(-1) });
    e6.addElement(ii), b2 = new Tn(), v3 = b2;
    const s4 = new Tn(), n7 = new Tn();
    for (t3.div(e6, s4, n7), b2.assignCopy(s4); v3.evaluate(ii).isZero(); ) v3.div(e6, s4, n7), b2.assignCopy(s4);
  }
  let S3 = false;
  if (v3.power() > 0 && v3.getElement(0).isZero()) for (S3 = true, b2 || (b2 = new Tn({ copy: v3 }), v3 = b2); v3.getElement(0).isZero(); ) b2.shiftRight(1);
  let E2 = i2 + 2 * v3.power() + 2, D3 = n6 / Math.pow(2, v3.power() + 2), w4 = E2;
  if (ei.gt(P5) && ei.lt(y2)) {
    for (let s4 = 0, Y3 = v3.power(); s4 < Y3; s4++) if (v3.getElement(s4).isZero()) {
      m3.push(ei.clone());
      break;
    }
  }
  for (let Y3 = v3.power() - 1; Y3 > 0; Y3--) if (D3 *= 2, E2 -= 2, w4 -= 2, v3.power() - Y3 !== 1) if (v3.power() - Y3 !== 2) {
    g2.assignMove(d2), d2.assignMove(v3.derivative(Y3 - 1));
    let t4 = [];
    for (let e6 = 0, s4 = l2.length; e6 < s4; ++e6) if (l2[e6].first.lte(l2[e6].second)) {
      const s5 = new si();
      if (Zn(g2, c, l2[e6].first, l2[e6].second, D3, E2, s5)) {
        m3.push(s5);
        let n7 = s5.sub(_);
        n7.limitPrecisionThis(w4), t4.push($t(l2[e6].first, n7)), n7 = s5.add(_), n7.limitPrecisionThis(w4), t4.push($t(n7, l2[e6].second));
      } else t4.push(l2[e6]);
    }
    l2 = t4, t4 = [], c.assignMove(g2);
  } else {
    g2.assignMove(v3.derivative(Y3));
    const t4 = jn(g2, E2, u, h2);
    n2(t4 >= 0 && t4 <= 2);
    for (let e6 = 0; e6 < t4; e6++) u[e6].gt(P5) && u[e6].lt(y2) && !u[e6].isZero() && m3.push(u[e6].clone());
    if (m3.length > 1 && m3.sort((t5, e6) => t5.compare(e6)), m3.length > 0) {
      let t5 = m3[0].sub(_);
      t5.limitPrecisionThis(w4), l2.push($t(P5.clone(), t5));
      let e6 = 1 === m3.length ? y2.clone() : m3[1].sub(_);
      t5 = m3[0].add(_), t5.limitPrecisionThis(w4), e6.limitPrecisionThis(w4), l2.push($t(t5, e6)), m3.length > 1 && (e6 = 2 === m3.length ? y2.clone() : m3[2].sub(_), e6.limitPrecisionThis(w4), t5 = m3[1].add(_), t5.limitPrecisionThis(w4), l2.push($t(t5, e6)), m3.length > 2 && (t5 = m3[2].add(_), t5.limitPrecisionThis(w4), l2.push($t(t5, y2.clone()))));
    } else l2.push($t(P5.clone(), y2.clone()));
    c.assignCopy(g2), d2.assignMove(v3.derivative(Y3 - 1));
  }
  else {
    g2.assignMove(v3.derivative(Y3));
    1 === Wn(g2, u, h2) && (u[0].gt(P5) && u[0].lt(y2) && !u[0].isZero() && m3.push(u[0].clone()), c.assignMove(g2), d2.assignMove(v3.derivative(Y3 - 1)));
  }
  m3.sort((t4, e6) => t4.compare(e6)), 0 === l2.length && (c.assignMove(v3.derivative(v3.power())), c.isZero() || l2.push($t(P5.clone(), y2.clone())));
  let A4 = 0, T3 = 0, I4 = 0;
  const M2 = new si();
  for (; ; ) {
    if (T3 < l2.length) {
      if (l2[T3].first.gt(l2[T3].second)) {
        T3++;
        continue;
      }
      let t4 = false;
      if (I4 < m3.length && m3[I4].lt(l2[T3].first) && (t4 = true), !t4) {
        Zn(v3, c, l2[T3].first, l2[T3].second, n6, i2, M2) && (M2.lt(p3) ? u[A4++].setThis(p3) : M2.gt(f3) ? u[A4++].setThis(f3) : u[A4++].setThis(M2)), T3++;
        continue;
      }
    }
    if (!(I4 < m3.length)) break;
    0 !== I4 && m3[I4 - 1].equals(m3[I4]) || Hn(v3, c, m3[I4], n6) && (M2.setThis(m3[I4]), M2.lt(p3) ? M2.setThis(p3) : M2.gt(f3) && M2.setThis(f3), 0 !== A4 && u[A4].equals(M2) || u[A4++].setThis(M2)), I4++;
  }
  return S3 && ei.gt(P5) && ei.lt(y2) && (u[A4++].setThis(ei), Zt(u, 0, A4, (t4, e6) => t4.compare(e6))), r && ii.gt(P5) && ii.lt(y2) && (u[A4++].setThis(ii), Zt(u, 0, A4, (t4, e6) => t4.compare(e6))), A4;
}
function On(t3) {
  const e5 = t3.getElement(t3.power());
  e5.limitPrecisionThis(53), e5.absThis();
  const s4 = ei.clone();
  for (let n6 = 0, i2 = t3.power(); n6 < i2; n6++) {
    const e6 = t3.getElement(n6);
    e6.limitPrecisionThis(53), e6.gt(s4) && s4.setThis(e6);
  }
  return s4.divThis(e5), s4.addThis(ii), s4.mulThis(si.constructDouble(1 + 100 * Number.EPSILON)), s4;
}
function Qn(t3, e5, s4, n6) {
  let i2 = n6;
  if (!t3.isEmpty()) {
    i2 = 0;
    for (let e6 = 0; e6 < n6; ++e6) t3.containsCoordinate(s4[e6].value()) && (i2 !== e6 && s4[i2].setThis(s4[e6]), i2++);
  }
  i2 > 1 && (s4[0].gt(s4[1]) && (s4[1] = Pt(s4[0], s4[0] = s4[1])), i2 > 2 && (s4[0].gt(s4[2]) && (s4[2] = Pt(s4[0], s4[0] = s4[2])), s4[1].gt(s4[2]) && (s4[2] = Pt(s4[1], s4[1] = s4[2]))));
  for (let r = 0; r < i2; ++r) s4[r].limitPrecisionThis(e5);
  return i2;
}
function Jn(t3, e5, s4, n6, i2, r) {
  return ti(t3, e5, s4, r, n6, i2);
}
function Kn(t3, e5, s4, n6, i2, r) {
  let o = i2;
  if (n6) return r[0] = 1, o = 0.5 * (e5 - t3) * (s4(t3) + s4(e5)), o;
  const a2 = r[0], h2 = (e5 - t3) / a2, u = t3, m3 = new n3(0);
  for (let l2 = 1; l2 <= r[0]; ++l2) {
    const t4 = (l2 - 0.5) * h2;
    m3.add(s4(u + t4));
  }
  return o = 0.5 * (o + (e5 - t3) * m3.getResult() / a2), r[0] *= 2, o;
}
function $n(t3, e5, s4, n6, i2, r, o) {
  let a2 = 0, h2 = Math.abs(i2 - s4[t3]);
  const u = Yt(e5, Number.NaN), m3 = Yt(e5, Number.NaN);
  for (let d2 = 0; d2 < e5; ++d2) {
    const e6 = Math.abs(i2 - s4[t3 + d2]);
    e6 < h2 && (a2 = d2, h2 = e6), u[d2] = n6[t3 + d2], m3[d2] = n6[t3 + d2];
  }
  let l2 = 0, c = 0, g2 = 0;
  r[0] = n6[t3 + a2], a2--;
  for (let d2 = 1; d2 < e5; d2++) {
    for (let n7 = 0; n7 < e5 - d2; n7++) {
      if (c = s4[t3 + n7] - i2, g2 = s4[t3 + n7 + d2] - i2, l2 = c - g2, 0 === l2) return false;
      const e6 = (u[n7 + 1] - m3[n7]) / l2;
      u[n7] = c * e6, m3[n7] = g2 * e6;
    }
    if (2 * (a2 + 1) < e5 - d2) {
      const t4 = a2 + 1;
      o[0] = u[t4];
    } else {
      const t4 = a2;
      o[0] = m3[t4], a2--;
    }
    r[0] += o[0];
  }
  return true;
}
function ti(t3, s4, n6, i2, r, o) {
  if (n6 < s4 && P("xTo < xFrom"), n6 === s4) return 0;
  const a2 = [0];
  let u = Number.MAX_VALUE;
  const m3 = [Number.MAX_VALUE];
  let l2 = 0;
  const c = 32, g2 = Yt(c + 1, Number.NaN), d2 = Yt(c + 1, Number.NaN), _ = [0];
  g2[0] = 1;
  let p3 = 0, f3 = 0;
  for (let e5 = 0; e5 < c; e5++) {
    if (l2 = Kn(s4, n6, i2, 0 === e5, l2, _), d2[e5] = l2, e5 + 1 >= t3) {
      $n(e5 + 1 - t3, t3, g2, d2, 0, a2, m3) || b("polynomial_interpolation");
      const s5 = r * Math.abs(a2[0]) + o, n7 = Math.abs(u - a2[0]);
      if (n7 <= s5 && Math.abs(m3[0]) <= s5) {
        if (p3++, p3 > 1 && (n7 <= 0.1 * f3 || 0 === f3 || p3 > 2)) return a2[0];
      } else p3 = 0;
      f3 = n7, u = a2[0];
    }
    d2[e5 + 1] = d2[e5], g2[e5 + 1] = 0.25 * g2[e5];
  }
  return a2[0];
}
var ei2 = class {
  constructor() {
    this.area = Number.NaN, this.centroid_x = Number.NaN, this.centroid_y = 0, this.specialPoints = [], this.specialPointsLength = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
var si2 = class {
  constructor(t3, e5) {
    this.b = t3, this.len = e5;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t3, e5) {
    return 0 === t3 ? this.len - hi2(this.b, e5, false) : 0;
  }
  getError(t3) {
    return n2(0), 0;
  }
};
function ni2(t3, e5, s4, n6, i2) {
  let r = true;
  const o = Ot(mi, 3);
  t3.queryControlPoints(o);
  let a2 = r ? 0 : 1, h2 = o[1][a2] - o[0][a2], u = o[2][a2] - o[0][a2];
  const m3 = Jn(5, e5, s4, n6, i2, (t4) => {
    let e6;
    if (t4 <= 0.5) {
      const s5 = V(0, h2, t4), n7 = V(h2, u, t4);
      e6 = V(s5, n7, t4);
    } else {
      const s5 = U2(0, h2, t4), n7 = U2(h2, u, t4);
      e6 = U2(s5, n7, t4);
    }
    return e6 * gi(o, 1, t4).length();
  });
  r = false, a2 = r ? 0 : 1, h2 = o[1][a2] - o[0][a2], u = o[2][a2] - o[0][a2];
  const l2 = Jn(5, e5, s4, n6, i2, (t4) => {
    let e6;
    if (t4 <= 0.5) {
      const s5 = V(0, h2, t4), n7 = V(h2, u, t4);
      e6 = V(s5, n7, t4);
    } else {
      const s5 = U2(0, h2, t4), n7 = U2(h2, u, t4);
      e6 = U2(s5, n7, t4);
    }
    return e6 * gi(o, 1, t4).length();
  });
  return new mi(m3, l2);
}
function ii2(t3) {
  t3.m_cachedValues = null;
}
function ri(t3, e5) {
  e5.m_cachedValues = Pt(t3.m_cachedValues, t3.m_cachedValues = e5.m_cachedValues);
}
function oi2(t3) {
  if (t3.m_cachedValues) return t3.m_cachedValues;
  const e5 = new ei2();
  return ai2(t3, e5.specialPoints), xi(t3, e5), e5;
}
function ai2(t3, e5) {
  const s4 = Ot(mi, 3);
  t3.queryControlPoints(s4);
  const n6 = Ot(p2, 8);
  n6[0].set(0);
  let i2 = 1;
  {
    const t4 = Ot(p2, 3);
    ki(s4, t4, false);
    const e6 = Ot(p2, 2), r = new x2(0, 1);
    let o = cn(t4[2].mul(2), t4[1], r, e6[0]);
    o < 0 && (o = 0);
    for (let s5 = 0; s5 < o; s5++) Vs(e6[s5].value(), 0, 1) || (n6[i2] = e6[s5], i2++);
  }
  {
    const t4 = Ot(p2, 3);
    Gi(s4, t4, false);
    const e6 = Ot(p2, 2), r = new x2(0, 1);
    let o = cn(t4[2].mul(2), t4[1], r, e6[0]);
    o < 0 && (o = 0);
    for (let s5 = 0; s5 < o; s5++) Vs(e6[s5].value(), 0, 1) || (n6[i2] = e6[s5], i2++);
  }
  if (n6[i2].set(1), i2++, i2 > 2) {
    Zt(n6, 0, i2, (t5, e7) => t5.value() - e7.value());
    let t4 = 0, e6 = n6[0].value(), s5 = 1;
    for (let r = 1; r < i2; r++) n6[r].eq(n6[r - 1]) ? (e6 += n6[r].value(), s5++) : (s5 > 1 && (e6 /= s5, n6[t4].set(e6)), t4++, n6[t4] = n6[r], e6 = n6[r].value(), s5 = 1);
    t4++, i2 = t4;
  }
  n6[0].set(0), n6[i2 - 1].set(1), e5.length = i2;
  for (let r = 0; r < i2; r++) e5[r] = n6[r].value();
}
function hi2(t3, e5, s4) {
  const n6 = Ot(mi, 3);
  return t3.queryControlPoints(n6), ui(n6, e5, s4);
}
function ui(t3, e5, s4) {
  if (s4) {
    if (e5 < 0) return e5;
    if (e5 > 1) return e5 - 1 + ui(t3, 1, false);
  }
  if (1 === e5) return mi2(t3);
  const n6 = Ot(mi, 3);
  return Ii(t3, e5, n6, null), mi2(n6);
}
function mi2(t3) {
  if (t3[0].equals(t3[1])) return mi.distance(t3[2], t3[0]);
  if (t3[1].equals(t3[2])) return mi.distance(t3[0], t3[2]);
  const e5 = mi.distance(t3[0], t3[1]) + mi.distance(t3[2], t3[1]), s4 = mi.distance(t3[0], t3[2]);
  if (e5 - s4 <= e5 * Number.EPSILON) return s4;
  const n6 = 1, i2 = Ot(mi, 3);
  zi(t3, i2, true);
  const r = 4 * (H(i2[2].x) + H(i2[2].y)), o = 2 * (i2[2].x * i2[1].x + i2[2].y * i2[1].y), a2 = H(i2[1].x) + H(i2[1].y);
  if (1e-14 * (Math.abs(o) + Math.abs(a2)) >= Math.abs(r)) {
    if (1e-14 * Math.abs(a2) >= Math.abs(o)) {
      return Math.sqrt(a2) * n6;
    }
    return 2 / (3 * o) * (Math.pow(o * n6 + a2, 1.5) - Math.pow(a2, 1.5));
  }
  const h2 = o / r, u = a2 / r, m3 = u - h2 * h2, l2 = n6 + h2;
  if (0 === m3) {
    if (h2 >= 0 && l2 >= 0 || h2 <= 0 && l2 <= 0) {
      return Math.abs(0.5 * Math.sqrt(r) * (l2 * l2 - h2 * h2));
    }
    return 0.5 * Math.sqrt(r) * (l2 * l2 + h2 * h2);
  }
  const c = Math.sqrt(m3 + l2 * l2), g2 = Math.sqrt(u);
  return 0.5 * Math.sqrt(r) * (l2 * c - h2 * g2 + m3 * Math.log(Math.abs((l2 + c) / (h2 + g2))));
}
function li(t3, e5) {
  const s4 = Us(e5, 0, 1);
  let n6 = gi(t3, 1, s4);
  return n6.isZero() && (n6 = gi(t3, 2, s4)), n6;
}
function ci(t3, e5, s4) {
  const n6 = Ot(mi, 3);
  return t3.queryControlPoints(n6), gi(n6, e5, s4);
}
function gi(t3, e5, s4) {
  if (1 === e5) {
    const e6 = t3[1].sub(t3[0]).mul(1 - s4).add(t3[2].sub(t3[1]).mul(s4));
    return e6.mulThis(2), e6;
  }
  return 2 === e5 ? t3[2].sub(t3[1]).sub(t3[1].sub(t3[0]).mul(2)) : mi.construct(0, 0);
}
function di(t3, e5, s4) {
  {
    const e6 = Ye.constructPoint2D(t3[1]).subE(Ye.constructPoint2D(t3[0])), n6 = new p2(1).subE(s4), i2 = Ye.constructPoint2D(t3[2]).subE(Ye.constructPoint2D(t3[1])), r = e6.mulE(n6).addE(i2.mulE(s4));
    return r.mulThisE(new p2(2)), r;
  }
}
function _i(t3, e5, s4) {
  const n6 = hi2(t3, 1, false);
  if (e5 <= 0) return e5;
  if (e5 >= n6) return e5 - n6 + 1;
  const i2 = [0];
  return 1 !== tn(new si2(t3, e5), x2.unit(), 1, i2) && b(""), i2[0];
}
function pi(t3) {
  const e5 = Ot(mi, 3);
  return t3.queryControlPoints(e5), fi(e5);
}
function fi(t3) {
  return -t3[1].sub(t3[0]).crossProduct(t3[2].sub(t3[0])) / 3;
}
function Pi(t3) {
  const e5 = mi.distance(t3.getStartXY(), t3.getEndXY()), s4 = t3.calculateUpperLength2D();
  return s4 - e5 <= 8 * Number.EPSILON * s4;
}
function yi(t3) {
  return t3.m_cachedValues;
}
function xi(t3, e5) {
  t3.m_cachedValues = e5;
}
function Ci(t3, e5, s4, n6, i2) {
  D(x2.unit().contains(s4), "QuadraticBezierHelper::getClosestCoordinateSegment");
  const r = Ot(mi, 3);
  t3.queryControlPoints(r);
  let o = Number.MAX_VALUE;
  const a2 = [0], h2 = vi(r, e5, a2);
  if (s4.containsCoordinate(a2[0])) o = mi.distance(e5, h2);
  else {
    a2[0] = s4.vmin, ji(r, a2[0], h2), o = mi.distance(h2, e5);
    const t4 = new mi();
    ji(r, s4.vmax, t4);
    const n7 = mi.distance(t4, e5);
    o > n7 && (h2.setCoordsPoint2D(t4), a2[0] = s4.vmax, o = n7);
  }
  if (!n6) return a2[0];
  if (s4.vmin <= 0) {
    const n7 = new mi();
    t3.queryCoord2DExtended(-1, n7, true);
    const i3 = new mi();
    t3.queryCoord2D(s4.vmin, i3);
    const r2 = new pm({ start: n7, end: i3 }), u = r2.getClosestCoordinate(e5, true);
    if (u < 1) {
      const t4 = r2.getCoord2D(u), s5 = mi.distance(t4, e5);
      s5 < o && (o = s5, a2[0] = u - 1, h2.assign(t4));
    }
  }
  if (s4.vmin >= 1) {
    const n7 = new mi();
    t3.queryCoord2DExtended(2, n7, true);
    const i3 = new mi();
    t3.queryCoord2D(s4.vmax, i3);
    const r2 = new pm({ start: i3, end: n7 }), u = r2.getClosestCoordinate(e5, true);
    if (u > 0) {
      const t4 = r2.getCoord2D(u), s5 = mi.distance(t4, e5);
      s5 < o && (o = s5, a2[0] = 1 + u, h2.assign(t4));
    }
  }
  return a2[0];
}
function vi(t3, e5, s4) {
  const n6 = t3[2].sub(t3[1]).sub(t3[1].sub(t3[0])), i2 = t3[1].sub(t3[0]), r = t3[0].sub(e5), o = r.dotProduct(i2), a2 = r.dotProduct(n6) + 2 * i2.dotProduct(i2), h2 = 3 * i2.dotProduct(n6), u = n6.dotProduct(n6), m3 = Yt(3, Number.NaN), l2 = nn(u, h2, a2, o, x2.unit(), false, m3), c = t3[0].clone();
  let g2 = 0, d2 = mi.sqrDistance(t3[0], e5), _ = mi.sqrDistance(t3[2], e5);
  _ < d2 && (g2 = 1, c.assign(t3[2]), d2 = _);
  for (let p3 = 0; p3 < l2; p3++) {
    const s5 = new mi();
    ji(t3, m3[p3], s5), _ = mi.sqrDistance(s5, e5), _ < d2 && (d2 = _, c.assign(s5), g2 = m3[p3]);
  }
  return s4 && (s4[0] = g2), c;
}
function bi(t3, e5, s4, n6, i2, r) {
  const o = new De();
  if (Si(t3, x2.unit(), o), o.inflate(i2), !o.isIntersectingPoint2D(e5)) return 0;
  const a2 = new mi(), h2 = Ci(t3, e5, x2.unit(), false);
  t3.queryCoord2D(h2, a2);
  return mi.distance(a2, e5) <= i2 ? (n6 && (n6[0] = h2), 1) : 0;
}
function Si(t3, e5, s4) {
  const n6 = Ot(mi, 3);
  t3.queryControlPoints(n6), Ei(n6, e5, s4);
}
function Ei(t3, e5, s4) {
  if (e5.equalsRange(0, 1)) return void s4.setFromPoints(t3, 3);
  const n6 = Ot(mi, 3);
  Mi(t3, e5.vmin, e5.vmax, n6), s4.setFromPoints(n6, 3);
}
function Di(t3, e5, s4) {
  s4.setEmpty();
  const n6 = [];
  n6.push(new x2(0, 1));
  const i2 = 0.5 * Math.max(e5.width(), e5.height());
  for (; n6.length; ) {
    const r = n6.at(-1);
    n6.pop();
    const o = new De();
    if (Ei(t3, r, o), o.isIntersectingW(e5)) {
      const t4 = Math.max(o.width(), o.height());
      if (e5.containsW(o) || t4 <= i2 || r.width() < 1e-12) s4.merge(r);
      else {
        const t5 = r.getCenter();
        n6.push(x2.construct(r.vmin, t5)), n6.push(x2.construct(t5, r.vmax));
      }
    }
  }
}
function wi(t3) {
  const e5 = Ot(mi, 3);
  t3.queryControlPoints(e5);
  const s4 = Ai(e5);
  return s4 && (t3.m_cp.setCoordsPoint2D(e5[1]), t3.afterCompletedModification()), s4;
}
function Ai(t3) {
  let e5 = false;
  for (let s4 = 0; s4 < 2; s4++) {
    const n6 = fs(t3[0][s4], t3[2][s4]);
    n6 > 0 ? (fs(t3[0][s4], t3[1][s4]) < 0 && (t3[1][s4] = t3[0][s4], e5 = true), fs(t3[1][s4], t3[2][s4]) < 0 && (t3[1][s4] = t3[2][s4], e5 = true)) : n6 < 0 ? (fs(t3[0][s4], t3[1][s4]) > 0 && (t3[1][s4] = t3[0][s4], e5 = true), fs(t3[1][s4], t3[2][s4]) > 0 && (t3[1][s4] = t3[2][s4], e5 = true)) : t3[1][s4] !== t3[0][s4] && (t3[1][s4] = t3[0][s4], e5 = true);
  }
  return e5;
}
function Ti(t3, s4, n6) {
  void 0 === n6 && (n6 = s4, s4 = 0);
  const i2 = new mi();
  if (s4 < 0 || n6 > 1) return i2.setNAN(), i2;
  if (s4 > n6 && P("calculate_sub_weighted_centroid"), s4 === n6 || t3.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = oi2(t3), o = is(t3), a2 = Math.min(o / t3.calculateUpperLength2D(), 1e-7);
  let h2 = s4, u = 0;
  for (let e5 = 1, m3 = r.specialPointsCount(); e5 < m3; e5++) if (s4 < r.specialPoints[e5]) {
    u = e5 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let e5 = u + 1, m3 = r.specialPointsCount(); e5 < m3; e5++) {
    const s5 = Math.min(r.specialPoints[e5], n6), u2 = ni2(t3, h2, s5, a2, o);
    if (i2.addThis(u2), h2 = s5, n6 <= r.specialPoints[e5]) break;
  }
  return i2.add(t3.getStartXY().mul(t3.calculateLength2D()));
}
function Ii(t3, e5, s4, n6) {
  new mi().setCoordsPoint2D(t3[0]);
  new mi().setCoordsPoint2D(t3[1]);
  new mi().setCoordsPoint2D(t3[2]);
  const i2 = new mi(), r = new mi(), o = new mi();
  if (Y(t3[0], t3[1], e5, i2), Y(t3[1], t3[2], e5, r), Y(i2, r, e5, o), s4 && (s4[0].assign(t3[0]), s4[1].assign(i2), s4[2].assign(o)), n6) {
    const e6 = t3[2];
    n6[0].assign(o), n6[1].assign(r), n6[2].assign(e6);
  }
}
function Mi(t3, e5, s4, n6) {
  if (e5 === s4) {
    const s5 = new mi();
    return ji(t3, e5, s5), n6[0] = s5, n6[1] = s5, void (n6[2] = s5);
  }
  const i2 = Ot(mi, 3);
  Ii(t3, s4, i2, null), Ii(i2, e5 / s4, null, i2), ji(t3, e5, i2[0]), ji(t3, s4, i2[2]), n6[0].setCoordsPoint2D(i2[0]), n6[1].setCoordsPoint2D(i2[1]), n6[2].setCoordsPoint2D(i2[2]);
}
function Yi(t3, e5, s4, n6) {
  if (e5.isEqual(t3.m_XStart, t3.m_YStart) && s4.isEqual(t3.m_XEnd, t3.m_YEnd)) return;
  const i2 = !!n6 && t3.isMonotoneQuickAndDirty(), r = new x3(), o = Ot(mi, 3);
  o[0].setCoords(t3.m_XStart, t3.m_YStart), o[2].setCoords(t3.m_XEnd, t3.m_YEnd);
  const a2 = new mi();
  a2.setSub(o[2], o[0]), a2.leftPerpendicularThis(), o[1].setAdd(o[0], a2);
  const h2 = Ot(mi, 3);
  h2[0].setCoordsPoint2D(e5), h2[2].setCoordsPoint2D(s4), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o, h2) ? r.transformInPlace(t3.m_cp) : Y(e5, s4, 0.5, t3.m_cp), t3.changeEndPoints2D(e5, s4), i2 && wi(t3);
}
function Ni(t3) {
  return t3.getStartXY().norm(1) + t3.getEndXY().norm(1) + t3.m_cp.norm(1);
}
function Xi(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== Vi(t3, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function qi(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== Li(t3, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function Fi(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== Ri(t3, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function Vi(t3, e5, n6, i2, r, o, a2, h2, u, m3) {
  if (null != r && (r.length = 0), null !== o && (o.length = 0), null !== i2 && (i2.length = 0), n6.isDegenerate(0)) {
    const t4 = [0, 0], s4 = e5.intersectPoint(n6.getStartXY(), t4, a2);
    if (s4 > 0) {
      if (null !== r) for (let e6 = 0; e6 < s4; e6++) r.push(t4[e6]);
      if (null !== o) for (let t5 = 0; t5 < s4; t5++) o.push(0);
      if (null !== i2) for (let n7 = 0; n7 < s4; n7++) {
        const s5 = new mi();
        e5.queryCoord2D(t4[n7], s5), i2.push(s5);
      }
    }
    return s4;
  }
  const l2 = rs2(e5, n6);
  if (a2 = Math.max(a2, l2), e5.isDegenerateToLineHelper(l2)) {
    const t4 = new pm({ start: e5.getStartXY(), end: e5.getEndXY() }), s4 = Ds2(t4, n6, i2, r, o, a2, h2, m3);
    if (r) for (let n7 = 0; n7 < s4; ++n7) {
      const s5 = t4.getCoord2D(r[n7]);
      r[n7] = e5.getClosestCoordinate(s5, false);
    }
    return s4;
  }
  if (os(e5, n6, a2)) return 0;
  const c = Xe.constructPoint2D(n6.getStartXY()), g2 = Xe.constructPoint2D(n6.getEndXY()).sub(c), d2 = g2.clone();
  d2.leftPerpendicularThis();
  const _ = Xe.constructPoint2D(e5.m_cp).sub(Xe.constructPoint2D(e5.getStartXY())), p3 = Xe.constructPoint2D(e5.getEndXY()).sub(Xe.constructPoint2D(e5.m_cp));
  let f3 = _.dotProduct(d2).toDouble(), P5 = p3.sub(_).dotProduct(d2).toDouble();
  const y2 = Yt(12, Number.NaN), x4 = Yt(12, Number.NaN);
  let C3 = en(P5, f3, x2.unit(), y2);
  C3 < 0 && (y2[0] = 0, y2[1] = 1, C3 = 2);
  let v3, b2 = 0;
  for (let s4 = 0, w4 = b2; s4 < C3; ++s4) {
    const t4 = e5.getCoord2D(y2[s4 + w4]);
    x4[b2] = n6.getClosestCoordinate(t4, false), mi.distance(t4, n6.getCoord2D(x4[b2])) <= a2 && (y2[b2] = y2[s4 + w4], b2++);
  }
  const S3 = Ot(mi, 3);
  e5.queryControlPoints(S3);
  {
    const t4 = Ot(Xe, 3);
    if (Wi(S3, t4, false), t4[0] = t4[0].sub(c), g2.x.abs().gte(g2.y.abs())) {
      const e6 = g2.y.div(g2.x);
      P5 = t4[2].y.sub(t4[2].x.mul(e6)).toDouble(), f3 = t4[1].y.sub(t4[1].x.mul(e6)).toDouble(), v3 = t4[0].y.sub(t4[0].x.mul(e6)).toDouble();
    } else {
      const e6 = g2.x.div(g2.y);
      P5 = t4[2].x.sub(t4[2].y.mul(e6)).toDouble(), f3 = t4[1].x.sub(t4[1].y.mul(e6)).toDouble(), v3 = t4[0].x.sub(t4[0].y.mul(e6)).toDouble();
    }
  }
  const E2 = e5.getEndXY().equals(n6.getStartXY()) || e5.getEndXY().equals(n6.getEndXY()), D3 = [0, 0];
  C3 = sn(P5, f3, v3, x2.unit(), E2, D3);
  for (let s4 = 0, w4 = b2; s4 < C3; ++s4) {
    y2[s4 + w4] = D3[s4];
    const t4 = e5.getCoord2D(y2[s4 + w4]);
    x4[b2] = n6.getClosestCoordinate(t4, false), mi.distance(t4, n6.getCoord2D(x4[b2])) <= a2 && (y2[b2] = y2[s4 + w4], b2++);
  }
  n2(b2 < y2.length + 4), C3 = e5.intersectPoint(n6.getStartXY(), D3, a2);
  for (let s4 = 0; s4 < C3; s4++) y2[b2] = D3[s4], x4[b2++] = 0;
  C3 = e5.intersectPoint(n6.getEndXY(), D3, a2);
  for (let s4 = 0; s4 < C3; s4++) y2[b2] = D3[s4], x4[b2++] = 1;
  C3 = n6.intersectPoint(e5.getStartXY(), D3, a2);
  for (let s4 = 0; s4 < C3; s4++) x4[b2] = D3[s4], y2[b2++] = 0;
  C3 = n6.intersectPoint(e5.getEndXY(), D3, a2);
  for (let s4 = 0; s4 < C3; s4++) x4[b2] = D3[s4], y2[b2++] = 0;
  return 0 === b2 ? 0 : cm(t3, e5, n6, y2, x4, b2, i2, r, o, a2, h2, u, m3);
}
function Li(t3, e5, s4, n6, i2, r, o, a2, h2, u) {
  if (Su(s4)) {
    return Vi(t3, e5, new pm({ start: s4.getStartXY(), end: s4.getEndXY() }), n6, i2, r, o, a2, h2, u);
  }
  const m3 = rs2(e5, s4);
  if (os(e5, s4, o = Math.max(o, m3))) return 0;
  const l2 = [], c = [], g2 = Ot(mi, 3);
  {
    e5.queryControlPoints(g2);
    const t4 = Ot(mi, 3), n7 = new x3();
    s4.canonicToWorldTransformation(n7);
    const i3 = new x3();
    i3.setInvert(n7), i3.transformPoints2D(g2, 3, t4);
    const r2 = Ot(Xe, 3);
    Wi(t4, r2);
    const h3 = [r2[0].x, r2[1].x, r2[2].x], u2 = [r2[0].y, r2[1].y, r2[2].y], m4 = Ot(si, 3);
    m4[0].setDouble(s4.getSemiMinorAxis()), m4[0].sqrThis(), m4[1].setDouble(s4.getSemiMajorAxis()), m4[1].sqrThis(), m4[2] = m4[0], m4[2].mul(m4[1]), m4[2].negate();
    const d3 = qn(h3, 2, u2, 2, null, 0, m4, true, x2.unit(), x2.unit(), l2, a2);
    if (d3 > 0) {
      let t5 = 0;
      for (let n8 = 0; n8 < d3; n8++) {
        const i4 = new mi();
        e5.queryCoord2D(l2[n8], i4);
        const r3 = s4.getClosestCoordinate(i4, false), a3 = new mi();
        s4.queryCoord2D(r3, a3), mi.distance(i4, a3) <= o && (l2[t5] = l2[n8], c.push(r3), t5++);
      }
      l2.length = t5;
    }
  }
  const d2 = [0, 1];
  for (let _ = 0; _ < 2; _++) {
    const t4 = 0 === _ ? s4.getStartXY() : s4.getEndXY(), e6 = [0];
    vi(g2, t4, e6);
    const n7 = new mi();
    ji(g2, e6[0], n7), mi.distance(t4, n7) <= o && (l2.push(e6[0]), c.push(d2[_]));
  }
  for (let _ = 0; _ < 2; _++) {
    const t4 = [0, 2];
    {
      const e6 = s4.getClosestCoordinate(g2[t4[_]], false), n7 = new mi();
      s4.queryCoord2D(e6, n7), mi.distance(g2[t4[_]], n7) <= o && (l2.push(d2[_]), c.push(e6));
    }
  }
  return cm(t3, e5, s4, l2, c, l2.length, n6, i2, r, o, a2, h2, u);
}
function Ri(t3, e5, s4, n6, i2, r, o, a2, h2, u) {
  const m3 = Ot(mi, 3);
  e5.queryControlPoints(m3);
  const l2 = Ot(mi, 3);
  if (s4.queryControlPoints(l2), as(m3, l2, 3) < 0) return Ri(t3, s4, e5, n6, r, i2, o, a2, h2, !u);
  const c = rs2(e5, s4);
  if (os(e5, s4, o = Math.max(o, c))) return 0;
  if (er(e5, s4, n6, i2, r, o, a2, h2, u)) return 2;
  const g2 = new x2(0, 1), d2 = new x2(0, 1);
  {
    const t4 = new De();
    Ei(m3, x2.unit(), t4);
    const e6 = new De();
    Ei(l2, x2.unit(), e6);
    const s5 = Math.max(t4.maxDim(), e6.maxDim());
    if (t4.inflate(3 * o), e6.inflate(3 * o), !t4.intersectW(e6)) return 0;
    if (t4.maxDim() < 0.1 * s5) {
      if (Di(m3, t4, g2), Di(l2, t4, d2), g2.isEmpty() || d2.isEmpty()) return 0;
      Mi(m3, g2.vmin, g2.vmax, m3), Mi(l2, d2.vmin, d2.vmax, l2);
    }
  }
  const _ = dm(m3, 2, l2, 2, o);
  if (0 === _) return 0;
  const p3 = [], f3 = [];
  if (-1 === _) {
    const t4 = Ot(Xe, 3);
    Wi(m3, t4);
    const e6 = [t4[0].x, t4[1].x, t4[2].x], s5 = [t4[0].y, t4[1].y, t4[2].y], n7 = Ot(Xe, 3);
    Wi(l2, n7);
    const i3 = Yn(e6, 2, s5, 2, null, 0, [n7[0].x, n7[1].x, n7[2].x], 2, [n7[0].y, n7[1].y, n7[2].y], 2, null, 0, true, x2.unit(), x2.unit(), p3, f3, u, a2, u);
    if (i3 > 0) {
      let t5 = 0;
      for (let e7 = 0; e7 < i3; e7++) {
        const s6 = new mi(), n8 = new mi();
        ji(l2, f3[e7], n8), ji(m3, p3[e7], s6), mi.distance(s6, n8) <= o && (p3[t5] = p3[e7], f3[t5] = f3[e7], t5++);
      }
      p3.length = t5, f3.length = t5;
    }
  }
  for (let P5 = 0; P5 < 2; P5++) {
    const t4 = 0 === P5 ? m3 : l2, e6 = 0 === P5 ? l2 : m3;
    for (let s5 = 0; s5 < 2; s5++) {
      const n7 = 0 === s5 ? 0 : 2, i3 = [0];
      vi(e6, t4[n7], i3);
      const r2 = new mi();
      ji(e6, i3[0], r2), mi.distance(t4[n7], r2) <= o && (0 === P5 ? (p3.push(0 === n7 ? 0 : 1), f3.push(i3[0])) : (f3.push(0 === n7 ? 0 : 1), p3.push(i3[0])));
    }
  }
  if (0 === p3.length) return 0;
  if (!g2.equalsRange(0, 1)) for (let P5 = 0; P5 < p3.length; ++P5) p3[P5] = wn.recalculateParentT(g2.vmin, g2.vmax, p3[P5]);
  if (!d2.equalsRange(0, 1)) for (let P5 = 0; P5 < f3.length; ++P5) f3[P5] = wn.recalculateParentT(d2.vmin, d2.vmax, f3[P5]);
  return cm(t3, e5, s4, p3, f3, p3.length, n6, i2, r, o, a2, h2, u);
}
function zi(t3, e5, s4 = false) {
  const n6 = t3[1].sub(t3[0]);
  e5[1].assign(n6.mul(2)), e5[2].assign(t3[2].sub(t3[1]).sub(n6)), s4 ? e5[0].setCoords(0, 0) : e5[0].assign(t3[0]);
}
function Bi(t3, e5, s4 = false) {
  const n6 = Ot(mi, 3);
  t3.queryControlPoints(n6), zi(n6, e5, s4);
}
function ki(t3, e5, s4 = false) {
  const n6 = 0, i2 = new p2(t3[1][n6]).subE(new p2(t3[0][n6]));
  e5[1] = i2.mul(2), e5[2] = new p2(t3[2][n6]).subE(new p2(t3[1][n6])).subE(i2), s4 ? e5[0].set(0) : e5[0].set(t3[0][n6]);
}
function Gi(t3, e5, s4 = false) {
  const n6 = 1, i2 = new p2(t3[1][n6]).subE(new p2(t3[0][n6]));
  e5[1] = i2.mul(2), e5[2] = new p2(t3[2][n6]).subE(new p2(t3[1][n6])).subE(i2), s4 ? e5[0].set(0) : e5[0].set(t3[0][n6]);
}
function Wi(t3, e5, s4 = false) {
  const n6 = Xe.constructPoint2D(t3[1]), i2 = n6.sub(Xe.constructPoint2D(t3[0]));
  e5[1] = i2.mul(si.constructInt32(2)), e5[2] = Xe.constructPoint2D(t3[2]).sub(n6).sub(i2), e5[0] = s4 ? new Xe(ei, ei) : Xe.constructPoint2D(t3[0]);
}
function ji(t3, e5, s4, n6) {
  if (n6) {
    if (e5 < 0) {
      return void _s2(new pm({ start: t3[0], end: t3[0].add(li(t3, 0).getUnitVector()) }), e5, s4);
    }
    if (e5 > 1) {
      return void _s2(new pm({ start: t3[2], end: t3[2].add(li(t3, 1).getUnitVector()) }), e5 - 1, s4);
    }
  }
  if (e5 <= 0.5) {
    const n7 = t3[1].clone(), i2 = new mi();
    k2(2, t3[0], n7, e5, i2);
    const r = new mi();
    k2(2, n7, t3[2], e5, r);
    const o = new mi();
    k2(2, i2, r, e5, o), s4.assign(o);
  } else {
    const n7 = t3[1].clone(), i2 = new mi();
    F(2, t3[0], n7, e5, i2);
    const r = new mi();
    F(2, n7, t3[2], e5, r);
    const o = new mi();
    F(2, i2, r, e5, o), s4.assign(o);
  }
}
function Zi(t3, e5, s4) {
  const n6 = Ot(mi, 3);
  t3.queryControlPoints(n6), Hi(n6, e5, s4);
}
function Hi(t3, e5, s4) {
  if (e5.value() <= 0.5) {
    const n6 = Ye.constructPoint2D(t3[1]), i2 = new Ye();
    O(2, Ye.constructPoint2D(t3[0]), n6, e5, i2);
    const r = new Ye();
    O(2, n6, Ye.constructPoint2D(t3[2]), e5, r);
    const o = new Ye();
    O(2, i2, r, e5, o), s4.setE(o);
  } else {
    const n6 = Ye.constructPoint2D(t3[1]), i2 = new Ye();
    G2(2, Ye.constructPoint2D(t3[0]), n6, e5, i2);
    const r = new Ye();
    G2(2, n6, Ye.constructPoint2D(t3[2]), e5, r);
    const o = new Ye();
    G2(2, i2, r, e5, o), s4.setE(o);
  }
}
function Ui(t3, e5, s4) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6), Oi(n6, e5, s4);
}
function Oi(t3, e5, s4) {
  e5.value() < 0 && e5.set(0, e5.eps()), e5.value() > 1 && e5.set(1, e5.eps()), s4.setE(di(t3, 1, e5));
}
function Ki(t3, e5) {
  e5[0].assign(t3[0]), e5[3].assign(t3[2]), Y(t3[0], t3[1], 2 / 3, e5[1]), Y(t3[1], t3[2], 1 / 3, e5[2]);
}
function $i(t3, e5) {
  const s4 = Ot(mi, 3);
  t3.queryControlPoints(s4);
  const n6 = mi.sqrDistance(s4[1], s4[0]), i2 = mi.sqrDistance(s4[1], s4[2]);
  let r = s4[0].clone(), o = n6;
  n6 > i2 && (r = s4[2].clone(), o = i2);
  let a2 = false;
  return o <= e5 && 0 !== o && (a2 = true, t3.setControlPoint1(r)), a2;
}
function tr(t3, e5) {
  if (!e5) return false;
  const s4 = Ot(mi, 3);
  t3.queryControlPoints(s4);
  const n6 = mi.sqrDistance(s4[1], s4[0]), i2 = mi.sqrDistance(s4[1], s4[2]);
  s4[0].clone();
  let r = n6;
  return n6 > i2 && (s4[2].clone(), r = i2), r <= e5 && 0 !== r;
}
function er(t3, e5, s4, n6, i2, r, o, a2, h2) {
  const u = Ot(mi, 3);
  t3.queryControlPoints(u);
  const m3 = Ot(mi, 3);
  if (e5.queryControlPoints(m3), u[0].equals(m3[0])) {
    if (u[1].equals(m3[1]) && u[2].equals(m3[2])) return s4 && (s4.length = 0, s4.push(u[0]), s4.push(u[2])), n6 && (n6.length = 0, n6.push(0), n6.push(1)), i2 && (i2.length = 0, i2.push(0), i2.push(1)), true;
    if (!u[0].equals(m3[2])) return false;
  }
  return !!(u[0].equals(m3[2]) && u[1].equals(m3[1]) && u[2].equals(m3[0])) && (n6 && (n6.length = 0, n6.push(0), n6.push(1), h2 && (n6[1] = Pt(n6[0], n6[0] = n6[1]))), i2 && (i2.length = 0, i2.push(1), i2.push(0), h2 && (i2[1] = Pt(i2[0], i2[0] = i2[1]))), s4 && (s4.length = 0, s4.push(u[0]), s4.push(u[2]), h2 && (s4[1] = Pt(s4[0], s4[0] = s4[1]))), true);
}
var sr = [[0.33998104358485626, 0.6521451548625461], [0.8611363115940526, 0.34785484513745385]];
var nr = [[0.1834346424956498, 0.362683783378362], [0.525532409916329, 0.31370664587788727], [0.7966664774136267, 0.22238103445337448], [0.9602898564975363, 0.10122853629037626]];
var ir = [[0.09501250983763744, 0.1894506104550685], [0.2816035507792589, 0.18260341504492358], [0.45801677765722737, 0.16915651939500254], [0.6178762444026438, 0.14959598881657674], [0.755404408355003, 0.12462897125553388], [0.8656312023878318, 0.09515851168249279], [0.9445750230732326, 0.062253523938647894], [0.9894009349916499, 0.027152459411754096]];
var rr = [[0.04830766568773832, 0.0965400885147278], [0.1444719615827965, 0.09563872007927486], [0.23928736225213706, 0.09384439908080457], [0.33186860228212767, 0.09117387869576389], [0.42135127613063533, 0.08765209300440381], [0.5068999089322294, 0.08331192422694675], [0.5877157572407623, 0.07819389578707031], [0.6630442669302152, 0.0723457941088485], [0.7321821187402897, 0.06582222277636185], [0.7944837959679424, 0.058684093478535544], [0.84936761373257, 0.050998059262376175], [0.8963211557660521, 0.04283589802222668], [0.9349060759377397, 0.03427386291302143], [0.9647622555875064, 0.02539206530926206], [0.9856115115452684, 0.01627439473090567], [0.9972638618494816, 0.007018610009470096]];
var or = [[0.024350292663424433, 0.048690957009139724], [0.07299312178779904, 0.04857546744150343], [0.12146281929612056, 0.048344762234802954], [0.16964442042399283, 0.04799938859645831], [0.21742364374000708, 0.04754016571483031], [0.2646871622087674, 0.04696818281621002], [0.31132287199021097, 0.046284796581314416], [0.3572201583376681, 0.04549162792741814], [0.4022701579639916, 0.044590558163756566], [0.4463660172534641, 0.04358372452932345], [0.48940314570705296, 0.04247351512365359], [0.5312794640198946, 0.04126256324262353], [0.571895646202634, 0.03995374113272034], [0.6111553551723933, 0.038550153178615626], [0.6489654712546573, 0.03705512854024005], [0.6852363130542333, 0.035472213256882386], [0.7198818501716109, 0.033805161837141606], [0.7528199072605319, 0.03205792835485155], [0.7839723589433414, 0.030234657072402478], [0.8132653151227975, 0.028339672614259483], [0.8406292962525803, 0.02637746971505466], [0.8659993981540928, 0.024352702568710874], [0.8893154459951141, 0.022270173808383253], [0.9105221370785028, 0.02013482315353021], [0.9295691721319396, 0.017951715775697343], [0.9464113748584028, 0.015726030476024718], [0.9610087996520538, 0.013463047896718643], [0.973326827789911, 0.011168139460131128], [0.983336253884626, 0.008846759826363947], [0.9910133714767443, 0.006504457968978363], [0.9963401167719553, 0.004147033260562468], [0.9993050417357722, 0.001783280721696433]];
var ar = [[0.012223698960615764, 0.024446180196262518], [0.03666379096873349, 0.024431569097850044], [0.06108196960413957, 0.02440235563384958], [0.08546364050451549, 0.024358557264690626], [0.10979423112764375, 0.024300200167971867], [0.13405919946118777, 0.02422731922281525], [0.15824404271422493, 0.024139957989019287], [0.18233430598533718, 0.024038168681024052], [0.2063155909020792, 0.023922012136703457], [0.23017356422666, 0.023791557781003402], [0.2538939664226943, 0.023646883584447616], [0.2774626201779044, 0.02348807601653591], [0.3008654388776772, 0.02331522999406276], [0.32408843502441337, 0.023128448824387027], [0.3471177285976355, 0.022927844143686846], [0.369939555349859, 0.02271353585023646], [0.39254027503326744, 0.022485652032744968], [0.414906379552275, 0.022244328893799764], [0.43702450103710416, 0.02198971066846049], [0.4588814198335522, 0.021721949538052076], [0.48046407240417205, 0.02144120553920846], [0.5017595591361445, 0.02114764646822135], [0.5227551520511755, 0.02084144778075115], [0.5434383024128103, 0.02052279248696007], [0.5637966482266181, 0.020191871042130043], [0.5838180216287631, 0.01984888123283086], [0.6034904561585486, 0.019494028058706602], [0.6228021939105849, 0.019127523609950944], [0.6417416925623075, 0.01874958694054471], [0.660297632272646, 0.01836044393733134], [0.6784589224477192, 0.017960327185008687], [0.6962147083695144, 0.017549475827117706], [0.7135543776835874, 0.01712813542311138], [0.7304675667419088, 0.016696557801589205], [0.746944166797062, 0.016255000909785187], [0.7629743300440948, 0.015803728659399347], [0.7785484755064119, 0.015343010768865144], [0.7936572947621933, 0.014873122602147314], [0.8082917575079137, 0.014394345004166847], [0.8224431169556439, 0.013906964132951985], [0.8361029150609068, 0.013411271288616333], [0.8492629875779689, 0.012907562739267348], [0.8619154689395485, 0.012396139543950923], [0.8740527969580318, 0.01187730737274028], [0.8856677173453972, 0.011351376324080417], [0.8967532880491582, 0.010818660739503076], [0.9073028834017568, 0.010279479015832158], [0.9173101980809605, 0.009734153415006806], [0.9267692508789478, 0.009183009871660874], [0.9356743882779164, 0.00862637779861675], [0.9440202878302202, 0.008064589890486059], [0.9518019613412644, 0.0074979819256347285], [0.9590147578536999, 0.006926892566898814], [0.9656543664319652, 0.006351663161707189], [0.9717168187471366, 0.005772637542865698], [0.9771984914639074, 0.00519016183267633], [0.9820961084357185, 0.004604584256702955], [0.9864067427245862, 0.004016254983738642], [0.9901278184917344, 0.0034255260409102157], [0.9932571129002129, 0.0028327514714579912], [0.9957927585349812, 0.0022382884309626186], [0.997733248625514, 0.0016425030186690294], [0.9990774599773758, 0.0010458126793403489], [0.9998248879471319, 44938096029209035e-20]];
function hr(t3, e5, s4, n6) {
  const i2 = 0.5 * (n6 - s4), r = s4 + i2, o = new n3(0);
  for (let a2 = 0, h2 = Math.trunc(t3 / 2); a2 < h2; ++a2) {
    let s5, n7;
    switch (t3) {
      case 4:
        s5 = sr[a2][0], n7 = sr[a2][1];
        break;
      case 8:
        s5 = nr[a2][0], n7 = nr[a2][1];
        break;
      case 16:
        s5 = ir[a2][0], n7 = ir[a2][1];
        break;
      case 32:
        s5 = rr[a2][0], n7 = rr[a2][1];
        break;
      case 64:
        s5 = or[a2][0], n7 = or[a2][1];
        break;
      case 128:
        s5 = ar[a2][0], n7 = ar[a2][1];
        break;
      default:
        throw new Error("Quadrature_integral: invalid n");
    }
    const h3 = st(-0.5, s5, r), u = st(i2, s5, r);
    o.pe(e5(h3) * n7), o.pe(e5(u) * n7);
  }
  return o.getResult() * i2;
}
var ur = class _ur extends Hs2 {
  constructor(t3) {
    t3 ? t3.vd ? (super({ vd: t3.vd, bPolygon: true }), this.m_segmentBufferCTor = fm) : t3.copy ? (super({ vd: t3.copy.getDescription(), bPolygon: true }), this.m_segmentBufferCTor = fm, t3.copy.copyTo(this)) : t3.move ? (super({ move: t3.move }), this.m_segmentBufferCTor = fm) : t3.envelope ? z("envelope constructor not impl") : b("bad arg to polygon constructor") : (super({ bPolygon: true }), this.m_segmentBufferCTor = fm);
  }
  assignMove(t3) {
    return t3.copyTo(this), this;
  }
  assignCopy(t3) {
    return t3.copyTo(this), this;
  }
  getBoundary() {
    return Ks(this);
  }
  getExteriorRingCount() {
    return this.getOGCPolygonCount();
  }
  getGeometryType() {
    return _ur.type;
  }
  getDimension() {
    return 2;
  }
  createInstance() {
    return new _ur({ vd: this.getDescription() });
  }
  equals(t3, e5) {
    return this.equalsBase(t3, e5);
  }
};
function mr(t3, s4) {
  let n6, r = s4, o = null;
  switch (r || (o = g(t3) ? O2() : M(), r = o), t3) {
    case a.enumPoint:
      n6 = new ee({ vd: r });
      break;
    case a.enumLine:
      n6 = new pm({ vd: r });
      break;
    case a.enumBezier:
      n6 = new ia({ vd: r });
      break;
    case a.enumEllipticArc:
      n6 = new Xh({ vd: r });
      break;
    case a.enumRationalBezier2:
      n6 = new En({ vd: r });
      break;
    case a.enumBezier2:
      n6 = new wn({ vd: r });
      break;
    case a.enumEnvelope:
      n6 = new re({ vd: r });
      break;
    case a.enumMultiPoint:
      n6 = new Ee({ vd: r });
      break;
    case a.enumPolyline:
      n6 = new Os2({ vd: r });
      break;
    case a.enumPolygon:
      n6 = new ur({ vd: r });
      break;
    case a.enumMultipatch:
      z("multipatch not impl");
      break;
    case a.enumGeometryCollection:
      n6 = new ls2({ vd: r });
      break;
    default:
      P("Geometry.create");
  }
  return n6;
}
ur.type = a.enumPolygon;
var lr = z3;
var cr = -1;
var gr = 1;
var dr = class {
  constructor(t3) {
    this.m_shape = t3;
  }
  userSort(t3, e5, s4) {
    this.m_shape.sortVerticesSimpleByYHelper(s4, t3, e5);
  }
  getValue(t3) {
    return this.m_shape.getY(t3);
  }
};
function _r(t3) {
  return void 0 !== t3.parent;
}
var pr = class _pr {
  constructor(t3) {
    _r(t3) ? (this.m_parent = t3.parent, this.m_geometry = t3.geometry, this.m_path = t3.path, this.m_vertex = t3.vertex, this.m_firstVertex = t3.firstVertex, this.m_index = t3.selection ? 0 : t3.index, this.m_bSkipMultiPoints = t3.bSkipMultiPoints, this.m_selection = t3.selection, this.m_bOneGeom = t3.bOneGeom, this.m_bFirst = true) : (this.m_parent = t3.copy.m_parent, this.m_geometry = t3.copy.m_geometry, this.m_path = t3.copy.m_path, this.m_vertex = t3.copy.m_vertex, this.m_index = t3.copy.m_index, this.m_bSkipMultiPoints = t3.copy.m_bSkipMultiPoints, this.m_firstVertex = t3.copy.m_firstVertex, this.m_bFirst = true, this.m_selection = t3.copy.m_selection, this.m_bOneGeom = t3.copy.m_bOneGeom);
  }
  moveToNextHelper() {
    for (this.m_path = this.m_parent.getNextPath(this.m_path), this.m_index = 0; this.m_geometry !== cr; ) {
      for (; this.m_path !== cr; this.m_path = this.m_parent.getNextPath(this.m_path)) if (this.m_vertex = this.m_parent.getFirstVertex(this.m_path), this.m_firstVertex = this.m_vertex, this.m_vertex !== cr) return this.m_vertex;
      if (this.m_bOneGeom) return cr;
      if (this.m_geometry = this.m_parent.getNextGeometry(this.m_geometry), this.m_geometry === cr) break;
      this.m_bSkipMultiPoints && !h(this.m_parent.getGeometryType(this.m_geometry)) || (this.m_path = this.m_parent.getFirstPath(this.m_geometry));
    }
    return cr;
  }
  nextSelection() {
    for (; this.m_index < this.m_parent.m_selectedVertices.length; ) {
      const t3 = this.m_parent.m_selectedVertices[this.m_index++];
      if (t3 !== cr && (this.m_path = this.m_parent.getPathFromVertex(t3), !this.m_bOneGeom || this.m_geometry === this.m_parent.getGeometryFromPath(this.m_path))) return this.m_geometry = this.m_parent.getGeometryFromPath(this.m_path), t3;
    }
    return cr;
  }
  next() {
    return this.m_selection ? this.nextSelection() : this.m_bFirst ? (this.m_bFirst = false, this.m_vertex) : this.m_vertex !== cr ? (this.m_vertex = this.m_parent.getNextVertex(this.m_vertex), this.m_index++, this.m_vertex !== cr && this.m_vertex !== this.m_firstVertex ? this.m_vertex : this.moveToNextHelper()) : cr;
  }
  currentGeometry() {
    return this.m_geometry;
  }
  currentPath() {
    return this.m_path;
  }
  static create_(t3, e5, s4, n6, i2, r, o, a2, h2) {
    return new _pr({ parent: t3, geometry: e5, path: s4, vertex: n6, firstVertex: i2, index: r, bSkipMultiPoints: o, selection: a2, bOneGeom: h2 });
  }
};
var fr = class {
  constructor(t3) {
    this.parentage = t3;
  }
  equals(t3) {
    return this.parentage === t3.parentage;
  }
};
var Pr = class _Pr {
  setPrevPath(t3, e5) {
    this.m_pathIndexList.setField(t3, 1, e5);
  }
  setNextPath(t3, e5) {
    this.m_pathIndexList.setField(t3, 2, e5);
  }
  setPathFlags(t3, e5) {
    this.m_pathIndexList.setField(t3, 6, e5);
  }
  getPathFlags(t3) {
    return this.m_pathIndexList.getField(t3, 6);
  }
  setPathGeometry(t3, e5) {
    this.m_pathIndexList.setField(t3, 7, e5);
  }
  getPathIndex(t3) {
    return this.m_pathIndexList.getField(t3, 0);
  }
  setNextGeometry(t3, e5) {
    this.m_geometryIndexList.setField(t3, 1, e5);
  }
  setPrevGeometry(t3, e5) {
    this.m_geometryIndexList.setField(t3, 0, e5);
  }
  getGeometryIndex(t3) {
    return this.m_geometryIndexList.getField(t3, 7);
  }
  setFirstPath(t3, e5) {
    this.m_geometryIndexList.setField(t3, 3, e5);
  }
  setLastPath(t3, e5) {
    this.m_geometryIndexList.setField(t3, 4, e5);
  }
  newGeometry(t3) {
    const e5 = this.m_geometryIndexList.newElement();
    return this.m_geometryIndexList.setField(e5, 2, t3), this.m_geometryIndexList.setField(e5, 5, 0), this.m_geometryIndexList.setField(e5, 6, 0), this.m_geometryIndexList.setField(e5, 7, this.m_geometryIndexList.elementToIndex(e5)), e5;
  }
  freeGeometry(t3) {
    this.m_geometryIndexList.deleteElement(t3);
  }
  newPath(t3) {
    const e5 = this.m_pathIndexList.newElement(), s4 = this.m_pathIndexList.elementToIndex(e5);
    if (this.m_pathIndexList.setField(e5, 0, s4), this.m_pathIndexList.setField(e5, 3, 0), this.m_pathIndexList.setField(e5, 6, 0), this.setPathGeometry(e5, t3), s4 >= this.m_pathAreas.length) {
      const t4 = Math.trunc(s4 < 16 ? 16 : 3 * s4 / 2);
      this.m_pathAreas.length = t4, this.m_pathLengths.length = t4;
    }
    return this.m_pathAreas[s4] = 0, this.m_pathLengths[s4] = 0, this.m_pathCount++, e5;
  }
  freePath(t3) {
    this.m_pathIndexList.deleteElement(t3), this.m_pathCount--;
  }
  newVertex(t3) {
    const e5 = this.m_vertexIndexList.newElement(), s4 = t3 >= 0 ? t3 : this.m_vertexIndexList.elementToIndex(e5);
    if (this.m_vertexIndexList.setField(e5, 0, s4), t3 < 0) {
      if (s4 >= this.m_vertices.getPointCount()) {
        const t4 = Math.trunc(s4 < 16 ? 16 : 3 * s4 / 2);
        this.m_vertices.reserveRounded(t4), this.m_vertices.resizeNoInit(t4), null !== this.m_segments && (this.m_segments.length = t4), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
      }
      this.m_segments && (this.m_segments[s4] = null);
    }
    return this.m_pointCount++, e5;
  }
  freeVertex(t3) {
    this.unselect(t3);
    const e5 = this.getVertexIndex(t3);
    this.m_vertexIndexList.deleteElement(t3), this.m_pointCount--;
    for (let s4 = 0, n6 = this.m_indices.length; s4 < n6; s4++) {
      if (s4 === this.m_selectionIndex) continue;
      const t4 = this.m_indices[s4];
      null !== t4 && t4.size() > e5 && t4.write(e5, -1);
    }
    this.m_weights && this.m_weights.size() > e5 && this.m_weights.write(e5, 1), this.m_ranks && this.m_ranks.size() > e5 && this.m_ranks.write(e5, gr), this.m_segmentWeights && this.m_segmentWeights.size() > e5 && this.m_segmentWeights.write(e5, 1), this.m_segmentRanks && this.m_segmentRanks.size() > e5 && this.m_segmentRanks.write(e5, gr), this.m_segments && this.setSegmentToIndex(e5, null);
  }
  insertVertex_(t3, e5, s4, n6) {
    this.m_hasForceSetEnvelope = 0;
    const i2 = e5 !== cr ? this.getPrevVertex(e5) : this.getLastVertex(t3), r = i2 !== cr ? this.getNextVertex(i2) : cr, o = this.newVertex(null === s4 ? this.m_pointCount : -1), a2 = this.getVertexIndex(o);
    null !== s4 && this.m_vertices.setPointByValNoCurves(a2, s4), this.setPathToVertex(o, t3), this.setNextVertex(o, r), this.setPrevVertex(o, i2), r !== cr && this.setPrevVertex(r, o), i2 !== cr && this.setNextVertex(i2, o);
    const h2 = this.isClosedPath(t3), u = this.getFirstVertex(t3);
    e5 === cr && this.setLastVertex(t3, o), e5 === u && (h2 && n6 && u !== cr || this.setFirstVertex(t3, o)), h2 && r === cr && (this.setNextVertex(o, o), this.setPrevVertex(o, o)), this.setPathSize(t3, this.getPathSize(t3) + 1);
    const m3 = this.getGeometryFromPath(t3);
    return this.setGeometryVertexCount(m3, this.getPointCount(m3) + 1), o;
  }
  getHelperPoint() {
    return this.m_helperPoint || (this.m_helperPoint = new ee({ vd: this.m_vertices.getDescription() }), this.m_helperPoint.setXYCoords(0, 0)), this.m_helperPoint;
  }
  addMultiPoint(t3, e5) {
    const s4 = this.createGeometry(t3.getGeometryType(), t3.getDescription());
    return this.appendMultiPoint(s4, t3, e5), s4;
  }
  addPoint_(t3, e5) {
    const s4 = this.createGeometry(a.enumMultiPoint, t3.getDescription());
    return this.appendPoint(s4, t3, e5), s4;
  }
  appendMultiPath_(t3, e5) {
    if (e5.isEmpty()) return;
    const s4 = e5.getImpl();
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + s4.getPointCount()), this.m_verticesMp.addPoints(e5, 0, s4.getPointCount()), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
    const n6 = null !== this.m_segments || null !== s4.getSegmentFlagsStreamRef();
    this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + s4.getPointCount()), this.m_pathIndexList.setCapacity(this.m_pathIndexList.size() + s4.getPathCount());
    for (let i2 = 0, r = s4.getPathCount(); i2 < r; i2++) {
      if (0 === s4.getPathSize(i2)) continue;
      const e6 = this.insertPath(t3, cr);
      this.setClosedPath(e6, s4.isClosedPath(i2));
      for (let t4 = s4.getPathStart(i2), r2 = s4.getPathEnd(i2); t4 < r2; t4++) {
        const i3 = this.insertVertex_(e6, cr, null, false);
        if (n6) {
          const e7 = this.getVertexIndex(i3);
          if (1 & s4.getSegmentFlags(t4)) this.setSegmentToIndex(e7, null);
          else {
            const n7 = new fm();
            s4.querySegment(t4, n7, true), this.setSegmentToIndex(e7, n7.releaseSegment());
          }
        }
      }
      s4.isStrongPathStart(i2) && this.setStrongPathStart(e6, true), s4.isStrongPathEnd(i2) && this.setStrongPathEnd(e6, true);
    }
  }
  addMultiPath(t3, e5) {
    const s4 = this.createGeometry(t3.getGeometryType(), t3.getDescription());
    return t3.getGeometryType() === a.enumPolygon && this.setFillRule(s4, t3.getFillRule()), this.appendMultiPath(s4, t3, e5), s4;
  }
  appendMultiPathPolyline(t3, e5, s4) {
    const n6 = e5.getImpl(), i2 = null !== this.m_segments || null !== n6.getSegmentFlagsStreamRef(), r = new n4();
    e5.queryEnvelope(r);
    {
      const r2 = s4.clone();
      let o = n6.getPointCount();
      const a2 = n6.getAccelerators();
      if (a2 && a2.getQuadTree()) {
        o = a2.getQuadTree().getIntersectionCount(r2, 0, n6.getPointCount() + 1);
      }
      if (o < e5.getPointCount()) {
        if (0 === o) return;
        const s5 = n6.queryLimitedSegmentIterator(r2);
        let a3 = -1, h2 = -100, u = -1, m3 = 0, l2 = -1, c = cr, g2 = false, d2 = s5.nextSegment();
        if (null !== d2) for (; ; d2 = s5.nextSegment()) {
          let r3 = null === d2;
          const o2 = null !== d2 ? s5.getPathIndex() : a3, _ = null !== d2 ? s5.getStartPointIndex() : h2;
          if (r3 || (a3 === o2 && h2 + 1 === _ ? m3++ : r3 = true), r3) {
            if (-1 !== l2) {
              let t4 = -1, s6 = -1;
              if (m3 === u) {
                this.setClosedPath(c, g2);
                const i3 = n6.getPathEnd(a3);
                this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + i3 - l2), this.m_verticesMp.addPoints(e5, l2, i3), s6 = n6.getPathSize(a3), t4 = i3 - 1;
              } else if (!g2 || h2 + 1 < n6.getPathEnd(a3)) this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h2 + 2 - l2), this.m_verticesMp.addPoints(e5, l2, h2 + 2), s6 = h2 - l2 + 2, t4 = h2;
              else {
                this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h2 + 2 - l2), this.m_verticesMp?.addPoints(e5, l2, h2 + 1), t4 = h2, s6 = h2 - l2 + 1;
                const i3 = n6.getPathStart(a3);
                this.m_verticesMp.addPoints(e5, i3, i3 + 1), s6 += 1;
              }
              this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
              for (let e6 = 0, r4 = l2; e6 < s6; e6++, r4++) {
                const e7 = this.insertVertex_(c, cr, null, false);
                if (i2) {
                  const s7 = this.getVertexIndex(e7);
                  if (1 & n6.getSegmentFlags(r4) || r4 > t4) this.setSegmentToIndex(s7, null);
                  else {
                    const t5 = new fm();
                    n6.getSegmentBuffer(r4, t5, true), this.setSegmentToIndex(s7, t5.releaseSegment());
                  }
                }
              }
            }
            if (null === d2) break;
            m3 = 1, l2 = _, a3 !== o2 ? (c = this.insertPath(t3, cr), this.setClosedPath(c, false), u = n6.getSegmentCountPath(o2), g2 = n6.isClosedPath(o2), a3 = o2) : c = this.insertPath(t3, cr);
          }
          h2 = _;
        }
        return;
      }
    }
    this.appendMultiPath_(t3, e5);
  }
  appendMultiPathPolygon(t3, e5, n6) {
    const i2 = e5.getImpl(), r = null !== this.m_segments || null !== i2.getSegmentFlagsStreamRef(), o = n4.constructEmpty();
    e5.queryEnvelope(o), n2(n6.isIntersecting(o) && !n6.containsEnvelope(o));
    let a2 = n4.construct(Number.NEGATIVE_INFINITY, n6.ymin, Number.POSITIVE_INFINITY, n6.ymax), h2 = n4.construct(n6.xmin, Number.NEGATIVE_INFINITY, n6.xmax, Number.POSITIVE_INFINITY);
    const u = i2.getAccelerators();
    if (u && u.getQuadTree()) {
      const t4 = u.getQuadTree(), e6 = t4.getIntersectionCount(a2, 0, 0);
      e6 > t4.getIntersectionCount(h2, 0, e6 + 1) && (h2 = Pt(a2, a2 = h2));
    } else a2.height() > h2.width() && (h2 = Pt(a2, a2 = h2));
    const m3 = [], l2 = i2.queryLimitedSegmentIterator(a2);
    let c = -1, g2 = -100, d2 = -1, _ = 0, p3 = -1, f3 = -1, P5 = cr, y2 = true, x4 = l2.nextSegment();
    if (null !== x4) for (; ; x4 = l2.nextSegment()) {
      let n7 = null === x4;
      const o2 = null !== x4 ? l2.getPathIndex() : c, a3 = null !== x4 ? l2.getStartPointIndex() : g2;
      if (n7 || (o2 === c ? g2 + 1 === a3 ? _++ : n7 = true : (n7 = c >= 0, c < 0 && (c = o2, d2 = i2.getSegmentCountPath(c), p3 = a3, P5 = cr, _ = 1))), n7) {
        if (!(0 === m3.length && d2 === _)) {
          0 !== m3.length && m3[0].first === p3 || (this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.addPoints(e5, p3, p3 + 1), -1 === f3 && (f3 = p3), P5 === cr && (P5 = this.insertPath(t3, cr), this.setClosedPath(P5, true)), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.insertVertex_(P5, cr, null, false));
          for (const { first: n8, second: o3 } of m3) {
            -1 === f3 && (f3 = n8);
            let a4 = -1, h3 = -1;
            const u2 = n8 + o3 - 1;
            if (o3 === d2) {
              const t4 = u2 + 1;
              h3 = t4 - n8, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h3), this.m_verticesMp.addPoints(e5, n8, t4), a4 = u2, n2(1 === m3.length);
            } else if (u2 + 1 < i2.getPathEnd(c)) {
              const t4 = u2 + 2;
              h3 = t4 - n8, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h3), this.m_verticesMp.addPoints(e5, n8, t4), a4 = u2;
            } else {
              const t4 = i2.getPathStart(c), s4 = t4 !== f3 ? 1 : 0, r2 = u2 + 1;
              h3 = r2 - n8 + s4, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + (r2 - n8) + s4), this.m_verticesMp.addPoints(e5, n8, r2), a4 = u2, s4 > 0 && this.m_verticesMp?.addPoints(e5, t4, t4 + 1);
            }
            this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), P5 === cr && (P5 = this.insertPath(t3, cr), this.setClosedPath(P5, true));
            for (let t4 = 0, e6 = n8; t4 < h3; t4++, e6++) {
              const t5 = this.insertVertex_(P5, cr, null, false);
              if (r) {
                const s4 = this.getVertexIndex(t5);
                if (1 & i2.getSegmentFlags(e6) || e6 > a4) this.setSegmentToIndex(s4, null);
                else {
                  const t6 = new fm();
                  i2.getSegmentBuffer(e6, t6, true), this.setSegmentToIndex(s4, t6.releaseSegment());
                }
              }
            }
          }
          if (0 === m3.length || m3.at(-1).first + m3.at(-1).second !== p3 + _) {
            let t4 = p3 + _;
            t4 === e5.getPathEnd(c) && (t4 = e5.getPathStart(c)), f3 !== t4 && (this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.addPoints(e5, t4, t4 + 1), this.insertVertex_(P5, cr, null, false));
          }
        }
        m3.length = 0, y2 = true, o2 !== c && (c = o2, d2 = i2.getSegmentCountPath(c), P5 = cr, f3 = -1), p3 = a3, _ = 1;
      }
      if (!x4) break;
      {
        const t4 = n4.constructEmpty();
        x4.queryLooseEnvelope(t4), h2.isIntersecting(t4) ? (y2 ? m3.push($t(a3, 1)) : m3.at(-1).second++, y2 = false) : y2 = true;
      }
      g2 = a3;
    }
  }
  appendMultiPath(t3, e5, s4) {
    if (void 0 === s4) return void this.appendMultiPath_(t3, e5);
    if (e5.isEmpty()) return;
    const n6 = e5.getGeometryType() === a.enumPolygon, r = n4.constructEmpty();
    e5.queryEnvelope(r), s4.isIntersecting(r) && (!s4.containsEnvelope(r) && e5.getPointCount() > 10 ? n6 ? this.appendMultiPathPolygon(t3, e5, s4) : this.appendMultiPathPolyline(t3, e5, s4) : this.appendMultiPath_(t3, e5));
  }
  appendPoint(t3, e5, s4) {
    if (e5.isEmpty()) return;
    if (void 0 !== s4 && !s4.contains(e5.getXY())) return;
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.add(e5), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + 1);
    const n6 = this.insertPath(t3, cr);
    this.insertVertex_(n6, cr, null, false);
  }
  appendMultiPoint_(t3, e5) {
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + e5.getPointCount()), this.m_verticesMp.addPoints(e5, 0, e5.getPointCount()), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + e5.getPointCount());
    const s4 = this.insertPath(t3, cr);
    for (let n6 = 0, i2 = e5.getPointCount(); n6 < i2; n6++) this.insertVertex_(s4, cr, null, false);
  }
  appendMultiPoint(t3, e5, s4) {
    if (void 0 === s4) return void this.appendMultiPoint_(t3, e5);
    const n6 = e5.getAttributeStreamRef(0);
    let i2 = 0;
    for (let u = 0, m3 = e5.getPointCount(); u < m3; u++) {
      const t4 = n6.readPoint2D(2 * u);
      s4.contains(t4) && i2++;
    }
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + i2);
    let r = -1, o = -1, a2 = 0;
    for (let u = 0, m3 = e5.getPointCount(); u < m3; u++) {
      const t4 = n6.readPoint2D(2 * u);
      s4.contains(t4) ? (-1 === r && (r = u, o = u), o++) : r >= 0 && (this.m_verticesMp.addPoints(e5, r, o - r), r = -1, a2++);
    }
    if (r > 0 && (this.m_verticesMp.addPoints(e5, r, o - r), a2++), !a2) return;
    this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + i2);
    const h2 = this.insertPath(t3, cr);
    for (let u = 0, m3 = e5.getPointCount(); u < m3; u++) {
      const t4 = n6.readPoint2D(2 * u);
      s4.contains(t4) && this.insertVertex_(h2, cr, null, false);
    }
  }
  splitSegmentForward(t3, s4, n6, r, o) {
    const a2 = this.getNextVertex(t3);
    a2 === cr && P("Edit_shape.split_segment_forward_");
    const h2 = this.getHelperPoint(), u = this.getPathFromVertex(t3);
    let m3 = t3;
    const l2 = this.hasSegmentParentage();
    for (let e5 = 0, c = s4.getResultSegmentCount(n6); e5 < c; e5++) {
      const t4 = this.getVertexIndex(m3), r2 = this.getNextVertex(m3), g2 = s4.getResultSegment(n6, e5);
      let d2 = null;
      if (g2.getGeometryType() !== a.enumLine && (d2 = g2.clone(), d2.dropAllAttributes()), 0 === e5 && (g2.queryStart(h2), this.setSegmentToIndex(t4, null), this.setPointEx(m3, h2, s4.getResultSegmentStartPointRank(n6, e5), s4.getResultSegmentStartPointWeight(n6, e5), o)), this.setSegmentRank(m3, s4.getResultSegmentInteriorRank(n6, e5)), this.setSegmentWeight(m3, s4.getResultSegmentInteriorWeight(n6, e5)), l2) {
        const t5 = s4.getResultSegmentSegmentParentage(n6, e5), i2 = s4.getResultSegmentStartPointIsBreak(n6, e5);
        this.setSegmentParentageAndBreak(m3, t5, i2);
      }
      if (g2.queryEnd(h2), e5 < c - 1) {
        this.setSegmentToIndex(t4, d2);
        const i2 = this.insertVertex(u, r2, h2);
        this.setWeight(i2, s4.getResultSegmentEndPointWeight(n6, e5)), this.setRank(i2, s4.getResultSegmentEndPointRank(n6, e5)), this.select(i2), m3 = i2;
      } else {
        this.setPointEx(a2, h2, s4.getResultSegmentEndPointRank(n6, e5), s4.getResultSegmentEndPointWeight(n6, e5), o);
        const i2 = s4.getResultSegmentEndPointIsBreak(n6, e5);
        this.setSegmentParentageBreakVertex(a2, i2), this.setSegmentToIndex(t4, d2);
      }
    }
  }
  splitSegmentBackward(t3, s4, n6, r, o) {
    const a2 = this.getNextVertex(t3);
    a2 === cr && P("Edit_shape.split_segment_backward_");
    const h2 = this.getHelperPoint(), u = this.getPathFromVertex(t3);
    let m3 = t3;
    const l2 = this.hasSegmentParentage();
    for (let e5 = 0, c = s4.getResultSegmentCount(n6); e5 < c; e5++) {
      const t4 = c - e5 - 1, r2 = this.getVertexIndex(m3), g2 = this.getNextVertex(m3), d2 = s4.getResultSegment(n6, t4);
      let _ = null;
      if (d2.getGeometryType() !== a.enumLine && (_ = d2.clone(), _.reverse(), _.dropAllAttributes()), 0 === e5 && (d2.queryEnd(h2), this.setSegmentToIndex(r2, null), this.setPointEx(m3, h2, s4.getResultSegmentEndPointRank(n6, t4), s4.getResultSegmentEndPointWeight(n6, t4), o), this.setSegmentParentageAndBreak(m3, s4.getResultSegmentSegmentParentage(n6, t4), s4.getResultSegmentEndPointIsBreak(n6, t4))), d2.getGeometryType() === a.enumLine ? this.setSegmentToIndex(r2, null) : this.setSegmentToIndex(r2, _), this.setSegmentRank(m3, s4.getResultSegmentInteriorRank(n6, t4)), this.setSegmentWeight(m3, s4.getResultSegmentInteriorWeight(n6, t4)), d2.queryStart(h2), e5 < c - 1) {
        const e6 = this.insertVertex(u, g2, h2);
        this.setWeight(e6, s4.getResultSegmentStartPointWeight(n6, t4)), this.setRank(e6, s4.getResultSegmentStartPointRank(n6, t4)), this.select(e6), m3 = e6, l2 && this.setSegmentParentageAndBreak(e6, s4.getResultSegmentSegmentParentage(n6, t4), s4.getResultSegmentEndPointIsBreak(n6, t4));
      } else this.setPointEx(a2, h2, s4.getResultSegmentStartPointRank(n6, t4), s4.getResultSegmentStartPointWeight(n6, t4), o);
    }
  }
  selected_(t3) {
    return this.getUserIndex(t3, this.m_selectionIndex) >= 0;
  }
  allocateIndex(t3 = true) {
    if (this.m_deletedIndices.length) {
      const e5 = this.m_deletedIndices.pop();
      return t3 && e5.setRange(-1, 0, e5.size()), e5;
    }
    return t3 ? J2(0, -1) : J2(0);
  }
  recycleUserIndex(t3) {
    this.m_deletedIndices.push(t3);
  }
  allocatePathIndex() {
    if (this.m_deletedPathIndices.length) {
      const t3 = this.m_deletedPathIndices.at(-1);
      return this.m_deletedPathIndices.pop(), t3;
    }
    return J2(0);
  }
  recyclePathUserIndex(t3) {
    this.m_deletedPathIndices.push(t3);
  }
  peelALoop_(t3, e5, s4) {
    const n6 = this.getNextVertex(t3), i2 = this.getNextVertex(e5), r = this.getVertexIndex(t3), o = this.getVertexIndex(e5);
    if (this.setNextVertex(t3, i2), this.setPrevVertex(i2, t3), this.setNextVertex(e5, n6), this.setPrevVertex(n6, e5), this.m_segments) {
      const t4 = this.getSegmentFromIndex(r), e6 = this.getSegmentFromIndex(o);
      this.setSegmentToIndex(o, null), this.setSegmentToIndex(r, e6), this.setSegmentToIndex(o, t4);
    }
    if (this.hasSegmentParentage()) {
      let s5 = this.getSegmentParentage(e5), n7 = this.getSegmentParentage(t3);
      -1 === s5 && -1 === n7 || (n7 = Pt(s5, s5 = n7), this.setSegmentParentageAndBreak(t3, n7), this.setSegmentParentageAndBreak(e5, s5));
    }
    if (s4) {
      const e6 = this.getPathFromVertex(t3), s5 = this.getGeometryFromPath(e6), r2 = [false], o2 = this.insertClosedPath(s5, cr, n6, this.getFirstVertex(e6), r2);
      r2[0] && this.setFirstVertex(e6, i2);
      let a2 = this.getPathSize(e6);
      return a2 -= this.getPathSize(o2), this.setPathSize(e6, a2), o2;
    }
    return cr;
  }
  sortVerticesSimpleByYHelper(t3, e5, s4) {
    t3.sort(e5, s4, (t4, e6) => {
      let s5 = this.compareVerticesSimpleY(t4, e6);
      if (0 === s5) {
        const n6 = this.getPathInternalIndexFromVertex(t4), i2 = this.getPathInternalIndexFromVertex(e6);
        s5 = n6 < i2 ? -1 : n6 > i2 ? 1 : 0;
      }
      return s5;
    });
  }
  sortVerticesSimpleByYHelper3D(t3, e5, n6) {
    n2(0);
  }
  constructor() {
    this.m_verticesMp = null, this.m_vertices = null, this.m_xyStream = null, this.m_vertexDescription = null, this.m_segments = null, this.m_weights = null, this.m_ranks = null, this.m_segmentWeights = null, this.m_segmentRanks = null, this.m_indices = [], this.m_deletedIndices = [], this.m_pathAreas = [], this.m_pathLengths = [], this.m_pathindices = [], this.m_deletedPathIndices = [], this.m_geometryIndices = [], this.m_selectedVertices = [], this.m_helperPoint = null, this.m_forceSetEnvelope = G3.constructEmpty(), this.m_hasForceSetEnvelope = 0, this.m_workPoint2D = mi.getNAN(), this.m_workPoint2_2D = mi.getNAN(), this.m_curveStitcher = null, this.m_pathCount = 0, this.m_pointCount = 0, this.m_firstGeometry = cr, this.m_lastGeometry = cr, this.m_vertexIndexList = new at(5), this.m_pathIndexList = new at(8), this.m_geometryIndexList = new at(8), this.m_bHasAttributes = false, this.m_selectedCount = 0, this.m_selectionIndex = -1, this.m_selection = false, this.m_bucketSort = new ot(), this.m_segmentParentageIndex = -1;
  }
  getTotalPointCount() {
    return this.m_pointCount;
  }
  getEnvelope2D(t3) {
    if (0 !== this.m_hasForceSetEnvelope) return new n4(this.m_forceSetEnvelope.xmin, this.m_forceSetEnvelope.ymin, this.m_forceSetEnvelope.xmax, this.m_forceSetEnvelope.ymax);
    const e5 = this.hasCurves(), s4 = n4.constructEmpty(), n6 = this.queryVertexIterator();
    let i2 = true;
    for (let r = n6.next(); r !== cr; r = n6.next()) {
      if (i2 ? s4.merge(this.getXY(r)) : s4.mergeNe(this.getXY(r)), e5) {
        const t4 = this.getSegment(r);
        if (null !== t4) {
          const e6 = n4.constructEmpty();
          t4.queryLooseEnvelope(e6), s4.mergeEnvelope2D(e6);
        }
      }
      i2 = false;
    }
    return s4;
  }
  getEnvelope3D(t3) {
    return n2(0), G3.constructEmpty();
  }
  forceSetEnvelope2D(t3) {
    this.m_hasForceSetEnvelope = 1, this.m_forceSetEnvelope.setCoords(t3.xmin, t3.ymin, 0, t3.xmax, t3.ymax, 0);
  }
  forceSetEnvelope3D(t3) {
    n2(0);
  }
  forgetForceSetEnvelope() {
    this.m_hasForceSetEnvelope = 0;
  }
  getGeometryCount() {
    return this.m_geometryIndexList.size();
  }
  addGeometry(t3, s4) {
    const n6 = t3.getGeometryType();
    if (h(n6)) return this.addMultiPath(t3, s4);
    if (n6 === a.enumMultiPoint) return this.addMultiPoint(t3, s4);
    if (n6 === a.enumPoint) return this.addPoint_(t3, s4);
    if (n6 === a.enumEnvelope) {
      const e5 = new ur();
      return e5.addEnvelope(t3, false), this.addMultiPath(e5, s4);
    }
    P("");
  }
  appendGeometry(t3, s4) {
    this.mergeVertexDescription(s4.getDescription());
    const n6 = s4.getGeometryType();
    h(n6) ? this.appendMultiPath(t3, s4) : n6 !== a.enumMultiPoint ? P("") : this.appendMultiPoint(t3, s4);
  }
  assignRankToGeometryVertices(t3, e5) {
    e5 < gr && (e5 = gr);
    const s4 = this.queryVertexIterator();
    for (let n6 = s4.next(); n6 !== cr; n6 = s4.next()) this.setRank(n6, e5), this.setSegmentRank(n6, e5);
  }
  collapseAllGeometriesToFirst() {
    this.collapseGeometriesToFirst(a.enumUnknown);
  }
  collapseGeometriesToFirst(t3) {
    this.dbgVerifyVertexCounts();
    let e5 = cr, s4 = -1, n6 = -1;
    for (let r = this.getFirstGeometry(); r !== cr; ) if (t3 !== a.enumUnknown && this.getGeometryType(r) !== t3) r = this.getNextGeometry(r);
    else {
      if (e5 === cr) {
        e5 = r, s4 = this.getPathCount(e5), n6 = this.getPointCount(e5), r = this.getNextGeometry(r);
        continue;
      }
      for (let s5 = this.getFirstPath(r); s5 !== cr; s5 = this.getNextPath(s5)) this.setPathGeometry(s5, e5);
      s4 += this.getPathCount(r), n6 += this.getPointCount(r);
      const t4 = this.getLastPath(e5), i2 = this.getFirstPath(r);
      t4 !== cr ? this.setNextPath(t4, i2) : this.setFirstPath(e5, i2), i2 !== cr && (this.setPrevPath(i2, t4), this.setLastPath(e5, this.getLastPath(r))), this.setFirstPath(r, cr), this.setLastPath(r, cr);
      const o = r;
      r = this.getNextGeometry(r), this.setGeometryVertexCount(o, 0), this.removeGeometry(o);
    }
    return e5 !== cr && (this.setGeometryVertexCount(e5, n6), this.setGeometryPathCount(e5, s4), this.dbgVerifyVertexCounts()), e5;
  }
  setFillRule(t3, e5) {
    let s4 = this.m_geometryIndexList.getField(t3, 2);
    s4 &= -134217729, s4 |= 1 === e5 ? 134217728 : 0, this.m_geometryIndexList.setField(t3, 2, s4);
  }
  getFillRule(t3) {
    return 134217728 & this.m_geometryIndexList.getField(t3, 2) ? 1 : 0;
  }
  setGeometryModified(t3, e5) {
    let s4 = this.m_geometryIndexList.getField(t3, 2);
    !!(67108864 & s4) !== e5 && (s4 &= -67108865, s4 |= e5 ? 67108864 : 0, this.m_geometryIndexList.setField(t3, 2, s4));
  }
  getGeometryModified(t3) {
    return !!(67108864 & this.m_geometryIndexList.getField(t3, 2));
  }
  setGeometryModifiedWithVertex(t3, e5) {
    const s4 = this.getPathFromVertex(t3), n6 = this.getGeometryFromPath(s4);
    this.setGeometryModified(n6, e5);
  }
  getGeometryModifiedWithVertex(t3) {
    const e5 = this.getPathFromVertex(t3), s4 = this.getGeometryFromPath(e5);
    return this.getGeometryModified(s4);
  }
  swapGeometry(t3, e5) {
    const s4 = this.getFirstPath(t3), n6 = this.getFirstPath(e5), i2 = this.getLastPath(t3), r = this.getLastPath(e5);
    for (let c = this.getFirstPath(t3); c !== cr; c = this.getNextPath(c)) this.setPathGeometry(c, e5);
    for (let c = this.getFirstPath(e5); c !== cr; c = this.getNextPath(c)) this.setPathGeometry(c, t3);
    this.setFirstPath(t3, n6), this.setFirstPath(e5, s4), this.setLastPath(t3, r), this.setLastPath(e5, i2);
    const o = this.getPointCount(t3), a2 = this.getPathCount(t3), h2 = this.getPointCount(e5), u = this.getPathCount(e5);
    this.setGeometryVertexCount(t3, h2), this.setGeometryVertexCount(e5, o), this.setGeometryPathCount(t3, u), this.setGeometryPathCount(e5, a2);
    const m3 = this.m_geometryIndexList.getField(t3, 2), l2 = this.m_geometryIndexList.getField(e5, 2);
    this.m_geometryIndexList.setField(t3, 2, l2), this.m_geometryIndexList.setField(e5, 2, m3);
  }
  addPathFromMultiPath(t3, e5, s4) {
    const n6 = this.createGeometry(s4 ? a.enumPolygon : a.enumPolyline, t3.getDescription()), r = t3.getImpl();
    if (t3.getPathSize(e5) < 2) return n6;
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + t3.getPathSize(e5)), this.m_verticesMp.addPoints(t3, t3.getPathStart(e5), r.getPathEnd(e5)), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
    const o = this.insertPath(n6, cr);
    this.setClosedPath(o, r.isClosedPath(e5) || s4);
    const a2 = null !== this.m_segments || null !== r.getSegmentFlagsStreamRef();
    for (let i2 = r.getPathStart(e5), h2 = r.getPathEnd(e5); i2 < h2; i2++) {
      const t4 = this.insertVertex_(o, cr, null, false);
      if (a2) {
        const e6 = this.getVertexIndex(t4);
        if (1 & r.getSegmentFlags(i2)) this.setSegmentToIndex(e6, null);
        else {
          const t5 = new fm();
          r.querySegment(i2, t5, true), this.setSegmentToIndex(e6, t5.releaseSegment());
        }
      }
    }
    return r.isStrongPathStart(e5) && this.setStrongPathStart(o, true), r.isStrongPathEnd(e5) && this.setStrongPathEnd(o, true), n6;
  }
  getGeometry(t3) {
    const e5 = this.getGeometryType(t3), s4 = mr(e5, this.m_verticesMp.getDescription()), n6 = this.getPointCount(t3);
    if (0 === n6) return s4;
    if (h(e5)) {
      const e6 = s4.getImpl(), i2 = this.getPathCount(t3), r = J2(i2 + 1), o = K2(i2 + 1, 0), a2 = s4.getDescription(), h2 = this.hasCurves();
      for (let s5 = 0, u = a2.getAttributeCount(); s5 < u; s5++) {
        const h3 = a2.getSemantics(s5), u2 = lr.getComponentCount(h3), m3 = j3(h3, n6), l2 = this.m_vertices.getAttributeStreamRef(h3);
        let c = 0, g2 = 0, d2 = 0;
        for (let e7 = this.getFirstPath(t3); e7 !== cr; e7 = this.getNextPath(e7)) {
          let t4 = 0;
          this.isClosedPath(e7) && (t4 |= 1), this.isExterior(e7) && (t4 |= 8), this.isStrongPathStart(e7) && (t4 |= 2), this.isStrongPathEnd(e7) && (t4 |= 4), t4 && o.setBits(g2, t4);
          const s6 = this.getPathSize(e7);
          if (r.write(g2++, d2), d2 += s6, 0 === h3) {
            const t5 = l2, s7 = m3;
            let n7;
            for (let i3 = this.getFirstVertex(e7); c < d2; i3 = this.getNextVertex(i3), c++) {
              const e8 = this.getVertexIndex(i3);
              n7 = t5.readPoint2D(2 * e8), s7.writePoint2D(2 * c, n7);
            }
          } else for (let n7 = this.getFirstVertex(e7); c < d2; n7 = this.getNextVertex(n7), c++) {
            const t5 = this.getVertexIndex(n7);
            for (let e8 = 0; e8 < u2; e8++) {
              const s7 = l2.readAsDbl(t5 * u2 + e8);
              m3.writeAsDbl(c * u2 + e8, s7);
            }
          }
        }
        e6.setAttributeStreamRef(h3, m3), r.write(i2, n6);
      }
      if (e6.setPathFlagsStreamRef(o), e6.setPathStreamRef(r), e6.notifyModifiedFlags(65535), h2) {
        let s5 = 0, n7 = 0;
        for (let i3 = this.getFirstPath(t3); i3 !== cr; i3 = this.getNextPath(i3)) {
          s5 += this.getPathSize(i3);
          for (let t4 = this.getFirstVertex(i3); n7 < s5; t4 = this.getNextVertex(t4)) {
            const s6 = this.getSegment(t4);
            null !== s6 && s6.isCurve() && e6.replaceSegment(n7, s6, true), n7++;
          }
        }
      }
    } else if (e5 === a.enumMultiPoint) {
      const e6 = s4.getImpl(), i2 = s4.getDescription();
      e6.reserve(n6), e6.resizeNoInit(n6);
      for (let s5 = 0, n7 = i2.getAttributeCount(); s5 < n7; s5++) {
        const n8 = i2.getSemantics(s5), r = lr.getComponentCount(n8), o = e6.getAttributeStreamRef(n8), a2 = this.m_vertices.getAttributeStreamRef(n8);
        let h2 = 0;
        const u = this.getFirstPath(t3), m3 = this.getPathSize(u);
        for (let t4 = this.getFirstVertex(u); h2 < m3; t4 = this.getNextVertex(t4), h2++) {
          const e7 = this.getVertexIndex(t4);
          for (let t5 = 0; t5 < r; t5++) {
            const s6 = a2.readAsDbl(e7 * r + t5);
            o.writeAsDbl(h2 * r + t5, s6);
          }
        }
        e6.setAttributeStreamRef(n8, o);
      }
      e6.notifyModifiedFlags(65535);
    } else b("getGeometry");
    return s4;
  }
  queryPointGeometryOnly(t3, s4) {
    this.getGeometryType(t3) !== a.enumMultiPoint && P("get_point_geometry_only");
    const n6 = this.getPointCount(t3);
    if (n6 > 1 && P("get_point_geometry_only"), 0 === n6) return s4.assignVertexDescription(this.m_vertexDescription), void s4.setEmpty();
    const r = this.getFirstPath(t3), o = this.getFirstVertex(r);
    this.queryPoint(o, s4);
  }
  removeGeometry(t3) {
    for (let n6 = this.getFirstPath(t3); n6 !== cr; n6 = this.removePath(n6)) ;
    const e5 = this.getPrevGeometry(t3), s4 = this.getNextGeometry(t3);
    return e5 !== cr ? this.setNextGeometry(e5, s4) : this.m_firstGeometry = s4, s4 !== cr ? this.setPrevGeometry(s4, e5) : this.m_lastGeometry = e5, this.freeGeometry(t3), s4;
  }
  createGeometry(t3, e5) {
    void 0 === e5 && (e5 = M());
    const s4 = this.newGeometry(t3);
    return this.m_vertices || (this.m_verticesMp = new Ee({ vd: e5 }), this.m_vertices = this.m_verticesMp.getImpl()), this.mergeVertexDescription(e5), this.m_firstGeometry === cr ? (this.m_firstGeometry = s4, this.m_lastGeometry = s4) : (this.setPrevGeometry(s4, this.m_lastGeometry), this.setNextGeometry(this.m_lastGeometry, s4), this.m_lastGeometry = s4), s4;
  }
  getFirstGeometry() {
    return this.m_firstGeometry;
  }
  getLastGeometry() {
    return this.m_lastGeometry;
  }
  getNextGeometry(t3) {
    return this.m_geometryIndexList.getField(t3, 1);
  }
  getPrevGeometry(t3) {
    return this.m_geometryIndexList.getField(t3, 0);
  }
  getGeometryType(t3) {
    return 16777215 & this.m_geometryIndexList.getField(t3, 2);
  }
  setGeometryUserIndex(t3, e5, s4) {
    const n6 = this.m_geometryIndices[e5], i2 = this.getGeometryIndex(t3);
    i2 >= n6.size() && n6.resize(Math.max(1.25 * i2, 16), -1), n6.write(i2, s4);
  }
  getGeometryUserIndex(t3, e5) {
    const s4 = this.getGeometryIndex(t3), n6 = this.m_geometryIndices[e5];
    return s4 < n6.size() ? n6.read(s4) : -1;
  }
  createGeometryUserIndex() {
    for (let e5 = 0; e5 < this.m_geometryIndices.length; e5++) if (null === this.m_geometryIndices[e5]) return this.m_geometryIndices[e5] = J2(0), e5;
    this.m_geometryIndices.push(J2(0));
    const t3 = this.m_geometryIndices.length - 1;
    return n2(t3 >= 0 && t3 <= Number.MAX_SAFE_INTEGER), t3;
  }
  removeGeometryUserIndex(t3) {
    for (this.m_geometryIndices[t3] = null; this.m_geometryIndices.length > 0 && null === this.m_geometryIndices.at(-1); ) this.m_geometryIndices.pop();
  }
  getFirstPath(t3) {
    return this.m_geometryIndexList.getField(t3, 3);
  }
  getLastPath(t3) {
    return this.m_geometryIndexList.getField(t3, 4);
  }
  hasPointFeatures() {
    for (let t3 = this.getFirstGeometry(); t3 !== cr; t3 = this.getNextGeometry(t3)) if (!h(this.getGeometryType(t3))) return true;
    return false;
  }
  getPointCount(t3) {
    return this.m_geometryIndexList.getField(t3, 5);
  }
  getPathCount(t3) {
    return this.m_geometryIndexList.getField(t3, 6);
  }
  filterClosePoints(t3, e5, n6, r, o) {
    const a2 = t3 * t3;
    let h2 = 0;
    const u = this.hasCurves(), m3 = this.hasSegmentParentage(), l2 = true;
    for (let g2 = o === cr ? this.getFirstGeometry() : o; g2 !== cr; g2 = o === cr ? this.getNextGeometry(g2) : cr) {
      const t4 = this.getGeometryType(g2);
      if (!h(t4)) continue;
      if (n6 && t4 !== a.enumPolygon) continue;
      const o2 = this.getGeometryType(g2) === a.enumPolygon;
      let d2 = this.getGeometryModified(g2);
      for (let n7 = this.getFirstPath(g2); n7 !== cr; ) {
        let t5 = 0;
        for (let e6 = this.getFirstVertex(n7); t5 < Math.trunc(this.getPathSize(n7) / 2); ) {
          const i3 = this.getNextVertex(e6);
          if (i3 === cr) break;
          const o3 = this.getXY(e6), c2 = this.getXY(i3);
          let _2 = mi.sqrDistance(o3, c2), p3 = true;
          do {
            if (_2 <= a2) {
              if (u) {
                const t6 = this.getSegment(e6);
                if (null !== t6) {
                  const e7 = t6.calculateLength2D();
                  if (_2 = e7 * e7, _2 > a2) break;
                }
              }
              if (0 === _2 ? 0 === h2 && (h2 = -1) : h2 = 1, i3 !== this.getLastVertex(n7)) {
                const t6 = m3 && (this.getSegmentParentageBreakVertex(e6) || this.getSegmentParentageBreakVertex(i3));
                if (this.transferAllDataToTheVertex(i3, e6, l2), this.removeVertex(i3, false), r && !d2 && (this.setGeometryModified(g2, true), d2 = true), m3 && e6 !== i3) {
                  this.setSegmentParentageBreakVertex(e6, t6);
                  const n8 = this.getNextVertex(e6);
                  n2(n8 !== cr), this.isDiscontinuousSegmentParentage(n8) && this.setSegmentParentageBreakVertex(n8, true);
                }
              }
              p3 = false;
            }
          } while (0);
          p3 && (e6 = this.getNextVertex(e6)), t5++;
        }
        let i2 = this.getFirstVertex(n7);
        for (let e6 = this.isClosedPath(n7) ? i2 : this.getLastVertex(n7); this.getPathSize(n7) > 0; ) {
          const t6 = this.getPrevVertex(e6);
          if (t6 === cr) break;
          {
            const o3 = this.getXY(t6), c2 = this.getXY(e6);
            let _2 = mi.sqrDistance(o3, c2), p3 = true;
            do {
              if (_2 <= a2) {
                if (u) {
                  const e7 = this.getSegment(t6);
                  if (null !== e7) {
                    const t7 = e7.calculateLength2D();
                    if (_2 = t7 * t7, _2 > a2) break;
                  }
                }
                if (0 === _2 ? 0 === h2 && (h2 = -1) : h2 = 1, m3) {
                  n2(this.m_segmentParentageIndex >= 0);
                  const n8 = this.getUserIndex(e6, this.m_segmentParentageIndex);
                  this.transferAllDataToTheVertex(t6, e6, l2), this.setUserIndex(e6, this.m_segmentParentageIndex, n8);
                } else this.transferAllDataToTheVertex(t6, e6, l2);
                const o4 = m3 && (this.getSegmentParentageBreakVertex(e6) || this.getSegmentParentageBreakVertex(t6));
                this.removeVertex(t6, true), r && !d2 && (this.setGeometryModified(g2, true), d2 = true), m3 && t6 !== e6 && (o4 || this.isDiscontinuousSegmentParentage(e6)) && this.setSegmentParentageBreakVertex(e6, true), i2 === t6 && (i2 = this.getFirstVertex(n7)), p3 = false;
              }
            } while (0);
            if (p3 && (e6 = this.getPrevVertex(e6), e6 === i2)) break;
          }
        }
        const c = this.getPathSize(n7);
        let _ = e5 && c < (o2 ? 3 : 2);
        _ && o2 && 2 === c && u && (_ = !this.pathHasCurves(n7)), _ ? (n7 = this.removePath(n7), 0 === h2 && (h2 = -1), r && !d2 && (this.setGeometryModified(g2, true), d2 = true)) : n7 = this.getNextPath(n7);
      }
    }
    return h2;
  }
  filterClosePoints3D(t3, e5, n6, i2, r, o) {
    return n2(0), 0;
  }
  hasDegenerateSegments(t3) {
    for (let e5 = this.getFirstGeometry(); e5 !== cr; e5 = this.getNextGeometry(e5)) if (h(this.getGeometryType(e5))) for (let s4 = this.getFirstPath(e5); s4 !== cr; ) {
      const e6 = this.getPathSize(s4);
      if (0 === e6) return true;
      let n6 = this.getFirstVertex(s4);
      for (let s5 = 0; s5 < e6; s5++) {
        const e7 = this.getNextVertex(n6);
        if (e7 === cr) break;
        const s6 = this.getVertexIndex(n6), i2 = this.getSegmentFromIndex(s6);
        let r = 0;
        if (null !== i2) {
          if (r = i2.calculateLowerLength2D(), r <= t3) {
            if (r = i2.calculateUpperLength2D(), r <= t3) return true;
            if (r = i2.calculateLength2D(), r <= t3) return true;
          }
        } else {
          const n7 = this.getVertexIndex(e7);
          if (r = this.m_vertices.getShortestDistance(s6, n7), r <= t3) return true;
        }
        n6 = e7;
      }
      s4 = this.getNextPath(s4);
    }
    return false;
  }
  hasDegenerateSegments3D(t3, e5) {
    return n2(0), false;
  }
  transferAllDataToTheVertex(t3, e5, s4 = false) {
    const n6 = this.getVertexIndex(t3), i2 = this.getVertexIndex(e5);
    if (s4) {
      let t4 = 1, e6 = 1;
      if (this.m_ranks && (t4 = this.getRankWithIndex(n6), e6 = this.getRankWithIndex(i2)), t4 > e6 && this.setRankWithIndex(i2, t4), t4 >= e6 && this.m_weights) {
        const s5 = this.getWeightWithIndex(n6), r2 = this.getWeightWithIndex(i2);
        (t4 > e6 || s5 > r2) && this.setWeightWithIndex(i2, s5);
      }
    } else {
      if (this.m_weights) {
        const t4 = this.getWeightWithIndex(n6);
        this.setWeightWithIndex(i2, t4);
      }
      if (this.m_ranks) {
        const t4 = this.getRankWithIndex(n6);
        this.setRankWithIndex(i2, t4);
      }
    }
    if (this.m_segmentWeights) {
      const t4 = this.getSegmentWeightWithIndex(n6);
      this.setSegmentWeightWithIndex(i2, t4);
    }
    if (this.m_segmentRanks) {
      const t4 = this.getSegmentRankWithIndex(n6);
      this.setSegmentRankWithIndex(i2, t4);
    }
    for (let o = 0, a2 = this.m_indices.length; o < a2; o++) if (o !== this.m_selectionIndex && null !== this.m_indices[o]) {
      const s5 = this.getUserIndex(t3, o);
      this.setUserIndex(e5, o, s5);
    }
    const r = this.selected(t3);
    r !== this.selected(e5) && (r ? this.select(e5) : this.unselect(e5));
  }
  splitSegmentAxisAware(t3, s4, n6, i2, r) {
    let o = 0;
    const a2 = this.getNextVertex(t3);
    a2 === cr && P("");
    const h2 = this.getVertexIndex(t3), u = this.getVertexIndex(a2), m3 = this.getSegmentFromIndex(h2);
    let l2 = this.m_vertices.getShortestDistance(h2, u);
    const c = this.getPathFromVertex(t3), g2 = this.m_bHasAttributes;
    g2 && m3 && (l2 = m3.calculateLength2D());
    const d2 = this.getSegmentParentage(t3), _ = this.getHelperPoint();
    if (m3) {
      let t4 = 0, e5 = 0, r2 = cr;
      for (let p3 = 0; p3 < n6; p3++) {
        const n7 = s4[p3];
        if (t4 < n7 && n7 < 1) {
          const s5 = m3.cut(t4, n7);
          if (null !== i2 && (p3 > 0 && s5.setStartXY(i2[p3 - 1]), s5.setEndXY(i2[p3]), s5.normalizeAfterEndpointChange(), e5 = p3), g2) {
            const t5 = l2 > 0 ? m3.calculateSubLengthFromStart(n7) / l2 : 0;
            this.m_vertices.interpolateTwoVertices(h2, u, t5, _);
          }
          _.setXY(s5.getEndXY()), r2 = this.insertVertex(c, a2, _), o++;
          const f3 = this.getPrevVertex(r2), P5 = this.getVertexIndex(f3);
          this.setSegmentToIndex(P5, s5), -1 !== d2 && this.setSegmentParentageAndBreak(r2, d2, false), t4 = n7;
        }
      }
      if (r2 !== cr) {
        const s5 = m3.cut(t4, 1);
        null !== i2 && (s5.setStartXY(i2[e5]), s5.normalizeAfterEndpointChange());
        const n7 = this.getVertexIndex(r2);
        this.setSegmentToIndex(n7, s5);
      }
    } else {
      let t4 = 0;
      for (let e5 = 0; e5 < n6; e5++) {
        const n7 = s4[e5];
        if (t4 < n7 && n7 < 1) {
          this.m_vertices.interpolateTwoVertices(h2, u, n7, _);
          const t5 = this.insertVertex(c, a2, _);
          o++, -1 !== d2 && this.setSegmentParentageAndBreak(t5, d2, false);
        }
        t4 = n7;
      }
    }
    return o;
  }
  splitSegment(t3, e5, s4, n6 = null) {
    return this.splitSegmentAxisAware(t3, e5, s4, n6, -1);
  }
  snapControlPoints(t3, s4, n6) {
    this.getNextVertex(t3) === cr && P("");
    let i2 = t3, r = false;
    for (let e5 = 0; e5 < s4; ++e5) {
      const t4 = this.getVertexIndex(i2), e6 = this.getSegmentFromIndex(t4);
      if (e6) {
        const t5 = e6.snapControlPoints(n6);
        r ||= t5;
      }
      i2 = this.getNextVertex(i2);
    }
    return r;
  }
  snapControlPointsOnSelection(t3) {
    if (!this.hasCurves()) return false;
    let e5 = 0;
    const s4 = this.queryVertexIteratorOnSelection();
    for (let n6 = s4.next(); n6 !== cr; n6 = s4.next()) {
      const s5 = this.getVertexIndex(n6), i2 = this.getSegmentFromIndex(s5);
      i2 && (e5 |= i2.snapControlPoints(t3) ? 1 : 0);
    }
    return 0 !== e5;
  }
  calculateSubLength2D(t3, e5, n6) {
    return n2(0), 0;
  }
  setPoint(t3, e5, s4) {
    if (this.setPointOnly(t3, e5), null !== this.m_segments) {
      const n6 = this.getVertexIndex(t3), i2 = this.getSegmentFromIndex(n6);
      null !== i2 && (i2.setStartXY(e5.getXY()), i2.normalizeAfterEndpointChange(), s4 && i2.ensureXYMonotone());
      const r = this.getPrevVertex(t3);
      if (r !== cr) {
        const t4 = this.getVertexIndex(r), n7 = this.getSegmentFromIndex(t4);
        null !== n7 && (n7.setEndXY(e5.getXY()), n7.normalizeAfterEndpointChange(), s4 && n7.ensureXYMonotone());
      }
    }
  }
  setPointEx(t3, e5, s4, n6, i2) {
    this.setPoint(t3, e5, i2);
    const r = this.getVertexIndex(t3);
    this.setWeightWithIndex(r, n6), this.setRankWithIndex(r, s4);
  }
  setPointOnly(t3, e5) {
    const s4 = this.getVertexIndex(t3);
    this.m_vertices.setPointByValNoCurves(s4, e5);
  }
  setPointOnlyEx(t3, e5, n6, i2) {
    n2(0);
  }
  queryPoint(t3, e5) {
    const s4 = this.getVertexIndex(t3);
    this.m_vertices.getPointByVal(s4, e5);
  }
  setXY(t3, e5) {
    this.setXYCoords(t3, e5.x, e5.y);
  }
  setXYCoords(t3, e5, s4) {
    const n6 = this.getVertexIndex(t3);
    if (this.m_vertices?.setXYCoordsNoCurves(n6, e5, s4), null !== this.m_segments) {
      const i2 = this.getSegmentFromIndex(n6);
      null !== i2 && (i2.setStartXYCoords(e5, s4), i2.normalizeAfterEndpointChange());
      const r = this.getPrevVertex(t3);
      if (r !== cr) {
        const t4 = this.getVertexIndex(r), n7 = this.getSegmentFromIndex(t4);
        null != n7 && (n7.setEndXYCoords(e5, s4), n7.normalizeAfterEndpointChange());
      }
    }
  }
  setXYMonotonic(t3, e5, s4) {
    const n6 = this.getVertexIndex(t3);
    if (this.m_vertices.setXYCoordsNoCurves(n6, e5, s4), null !== this.m_segments) {
      const i2 = this.getSegmentFromIndex(n6);
      if (null !== i2) {
        const t4 = i2.getEndXY();
        i2.setCoordsForIntersector(new mi(e5, s4), t4, false), i2.ensureXYMonotone();
      }
      const r = this.getPrevVertex(t3);
      if (r !== cr) {
        const t4 = this.getVertexIndex(r), n7 = this.getSegmentFromIndex(t4);
        if (null !== n7) {
          const t5 = n7.getStartXY();
          n7.setCoordsForIntersector(t5, new mi(e5, s4), false), n7.ensureXYMonotone();
        }
      }
    }
  }
  setXYMonotonicPoint2D(t3, e5) {
    this.setXYMonotonic(t3, e5.x, e5.y);
  }
  queryXY(t3, e5) {
    const s4 = this.getVertexIndex(t3);
    return this.m_vertices.queryXY(s4, e5);
  }
  getXY(t3) {
    const e5 = this.getVertexIndex(t3);
    return this.m_vertices.getXY(e5);
  }
  getXYWithIndex(t3) {
    return this.m_xyStream.readPoint2D(2 * t3);
  }
  static setSegDefault(t3, e5, n6) {
    n2(0);
  }
  setXYZ(t3, e5, n6) {
    n2(0);
  }
  setXYZCoords(t3, e5, n6, i2) {
    n2(0);
  }
  queryXYZ(t3, e5) {
    n2(0);
  }
  getXYZ(t3) {
    return n2(0), X.getNAN();
  }
  getXYZWithIndex(t3) {
    return n2(0), X.getNAN();
  }
  mergeVertexDescription(t3) {
    this.m_verticesMp.mergeVertexDescription(t3), this.m_vertexDescription = this.m_verticesMp.getDescription(), this.m_bHasAttributes = this.m_vertexDescription.getAttributeCount() > 1;
  }
  addAttribute(t3) {
    n2(0);
  }
  getAttributeAsDbl(t3, e5, s4) {
    return this.m_vertices.getAttributeAsDbl(t3, this.getVertexIndex(e5), s4);
  }
  queryAttributeAsDbl(t3, e5, n6, i2) {
    n2(0);
  }
  setAttribute(t3, e5, n6, i2) {
    n2(0);
  }
  setAttributeInt(t3, e5, n6, i2) {
    n2(0);
  }
  getVertexDescription() {
    return this.m_vertexDescription;
  }
  getMinPathVertexY(t3) {
    return n2(0), 0;
  }
  getVertexIndex(t3) {
    return this.m_vertexIndexList.getField(t3, 0);
  }
  getY(t3) {
    const e5 = this.getVertexIndex(t3);
    return this.m_vertices.queryXY(e5, this.m_workPoint2D), this.m_workPoint2D.y;
  }
  getX(t3) {
    return this.getXY(t3).x;
  }
  isEqualXY(t3, e5) {
    return this.queryXY(t3, this.m_workPoint2D), this.queryXY(e5, this.m_workPoint2_2D), this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D);
  }
  isEqualXYPoint2D(t3, e5) {
    return this.queryXY(t3, this.m_workPoint2D), this.m_workPoint2D.isEqualPoint2D(e5);
  }
  isEqualXYZPoint3D(t3, e5) {
    return n2(0), false;
  }
  setWeight(t3, e5) {
    e5 < 1 && (e5 = 1);
    const s4 = 1 === e5;
    if (null == this.m_weights) {
      if (s4) return;
      this.m_weights = $2(this.m_vertices.getPointCount(), 1);
    }
    const n6 = this.getVertexIndex(t3);
    if (n6 >= this.m_weights.size()) {
      if (s4) return;
      this.m_weights.resize(n6 + 1, 1);
    }
    this.m_weights.write(n6, e5);
  }
  setWeightWithIndex(t3, e5) {
    e5 < 1 && (e5 = 1);
    const s4 = 1 === e5;
    if (null === this.m_weights) {
      if (s4) return;
      this.m_weights = $2(this.m_vertices.getPointCount(), 1);
    }
    if (t3 >= this.m_weights.size()) {
      if (s4) return;
      this.m_weights.resize(t3 + 1, 1);
    }
    this.m_weights.write(t3, e5);
  }
  getWeight(t3) {
    if (null === this.m_weights) return 1;
    const e5 = this.getVertexIndex(t3);
    return e5 >= this.m_weights.size() ? 1 : this.m_weights.read(e5);
  }
  getWeightWithIndex(t3) {
    return null === this.m_weights || t3 >= this.m_weights.size() ? 1 : this.m_weights.read(t3);
  }
  getRank(t3) {
    if (null === this.m_ranks) return gr;
    const e5 = this.getVertexIndex(t3);
    return e5 >= this.m_ranks.size() ? gr : this.m_ranks.read(e5);
  }
  getRankWithIndex(t3) {
    return null === this.m_ranks || t3 >= this.m_ranks.size() ? gr : this.m_ranks.read(t3);
  }
  setRank(t3, e5) {
    e5 < gr && (e5 = gr);
    const s4 = e5 === gr;
    if (null === this.m_ranks) {
      if (s4) return;
      this.m_ranks = J2(this.m_vertices.getPointCount(), gr);
    }
    const n6 = this.getVertexIndex(t3);
    if (n6 >= this.m_ranks.size()) {
      if (s4) return;
      this.m_ranks.resize(n6 + 1, gr);
    }
    this.m_ranks.write(n6, e5);
  }
  setRankWithIndex(t3, e5) {
    e5 < gr && (e5 = gr);
    const s4 = e5 === gr;
    if (null === this.m_ranks) {
      if (s4) return;
      this.m_ranks = J2(this.m_vertices.getPointCount(), gr);
    }
    if (t3 >= this.m_ranks.size()) {
      if (s4) return;
      this.m_ranks.resize(t3 + 1, gr);
    }
    this.m_ranks.write(t3, e5);
  }
  setSegmentWeight(t3, e5) {
    e5 < 1 && (e5 = 1);
    const s4 = 1 === e5;
    if (null === this.m_segmentWeights) {
      if (s4) return;
      this.m_segmentWeights = $2(this.m_vertices.getPointCount(), 1);
    }
    const n6 = this.getVertexIndex(t3);
    if (n6 >= this.m_segmentWeights.size()) {
      if (s4) return;
      this.m_segmentWeights.resize(n6 + 1, 1);
    }
    this.m_segmentWeights.write(n6, e5);
  }
  setSegmentWeightWithIndex(t3, e5) {
    e5 < 1 && (e5 = 1);
    const s4 = 1 === e5;
    if (null == this.m_segmentWeights) {
      if (s4) return;
      this.m_segmentWeights = $2(this.m_vertices.getPointCount(), 1);
    }
    if (t3 >= this.m_segmentWeights.size()) {
      if (s4) return;
      this.m_segmentWeights.resize(t3 + 1, 1);
    }
    this.m_segmentWeights.write(t3, e5);
  }
  getSegmentWeight(t3) {
    if (null === this.m_segmentWeights) return 1;
    const e5 = this.getVertexIndex(t3);
    return e5 >= this.m_segmentWeights.size() ? 1 : this.m_segmentWeights.read(e5);
  }
  getSegmentWeightWithIndex(t3) {
    return null == this.m_segmentWeights || t3 >= this.m_segmentWeights.size() ? 1 : this.m_segmentWeights.read(t3);
  }
  getSegmentRank(t3) {
    if (null === this.m_segmentRanks) return _Pr.st_defaultRank;
    const e5 = this.getVertexIndex(t3);
    return e5 >= this.m_segmentRanks.size() ? _Pr.st_defaultRank : this.m_segmentRanks.read(e5);
  }
  getSegmentRankWithIndex(t3) {
    return null === this.m_segmentRanks || t3 >= this.m_segmentRanks.size() ? gr : this.m_segmentRanks.read(t3);
  }
  setSegmentRank(t3, e5) {
    e5 < gr && (e5 = gr);
    const s4 = e5 === gr;
    if (null === this.m_segmentRanks) {
      if (s4) return;
      this.m_segmentRanks = J2(this.m_vertices.getPointCount(), gr);
    }
    const n6 = this.getVertexIndex(t3);
    if (n6 >= this.m_segmentRanks.size()) {
      if (s4) return;
      this.m_segmentRanks.resize(n6 + 1, gr);
    }
    this.m_segmentRanks.write(n6, e5);
  }
  setSegmentRankWithIndex(t3, e5) {
    e5 < gr && (e5 = gr);
    const s4 = e5 === gr;
    if (null === this.m_segmentRanks) {
      if (s4) return;
      this.m_segmentRanks = J2(this.m_vertices.getPointCount(), gr);
    }
    if (t3 >= this.m_segmentRanks.size()) {
      if (s4) return;
      this.m_segmentRanks.resize(t3 + 1, gr);
    }
    this.m_segmentRanks.write(t3, e5);
  }
  removeWeights() {
    this.m_weights = null, this.m_segmentWeights = null;
  }
  removeRanks() {
    this.m_ranks = null, this.m_segmentRanks = null;
  }
  setUserIndex(t3, e5, s4) {
    const n6 = this.m_indices[e5], i2 = this.getVertexIndex(t3);
    if (n6.size() <= i2) {
      if (-1 === s4) return;
      n6.resize(this.m_vertices.getPointCount(), -1);
    }
    n6.write(i2, s4);
  }
  getUserIndex(t3, e5) {
    const s4 = this.getVertexIndex(t3), n6 = this.m_indices[e5];
    if (s4 < n6.size()) {
      return n6.read(s4);
    }
    return -1;
  }
  addToUserIndex(t3, e5, s4) {
    const n6 = this.m_indices[e5], i2 = this.getVertexIndex(t3);
    n6.size() <= i2 && n6.resize(this.m_vertices.getPointCount(), -1);
    const r = n6.read(i2);
    n6.write(i2, r + s4);
  }
  createUserIndex() {
    for (let e5 = 0; e5 < this.m_indices.length; e5++) if (null === this.m_indices[e5]) return this.m_indices[e5] = this.allocateIndex(), e5;
    this.m_indices.push(this.allocateIndex());
    const t3 = this.m_indices.length - 1;
    return n2(t3 >= 0 && t3 <= ds()), t3;
  }
  createUserIndexUninitialized() {
    for (let e5 = 0; e5 < this.m_indices.length; e5++) if (null === this.m_indices[e5]) return this.m_indices[e5] = this.allocateIndex(false), e5;
    this.m_indices.push(this.allocateIndex(false));
    const t3 = this.m_indices.length - 1;
    return n2(t3 >= 0 && t3 <= Number.MAX_SAFE_INTEGER), t3;
  }
  fillUserIndexForGeometry(t3, e5, s4) {
    const n6 = this.m_indices[e5], i2 = n6.size();
    for (let r = this.getFirstPath(t3); r !== cr; r = this.getNextPath(r)) {
      let t4 = this.getFirstVertex(r);
      for (let e6 = 0, o = this.getPathSize(r); e6 < o; e6++, t4 = this.getNextVertex(t4)) {
        const e7 = this.getVertexIndex(t4);
        e7 < i2 && n6.write(e7, s4);
      }
    }
  }
  fillUserIndexForSelection(t3, e5) {
    n2(0);
  }
  removeUserIndex(t3) {
    for (this.recycleUserIndex(this.m_indices[t3]), this.m_indices[t3] = null; this.m_indices.length > 0 && null === this.m_indices[this.m_indices.length - 1]; ) this.m_indices.pop();
  }
  replaceCurveWithLine(t3) {
    if (null !== this.m_segments) {
      const e5 = this.getVertexIndex(t3);
      this.setSegmentToIndex(e5, null);
    }
  }
  queryLineConnector(t3, e5, s4 = false) {
    const n6 = this.getNextVertex(t3);
    if (n6 === cr) return false;
    if (!this.m_bHasAttributes || s4) {
      const s5 = this.getXY(t3);
      e5.setStartXY(s5);
      const i2 = this.getXY(n6);
      e5.setEndXY(i2);
    } else {
      const s5 = new ee({ vd: this.getVertexDescription() });
      this.queryPoint(t3, s5), e5.setStart(s5), this.queryPoint(n6, s5), e5.setEnd(s5);
    }
    return true;
  }
  queryLineConnector3D(t3, e5, n6 = false) {
    return n2(0), false;
  }
  hasCurves() {
    return null !== this.m_segments;
  }
  geometryHasCurves(t3) {
    return n2(0), false;
  }
  pathHasCurves(t3) {
    if (!this.hasCurves()) return false;
    const e5 = this.getFirstVertex(t3);
    if (e5 === cr) return false;
    const s4 = this.getPathSize(t3);
    let n6 = e5;
    for (let r = 0; r < s4; r++, n6 = this.getNextVertex(n6)) {
      const t4 = this.getSegment(n6);
      if (null !== t4 && t4.getGeometryType() !== a.enumLine) return true;
    }
    return false;
  }
  insertPath(t3, s4) {
    let n6 = cr;
    s4 !== cr ? (t3 !== this.getGeometryFromPath(s4) && P(""), n6 = this.getPrevPath(s4)) : n6 = this.getLastPath(t3);
    const i2 = this.newPath(t3);
    return s4 !== cr && this.setPrevPath(s4, i2), this.setNextPath(i2, s4), this.setPrevPath(i2, n6), n6 !== cr ? this.setNextPath(n6, i2) : this.setFirstPath(t3, i2), s4 === cr && this.setLastPath(t3, i2), this.setGeometryPathCount(t3, this.getPathCount(t3) + 1), i2;
  }
  removePath(t3) {
    const e5 = this.getPrevPath(t3), s4 = this.getNextPath(t3), n6 = this.getGeometryFromPath(t3);
    return e5 !== cr ? this.setNextPath(e5, s4) : this.setFirstPath(n6, s4), s4 !== cr ? this.setPrevPath(s4, e5) : this.setLastPath(n6, e5), this.clearPath(t3), this.setGeometryPathCount(n6, this.getPathCount(n6) - 1), this.freePath(t3), s4;
  }
  clearPath(t3) {
    const e5 = this.getFirstVertex(t3);
    if (e5 !== cr) {
      let s4 = e5;
      for (let e6 = 0, i2 = this.getPathSize(t3); e6 < i2; e6++) {
        const t4 = s4;
        s4 = this.getNextVertex(s4), this.freeVertex(t4);
      }
      const n6 = this.getGeometryFromPath(t3);
      this.setGeometryVertexCount(n6, this.getPointCount(n6) - this.getPathSize(t3));
    }
    this.setPathSize(t3, 0);
  }
  getNextPath(t3) {
    return this.m_pathIndexList.getField(t3, 2);
  }
  getPrevPath(t3) {
    return this.m_pathIndexList.getField(t3, 1);
  }
  getPathSize(t3) {
    return this.m_pathIndexList.getField(t3, 3);
  }
  isClosedPath(t3) {
    return !!(1 & this.getPathFlags(t3));
  }
  setClosedPath(t3, e5) {
    if (this.isClosedPath(t3) === e5) return;
    if (this.getPathSize(t3) > 0) {
      const s5 = this.getFirstVertex(t3), n6 = this.getLastVertex(t3);
      if (e5) {
        this.setNextVertex(n6, s5), this.setPrevVertex(s5, n6);
        const t4 = this.getVertexIndex(n6);
        this.setSegmentToIndex(t4, null);
      } else {
        this.setNextVertex(n6, cr), this.setPrevVertex(s5, cr);
        const t4 = this.getVertexIndex(n6);
        this.setSegmentToIndex(t4, null);
      }
    }
    const s4 = (1 | this.getPathFlags(t3)) - 1;
    this.setPathFlags(t3, s4 | (e5 ? 1 : 0));
  }
  closeAllPaths(t3) {
    n2(0);
  }
  isStrongPathStart(t3) {
    return !!(8 & this.getPathFlags(t3));
  }
  isStrongPathEnd(t3) {
    return !!(16 & this.getPathFlags(t3));
  }
  setStrongPathStart(t3, e5) {
    const s4 = (8 | this.getPathFlags(t3)) - 8;
    this.setPathFlags(t3, s4 | (e5 ? 8 : 0));
  }
  setStrongPathEnd(t3, e5) {
    const s4 = (16 | this.getPathFlags(t3)) - 16;
    this.setPathFlags(t3, s4 | (e5 ? 16 : 0));
  }
  getGeometryFromPath(t3) {
    return this.m_pathIndexList.getField(t3, 7);
  }
  isExterior(t3) {
    return !!(2 & this.getPathFlags(t3));
  }
  setExterior(t3, e5) {
    const s4 = (2 | this.getPathFlags(t3)) - 2;
    this.setPathFlags(t3, s4 | (e5 ? 2 : 0));
  }
  getRingArea(t3) {
    if (this.isRingAreaValid(t3)) return this.m_pathAreas[this.getPathIndex(t3)];
    const e5 = this.getFirstVertex(t3);
    if (e5 === cr) return 0;
    const s4 = this.getXY(e5), n6 = new n3(0), r = this.getPathSize(t3);
    if (r > 2) {
      const t4 = s4.clone(), i2 = t4.x, o2 = t4.y;
      let a2 = this.getNextVertex(e5);
      const h2 = this.getXY(a2);
      a2 = this.getNextVertex(a2);
      const u = mi.getNAN();
      for (let e6 = 2; e6 < r; e6++, a2 = this.getNextVertex(a2)) this.queryXY(a2, u), n6.pe((u.x - t4.x) * (h2.y - o2)), t4.setCoordsPoint2D(h2), h2.setCoordsPoint2D(u);
      n6.pe((i2 - t4.x) * (h2.y - o2));
    }
    if (this.hasCurves()) {
      let t4 = e5;
      for (let e6 = 0; e6 < r; e6++, t4 = this.getNextVertex(t4)) {
        const e7 = this.getSegment(t4);
        if (null === e7 || e7.getGeometryType() === a.enumLine) continue;
        const s5 = 2 * e7.calculateArea2DHelper();
        n6.pe(s5);
      }
    }
    this.setRingAreaValid(t3, true);
    const o = 0.5 * n6.getResult();
    return this.m_pathAreas[this.getPathIndex(t3)] = o, o;
  }
  getPathIndexInternal(t3) {
    return this.getPathIndex(t3);
  }
  getPathInternalIndexFromVertex(t3) {
    return this.getPathIndex(this.getPathFromVertex(t3));
  }
  setPathUserIndex(t3, e5, s4) {
    const n6 = this.m_pathindices[e5], i2 = this.getPathIndex(t3);
    n6.size() < this.m_pathAreas.length && n6.resize(this.m_pathAreas.length, -1), n6.write(i2, s4);
  }
  getPathUserIndex(t3, e5) {
    const s4 = this.getPathIndex(t3), n6 = this.m_pathindices[e5];
    return s4 < n6.size() ? n6.read(s4) : -1;
  }
  createPathUserIndex() {
    for (let e5 = 0; e5 < this.m_pathindices.length; e5++) if (null === this.m_pathindices[e5]) return this.m_pathindices[e5] = this.allocatePathIndex(), e5;
    this.m_pathindices.push(this.allocatePathIndex());
    const t3 = this.m_pathindices.length - 1;
    return n2(t3 >= 0 && t3 <= Number.MAX_SAFE_INTEGER), t3;
  }
  fillPathUserIndexForGeometry(t3, e5, s4) {
    const n6 = this.m_pathindices[e5], i2 = n6.size();
    for (let r = this.getFirstPath(t3); r !== cr; r = this.getNextPath(r)) {
      const t4 = this.getPathIndex(r);
      t4 < i2 && n6.write(t4, s4);
    }
  }
  removePathUserIndex(t3) {
    for (this.recyclePathUserIndex(this.m_pathindices[t3]), this.m_pathindices[t3] = null; this.m_pathindices.length > 0 && null === this.m_pathindices.at(-1); ) this.m_pathindices.pop();
  }
  movePath(t3, s4, n6) {
    if (n6 === cr && P(""), s4 === n6) return;
    const i2 = this.getNextPath(n6);
    let r = this.getPrevPath(n6);
    const o = this.getGeometryFromPath(n6);
    r === cr ? this.setFirstPath(o, i2) : this.setNextPath(r, i2), i2 === cr ? this.setLastPath(o, r) : this.setPrevPath(i2, r), this.setGeometryVertexCount(o, this.getPointCount(o) - this.getPathSize(n6)), this.setGeometryPathCount(o, this.getPathCount(o) - 1), r = s4 === cr ? this.getLastPath(t3) : this.getPrevPath(s4), this.setPrevPath(n6, r), this.setNextPath(n6, s4), s4 === cr ? this.setLastPath(t3, n6) : this.setPrevPath(s4, n6), r === cr ? this.setFirstPath(t3, n6) : this.setNextPath(r, n6), this.setGeometryVertexCount(t3, this.getPointCount(t3) + this.getPathSize(n6)), this.setGeometryPathCount(t3, this.getPathCount(t3) + 1), this.setPathGeometry(n6, t3);
  }
  addVertex(t3, e5) {
    this.m_vertices.getPointByVal(this.getVertexIndex(e5), this.getHelperPoint());
    return this.insertVertex_(t3, cr, this.getHelperPoint(), false);
  }
  insertVertex(t3, e5, s4) {
    return this.insertVertex_(t3, e5, s4, true);
  }
  removeVertex(t3, e5) {
    const s4 = this.getPathFromVertex(t3), n6 = this.getPrevVertex(t3), i2 = this.getNextVertex(t3);
    n6 !== cr && this.setNextVertex(n6, i2);
    const r = this.getPathSize(s4);
    t3 === this.getFirstVertex(s4) && this.setFirstVertex(s4, r > 1 ? i2 : cr), i2 !== cr && this.setPrevVertex(i2, n6), t3 === this.getLastVertex(s4) && this.setLastVertex(s4, r > 1 ? n6 : cr);
    if (this.hasCurves() && n6 !== cr && i2 !== cr) {
      const s5 = this.getVertexIndex(t3), r2 = this.getVertexIndex(n6), o2 = this.getVertexIndex(i2);
      if (e5) {
        const t4 = this.getSegmentFromIndex(r2);
        if (null !== t4) {
          const e6 = this.m_vertices.getXY(o2);
          t4.setEndXY(e6), t4.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(s5, null);
      } else {
        const t4 = this.getSegmentFromIndex(s5);
        if (this.setSegmentToIndex(s5, null), null !== t4) {
          const e6 = this.m_vertices.getXY(r2);
          t4.setStartXY(e6), t4.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(r2, t4);
      }
    }
    this.setPathSize(s4, r - 1);
    const o = this.getGeometryFromPath(s4);
    return this.setGeometryVertexCount(o, this.getPointCount(o) - 1), this.freeVertex(t3), i2;
  }
  removeVertices(t3, e5) {
    n2(t3 !== e5);
    const n6 = this.getPathFromVertex(t3), i2 = this.getPrevVertex(t3), r = this.getPrevVertex(e5);
    i2 !== cr && this.setNextVertex(i2, e5);
    let o = this.getPathSize(n6);
    const a2 = this.getVertexIndex(t3);
    this.setSegmentToIndex(a2, null), this.setPrevVertex(e5, i2), this.setPrevVertex(t3, cr), this.setNextVertex(r, cr);
    let h2 = 0, u = t3;
    const m3 = this.getFirstVertex(n6);
    let l2 = false;
    for (; ; ) {
      const t4 = this.getNextVertex(u);
      if (l2 ||= m3 === u, this.freeVertex(u), h2++, u === r) break;
      u = t4;
    }
    o -= h2, l2 && this.setFirstVertex(n6, o > 0 ? e5 : cr), this.setPathSize(n6, o);
    const c = this.getGeometryFromPath(n6);
    this.setGeometryVertexCount(c, this.getPointCount(c) - h2);
  }
  getFirstVertex(t3) {
    return this.m_pathIndexList.getField(t3, 4);
  }
  getLastVertex(t3) {
    return this.m_pathIndexList.getField(t3, 5);
  }
  getNextVertex(t3) {
    return this.m_vertexIndexList.getField(t3, 2);
  }
  getPrevVertex(t3) {
    return this.m_vertexIndexList.getField(t3, 1);
  }
  getNextVertexEx(t3, e5) {
    return e5 > 0 ? this.m_vertexIndexList.getField(t3, 2) : this.m_vertexIndexList.getField(t3, 1);
  }
  getPrevVertexEx(t3, e5) {
    return e5 > 0 ? this.m_vertexIndexList.getField(t3, 1) : this.m_vertexIndexList.getField(t3, 2);
  }
  getPathFromVertex(t3) {
    return this.m_vertexIndexList.getField(t3, 3);
  }
  addPoint(t3, e5) {
    return this.insertVertex_(t3, cr, e5, false);
  }
  getGeometryFromVertex(t3) {
    return this.getGeometryFromPath(this.getPathFromVertex(t3));
  }
  replaceNaNs(t3, e5) {
    this.m_vertexDescription.hasAttribute(t3) || b(""), this.m_vertices.replaceNaNs(t3, e5);
  }
  removeNaNVertices() {
    for (let t3 = this.getFirstGeometry(); t3 !== cr; t3 = this.getNextGeometry(t3)) for (let e5 = this.getFirstPath(t3); e5 !== cr; e5 = this.getNextPath(e5)) {
      let t4 = this.getFirstVertex(e5);
      for (let s4 = 0, n6 = this.getPathSize(e5); s4 < n6; s4++) t4 = this.getXY(t4).isFinite() ? this.getNextVertex(t4) : this.removeVertex(t4, true);
    }
  }
  queryVertexIterator(t3 = cr) {
    return this.queryVertexIteratorEx(false, t3);
  }
  queryVertexIteratorEx(t3, e5 = cr) {
    let s4 = cr, n6 = cr, i2 = cr, r = cr, o = 0, a2 = false;
    for (s4 = e5 !== cr ? e5 : this.getFirstGeometry(); s4 !== cr; s4 = this.getNextGeometry(s4)) if (!t3 || h(this.getGeometryType(s4))) {
      for (n6 = this.getFirstPath(s4); n6 !== cr; n6 = this.getNextPath(n6)) if (i2 = this.getFirstVertex(n6), r = i2, o = 0, i2 !== cr) {
        a2 = true;
        break;
      }
      if (a2 || e5 !== cr) break;
    }
    return a2 || (s4 = cr), pr.create_(this, s4, n6, i2, r, o, t3, false, e5 !== cr);
  }
  queryVertexIteratorOnSelection(t3 = cr) {
    return this.m_selection ? pr.create_(this, t3, cr, cr, cr, -1, false, true, t3 !== cr) : this.queryVertexIteratorEx(false, t3);
  }
  hasSelection() {
    return this.m_selection;
  }
  createEmptySelection() {
    n2(0);
  }
  removeSelection() {
    this.m_selection && (this.m_selectedVertices.length = 0, this.removeUserIndex(this.m_selectionIndex), this.m_selectionIndex = -1, this.m_selection = false, this.m_selectedCount = 0);
  }
  select(t3) {
    return !!this.selected(t3) || (this.setUserIndex(t3, this.m_selectionIndex, this.m_selectedVertices.length), this.m_selectedVertices.push(t3), this.m_selectedCount++, false);
  }
  unselect(t3) {
    if (!this.m_selection) return;
    const e5 = this.getUserIndex(t3, this.m_selectionIndex);
    e5 >= 0 && (this.m_selectedVertices[e5] = cr, this.setUserIndex(t3, this.m_selectionIndex, -1), this.m_selectedCount--);
  }
  selected(t3) {
    return !this.m_selection || this.selected_(t3);
  }
  getSelectedCount() {
    return this.m_selection ? this.m_selectedCount : this.getTotalPointCount();
  }
  createSelectionForCrackingAndClustering(t3, e5) {
    return n2(0), false;
  }
  peelALoop(t3, e5) {
    this.peelALoop_(t3, e5, false);
  }
  peelALoopIntoAPath(t3, e5) {
    return this.peelALoop_(t3, e5, true);
  }
  applyTransformation(t3) {
    if (this.m_verticesMp.applyTransformation(t3), null !== this.m_segments) for (let e5 = 0, s4 = this.m_segments.length; e5 < s4; e5++) this.m_segments[e5] && this.m_segments[e5].applyTransformation(t3);
  }
  setGeometryType(t3, e5) {
    this.m_geometryIndexList.setField(t3, 2, e5);
  }
  splitSegmentWithIntersector(t3, e5, s4, n6, i2) {
    n6 ? this.splitSegmentForward(t3, e5, s4, true, i2) : this.splitSegmentBackward(t3, e5, s4, true, i2);
  }
  setPrevVertex(t3, e5) {
    this.m_vertexIndexList.setField(t3, 1, e5);
  }
  setNextVertex(t3, e5) {
    this.m_vertexIndexList.setField(t3, 2, e5);
  }
  setPathToVertex(t3, e5) {
    this.m_vertexIndexList.setField(t3, 3, e5);
  }
  setPathSize(t3, e5) {
    this.m_pathIndexList.setField(t3, 3, e5);
  }
  setFirstVertex(t3, e5) {
    this.m_pathIndexList.setField(t3, 4, e5);
  }
  setLastVertex(t3, e5) {
    this.m_pathIndexList.setField(t3, 5, e5);
  }
  getSegment(t3) {
    if (null != this.m_segments) {
      const e5 = this.getVertexIndex(t3);
      return this.getSegmentFromIndex(e5);
    }
    return null;
  }
  isCurve(t3) {
    if (null === this.m_segments) return false;
    const e5 = this.getVertexIndex(t3);
    return this.m_segments.length > e5 && null !== this.m_segments[e5];
  }
  querySegment(t3, e5, s4 = true, n6 = false) {
    const i2 = this.getNextVertex(t3);
    if (i2 === cr) return false;
    const r = this.getSegment(t3);
    if (!r) return !s4 && (this.queryLineConnector(t3, e5.createLine(), n6), true);
    if (e5.copyFrom(r, true), n6) return true;
    if (this.m_vertexDescription.getAttributeCount() > 1) {
      const s5 = this.getHelperPoint();
      this.queryPoint(t3, s5), e5.get().setStart(s5), this.queryPoint(i2, s5), e5.get().setEnd(s5);
    }
    return true;
  }
  getSegmentFromIndex(t3) {
    const e5 = null !== this.m_segments && this.m_segments.length > t3 ? this.m_segments[t3] : null;
    return e5 || null;
  }
  getAndClearSegmentFromIndex(t3) {
    const e5 = null !== this.m_segments && this.m_segments.length > t3 ? this.m_segments[t3] : null;
    return e5 || null;
  }
  setSegmentToIndex(t3, e5) {
    if (this.m_hasForceSetEnvelope = 0, null === this.m_segments) {
      if (!e5) return;
      this.m_segments = [], this.m_segments.length = this.m_vertices.getPointCount();
    }
    t3 >= this.m_segments.length && (this.m_segments.length = t3 + 1), this.m_segments[t3] = e5;
  }
  setGeometryPathCount(t3, e5) {
    this.m_geometryIndexList.setField(t3, 6, e5);
  }
  setGeometryVertexCount(t3, e5) {
    this.m_geometryIndexList.setField(t3, 5, e5);
  }
  ringParentageCheckInternal(t3, e5) {
    return n2(0), false;
  }
  reverseRingInternal(t3) {
    const e5 = this.hasCurves(), s4 = this.hasSegmentParentage();
    let n6 = null, i2 = -1, r = t3;
    if (e5) {
      const t4 = this.getVertexIndex(r);
      n6 = this.getAndClearSegmentFromIndex(t4);
    }
    s4 && (i2 = this.getSegmentParentage(r));
    do {
      const t4 = this.getPrevVertex(r), o = this.getNextVertex(r);
      if (this.setNextVertex(r, t4), this.setPrevVertex(r, o), e5) {
        const t5 = this.getVertexIndex(o), e6 = this.getSegmentFromIndex(t5);
        n6 && n6.reverse(), this.setSegmentToIndex(t5, n6), n6 = e6;
      }
      if (s4) {
        const t5 = this.getSegmentParentage(o);
        this.setSegmentParentagePreserveBreak(o, i2), i2 = t5;
      }
      r = o;
    } while (r !== t3);
    this.dbgVerifyIntegrity(t3);
  }
  setTotalPointCount(t3) {
    this.m_pointCount = t3;
  }
  removePathOnly(t3) {
    const e5 = this.getPrevPath(t3), s4 = this.getNextPath(t3), n6 = this.getGeometryFromPath(t3);
    e5 !== cr ? this.setNextPath(e5, s4) : this.setFirstPath(n6, s4), s4 !== cr ? this.setPrevPath(s4, e5) : this.setLastPath(n6, e5), this.setFirstVertex(t3, cr), this.setLastVertex(t3, cr), this.freePath(t3);
  }
  insertClosedPath(t3, e5, s4, n6, i2) {
    const r = this.insertPath(t3, cr);
    let o = 0, a2 = s4;
    for (i2[0] = false; ; ) {
      a2 === n6 && (i2[0] = true), this.setPathToVertex(a2, r), o++;
      const t4 = this.getNextVertex(a2);
      if (t4 === s4) break;
      a2 = t4;
    }
    return this.setClosedPath(r, true), this.setPathSize(r, o), i2[0] && (s4 = n6), this.setFirstVertex(r, s4), this.setLastVertex(r, this.getPrevVertex(s4)), this.setRingAreaValid(r, false), r;
  }
  findVertex2D(t3, e5) {
    return n2(0), 0;
  }
  findVertex3D(t3, e5, n6) {
    return n2(0), 0;
  }
  dbgVerifyMonotone() {
  }
  dbgCheckSelection() {
  }
  dbgVerifySegment(t3) {
  }
  dbgVerifyIntegrity(t3, e5 = true) {
  }
  dbgVerifyVertexCounts() {
  }
  dbgVerifyCurves() {
  }
  dbgDumpGeometry(t3, e5) {
  }
  getNextNthVertex(t3, e5) {
    if (0 === e5) return t3;
    let s4 = t3;
    for (let n6 = 0; n6 < e5; ++n6) if (s4 = e5 > 0 ? this.getNextVertex(s4) : this.getPrevVertex(s4), s4 === cr) return cr;
    return s4;
  }
  removeVertexInternal(t3, e5) {
    const s4 = this.getPrevVertex(t3), n6 = this.getNextVertex(t3);
    s4 !== cr && this.setNextVertex(s4, n6), n6 !== cr && this.setPrevVertex(n6, s4);
    if (this.hasCurves() && s4 !== cr && n6 !== cr) {
      const i2 = this.getVertexIndex(t3), r = this.getVertexIndex(s4), o = this.getVertexIndex(n6);
      if (e5) {
        const t4 = this.getSegmentFromIndex(r);
        if (null !== t4) {
          const e6 = this.m_vertices.getXY(o);
          t4.setEndXY(e6), t4.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(i2, null);
      } else {
        const t4 = this.getSegmentFromIndex(i2);
        if (this.setSegmentToIndex(i2, null), null !== t4) {
          const e6 = this.m_vertices.getXY(r);
          t4.setStartXY(e6), t4.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(r, t4);
      }
    }
    return this.freeVertex(t3), n6;
  }
  isRingAreaValid(t3) {
    return !!(4 & this.getPathFlags(t3));
  }
  setRingAreaValid(t3, e5) {
    const s4 = (4 | this.getPathFlags(t3)) - 4;
    this.setPathFlags(t3, s4 | (e5 ? 4 : 0));
  }
  compareVerticesSimpleY(t3, e5) {
    return this.queryXY(t3, this.m_workPoint2D), this.queryXY(e5, this.m_workPoint2_2D), this.m_workPoint2D.compare(this.m_workPoint2_2D);
  }
  compareVerticesSimpleY3D(t3, e5) {
    return this.getXYZ(t3).compare(this.getXYZ(e5));
  }
  compareVerticesSimpleX(t3, e5) {
    return this.getXY(t3).compareX(this.getXY(e5));
  }
  sortVerticesSimpleByYHeapMerge(t3, e5) {
    n2(0);
  }
  sortVerticesSimpleByY(t3, e5, s4) {
    this.m_bucketSort.sort(t3, e5, s4, new dr(this));
  }
  sortVerticesSimpleByX(t3, e5, n6) {
    n2(0);
  }
  sortVerticesSimpleByY3D(t3, e5, n6) {
    n2(0);
  }
  snapVertexForPoleClipping(t3, e5) {
    const s4 = this.getPrevVertex(t3);
    s4 !== cr && this.replaceCurveWithLine(s4);
    this.getNextVertex(t3) !== cr && this.replaceCurveWithLine(t3);
    const n6 = new mi();
    this.queryXY(t3, n6), n6.y = e5, this.setXY(t3, n6);
  }
  setSegmentParentageAndBreak(t3, e5, n6 = true) {
    if (-1 === this.m_segmentParentageIndex) {
      if (-1 === e5) return;
      this.m_segmentParentageIndex = this.createUserIndex();
    }
    e5 >= 0 && (n2(e5 <= vs() >> 1), e5 <<= 1, e5 |= n6 ? 1 : 0), this.setUserIndex(t3, this.m_segmentParentageIndex, e5);
  }
  setSegmentParentagePreserveBreak(t3, e5) {
    if (n2(e5 >= -1), -1 === this.m_segmentParentageIndex) {
      if (-1 === e5) return;
      this.m_segmentParentageIndex = this.createUserIndex();
    }
    if (e5 >= 0) {
      n2(e5 <= vs() >> 1), e5 <<= 1;
      e5 |= this.getSegmentParentageBreakVertex(t3) ? 1 : 0;
    }
    this.setUserIndex(t3, this.m_segmentParentageIndex, e5);
  }
  getSegmentParentage(t3) {
    if (-1 === this.m_segmentParentageIndex) return -1;
    const e5 = this.getUserIndex(t3, this.m_segmentParentageIndex);
    return e5 < 0 ? e5 : e5 >> 1;
  }
  getOriginalSegmentInfo(t3) {
    if (-1 !== this.m_segmentParentageIndex) {
      const e5 = this.getSegmentParentage(t3);
      return new fr(e5);
    }
    return new fr(-1);
  }
  setSegmentParentageBreakVertex(t3, e5) {
    if (-1 === this.m_segmentParentageIndex) return;
    let s4 = this.getUserIndex(t3, this.m_segmentParentageIndex);
    s4 < 0 || !!(1 & s4) !== e5 && (e5 ? s4 |= 1 : s4 &= vs() >> 1 << 1, this.setUserIndex(t3, this.m_segmentParentageIndex, s4));
  }
  getSegmentParentageBreakVertex(t3) {
    if (-1 === this.m_segmentParentageIndex) return true;
    const e5 = this.getUserIndex(t3, this.m_segmentParentageIndex);
    return e5 < 0 || !!(1 & e5);
  }
  isDiscontinuousSegmentParentage(t3) {
    const e5 = this.getPrevVertex(t3);
    if (e5 === cr) return false;
    return this.getSegmentParentage(e5) !== this.getSegmentParentage(t3);
  }
  setCurveStitcherPointer(t3) {
    this.m_curveStitcher = t3;
  }
  hasSegmentParentage() {
    return -1 !== this.m_segmentParentageIndex;
  }
  deleteSegmentParentage() {
    -1 !== this.m_segmentParentageIndex && (this.removeUserIndex(this.m_segmentParentageIndex), this.m_segmentParentageIndex = -1), this.m_curveStitcher = null;
  }
  clearSegments() {
    this.m_segments = null;
  }
};
function yr(t3) {
  if (t3.isEmpty()) return new ur({ vd: t3.getDescription() });
  if (h(t3.getGeometryType()) && t3.hasNonLinearSegments()) return Cr(t3);
  const e5 = t3.getImpl(), s4 = e5.getPointCount();
  if (s4 <= 2) {
    if (1 === s4 || e5.getXY(0).equals(e5.getXY(1))) {
      const t4 = new ee({ vd: e5.getDescription() });
      return e5.getPointByVal(0, t4), t4;
    }
    {
      const t4 = new ee(), s5 = new Os2({ vd: e5.getDescription() });
      return e5.getPointByVal(0, t4), s5.startPathPoint(t4), e5.getPointByVal(1, t4), s5.lineToPoint(t4), s5;
    }
  }
  const n6 = e5.getAttributeStreamRef(0), i2 = new wr({ stream: n6, n: s4 });
  let r = 0, o = 1;
  const a2 = n6.readPoint2D(r << 1), h2 = new mi();
  for (; o < s4 && n6.queryPoint2D(o << 1, h2).equals(a2); ) o++;
  if (i2.m_treeHull.addElement(r), o < s4) {
    i2.m_treeHull.addBiggestElement(o);
    const t4 = new mi();
    for (let s5 = o + 1; s5 < e5.getPointCount(); s5++) {
      n6.queryPoint2D(s5 << 1, t4);
      const e6 = i2.treeHull(t4);
      -1 !== e6 && i2.m_treeHull.setElement(e6, s5);
    }
  }
  const u = e5.getDescription(), m3 = u.getAttributeCount() > 1, l2 = i2.m_treeHull.size();
  let g2 = null;
  if (l2 >= 2) {
    g2 = l2 >= 3 ? new ur({ vd: u }) : new Os2({ vd: u });
    const t4 = g2.getImpl();
    t4.reserve(i2.m_treeHull.size()), t4.addPathPoint2D(null, 0, true);
    const s5 = new mi();
    for (let r2 = i2.m_treeHull.getFirst(); -1 !== r2; r2 = i2.m_treeHull.getNext(r2)) if (m3) {
      const s6 = new ee();
      e5.getPointByVal(i2.m_treeHull.getElement(r2), s6), t4.insertPoint(0, -1, s6);
    } else n6.queryPoint2D(i2.m_treeHull.getElement(r2) << 1, s5), t4.insertPoint2D(0, -1, s5);
  } else if (m3) {
    const t4 = new ee({ vd: u });
    e5.getPointByVal(i2.m_treeHull.getElement(i2.m_treeHull.getFirst()), t4), g2 = t4;
  } else {
    const t4 = n6.readPoint2D(i2.m_treeHull.getElement(i2.m_treeHull.getFirst()) << 1);
    g2 = new ee(t4);
  }
  return g2;
}
function xr(t3, e5, s4, n6 = false) {
  if (e5 <= 262144) return Ir(t3, e5, s4, n6);
  const i2 = new wr({ points: t3, n: e5 }), r = 0;
  let o = 1;
  const a2 = t3[r];
  for (; o < e5 && t3[o].equals(a2); ) o++;
  if (i2.m_treeHull.addElement(r), o < e5) {
    i2.m_treeHull.addBiggestElement(o);
    for (let s5 = o + 1; s5 < e5; s5++) {
      const e6 = t3[s5], n7 = i2.treeHull(e6);
      -1 !== n7 && i2.m_treeHull.setElement(n7, s5);
    }
  }
  let h2 = 0;
  for (let u = i2.m_treeHull.getFirst(); -1 !== u; u = i2.m_treeHull.getNext(u)) s4[h2++] = i2.m_treeHull.getElement(u);
  return h2;
}
function Cr(t3) {
  n2(t3.hasNonLinearSegments() && !t3.isEmpty());
  const e5 = new wr();
  return e5.addGeometry(t3), e5.getBoundingGeometry();
}
function vr(t3, s4, n6) {
  if ((s4 < 0 || s4 >= t3.getPathCount()) && P("path index"), t3.hasNonLinearSegmentsPath(s4)) return false;
  const i2 = t3.getImpl(), r = i2.getPathStart(s4), o = i2.getPathEnd(s4), a2 = !i2.isClosedPath(s4) && i2.isClosedPathInXYPlane(s4), h2 = i2.getAttributeStreamRef(0), u = 2 * r;
  let m3 = 2 * o;
  if (a2 && (m3 -= 2), m3 - u < 6) return true;
  const l2 = h2.readPoint2D(u), c = h2.readPoint2D(u + 2), g2 = h2.readPoint2D(u + 4);
  if (!Mr(mi.orientationRobust(c, g2, l2))) return false;
  const d2 = c.clone(), _ = new mi();
  for (let e5 = u + 6; e5 < m3; e5 += 2) {
    _.assign(c), c.assign(g2), h2.queryPoint2D(e5, g2);
    if (!Mr(mi.orientationRobust(c, g2, l2))) return false;
    if (!Mr(mi.orientationRobust(d2, g2, l2))) return false;
    if (!Mr(mi.orientationRobust(c, g2, _))) return false;
  }
  return true;
}
function br(t3, e5, s4) {
  t3.setNAN(), e5.setCoords(1, 0), s4.setCoords(0, 0);
}
function Sr(t3, e5, s4, n6, r) {
  if (br(s4, n6, r), t3.isEmpty()) return;
  if (t3.getGeometryType() === a.enumPoint) return void s4.assign(t3.getXY());
  const o = t3, a2 = o.getPointCount();
  0 !== a2 && (1 !== a2 ? Er(o, a2, e5, s4, n6, r) : s4.assign(o.getXY(0)));
}
function Er(t3, e5, s4, n6, i2, r) {
  if (2 === e5) {
    const e6 = t3.getXY(0), s5 = t3.getXY(1);
    n6.assign(e6.add(s5).mul(0.5));
    const o = s5.sub(e6);
    i2 = Xr(o), r.setCoords(0.5 * o.length(), 0);
  } else {
    let o = Number.MAX_VALUE;
    const a2 = [0, 1, 0, 0], h2 = new Xt(4, 2);
    for (h2.set(0, 0, 0), h2.set(0, 1, 1), h2.set(1, 0, 1), h2.set(1, 1, 2); a2[0] < e5; ++a2[0], qr(h2, 0, e5)) {
      a2[1] === a2[0] && (++a2[1], qr(h2, 1, e5));
      for (let s5 = 1; ; ++s5) {
        for (; ; ) {
          const n7 = Fr(t3.getXY(h2.get(0, 0)), t3.getXY(h2.get(0, 1)), t3.getXY(h2.get(s5, 0)), t3.getXY(h2.get(s5, 1)), 2 ^ s5);
          if (n7 > 0) break;
          if (++a2[s5], qr(h2, s5, e5), 0 === n7) break;
        }
        if (3 === s5) break;
        a2[s5 + 1] < a2[s5] && (a2[s5 + 1] = a2[s5], h2.set(s5 + 1, 0, h2.get(s5, 0)), h2.set(s5 + 1, 1, h2.get(s5, 1)));
      }
      const u = t3.getXY(h2.get(0, 0)).add(t3.getXY(h2.get(2, 0))).mul(0.5), m3 = Xr(t3.getXY(h2.get(0, 1)).sub(t3.getXY(h2.get(0, 0)))), l2 = new mi();
      let c, g2;
      if (l2.x = Math.max(0, m3.dotProduct(t3.getXY(h2.get(1, 0)).sub(t3.getXY(h2.get(3, 0))))), l2.y = Math.max(0, m3.crossProduct(t3.getXY(h2.get(0, 0)).sub(t3.getXY(h2.get(2, 0))))), s4 ? (c = l2.x * l2.y, g2 = c < o) : (c = l2.y, g2 = c < o), g2) {
        o = c;
        const e6 = t3.getXY(h2.get(1, 0)), s5 = t3.getXY(h2.get(3, 0)), a3 = e6.add(s5).mul(0.5).sub(u);
        n6.assign(u.add(m3.mul(m3.dotProduct(a3)))), i2.assign(m3), r.assign(l2);
      }
    }
    r.mulThis(0.5), r.x < r.y && (r.y = Pt(r.x, r.x = r.y), i2.leftPerpendicularThis());
  }
  i2.y < 0 ? i2.negateThis() : 0 === i2.y && (i2.x = 1);
}
Pr.st_defaultRank = 1;
var Dr = class {
  constructor(t3) {
    this.m_handleP = -1, this.m_handleQ = -1, this.m_currentSupport = -1, this.m_area = 0, this.m_bDone = true, n2(0), this.m_convexHull = t3, this.m_function = this.done_;
  }
  next() {
    return n2(0), false;
  }
  get_vertex_handle_p() {
    return n2(0), 0;
  }
  get_vertex_handle_q() {
    return n2(0), 0;
  }
  get_current_support() {
    return n2(0), 0;
  }
  getNext(t3) {
    return n2(0), 0;
  }
  getPrev(t3) {
    return n2(0), 0;
  }
  intialize_() {
    return n2(0), false;
  }
  increment_() {
    return n2(0), false;
  }
  increment_q_() {
    return n2(0), false;
  }
  increment_p_() {
    return n2(0), false;
  }
  parallel_edge_with_q_support_() {
    return n2(0), false;
  }
  parallel_edge_with_p_support_() {
    return n2(0), false;
  }
  done_() {
    return n2(0), false;
  }
};
var wr = class _wr {
  nullGetXY(t3) {
    return b("m_getXY is null"), {};
  }
  nullDeleteNode(t3) {
    b("m_deleteNode is null");
  }
  constructor(t3) {
    return this.m_treeHull = new ct2(), this.m_shape = null, this.m_stream = null, this.m_points = null, this.m_geometryHandle = -1, this.m_pathHandle = -1, this.m_getXY = this.nullGetXY, this.m_deleteNode = this.nullDeleteNode, t3 ? t3.stream ? (this.m_treeHull.setCapacity(Math.min(20, t3.n)), this.m_stream = t3.stream, this.m_getXY = this.getXYStream, this.m_deleteNode = this.deleteNodeStream, this.m_points = null, this.m_geometryHandle = cr, void (this.m_pathHandle = cr)) : t3.points ? (this.m_treeHull.setCapacity(Math.min(20, t3.n)), this.m_points = t3.points, this.m_getXY = this.getXYPoints, this.m_deleteNode = this.deleteNodePoints, this.m_stream = null, this.m_geometryHandle = cr, void (this.m_pathHandle = cr)) : void C("unrecognized constructor parameter") : (this.m_treeHull.setCapacity(20), this.m_shape = new Pr(), this.m_geometryHandle = this.m_shape.createGeometry(a.enumMultiPoint), this.m_pathHandle = this.m_shape.insertPath(this.m_geometryHandle, cr), this.m_getXY = this.getXYShape, this.m_deleteNode = this.deleteNodeShape, this.m_stream = null, void (this.m_points = null));
  }
  getXYShape(t3) {
    return this.m_shape.getXY(t3);
  }
  getXYStream(t3) {
    return this.m_stream.readPoint2D(t3 << 1);
  }
  getXYPoints(t3) {
    return n2(0), new mi();
  }
  deleteNodeShape(t3) {
    const e5 = this.m_treeHull.getElement(t3);
    this.m_treeHull.deleteNode(t3), this.m_shape.removeVertex(e5, false);
  }
  deleteNodeStream(t3) {
    this.m_treeHull.deleteNode(t3);
  }
  deleteNodePoints(t3) {
    n2(0);
  }
  addGeometry(s4) {
    if (s4.isEmpty()) return;
    const n6 = s4.getGeometryType();
    if (n6 === a.enumGeometryCollection) {
      const t3 = s4;
      for (let e5 = 0, s5 = t3.getGeometryCount(); e5 < s5; e5++) this.addGeometry(t3.getGeometry(e5));
    } else y(n6) ? this.addMultiVertexGeometry(s4) : f(n6) ? this.addSegment(s4, false) : n6 === a.enumEnvelope ? this.addEnvelope(s4) : n6 === a.enumPoint ? this.addPoint(s4) : P("Convex_hull: geometry not supported");
  }
  getBoundingGeometry() {
    const t3 = new ee(), e5 = this.m_treeHull.getFirst(), s4 = new ur({ vd: this.m_shape.getVertexDescription() });
    if (0 === this.m_treeHull.size()) return s4;
    s4.reserve(this.m_treeHull.size()), this.m_shape.queryPoint(this.m_treeHull.getElement(e5), t3), s4.startPathPoint(t3);
    for (let n6 = this.m_treeHull.getNext(e5); -1 !== n6; n6 = this.m_treeHull.getNext(n6)) this.m_shape.queryPoint(this.m_treeHull.getElement(n6), t3), s4.lineToPoint(t3);
    return s4;
  }
  getAntipodalPairsIterator() {
    return n2(0), new Dr(this);
  }
  getXY(t3) {
    return n2(0), new mi();
  }
  getXYWithIndex(t3) {
    return n2(0), new mi();
  }
  getFirst() {
    return n2(0), 0;
  }
  getLast() {
    return n2(0), 0;
  }
  getNext(t3) {
    return n2(0), 0;
  }
  getPrev(t3) {
    return n2(0), 0;
  }
  getVertexIndex(t3) {
    return n2(0), 0;
  }
  getPointCount() {
    return n2(0), 0;
  }
  addMultiVertexGeometry(t3) {
    const e5 = new ee(), s4 = t3.getImpl(), n6 = new mi();
    for (let i2 = 0; i2 < t3.getPointCount(); i2++) {
      s4.queryXY(i2, n6);
      const r = this.addPoint2D(n6);
      if (-1 !== r) {
        t3.getPointByVal(i2, e5);
        const s5 = this.m_shape.addPoint(this.m_pathHandle, e5);
        this.m_treeHull.setElement(r, s5);
      }
    }
    if (h(t3.getGeometryType())) {
      const e6 = t3;
      if (e6.hasNonLinearSegments()) {
        const t4 = e6.querySegmentIterator();
        for (; t4.nextPath(); ) for (; t4.hasNextSegment(); ) {
          const e7 = t4.nextCurve();
          null !== e7 && this.addSegment(e7, true);
        }
      }
    }
  }
  addEnvelope(t3) {
    const e5 = new ee();
    for (let s4 = 0; s4 < 4; s4++) {
      const n6 = new mi();
      t3.queryCorner(s4, n6);
      const i2 = this.addPoint2D(n6);
      if (-1 !== i2) {
        t3.queryCornerByVal(s4, e5);
        const n7 = this.m_shape.addPoint(this.m_pathHandle, e5);
        this.m_treeHull.setElement(i2, n7);
      }
    }
  }
  static querySegmentControlPoints(t3, n6, r) {
    const o = t3.getGeometryType();
    if (n2(o !== a.enumLine), o === a.enumEllipticArc) {
      const e5 = t3, s4 = 60 * Math.PI / 180, i2 = Math.abs(e5.getSweepAngle());
      if (i2 > s4) {
        const t4 = Math.min(6, Math.ceil(i2 / s4)), r2 = 1 / t4, o2 = new fm();
        e5.queryStart(n6[0]);
        let a2 = 1;
        for (let s5 = 0; s5 < t4; s5++) {
          e5.queryCut(s5 * r2, (s5 + 1) * r2, o2);
          const i3 = Ot(mi, 3);
          Bu(o2.get(), i3);
          const h2 = mi.calculateLength(i3, 3), u = mi.calculateLength(i3, 2), m3 = h2 > 0 ? u / h2 : 0.5;
          s5 < t4 - 1 ? o2.get().queryEnd(n6[a2 + 1]) : e5.queryEnd(n6[a2 + 1]), ee.lerp(n6[a2 - 1], n6[a2 + 1], m3, n6[a2]), n6[a2].setXY(i3[1]), a2 += 2;
        }
        return a2;
      }
      {
        const e6 = Ot(mi, 3);
        Bu(t3, e6);
        const s5 = mi.calculateLength(e6, 3);
        t3.queryStart(n6[0]), t3.queryEnd(n6[2]);
        const i3 = mi.calculateLength(e6, 2), r2 = s5 > 0 ? i3 / s5 : 0.5;
        return ee.lerp(n6[0], n6[2], r2, n6[1]), n6[1].setXY(e6[1]), 3;
      }
    }
    if (o === a.enumBezier) {
      const e5 = t3, s4 = Ot(mi, 4);
      e5.queryControlPoints(s4);
      const i2 = mi.calculateLength(s4, 4), r2 = mi.calculateLength(s4, 2), o2 = mi.calculateLength(s4, 3);
      t3.queryStart(n6[0]), t3.queryEnd(n6[3]);
      const a2 = i2 > 0 ? r2 / i2 : 0.5;
      ee.lerp(n6[0], n6[3], a2, n6[1]), n6[1].setXY(s4[1]);
      const h2 = i2 > 0 ? o2 / i2 : 0.5;
      return ee.lerp(n6[0], n6[3], h2, n6[2]), n6[2].setXY(s4[2]), 4;
    }
    if (o === a.enumBezier2) {
      const e5 = t3, s4 = Ot(mi, 3);
      e5.queryControlPoints(s4);
      const i2 = mi.calculateLength(s4, 3);
      t3.queryStart(n6[0]), t3.queryEnd(n6[2]);
      const r2 = mi.calculateLength(s4, 2), o2 = i2 > 0 ? r2 / i2 : 0.5;
      return ee.lerp(n6[0], n6[2], o2, n6[1]), n6[1].setXY(s4[1]), 3;
    }
    if (o === a.enumRationalBezier2) {
      const e5 = t3, s4 = Ot(mi, 3);
      e5.queryControlPoints(s4);
      const i2 = mi.calculateLength(s4, 3);
      t3.queryStart(n6[0]), t3.queryEnd(n6[2]);
      const r2 = mi.calculateLength(s4, 2), o2 = i2 > 0 ? r2 / i2 : 0.5;
      return ee.lerp(n6[0], n6[2], o2, n6[1]), n6[1].setXY(s4[1]), 3;
    }
    P("Convex_hull: segment type not supported");
  }
  addSegment(t3, e5) {
    if (!e5) {
      const e6 = new ee(), s4 = t3.getStartXY(), n6 = this.addPoint2D(s4);
      if (-1 !== n6) {
        t3.queryStart(e6);
        const s5 = this.m_shape.addPoint(this.m_pathHandle, e6);
        this.m_treeHull.setElement(n6, s5);
      }
      const i2 = t3.getEndXY(), r = this.addPoint2D(i2);
      if (-1 !== r) {
        t3.queryEnd(e6);
        const s5 = this.m_shape.addPoint(this.m_pathHandle, e6);
        this.m_treeHull.setElement(r, s5);
      }
    }
    if (t3.isCurve()) {
      const e6 = Ot(ee, 13);
      for (let s4 = 1, n6 = _wr.querySegmentControlPoints(t3, e6, e6.length) - 1; s4 < n6; ++s4) {
        const t4 = e6[s4].getXY(), n7 = this.addPoint2D(t4);
        if (-1 !== n7) {
          const t5 = this.m_shape.addPoint(this.m_pathHandle, e6[s4]);
          this.m_treeHull.setElement(n7, t5);
        }
      }
    }
  }
  addPoint(t3) {
    const e5 = t3.getXY(), s4 = this.addPoint2D(e5);
    if (-1 !== s4) {
      const e6 = this.m_shape.addPoint(this.m_pathHandle, t3);
      this.m_treeHull.setElement(s4, e6);
    }
  }
  addPoint2D(t3) {
    let e5 = -1;
    if (0 === this.m_treeHull.size()) return e5 = this.m_treeHull.addElement(-4), e5;
    if (1 === this.m_treeHull.size()) {
      const s4 = this.m_treeHull.getElement(this.m_treeHull.getFirst()), n6 = this.m_shape.getXY(s4);
      return t3.equals(n6) || (e5 = this.m_treeHull.addBiggestElement(-5)), e5;
    }
    return e5 = this.treeHull(t3), e5;
  }
  treeHull(t3) {
    let e5 = -1;
    do {
      const s4 = this.m_treeHull.getFirst(), n6 = this.m_treeHull.getLast(), i2 = this.m_treeHull.getElement(s4), r = this.m_treeHull.getElement(n6), o = this.m_getXY(i2), a2 = this.m_getXY(r), h2 = mi.orientationRobust(a2, t3, o);
      if (Mr(h2)) {
        e5 = this.m_treeHull.addBiggestElement(-1);
        const i3 = this.treeHullWalkBackward(t3, n6, s4);
        i3 !== s4 && this.treeHullWalkForward(t3, s4, this.m_treeHull.getPrev(i3));
        break;
      }
      if (Yr(h2)) {
        let i3 = this.m_treeHull.getRoot(), r2 = this.m_treeHull.getFirst(), a3 = this.m_treeHull.getLast(), h3 = -1, u = -1, m3 = -1;
        for (; r2 !== this.m_treeHull.getPrev(a3); ) {
          u = this.m_treeHull.getElement(i3);
          const e6 = this.m_getXY(u);
          Yr(mi.orientationRobust(e6, t3, o)) ? (a3 = i3, i3 = this.m_treeHull.getLeft(i3)) : (r2 = i3, i3 = this.m_treeHull.getRight(i3));
        }
        i3 = a3, h3 = r2, u = this.m_treeHull.getElement(i3), m3 = this.m_treeHull.getElement(h3);
        const l2 = this.m_getXY(u), c = this.m_getXY(m3);
        if (h3 !== s4) {
          if (!Mr(mi.orientationRobust(c, t3, l2))) break;
        }
        e5 = this.m_treeHull.addElementAtPosition(h3, i3, -2, true, false), this.treeHullWalkForward(t3, i3, n6), this.treeHullWalkBackward(t3, h3, s4);
        break;
      }
      {
        const i3 = Nr(t3, a2, o);
        if (-1 === i3) {
          const i4 = this.m_treeHull.getPrev(n6);
          this.m_treeHull.deleteNode(n6), e5 = this.m_treeHull.addBiggestElement(-3), this.treeHullWalkBackward(t3, i4, s4);
        } else if (1 === i3) {
          const i4 = this.m_treeHull.getNext(s4);
          this.m_treeHull.deleteNode(s4), e5 = this.m_treeHull.addElementAtPosition(-1, i4, -3, true, false), this.treeHullWalkForward(t3, i4, n6);
        }
        break;
      }
    } while (0);
    return e5;
  }
  treeHullWalkForward(t3, e5, s4) {
    if (e5 === s4) return s4;
    let n6 = e5, i2 = this.m_treeHull.getElement(n6), r = this.m_treeHull.getNext(n6);
    const o = this.m_getXY(i2);
    for (; n6 !== s4 && this.m_treeHull.size() > 2; ) {
      const e6 = this.m_treeHull.getElement(r), s5 = this.m_getXY(e6);
      if (Mr(mi.orientationRobust(s5, t3, o))) break;
      const a2 = n6;
      n6 = r, i2 = e6, o.assign(s5), r = this.m_treeHull.getNext(n6), this.m_deleteNode(a2);
    }
    return n6;
  }
  treeHullWalkBackward(t3, e5, s4) {
    if (e5 === s4) return s4;
    let n6 = e5, i2 = this.m_treeHull.getElement(n6), r = this.m_treeHull.getPrev(n6);
    const o = this.m_getXY(i2);
    for (; n6 !== s4 && this.m_treeHull.size() > 2; ) {
      const e6 = this.m_treeHull.getElement(r), s5 = this.m_getXY(e6);
      if (Mr(mi.orientationRobust(o, t3, s5))) break;
      const a2 = n6;
      n6 = r, i2 = e6, o.assign(s5), r = this.m_treeHull.getPrev(n6), this.m_deleteNode(a2);
    }
    return n6;
  }
};
function Ar(t3, e5, s4) {
  const n6 = e5.sub(t3), i2 = s4.sub(e5);
  if (0 === n6.x) return i2.x > 0 ? -1 : 0;
  if (0 === n6.y) return i2.y > 0 ? 1 : i2.y < 0 ? -1 : 0;
  const r = n6.crossProduct(i2), o = 4 * Number.EPSILON * (Math.abs(i2.x * n6.y) + Math.abs(i2.y * n6.x));
  return r > o ? 1 : r < -o ? -1 : mi.orientationRobust(t3, e5, s4);
}
function Tr(t3, e5, s4) {
  const n6 = e5.sub(t3), i2 = s4.sub(e5);
  if (0 === n6.x) return i2.x < 0 ? -1 : 0;
  if (0 === n6.y) return i2.y > 0 ? -1 : i2.y < 0 ? 1 : 0;
  const r = n6.crossProduct(i2), o = 4 * Number.EPSILON * (Math.abs(i2.x * n6.y) + Math.abs(i2.y * n6.x));
  return r > o ? 1 : r < -o ? -1 : mi.orientationRobust(t3, e5, s4);
}
function Ir(t3, e5, s4, n6) {
  const i2 = new st2(0);
  for (let h2 = 0; h2 < e5; h2++) i2.add(h2);
  const r = { userSort(e6, s5, n7) {
    n7.sort(e6, s5, (e7, s6) => t3[e7].compareX(t3[s6]));
  }, getValue: (e6) => t3[e6].x };
  n6 || ot.sortEx(i2, 0, e5, r);
  let o = 0;
  t: for (let h2 = 0; h2 < e5; ++h2) {
    const e6 = i2.read(h2);
    for (; o >= 2; ) {
      const n7 = s4[o - 2], r2 = s4[o - 1];
      if (t3[r2].equals(t3[e6])) {
        i2.write(h2, -1);
        continue t;
      }
      if (!(Ar(t3[n7], t3[r2], t3[e6]) >= 0)) {
        r2 === i2.read(h2 - 1) && i2.write(h2 - 1, -1);
        break;
      }
      o--;
    }
    s4[o++] = e6, 2 === o && t3[e6].equals(t3[s4[0]]) && (i2.write(1, -1), o--);
  }
  const a2 = o + 1;
  t: for (let h2 = e5 - 2; h2 >= 0; --h2) {
    const e6 = i2.read(h2);
    if (!(e6 < 0)) {
      for (; o >= a2; ) {
        const n7 = s4[o - 2], i3 = s4[o - 1];
        if (t3[i3].equals(t3[e6])) continue t;
        if (!(Tr(t3[n7], t3[i3], t3[e6]) >= 0)) break;
        o--;
      }
      if (0 !== h2) {
        const n7 = s4[o - 1];
        s4[o++] = e6, t3[e6].equals(t3[n7]) && o--;
      }
    }
  }
  return o > 1 && t3[s4[0]].equals(t3[s4[o - 1]]) && o--, o;
}
function Mr(t3) {
  return t3 < 0;
}
function Yr(t3) {
  return t3 > 0;
}
function Nr(t3, e5, s4) {
  let n6 = -1;
  if (e5.y === s4.y) n6 = 0;
  else if (e5.x === s4.x) n6 = 1;
  else {
    n6 = Math.abs(e5.x - s4.x) >= Math.abs(e5.y - s4.y) ? 0 : 1;
  }
  let i2 = -1;
  return i2 = e5[n6] < s4[n6] ? t3[n6] < e5[n6] ? -1 : s4[n6] < t3[n6] ? 1 : 0 : e5[n6] < t3[n6] ? -1 : t3[n6] < s4[n6] ? 1 : 0, i2;
}
function Xr(t3) {
  return (t3 = t3.clone()).divThis(Math.max(Math.abs(t3.x), Math.abs(t3.y))), t3.normalize(), t3;
}
function qr(t3, e5, s4) {
  t3.inc(e5, 0) === s4 && t3.set(e5, 0, 0), t3.inc(e5, 1) === s4 && t3.set(e5, 1, 0);
}
function Fr(t3, s4, n6, i2, r) {
  switch (r) {
    case 0:
      break;
    case 1:
      s4.rightPerpendicularThis(), t3.rightPerpendicularThis();
      break;
    case 2:
      s4.negateThis(), t3.negateThis();
      break;
    case 3:
      s4.leftPerpendicularThis(), t3.leftPerpendicularThis();
      break;
    default:
      P("");
  }
  return mi.orientationRobustEx(t3, s4, n6, i2);
}
var Vr = class {
  constructor() {
    this.length = Number.NaN, this.specialPoints = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
function Lr(t3) {
  return Rr(t3.calculateUpperLength2D());
}
function Rr(t3) {
  return 256 * Qs() * t3;
}
function zr(t3) {
  const e5 = mi.distance(t3.getStartXY(), t3.getEndXY()), s4 = t3.calculateUpperLength2D();
  return s4 - e5 <= 8 * Number.EPSILON * s4;
}
function Br(t3, e5, s4 = false) {
  e5[1].setCoords(t3.m_cp[0].x - t3.getStartX(), t3.m_cp[0].y - t3.getStartY()), e5[1].mulThis(3), e5[2].setCoords(t3.m_cp[1].x - t3.m_cp[0].x, t3.m_cp[1].y - t3.m_cp[0].y), e5[2].mulThis(3), e5[3] = t3.getEndXY().sub(t3.getStartXY()), e5[3].subThis(e5[2]), e5[2].subThis(e5[1]), s4 ? e5[0].setCoords(0, 0) : e5[0] = t3.getStartXY();
}
function kr(t3, e5, s4) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6), Wr(n6, e5, s4);
}
function Gr(t3, e5, s4) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6), jr(n6, e5, s4);
}
function Wr(t3, e5, s4) {
  let n6 = t3[1].x;
  n6 -= t3[0].x, n6 *= 3;
  let i2 = t3[2].x;
  i2 -= t3[1].x, i2 *= 3;
  let r = t3[3].x;
  r -= t3[0].x, r -= i2, i2 -= n6, e5[3].setWithEps(r), e5[2].setWithEps(i2), e5[1].setWithEps(n6), s4 ? e5[0].set(0) : e5[0].set(t3[0].x);
}
function jr(t3, e5, s4) {
  let n6 = t3[1].y;
  n6 -= t3[0].y, n6 *= 3;
  let i2 = t3[2].y;
  i2 -= t3[1].y, i2 *= 3;
  let r = t3[3].y;
  r -= t3[0].y, r -= i2, i2 -= n6, e5[3].setWithEps(r), e5[2].setWithEps(i2), e5[1].setWithEps(n6), s4 ? e5[0].set(0) : e5[0].set(t3[0].y);
}
function Zr(t3, e5, s4 = false) {
  const n6 = Ot(Xe, 4);
  n6[0].assignPoint2D(t3[0]), n6[1].assignPoint2D(t3[1]), n6[2].assignPoint2D(t3[2]), n6[3].assignPoint2D(t3[3]), e5[1].setCoords(n6[1].x.sub(n6[0].x), n6[1].y.sub(n6[0].y)), e5[1].mulThis(si.constructInt32(3)), e5[2].setCoords(n6[2].x.sub(n6[1].x), n6[2].y.sub(n6[1].y)), e5[2].mulThis(si.constructInt32(3)), e5[3] = n6[3].sub(n6[0]), e5[3] = e5[3].sub(e5[2]), e5[2] = e5[2].sub(e5[1]), s4 ? e5[0].setCoords(ei, ei) : e5[0] = n6[0].clone();
}
function Hr(t3, e5, s4) {
  if (s4) {
    if (e5 < 0) return e5;
    if (e5 > 1) return e5 - 1 + Hr(t3, 1, false);
  }
  if (t3.isDegenerate(0)) return 0;
  const n6 = 1 === e5, i2 = Qr(t3);
  if (n6 && !Number.isNaN(i2.length) && !Number.isNaN(i2.length)) return i2.length;
  const r = Lr(t3), o = r / t3.calculateUpperLength2D();
  let a2 = 0, h2 = 0;
  for (let u = 1, m3 = i2.specialPointsCount(); u < m3; u++) {
    const s5 = i2.specialPoints[u];
    if (a2 += $o(t3, h2, Math.min(e5, s5), o, r), e5 <= s5) break;
    h2 = s5;
  }
  return n6 && (i2.length = a2), a2;
}
function Ur(t3, e5, s4) {
  const n6 = Hr(t3, 1, false);
  if (e5 <= 0) return e5;
  if (e5 >= n6) return e5 - n6 + 1;
  const i2 = [0];
  return 1 !== tn(new Jo(t3, e5), x2.unit(), 1, i2) && b(""), i2[0];
}
function Or(t3, s4, n6) {
  void 0 === n6 && (n6 = s4, s4 = 0);
  const i2 = new mi();
  if (s4 < 0 || n6 > 1) return i2.setNAN(), i2;
  if (s4 > n6 && P("calculate_sub_weightedCentroid"), s4 === n6 || t3.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = Qr(t3), o = Lr(t3), a2 = o / t3.calculateUpperLength2D();
  let h2 = s4, u = 0;
  for (let e5 = 1, m3 = r.specialPointsCount(); e5 < m3; e5++) if (s4 < r.specialPoints[e5]) {
    u = e5 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let e5 = u + 1, m3 = r.specialPointsCount(); e5 < m3; e5++) {
    const s5 = Math.min(r.specialPoints[e5], n6), u2 = ta(t3, h2, s5, a2, o);
    if (i2.addThis(u2), h2 = s5, n6 <= r.specialPoints[e5]) break;
  }
  return i2.add(t3.getStartXY().mul(t3.calculateLength2D()));
}
function Qr(t3) {
  if (t3.m_cachedValues) return t3.m_cachedValues;
  const e5 = new Vr(), s4 = Ot(p2, 8), n6 = Ot(mi, 4);
  t3.queryControlPoints(n6);
  const i2 = jo(n6, s4);
  e5.specialPoints = [];
  for (let r = 0; r < i2; r++) e5.specialPoints.push(s4[r].value());
  return Kr(t3, e5), e5;
}
function Jr(t3) {
  let e5 = null;
  return e5 = t3.m_cachedValues, e5;
}
function Kr(t3, e5) {
  t3.m_cachedValues = e5;
}
function $r(t3) {
  t3.m_cachedValues = null;
}
function to(t3, e5) {
  e5.m_cachedValues = Pt(t3.m_cachedValues, t3.m_cachedValues = e5.m_cachedValues);
}
function eo(t3, e5, s4, n6) {
  if (e5.isEqual(t3.m_XStart, t3.m_YStart) && s4.isEqual(t3.m_XEnd, t3.m_YEnd)) return;
  const i2 = !!n6 && t3.isMonotoneQuickAndDirty(), r = new x3(), o = Ot(mi, 3);
  o[0].setCoords(t3.m_XStart, t3.m_YStart), o[2].setCoords(t3.m_XEnd, t3.m_YEnd);
  const a2 = new mi();
  a2.setSub(o[2], o[0]), a2.leftPerpendicularThis(), o[1].setAdd(o[0], a2);
  const h2 = Ot(mi, 3);
  h2[0].setCoordsPoint2D(e5), h2[2].setCoordsPoint2D(s4), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o, h2) ? r.transformPoints2D(t3.m_cp, 2, t3.m_cp) : (Y(e5, s4, 1 / 3, t3.m_cp[0]), Y(e5, s4, 2 / 3, t3.m_cp[1])), t3.changeEndPoints2D(e5, s4), i2 && lo(t3);
}
function so(t3, e5, s4, n6, i2) {
  return { tmin: t3, tmax: e5, t: s4, d: n6, pt: i2.clone() };
}
function no(t3, e5, s4, n6) {
  const i2 = Ot(mi, 4);
  t3.queryControlPoints(i2);
  const r = Yt(18, NaN), o = tn(new Vo(i2, e5, NaN), x2.construct(s4, n6), 18, r), a2 = new mi();
  t3.queryCoord2D(s4, a2);
  let h2 = s4, u = mi.distance(a2, e5);
  const m3 = new mi();
  t3.queryCoord2D(n6, m3);
  const l2 = mi.distance(m3, e5);
  l2 < u && (u = l2, h2 = n6, a2.assign(m3));
  for (let c = 0; c < o; c++) {
    t3.queryCoord2D(r[c], m3);
    const s5 = mi.distance(m3, e5);
    s5 < u && (u = s5, h2 = r[c], a2.assign(m3));
  }
  return so(s4, n6, h2, u, a2);
}
function io(t3, e5) {
  const n6 = Ot(p2, 4);
  kr(t3, n6, true);
  const i2 = Ot(p2, 4);
  Gr(t3, i2, true);
  const r = n6[3].clone(), o = n6[2].clone(), a2 = n6[1].clone(), h2 = i2[3].clone(), u = i2[2].clone(), m3 = i2[1].clone(), l2 = o.mulE(a2).addE(u.mulE(m3)).mul(4), c = o.mulE(o).mul(8).addE(r.mulE(a2).mul(12)).addE(u.mulE(u).mul(8).addE(h2.mulE(m3).mul(12))), g2 = r.mulE(o).addE(h2.mulE(u)).mul(36), d2 = r.mulE(r).addE(h2.mulE(h2)).mul(36), _ = Ot(p2, 3), p3 = dn(d2, g2, c, l2, new x2(0, 1), false, _);
  if (n2(p3 <= 3), p3 > 0) {
    const s4 = uo(t3, 1, 0).sqrLength(), n7 = uo(t3, 1, 1).sqrLength();
    let i3 = s4;
    e5.set(0), i3 < n7 && (i3 = n7, e5.set(1));
    for (let r2 = 0; r2 < p3; r2++) {
      const s5 = uo(t3, 1, _[r2].value()).sqrLength();
      s5 < i3 && (i3 = s5, e5 = _[r2]);
    }
  }
}
function ro(t3, e5, s4, n6) {
  if (1 === e5) {
    const e6 = 1 - s4, i2 = e6 * e6, r = s4 * s4, o = t3[1].sub(t3[0]), a2 = t3[2].sub(t3[1]), h2 = t3[3].sub(t3[2]), u = o.mul(i2).add(a2.mul(2 * e6 * s4)).add(h2.mul(r));
    n6.assign(u.mul(3));
  } else if (2 === e5) {
    const e6 = 1 - s4, i2 = t3[2].sub(t3[1]).sub(t3[1].sub(t3[0])), r = t3[3].sub(t3[2]).sub(t3[2].sub(t3[1])), o = i2.mul(e6).add(r.mul(s4));
    n6.assign(o.mul(6));
  } else if (3 === e5) {
    const e6 = t3[2].sub(t3[1]), s5 = t3[3].sub(e6.mul(3)).sub(t3[0]);
    n6.assign(s5.mul(6));
  } else n6.setCoords(0, 0);
}
function oo(t3, e5, s4, n6) {
  {
    const e6 = w2.subE(s4), i2 = e6.sqr(), r = s4.sqr(), o = t3[1].subE(t3[0]).mulE(i2).addE(t3[2].subE(t3[1]).mulE(new p2(2).mulE(e6).mulE(s4))).addE(t3[3].subE(t3[2]).mulE(r));
    n6.setE(o.mulE(new p2(3)));
  }
}
function ao(t3, e5, s4) {
  const n6 = new mi();
  return ro(t3, e5, s4, n6), n6;
}
function ho(t3, e5, s4) {
  const n6 = [Ye.constructPoint2D(t3[0]), Ye.constructPoint2D(t3[1]), Ye.constructPoint2D(t3[2]), Ye.constructPoint2D(t3[3])], i2 = new Ye();
  return oo(n6, e5, s4, i2), i2;
}
function uo(t3, e5, s4) {
  const n6 = Ot(mi, 4);
  return t3.queryControlPoints(n6), ao(n6, e5, s4);
}
function mo(t3) {
  const e5 = t3.m_cp[0].sub(t3.getStartXY()), s4 = t3.m_cp[1].sub(t3.m_cp[0]), n6 = t3.getEndXY().sub(t3.getStartXY());
  e5.mulThis(3), s4.mulThis(3), n6.subThis(s4), s4.subThis(e5);
  return (3 * n6.x * (2 * s4.y + 5 * e5.y) - 3 * n6.y * (2 * s4.x + 5 * e5.x) + 10 * (s4.x * e5.y - s4.y * e5.x)) / 60;
}
function lo(t3) {
  const e5 = Ot(mi, 4);
  t3.queryControlPoints(e5);
  const s4 = co(e5);
  return s4 && (t3.m_cp[0].setCoordsPoint2D(e5[1]), t3.m_cp[1].setCoordsPoint2D(e5[2]), t3.afterCompletedModification()), s4;
}
function co(t3) {
  return Fe(t3);
}
function go(t3) {
  return Ve(t3);
}
function _o(t3, e5, s4) {
  const n6 = new mi(), i2 = new mi(), r = new mi(), o = new mi(), a2 = new mi();
  e5 <= 0.5 ? (k2(2, t3[0], t3[1], e5, n6), k2(2, t3[1], t3[2], e5, i2), k2(2, t3[2], t3[3], e5, r), k2(2, n6, i2, e5, o), k2(2, i2, r, e5, a2), k2(2, o, a2, e5, s4)) : (F(2, t3[0], t3[1], e5, n6), F(2, t3[1], t3[2], e5, i2), F(2, t3[2], t3[3], e5, r), F(2, n6, i2, e5, o), F(2, i2, r, e5, a2), F(2, o, a2, e5, s4));
}
function po(t3, e5, n6, i2) {
  n2(e5 >= 0 && e5 <= 1);
  const r = new mi(), o = new mi(), a2 = new mi(), h2 = new mi(), u = new mi(), m3 = new mi();
  e5 <= 0.5 ? (k2(2, t3[0], t3[1], e5, r), k2(2, t3[1], t3[2], e5, o), k2(2, t3[2], t3[3], e5, a2), k2(2, r, o, e5, h2), k2(2, o, a2, e5, u), k2(2, h2, u, e5, m3)) : (F(2, t3[0], t3[1], e5, r), F(2, t3[1], t3[2], e5, o), F(2, t3[2], t3[3], e5, a2), F(2, r, o, e5, h2), F(2, o, a2, e5, u), F(2, h2, u, e5, m3));
  const l2 = t3[3].clone();
  n6 && (n6[0].assign(t3[0]), n6[1].assign(r), n6[2].assign(h2), n6[3].assign(m3)), i2 && (i2[0].assign(m3), i2[1].assign(u), i2[2].assign(a2), i2[3].assign(l2));
}
function fo(t3, e5, n6, i2) {
  if (n2(e5 >= 0 && n6 <= 1 && e5 <= n6), e5 === n6) {
    const s4 = new mi();
    return Po(t3, e5, s4), i2[0].assign(s4), i2[1].assign(s4), i2[2].assign(s4), void i2[3].assign(s4);
  }
  if (0 === e5 && 1 === n6) {
    for (let e6 = 0; e6 < 4; ++e6) i2[e6].assign(t3[e6]);
    return;
  }
  const r = Ot(mi, 4);
  po(t3, n6, r, null), po(r, n6 > 0 ? e5 / n6 : 0, null, r), Po(t3, e5, r[0]), Po(t3, n6, r[3]), i2[0].setCoordsPoint2D(r[0]), i2[1].setCoordsPoint2D(r[1]), i2[2].setCoordsPoint2D(r[2]), i2[3].setCoordsPoint2D(r[3]);
}
function Po(t3, e5, s4, n6) {
  if (n6) {
    if (e5 < 0) {
      return void _s2(new pm({ start: t3[0], end: t3[0].add(Co(t3, 0).getUnitVector()) }), e5, s4);
    }
    if (e5 > 1) {
      return void _s2(new pm({ start: t3[3], end: t3[3].add(Co(t3, 1).getUnitVector()) }), e5 - 1, s4);
    }
  }
  if (e5 <= 0.5) {
    const n7 = new mi();
    k2(2, t3[0], t3[1], e5, n7);
    const i2 = new mi();
    k2(2, t3[1], t3[2], e5, i2);
    const r = new mi();
    k2(2, t3[2], t3[3], e5, r);
    const o = new mi();
    k2(2, n7, i2, e5, o);
    const a2 = new mi();
    k2(2, i2, r, e5, a2), k2(2, o, a2, e5, s4);
  } else {
    const n7 = new mi();
    F(2, t3[0], t3[1], e5, n7);
    const i2 = new mi();
    F(2, t3[1], t3[2], e5, i2);
    const r = new mi();
    F(2, t3[2], t3[3], e5, r);
    const o = new mi();
    F(2, n7, i2, e5, o);
    const a2 = new mi();
    F(2, i2, r, e5, a2), F(2, o, a2, e5, s4);
  }
}
function yo(t3, e5, s4) {
  if (e5.value() <= 0.5) {
    const n6 = new Ye();
    O(2, Ye.constructPoint2D(t3[0]), Ye.constructPoint2D(t3[1]), e5, n6);
    const i2 = new Ye();
    O(2, Ye.constructPoint2D(t3[1]), Ye.constructPoint2D(t3[2]), e5, i2);
    const r = new Ye();
    O(2, Ye.constructPoint2D(t3[2]), Ye.constructPoint2D(t3[3]), e5, r);
    const o = new Ye();
    O(2, n6, i2, e5, o);
    const a2 = new Ye();
    O(2, i2, r, e5, a2), O(2, o, a2, e5, s4);
  } else {
    const n6 = new Ye();
    G2(2, Ye.constructPoint2D(t3[0]), Ye.constructPoint2D(t3[1]), e5, n6);
    const i2 = new Ye();
    G2(2, Ye.constructPoint2D(t3[1]), Ye.constructPoint2D(t3[2]), e5, i2);
    const r = new Ye();
    G2(2, Ye.constructPoint2D(t3[2]), Ye.constructPoint2D(t3[3]), e5, r);
    const o = new Ye();
    G2(2, n6, i2, e5, o);
    const a2 = new Ye();
    G2(2, i2, r, e5, a2), G2(2, o, a2, e5, s4);
  }
}
function xo(t3, e5, s4) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6), yo(n6, e5, s4);
}
function Co(t3, e5) {
  const s4 = Us(e5, 0, 1);
  let n6 = ao(t3, 1, s4);
  return n6.isZero() && (n6 = ao(t3, 2, s4), n6.isZero() ? n6 = ao(t3, 3, s4) : 1 === s4 && n6.negateThis()), n6;
}
function vo(t3, e5, s4) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6), bo(n6, e5, s4);
}
function bo(t3, e5, s4) {
  e5.value() < 0 && e5.set(0, e5.eps()), e5.value() > 1 && e5.set(1, e5.eps()), s4.setE(ho(t3, 1, e5));
}
function So(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== To(t3, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Eo(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== Io(t3, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Do(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== Mo(t3, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function wo(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== Yo(t3, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Ao(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== No(t3, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function To(t3, e5, s4, n6, i2, r, o, a2, h2, u) {
  if (null !== i2 && (i2.length = 0), null != r && (r.length = 0), null !== n6 && (n6.length = 0), s4.isDegenerate(0)) {
    const t4 = [0, 0, 0], a3 = e5.intersectPoint(s4.getStartXY(), t4, o);
    if (a3 > 0) {
      if (null !== i2) for (let e6 = 0; e6 < a3; e6++) i2.push(t4[e6]);
      if (null !== r) for (let t5 = 0; t5 < a3; t5++) r.push(0);
      if (null != n6) for (let s5 = 0; s5 < a3; s5++) {
        const i3 = new mi();
        e5.queryCoord2D(t4[s5], i3), n6.push(i3);
      }
    }
    return a3;
  }
  const m3 = rs2(e5, s4);
  if (os(e5, s4, o = Math.max(o, m3))) return 0;
  const l2 = Ot(mi, 4);
  Br(e5, l2);
  const c = s4.getEndXY();
  c.subThis(s4.getStartXY());
  const g2 = c.clone();
  g2.leftPerpendicularThis();
  let d2 = 3 * l2[3].dotProduct(g2), _ = 2 * l2[2].dotProduct(g2), p3 = l2[1].dotProduct(g2);
  const f3 = Yt(15, Number.NaN), P5 = Yt(15, Number.NaN);
  let y2 = sn(d2, _, p3, x2.unit(), false, f3);
  y2 < 0 && (f3[0] = 0, f3[1] = 1, y2 = 2);
  let x4, C3 = 0;
  for (let S3 = 0, E2 = C3; S3 < y2; ++S3) {
    const t4 = e5.getCoord2D(f3[S3 + E2]);
    P5[C3] = s4.getClosestCoordinate(t4, false), mi.distance(t4, s4.getCoord2D(P5[C3])) <= o && (f3[C3] = f3[S3 + E2], C3++);
  }
  if (l2[0].subThis(s4.getStartXY()), Math.abs(c.x) >= Math.abs(c.y)) {
    const t4 = c.y / c.x;
    d2 = l2[3].y - l2[3].x * t4, _ = l2[2].y - l2[2].x * t4, p3 = l2[1].y - l2[1].x * t4, x4 = l2[0].y - l2[0].x * t4;
  } else {
    const t4 = c.x / c.y;
    d2 = l2[3].x - l2[3].y * t4, _ = l2[2].x - l2[2].y * t4, p3 = l2[1].x - l2[1].y * t4, x4 = l2[0].x - l2[0].y * t4;
  }
  const v3 = e5.getEndXY().equals(s4.getStartXY()) || e5.getEndXY().equals(s4.getEndXY()), b2 = [0, 0, 0];
  y2 = nn(d2, _, p3, x4, x2.unit(), v3, b2);
  for (let S3 = 0, E2 = C3; S3 < y2; ++S3) {
    f3[S3 + E2] = b2[S3];
    const t4 = e5.getCoord2D(f3[S3 + E2]);
    P5[C3] = s4.getClosestCoordinate(t4, false);
    mi.distance(t4, s4.getCoord2D(P5[C3])) <= o && (f3[C3] = f3[S3 + E2], C3++);
  }
  y2 = e5.intersectPoint(s4.getStartXY(), b2, o);
  for (let S3 = 0; S3 < y2; S3++) f3[C3] = b2[S3], P5[C3++] = 0;
  y2 = e5.intersectPoint(s4.getEndXY(), b2, o);
  for (let S3 = 0; S3 < y2; S3++) f3[C3] = b2[S3], P5[C3++] = 1;
  return 0 !== s4.intersectPoint(e5.getStartXY(), b2, o) && (P5[C3] = b2[0], f3[C3++] = 0), 0 !== s4.intersectPoint(e5.getEndXY(), b2, o) && (P5[C3] = b2[0], f3[C3++] = 1), 0 === C3 ? 0 : cm(t3, e5, s4, f3, P5, C3, n6, i2, r, o, a2, h2, u);
}
function Io(t3, e5, s4, n6, i2, r, o, a2, h2, u) {
  if (Su(s4)) {
    return To(t3, e5, new pm({ start: s4.getStartXY(), end: s4.getEndXY() }), n6, i2, r, o, a2, h2, u);
  }
  const m3 = rs2(e5, s4);
  if (os(e5, s4, o = Math.max(o, m3))) return 0;
  const l2 = [], c = [], g2 = [], d2 = Ot(mi, 4);
  {
    e5.queryControlPoints(d2);
    const t4 = Ot(mi, 4), n7 = new x3();
    s4.canonicToWorldTransformation(n7);
    const i3 = new x3();
    i3.setInvert(n7), i3.transformPoints2D(d2, 4, t4);
    const r2 = Ot(Xe, 4);
    Zr(t4, r2);
    const h3 = [r2[0].x, r2[1].x, r2[2].x, r2[3].x], u2 = [r2[0].y, r2[1].y, r2[2].y, r2[3].y], m4 = Ot(si, 3);
    m4[0].setDouble(s4.getSemiMinorAxis()), m4[0].sqrThis(), m4[1].setDouble(s4.getSemiMajorAxis()), m4[1].sqrThis(), m4[2].setThis(m4[0]), m4[2].mulThis(m4[1]), m4[2].negateThis();
    const _2 = qn(h3, 3, u2, 3, null, 0, m4, true, x2.unit(), x2.unit(), c, a2);
    if (_2 > 0) {
      let t5 = 0;
      for (let n8 = 0; n8 < _2; n8++) {
        const i4 = new mi();
        e5.queryCoord2D(c[n8], i4);
        const r3 = s4.getClosestCoordinate(i4, false), a3 = new mi();
        s4.queryCoord2D(r3, a3);
        mi.distance(i4, a3) <= o && (l2.push(i4.clone()), c[t5] = c[n8], g2.push(r3), t5++);
      }
      c.length = t5, l2.length = t5;
    }
  }
  const _ = [0, 1];
  for (let p3 = 0; p3 < 2; p3++) {
    const t4 = 0 === p3 ? s4.getStartXY() : s4.getEndXY(), e6 = [0];
    Lo(d2, t4, x2.unit(), false, -1, 1, e6);
    const n7 = new mi();
    Po(d2, e6[0], n7);
    mi.distance(t4, n7) <= o && (c.push(e6[0]), g2.push(_[p3]), l2.push(n7.clone()));
  }
  for (let p3 = 0; p3 < 2; p3++) {
    const t4 = [0, 3];
    {
      const e6 = s4.getClosestCoordinate(d2[t4[p3]], false), n7 = new mi();
      s4.queryCoord2D(e6, n7);
      mi.distance(d2[t4[p3]], n7) <= o && (c.push(_[p3]), g2.push(e6), l2.push(n7.clone()));
    }
  }
  return cm(t3, e5, s4, c, g2, c.length, n6, i2, r, o, a2, h2, u);
}
function Mo(t3, e5, n6, i2, r, o, a2, h2, u, m3) {
  const l2 = Ot(mi, 4);
  e5.queryControlPoints(l2);
  const c = Ot(mi, 4);
  if (n6.queryControlPoints(c), as(l2, c, 4) < 0) return Mo(t3, n6, e5, i2, o, r, a2, h2, u, !m3);
  const g2 = rs2(e5, n6);
  if (os(e5, n6, a2 = Math.max(a2, g2))) return 0;
  if (ea(e5, n6, i2, r, o, a2, h2, u, m3)) return 2;
  const d2 = new x2(0, 1), _ = new x2(0, 1);
  {
    const t4 = new De();
    Fo(l2, new x2(0, 1), t4);
    const e6 = new De();
    Fo(c, new x2(0, 1), e6);
    const s4 = Math.max(t4.maxDim(), e6.maxDim());
    if (t4.inflate(3 * a2), e6.inflate(3 * a2), !t4.intersectW(e6)) return 0;
    if (t4.maxDim() < 0.1 * s4) {
      if (Oo(l2, t4, d2), d2.isEmpty()) return 0;
      if (Oo(c, t4, _), _.isEmpty()) return 0;
      fo(l2, d2.vmin, d2.vmax, l2), fo(c, _.vmin, _.vmax, c);
    }
  }
  const p3 = dm(l2, 3, c, 3, a2);
  if (0 === p3) return 0;
  const f3 = [], P5 = [], y2 = [];
  let x4 = false;
  if (-1 === p3) {
    const t4 = Ot(Xe, 4);
    Zr(l2, t4);
    const e6 = [t4[0].x, t4[1].x, t4[2].x, t4[3].x], s4 = [t4[0].y, t4[1].y, t4[2].y, t4[3].y], n7 = Ot(Xe, 4);
    Zr(c, n7);
    const i3 = [], r2 = [], o2 = Yn(e6, 3, s4, 3, null, 0, [n7[0].x, n7[1].x, n7[2].x, n7[3].x], 3, [n7[0].y, n7[1].y, n7[2].y, n7[3].y], 3, null, 0, true, x2.unit(), x2.unit(), i3, r2, u);
    if (o2 > 0) for (let h3 = 0; h3 < o2; h3++) {
      const t5 = new mi();
      Po(c, r2[h3], t5);
      const e7 = new mi();
      Po(l2, i3[h3], e7);
      mi.distance(e7, t5) <= a2 && (f3.push(e7.clone()), y2.push(r2[h3]), P5.push(i3[h3]));
    }
    else -1 === o2 && (x4 = true);
  }
  for (let s4 = 0; s4 < 2; s4++) {
    const t4 = 0 === s4 ? l2 : c, e6 = 0 === s4 ? c : l2;
    for (let n7 = 0; n7 < 2; n7++) {
      const i3 = 0 === n7 ? 0 : 3, r2 = [0];
      Lo(e6, t4[i3], x2.unit(), false, -1, 1, r2);
      const o2 = new mi();
      Po(e6, r2[0], o2);
      mi.distance(t4[i3], o2) <= a2 && (0 === s4 ? (P5.push(0 === i3 ? 0 : 1), y2.push(r2[0])) : (y2.push(0 === i3 ? 0 : 1), P5.push(r2[0])), f3.push(o2.clone()));
    }
  }
  if (0 === P5.length && x4) {
    const t4 = e5.calculateUpperLength2D() > n6.calculateUpperLength2D();
    {
      const i3 = [0, 0];
      if (2 === Go(t4 ? e5 : n6, i3, true) && (n2(x2.unit().containsCoordinate(i3[0])), !x2.unit().containsCoordinate(i3[1]))) {
        const e6 = new mi();
        Po(t4 ? l2 : c, i3[0], e6);
        const s4 = [0, 0];
        1 === Lo(t4 ? c : l2, e6, x2.unit(), false, -1, 2, s4) && (f3.push(e6.clone()), P5.push(t4 ? i3[0] : s4[0]), y2.push(t4 ? s4[0] : i3[0]));
      }
    }
  }
  if (0 === P5.length) return 0;
  if (!d2.equalsRange(0, 1)) for (let s4 = 0; s4 < P5.length; ++s4) P5[s4] = ia.recalculateParentT(d2.vmin, d2.vmax, P5[s4]);
  if (!_.equalsRange(0, 1)) for (let s4 = 0; s4 < y2.length; ++s4) y2[s4] = ia.recalculateParentT(_.vmin, _.vmax, y2[s4]);
  return cm(t3, e5, n6, P5, y2, P5.length, i2, r, o, a2, h2, u, m3);
}
function Yo(t3, e5, n6, i2, r, o, a2, h2, u, m3) {
  const l2 = rs2(e5, n6);
  if (n6.isDegenerateToLineHelper(l2)) {
    const s4 = new pm({ start: n6.getStartXY(), end: n6.getEndXY() }), l3 = To(t3, e5, s4, i2, r, o, a2, h2, u, m3);
    if (o) for (let t4 = 0; t4 < l3; ++t4) {
      const e6 = s4.getCoord2D(o[t4]);
      o[t4] = n6.getClosestCoordinate(e6, false);
    }
    return l3;
  }
  if (os(e5, n6, a2 = Math.max(a2, l2))) return 0;
  const c = Ot(mi, 4);
  e5.queryControlPoints(c);
  const g2 = Ot(mi, 3);
  n6.queryControlPoints(g2);
  const d2 = new x2(0, 1), _ = new x2(0, 1), p3 = [0, 0, 0];
  n6.queryWeights(p3);
  const f3 = [1, fh(p3), 1];
  {
    const t4 = new De();
    Fo(c, new x2(0, 1), t4);
    const e6 = new De();
    Wa(g2, f3, new x2(0, 1), e6);
    const s4 = Math.max(t4.maxDim(), e6.maxDim());
    if (t4.inflate(3 * a2), e6.inflate(3 * a2), !t4.intersectW(e6)) return 0;
    if (t4.maxDim() < 0.1 * s4) {
      if (Oo(c, t4, d2), d2.isEmpty()) return 0;
      if (ph(g2, f3, t4, _), _.isEmpty()) return 0;
      fo(c, d2.vmin, d2.vmax, c), Qa(g2, f3, _.vmin, _.vmax, g2, f3);
    }
  }
  const P5 = dm(c, 3, g2, 2, a2);
  if (0 === P5) return 0;
  const y2 = [], x4 = [], C3 = [];
  if (-1 === P5) {
    const t4 = Ot(Xe, 4);
    Zr(c, t4);
    const e6 = [t4[0].x, t4[1].x, t4[2].x, t4[3].x], s4 = [t4[0].y, t4[1].y, t4[2].y, t4[3].y], n7 = Ot(si, 3), i3 = Ot(si, 3), r2 = Ot(si, 3);
    hh(g2, f3, n7, i3, r2);
    const o2 = [], h3 = [], m4 = Yn(n7, 2, i3, 2, r2, 2, e6, 3, s4, 3, null, 0, true, x2.unit(), x2.unit(), h3, o2, u);
    if (m4 > 0) for (let u2 = 0; u2 < m4; u2++) {
      const t5 = new mi();
      Po(c, o2[u2], t5);
      const e7 = new mi();
      _h(g2, f3, h3[u2], e7);
      mi.distance(t5, e7) <= a2 && (y2.push(t5.clone()), x4.push(o2[u2]), C3.push(h3[u2]));
    }
  }
  for (let v3 = 0; v3 < 2; v3++) {
    let t4, e6;
    0 === v3 ? (t4 = c, e6 = g2) : (e6 = c, t4 = g2);
    for (let n7 = 0; n7 < 2; n7++) {
      const i3 = 0 === n7 ? 0 : t4.length - 1, r2 = [0], o2 = new mi();
      if (0 === v3) {
        const n8 = za(e6, f3, t4[i3], x2.unit(), false, -1, 1, r2);
        n2(1 === n8), _h(e6, f3, r2[0], o2);
      } else {
        const n8 = Lo(e6, t4[i3], x2.unit(), false, -1, 1, r2);
        n2(1 === n8), Po(e6, r2[0], o2);
      }
      mi.distance(t4[i3], o2) <= a2 && (0 === v3 ? (x4.push(0 === i3 ? 0 : 1), C3.push(r2[0])) : (C3.push(0 === i3 ? 0 : 1), x4.push(r2[0])), y2.push(o2.clone()));
    }
  }
  if (0 === x4.length) return 0;
  if (!d2.equalsRange(0, 1)) for (let s4 = 0; s4 < x4.length; ++s4) x4[s4] = ia.recalculateParentT(d2.vmin, d2.vmax, x4[s4]);
  if (!_.equalsRange(0, 1)) for (let s4 = 0; s4 < C3.length; ++s4) C3[s4] = En.recalculateParentT(_.vmin, _.vmax, C3[s4]);
  for (let s4 = 0; s4 < C3.length; ++s4) C3[s4] = Ph(p3, C3[s4]);
  return cm(t3, e5, n6, x4, C3, x4.length, i2, r, o, a2, h2, u, m3);
}
function No(t3, e5, n6, i2, r, o, a2, h2, u, m3) {
  const l2 = rs2(e5, n6);
  if (os(e5, n6, a2 = Math.max(a2, l2))) return 0;
  const c = Ot(mi, 4);
  e5.queryControlPoints(c);
  const g2 = Ot(mi, 3);
  n6.queryControlPoints(g2);
  const d2 = dm(c, 3, g2, 2, a2);
  if (0 === d2) return 0;
  const _ = [], p3 = [], f3 = [];
  if (-1 === d2) {
    const t4 = Ot(Xe, 4);
    Zr(c, t4);
    const s4 = [t4[0].x, t4[1].x, t4[2].x, t4[3].x], i3 = [t4[0].y, t4[1].y, t4[2].y, t4[3].y], r2 = Ot(Xe, 3);
    Wi(g2, r2);
    const o2 = Yn([r2[0].x, r2[1].x, r2[2].x], 2, [r2[0].y, r2[1].y, r2[2].y], 2, null, 0, s4, 3, i3, 3, null, 0, true, x2.unit(), x2.unit(), f3, p3, h2);
    if (o2 > 0) {
      let t5 = 0;
      for (let s5 = 0; s5 < o2; s5++) {
        const i4 = new mi();
        e5.queryCoord2D(p3[s5], i4);
        const r3 = new mi();
        n6.queryCoord2D(f3[s5], r3);
        mi.distance(i4, r3) <= a2 && (_.push(i4.clone()), p3[t5] = p3[s5], f3[t5] = f3[s5], t5++);
      }
      p3.length = t5, _.length = t5;
    }
  }
  for (let P5 = 0; P5 < 2; P5++) {
    let t4, e6;
    0 === P5 ? (t4 = c, e6 = g2) : (e6 = c, t4 = g2);
    for (let n7 = 0; n7 < 2; n7++) {
      const i3 = 0 === n7 ? 0 : t4.length - 1, r2 = [0], o2 = new mi();
      if (0 === P5) vi(e6, t4[i3], r2), ji(e6, r2[0], o2);
      else {
        const n8 = Lo(e6, t4[i3], x2.unit(), false, -1, 1, r2);
        n2(1 === n8), Po(e6, r2[0], o2);
      }
      mi.distance(t4[i3], o2) <= a2 && (0 === P5 ? (p3.push(0 === i3 ? 0 : 1), f3.push(r2[0])) : (f3.push(0 === i3 ? 0 : 1), p3.push(r2[0])), _.push(o2.clone()));
    }
  }
  return cm(t3, e5, n6, p3, f3, p3.length, i2, r, o, a2, h2, u, m3);
}
function Xo(t3, e5, i2, r, o) {
  const a2 = new De();
  if (qo(t3, x2.unit(), a2), a2.inflate(r), !a2.isIntersectingPoint2D(e5)) return 0;
  const h2 = Qr(t3);
  let u = 0, m3 = h2.specialPoints[0];
  const l2 = [];
  for (let n6 = 1, c = h2.specialPoints.length; n6 < c; ++n6) {
    const i3 = h2.specialPoints[n6], r2 = no(t3, e5, m3, i3);
    if (0 === l2.length) l2.push(r2);
    else if (r2.t === r2.tmin) n2(l2.at(-1).d <= r2.d), l2.at(-1).tmax = r2.tmax;
    else if (l2.at(-1).t === l2.at(-1).tmax) {
      n2(l2.at(-1).d >= r2.d);
      const t4 = l2.at(-1).tmin;
      l2[l2.length - 1] = r2, l2.at(-1).tmin = t4;
    } else l2.push(r2);
    m3 = i3;
  }
  for (const s4 of l2) if (s4.d <= r) {
    const t4 = s4.t;
    i2 ? (u >= i2.length && A(""), i2[u] = t4, u++) : u++;
  }
  return u;
}
function qo(t3, e5, s4) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6), Fo(n6, e5, s4);
}
function Fo(t3, e5, s4) {
  if (e5.equalsRange(0, 1)) return void s4.setFromPoints(t3, 4);
  const n6 = Ot(mi, 4);
  fo(t3, e5.vmin, e5.vmax, n6), s4.setFromPoints(n6, 4);
}
var Vo = class {
  constructor(t3, e5, s4) {
    this.dbgCounter = 0, this.controlPoints = t3, this.point = e5.clone(), this.maxDistance = s4;
  }
  getMaxDerivative() {
    return 6;
  }
  getValue(t3, e5) {
    switch (t3) {
      case 0: {
        const t4 = new mi();
        Po(this.controlPoints, e5, t4);
        const s4 = ao(this.controlPoints, 1, e5);
        return 2 * t4.sub(this.point).dotProduct(s4);
      }
      case 1: {
        const t4 = new mi();
        Po(this.controlPoints, e5, t4);
        const s4 = ao(this.controlPoints, 1, e5), n6 = ao(this.controlPoints, 2, e5);
        return 2 * (t4.sub(this.point).dotProduct(n6) + s4.dotProduct(s4));
      }
      case 2: {
        const t4 = new mi();
        Po(this.controlPoints, e5, t4);
        const s4 = ao(this.controlPoints, 1, e5), n6 = ao(this.controlPoints, 2, e5), i2 = ao(this.controlPoints, 3, e5);
        return 2 * (t4.sub(this.point).dotProduct(i2) + 3 * s4.dotProduct(n6));
      }
      case 3: {
        const t4 = ao(this.controlPoints, 1, e5), s4 = ao(this.controlPoints, 2, e5), n6 = ao(this.controlPoints, 3, e5);
        return 2 * (4 * t4.dotProduct(n6) + 3 * s4.sqrLength());
      }
      case 4: {
        const t4 = ao(this.controlPoints, 2, e5), s4 = ao(this.controlPoints, 3, e5);
        return 2 * (10 * t4.dotProduct(s4));
      }
      case 5: {
        const t4 = ao(this.controlPoints, 3, e5);
        return 2 * (10 * t4.dotProduct(t4));
      }
      default:
        return 0;
    }
  }
  getError(t3) {
    return 0;
  }
  isInterestingInterval(t3, e5) {
    if (t3 >= 0 && e5 <= 1) {
      const s4 = Ot(mi, 4);
      fo(this.controlPoints, t3, e5, s4);
      const n6 = new De();
      if (n6.setFromPoints(s4, 4), Math.sqrt(n6.sqrMinDistance(this.point)) > this.maxDistance) return false;
    }
    return true;
  }
};
function Lo(t3, e5, n6, i2, r, o, a2) {
  D(x2.unit().contains(n6) && o > 0, "getClosestCoordinate"), (r < 0 || Number.isNaN(r)) && (r = Number.MAX_VALUE);
  const h2 = [], u = new mi();
  Po(t3, n6.vmin, u);
  let m3 = mi.distance(u, e5);
  if (m3 <= r && h2.push(new mi(n6.vmin, m3)), n6.vmin !== n6.vmax && (Po(t3, n6.vmax, u), m3 = mi.distance(u, e5), m3 <= r && h2.push(new mi(n6.vmax, m3))), n6.width() > 0) {
    const s4 = Yt(18, Number.NaN), i3 = tn(new Vo(t3, e5, r), n6, 18, s4);
    for (let n7 = 0; n7 < i3; n7++) Po(t3, s4[n7], u), m3 = mi.distance(u, e5), m3 > r || h2.push(new mi(s4[n7], m3));
  }
  if (i2) {
    n2(n6.equals(x2.unit()));
    {
      Po(t3, -1, u, true);
      const s4 = new mi();
      Po(t3, 0, s4);
      const n7 = new pm({ start: u, end: s4 }), i3 = n7.getClosestCoordinate(e5, true);
      i3 < 1 && (u.assign(n7.getCoord2D(i3)), m3 = mi.distance(u, e5), m3 <= r && h2.push(new mi(i3 - 1, m3)));
    }
    {
      Po(t3, 2, u, true);
      const s4 = new mi();
      Po(t3, n6.vmax, s4);
      const i3 = new pm({ start: s4, end: u }), o2 = i3.getClosestCoordinate(e5, true);
      o2 > 0 && (u.assign(i3.getCoord2D(o2)), m3 = mi.distance(u, e5), m3 <= r && h2.push(new mi(1 + o2, m3)));
    }
  }
  if (!h2.length) return 0;
  h2.sort((t4, e6) => t4.compare(e6));
  let l2 = 0;
  const c = h2[0].x;
  if (a2[l2++] = c, l2 < o) {
    const e6 = Rt2(t3, 4, false).total(), s4 = h2[0].y;
    for (let t4 = 1, n7 = h2.length; t4 < n7; t4++) if (h2[t4].y > s4 + e6) {
      h2.length = t4;
      break;
    }
    h2.sort((t4, e7) => Ct(t4.x, e7.x)), l2 = 0, a2[l2++] = h2[0].x;
    for (let t4 = 1, n7 = h2.length; t4 < n7; t4++) h2[t4].x !== a2[l2 - 1] && l2 < o && (a2[l2++] = h2[t4].x);
  }
  return l2;
}
function Ro(t3, e5, s4, n6, i2, r, o) {
  const a2 = Ot(mi, 4);
  return t3.queryControlPoints(a2), Lo(a2, e5, s4, n6, i2, r, o);
}
function zo(t3) {
  return t3.getStartXY().norm(1) + t3.getEndXY().norm(1) + t3.m_cp[0].norm(1) + t3.m_cp[1].norm(1);
}
function Bo(t3) {
  return t3[0].norm(1) + t3[1].norm(1) + t3[2].norm(1) + t3[3].norm(1);
}
function ko(t3, e5, n6) {
  if (n2(n6 >= 2), 2 === n6) {
    const s4 = new mi();
    Y(e5[0], e5[n6 - 1], 1 / 3, s4);
    const i3 = new mi();
    return Y(e5[0], e5[n6 - 1], 2 / 3, i3), void t3.construct(e5[0], s4, i3, e5[n6 - 1]);
  }
  const i2 = e5[0], r = e5[n6 - 1], o = [0, 0], a2 = Ro(t3, i2, x2.unit(), false, Number.NaN, 2, o), h2 = [0, 0], u = Ro(t3, r, x2.unit(), false, Number.NaN, 2, h2), m3 = [];
  for (let s4 = 0; s4 < a2; s4++) for (let a3 = 0; a3 < u; a3++) {
    const u2 = o[s4], l3 = h2[a3], c2 = u2 > l3, g3 = (s5, o2) => {
      const a4 = Yt(n6 - 2, Number.NaN), h3 = () => {
        let t4 = 0;
        for (let s6 = 1, i3 = n6 - 1; s6 < i3; s6++) {
          t4 += mi.distance(e5[s6 - 1], e5[s6]);
          const n7 = t4;
          a4[s6 - 1] = n7;
        }
        t4 += mi.distance(e5[n6 - 2], e5[n6 - 1]), c2 && a4.reverse();
        for (let e6 = 1, s6 = n6 - 1; e6 < s6; e6++) a4[e6 - 1] /= t4, c2 && (a4[e6 - 1] = 1 - a4[e6 - 1]);
      };
      let m4 = false, g4 = false;
      {
        const e6 = new fm();
        c2 ? (t3.queryCut(l3, u2, e6, true), s5.assign(e6.get().getControlPoint2()), o2.assign(e6.get().getControlPoint1())) : (t3.queryCut(u2, l3, e6, true), s5.assign(e6.get().getControlPoint1()), o2.assign(e6.get().getControlPoint2())), i2.equals(s5) && (m4 = true), r.equals(o2) && (g4 = true);
      }
      h3();
      let d4 = Number.MAX_VALUE;
      const _2 = s5.clone(), p4 = o2.clone();
      for (let t4 = 0; t4 < 5; t4++) {
        d4 = sa(true, false, i2, _2, p4, r, m4, g4, a4, n6 - 2, e5, n6);
      }
      for (let t4 = 0; t4 < 30; t4++) {
        const t5 = _2.clone();
        p4.clone();
        const s6 = sa(true, true, i2, _2, p4, r, m4, g4, a4, n6 - 2, e5, n6);
        if (d4 <= s6 && t5.equals(_2) && t5.equals(p4)) break;
        d4 = s6;
      }
      h3();
      let f3 = false, P5 = Number.MAX_VALUE;
      const y2 = s5.clone(), x4 = o2.clone();
      for (let t4 = 0; t4 < 30; t4++) {
        const t5 = y2.clone();
        x4.clone();
        const s6 = sa(f3, true, i2, y2, x4, r, m4, g4, a4, n6 - 2, e5, n6);
        if (P5 <= s6 && t5.equals(y2) && t5.equals(x4)) break;
        f3 = true, P5 = s6;
      }
      return P5 < d4 ? (s5.assign(y2), o2.assign(x4)) : (s5.assign(_2), o2.assign(p4), P5 = d4), P5;
    }, d3 = new mi(), _ = new mi(), p3 = [g3(d3, _), mi.distance(i2, d3) + mi.distance(d3, _) + mi.distance(_, r), d3.x, d3.y, _.x, _.y];
    m3.splice(m3.length, 0, ...p3);
  }
  let l2 = m3[0], c = m3[1], g2 = 0;
  for (let s4 = 6; s4 < m3.length; s4 += 6) m3[s4] < l2 && (l2 = m3[s4], c = m3[s4 + 1], g2 = s4);
  let d2 = g2;
  for (let s4 = 0; s4 < m3.length; s4 += 6) s4 !== g2 && m3[s4 + 1] < c && Math.abs(l2 - m3[s4]) < 10 * l2 && (c = m3[s4 + 1], d2 = s4);
  t3.construct(i2, new mi(m3[d2 + 2], m3[d2 + 3]), new mi(m3[d2 + 4], m3[d2 + 5]), r);
}
function Go(t3, e5, s4 = false) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6);
  const i2 = Ot(Xe, 4);
  let r, o, a2;
  Zr(n6, i2, true);
  const h2 = i2[3].x.isZero(), u = i2[3].y.isZero();
  if (h2 || u) if (h2 && !u) {
    if (i2[2].x.isZero()) return 0;
    r = i2[1].x.div(i2[2].x).negate(), o = i2[2].y.div(i2[3].y), a2 = i2[1].y.div(i2[3].y);
  } else {
    if (h2 || !u) return 0;
    if (i2[2].y.isZero()) return 0;
    r = i2[1].y.div(i2[2].y).negate(), o = i2[2].x.div(i2[3].x), a2 = i2[1].x.div(i2[3].x);
  }
  else {
    i2[2].x.divThis(i2[3].x), i2[1].x.divThis(i2[3].x), i2[2].y.divThis(i2[3].y), i2[1].y.divThis(i2[3].y);
    const t4 = i2[2].x.sub(i2[2].y);
    if (t4.isZero()) return 0;
    r = i2[1].x.sub(i2[1].y).div(t4).negate(), o = i2[2].x.clone(), a2 = i2[1].x.clone();
  }
  if (!s4 && r.abs().value() > 2) return 0;
  const m3 = [0, 0], l2 = t3.getStartXY().equals(t3.getEndXY()), c = sn(1, -r.toDouble(), r.add(o).mul(r).add(a2).toDouble(), x2.unit(), l2, m3);
  if (0 === c) return 0;
  if (m3[0] >= 0 && m3[0] <= 1) {
    const t4 = r.toDouble() - m3[0];
    if (s4 || t4 >= 0 && t4 <= 1) return e5[0] = m3[0], e5[1] = t4, e5[0] > e5[1] && (e5[1] = Pt(e5[0], e5[0] = e5[1])), 2;
  }
  if (2 === c && m3[1] >= 0 && m3[1] <= 1) {
    const t4 = r.toDouble() - m3[1];
    if (s4 || t4 >= 0 && t4 <= 1) return e5[0] = m3[1], e5[1] = t4, e5[0] > e5[1] && (e5[1] = Pt(e5[0], e5[0] = e5[1])), 2;
  }
  return 0;
}
function Wo(t3, e5, s4) {
  const n6 = t3[1].mulE(e5[2]).subThisE(t3[2].mulE(e5[1])), i2 = t3[1].mulE(e5[3]).subThisE(t3[3].mulE(e5[1])).mulThis(3), r = t3[2].mulE(e5[3]).subThisE(t3[3].mulE(e5[2])).mulThis(3), o = Ot(p2, 2);
  let a2 = gn(r, i2, n6, new x2(0, 1), false, o);
  a2 < 0 && (a2 = 0);
  let h2 = 0;
  for (let u = 0; u < a2; u++) Vs(o[u].value(), 0, 1) || (s4[h2].setE(o[u]), h2++);
  return h2;
}
function jo(t3, e5) {
  e5[0].set(0);
  let n6 = 1;
  const i2 = Ot(p2, 4);
  Wr(t3, i2, true);
  const r = Ot(p2, 4);
  jr(t3, r, true);
  {
    const t4 = i2[3].mul(3), s4 = i2[2].mul(2), r2 = i2[1].clone(), o = Ot(p2, 2);
    let a2 = gn(t4, s4, r2, new x2(0, 1), false, o);
    a2 < 0 && (a2 = 0);
    for (let i3 = 0; i3 < a2; i3++) Vs(o[i3].value(), 0, 1) || (e5[n6] = o[i3], n6++);
  }
  {
    const t4 = r[3].mul(3), s4 = r[2].mul(2), i3 = r[1].clone(), o = Ot(p2, 2);
    let a2 = gn(t4, s4, i3, new x2(0, 1), false, o);
    a2 < 0 && (a2 = 0);
    for (let r2 = 0; r2 < a2; r2++) Vs(o[r2].value(), 0, 1) || (e5[n6] = o[r2], n6++);
  }
  if (n6 += Wo(i2, r, e5.slice(n6)), e5[n6].set(1), n6++, n6 > 2) {
    Zt(e5, 0, n6, (t4, e6) => {
      const s5 = t4.value(), n7 = e6.value();
      return s5 < n7 ? -1 : s5 > n7 ? 1 : 0;
    });
    let s4 = 0;
    const i3 = e5[0].clone();
    let r2 = 0;
    const o = Bo(t3) * Qs(), a2 = new mi();
    _o(t3, e5[0].value(), a2);
    for (let h2 = 1; h2 < n6; h2++) {
      const n7 = new mi();
      if (_o(t3, e5[h2].value(), n7), e5[h2].eq(i3) || n7.isEqualPoint2D(a2, o)) {
        if (0 !== s4) {
          if (0 === e5[h2].eps()) i3.setE(e5[h2]), r2 = 0;
          else if (0 !== r2) {
            const t4 = H(1 / e5[h2].eps()), s5 = 1 / r2, n8 = t4 + s5;
            i3.set((e5[h2].value() * t4 + i3.value() * s5) / n8), r2 = 1 / n8, i3.setError(Math.sqrt(r2));
          }
          e5[s4].setE(i3), _o(t3, i3.value(), a2);
        }
      } else s4++, e5[s4].setE(e5[h2]), i3.setE(e5[h2]), _o(t3, i3.value(), a2), r2 = H(e5[h2].eps());
    }
    s4++, n6 = s4;
  }
  return 1 === n6 && (n6 = 2, e5[1].set(1)), n2(0 === e5[0].value()), n2(1 === e5[n6 - 1].value()), n6;
}
function Zo(t3, e5, s4, n6, i2) {
  const r = Ot(p2, 4), o = Ot(p2, 3), a2 = new x2(0, 1);
  let h2 = 0;
  if (e5) {
    if (jr(t3, r, false), h2 = dn(r[3], r[2], r[1], r[0].sub(s4), a2, false, o), n6) for (let u = 0; u < h2; u++) {
      const e6 = new mi();
      Po(t3, o[u].value(), e6), n6[u] = e6.x;
    }
  } else if (Wr(t3, r, false), h2 = dn(r[3], r[2], r[1], r[0].sub(s4), a2, false, o), n6) for (let u = 0; u < h2; u++) {
    const e6 = new mi();
    Po(t3, o[u].value(), e6), n6[u] = e6.y;
  }
  if (i2) for (let u = 0; u < h2; u++) i2[u] = o[u].value();
  else n6 && Zt(n6, 0, h2, Ct);
  return h2;
}
function Ho(t3, e5, s4, n6) {
  const i2 = Uo(t3, e5, s4, n6.getEnvelope2D());
  if (i2.isEmpty()) return new x2(i2);
  const r = Ot(mi, s4);
  for (let a2 = 0; a2 < s4; ++a2) n6.xyRot(t3[a2], r[a2]);
  const o = Uo(r, e5, s4, n6.getRotatedEnvelope2D());
  return i2.intersect(new x2(o)), new x2(i2);
}
function Uo(t3, e5, s4, n6) {
  const i2 = Ot(mi, s4);
  for (let a2 = 0; a2 < s4; ++a2) i2[a2] = new mi(a2 / (s4 - 1), 0);
  const r = (t4, e6, s5, n7) => {
    const i3 = 0.1, r2 = new p2(e6.x).subE(new p2(t4.x)).divE(new p2(e6.y).subE(new p2(t4.y))).mulE(new p2(s5).subE(new p2(t4.y))).addE(new p2(t4.x));
    if (r2.eps() > i3) {
      const n8 = (e6.x - t4.x) / (e6.y - t4.y) * (s5 - t4.y) + t4.x;
      r2.set(n8, Qs());
    }
    if (r2.lt(new p2(0)) || r2.gt(new p2(1))) return false;
    let o2 = r2.value() - r2.eps();
    o2 = Us(o2, 0, 1);
    let a2 = r2.value() + r2.eps();
    return a2 = Us(a2, 0, 1), n7.mergeCoordinate(o2), n7.mergeCoordinate(a2), true;
  }, o = [];
  {
    const e6 = (t4, e7) => {
      o.length = s4;
      const n7 = xr(i2, s4, o, true), a3 = new x2();
      a3.setEmpty();
      const h3 = (s5) => s5.y < t4 ? -1 : s5.y > e7 ? 1 : 0;
      let u = i2[o[0]], m3 = h3(u);
      0 === m3 && a3.mergeCoordinate(u.x);
      for (let s5 = 1; s5 <= n7; ++s5) {
        const l2 = i2[o[s5 % n7]], c = h3(l2);
        0 === c && a3.mergeCoordinate(l2.x);
        let g2 = 0;
        c !== m3 && (g2 = c * m3 === 0 ? 1 === c || 1 === m3 ? 2 : 1 : 3, 1 & g2 && r(u, l2, t4, a3), 2 & g2 && r(u, l2, e7, a3)), u = l2, m3 = c;
      }
      return a3;
    };
    for (let n7 = 0; n7 < s4; ++n7) i2[n7].y = t3[n7].x;
    const a2 = e6(n6.xmin, n6.xmax);
    if (a2.isEmpty()) return new x2(a2);
    for (let n7 = 0; n7 < s4; ++n7) i2[n7].y = t3[n7].y;
    const h2 = e6(n6.ymin, n6.ymax);
    return a2.intersect(new x2(h2)), new x2(a2);
  }
}
function Oo(t3, e5, s4) {
  s4.setEmpty(), s4.merge(Ho(t3, null, 4, e5));
}
function Qo(t3, e5, s4) {
  s4.length = 0;
  {
    const e6 = new p2();
    io(t3, e6);
    const n7 = new Ye();
    if (vo(t3, e6, n7), n7.isZero()) return e6.isZero() || e6.eq(new p2(1)) ? 0 : (s4.push(e6.value()), 1);
  }
  const n6 = Ot(p2, 4);
  kr(t3, n6, true);
  const i2 = Ot(p2, 4);
  Gr(t3, i2, true);
  const r = Ot(p2, 6), o = n6[3].negate().mulE(i2[1]).addE(n6[2].mulE(i2[2]).mul(2)).addE(n6[1].mulE(i2[3])), a2 = n6[3].negate().mulE(i2[1]).subE(n6[2].mulE(i2[2]).mul(2)).addE(n6[1].mulE(i2[3])), h2 = n6[2].mulE(n6[2]).subE(i2[2].mulE(i2[2]));
  r[0] = i2[1].mulE(i2[1]).mulE(o).addE(n6[1].mulE(n6[1]).mulE(a2)).addE(n6[1].mulE(i2[1]).mulE(h2).mul(2)).mul(6), r[1] = n6[2].mulE(i2[1]).subE(n6[1].mulE(i2[2])).mulE(n6[2].mulE(n6[2]).addE(n6[1].mulE(n6[3]).mul(2)).addE(i2[2].mulE(i2[2])).addE(i2[1].mulE(i2[3]).mul(2))).mul(24);
  const u = n6[1].mulE(i2[2]).mulE(i2[2]).mulE(i2[3]), m3 = n6[2].mulE(n6[2]).mulE(n6[3]).mulE(i2[1]).subE(u).mul(156), l2 = n6[3].mulE(i2[1]).subE(n6[1].mulE(i2[3])), c = n6[3].mulE(i2[1]).subE(n6[1].mulE(i2[3])), g2 = n6[1].mulE(n6[3]).mulE(c).addE(i2[1].mulE(i2[3]).mulE(l2)).mul(72), d2 = i2[1].mulE(i2[3]).subE(n6[1].mulE(n6[3])), _ = n6[2].mulE(i2[2]).mulE(d2).mul(120), p3 = n6[1].mulE(n6[2]).mulE(n6[2]).mulE(i2[3]), f3 = n6[3].mulE(i2[1]).mulE(i2[2]).mulE(i2[2]).subE(p3).mul(36);
  r[2] = m3.addE(g2).addE(_).addE(f3);
  const P5 = n6[2].mulE(n6[3]).mulE(n6[3]).mulE(i2[1]).subE(n6[1].mulE(i2[2]).mulE(i2[3]).mulE(i2[3])).mul(360), y2 = n6[2].mulE(i2[2]).mulE(n6[2].mulE(n6[3]).subE(i2[2].mulE(i2[3]))).addE(n6[3].mulE(i2[2]).mulE(i2[2]).mulE(i2[2])).subE(n6[2].mulE(n6[2]).mulE(n6[2]).mulE(i2[3])).mul(24), x4 = n6[2].mulE(i2[1]).mulE(i2[3]).mulE(i2[3]).subE(n6[1].mulE(n6[3]).mulE(n6[3]).mulE(i2[2])).mul(72), C3 = n6[3].mulE(i2[3]).mulE(i2[1].mulE(i2[2]).subE(n6[1].mulE(n6[2]))).mul(288);
  r[3] = P5.addE(y2).addE(x4).addE(C3), r[4] = i2[3].mulE(i2[3]).addE(n6[3].mulE(n6[3])).mulE(n6[3].mulE(i2[1]).subE(n6[1].mulE(i2[3]))).mul(270).addE(n6[3].mulE(i2[2]).subE(n6[2].mulE(i2[3]))).mulE(n6[2].mulE(n6[3]).addE(i2[2].mulE(i2[3]))).mul(180), r[5] = n6[3].mulE(i2[2]).subE(n6[2].mulE(i2[3])).mulE(n6[3].mulE(n6[3]).addE(i2[3].mulE(i2[3]))).mul(216);
  const v3 = Ot(p2, 5), b2 = _n(r, 5, new x2(0, 1), false, v3, 5);
  if (b2 > 0) {
    let n7 = Math.abs(t3.getCurvature(0)), i3 = 0;
    const r2 = Math.abs(t3.getCurvature(1));
    (r2 > n7 || !Number.isFinite(r2)) && (i3 = 1);
    for (let e6 = 0; e6 < b2; e6++) {
      const s5 = Math.abs(t3.getCurvature(v3[e6].value()));
      t3.getCoord2D(v3[e6].value()), (s5 > n7 || !Number.isFinite(s5)) && (n7 = s5, i3 = v3[e6].value());
    }
    if ((!Number.isFinite(n7) || 1 / n7 < e5) && !Vs(i3, 0, 1)) {
      const e6 = t3.getCoord2D(i3);
      if (!e6.equals(t3.getStartXY()) && !e6.equals(t3.getEndXY())) return s4.push(i3), 1;
    }
  }
  if (!t3.isClosed()) {
    const e6 = [0, 0], n7 = Go(t3, e6, false);
    for (let t4 = 0; t4 < n7; t4++) e6[t4] > 0 && e6[t4] < 1 && s4.push(e6[t4]);
    return s4.length;
  }
  return 0;
}
var Jo = class {
  constructor(t3, e5) {
    this.b = t3, this.len = e5;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t3, e5) {
    return 0 === t3 ? this.len - Hr(this.b, e5, false) : 0;
  }
  getError(t3) {
    return 0;
  }
};
function Ko(t3, e5, n6, i2, r, o, a2) {
  for (; ; ) {
    const h2 = mi.distance(e5[0], e5[3]), u = mi.distance(e5[0], e5[1]) + mi.distance(e5[1], e5[2]) + mi.distance(e5[2], e5[3]);
    if (u - h2 <= i2 + n6 * u) return t3 + Q(h2, u, 0.5);
    const m3 = (t4) => ao(e5, 1, t4).length();
    {
      n2(a2 < 12);
      let h3 = m3(0), l3 = m3(1);
      r[0] += 2, h3 > l3 && (l3 = Pt(h3, h3 = l3), e5[3] = Pt(e5[0], e5[0] = e5[3]), e5[2] = Pt(e5[1], e5[1] = e5[2]));
      let c2 = h3 / (h3 + l3), g3 = 1, d3 = u;
      for (; c2 < 1 / 32 && d3 >= 32 * (i2 + n6 * d3); ) {
        g3 /= 4;
        const t4 = m3(g3);
        r[0]++, c2 = h3 / (t4 + h3);
        const s4 = new mi();
        if (Po(e5, 0.5 * g3, s4), d3 = mi.distance(s4, e5[0]), d3 <= i2) {
          const t5 = new mi();
          Po(e5, g3, t5), d3 += mi.distance(t5, s4);
        }
      }
      if (1 !== g3) {
        const s4 = Ot(mi, 4);
        po(e5, g3, e5, s4), t3 = Ko(t3, s4, n6, i2, r, 0, a2 + 1), o++, a2++;
        continue;
      }
    }
    const l2 = 8;
    r[0] += l2;
    const c = hr(l2, m3, 0, 1), g2 = 16;
    r[0] += g2;
    const d2 = hr(g2, m3, 0, 1);
    let _ = Math.abs(c - d2) > i2 + n6 * u;
    if (!_) return t3 + d2;
    if (o < 3) {
      const s4 = Ot(mi, 4);
      po(e5, 0.5, e5, s4), t3 = Ko(t3, s4, n6, i2, r, o + 1, a2 + 1), o++, a2++;
      continue;
    }
    const p3 = 32;
    r[0] += p3;
    const f3 = hr(p3, m3, 0, 1);
    if (_ = Math.abs(d2 - f3) > i2 + n6 * u, !_) return t3 + f3;
    const P5 = 64;
    r[0] += P5;
    const y2 = hr(P5, m3, 0, 1);
    if (_ = Math.abs(f3 - y2) > i2 + n6 * u, !_) return t3 + y2;
    const x4 = 128;
    r[0] += x4;
    const C3 = hr(x4, m3, 0, 1);
    return _ = Math.abs(y2 - C3) > i2 + n6 * u, t3 + C3;
  }
}
function $o(t3, e5, s4, n6, i2) {
  if (s4 === e5) return 0;
  const r = Ot(mi, 4);
  t3.queryControlPoints(r);
  const o = Ot(mi, 4);
  fo(r, e5, s4, o);
  return Ko(0, o, n6, i2, [0], 0, 0);
}
function ta(t3, e5, s4, n6, i2) {
  let r = true;
  const o = Jn(5, e5, s4, n6, i2, (e6) => {
    const s5 = uo(t3, 1, e6);
    return (r ? t3.getCoordX(e6) - t3.getStartX() : t3.getCoordY(e6) - t3.getStartY()) * s5.length();
  });
  r = false;
  const a2 = Jn(5, e5, s4, n6, i2, (e6) => {
    const s5 = uo(t3, 1, e6);
    return (r ? t3.getCoordX(e6) - t3.getStartX() : t3.getCoordY(e6) - t3.getStartY()) * s5.length();
  });
  return new mi(o, a2);
}
function ea(t3, e5, s4, n6, i2, r, o, a2, h2) {
  const u = Ot(mi, 4);
  t3.queryControlPoints(u);
  const m3 = Ot(mi, 4);
  if (e5.queryControlPoints(m3), u[0].equals(m3[0])) {
    if (u[1].equals(m3[1]) && u[2].equals(m3[2]) && u[3].equals(m3[3])) return s4 && (s4.length = 0, s4.push(u[0]), s4.push(u[3])), n6 && (n6.length = 0, n6.push(0), n6.push(1)), i2 && (i2.length = 0, i2.push(0), i2.push(1)), true;
    if (!u[0].equals(m3[3])) return false;
  }
  return !!(u[0].equals(m3[3]) && u[1].equals(m3[2]) && u[2].equals(m3[1]) && u[3].equals(m3[0])) && (n6 && (n6.length = 0, n6.push(0), n6.push(1), h2 && (n6[1] = Pt(n6[0], n6[0] = n6[1]))), i2 && (i2.length = 0, i2.push(1), i2.push(0), h2 && (i2[1] = Pt(i2[0], i2[0] = i2[1]))), s4 && (s4.length = 0, s4.push(u[0]), s4.push(u[3]), h2 && (s4[1] = Pt(s4[0], s4[0] = s4[1]))), true);
}
function sa(t3, e5, n6, i2, r, o, a2, h2, u, m3, l2, c) {
  n2(m3 + 2 === c);
  let g2 = 0, d2 = 0, _ = 0, p3 = 0, f3 = 0, P5 = 0, y2 = 0;
  const x4 = (t4, e6) => {
    const s4 = 1 - e6, a3 = n6.mul($(s4)), h3 = i2.mul(3 * e6 * s4 * s4), u2 = r.mul(3 * e6 * e6 * s4), m4 = o.mul($(e6));
    return a3.add(h3).add(u2).add(m4).sub(l2[t4]).sqrLength();
  };
  for (let s4 = 1, v3 = c - 1; s4 < v3; s4++) {
    let e6 = u[s4 - 1];
    if (t3) {
      s4 > 2 ? (e6 = Us(2 * u[s4 - 2] - u[s4 - 3], 0, 1), u[s4 - 1] = e6) : 2 === s4 && (e6 = Us(2 * u[s4 - 2], 0, 1), u[s4 - 1] = e6);
      const t4 = (t5, e7, s5) => {
        let a4 = -1;
        for (let h4 = 0; !(Math.abs(e7 - a4) < 1e-12) && 10 !== h4; h4++) {
          const h5 = e7 * e7, u2 = 1 - e7, m5 = u2 * u2, c3 = m5 * u2, g3 = n6.x - 2 * i2.x + r.x, d3 = n6.x - 3 * i2.x + 3 * r.x - o.x, _2 = n6.y - 2 * i2.y + r.y, p4 = n6.y - 3 * i2.y + 3 * r.y - o.y, f4 = n6.x - i2.x - 2 * g3 * e7 + d3 * h5, P6 = -l2[t5].x + n6.x * c3 + e7 * (3 * i2.x * m5 + e7 * (3 * r.x * u2 + o.x * e7)), y3 = n6.y - i2.y - 2 * _2 * e7 + p4 * h5, x5 = -l2[t5].y + n6.y * c3 + e7 * (3 * i2.y * m5 + e7 * (3 * r.y * u2 + o.y * e7)), C5 = -6 * (f4 * P6 + y3 * x5), v5 = 6 * (3 * H(f4) - (-2 * g3 + 2 * d3 * e7) * P6) + 6 * (3 * H(y3) - (-2 * _2 + 2 * p4 * e7) * x5);
          if (a4 = e7, 0 === v5) break;
          e7 = Us(e7 - C5 / v5, s5, 1);
        }
        return a4;
      };
      {
        const e7 = x4(s4, u[s4 - 1]);
        let n7 = t4(s4, u[s4 - 1], 0), i3 = x4(s4, n7);
        if (1.01 * e7 < i3) {
          const e8 = s4 > 1 ? u[s4 - 2] : 0, r2 = t4(s4, 0.3 * (u[s4 - 1] - e8) + e8, 0), o2 = x4(s4, r2);
          o2 < i3 && (i3 = o2, n7 = r2);
        }
        e7 > i3 && (u[s4 - 1] = n7);
      }
    }
    const a3 = u[s4 - 1], h3 = a3 * a3, m4 = h3 * a3, c2 = 1 - a3, C4 = c2 * c2, v4 = C4 * c2;
    g2 += 3 * h3 * C4 * C4, d2 += 3 * m4 * v4, _ += 3 * h3 * h3 * C4;
    const b2 = -(v4 * n6.x + m4 * o.x - l2[s4].x);
    p3 += b2 * a3 * C4, f3 += b2 * h3 * c2;
    const S3 = -(v4 * n6.y + m4 * o.y - l2[s4].y);
    P5 += S3 * a3 * C4, y2 += S3 * h3 * c2;
  }
  if (e5) {
    const t4 = g2 * _ - d2 * d2;
    Math.abs(t4) >= 1e-12 * (Math.abs(g2 * _) + Math.abs(d2 * d2)) + 1e-10 ? (a2 || (i2.x = (p3 * _ - f3 * d2) / t4, i2.y = (P5 * _ - y2 * d2) / t4), h2 || (r.x = (g2 * f3 - d2 * p3) / t4, r.y = (g2 * y2 - d2 * P5) / t4)) : (Y(n6, o, 0.3, i2), Y(n6, o, 0.6, r));
  }
  let C3 = 0;
  for (let s4 = 1, v3 = c - 1; s4 < v3; s4++) C3 += x4(s4, u[s4 - 1]);
  return C3;
}
var na = z3;
var ia = class _ia extends gs {
  constructor(t3) {
    t3 && t3.cp ? (super({ start: t3.cp[0], end: t3.cp[3], vd: t3.vd }), this.m_cp = Ot(mi, 2), this.m_cp[0].assign(t3.cp[1]), this.m_cp[1].assign(t3.cp[2])) : void 0 === t3 || jt(t3, "vd") ? (super({ vd: t3?.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = Ot(mi, 2), this.m_cp[0].setCoords(0, 0), this.m_cp[1].setCoords(0, 0)) : t3.from ? (super({ start: t3.from, end: t3.to, vd: t3.vd }), this.m_cp = Ot(mi, 2), this.m_cp[0].assign(t3.cp1), this.m_cp[1].assign(t3.cp2)) : (super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0, vd: t3.vd }), b("unrecognized constructor params"), this.m_cp = Ot(mi, 2), this.m_cp[0].setCoords(0, 0), this.m_cp[1].setCoords(0, 0)), this.m_cachedValues = 0;
  }
  getBoundary() {
    return Ks(this);
  }
  construct(t3, e5, s4, n6) {
    this.m_XStart = t3.x, this.m_YStart = t3.y, this.m_XEnd = n6.x, this.m_YEnd = n6.y, this.m_cp[0].assign(e5), this.m_cp[1].assign(s4), this.afterCompletedModification();
  }
  constructPoints(t3) {
    this.m_XStart = t3[0].x, this.m_YStart = t3[0].y, this.m_XEnd = t3[3].x, this.m_YEnd = t3[3].y, this.m_cp[0].assign(t3[1]), this.m_cp[1].assign(t3[2]), this.afterCompletedModification();
  }
  constructFromQuadratic(t3) {
    const e5 = Ot(mi, 4);
    Ki(t3, e5), this.constructPoints(e5);
  }
  constructFromQuadraticSegment(t3) {
    this.dropAllAttributes(), this.assignVertexDescription(t3.getDescription()), this.m_XStart = t3.getStartX(), this.m_YStart = t3.getStartY(), this.m_XEnd = t3.getEndX(), this.m_YEnd = t3.getEndY(), L2(2, t3.getStartXY(), t3.getControlPoint1(), 2 / 3, this.m_cp[0]), L2(2, t3.getControlPoint1(), t3.getEndXY(), 1 / 3, this.m_cp[1]), this.afterCompletedModification(), ss(this, t3);
  }
  getGeometryType() {
    return a.enumBezier;
  }
  queryEnvelope(t3) {
    if (2 !== t3.m_EnvelopeType) return void n2(0);
    if (t3.setCoords(this.getStartXY()), t3.mergeNe(this.getEndXY()), t3.contains(this.m_cp[0]) && t3.contains(this.m_cp[1])) return;
    const e5 = Jr(this);
    if (null !== e5) {
      const s4 = new mi();
      for (const n7 of e5.specialPoints) this.queryCoord2D(n7, s4), t3.mergeNe(s4);
      return;
    }
    const n6 = Ot(p2, 8), i2 = Ot(mi, 4);
    this.queryControlPoints(i2);
    const r = jo(i2, n6), o = new mi();
    for (let s4 = 1; s4 < r - 1; s4++) this.queryCoord2D(n6[s4].value(), o), t3.mergeNe(o);
  }
  applyTransformation(t3) {
    if (1 === t3.m_TransformationType) {
      const e5 = Ot(mi, 4);
      return this.queryControlPoints(e5), t3.transformPoints2D(e5, 4, e5), this.setStartXY(e5[0]), this.m_cp[0].assign(e5[1]), this.m_cp[1].assign(e5[2]), this.setEndXY(e5[3]), void $r(this);
    }
    n2(0);
  }
  createInstance() {
    return new _ia({ vd: this.m_description });
  }
  calculateLength2D() {
    return Hr(this, 1, false);
  }
  calculateLowerLength2D() {
    return mi.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return mi.distance(this.getStartXY(), this.m_cp[0]) + mi.distance(this.m_cp[0], this.m_cp[1]) + mi.distance(this.getEndXY(), this.m_cp[1]);
  }
  queryCoord2D(t3, e5) {
    return this.queryCoord2DExtends(t3, e5, true);
  }
  queryCoord2DMP(t3, e5) {
    n2(0);
  }
  queryCoord2DExtends(t3, e5, s4) {
    const n6 = Ot(mi, 4);
    this.queryControlPoints(n6), Po(n6, t3, e5, s4);
  }
  queryCoord2DE(t3, e5) {
    xo(this, t3, e5);
  }
  getCoordX(t3) {
    if (t3 < 0 || t3 > 1) {
      const e6 = new mi();
      return this.queryCoord2DExtends(t3, e6, true), e6.x;
    }
    const e5 = Q(this.getStartX(), this.m_cp[0].x, t3), s4 = Q(this.m_cp[0].x, this.m_cp[1].x, t3), n6 = Q(this.m_cp[1].x, this.getEndX(), t3), i2 = Q(e5, s4, t3), r = Q(s4, n6, t3);
    return Q(i2, r, t3);
  }
  getCoordY(t3) {
    if (t3 < 0 || t3 > 1) {
      const e6 = new mi();
      return this.queryCoord2DExtends(t3, e6, true), e6.y;
    }
    const e5 = Q(this.getStartY(), this.m_cp[0].y, t3), s4 = Q(this.m_cp[0].y, this.m_cp[1].y, t3), n6 = Q(this.m_cp[1].y, this.getEndY(), t3), i2 = Q(e5, s4, t3), r = Q(s4, n6, t3);
    return Q(i2, r, t3);
  }
  cut(t3, e5, s4) {
    const n6 = new fm();
    return this.queryCut(t3, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t3, e5, s4, n6) {
    const i2 = s4.createCubicBezier();
    if (this.cutBezierIgnoreAttributes(t3, e5, i2), n6) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e6 = 1; e6 < r; e6++) {
        const s5 = this.m_description.getSemantics(e6), n7 = na.getComponentCount(s5);
        for (let e7 = 0; e7 < n7; e7++) {
          const n8 = this.getAttributeAsDbl(t3, s5, e7);
          i2.setStartAttribute(s5, e7, n8);
        }
      }
      for (let t4 = 1; t4 < r; t4++) {
        const s5 = this.m_description.getSemantics(t4), n7 = na.getComponentCount(s5);
        for (let t5 = 0; t5 < n7; t5++) {
          const n8 = this.getAttributeAsDbl(e5, s5, t5);
          i2.setEndAttribute(s5, t5, n8);
        }
      }
    }
  }
  queryDerivative(t3, e5) {
    vo(this, t3, e5);
  }
  cutBezierIgnoreAttributes(t3, s4, n6) {
    (t3 < 0 || s4 > 1 || t3 > s4) && P("Cubic_bezier.cut_bezier_ignore_attributes");
    const i2 = Ot(mi, 4);
    this.queryControlPoints(i2);
    const r = Ot(mi, 4);
    fo(i2, t3, s4, r), n6.setControlPoints(r);
  }
  splitBezierIgnoreAttributes(t3, s4, n6) {
    this === s4 && this === n6 && P("Cubic_bezier.split_bezier_ignore_attributes");
    const i2 = Ot(mi, 4);
    this.queryControlPoints(i2);
    const r = Ot(mi, 4), o = Ot(mi, 4);
    po(i2, t3, r, o), s4 && s4.setControlPoints(r), n6 && n6.setControlPoints(o);
  }
  getAttributeAsDbl(t3, e5, s4) {
    if (0 === e5) return 0 === s4 ? this.getCoordX(t3) : this.getCoordY(t3);
    if (0 === t3) return this.getStartAttributeAsDbl(e5, s4);
    if (1 === t3) return this.getEndAttributeAsDbl(e5, s4);
    const n6 = this.getStartAttributeAsDbl(e5, s4), i2 = this.getEndAttributeAsDbl(e5, s4), r = this.calculateLength2D(), o = r > 0 ? this.tToLength(t3) / r : 0, a2 = na.getInterpolation(e5);
    return It(a2, n6, i2, o, na.getDefaultValue(e5));
  }
  getClosestCoordinate(t3, e5) {
    const s4 = [Number.NaN];
    return Ro(this, t3, x2.unit(), e5, -1, 1, s4), s4[0];
  }
  getClosestCoordinateOnInterval(t3, e5, s4 = -1) {
    const n6 = [Number.NaN];
    return 0 === Ro(this, t3, e5, false, s4, 1, n6) ? Number.NaN : n6[0];
  }
  getYMonotonicParts(t3, e5 = false) {
    return this.getMonotonicParts(t3, e5);
  }
  getMonotonicParts(t3, n6) {
    t3.length < 2 && P("");
    const i2 = Qr(this);
    if (2 === i2.specialPointsCount() && this.isMonotoneQuickAndDirty()) return 0;
    let r = 0;
    n2(t3.length >= i2.specialPointsCount() - 1);
    for (let e5 = 1, s4 = i2.specialPointsCount(); e5 < s4; ++e5) this.queryCut(i2.specialPoints[e5 - 1], i2.specialPoints[e5], t3[r], n6), r++;
    for (let e5 = 0; e5 < r; ++e5) {
      lo(t3[e5].get());
    }
    return r;
  }
  intersectionWithAxis2D(t3, e5, s4, n6) {
    const i2 = Ot(mi, 4);
    return this.queryControlPoints(i2), Zo(i2, t3, e5, s4, n6);
  }
  intersectionOfYMonotonicWithAxisX(t3, e5) {
    if (this.m_YStart === this.m_YEnd) return t3 === this.m_YStart ? e5 : Number.NaN;
    if (t3 === this.m_YStart) return this.m_XStart;
    if (t3 === this.m_YEnd) return this.m_XEnd;
    const n6 = [0, 0], i2 = this.intersectionWithAxis2D(true, t3, n6, null);
    return n2(2 !== i2), -1 === i2 ? e5 : n6[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t3) {
    return Re(this, t3);
  }
  isDegenerate3D(t3, e5) {
    return n2(0), false;
  }
  queryLooseEnvelope(t3) {
    if (2 === t3.m_EnvelopeType) return t3.setCoords({ pt: this.getStartXY() }), t3.mergeNe(this.m_cp[0]), t3.mergeNe(this.m_cp[1]), void t3.mergeNe(this.getEndXY());
    n2(0);
  }
  clone(t3) {
    const e5 = this.createInstance();
    return this.copyTo(e5), e5;
  }
  queryInterval(t3, e5) {
    if (0 === t3) {
      const t4 = n4.constructEmpty();
      this.queryEnvelope(t4);
      const s4 = x2.constructEmpty();
      return 0 === e5 ? t4.queryIntervalX(s4) : t4.queryIntervalY(s4), s4;
    }
    return super.queryInterval(t3, e5);
  }
  queryLooseEnvelopeOnInterval(t3, e5) {
    const s4 = Ot(mi, 4);
    this.queryControlPoints(s4), fo(s4, t3.vmin, t3.vmax, s4), e5.setFromPoints(s4, 4);
  }
  changeEndPoints2D(t3, e5) {
    if (t3.isEqual(this.m_XStart, this.m_YStart) && e5.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s4 = this.m_cp[0].isEqual(this.m_XStart, this.m_YStart), n6 = this.m_cp[0].isEqual(this.m_XEnd, this.m_YEnd), i2 = this.m_cp[1].isEqual(this.m_XStart, this.m_YStart), r = this.m_cp[1].isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t3), this.setEndXY(e5), s4 ? this.m_cp[0].setCoordsPoint2D(t3) : n6 && this.m_cp[0].setCoordsPoint2D(e5), r ? this.m_cp[1].setCoordsPoint2D(e5) : i2 && this.m_cp[1].setCoordsPoint2D(t3), this.normalizeAfterEndpointChange();
  }
  tToLength(t3) {
    return Hr(this, t3, true);
  }
  lengthToT(t3) {
    return Ur(this, t3);
  }
  calculateWeightedAreaCentroid2D(t3) {
    const e5 = Ot(mi, 4);
    Br(this, e5);
    const s4 = e5[3], n6 = e5[2], i2 = e5[1], r = new mi();
    r.x = (5 * s4.x * s4.x * (7 * n6.y + 16 * i2.y) + s4.x * (-35 * s4.y * n6.x + 40 * n6.x * n6.y - 80 * s4.y * i2.x + 140 * n6.x * i2.y + 112 * i2.x * i2.y) - 2 * (s4.y * (20 * n6.x * n6.x + 70 * n6.x * i2.x + 56 * i2.x * i2.x) - 7 * (4 * n6.x + 5 * i2.x) * (-n6.y * i2.x + n6.x * i2.y))) / 840, r.y = (-5 * s4.y * s4.y * (7 * n6.x + 16 * i2.x) + s4.y * (5 * s4.x * (7 * n6.y + 16 * i2.y) - 4 * (10 * n6.x * n6.y + 35 * n6.y * i2.x + 28 * i2.x * i2.y)) + 2 * (-7 * (4 * n6.y + 5 * i2.y) * (n6.y * i2.x - n6.x * i2.y) + s4.x * (20 * n6.y * n6.y + 70 * n6.y * i2.y + 56 * i2.y * i2.y))) / 840;
    const o = mo(this);
    return r.x += (e5[0].x - t3.x) * o, r.y += (e5[0].y - t3.y) * o, r;
  }
  calculateWeightedCentroid2D() {
    const t3 = new mi();
    return this.isDegenerate(0) ? (t3.setCoords(0, 0), t3) : zr(this) ? (t3.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t3) : (t3.assign(Or(this, 1)), t3);
  }
  getControlPoint1() {
    return this.m_cp[0].clone();
  }
  setControlPoint1(t3) {
    this.m_cp[0].setCoordsPoint2D(t3), this.afterCompletedModification();
  }
  getControlPoint2() {
    return this.m_cp[1].clone();
  }
  setControlPoint2(t3) {
    this.m_cp[1].setCoordsPoint2D(t3), this.afterCompletedModification();
  }
  queryControlPoints(t3) {
    t3[0].assign(this.getStartXY()), t3[1].assign(this.m_cp[0]), t3[2].assign(this.m_cp[1]), t3[3].assign(this.getEndXY());
  }
  queryControlPointsHelper(t3) {
    return this.queryControlPoints(t3), 4;
  }
  setControlPoints(t3) {
    for (let s4 = 0; s4 < 4; s4++) t3[s4].isNAN() && P("NAN control points in bezier are not supported");
    this.m_XStart = t3[0].x, this.m_YStart = t3[0].y, this.m_cp[0].setCoordsPoint2D(t3[1]), this.m_cp[1].setCoordsPoint2D(t3[2]), this.m_XEnd = t3[3].x, this.m_YEnd = t3[3].y, this.afterCompletedModification();
  }
  getTangent(t3) {
    const e5 = Ot(mi, 4);
    return this.queryControlPoints(e5), Co(e5, t3);
  }
  getDerivative(t3) {
    const e5 = Ot(mi, 4);
    return this.queryControlPoints(e5), ao(e5, 1, t3);
  }
  getCurvature(t3) {
    const e5 = uo(this, 1, t3), s4 = uo(this, 2, t3), n6 = e5.sqrLength();
    if (0 === n6) return Number.NaN;
    e5.divThis(Math.sqrt(n6));
    return e5.crossProduct(s4) / n6;
  }
  isIntersectingPoint(t3, e5, s4) {
    if (s4 && (t3.equals(this.getStartXY()) || t3.equals(this.getEndXY()))) return false;
    const n6 = new n4();
    if (this.queryLooseEnvelope(n6), n6.inflateCoords(e5, e5), !n6.contains(t3)) return false;
    const i2 = this.getClosestCoordinate(t3, false), r = new mi();
    this.queryCoord2D(i2, r);
    return mi.distance(r, t3) <= e5;
  }
  isIntersectingPoint3D(t3, e5, n6, i2, r = 1) {
    return n2(0), false;
  }
  isMonotoneQuickAndDirty() {
    const t3 = Ot(mi, 4);
    return this.queryControlPoints(t3), go(t3);
  }
  getMonotonicPartParams(t3, n6) {
    const i2 = Qr(this), r = i2.specialPointsCount();
    if (n2(us.s_maxMonotonicPartParams >= r), !n6) return i2.specialPointsCount();
    t3 < r && P("");
    for (let e5 = 0; e5 < r; e5++) n6[e5] = i2.specialPoints[e5];
    return r;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Pt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Pt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t3 = 0, e5 = this.m_description.getTotalComponentCount() - 2; t3 < e5; t3++) this.m_attributes[t3 + e5] = Pt(this.m_attributes[t3], this.m_attributes[t3] = this.m_attributes[t3 + e5]);
      this.m_cp[1] = Pt(this.m_cp[0], this.m_cp[0] = this.m_cp[1]), this.m_cachedValues = null;
    }
  }
  findMinDeriv() {
    const t3 = new p2();
    return io(this, t3), t3.value();
  }
  isLine() {
    return false;
  }
  isDegenerateToLineHelper(t3) {
    const e5 = Ot(mi, 4);
    this.queryControlPoints(e5);
    const s4 = e5[3].sub(e5[0]), n6 = s4.length();
    if (mi.distance(e5[0], e5[1]) + mi.distance(e5[2], e5[1]) + mi.distance(e5[2], e5[3]) - n6 > t3) return false;
    const i2 = t3;
    let r = e5[1].clone();
    r.subThis(e5[0]);
    let o = Math.abs(r.crossProduct(s4)) / n6;
    return !(o > i2) && (r = e5[2].clone(), r.subThis(e5[1]), o = Math.abs(r.crossProduct(s4)) / n6, !(o > i2));
  }
  copyIgnoreAttributes(t3) {
    const e5 = Ot(mi, 4);
    this.queryControlPoints(e5), t3.setControlPoints(e5);
  }
  calculateArea2DHelper() {
    return mo(this);
  }
  absNorm() {
    return zo(this);
  }
  queryEnvelopeW(t3, e5) {
    qo(this, t3, e5);
  }
  setSegmentFromCoordsForStitcher(t3, e5) {
    ko(this, t3, e5);
  }
  writeInBufferStream(t3, e5) {
    const s4 = new Float64Array(4);
    return this.writeInBuffer_(s4), t3.writeRangeFromArray(e5, s4.length, s4, true, 1), e5 + s4.length;
  }
  writeInBuffer_(t3) {
    return t3[0] = this.m_cp[0].x, t3[1] = this.m_cp[0].y, t3[2] = this.m_cp[1].x, t3[3] = this.m_cp[1].y, 4;
  }
  readFromBufferStream(t3, e5) {
    const s4 = new Float64Array(4);
    t3.queryRange(e5, s4.length, s4, true, 1), this.readFromBuffer_(s4);
  }
  readFromBuffer_(t3) {
    this.m_cp = Ot(mi, 2), this.m_cp[0].x = t3[0], this.m_cp[0].y = t3[1], this.m_cp[1].x = t3[2], this.m_cp[1].y = t3[3], this.m_cachedValues = null;
  }
  snapControlPoints(t3) {
    const e5 = Ot(mi, 4);
    this.queryControlPoints(e5);
    const s4 = (e6, s5, n7) => {
      let i3 = false;
      if (mi.sqrDistance(e6, n7) <= t3) {
        i3 = !e6.equals(n7), e6.setCoordsPoint2D(n7);
        mi.sqrDistance(s5, n7) <= t3 && (i3 ||= !s5.equals(n7), s5.setCoordsPoint2D(n7));
      }
      return i3;
    }, n6 = s4(e5[1], e5[2], e5[0]), i2 = s4(e5[2], e5[1], e5[3]);
    return (n6 || i2) && this.setControlPoints(e5), n6 || i2;
  }
  needsSnapControlPoints(t3) {
    if (!t3) return false;
    const e5 = Ot(mi, 4);
    this.queryControlPoints(e5);
    const s4 = (e6, s5, n7) => {
      let i3 = false;
      if (mi.sqrDistance(e6, n7) <= t3) {
        i3 = !e6.equals(n7), e6.setCoordsPoint2D(n7);
        mi.sqrDistance(s5, n7) <= t3 && (i3 ||= !s5.equals(n7), s5.setCoordsPoint2D(n7));
      }
      return i3;
    }, n6 = s4(e5[1], e5[2], e5[0]), i2 = s4(e5[2], e5[1], e5[3]);
    return n6 || i2;
  }
  calculateSpecialPointsForCracking(t3, e5) {
    return Qo(this, t3, e5);
  }
  ensureXYMonotone() {
    return lo(this);
  }
  setCoordsForIntersector(t3, e5, s4) {
    eo(this, t3, e5, s4);
  }
  copyToImpl(t3) {
    const e5 = t3;
    e5.m_cp[0].assign(this.m_cp[0]), e5.m_cp[1].assign(this.m_cp[1]), Kr(e5, Jr(this));
  }
  reverseImpl() {
    this.m_cp[1] = Pt(this.m_cp[0], this.m_cp[0] = this.m_cp[1]);
  }
  equalsImpl(t3) {
    const e5 = t3, s4 = 0, n6 = 1;
    return !!this.m_cp[0].equals(e5.m_cp[s4]) && !!this.m_cp[1].equals(e5.m_cp[n6]);
  }
  equalsImplTol(t3, e5) {
    const s4 = t3, n6 = 0, i2 = 1;
    return !!this.m_cp[0].isEqualPoint2D(s4.m_cp[n6], e5) && !!this.m_cp[1].isEqualPoint2D(s4.m_cp[i2], e5);
  }
  swapImpl(t3) {
    const e5 = t3;
    e5.m_cp[0] = Pt(this.m_cp[0], this.m_cp[0] = e5.m_cp[0]), e5.m_cp[1] = Pt(this.m_cp[1], this.m_cp[1] = e5.m_cp[1]), to(this, e5);
  }
  afterCompletedModification() {
    $r(this);
  }
  isIntersecting(t3, e5, s4) {
    return 0 !== rm(false, this, t3, e5, s4);
  }
  intersect(t3, e5, s4, n6, i2) {
    return um(false, this, t3, e5, s4, n6, i2);
  }
  intersectPoint(t3, e5, s4) {
    return Xo(this, t3, e5, s4);
  }
  endPointModified() {
    $r(this);
  }
  clearEndPointModified() {
  }
};
ia.type = a.enumBezier;
var ra = class {
  constructor() {
    this.length = Number.NaN, this.area = Number.NaN, this.centroidX = Number.NaN, this.centroidY = 0, this.specialPoints = [], this.specialPointsLength = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
function oa(t3, e5, n6, i2, r, o, a2, h2) {
  for (; ; ) {
    const u = mi.distance(e5[0], e5[2]), m3 = mi.distance(e5[0], e5[1]) + mi.distance(e5[1], e5[2]);
    if (m3 - u <= r + i2 * m3) return t3 + Q(u, m3, 0.5);
    const l2 = Ot(mi, 4), c = (t4) => {
      fa(e5, n6, 1, t4, l2);
      return l2[1].length();
    };
    if (0 === a2 && h2 < 8) {
      n2(h2 < 8);
      let u2 = c(0), l3 = c(1);
      o[0] += 2, u2 > l3 && (l3 = Pt(u2, u2 = l3), e5[2] = Pt(e5[0], e5[0] = e5[2]), n6[2] = Pt(n6[0], n6[0] = n6[2]));
      let g3 = u2 / (u2 + l3), d3 = 1, _2 = m3;
      for (; g3 < 1 / 32 && _2 >= r + i2 * _2; ) {
        d3 /= 4;
        const t4 = c(d3);
        o[0]++, g3 = u2 / (t4 + u2);
        const s4 = new mi();
        if (_h(e5, n6, 0.5 * d3, s4), _2 = mi.distance(s4, e5[0]), _2 <= r) {
          const t5 = new mi();
          _h(e5, n6, d3, t5), _2 += mi.distance(t5, s4);
        }
      }
      if (1 !== d3) {
        const s4 = Ot(mi, 3), u3 = [0, 0, 0];
        Oa(e5, n6, d3, e5, n6, s4, u3), t3 = oa(t3, s4, u3, i2, r, o, 0, h2 + 1), a2++, h2++;
        continue;
      }
    }
    let g2 = false;
    const d2 = 8;
    o[0] += d2;
    const _ = hr(d2, c, 0, 1), p3 = 16;
    o[0] += p3;
    const f3 = hr(p3, c, 0, 1);
    if (g2 = Math.abs(_ - f3) > r + i2 * m3, !g2) return t3 + f3;
    if (a2 < 8 && h2 < 9) {
      const s4 = Ot(mi, 3), u2 = [0, 0, 0];
      Oa(e5, n6, 0.5, e5, n6, s4, u2), t3 = oa(t3, s4, u2, i2, r, o, a2 + 1, h2 + 1), a2++, h2++;
      continue;
    }
    const P5 = 32;
    o[0] += P5;
    const y2 = hr(P5, c, 0, 1);
    if (g2 = Math.abs(f3 - y2) > r + i2 * m3, !g2) return t3 + y2;
    const x4 = 64;
    o[0] += x4;
    const C3 = hr(x4, c, 0, 1);
    if (g2 = Math.abs(y2 - C3) > r + i2 * m3, !g2) return t3 + C3;
    const v3 = 128;
    o[0] += v3;
    const b2 = hr(v3, c, 0, 1);
    return g2 = Math.abs(C3 - b2) > r + i2 * m3, t3 + b2;
  }
}
function aa(t3, e5, s4, n6, i2) {
  if (s4 === e5) return 0;
  const r = Ot(mi, 3), o = [0, 0, 0];
  t3.queryControlPoints(r), t3.queryWeights(o);
  const a2 = [0, 0, 0], h2 = Ot(mi, 3);
  Qa(r, o, e5, s4, h2, a2);
  return oa(0, h2, a2, n6, i2, [0], 0, 0);
}
var ha = class {
  constructor(t3, e5, s4) {
    this.controlPoints = Qt(t3, 3), this.weights = [0, 0, 0], Dt(this.weights, e5, 0, 0, 3), this.point = s4.clone();
  }
  getMaxDerivative() {
    return 3;
  }
  getValue(t3, e5) {
    if (0 === t3) {
      const t4 = new mi();
      _h(this.controlPoints, this.weights, e5, t4);
      const s4 = Ot(mi, 4);
      fa(this.controlPoints, this.weights, 1, e5, s4);
      return 2 * t4.sub(this.point).dotProduct(s4[1]);
    }
    if (1 === t3) {
      const t4 = new mi();
      _h(this.controlPoints, this.weights, e5, t4);
      const s4 = Ot(mi, 4);
      fa(this.controlPoints, this.weights, 2, e5, s4);
      return 2 * (t4.sub(this.point).dotProduct(s4[2]) + s4[1].dotProduct(s4[1]));
    }
    if (2 === t3) {
      const t4 = new mi();
      _h(this.controlPoints, this.weights, e5, t4);
      const s4 = Ot(mi, 4);
      fa(this.controlPoints, this.weights, 3, e5, s4);
      return 2 * (t4.sub(this.point).dotProduct(s4[3]) + 3 * s4[1].dotProduct(s4[2]));
    }
    return 0;
  }
  getError(t3) {
    return n2(0), 0;
  }
};
function ua(t3, e5, s4, n6) {
  const i2 = Ba(0, 0, 0, 0, mi.getNAN()), r = Yt(18, Number.NaN), o = Ot(mi, 3);
  t3.queryControlPoints(o), o[2].subThis(e5), o[1].subThis(e5), o[0].subThis(e5);
  const a2 = [0, 0, 0];
  t3.queryWeights(a2);
  const h2 = [1, fh(a2), 1], u = yh(a2, s4), m3 = yh(a2, n6), l2 = tn(new ha(o, h2, new mi(0, 0)), x2.construct(u, m3), 18, r);
  _h(o, h2, u, i2.pt), i2.t = u, i2.d = mi.distance(i2.pt, new mi(0, 0));
  const c = new mi();
  _h(o, h2, m3, c);
  const g2 = mi.distance(c, new mi(0, 0));
  g2 < i2.d && (i2.d = g2, i2.t = m3, i2.pt.assign(c));
  for (let d2 = 0; d2 < l2; d2++) {
    _h(o, h2, r[d2], c);
    const t4 = mi.distance(c, new mi(0, 0));
    t4 < i2.d && (i2.d = t4, i2.t = Ph(a2, r[d2]), i2.pt.assign(c));
  }
  return i2;
}
function ma(t3, e5, s4, n6, i2) {
  let r = true;
  const o = Ot(mi, 4), a2 = Jn(5, e5, s4, n6, i2, (e6) => {
    pa(t3, 1, e6, o);
    return (r ? t3.getCoordX(e6) - t3.getStartX() : t3.getCoordY(e6) - t3.getStartY()) * o[1].length();
  });
  r = false;
  const h2 = Jn(5, e5, s4, n6, i2, (e6) => {
    pa(t3, 1, e6, o);
    return (r ? t3.getCoordX(e6) - t3.getStartX() : t3.getCoordY(e6) - t3.getStartY()) * o[1].length();
  });
  return new mi(a2, h2);
}
function la(t3) {
  t3.m_cachedValues = null;
}
function ca(t3, e5) {
  e5.m_cachedValues = Pt(t3.m_cachedValues, t3.m_cachedValues = e5.m_cachedValues);
}
function ga(t3) {
  if (t3.m_cachedValues) return t3.m_cachedValues;
  const e5 = new ra(), s4 = Ot(mi, 3);
  t3.queryControlPoints(s4);
  const n6 = [0, 0, 0];
  return t3.queryWeights(n6), da(s4, n6, e5.specialPoints), La(t3, e5), e5;
}
function da(t3, e5, s4) {
  if (0 === e5[1]) return s4.length = 0, s4.push(0), void s4.push(1);
  const n6 = Ot(p2, 8);
  n6[0].set(0);
  let i2 = 1;
  {
    const s5 = new p2(t3[1].x).subThis(t3[0].x).mulThis(e5[1]).mulThis(e5[0]), r = new p2(t3[2].x).subThis(t3[0].x).mulThis(e5[2]).mulThis(e5[0]), o = s5.subE(r).addThisE(new p2(t3[2].x).subThis(t3[1].x).mulThis(e5[2]).mulThis(e5[1]));
    r.subThisE(s5.mul(2));
    const a2 = Ot(p2, 2);
    let h2 = gn(o, r, s5, new x2(0, 1), false, a2);
    h2 < 0 && (h2 = 0);
    for (let t4 = 0; t4 < h2; t4++) Vs(a2[t4].value(), 0, 1) || (n6[i2] = a2[t4], i2++);
  }
  {
    const s5 = new p2(t3[1].y).subThis(t3[0].y).mulThis(e5[1]).mulThis(e5[0]), r = new p2(t3[2].y).subThis(t3[0].y).mulThis(e5[2]).mulThis(e5[0]), o = s5.subE(r).addThisE(new p2(t3[2].y).subThis(t3[1].y).mulThis(e5[2]).mulThis(e5[1]));
    r.subThisE(s5.mul(2));
    const a2 = Ot(p2, 2);
    let h2 = gn(o, r, s5, new x2(0, 1), false, a2);
    h2 < 0 && (h2 = 0);
    for (let t4 = 0; t4 < h2; t4++) Vs(a2[t4].value(), 0, 1) || (n6[i2] = a2[t4], i2++);
  }
  if (n6[i2].set(1), i2++, i2 > 2) {
    Zt(n6, 0, i2, (t5, e7) => Ct(t5.value(), e7.value()));
    let t4 = 0, e6 = n6[0].value(), s5 = 1;
    for (let r = 1; r < i2; r++) n6[r].eq(n6[r - 1]) ? (e6 += n6[r].value(), s5++) : (s5 > 1 && (e6 /= s5, n6[t4].set(e6)), t4++, n6[t4] = n6[r], e6 = n6[r].value(), s5 = 1);
    t4++, i2 = t4;
  }
  n6[0].set(0), n6[i2 - 1].set(1), s4.length = i2;
  for (let r = 0; r < i2; r++) s4[r] = n6[r].value();
}
function _a(t3, e5, s4) {
  if (s4) {
    if (e5 < 0) return e5;
    if (e5 > 1) return e5 - 1 + _a(t3, 1, false);
  }
  if (t3.isDegenerate(0)) return 0;
  const n6 = 1 === e5, i2 = ga(t3);
  if (n6 && !Number.isNaN(i2.length)) return i2.length;
  const r = Xa(t3), o = r / t3.calculateUpperLength2D();
  let a2 = 0, h2 = 0;
  for (let u = 1, m3 = i2.specialPointsCount(); u < m3; u++) {
    const s5 = i2.specialPoints[u];
    if (a2 += aa(t3, h2, Math.min(e5, s5), o, r), e5 <= s5) break;
    h2 = s5;
  }
  return n6 && (i2.length = a2), a2;
}
function pa(t3, e5, s4, n6) {
  const i2 = Ot(mi, 3);
  t3.queryControlPoints(i2);
  const r = [0, 0, 0];
  t3.queryWeights(r), fa(i2, r, e5, s4, n6);
}
function fa(t3, e5, s4, n6, i2) {
  const r = [t3[0], t3[1], t3[2]], o = [e5[0], e5[1], e5[2]], a2 = Ot(mi, 4);
  Pa(r, o, s4, n6, a2);
  for (let h2 = 0; h2 <= s4; h2++) i2[h2].setCoords(a2[h2].x, a2[h2].y);
}
function Pa(t3, e5, n6, i2, r) {
  n2(n6 > 0);
  const o = [t3[0].clone(), t3[1].clone(), t3[2].clone()];
  if (!o[0].isZero()) {
    for (let t4 = 1; t4 < 3; ++t4) o[t4].subThis(o[0]);
    o[0].setCoords(0, 0);
  }
  const a2 = ya(o, e5, 0, i2), u = Ca(e5, 0, i2), m3 = a2.divide(u);
  if (r[0].assign(m3), 0 === n6) return;
  const l2 = [e5[1] * e5[0], e5[2] * e5[0] * 0.5, e5[1] * e5[2]], c = [t3[1].sub(t3[0]), t3[2].sub(t3[0]), t3[2].sub(t3[1])], g2 = u * u, d2 = ya(c, l2, 0, i2).mul(2).divide(g2);
  if (r[1].assign(d2), 1 === n6) return;
  const _ = Ca(e5, 1, i2), p3 = 2 * u * _, f3 = ya(c, l2, 1, i2).mul(2).sub(d2.mul(p3)).divide(g2);
  if (r[2].assign(f3), 2 === n6) return;
  const P5 = ya(c, l2, 2, i2).mul(2), y2 = 2 * (_ * _ + u * Ca(e5, 2, i2)), x4 = P5.sub(f3.mul(p3).mul(2)).sub(d2.mul(y2)).divide(g2);
  r[3].assign(x4), 3 !== n6 && b("");
}
function ya(t3, e5, s4, n6) {
  if (0 === s4) {
    if (n6 <= 0.5) {
      const s5 = new mi();
      k2(2, t3[0].mul(e5[0]), t3[1].mul(e5[1]), n6, s5);
      const i2 = new mi();
      k2(2, t3[1].mul(e5[1]), t3[2].mul(e5[2]), n6, i2);
      const r = new mi();
      return k2(2, s5, i2, n6, r), r;
    }
    {
      const s5 = new mi();
      F(2, t3[0].mul(e5[0]), t3[1].mul(e5[1]), n6, s5);
      const i2 = new mi();
      F(2, t3[1].mul(e5[1]), t3[2].mul(e5[2]), n6, i2);
      const r = new mi();
      return F(2, s5, i2, n6, r), r;
    }
  }
  if (1 === s4) {
    const s5 = t3[1].mul(e5[1]), i2 = s5.sub(t3[0].mul(e5[0])).mul(1 - n6).add(t3[2].mul(e5[2]).sub(s5).mul(n6));
    return i2.mulThis(2), i2;
  }
  if (2 === s4) {
    const s5 = t3[1].mul(e5[1]), n7 = t3[2].mul(e5[2]).sub(s5).sub(s5.sub(t3[0].mul(e5[0])));
    return n7.mulThis(2), n7;
  }
  b("");
}
function xa(t3, e5, s4, n6) {
  if (n6.toDouble() <= 0.5) {
    const s5 = new Ye();
    O(2, t3[0].mulE(e5[0]), t3[1].mulE(e5[1]), n6, s5);
    const i2 = new Ye();
    O(2, t3[1].mulE(e5[1]), t3[2].mulE(e5[2]), n6, i2);
    const r = new Ye();
    return O(2, s5, i2, n6, r), r;
  }
  {
    const s5 = new Ye();
    G2(2, t3[0].mulE(e5[0]), t3[1].mulE(e5[1]), n6, s5);
    const i2 = new Ye();
    G2(2, t3[1].mulE(e5[1]), t3[2].mulE(e5[2]), n6, i2);
    const r = new Ye();
    return G2(2, s5, i2, n6, r), r;
  }
}
function Ca(t3, e5, s4) {
  if (0 === e5) {
    const e6 = Q(t3[0], t3[1], s4), n6 = Q(t3[1], t3[2], s4);
    return Q(e6, n6, s4);
  }
  if (1 === e5) {
    return 2 * ((1 - s4) * (t3[1] - t3[0]) + (t3[2] - t3[1]) * s4);
  }
  if (2 === e5) {
    return 2 * (t3[2] - t3[1] - (t3[1] - t3[0]));
  }
  b("");
}
function va(t3, e5, s4) {
  if (s4.toDouble() <= 0.5) {
    const e6 = A2(t3[0], t3[1], s4), n6 = A2(t3[1], t3[2], s4);
    return A2(e6, n6, s4);
  }
  {
    const e6 = P2(t3[0], t3[1], s4), n6 = P2(t3[1], t3[2], s4);
    return P2(e6, n6, s4);
  }
}
function ba(t3, e5, s4, n6, i2) {
  const r = [Ye.constructPoint2D(t3[0]), Ye.constructPoint2D(t3[1]), Ye.constructPoint2D(t3[2])];
  r[2].subThisE(r[0]), r[1].subThisE(r[0]), r[0].setCoords(0, 0);
  Sa(r, [new p2(e5[0]), new p2(e5[1]), new p2(e5[2])], s4, n6, i2);
}
function Sa(t3, e5, n6, i2, r) {
  n2(n6 > 0);
  const o = [t3[0].clone(), t3[1].clone(), t3[2].clone()];
  if (!o[0].isZero()) {
    for (let t4 = 1; t4 < 3; ++t4) o[t4].subThisE(o[0]);
    o[0] = Ye.constructCoords(0, 0);
  }
  const a2 = xa(o, e5, 0, i2), h2 = va(e5, 0, i2), u = a2.divE(h2);
  r[0].setE(u);
  const m3 = [e5[1].mulE(e5[0]), e5[2].mulE(e5[0]).mul(0.5), e5[1].mulE(e5[2])], l2 = xa([t3[1].subE(t3[0]), t3[2].subE(t3[0]), t3[2].subE(t3[1])], m3, 0, i2).mul(2), c = h2.sqr(), g2 = l2.divE(c);
  r[1].setE(g2);
}
function Ea(t3, e5, s4) {
  const n6 = Ot(mi, 3);
  t3.queryControlPoints(n6);
  const i2 = Yt(3, Number.NaN);
  t3.queryWeights(i2), Da(n6, i2, e5, s4);
}
function Da(t3, e5, s4, n6) {
  s4.value() < 0 && s4.set(0, s4.eps()), s4.value() > 1 && s4.set(1, s4.eps());
  const i2 = Ot(Ye, 4);
  ba(t3, e5, 1, s4, i2), n6.setE(i2[1]);
}
function wa(t3, e5, s4) {
  const n6 = Us(s4, 0, 1), i2 = Ot(mi, 4);
  if (fa(t3, e5, 3, n6, i2), i2[1].isZero()) {
    if (i2[2].isZero()) return i2[3];
    {
      const t4 = i2[2].clone();
      return 1 === n6 && t4.negateThis(), t4;
    }
  }
  return i2[1];
}
var Aa = class {
  constructor(t3, e5) {
    this.len = 0, this.b = t3, this.len = e5;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t3, e5) {
    return 0 === t3 ? this.len - _a(this.b, e5, false) : 0;
  }
  getError(t3) {
    return n2(0), 0;
  }
};
function Ta(t3, e5, s4) {
  const n6 = _a(t3, 1, false);
  if (e5 <= 0) return e5;
  if (e5 >= n6) return e5 - n6 + 1;
  const i2 = [0];
  return 1 !== tn(new Aa(t3, e5), x2.unit(), 1, i2) && b(""), i2[0];
}
function Ia(t3) {
  const e5 = Ot(mi, 3), s4 = [0, 0, 0];
  return t3.queryControlPoints(e5), t3.queryWeights(s4), Ma(e5, s4);
}
function Ma(t3, e5) {
  const n6 = fh(e5);
  if (1 === n6) {
    return fi(t3);
  }
  if (0 === n6) return 0;
  const i2 = [new mi(0, 0), t3[1].sub(t3[0]), t3[2].sub(t3[0])], r = i2[1].crossProduct(i2[2]);
  if (n6 < 1) {
    n2(n6 > 0);
    const t4 = 1 - n6;
    let e6;
    if (t4 < 0.01) e6 = -1 / 3 + t4 * (2 / 15 + t4 * (3 / 35 + t4 * (16 / 315 + t4 * (20 / 693 + t4 * (16 / 1001 + t4 * (56 / 6435))))));
    else {
      const s4 = t4 * (1 + n6), i3 = Math.atan2(Math.sqrt(t4), Math.sqrt(1 + n6));
      e6 = n6 * (0.5 * n6 - J(s4) * i3) / s4;
    }
    return r * e6;
  }
  {
    const t4 = (n6 - 1) * (n6 + 1);
    return 0.25 * n6 / Math.pow(t4, 1.5) * (-2 * n6 * Math.sqrt(t4) * r - 4 * i2[1].y * i2[2].x * Math.atanh(Math.sqrt((n6 - 1) / (n6 + 1))) - i2[1].x * i2[2].y * Math.log(2 * n6 * (n6 - Math.sqrt(t4)) - 1));
  }
}
function Ya(t3, e5) {
  const n6 = fh(e5);
  if (1 === n6) {
    const e6 = Ot(mi, 3);
    zi(t3, e6);
    const s4 = e6[2].clone(), n7 = e6[1].clone(), i3 = new mi(), r2 = s4.y * n7.x - s4.x * n7.y;
    return i3.x = -(4 * s4.x + 5 * n7.x) * r2 / 60, i3.y = -(4 * s4.y + 5 * n7.y) * r2 / 60, i3;
  }
  if (0 === n6) return new mi(0, 0);
  n2(n6 > 0);
  const i2 = t3[1].sub(t3[0]), r = t3[2].sub(t3[0]);
  if (n6 < 1) {
    const t4 = Math.sqrt(1 - n6), e6 = Math.sqrt(1 + n6), s4 = (i2.y * r.x - i2.x * r.y) * n6 / Math.pow(t4 * e6, 5) / 12, o = Math.atan2(t4, e6), a2 = n6 * t4 * e6, h2 = n6 * n6, u = i2.mul(2 * (2 + h2)), m3 = r.mul(2 * h2 - 5), l2 = u.add(m3).mul(a2), c = r.sub(i2.mul(2 * h2)).mul(6 * o);
    return l2.add(c).mul(s4);
  }
  {
    const t4 = Math.sqrt(n6 - 1), e6 = Math.sqrt(n6 + 1), s4 = (i2.y * r.x - i2.x * r.y) * n6 / Math.pow(t4 * e6, 5) / 12, o = Math.atanh(t4 / e6), a2 = n6 * t4 * e6, h2 = n6 * n6, u = i2.mul(4).sub(r.mul(5)), m3 = i2.add(r).mul(2 * h2), l2 = u.add(m3).mul(a2), c = r.sub(i2.mul(2 * h2)).mul(6 * o);
    return l2.add(c).mul(s4);
  }
}
function Na(t3) {
  const e5 = Ot(mi, 3), s4 = [0, 0, 0];
  return t3.queryControlPoints(e5), t3.queryWeights(s4), Ya(e5, s4);
}
function Xa(t3) {
  return qa(t3.calculateUpperLength2D());
}
function qa(t3) {
  return 256 * Qs() * t3;
}
function Fa(t3) {
  if (0 === t3.m_weights[1]) return true;
  const e5 = mi.distance(t3.getStartXY(), t3.getEndXY()), s4 = t3.calculateUpperLength2D();
  return s4 - e5 <= 8 * Number.EPSILON * s4;
}
function Va(t3) {
  return t3.m_cachedValues;
}
function La(t3, e5) {
  t3.m_cachedValues = e5;
}
function Ra(t3, e5, s4, n6, i2) {
  const r = Ot(mi, 3);
  t3.queryControlPoints(r);
  const o = [0, 0, 0];
  t3.queryWeights(o);
  const a2 = [0];
  return 1 === za(r, o, e5, x2.unit(), n6, i2, 1, a2) ? a2[0] : Number.NaN;
}
function za(t3, e5, n6, i2, r, o, a2, h2) {
  D(x2.unit().contains(i2) && a2 > 0, ""), (o < 0 || Number.isNaN(o)) && (o = Number.MAX_VALUE);
  const u = new Array(3);
  for (let s4 = 0; s4 < 3; ++s4) u[s4] = t3[s4].sub(n6);
  const m3 = fh(e5), l2 = Xe.constructPoint2D(u[0]), c = Xe.constructPoint2D(u[1]), g2 = Xe.constructPoint2D(u[2]), d2 = si.constructDouble(m3), p3 = d2.clone();
  p3.ldexpThis(1);
  const f3 = l2.dotProduct(c.sub(l2)).mul(d2), P5 = d2.mul(d2.addDouble(2)), y2 = g2.sub(c.mul(P5.ldexp(1))), x4 = c.sqrLength().mul(d2.mul(d2).ldexp(1)).add(l2.sqrLength().mul(d2.ldexp(2).subDouble(1))).add(l2.dotProduct(y2)), C3 = g2.sub(c.mul(p3)).add(l2.mul(p3.subDouble(1))), v3 = c.mul(d2).sub(l2).dotProduct(C3).mulDouble(3), b2 = c.dotProduct(g2).mul(d2.subDouble(3).mul(d2)).ldexp(1), S3 = c.sqrLength().mul(d2.mul(d2).ldexp(2)), E2 = l2.sqrLength().mul(d2.ldexp(2).subDouble(3)), D3 = l2.dotProduct(g2.sub(c.mul(d2.mulDouble(3).subDouble(1)).mul(d2))).ldexp(1), w4 = g2.sqrLength().addThis(b2).addThis(S3).addThis(E2).addThis(D3), A4 = l2.add(g2).sub(c.mul(p3)), T3 = d2.subDouble(1), I4 = g2.sub(l2).dotProduct(A4).mul(T3), M2 = new mi(0, 0), Y3 = [];
  let N2 = new mi();
  _h(u, e5, i2.vmin, N2);
  let X3 = mi.distance(N2, M2);
  if (X3 <= o && Y3.push(new mi(i2.vmin, X3)), i2.vmin !== i2.vmax && (_h(u, e5, i2.vmax, N2), X3 = mi.distance(N2, M2), X3 <= o && Y3.push(new mi(i2.vmax, X3))), i2.width() > 0) {
    const t4 = u[2].isZero(), s4 = Ot(si, 4), n7 = Rn(I4, w4, v3, x4, f3, 58, i2, t4, s4);
    for (let r2 = 0; r2 < n7; r2++) {
      if (!i2.containsExclusiveCoordinate(s4[r2].toDouble())) continue;
      let t5 = s4[r2].toDouble();
      t5 = Ph(e5, t5);
      const n8 = new mi();
      _h(u, e5, t5, n8), X3 = mi.distance(n8, M2), X3 <= o && Y3.push(new mi(t5, X3));
    }
  }
  if (r) {
    n2(i2.equals(x2.unit()));
    {
      _h(u, e5, -1, N2, true);
      const t4 = new mi();
      _h(u, e5, 0, t4);
      const s4 = new pm({ start: N2, end: t4 }), n7 = s4.getClosestCoordinate(M2, true);
      n7 < 1 && (N2 = s4.getCoord2D(n7), X3 = mi.distance(N2, M2), X3 <= o && Y3.push(new mi(n7 - 1, X3)));
    }
    {
      _h(u, e5, 2, N2, true);
      const t4 = new mi();
      _h(u, e5, i2.vmax, t4);
      const s4 = new pm({ start: t4, end: N2 }), n7 = s4.getClosestCoordinate(M2, true);
      n7 > 0 && (N2 = s4.getCoord2D(n7), X3 = mi.distance(N2, M2), X3 <= o && Y3.push(new mi(1 + n7, X3)));
    }
  }
  if (!Y3.length) return 0;
  Y3.sort((t4, e6) => t4.compare(e6));
  let q2 = 0;
  const F3 = Y3[0].x;
  if (h2[q2++] = F3, q2 < a2) {
    const t4 = Rt2(u, 4, false).total(), e6 = Y3[0].y;
    for (let s4 = 1, n7 = Y3.length; s4 < n7; s4++) if (Y3[s4].y > e6 + t4) {
      Y3.length = s4;
      break;
    }
    Y3.sort((t5, e7) => Ct(t5.x, e7.x)), q2 = 0, h2[q2++] = Y3[0].x;
    for (let s4 = 1, n7 = Y3.length; s4 < n7; s4++) Y3[s4].x !== h2[q2 - 1] && q2 < a2 && (h2[q2++] = Y3[s4].x);
  }
  return q2;
}
function Ba(t3, e5, s4, n6, i2) {
  return { tmin: t3, tmax: e5, t: s4, d: n6, pt: i2.clone() };
}
function ka(t3, e5, n6, i2, r) {
  const o = new De();
  if (Ga(t3, x2.unit(), o), o.inflate(i2), !o.isIntersectingPoint2D(e5)) return 0;
  const a2 = ga(t3);
  let h2 = 0;
  const u = [];
  let m3 = a2.specialPoints[0];
  for (let l2 = 1, c = a2.specialPoints.length; l2 < c; ++l2) {
    const n7 = a2.specialPoints[l2], i3 = ua(t3, e5, m3, n7);
    if (0 === u.length) u.push(i3);
    else if (i3.t === i3.tmin) n2(u.at(-1).d <= i3.d), u.at(-1).tmax = i3.tmax;
    else if (u.at(-1).t === u.at(-1).tmax) {
      n2(u.at(-1).d >= i3.d);
      const t4 = u.at(-1).tmin;
      u[u.length - 1] = i3, u.at(-1).tmin = t4;
    } else u.push(i3);
    m3 = n7;
  }
  for (const s4 of u) if (s4.d <= i2) {
    const t4 = s4.t;
    n6 ? (n6[h2] = t4, h2++) : h2++;
  }
  return h2;
}
function Ga(t3, e5, s4) {
  const n6 = Ot(mi, 3);
  t3.queryControlPoints(n6);
  const i2 = [0, 0, 0];
  t3.queryWeights(i2), Wa(n6, i2, e5, s4);
}
function Wa(t3, e5, s4, n6) {
  if (s4.equalsRange(0, 1)) return void n6.setFromPoints(t3, 3);
  const i2 = Ot(mi, 3), r = [0, 0, 0];
  Qa(t3, e5, s4.vmin, s4.vmax, i2, r), n6.setFromPoints(i2, 3);
}
function ja(t3) {
  const e5 = fs(t3[0].y, t3[1].y), s4 = fs(t3[1].y, t3[2].y);
  if (e5 >= 0 && s4 >= 0 || e5 <= 0 && s4 <= 0) {
    const e6 = fs(t3[0].x, t3[1].x), s5 = fs(t3[1].x, t3[2].x);
    if (e6 >= 0 && s5 >= 0 || e6 <= 0 && s5 <= 0) return true;
  }
  return false;
}
function Za(t3) {
  const e5 = Ot(mi, 3);
  t3.queryControlPoints(e5);
  const s4 = Ha(e5);
  return s4 && (t3.m_cp.setCoordsPoint2D(e5[1]), t3.afterCompletedModification()), s4;
}
function Ha(t3) {
  let e5 = false;
  for (let s4 = 0; s4 < 2; s4++) {
    const n6 = fs(t3[0][s4], t3[2][s4]);
    n6 > 0 ? (fs(t3[0][s4], t3[1][s4]) < 0 && (t3[1][s4] = t3[0][s4], e5 = true), fs(t3[1][s4], t3[2][s4]) < 0 && (t3[1][s4] = t3[2][s4], e5 = true)) : n6 < 0 ? (fs(t3[0][s4], t3[1][s4]) > 0 && (t3[1][s4] = t3[0][s4], e5 = true), fs(t3[1][s4], t3[2][s4]) > 0 && (t3[1][s4] = t3[2][s4], e5 = true)) : t3[1][s4] !== t3[0][s4] && (t3[1][s4] = t3[0][s4], e5 = true);
  }
  return e5;
}
function Ua(t3, s4, n6) {
  void 0 === n6 && (n6 = s4, s4 = 0);
  const i2 = new mi();
  if (s4 < 0 || n6 > 1) return i2.setNAN(), i2;
  if (s4 > n6 && P("calculate_sub_weighted_centroid"), s4 === n6 || t3.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = ga(t3), o = Xa(t3), a2 = o / t3.calculateUpperLength2D();
  let h2 = s4, u = 0;
  for (let e5 = 1, m3 = r.specialPointsCount(); e5 < m3; e5++) if (s4 < r.specialPoints[e5]) {
    u = e5 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let e5 = u + 1, m3 = r.specialPointsCount(); e5 < m3; e5++) {
    const s5 = Math.min(r.specialPoints[e5], n6), u2 = ma(t3, h2, s5, a2, o);
    if (i2.addThis(u2), h2 = s5, n6 <= r.specialPoints[e5]) break;
  }
  return i2.add(t3.getStartXY().mul(t3.calculateLength2D()));
}
function Oa(t3, e5, n6, i2, r, o, a2) {
  n2(n6 >= 0 && n6 <= 1 && i2 !== o && r !== a2), n2(e5[0] > 0 && e5[2] > 0 && e5[1] >= 0);
  const h2 = [1, fh(e5), 1], u = yh(e5, n6), m3 = Qt(t3, 3), l2 = Ot(X, 3);
  uh(m3, h2, l2);
  const c = Ot(X, 3), g2 = Ot(X, 3);
  xh(l2, u, i2 ? c : null, o ? g2 : null), Ch(e5, n6, r, a2);
  const d2 = ja(m3);
  if (i2) {
    for (let t4 = 0; t4 < 3; ++t4) dh(c[t4], i2[t4]);
    bh(m3, i2), d2 && Ha(i2);
  }
  if (o) {
    for (let t4 = 0; t4 < 3; ++t4) dh(g2[t4], o[t4]);
    bh(m3, o), d2 && Ha(o);
  }
}
function Qa(t3, e5, n6, i2, r, o) {
  if (n2(n6 >= 0 && i2 <= 1 && n6 <= i2), n6 === i2) {
    const s4 = new mi(), i3 = mh(t3, e5, n6, s4);
    return vh(t3, s4), r[0].assign(s4), r[1].assign(s4), r[2].assign(s4), o[0] = i3, o[1] = i3, void (o[2] = i3);
  }
  if (0 === n6 && 1 === i2) return r[0].assign(t3[0]), r[1].assign(t3[1]), r[2].assign(t3[2]), o[0] = e5[0], o[1] = e5[1], void (o[2] = e5[2]);
  const a2 = Ot(X, 3);
  {
    const s4 = [1, fh(e5), 1], r2 = yh(e5, n6), o2 = yh(e5, i2);
    uh(t3, s4, a2), xh(a2, o2, a2, null);
    xh(a2, r2 >= o2 ? 1 : r2 / o2, null, a2);
  }
  const h2 = [0, 0, 0];
  Ch(e5, i2, h2, null), Ch(h2, n6 / i2, null, h2);
  const u = ja(t3), m3 = Ot(mi, 3);
  dh(a2[1], m3[1]), _h(t3, e5, n6, m3[0]), _h(t3, e5, i2, m3[2]), bh(t3, m3);
  for (let s4 = 0; s4 < 3; ++s4) r[s4].assign(m3[s4]), o[s4] = h2[s4];
  u && Ha(r);
}
function Ja(t3, e5, s4) {
  const n6 = fh(e5), i2 = [1, n6, 1], r = 4 * n6 / (3 * (1 + n6));
  s4[0].assign(t3[0]), s4[3].assign(t3[2]), Y(t3[0], t3[1], r, s4[1]), Y(t3[2], t3[1], r, s4[2]), new ia({ cp: s4 }), new En({ points: t3, weight: n6 });
  let o = 0, a2 = 0.1, h2 = 0;
  for (let u = 0; u < 9; u++, a2 += 0.1) {
    const e6 = new mi();
    _h(t3, i2, a2, e6);
    const n7 = new mi();
    Po(s4, a2, n7);
    const r2 = mi.sqrDistance(e6, n7);
    r2 > o && (o = r2, h2 = a2);
  }
  {
    const e6 = new mi();
    _h(t3, i2, h2, e6);
    const n7 = [0];
    Lo(s4, e6, x2.unit(), false, -1, 1, n7);
    const r2 = new mi();
    return Po(s4, n7[0], r2), o = mi.sqrDistance(e6, r2), Math.sqrt(o);
  }
}
function Ka(t3, e5, s4, n6) {
  if (e5.isEqual(t3.m_XStart, t3.m_YStart) && s4.isEqual(t3.m_XEnd, t3.m_YEnd)) return;
  const i2 = !!n6 && t3.isMonotoneQuickAndDirty(), r = new x3(), o = Ot(mi, 3);
  o[0].setCoords(t3.m_XStart, t3.m_YStart), o[2].setCoords(t3.m_XEnd, t3.m_YEnd);
  const a2 = new mi();
  a2.setSub(o[2], o[0]), a2.leftPerpendicularThis(), o[1].setAdd(o[0], a2);
  const h2 = Ot(mi, 3);
  h2[0].setCoordsPoint2D(e5), h2[2].setCoordsPoint2D(s4), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o, h2) ? r.transformInPlace(t3.m_cp) : Y(e5, s4, 0.5, t3.m_cp), t3.changeEndPoints2D(e5, s4), i2 && Za(t3);
}
function $a(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== nh(t3, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function th(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== ih(t3, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function eh(t3, e5, s4, n6, i2) {
  if (i2) {
    const n7 = am(e5, s4);
    if (0 !== n7) {
      if (t3) {
        if (1 === n7) {
          if (e5.m_weights[0] === s4.m_weights[0] && e5.m_weights[1] === s4.m_weights[1] && e5.m_weights[2] === s4.m_weights[2]) return 2;
        } else if (e5.m_weights[0] === s4.m_weights[2] && e5.m_weights[1] === s4.m_weights[1] && e5.m_weights[2] === s4.m_weights[0]) return 2;
        return 4;
      }
      return 2;
    }
  } else if (Le(e5, s4)) return 1;
  return 0 !== rh(t3, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function sh(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return t3 ? 4 : 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== oh(t3, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function nh(t3, e5, n6, i2, r, o, a2, h2, u, m3) {
  if (null !== r && (r.length = 0), null !== o && (o.length = 0), null !== i2 && (i2.length = 0), n6.isDegenerate(0)) {
    const t4 = [0, 0], s4 = e5.intersectPoint(n6.getStartXY(), t4, a2);
    if (s4 > 0) {
      if (null !== r) for (let e6 = 0; e6 < s4; e6++) r.push(t4[e6]);
      if (null != o) for (let t5 = 0; t5 < s4; t5++) o.push(0);
      if (null != i2) for (let n7 = 0; n7 < s4; n7++) {
        const s5 = new mi();
        e5.queryCoord2D(t4[n7], s5), i2.push(s5);
      }
    }
    return s4;
  }
  const l2 = rs2(e5, n6);
  if (a2 = Math.max(a2, l2), e5.isDegenerateToLineHelper(l2)) {
    const t4 = new pm({ start: e5.getStartXY(), end: e5.getEndXY() }), s4 = Ds2(t4, n6, i2, r, o, a2, h2, m3);
    if (r) for (let n7 = 0; n7 < s4; ++n7) {
      const s5 = t4.getCoord2D(r[n7]);
      r[n7] = e5.getClosestCoordinate(s5, false);
    }
    return s4;
  }
  if (os(e5, n6, a2)) return 0;
  const c = Ot(mi, 3);
  e5.queryControlPoints(c);
  const g2 = [0, 0, 0];
  e5.queryWeights(g2);
  const d2 = [1, fh(g2), 1], _ = n6.getEndXY().sub(n6.getStartXY()), p3 = _.clone();
  p3.leftPerpendicularThis();
  const f3 = c[0].clone(), P5 = c[1].clone(), y2 = c[2].clone(), x4 = P5.sub(f3), C3 = y2.sub(f3), v3 = y2.sub(P5), b2 = d2[0], S3 = d2[1], E2 = d2[2], D3 = b2 * S3, w4 = b2 * E2, A4 = S3 * E2, T3 = x4.dotProduct(p3) * D3, I4 = C3.dotProduct(p3) * w4;
  let M2 = T3, Y3 = I4 - 2 * T3, N2 = v3.dotProduct(p3) * A4 + I4 - I4;
  const X3 = Yt(13, Number.NaN), q2 = Yt(13, Number.NaN);
  let F3 = sn(N2, Y3, M2, x2.unit(), false, X3);
  F3 < 0 && (X3[0] = 0, X3[1] = 1, F3 = 2);
  let V4 = 0;
  for (let s4 = 0, k4 = V4; s4 < F3; ++s4) {
    const t4 = new mi();
    _h(c, d2, X3[s4 + k4], t4), q2[V4] = n6.getClosestCoordinate(t4, false);
    mi.distance(t4, n6.getCoord2D(q2[V4])) <= a2 && (X3[V4] = X3[s4 + k4], V4++);
  }
  const L4 = Ot(mi, 3), R4 = Ot(mi, 3);
  if (e5.queryControlPoints(R4), R4[0].subThis(n6.getStartXY()), R4[1].subThis(n6.getStartXY()), R4[2].subThis(n6.getStartXY()), ah(R4, d2, L4, false), Math.abs(_.x) >= Math.abs(_.y)) {
    const t4 = _.y / _.x;
    N2 = L4[2].y - L4[2].x * t4, Y3 = L4[1].y - L4[1].x * t4, M2 = L4[0].y - L4[0].x * t4;
  } else {
    const t4 = _.x / _.y;
    N2 = L4[2].x - L4[2].y * t4, Y3 = L4[1].x - L4[1].y * t4, M2 = L4[0].x - L4[0].y * t4;
  }
  const z4 = e5.getEndXY().equals(n6.getStartXY()) || e5.getEndXY().equals(n6.getEndXY()), B4 = [0, 0];
  F3 = sn(N2, Y3, M2, x2.unit(), z4, B4);
  for (let s4 = 0, k4 = V4; s4 < F3; ++s4) {
    X3[s4 + k4] = B4[s4];
    const t4 = new mi();
    _h(c, d2, X3[s4 + k4], t4), q2[V4] = n6.getClosestCoordinate(t4, false);
    mi.distance(t4, n6.getCoord2D(q2[V4])) <= a2 && (X3[V4] = X3[s4 + k4], V4++);
  }
  n2(V4 < X3.length + 4);
  for (let s4 = 0; s4 < V4; s4++) X3[s4] = Ph(g2, X3[s4]);
  F3 = e5.intersectPoint(n6.getStartXY(), B4, a2);
  for (let s4 = 0; s4 < F3; s4++) X3[V4] = B4[s4], q2[V4++] = 0;
  F3 = e5.intersectPoint(n6.getEndXY(), B4, a2);
  for (let s4 = 0; s4 < F3; s4++) X3[V4] = B4[s4], q2[V4++] = 1;
  F3 = n6.intersectPoint(e5.getStartXY(), B4, a2);
  for (let s4 = 0; s4 < F3; s4++) q2[V4] = B4[s4], X3[V4++] = 0;
  F3 = n6.intersectPoint(e5.getEndXY(), B4, a2);
  for (let s4 = 0; s4 < F3; s4++) q2[V4] = B4[s4], X3[V4++] = 1;
  return 0 === V4 ? 0 : cm(t3, e5, n6, X3, q2, V4, i2, r, o, a2, h2, u, m3);
}
function ih(t3, e5, s4, n6, i2, r, o, a2, h2, u) {
  if (Su(s4)) {
    return nh(t3, e5, new pm({ start: s4.getStartXY(), end: s4.getEndXY() }), n6, i2, r, o, a2, h2, u);
  }
  const m3 = rs2(e5, s4);
  if (os(e5, s4, o = Math.max(o, m3))) return 0;
  const l2 = [], c = [], g2 = Ot(mi, 4);
  {
    e5.queryControlPoints(g2);
    const t4 = Ot(mi, 4), n7 = new x3();
    s4.canonicToWorldTransformation(n7);
    const i3 = new x3();
    i3.setInvert(n7), i3.transformPoints2D(g2, 4, t4);
    const r2 = Ot(si, 3), h3 = Ot(si, 3), u2 = Ot(si, 3), m4 = [0, 0, 0];
    e5.queryWeights(m4), hh(t4, m4, r2, h3, u2);
    const d3 = Ot(si, 3);
    d3[0].setDouble(s4.getSemiMinorAxis()), d3[0].sqrThis(), d3[1].setDouble(s4.getSemiMajorAxis()), d3[1].sqrThis(), d3[2].setThis(d3[0]), d3[2].mulThis(d3[1]), d3[2].negateThis();
    const _ = qn(r2, 2, h3, 2, u2, 2, d3, true, x2.unit(), x2.unit(), l2, a2);
    if (_ > 0) {
      let t5 = 0;
      for (let n8 = 0; n8 < _; n8++) {
        const i4 = new mi();
        e5.queryCoord2D(l2[n8], i4);
        const r3 = s4.getClosestCoordinate(i4, false), a3 = new mi();
        s4.queryCoord2D(r3, a3);
        mi.distance(i4, a3) <= o && (l2[t5] = l2[n8], c.push(r3), t5++);
      }
      l2.length = t5;
    }
  }
  const d2 = [0, 1];
  for (let _ = 0; _ < 2; _++) {
    const t4 = 0 === _ ? s4.getStartXY() : s4.getEndXY(), n7 = Ra(e5, t4, x2.unit(), false, -1), i3 = new mi();
    e5.queryCoord2D(n7, i3);
    mi.distance(t4, i3) <= o && (l2.push(n7), c.push(d2[_]));
  }
  for (let _ = 0; _ < 2; _++) {
    const t4 = [0, 3];
    {
      const e6 = s4.getClosestCoordinate(g2[t4[_]], false), n7 = new mi();
      s4.queryCoord2D(e6, n7);
      mi.distance(g2[t4[_]], n7) <= o && (l2.push(d2[_]), c.push(e6));
    }
  }
  return cm(t3, e5, s4, l2, c, l2.length, n6, i2, r, o, a2, h2, u);
}
function rh(t3, e5, n6, i2, r, o, a2, h2, u, m3) {
  const l2 = Ot(mi, 3);
  e5.queryControlPoints(l2);
  const c = Ot(mi, 3);
  if (n6.queryControlPoints(c), as(l2, c, 3) < 0) return rh(t3, n6, e5, i2, o, r, a2, h2, u, !m3);
  const g2 = rs2(e5, n6);
  if (e5.isDegenerateToLineHelper(g2)) {
    const s4 = new pm({ start: e5.getStartXY(), end: e5.getEndXY() }), l3 = nh(t3, n6, s4, i2, o, r, a2, h2, u, !m3);
    if (r) for (let t4 = 0; t4 < l3; ++t4) {
      const n7 = s4.getCoord2D(r[t4]);
      r[t4] = e5.getClosestCoordinate(n7, false);
    }
    return l3;
  }
  if (n6.isDegenerateToLineHelper(g2)) {
    const s4 = new pm({ start: n6.getStartXY(), end: n6.getEndXY() }), l3 = nh(t3, e5, s4, i2, r, o, a2, h2, u, m3);
    if (o) for (let t4 = 0; t4 < l3; ++t4) {
      const e6 = s4.getCoord2D(o[t4]);
      o[t4] = n6.getClosestCoordinate(e6, false);
    }
    return l3;
  }
  if (os(e5, n6, a2 = Math.max(a2, g2))) return 0;
  const d2 = Yt(3, Number.NaN);
  e5.queryWeights(d2);
  const _ = Yt(3, Number.NaN);
  n6.queryWeights(_);
  const p3 = [1, fh(d2), 1], f3 = [1, fh(_), 1], P5 = new x2(0, 1), y2 = new x2(0, 1);
  {
    const t4 = De.constructEmpty();
    Wa(l2, p3, new x2(0, 1), t4);
    const e6 = De.constructEmpty();
    Wa(c, f3, new x2(0, 1), e6);
    const s4 = Math.max(t4.maxDim(), e6.maxDim());
    if (t4.inflate(3 * a2), e6.inflate(3 * a2), !t4.intersectW(e6)) return 0;
    if (t4.maxDim() < 0.1 * s4) {
      if (ph(l2, p3, t4, P5), ph(c, f3, t4, y2), P5.isEmpty() || y2.isEmpty()) return 0;
      Qa(l2, p3, P5.vmin, P5.vmax, l2, p3), Qa(c, f3, y2.vmin, y2.vmax, c, f3);
    }
  }
  const x4 = dm(l2, 2, c, 2, a2);
  if (0 === x4) return 0;
  const C3 = [], v3 = [];
  if (-1 === x4) {
    const t4 = Ot(si, 3), e6 = Ot(si, 3), s4 = Ot(si, 3);
    hh(l2, p3, t4, e6, s4);
    const n7 = Ot(si, 3), i3 = Ot(si, 3), r2 = Ot(si, 3);
    hh(c, f3, n7, i3, r2);
    const o2 = [], g3 = [], d3 = Yn(t4, 2, e6, 2, s4, 2, n7, 2, i3, 2, r2, 2, true, x2.unit(), x2.unit(), o2, g3, h2, u, m3);
    if (d3 > 0) for (let h3 = 0; h3 < d3; h3++) {
      const t5 = new mi();
      _h(c, f3, g3[h3], t5);
      const e7 = new mi();
      _h(l2, p3, o2[h3], e7);
      mi.distance(e7, t5) <= a2 && (C3.push(o2[h3]), v3.push(g3[h3]));
    }
  }
  for (let b2 = 0; b2 < 2; b2++) {
    let t4, e6, n7;
    0 === b2 ? (t4 = l2, e6 = c, n7 = f3) : (t4 = c, e6 = l2, n7 = p3);
    for (let i3 = 0; i3 < 2; i3++) {
      const r2 = 0 === i3 ? 0 : t4.length - 1, o2 = new mi(), h3 = [0], u2 = za(e6, n7, t4[r2], x2.unit(), false, -1, 1, h3);
      n2(1 === u2), _h(e6, n7, h3[0], o2), mi.distance(t4[r2], o2) <= a2 && (0 === b2 ? (C3.push(0 === r2 ? 0 : 1), v3.push(h3[0])) : (v3.push(0 === r2 ? 0 : 1), C3.push(h3[0])));
    }
  }
  if (0 === C3.length) return 0;
  if (!P5.equalsRange(0, 1)) for (let s4 = 0; s4 < C3.length; ++s4) C3[s4] = En.recalculateParentT(P5.vmin, P5.vmax, C3[s4]);
  if (!y2.equalsRange(0, 1)) for (let s4 = 0; s4 < v3.length; ++s4) v3[s4] = En.recalculateParentT(y2.vmin, y2.vmax, v3[s4]);
  for (let s4 = 0; s4 < C3.length; ++s4) C3[s4] = Ph(d2, C3[s4]);
  for (let s4 = 0; s4 < v3.length; ++s4) v3[s4] = Ph(_, v3[s4]);
  return cm(t3, e5, n6, C3, v3, C3.length, i2, r, o, a2, h2, u, m3);
}
function oh(t3, e5, s4, n6, i2, r, o, a2, h2, u) {
  if (e5.isLine()) {
    return Vi(t3, s4, new pm({ start: e5.getStartXY(), end: e5.getEndXY() }), n6, r, i2, o, a2, h2, !u);
  }
  if (s4.isLine()) {
    return nh(t3, e5, new pm({ start: s4.getStartXY(), end: s4.getEndXY() }), n6, i2, r, o, a2, h2, u);
  }
  const m3 = rs2(e5, s4);
  if (os(e5, s4, o = Math.max(o, m3))) return 0;
  const l2 = Ot(mi, 3);
  e5.queryControlPoints(l2);
  const c = Ot(mi, 3);
  s4.queryControlPoints(c);
  const g2 = dm(l2, 2, c, 2, o);
  if (0 === g2) return 0;
  const d2 = [], _ = [];
  if (-1 === g2) {
    const t4 = Ot(si, 3), n7 = Ot(si, 3), i3 = Ot(si, 3), r2 = [0, 0, 0];
    e5.queryWeights(r2), hh(l2, r2, t4, n7, i3);
    const m4 = Ot(Xe, 3);
    Wi(c, m4);
    const g3 = Yn(t4, 2, n7, 2, i3, 2, [m4[0].x, m4[1].x, m4[2].x], 2, [m4[0].y, m4[1].y, m4[2].y], 2, null, 0, true, x2.unit(), x2.unit(), d2, _, a2, h2, u);
    if (g3 > 0) {
      let t5 = 0;
      for (let n8 = 0; n8 < g3; n8++) {
        const i4 = new mi();
        s4.queryCoord2D(_[n8], i4);
        const r3 = new mi();
        e5.queryCoord2D(d2[n8], r3), mi.distance(r3, i4) <= o && (d2[t5] = d2[n8], _[t5] = _[n8], t5++);
      }
      d2.length = t5, _.length = t5;
    }
  }
  for (let p3 = 0; p3 < 2; p3++) {
    let t4;
    t4 = 0 === p3 ? l2 : c;
    for (let n7 = 0; n7 < 2; n7++) {
      const i3 = 0 === n7 ? 0 : t4.length - 1;
      let r2;
      const a3 = new mi();
      0 === p3 ? (r2 = Ci(s4, t4[i3], x2.unit(), false), s4.queryCoord2D(r2, a3)) : (r2 = Ra(e5, t4[i3], x2.unit(), false, -1), e5.queryCoord2D(r2, a3)), mi.distance(t4[i3], a3) <= o && (0 === p3 ? (d2.push(0 === i3 ? 0 : 1), _.push(r2)) : (_.push(0 === i3 ? 0 : 1), d2.push(r2)));
    }
  }
  return cm(t3, e5, s4, d2, _, d2.length, n6, i2, r, o, a2, h2, u);
}
function ah(t3, e5, s4, n6 = false) {
  const i2 = Ot(mi, 3);
  n6 ? (i2[0].setCoordsPoint2D(t3[0]), i2[1].setCoordsPoint2D(t3[1]), i2[1].subThis(i2[0]), i2[2].setCoordsPoint2D(t3[2]), i2[2].subThis(i2[0]), i2[0].setCoords(0, 0)) : (i2[0].setCoordsPoint2D(t3[0]), i2[1].setCoordsPoint2D(t3[1]), i2[2].setCoordsPoint2D(t3[2])), i2[0].mulThis(e5[0]), i2[1].mulThis(e5[1]), i2[2].mulThis(e5[2]), s4[1].setCoords(i2[1].x - i2[0].x, i2[1].y - i2[0].y), s4[2].setCoordsPoint2D(i2[2].sub(i2[1])), s4[2].subThis(s4[1]), s4[1].x *= 2, s4[1].y *= 2, s4[0].setCoordsPoint2D(i2[0]);
}
function hh(t3, e5, s4, n6, i2) {
  const r = si.constructDouble(e5[0]), o = si.constructDouble(e5[1]), a2 = si.constructDouble(e5[2]);
  s4[0].setDouble(t3[0].x), s4[0].mulThis(r), s4[1].setDouble(t3[1].x), s4[1].mulThis(o), s4[2].setDouble(t3[2].x), s4[2].mulThis(a2), s4[2].subThis(s4[1]), s4[1].subThis(s4[0]), s4[2].subThis(s4[1]), s4[1].ldexpThis(1), n6[0].setDouble(t3[0].y), n6[0].mulThis(r), n6[1].setDouble(t3[1].y), n6[1].mulThis(o), n6[2].setDouble(t3[2].y), n6[2].mulThis(a2), n6[2].subThis(n6[1]), n6[1].subThis(n6[0]), n6[2].subThis(n6[1]), n6[1].ldexpThis(1), i2[0].setDouble(e5[0]), i2[1].setDouble(e5[1]), i2[2].setThis(i2[1]), i2[2].ldexpThis(1), i2[2].negateThis(), i2[2].addThis(i2[0]), i2[2].addDoubleThis(e5[2]), i2[1].subThis(i2[0]), i2[1].ldexpThis(1);
}
function uh(t3, e5, s4) {
  for (let n6 = 0; n6 < 3; ++n6) s4[n6].setCoordsPoint2DZ(t3[n6].mul(e5[n6]), e5[n6]);
}
function mh(t3, e5, s4, n6) {
  if (0 === s4) return n6.assign(t3[0]), e5[0];
  if (1 === s4) return n6.assign(t3[2]), e5[2];
  const i2 = [t3[0].x * e5[0], t3[1].x * e5[1], t3[2].x * e5[2]], r = [t3[0].y * e5[0], t3[1].y * e5[1], t3[2].y * e5[2]], o = [e5[0], e5[1], e5[2]], a2 = s4;
  let h2, u, m3;
  if (s4 <= 0.5) {
    const t4 = V(i2[0], i2[1], a2), e6 = V(i2[1], i2[2], a2);
    h2 = Q(t4, e6, a2);
    const s5 = V(r[0], r[1], a2), n7 = V(r[1], r[2], a2);
    u = Q(s5, n7, a2);
    const l2 = V(o[0], o[1], a2), c = V(o[1], o[2], a2);
    m3 = V(l2, c, a2);
  } else {
    const t4 = U2(i2[0], i2[1], a2), e6 = U2(i2[1], i2[2], a2);
    h2 = U2(t4, e6, a2);
    const s5 = U2(r[0], r[1], a2), n7 = U2(r[1], r[2], a2);
    u = U2(s5, n7, a2);
    const l2 = U2(o[0], o[1], a2), c = U2(o[1], o[2], a2);
    m3 = U2(l2, c, a2);
  }
  return h2 /= m3, u /= m3, n6.setCoords(h2, u), vh(t3, n6), m3;
}
function lh(t3, e5, s4) {
  const n6 = Ot(mi, 3);
  t3.queryControlPoints(n6);
  const i2 = [0, 0, 0];
  t3.queryWeights(i2);
  ch([Ye.constructPoint2D(n6[0]), Ye.constructPoint2D(n6[1]), Ye.constructPoint2D(n6[2])], [new p2(i2[0]), new p2(i2[1]), new p2(i2[2])], e5, s4);
}
function ch(t3, e5, s4, n6) {
  if (0 === s4.value()) return void n6.setE(t3[0]);
  if (1 === s4.value()) return void n6.setE(t3[2]);
  const i2 = [t3[0].x.mulE(e5[0]), t3[1].x.mulE(e5[1]), t3[2].x.mulE(e5[2])], r = [t3[0].y.mulE(e5[0]), t3[1].y.mulE(e5[1]), t3[2].y.mulE(e5[2])], o = [e5[0].clone(), e5[1].clone(), e5[2].clone()], a2 = new p2(), h2 = new p2(), u = new p2();
  if (s4.value() <= 0.5) {
    const t4 = A2(i2[0], i2[1], s4), e6 = A2(i2[1], i2[2], s4);
    a2.setE(A2(t4, e6, s4));
    const n7 = A2(r[0], r[1], s4), m4 = A2(r[1], r[2], s4);
    h2.setE(A2(n7, m4, s4));
    const l2 = A2(o[0], o[1], s4), c = A2(o[1], o[2], s4);
    u.setE(A2(l2, c, s4));
  } else {
    const t4 = P2(i2[0], i2[1], s4), e6 = P2(i2[1], i2[2], s4);
    a2.setE(P2(t4, e6, s4));
    const n7 = P2(r[0], r[1], s4), m4 = P2(r[1], r[2], s4);
    h2.setE(P2(n7, m4, s4));
    const l2 = P2(o[0], o[1], s4), c = P2(o[1], o[2], s4);
    u.setE(P2(l2, c, s4));
  }
  a2.divThisE(u), h2.divThisE(u);
  const m3 = new mi(a2.value(), h2.value());
  vh([t3[0].value(), t3[1].value(), t3[2].value()], m3), n6.x.set(m3.x, a2.eps()), n6.y.set(m3.y, h2.eps());
}
function gh(t3, e5, s4, n6) {
  const i2 = s4.lte(ni) ? si.lerpLo : si.lerpHi, [r, o, a2] = [e5.map((e6, s5) => t3[s5].x.mul(e6)), e5.map((e6, s5) => t3[s5].y.mul(e6)), e5].map(([t4, e6, n7]) => i2(i2(t4, e6, s4), i2(e6, n7, s4), s4)), h2 = new mi(r.divThis(a2).value(), o.divThis(a2).value());
  vh(t3.map((t4) => t4.asPoint2D()), h2), n6.x = si.constructDouble(h2.x), n6.y = si.constructDouble(h2.y);
}
function dh(t3, e5) {
  return e5.setCoords(t3.x / t3.z, t3.y / t3.z), t3.z;
}
function _h(t3, e5, s4, n6, i2) {
  if (i2) {
    if (s4 < 0) {
      return void _s2(new pm({ start: t3[0], end: t3[0].add(wa(t3, e5, 0).getUnitVector()) }), s4, n6);
    }
    if (s4 > 1) {
      return void _s2(new pm({ start: t3[2], end: t3[2].add(wa(t3, e5, 1).getUnitVector()) }), s4 - 1, n6);
    }
  }
  mh(t3, e5, s4, n6);
}
function ph(t3, e5, s4, n6) {
  n6.setEmpty();
  const i2 = [];
  i2.push(new x2(0, 1));
  const r = 0.5 * Math.max(s4.width(), s4.height());
  for (; i2.length; ) {
    const o = i2.at(-1);
    i2.pop();
    const a2 = new De();
    if (Wa(t3, e5, o, a2), a2.isIntersectingW(s4)) {
      const t4 = Math.max(a2.width(), a2.height());
      if (s4.containsW(a2) || t4 <= r || o.width() < 1e-12) n6.merge(o);
      else {
        const t5 = o.getCenter();
        i2.push(x2.construct(o.vmin, t5)), i2.push(x2.construct(t5, o.vmax));
      }
    }
  }
}
function fh(t3) {
  return t3[1] / Math.sqrt(t3[0] * t3[2]);
}
function Ph(t3, e5) {
  const s4 = Math.sqrt(t3[2] / t3[0]);
  return e5 / Q(s4, 1, e5);
}
function yh(t3, e5) {
  const s4 = Math.sqrt(t3[0] / t3[2]);
  return e5 / Q(s4, 1, e5);
}
function xh(t3, e5, n6, i2) {
  n2(e5 >= 0 && e5 <= 1);
  new X().setCoordsPoint3D(t3[0]);
  new X().setCoordsPoint3D(t3[1]);
  new X().setCoordsPoint3D(t3[2]);
  const r = new X(), o = new X(), a2 = new X();
  L2(3, t3[0], t3[1], e5, r), L2(3, t3[1], t3[2], e5, o), L2(3, r, o, e5, a2);
  const h2 = t3[2].clone();
  n6 && (n6[0].assign(t3[0]), n6[1].assign(r), n6[2].assign(a2)), i2 && (i2[0].assign(a2), i2[1].assign(o), i2[2].assign(h2));
}
function Ch(t3, e5, n6, i2) {
  const r = [t3[0], t3[1], t3[2]];
  n2(e5 >= 0 && e5 <= 1 && n6 !== i2);
  const o = Q(r[0], r[1], e5), a2 = Q(r[1], r[2], e5), h2 = Q(o, a2, e5);
  n6 && (n6[0] = r[0], n6[1] = o, n6[2] = h2), i2 && (i2[0] = h2, i2[1] = a2, i2[2] = r[2]);
}
function vh(t3, e5) {
  const s4 = x2.constructEmpty();
  s4.vmin = s4.vmax = t3[0].x, s4.mergeNeCoordinate(t3[1].x), s4.mergeNeCoordinate(t3[2].x), e5.x = Us(e5.x, s4.vmin, s4.vmax), s4.vmin = s4.vmax = t3[0].y, s4.mergeNeCoordinate(t3[1].y), s4.mergeNeCoordinate(t3[2].y), e5.y = Us(e5.y, s4.vmin, s4.vmax);
}
function bh(t3, e5) {
  const s4 = new x2();
  s4.vmin = s4.vmax = t3[0].x, s4.mergeNeCoordinate(t3[1].x), s4.mergeNeCoordinate(t3[2].x), e5[0].x = Us(e5[0].x, s4.vmin, s4.vmax), e5[1].x = Us(e5[1].x, s4.vmin, s4.vmax), e5[2].x = Us(e5[2].x, s4.vmin, s4.vmax), s4.vmin = s4.vmax = t3[0].y, s4.mergeNeCoordinate(t3[1].y), s4.mergeNeCoordinate(t3[2].y), e5[0].y = Us(e5[0].y, s4.vmin, s4.vmax), e5[1].y = Us(e5[1].y, s4.vmin, s4.vmax), e5[2].y = Us(e5[2].y, s4.vmin, s4.vmax);
}
var Sh = Jt / 180;
var Eh = 180 / Jt;
function Dh(t3) {
  let e5 = t3;
  return e5 >= -360 && e5 < 720 ? (e5 < 0 ? e5 += 360 : e5 >= 360 && (e5 -= 360), e5) : (e5 = ct(e5, 360), e5 < 0 && (e5 += 360), e5);
}
function wh(t3) {
  let e5 = t3;
  return e5 = Dh(e5), e5 > 180 && (e5 -= 360), e5;
}
function Ah(t3) {
  return t3 * Sh;
}
function Th(t3) {
  return t3 * Eh;
}
function Ih(t3) {
  const e5 = $s();
  let s4 = t3;
  return s4 >= -e5 && s4 < 2 * e5 ? (s4 < 0 && (s4 += e5), s4 >= e5 && (s4 -= e5), s4) : (s4 = ct(s4, e5), s4 < 0 && (s4 += e5), s4);
}
function Mh(t3) {
  const e5 = Hs();
  let s4 = t3;
  return s4 > -e5 && s4 <= e5 || (s4 = Ih(s4), s4 > e5 && (s4 -= $s())), s4;
}
function Yh(t3, e5) {
  return wh(e5 - t3);
}
var Nh = z3;
var Xh = class _Xh extends gs {
  constructor(t3) {
    if (void 0 === t3 || jt(t3, "vd")) return super({ vd: t3?.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_semiMajorAxis = 0, this.m_minorMajorRatio = 1, this.m_rotation = 0, this.m_cosr = 1, this.m_sinr = 0, this.m_center = new mi(0, 0), this.m_sweepAngle = 0, this.m_startAngle = 0, this.m_interior = new mi(0, 0), void (this.m_bits = 0);
    if (t3.copy) return super(t3), void (this !== t3.copy && (this.m_center = new mi(0, 0), this.m_interior = new mi(0, 0), t3.copy.copyToImpl(this)));
    if (t3.move) super(t3), this.m_semiMajorAxis = t3.move.m_semiMajorAxis, this.m_minorMajorRatio = t3.move.m_minorMajorRatio, this.m_rotation = t3.move.m_rotation, this.m_cosr = t3.move.m_cosr, this.m_sinr = t3.move.m_sinr, this.m_center = t3.move.m_center.clone(), this.m_sweepAngle = t3.move.m_sweepAngle, this.m_startAngle = t3.move.m_startAngle, this.m_interior = t3.move.m_interior.clone(), this.m_bits = t3.move.m_bits, this.m_cachedValues = t3.move.m_cachedValues, t3.move.m_cachedValues = null;
    else {
      if (t3.fromPoint) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_center = new mi(0, 0), this.m_interior = new mi(0, 0), void this.constructCircularArcThreePoint(t3.fromPoint, t3.toPoint, t3.interiorPoint);
      if (t3.center) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_center = new mi(0, 0), this.m_interior = new mi(0, 0), void this.constructCircleRadius(t3.radius, t3.center, t3.bIsCounterClockwise);
      if (t3.semiMajorAxis) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), void this.constructEllipticArcEndPoints(t3.fromPoint, t3.toPoint, t3.semiMajorAxis, t3.minorMajorRatio, t3.axisXRotationRad, t3.bBigArc, t3.bIsCounterClockwise);
    }
  }
  getBoundary() {
    return Ks(this);
  }
  assignCopy(t3) {
    return this !== t3 && t3.copyTo(this), this;
  }
  constructCircleRadius(t3, e5, s4 = false) {
    return this.constructEllipse(t3, 1, e5, 0, s4), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructCircleCenterAndPoint(t3, e5, s4 = false) {
    const n6 = mi.distance(t3, e5);
    return this.constructEllipticArcEndPointsCenter(e5, e5, n6, 1, 0, true, s4, t3), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructTwoPointCircle(t3, e5, s4 = false) {
    const n6 = mi.lerp(t3, e5, 0.5);
    return this.constructCircleCenterAndPoint(n6, t3, s4), this;
  }
  constructLineEllipticArc(t3, e5) {
    return bu(this, t3, e5, 1), this;
  }
  constructLineCircularArc(t3, e5) {
    return bu(this, t3, e5, 0), this;
  }
  constructEllipse(t3, e5, s4, n6, i2 = false) {
    this.m_semiMajorAxis = Math.abs(t3), this.m_minorMajorRatio = Math.abs(e5), this.m_minorMajorRatio > 1 && (this.m_semiMajorAxis *= this.m_minorMajorRatio, this.m_minorMajorRatio = 1 / this.m_minorMajorRatio);
    const r = new mi(0, this.m_minorMajorRatio * this.m_semiMajorAxis), o = Math.cos(n6), a2 = Math.sin(n6);
    return r.rotateDirect(o, a2), r.addThis(s4), this.constructEllipticArcEndPointsCenter(r, r, this.m_semiMajorAxis, this.m_minorMajorRatio, n6, true, i2, s4), this;
  }
  inflate(t3) {
    if (this.isDegenerateToLine()) return;
    let e5 = this.getSemiMinorAxis() + t3;
    if (e5 = e5 <= 0 ? 0 : (this.getSemiMajorAxis() + t3) / this.getSemiMajorAxis(), this.isCircular()) {
      const t4 = new x3();
      t4.setShiftCoords(-this.m_center.x, -this.m_center.y), t4.scale(e5, e5), t4.shiftCoords(this.m_center.x, this.m_center.y), this.applyTransformation(t4);
    } else {
      const t4 = new x3();
      this.canonicToWorldTransformation(t4);
      const s4 = t4.clone();
      s4.invertPreciseThis(), s4.scale(e5, e5), s4.multiply(t4), this.applyTransformation(s4);
    }
  }
  constructEnclosingCircle(t3, e5, s4 = false) {
    return ju(this, t3, e5, s4), this;
  }
  constructThreePointCircle(t3, e5, s4, n6 = false) {
    if (t3.equals(e5) || e5.equals(s4) || t3.equals(s4)) {
      const i2 = t3.clone(), r = e5.clone(), o = s4.clone();
      return i2.equals(r) && r.assign(o), this.constructTwoPointCircle(i2, r, n6);
    }
    {
      const i2 = mi.calculateCircleCenterFromThreePoints(t3, e5, s4);
      if (!i2.isFinite() || !Number.isFinite(mi.distance(t3, i2))) {
        const n7 = mi.distance(t3, e5), i3 = mi.distance(t3, s4);
        this.constructLineCircularArc(t3, n7 >= i3 ? e5 : s4);
      }
      return this.constructCircleCenterAndPoint(i2, t3, n6);
    }
  }
  constructCircularArcThreePoint(t3, e5, s4) {
    const n6 = new p2(t3.x), i2 = new p2(e5.x), r = new p2(s4.x), o = new p2(t3.y), a2 = new p2(e5.y), h2 = new p2(s4.y), u = new p2(0.5), m3 = i2.subE(n6), l2 = a2.subE(o), c = r.subE(n6), g2 = h2.subE(o), d2 = m3.mulE(g2).subThisE(l2.mulE(c));
    if (d2.scaleError(10), d2.isZero()) {
      if (!m3.isZero() || !l2.isZero()) return bu(this, t3, e5, 0), this;
      {
        const n7 = t3.clone().addThis(e5).mulThis(0.5).addThis(s4).mulThis(0.5), i3 = s4.sub(n7).length();
        this.constructEllipticArcEndPointsCenter(t3, e5, i3, 1, 0, true, false, n7), this.m_interior.assign(s4);
      }
      return this.setProjectionBehavior(0), this;
    }
    const _ = m3.sqr().addThisE(l2.sqr()).mulThisE(u), p3 = c.sqr().addThisE(g2.sqr()).mulThisE(u), f3 = _.mulE(g2).subThisE(p3.mulE(l2)), P5 = m3.mulE(p3).subThisE(c.mulE(_));
    f3.divThisE(d2), P5.divThisE(d2);
    const y2 = f3.sqr().addThisE(P5.sqr());
    y2.sqrtThis();
    const x4 = f3.addE(n6), C3 = P5.addE(o);
    let v3 = t3.x - x4.value(), b2 = t3.y - C3.value();
    const S3 = Math.atan2(b2, v3);
    v3 = e5.x - x4.value(), b2 = e5.y - C3.value();
    const E2 = Math.atan2(b2, v3);
    v3 = s4.x - x4.value(), b2 = s4.y - C3.value();
    const D3 = Math.atan2(b2, v3);
    let w4 = D3 - 2 * Hs();
    for (; w4 < S3; ) w4 += 2 * Hs();
    let A4 = E2 - 2 * Hs();
    for (; A4 < w4; ) A4 += 2 * Hs();
    let T3 = D3 + 2 * Hs();
    for (; T3 > S3; ) T3 -= 2 * Hs();
    let I4, M2 = E2 + 2 * Hs();
    for (; M2 > T3; ) M2 -= 2 * Hs();
    I4 = A4 - S3 < S3 - M2 ? A4 - S3 : M2 - S3;
    const Y3 = new mi(x4.value(), C3.value());
    return this.constructEllipticArcEndPointsCenter(t3, e5, y2.value(), 1, 0, Math.abs(I4) > Hs(), I4 > 0, Y3), this.m_interior.assign(s4), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructCircularArc(t3, e5, s4, n6) {
    return this.constructEllipticArcGeneral(t3, 1, e5, s4, n6, 0), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructEllipticArcEndPoints(t3, e5, s4, n6, i2, r, o) {
    return vu(this, t3, e5, s4, n6, i2, r, o);
  }
  constructEllipticArcEndPointsCenter(t3, e5, s4, n6, i2, r, o, a2) {
    return vu(this, t3, e5, s4, n6, i2, r, o, a2);
  }
  constructEllipticArcGeneral(t3, e5, s4, n6, i2, r) {
    this.m_semiMajorAxis = Math.abs(t3), this.m_minorMajorRatio = Math.abs(e5), this.m_minorMajorRatio > 1 && (this.m_semiMajorAxis *= this.m_minorMajorRatio, this.m_minorMajorRatio = 1 / this.m_minorMajorRatio);
    const o = Mh(r), a2 = Math.cos(o), h2 = Math.sin(o), u = new mi(this.m_semiMajorAxis, this.m_minorMajorRatio * this.m_semiMajorAxis), m3 = mi.getNAN(), l2 = Mh(n6);
    m3.x = u.x * Math.cos(l2), m3.y = u.y * Math.sin(l2), m3.rotateDirect(a2, h2), m3.addThis(s4);
    const c = js(i2, $s());
    let g2 = c;
    Math.abs(g2) === $s() && (g2 = 0);
    const d2 = mi.getNAN();
    return d2.x = u.x * Math.cos(l2 + g2), d2.y = u.y * Math.sin(l2 + g2), d2.rotateDirect(a2, h2), d2.addThis(s4), this.constructEllipticArcEndPointsCenter(m3, d2, this.m_semiMajorAxis, this.m_minorMajorRatio, o, Math.abs(c) > Hs(), c > 0, s4);
  }
  constructEllipticArcAsNURB(t3, s4, n6, i2) {
    (i2 >= 1 || i2 < 0) && P("construct_elliptic_arc_as_NURB: weight"), s4.isFinite() || P("construct_elliptic_arc_as_NURB: control_point");
    return ku([t3, s4, n6], i2 * i2, null, false, this), this;
  }
  constructCanonic(t3) {
    return this.assignCopy(t3), t3.isDegenerateToLine() || t3.m_center.isEqual(0, 0) && 0 === this.m_rotation || (this.m_XStart = t3.getSemiMajorAxis() * Math.cos(t3.m_startAngle), this.m_YStart = t3.getSemiMinorAxis() * Math.sin(t3.m_startAngle), this.m_XEnd = t3.getSemiMajorAxis() * Math.cos(t3.getEndAngle()), this.m_YEnd = t3.getSemiMinorAxis() * Math.sin(t3.getEndAngle()), this.m_center.setCoords(0, 0), this.m_rotation = 0, this.m_cosr = 1, this.m_sinr = 0, Hu(this), this.afterCompletedModification(), t3 !== this && ss(this, t3)), this;
  }
  isCircular() {
    return 1 === this.m_minorMajorRatio && 0 === this.m_rotation && !this.isDegenerateToLine();
  }
  isDegenerateToLineHelper(t3) {
    if (this.isLine()) return true;
    if (this.isMajor()) return false;
    const e5 = this.getEndXY().sub(this.getStartXY()).length();
    return !(this.calculateLength2D() - e5 > t3);
  }
  isDegenerateToLine() {
    return Su(this);
  }
  getCenter() {
    return this.m_center.clone();
  }
  setCenter(t3) {
    if (!this.m_center.isNAN()) {
      const e5 = t3.sub(this.m_center);
      this.m_XStart += e5.x, this.m_YStart += e5.y, this.m_XEnd += e5.x, this.m_YEnd += e5.y, this.m_interior.addThis(e5), this.m_center.assign(t3), this.endPointModified(), this.normalizeAfterEndpointChange();
    }
  }
  getAxisXRotation() {
    return this.m_rotation;
  }
  getSemiAxes() {
    return mi.construct(this.m_semiMajorAxis, this.m_semiMajorAxis * this.m_minorMajorRatio);
  }
  getSemiMajorAxis() {
    return this.m_semiMajorAxis;
  }
  getSemiMinorAxis() {
    return this.m_semiMajorAxis * this.m_minorMajorRatio;
  }
  getMinorMajorRatio() {
    return this.m_minorMajorRatio;
  }
  isClockwise() {
    return !Xu(this);
  }
  isMajor() {
    return Fu(this);
  }
  getSweepAngle() {
    return this.m_sweepAngle;
  }
  getStartAngle() {
    return this.m_startAngle;
  }
  getEndAngle() {
    return this.m_startAngle + this.m_sweepAngle;
  }
  getGeometryType() {
    return a.enumEllipticArc;
  }
  queryEnvelope(t3) {
    if (4 === t3.m_EnvelopeType) {
      t3.setEmpty(), t3.assignVertexDescription(this.m_description);
      const e5 = n4.constructEmpty();
      this.queryEnvelope(e5), t3.setEnvelope(e5);
      for (let s4 = 1, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) {
        const e6 = this.m_description.getSemantics(s4);
        for (let n7 = 0, i2 = Nh.getComponentCount(e6); s4 < i2; s4++) {
          const s5 = this.queryInterval(e6, n7);
          t3.setIntervalEnvelope(e6, n7, s5);
        }
      }
    } else 2 === t3.m_EnvelopeType ? Ku(this, x2.unit(), t3) : z("3d not impl");
  }
  applyTransformation(t3) {
    Au(this, t3, false, null, null);
  }
  createInstance() {
    return new _Xh();
  }
  calculateLength2D() {
    return pu(this, 0, 1);
  }
  queryControlPointsHelper(t3) {
    b("");
  }
  queryCoord2D(t3, e5) {
    if (Su(this)) ps(t3, this.getStartXY(), this.getEndXY(), e5);
    else if (0 === t3) e5.assign(mi.construct(this.m_XStart, this.m_YStart));
    else if (1 === t3) e5.assign(mi.construct(this.m_XEnd, this.m_YEnd));
    else {
      const s4 = cu(this, t3), n6 = new mi(this.m_semiMajorAxis * Math.cos(s4), this.getSemiMinorAxis() * Math.sin(s4));
      n6.rotateDirect(this.m_cosr, this.m_sinr), n6.addThis(this.m_center), e5.assign(n6);
    }
  }
  queryCoord2DE(t3, e5) {
    nu(this, t3, e5);
  }
  queryCoord2DMP(t3, e5) {
    z("");
  }
  getCoordX(t3) {
    const e5 = new mi();
    return this.queryCoord2D(t3, e5), e5.x;
  }
  getCoordY(t3) {
    const e5 = new mi();
    return this.queryCoord2D(t3, e5), e5.y;
  }
  cut(t3, e5, s4) {
    const n6 = new fm();
    return this.queryCut(t3, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t3, e5, s4, n6) {
    const i2 = s4.createEllipticArc();
    n6 && i2.dropAllAttributes();
    let r = 0 === t3 && 1 === e5;
    if (r && !n6) return void this.copyTo(i2);
    const o = mi.getNAN();
    this.queryCoord2D(t3, o);
    const a2 = mi.getNAN();
    if (this.queryCoord2D(e5, a2), !r) {
      if (o.equals(a2)) e5 - t3 > 0.5 && this.isMajor() && this.isClosed() ? (r = true, t3 = 0, e5 = 1) : 1 === e5 ? t3 = e5 : e5 = t3;
      else if (t3 > 0 && o.isEqual(this.m_XStart, this.m_YStart) && (t3 = 0), e5 < 1 && a2.isEqual(this.m_XEnd, this.m_YEnd) && (e5 = 1), r = 0 === t3 && 1 === e5, r && !n6) return void this.copyTo(i2);
    }
    if (i2.m_center.assign(this.m_center), i2.m_semiMajorAxis = this.m_semiMajorAxis, i2.m_minorMajorRatio = this.m_minorMajorRatio, i2.m_interior.assign(this.m_interior), i2.m_rotation = this.m_rotation, i2.m_cosr = this.m_cosr, i2.m_sinr = this.m_sinr, i2.m_sweepAngle = this.m_sweepAngle, i2.m_startAngle = this.m_startAngle, i2.m_bits = this.m_bits, je(i2, o.x, o.y), He(i2, a2.x, a2.y), r) return void Iu(i2, fu(this));
    i2.m_startAngle = cu(this, t3), i2.m_sweepAngle = cu(this, e5) - i2.m_startAngle, i2.m_startAngle = au(i2.m_startAngle), qu(i2, Math.abs(i2.m_sweepAngle) > Hs()), n6 && i2.assignVertexDescription(this.m_description), Hu(i2), mu(i2);
    const h2 = this.m_description.getAttributeCount();
    if (h2 > 1 && !n6) {
      for (let e6 = 1; e6 < h2; e6++) {
        const s5 = this.m_description.getSemantics(e6), n7 = Nh.getComponentCount(s5);
        for (let e7 = 0; e7 < n7; e7++) {
          const n8 = this.getAttributeAsDbl(t3, s5, e7);
          i2.setStartAttribute(s5, e7, n8);
        }
      }
      for (let t4 = 1; t4 < h2; t4++) {
        const s5 = this.m_description.getSemantics(t4), n7 = Nh.getComponentCount(s5);
        for (let t5 = 0; t5 < n7; t5++) {
          const n8 = this.getAttributeAsDbl(e5, s5, t5);
          i2.setEndAttribute(s5, t5, n8);
        }
      }
    }
    i2.afterCompletedModification();
  }
  queryDerivative(t3, e5) {
    sm(this, t3, e5);
  }
  cutArcIgnoreAttributes(t3, e5, s4) {
    let n6 = 0 === t3 && 1 === e5;
    const i2 = new mi();
    this.queryCoord2D(t3, i2);
    const r = new mi();
    this.queryCoord2D(e5, r), n6 || (i2.equals(r) ? e5 - t3 > 0.5 && this.isMajor() && this.isClosed() ? (n6 = true, t3 = 0, e5 = 1) : 1 === e5 ? t3 = e5 : e5 = t3 : (t3 > 0 && i2.isEqual(this.m_XStart, this.m_YStart) && (t3 = 0), e5 < 1 && r.isEqual(this.m_XEnd, this.m_YEnd) && (e5 = 1), n6 = 0 === t3 && 1 === e5)), s4.m_center.assign(this.m_center), s4.m_semiMajorAxis = this.m_semiMajorAxis, s4.m_minorMajorRatio = this.m_minorMajorRatio, s4.m_interior.assign(this.m_interior), s4.m_rotation = this.m_rotation, s4.m_cosr = this.m_cosr, s4.m_sinr = this.m_sinr, s4.m_sweepAngle = this.m_sweepAngle, s4.m_startAngle = this.m_startAngle, s4.m_bits = this.m_bits, je(s4, i2.x, i2.y), He(s4, r.x, r.y), n6 ? Iu(s4, fu(this)) : (s4.m_startAngle = cu(this, t3), s4.m_sweepAngle = cu(this, e5) - s4.m_startAngle, s4.m_startAngle = au(s4.m_startAngle), qu(s4, Math.abs(s4.m_sweepAngle) > Math.PI), Hu(s4), s4.afterCompletedModification());
  }
  changeEndPoints2D(t3, e5) {
    yu(this, t3, e5, false);
  }
  getAttributeAsDbl(t3, e5, s4) {
    if (0 === e5) return 0 === s4 ? this.getCoordX(t3) : this.getCoordY(t3);
    if (0 === t3) return this.getStartAttributeAsDbl(e5, s4);
    if (1 === t3) return this.getEndAttributeAsDbl(e5, s4);
    const n6 = this.calculateLength2D(), i2 = n6 > 0 ? this.tToLength(t3) / n6 : 0, r = Nh.getInterpolation(e5), o = this.getStartAttributeAsDbl(e5, s4), a2 = this.getEndAttributeAsDbl(e5, s4);
    return It(r, o, a2, i2, Nh.getDefaultValue(e5));
  }
  getClosestCoordinate(t3, e5) {
    return $u(this, t3, x2.unit(), e5);
  }
  getClosestCoordinateOnInterval(t3, e5, s4 = -1) {
    return $u(this, t3, e5, false);
  }
  getYMonotonicParts(t3, n6 = false) {
    t3.length < 2 && P("");
    const i2 = this.getSemiAxes(), r = Math.atan2(i2.y * this.m_cosr, i2.x * this.m_sinr), o = r + Hs(), a2 = Yt(3, Number.NaN);
    let h2 = 0;
    if (a2[0] = lu(this, r), a2[0] > 0 && a2[0] < 1 && h2++, a2[1] = lu(this, o), a2[1] > 0 && a2[1] < 1 && (a2[h2] = a2[1], h2++), 0 === h2) return 0;
    a2[h2] = 1, h2++, n2(t3.length >= h2);
    let u = 0;
    for (let e5 = 0; e5 < h2; e5++) {
      const s4 = a2[e5];
      this.queryCut(u, s4, t3[e5], n6), u = s4;
    }
    return h2;
  }
  getMonotonicParts(t3, n6) {
    if (t3.length < 4 && P(""), this.isDegenerateToLine()) return t3[0].createEllipticArc().assignCopy(this), n6 && t3[0].get().dropAllAttributes(), 1;
    const i2 = this.getSemiAxes(), r = Yt(4, Number.NaN);
    r[0] = Math.atan2(i2.y * this.m_cosr, i2.x * this.m_sinr), r[1] = r[0] + Hs(), r[2] = Math.atan2(-i2.y * this.m_sinr, i2.x * this.m_cosr), r[3] = r[2] + Hs();
    const o = Yt(5, Number.NaN);
    let a2 = 0;
    for (let e5 = 0; e5 < 4; e5++) o[a2] = lu(this, r[e5]), o[a2] > 0 && o[a2] < 1 && a2++;
    if (0 === a2) return 0;
    zt(o, a2), o[a2 - 1] < 1 && (o[a2] = 1, a2++), n2(t3.length >= a2);
    let h2 = 0;
    for (let e5 = 0; e5 < a2; e5++) {
      const s4 = o[e5];
      this.queryCut(h2, s4, t3[e5], n6), h2 = s4;
    }
    return a2;
  }
  intersectionWithAxis2D(t3, e5, s4, n6) {
    if (Su(this)) {
      return new pm({ start: this.getStartXY(), end: this.getEndXY() }).intersectionWithAxis2D(t3, e5, s4, n6);
    }
    let i2, r;
    const o = new p2(e5), a2 = this.getSemiAxes();
    if (t3) {
      if (e5 > this.m_center.y + a2.x || e5 < this.m_center.y - a2.x) return 0;
      i2 = new p2(a2.x).mulThis(this.m_sinr), r = new p2(a2.y).mulThis(this.m_cosr), o.subThis(this.m_center.y);
    } else {
      if (e5 > this.m_center.x + a2.x || e5 < this.m_center.x - a2.x) return 0;
      i2 = new p2(a2.x).mulThis(this.m_cosr), r = new p2(a2.y).mulThis(-this.m_sinr), o.subThis(this.m_center.x);
    }
    const h2 = i2.sqr(), u = r.sqr(), m3 = h2.addE(u), l2 = r.mulE(o).mulThis(-2), c = o.sqr().subThisE(h2), g2 = l2.sqr().subThisE(m3.mulE(c).mulThis(4)), d2 = i2.mulE(o).mulThis(-2), _ = o.sqr().subThisE(u), p3 = d2.sqr().subThisE(m3.mulE(_).mulThis(4));
    let f3 = g2.eps() * Math.abs(p3.value()) <= p3.eps() * Math.abs(g2.value());
    f3 ? i2.isZero() && (f3 = false) : r.isZero() && (f3 = true), f3 || (l2.setE(d2), c.setE(_));
    const P5 = Ot(p2, 2);
    let y2 = gn(m3, l2, c, x2.construct(-1, 1), false, P5);
    if (0 === y2) return 0;
    const x4 = [0, 0];
    let C3 = 0;
    for (let v3 = 0; v3 < y2; v3++) {
      const t4 = new p2(), e6 = new p2();
      f3 ? (t4.setE(P5[v3]), e6.setE(o.subE(r.mulE(P5[v3])).divThisE(i2))) : (e6.setE(P5[v3]), t4.setE(o.subE(i2.mulE(P5[v3])).divThisE(r)));
      const s5 = lu(this, Math.atan2(t4.value(), e6.value()));
      s5 >= 0 && s5 <= 1 && (x4[C3] = s5, C3++);
    }
    return y2 = C3, 0 === y2 ? 0 : (2 === y2 && x4[0] > x4[1] && (x4[1] = Pt(x4[0], x4[0] = x4[1])), n6 && Dt(n6, x4, 0, 0, y2), s4 && (s4[0] = t3 ? this.getCoordX(x4[0]) : this.getCoordY(x4[0]), y2 > 1 && (s4[1] = t3 ? this.getCoordX(x4[1]) : this.getCoordY(x4[1]), !n6 && s4[0] > s4[1] && (s4[1] = Pt(s4[0], s4[0] = s4[1])))), y2);
  }
  intersectionOfYMonotonicWithAxisX(t3, e5) {
    if (this.m_YStart === this.m_YEnd) return t3 === this.m_YStart ? e5 : Number.NaN;
    if (t3 === this.m_YStart) return this.m_XStart;
    if (t3 === this.m_YEnd) return this.m_XEnd;
    const s4 = [0, 0];
    return -1 === this.intersectionWithAxis2D(true, t3, s4, null) ? e5 : s4[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t3) {
    return Re(this, t3);
  }
  isDegenerate3D(t3, e5) {
    return n2(0), false;
  }
  queryLooseEnvelope(t3) {
    3 !== t3.m_EnvelopeType ? this.queryLooseEnvelopeOnInterval(new x2(0, 1), t3) : z("3d not impl");
  }
  clone(t3) {
    const e5 = new _Xh();
    return this.copyTo(e5), e5;
  }
  queryInterval(t3, e5) {
    if (0 === t3) {
      if (Su(this)) return 0 === e5 ? x2.construct(this.getStartX(), this.getEndX()) : x2.construct(this.getStartY(), this.getEndY());
      let t4;
      const s4 = this.getSemiAxes();
      t4 = 0 === e5 ? Math.atan2(-s4.y * this.m_sinr, s4.x * this.m_cosr) : Math.atan2(s4.y * this.m_cosr, s4.x * this.m_sinr);
      const n6 = t4 + Math.PI, i2 = [0, 0];
      i2[0] = lu(this, t4), i2[1] = lu(this, n6);
      const r = 0 === e5 ? x2.construct(this.getStartX(), this.getEndX()) : x2.construct(this.getStartY(), this.getEndY()), o = new mi();
      for (let a2 = 0; a2 < 2; a2++) {
        const t5 = i2[a2];
        t5 > 0 && t5 < 1 && (this.queryCoord2D(t5, o), r.mergeNeCoordinate(0 === e5 ? o.x : o.y));
      }
      return r;
    }
    return super.queryInterval(t3, e5);
  }
  queryLooseEnvelopeOnInterval(t3, e5) {
    const s4 = new x2(0, 1);
    if (s4.intersect(t3), s4.isEmpty()) return void e5.setEmpty();
    if (Su(this)) return e5.setCoords(this.getCoord2D(s4.vmin)), void e5.mergeNe(this.getCoord2D(s4.vmax));
    const n6 = this.getCoord2D(s4.vmin), i2 = this.getCoord2D(s4.vmax);
    if (1 === this.m_minorMajorRatio && Math.abs(this.m_sweepAngle) * s4.width() <= Wt) {
      let t4 = mi.lerp(n6, i2, 0.5);
      const s5 = t4.sub(this.m_center);
      return s5.normalize(), t4 = t4.add(s5.mul(0.5 * mi.distance(n6, i2))), e5.setCoords(n6), e5.mergeNe(i2), void e5.mergeNe(t4);
    }
    Ku(this, s4, e5);
  }
  tToLength(t3) {
    return Su(this) ? t3 * mi.distance(this.getStartXY(), this.getEndXY()) : 1 === this.m_minorMajorRatio ? Math.abs(this.getSweepAngle() * t3) * this.m_semiMajorAxis : Eu(this, t3);
  }
  parametricAngleToT(t3) {
    return lu(this, t3);
  }
  tToParametricAngle(t3) {
    return cu(this, t3);
  }
  lengthToT(t3) {
    if (Su(this)) {
      const e5 = mi.distance(this.getStartXY(), this.getEndXY());
      return 0 === e5 ? 0 : t3 / e5;
    }
    if (1 === this.m_minorMajorRatio) {
      const e5 = Math.abs(this.getSweepAngle()) * this.m_semiMajorAxis;
      return 0 === e5 ? 0 : t3 / e5;
    }
    return Du(this, t3);
  }
  calculateWeightedAreaCentroid2D(t3) {
    if (Su(this)) {
      const t4 = new mi();
      return t4.setCoords(0, 0), t4;
    }
    const e5 = Zu(this), s4 = this.getStartXY().sub(this.m_center), n6 = this.getEndXY().sub(this.m_center), i2 = this.m_semiMajorAxis, r = this.getSemiMinorAxis(), o = this.m_startAngle + this.m_sweepAngle, a2 = new mi();
    a2.x = i2 * r * (i2 * this.m_cosr * (-Math.sin(o) + Math.sin(this.m_startAngle)) + r * (-Math.cos(o) + Math.cos(this.m_startAngle)) * this.m_sinr) / 3, a2.y = i2 * r * (r * (Math.cos(o) - Math.cos(this.m_startAngle)) * this.m_cosr + i2 * (-Math.sin(o) + Math.sin(this.m_startAngle)) * this.m_sinr) / 3;
    const h2 = n6.add(s4).mul(n6.crossProduct(s4) / 6);
    return a2.x -= h2.x, a2.y -= h2.y, a2.add(this.m_center.sub(t3).mul(e5));
  }
  calculateWeightedCentroid2D() {
    const t3 = new mi();
    if (this.isDegenerate(0)) return t3.setCoords(0, 0), t3;
    if (Su(this)) return t3.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t3;
    let e5 = this.m_startAngle, s4 = this.m_startAngle + this.m_sweepAngle;
    if (s4 < e5) {
      const t4 = e5;
      e5 = s4, s4 = t4;
    }
    const n6 = Math.sin(e5), i2 = Math.sin(s4), r = Math.cos(e5), o = Math.cos(s4);
    if (1 === this.m_minorMajorRatio) {
      const e6 = this.getSemiMajorAxis(), s5 = e6 * e6, a2 = s5 * (i2 - n6), h2 = s5 * (r - o);
      t3.setCoords(a2, h2);
    } else {
      const e6 = this.getSemiMajorAxis(), s5 = this.getSemiMinorAxis(), a2 = e6 * e6, h2 = s5 * s5, u = e6 * s5, m3 = a2 - h2, l2 = m3 / h2, c = m3 / a2, g2 = Math.sqrt(l2), d2 = Math.sqrt(c), _ = 0.5 * u * (Math.asinh(g2 * i2) / g2 + i2 * Math.sqrt(1 + l2 * i2 * i2)) - 0.5 * u * (Math.asinh(g2 * n6) / g2 + n6 * Math.sqrt(1 + l2 * n6 * n6)), p3 = -0.5 * u * (Math.asin(d2 * o) / d2 + o * Math.sqrt(1 - c * o * o)) - -0.5 * u * (Math.asin(d2 * r) / d2 + r * Math.sqrt(1 - c * r * r));
      t3.setCoords(_, p3);
    }
    return t3.rotateDirect(this.m_cosr, this.m_sinr), t3.assign(t3.add(this.m_center.mul(this.calculateLength2D()))), t3;
  }
  isIntersectingPoint(t3, e5, s4) {
    if (s4 && (t3.isEqualPoint2D(this.getStartXY()) || t3.isEqualPoint2D(this.getEndXY()))) return false;
    if (!Su(this)) {
      const s5 = mi.distance(t3, this.m_center), n7 = this.getSemiAxes();
      if (s5 < n7.x - e5 || s5 > n7.y + e5) return false;
    }
    const n6 = this.getClosestCoordinate(t3, false), i2 = new mi();
    this.queryCoord2D(n6, i2);
    return mi.distance(i2, t3) <= e5;
  }
  isIntersectingPoint3D(t3, e5, n6, i2, r = 1) {
    return n2(0), false;
  }
  getTangent(t3) {
    if (Su(this)) return this.getEndXY().sub(this.getStartXY());
    {
      const e5 = cu(this, t3), s4 = new mi();
      return s4.setCoords(-this.m_semiMajorAxis * Math.sin(e5), this.getSemiMinorAxis() * Math.cos(e5)), this.m_rotation && s4.rotateDirect(this.m_cosr, this.m_sinr), s4.scale(this.getSweepAngle()), s4;
    }
  }
  getDerivative(t3) {
    if (Su(this)) return this.getEndXY().sub(this.getStartXY());
    {
      const e5 = cu(this, t3), s4 = new mi();
      return s4.setCoords(-this.m_semiMajorAxis * Math.sin(e5), this.getSemiMinorAxis() * Math.cos(e5)), this.m_rotation && s4.rotateDirect(this.m_cosr, this.m_sinr), s4.scale(this.getSweepAngle()), s4;
    }
  }
  normalizeAfterEndpointChange() {
    return !!Lu(this) && (Su(this) ? (Ru(this), false) : zu(this, false));
  }
  projectionBehavior() {
    return (4 & this.m_bits) >> 2;
  }
  setProjectionBehavior(t3) {
    this.m_bits = -5 & this.m_bits | t3 << 2;
  }
  convertToCanonic(t3) {
    const e5 = new mi(t3.x, t3.y);
    return e5.subThis(this.m_center), e5.rotateReverse(this.m_cosr, this.m_sinr), e5;
  }
  convertFromCanonic(t3) {
    const e5 = new mi(t3.x, t3.y);
    return e5.rotateDirect(this.m_cosr, this.m_sinr), e5.addThis(this.m_center), e5;
  }
  canonicToWorldTransformation(t3) {
    t3.setRotate(this.m_cosr, this.m_sinr), t3.shiftCoords(this.m_center.x, this.m_center.y);
  }
  getCurvature(t3) {
    const e5 = cu(this, t3), s4 = new mi(), n6 = this.getSemiMinorAxis();
    s4.setCoords(-this.m_semiMajorAxis * Math.sin(e5), n6 * Math.cos(e5));
    const i2 = new mi();
    i2.setCoords(-this.m_semiMajorAxis * Math.cos(e5), -n6 * Math.sin(e5)), this.m_rotation && (s4.rotateDirect(this.m_cosr, this.m_sinr), i2.rotateDirect(this.m_cosr, this.m_sinr));
    const r = s4.sqrLength();
    if (0 === r) return Number.NaN;
    const o = Math.sqrt(r);
    s4.divThis(o);
    return s4.crossProduct(i2) / r;
  }
  getMonotonicPartParams(t3, s4) {
    const n6 = Yt(6, Number.NaN);
    n6[0] = 0;
    let i2 = 1;
    if (this.isDegenerateToLine()) n6[1] = 1, i2 = 2;
    else {
      const t4 = this.getSemiAxes(), e5 = Yt(4, Number.NaN);
      this.m_rotation ? (e5[0] = Math.atan2(t4.y * this.m_cosr, t4.x * this.m_sinr), e5[1] = e5[0] + Math.PI, e5[2] = Math.atan2(-t4.y * this.m_sinr, t4.x * this.m_cosr), e5[3] = e5[2] + Math.PI) : (e5[0] = 0, e5[1] = Math.PI, e5[2] = 0.5 * Math.PI, e5[3] = Ws());
      for (let s5 = 0; s5 < 4; s5++) {
        const t5 = lu(this, e5[s5]);
        t5 > 0 && t5 < 1 && (n6[i2] = t5, i2++);
      }
      i2 > 2 && zt(n6, i2), n6[i2] = 1, i2++;
    }
    if (s4) {
      t3 < i2 && P("");
      for (let t4 = 0; t4 < i2; t4++) s4[t4] = n6[t4];
    }
    return i2;
  }
  calculateLowerLength2D() {
    const t3 = mi.distance(this.getStartXY(), this.getEndXY());
    if (this.isDegenerateToLine()) return t3;
    const e5 = Math.abs(this.m_sweepAngle) * this.getSemiMinorAxis();
    return Math.max(e5, t3);
  }
  calculateUpperLength2D() {
    const t3 = mi.distance(this.getStartXY(), this.getEndXY());
    if (this.isDegenerateToLine()) return t3;
    const e5 = Math.abs(this.m_sweepAngle) * this.getSemiMajorAxis();
    return Math.max(e5, t3);
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Pt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Pt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t3 = 0, e5 = this.m_description.getTotalComponentCount() - 2; t3 < e5; t3++) this.m_attributes[t3 + e5] = Pt(this.m_attributes[t3], this.m_attributes[t3] = this.m_attributes[t3 + e5]);
      this.m_startAngle = this.m_startAngle + this.m_sweepAngle, this.m_sweepAngle = -this.m_sweepAngle;
    }
  }
  isLine() {
    return Su(this);
  }
  copyIgnoreAttributes(t3) {
    t3.m_XStart = this.m_XStart, t3.m_YStart = this.m_YStart, t3.m_XEnd = this.m_XEnd, t3.m_YEnd = this.m_YEnd, t3.m_center.assign(this.m_center), t3.m_semiMajorAxis = this.m_semiMajorAxis, t3.m_minorMajorRatio = this.m_minorMajorRatio, t3.m_interior.assign(this.m_interior), t3.m_rotation = this.m_rotation, t3.m_cosr = this.m_cosr, t3.m_sinr = this.m_sinr, t3.m_sweepAngle = this.m_sweepAngle, t3.m_startAngle = this.m_startAngle, t3.m_bits = this.m_bits, Mu(t3);
  }
  calculateArea2DHelper() {
    return Zu(this);
  }
  absNorm() {
    let t3 = this.getStartXY().norm(1) + this.getEndXY().norm(1);
    return this.isDegenerateToLine() || (t3 += this.m_center.norm(1), t3 += this.m_semiMajorAxis), t3;
  }
  queryEnvelopeW(t3, e5) {
    if (e5.setCoords(this.getCoord2D(t3.vmin)), e5.mergeNe(this.getCoord2D(t3.vmax)), Su(this)) return;
    const s4 = this.getSemiAxes(), n6 = Yt(8, Number.NaN);
    {
      const t4 = Math.atan2(-s4.y * this.m_sinr, s4.x * this.m_cosr), e6 = t4 + Math.PI, i3 = Math.atan2(s4.y * this.m_cosr, s4.x * this.m_sinr), r = i3 + Math.PI;
      n6[0] = lu(this, t4), n6[1] = lu(this, e6), n6[2] = lu(this, i3), n6[3] = lu(this, r);
    }
    {
      const t4 = this.m_cosr + this.m_sinr, e6 = this.m_cosr - this.m_sinr, i3 = Math.atan2(-s4.y * t4, s4.x * e6), r = i3 + Math.PI, o = Math.atan2(s4.y * e6, s4.x * t4), a2 = o + Math.PI;
      n6[4] = lu(this, i3), n6[5] = lu(this, r), n6[6] = lu(this, o), n6[7] = lu(this, a2);
    }
    const i2 = mi.getNAN();
    for (let r = 0; r < 8; r++) {
      const s5 = n6[r];
      t3.containsExclusiveCoordinate(s5) && (this.queryCoord2D(s5, i2), e5.mergeNe(i2));
    }
  }
  setSegmentFromCoordsForStitcher(t3, e5) {
    xu(this, t3, e5);
  }
  writeInBufferStream(t3, e5) {
    const s4 = new Float64Array(10);
    return s4[0] = this.m_bits, s4[1] = this.m_semiMajorAxis, s4[2] = this.m_minorMajorRatio, s4[3] = this.m_rotation, s4[4] = this.m_center.x, s4[5] = this.m_center.y, s4[6] = this.m_sweepAngle, s4[7] = this.m_startAngle, s4[8] = this.m_interior.x, s4[9] = this.m_interior.y, t3.writeRangeFromArray(e5, s4.length, s4, true, 1), e5 + s4.length;
  }
  readFromBufferStream(t3, e5) {
    const s4 = new Float64Array(10);
    t3.queryRange(e5, s4.length, s4, true, 1), this.m_bits = s4[0], this.m_semiMajorAxis = s4[1], this.m_minorMajorRatio = s4[2], this.m_rotation = s4[3], this.m_center.x = s4[4], this.m_center.y = s4[5], this.m_sweepAngle = s4[6], this.m_startAngle = s4[7], this.m_interior.x = s4[8], this.m_interior.y = s4[9], this.m_cosr = Math.cos(this.m_rotation), this.m_sinr = Math.sin(this.m_rotation), this.m_cachedValues = null;
  }
  snapControlPoints(t3) {
    return false;
  }
  needsSnapControlPoints(t3) {
    return false;
  }
  calculateSpecialPointsForCracking(t3, e5) {
    return b("should not1; be called"), 0;
  }
  ensureXYMonotone() {
    if (Su(this)) return false;
    if (this.getStartXY().equals(this.getEndXY())) return bu(this, this.getStartXY(), this.getEndXY(), this.projectionBehavior()), true;
    const t3 = Ot(mi, 3);
    let e5 = Bu(this, t3);
    if (Ha(t3)) {
      let s4 = false;
      if (0 === this.projectionBehavior()) {
        const n6 = new n4();
        n6.setCoords({ pt: t3[0] }), n6.mergeNe(t3[2]);
        const i2 = new mi();
        i2.setSub(t3[2], t3[0]), i2.leftPerpendicularThis(), i2.normalize(), i2.scale(mi.distance(t3[2], t3[0]));
        const r = mi.lerp(t3[2], t3[0], 0.5), o = r.sub(i2), a2 = r.add(i2);
        n6.clipLine(o, a2);
        const h2 = mi.getClosestCoordinate(o, a2, t3[1], false);
        t3[1] = mi.lerp(o, a2, h2);
        const u = t3[2].sub(t3[1]), m3 = t3[0].sub(t3[1]), l2 = u.crossProduct(m3), c = u.dotProduct(m3);
        e5 = Js() - Math.abs(0.5 * Math.atan2(l2, c)), s4 = true;
      }
      return ku(t3, e5 * e5, null, s4, this), true;
    }
    return false;
  }
  setCoordsForIntersector(t3, e5, s4) {
    yu(this, t3, e5, s4);
  }
  getInteriorPoint() {
    return this.m_interior.clone();
  }
  copyToImpl(t3) {
    const e5 = t3;
    e5.m_center.assign(this.m_center), e5.m_semiMajorAxis = this.m_semiMajorAxis, e5.m_minorMajorRatio = this.m_minorMajorRatio, e5.m_interior.assign(this.m_interior), e5.m_rotation = this.m_rotation, e5.m_cosr = this.m_cosr, e5.m_sinr = this.m_sinr, e5.m_sweepAngle = this.m_sweepAngle, e5.m_startAngle = this.m_startAngle, e5.m_bits = this.m_bits, Iu(e5, fu(this));
  }
  reverseImpl() {
    Nu(this, !Xu(this)), mu(this), (0 !== this.projectionBehavior() || this.getStartXY().equals(this.getEndXY())) && Hu(this);
  }
  equalsImpl(t3) {
    const e5 = t3;
    if (this.m_bits !== e5.m_bits) return false;
    if (this.m_semiMajorAxis !== e5.m_semiMajorAxis) return false;
    if (this.m_minorMajorRatio !== e5.m_minorMajorRatio) return false;
    if (!(this.m_center.isEqualPoint2D(e5.m_center) || this.m_center.isNAN() && e5.m_center.isNAN())) return false;
    if (this.m_rotation !== e5.m_rotation) return false;
    if (!this.m_interior.equals(e5.m_interior)) return false;
    const s4 = e5.m_sweepAngle;
    if (this.m_sweepAngle !== s4) return false;
    const n6 = e5.m_startAngle;
    return this.m_startAngle === n6;
  }
  equalsImplTol(t3, e5) {
    const s4 = t3;
    if (this.m_bits !== s4.m_bits) return false;
    if (this.m_center.isNAN() && s4.m_center.isNAN()) return true;
    if (this.m_center.isNAN() !== s4.m_center.isNAN()) return false;
    if (!this.getSemiAxes().isEqualPoint2D(s4.getSemiAxes(), e5)) return false;
    if (!this.m_center.isEqualPoint2D(s4.m_center, e5)) return false;
    const n6 = Math.abs(Ah(wh(Th(this.m_rotation - s4.m_rotation)))), i2 = Math.abs(Hs() - n6), r = Math.min(n6, i2);
    if (this.m_semiMajorAxis * Math.abs(r) > e5) return false;
    const o = this.getCoord2D(0.5), a2 = s4.getCoord2D(0.5);
    return !!o.isEqualPoint2D(a2, e5);
  }
  swapImpl(t3) {
    const e5 = t3;
    this.m_center = Pt(e5.m_center, e5.m_center = this.m_center), this.m_semiMajorAxis = Pt(e5.m_semiMajorAxis, e5.m_semiMajorAxis = this.m_semiMajorAxis), this.m_minorMajorRatio = Pt(e5.m_minorMajorRatio, e5.m_minorMajorRatio = this.m_minorMajorRatio), this.m_interior = Pt(e5.m_interior, e5.m_interior = this.m_interior), this.m_rotation = Pt(e5.m_rotation, e5.m_rotation = this.m_rotation), this.m_cosr = Pt(e5.m_cosr, e5.m_cosr = this.m_cosr), this.m_sinr = Pt(e5.m_sinr, e5.m_sinr = this.m_sinr), this.m_sweepAngle = Pt(e5.m_sweepAngle, e5.m_sweepAngle = this.m_sweepAngle), this.m_startAngle = Pt(e5.m_startAngle, e5.m_startAngle = this.m_startAngle), this.m_bits = Pt(e5.m_bits, e5.m_bits = this.m_bits), Yu(this, e5);
  }
  afterCompletedModification() {
    Ru(this), Mu(this);
  }
  intersect(t3, e5, s4, n6, i2) {
    return um(false, this, t3, e5, s4, n6, i2);
  }
  intersectPoint(t3, e5, s4) {
    if (e5.length < 2 && A(""), Su(this)) {
      return new pm({ start: this.getStartXY(), end: this.getEndXY() }).intersectPoint(t3, e5, s4);
    }
    {
      const e6 = mi.distance(t3, this.m_center);
      if (e6 > this.m_semiMajorAxis + s4 || e6 < this.getSemiMinorAxis() - s4) return 0;
    }
    const i2 = this.getClosestCoordinate(t3, false), r = mi.getNAN();
    return this.queryCoord2D(i2, r), mi.distance(r, t3) <= s4 ? Vs(i2, 0, 1) && (this.queryCoord2D(0 === i2 ? 1 : 0, r), mi.distance(r, t3) <= s4) ? (e5 && (e5[0] = 0, e5[1] = 1), 2) : (e5 && (e5[0] = i2), 1) : 0;
  }
  isIntersecting(t3, e5, s4) {
    return 0 !== rm(false, this, t3, e5, s4);
  }
  endPointModified() {
    this.m_bits |= 8, Mu(this);
  }
  clearEndPointModified() {
    Ru(this);
  }
};
function Fh(t3, e5, s4, n6) {
  const i2 = [];
  return Lh(e5, i2), Rh(t3, i2, e5, s4);
}
function Lh(t3, e5) {
  e5.length = t3;
  for (let s4 = 0; s4 < e5.length; ++s4) e5[s4] = s4;
  t3 > 3 && pe(t3, e5);
}
function Rh(t3, e5, s4, n6, i2) {
  let r = 0;
  const o = [0, 0, 0];
  let a2 = 0;
  const h2 = 3;
  let u = 0;
  for (let m3 = 0; m3 < h2; ++m3) {
    let i3 = false;
    for (; u < s4; ) {
      const s5 = t3.at(e5[u]);
      let l2 = 1;
      if (3 === r ? l2 = mi.inCircleRobust(t3.at(n6[0]), t3.at(n6[1]), t3.at(n6[2]), s5) : 2 === r ? l2 = mi.inCircleRobust3Point(t3.at(n6[0]), t3.at(n6[1]), s5) : 1 === r && s5.equals(t3.at(n6[0])) && (l2 = 0), l2 <= 0) {
        if (l2 < 0 && m3 + 1 < h2) {
          e5[a2] = Pt(e5[u], e5[u] = e5[a2]);
          for (let t4 = 0; t4 < r; t4++) if (n6[t4] === e5[u]) {
            o[t4] = u;
            break;
          }
          a2++;
        }
        u++;
        continue;
      }
      i3 = true;
      let c = 0;
      for (let t4 = 0; t4 < r; t4++) o[t4] > u && (n6[c] = n6[t4], o[c] = o[t4], c++);
      r = c, n6[r] = e5[u], o[r] = u, r++, r < 3 ? u = a2 : (1 === mi.orientationRobust(t3.at(n6[0]), t3.at(n6[1]), t3.at(n6[2])) && (n6[2] = Pt(n6[0], n6[0] = n6[2]), o[2] = Pt(o[0], o[0] = o[2])), u++);
    }
    if (!i3) break;
    if (m3 + 1 < h2) {
      a2 = 0;
      let s5 = false;
      for (let t4 = 0; t4 < r; t4++) for (let e6 = t4 + 1; e6 < r; e6++) o[t4] > o[e6] && (o[e6] = Pt(o[t4], o[t4] = o[e6]), n6[e6] = Pt(n6[t4], n6[t4] = n6[e6]), s5 = true);
      for (let t4 = 0; t4 < r; t4++) e5[o[t4]] = Pt(e5[t4], e5[t4] = e5[o[t4]]), o[t4] = t4;
      s5 && 3 === r && 1 === mi.orientationRobust(t3.at(n6[0]), t3.at(n6[1]), t3.at(n6[2])) && (n6[2] = Pt(n6[0], n6[0] = n6[2]), o[2] = Pt(o[0], o[0] = o[2]));
    }
    u = r;
  }
  return r;
}
function zh(t3, e5, s4, n6, i2, r) {
  return new jh(0, 0, 0, null, false, ds()).densifyEx(t3, e5, s4, n6, false, r);
}
function kh(t3, e5, n6, r, o, h2, u, m3) {
  h2 && (h2.length = 0), u && (u.length = 0);
  const l2 = t3.getGeometryType();
  if (l2 === a.enumLine) return h2 && (h2.push(t3.getStartXY()), h2.push(mi.getNAN()), h2.push(mi.getNAN()), h2.push(t3.getEndXY())), u && (u.push(0), u.push(1)), 1;
  if (l2 === a.enumBezier) {
    if (!r) return h2 && (h2.push(t3.getStartXY()), h2.push(t3.getControlPoint1()), h2.push(t3.getControlPoint2()), h2.push(t3.getEndXY())), u && (u.push(0), u.push(1)), 1;
    const e6 = Yt(9, Number.NaN);
    let s4 = t3.getMonotonicPartParams(e6.length, e6);
    if (e6.length = s4, s4 = Zh(t3, n6, e6), 2 === s4 && o && (e6[1] = 0.5, e6.push(1), s4 = 3), u && u.splice(0, 0, ...e6.slice(0, s4)), h2) {
      const n7 = new fm();
      for (let i2 = 1; i2 < s4; i2++) {
        const s5 = e6[i2 - 1], r2 = e6[i2];
        t3.queryCut(s5, r2, n7, true);
        const o2 = n7.get();
        lo(o2), 1 === i2 && h2.push(o2.getStartXY()), h2.push(o2.getControlPoint1()), h2.push(o2.getControlPoint2()), h2.push(o2.getEndXY());
      }
    }
    return s4 - 1;
  }
  if (l2 === a.enumEllipticArc) {
    const i2 = t3;
    if (i2.isDegenerateToLine() || i2.isDegenerate(0)) return h2 && (h2.push(t3.getStartXY()), h2.push(mi.getNAN()), h2.push(mi.getNAN()), h2.push(t3.getEndXY())), u && (u.push(0), u.push(1)), 1;
    if (r && (o || !i2.isMonotoneQuickAndDirty())) {
      const a2 = Yt(6, Number.NaN);
      let m4 = i2.getMonotonicPartParams(a2.length, a2);
      a2.length = m4, m4 = Zh(t3, n6, a2), 2 === m4 && o && (a2[1] = 0.5, a2.push(1), m4 = 3);
      let l3 = 0;
      if (m4 > 2) {
        const t4 = new fm(), o2 = u || [];
        let c = 0;
        for (let g2 = 1; g2 < m4; g2++) {
          const d2 = a2[c], _ = a2[g2];
          if (i2.queryCut(d2, _, t4, true), t4.get().isDegenerate(0)) continue;
          const p3 = o2.length, f3 = Qh(1 === g2, t4.get(), e5, n6, r, h2, u);
          n2(f3 > 0), l3 += f3;
          const P5 = g2 === m4 - 1, y2 = a2[c], x4 = t4.get().getSweepAngle() / i2.getSweepAngle();
          for (let t5 = p3, e6 = o2.length; t5 < e6; t5++) if (o2[t5] = !P5 || t5 + 1 < e6 ? y2 + o2[t5] * x4 : 1, h2) {
            const e7 = 3 * t5, s4 = i2.getCoord2D(o2[t5]);
            if (h2[e7].setCoordsPoint2D(s4), e7 > 0) {
              co(h2.slice(e7 - 3));
            }
          }
          c = g2;
        }
        return l3;
      }
    }
    return Qh(true, i2, e5, n6, r, h2, u);
  }
  if (l2 === a.enumRationalBezier2) {
    const s4 = t3;
    if (r && (o || !s4.isMonotoneQuickAndDirty())) {
      const i2 = Yt(6, Number.NaN);
      let r2 = s4.getMonotonicPartParams(i2.length, i2);
      i2.length = r2, r2 = Zh(t3, n6, i2), 2 === r2 && o && (i2[1] = 0.5, i2.push(1), r2 = 3);
      let a2 = 0;
      if (r2 > 2) {
        const t4 = new fm(), o2 = u || [];
        for (let m4 = 1; m4 < r2; m4++) {
          const l3 = i2[m4 - 1], c = i2[m4];
          s4.queryCut(l3, c, t4, true);
          const g2 = o2.length;
          a2 += Kh(1 === m4, t4.get(), e5, n6, false, h2, u);
          const d2 = m4 === r2 - 1, _ = i2[m4 - 1];
          for (let t5 = g2, e6 = o2.length; t5 < e6; t5++) if (o2[t5] = !d2 || t5 + 1 < e6 ? _ + o2[t5] : 1, h2) {
            const e7 = 3 * t5, n7 = s4.getCoord2D(o2[t5]);
            if (h2[e7].setCoordsPoint2D(n7), e7 > 0) {
              Ai(h2.slice(e7 - 3));
            }
          }
        }
        return a2;
      }
    }
    return Kh(true, s4, e5, n6, r, h2, u);
  }
  if (l2 === a.enumBezier2) {
    const s4 = t3, i2 = Ot(mi, 3);
    s4.queryControlPoints(i2);
    const a2 = new ia();
    a2.constructFromQuadratic(i2);
    const m4 = kh(a2, e5, n6, r, o, h2, u);
    if (null != h2 && null != u) {
      const t4 = 3;
      for (let e6 = 1, n7 = 0; e6 < m4; ++e6, n7 += t4) {
        const i3 = new mi();
        s4.queryCoord2D(u[e6], i3);
        const o2 = h2[n7 + t4];
        if (!i3.equals(o2) && (h2[n7 + t4].setCoordsPoint2D(i3), r)) {
          co(h2.slice(n7, n7 + 4));
        }
      }
    }
    return m4;
  }
  z("");
}
function Wh(t3, e5, n6, r, o, a2, h2, u, m3) {
  const l2 = t3.getGeometryType();
  if (a2 && (a2.length = 0, h2.length = 0), u && (u.length = 0), l2 === a.enumEllipticArc) {
    const e6 = t3;
    if (e6.isDegenerateToLine() || e6.isDegenerate(0)) return a2 && (a2.push(t3.getStartXY()), a2.push(mi.getNAN()), a2.push(t3.getEndXY()), h2.push(Number.NaN), h2.push(Number.NaN), h2.push(Number.NaN)), u && (u.push(0), u.push(1)), 1;
  }
  const c = Yt(9, Number.NaN);
  let g2;
  if (o) g2 = t3.getMonotonicPartParams(c.length, c), c.length = g2, g2 = Zh(t3, n6, c);
  else {
    if (g2 = 2, c[0] = 0, c[1] = 1, l2 === Xh.type) {
      const e6 = t3.getSweepAngle();
      if (e6 > 0.9 * Math.PI) {
        const t4 = 2 * Math.PI / 3;
        Math.min(3, Math.trunc(e6 / t4 + 0.5)) > 2 ? (c[0] = 0, c[1] = 1 / 3, c[2] = 2 / 3, c[3] = 1, g2 = 4) : (c[0] = 0, c[1] = 0.5, c[2] = 1, g2 = 3);
      }
    } else n2(l2 === En.type);
    c.length = g2;
  }
  if (2 === g2 && r && (c[1] = 0.5, c.push(1), g2 = 3), a2) {
    const e6 = new fm();
    let s4 = 1;
    for (; s4 < g2; ) {
      const n7 = c[s4 - 1], r2 = c[s4];
      t3.queryCut(n7, r2, e6, true);
      const u2 = Ot(mi, 3), m4 = [1, 1, 1];
      if (l2 === a.enumEllipticArc) {
        const t4 = e6.get();
        if (Math.abs(t4.getSweepAngle()) > 0.9 * Math.PI) {
          const t5 = (r2 - n7) / 3;
          c.splice(s4, 0, n7 + t5), c.splice(s4 + 1, 0, n7 + 2 * t5), g2 += 2;
          continue;
        }
        m4[1] = Bu(t4, u2);
      } else {
        const t4 = e6.get();
        t4.queryControlPoints(u2), t4.queryWeights(m4);
      }
      o && Ha(u2), 1 === s4 && (a2.push(u2[0].clone()), h2.push(m4[0])), a2.push(u2[1].clone()), a2.push(u2[2].clone()), h2.push(m4[1]), h2.push(m4[2]), s4++;
    }
  }
  return u && (u.length = g2, Dt(u, c, 0, 0, g2)), g2 - 1;
}
Xh.type = a.enumEllipticArc;
var jh = class _jh {
  static constructDefault(t3) {
    return new _jh(0, 0, 0, t3, false, ds());
  }
  constructor(t3, e5, s4, n6, i2, r) {
    this.m_segmentBuffer = null, this.m_dummyPoint = new ee(), this.m_progressCounter = 0, this.m_progressTracker = n6, this.m_bSetDensifyFlag = i2, this.m_maxLength = t3, this.m_maxDeviation = e5, this.m_maxAngle = s4 > Js() ? Js() : s4, this.m_cosMaxAngle = Math.cos(this.m_maxAngle), this.m_bOnlyCurveDensify = this.m_maxAngle > 0 || this.m_maxDeviation > 0, this.m_maxSegmentsPerCurve = r, D(this.m_maxSegmentsPerCurve > 0, "this.m_maxSegmentsPerCurve > 0"), this.m_minStep = 1 / this.m_maxSegmentsPerCurve;
  }
  densify(t3) {
    return this.densifyGeom(t3);
  }
  densifySegment(t3, e5) {
    this.densifySegmentEx(t3, null, true, false, e5);
  }
  densifyEx(t3, e5, s4, n6, i2, r) {
    return this.m_maxLength = e5, this.m_maxDeviation = s4, this.m_maxAngle = n6 > Js() ? Js() : n6, this.m_cosMaxAngle = Math.cos(this.m_maxAngle), this.m_bOnlyCurveDensify = this.m_maxAngle > 0 || this.m_maxDeviation > 0, this.m_bSetDensifyFlag = i2, this.m_maxSegmentsPerCurve = r, D(this.m_maxSegmentsPerCurve > 0, "this.m_maxSegmentsPerCurve > 0"), this.m_minStep = 1 / this.m_maxSegmentsPerCurve, this.densifyGeom(t3);
  }
  densifyGeom(t3) {
    if (t3.isEmpty() || t3.getDimension() < 1) return t3;
    const e5 = t3.getGeometryType();
    return g(e5) ? t3 : h(e5) ? this.densifyMultiPath(t3) : f(e5) ? this.densifySegmentImpl(t3) : e5 === a.enumEnvelope ? this.densifyEnvelope(t3) : void b("");
  }
  densifySegmentEx(t3, e5, s4, n6, r) {
    const o = t3.getGeometryType();
    if (!(this.m_maxLength > 0 || this.m_bOnlyCurveDensify && o !== a.enumLine) && (!n6 || s4)) return void (e5 ? o === a.enumLine ? e5.addSegment(t3, s4) : (s4 && (t3.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)), t3.queryEnd(this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint)) : (s4 && r.push(0), r.push(1)));
    if (o === a.enumBezier) return void this.densifyCubicBezier(t3, e5, s4, n6, r);
    if (o === a.enumRationalBezier2) return void this.densifyRationalBezier2(t3, e5, s4, n6, r);
    if (o === a.enumBezier2) return void this.densifyBezier2(t3, e5, s4, n6, r);
    if (o === a.enumEllipticArc && !t3.isLine() && t3.getMinorMajorRatio() < 0.25) return void this.densifyEllipticArc(t3, e5, s4, n6, r);
    let a2 = 1;
    this.m_maxLength > 0 && (a2 = this.calculateLengthSubdivisionStep(t3, this.m_maxLength)), this.m_maxDeviation > 0 && (a2 = Math.min(a2, this.calculateDeviationSubdivisionStep(t3, this.m_maxDeviation))), this.m_maxAngle > 0 && (a2 = Math.min(a2, this.calculateAngularSubdivisionStep(t3, this.m_maxAngle))), this.densifySegmentByLength(t3, a2, e5, s4, n6, r);
  }
  densifyMultiPath(t3) {
    if (!t3.hasNonLinearSegments()) {
      if (1 === t3.getDescription().getAttributeCount()) return this.densifyMultiPathLinear(t3);
      if (!(this.m_maxLength > 0)) return t3;
    }
    const e5 = t3.createInstance();
    if (e5.getGeometryType() === a.enumPolygon) {
      e5.setFillRule(t3.getFillRule());
    }
    e5.reserve(t3.getPointCount());
    const s4 = t3.getImpl().querySegmentIterator();
    for (; s4.nextPath(); ) {
      let t4 = true;
      for (; s4.hasNextSegment(); ) {
        const n6 = s4.nextSegment(), i2 = s4.isClosingSegment();
        this.densifySegmentEx(n6, e5, t4, i2, null), i2 && e5.closePathWithLine(), t4 = false;
      }
    }
    return e5;
  }
  densifySegmentImpl(t3) {
    const e5 = new Os2({ vd: t3.getDescription() }), s4 = [0];
    return this.densifySegmentEx(t3, e5, true, false, s4), e5;
  }
  densifyEnvelope(t3) {
    const e5 = new ur({ vd: t3.getDescription() });
    e5.addEnvelope(t3, false);
    const s4 = n4.constructEmpty();
    t3.queryEnvelope(s4);
    const n6 = s4.width(), i2 = s4.height();
    return !(this.m_maxLength > 0) || n6 <= this.m_maxLength && i2 <= this.m_maxLength ? e5 : this.densifyMultiPath(e5);
  }
  densifyMultiPathLinear(t3) {
    if (!(this.m_maxLength > 0)) return t3;
    const e5 = t3.createInstance();
    if (e5.getGeometryType() === a.enumPolygon) {
      e5.setFillRule(t3.getFillRule());
    }
    e5.reserve(t3.getPointCount());
    const s4 = e5.getImpl(), n6 = t3.getImpl(), r = n6.getAttributeStreamRef(0), o = new pm();
    for (let i2 = 0, a2 = n6.getPathCount(); i2 < a2; i2++) {
      const t4 = n6.isClosedPath(i2);
      if (0 === n6.getPathSize(i2)) continue;
      const a3 = n6.getPathStart(i2), h2 = r.readPoint2D(2 * a3), u = h2.clone();
      s4.startPath(h2);
      for (let m3 = a3 + 1, l2 = n6.getPathEnd(i2); m3 < l2; m3++) {
        const t5 = r.readPoint2D(2 * m3), n7 = mi.distance(u, t5);
        if (n7 > this.m_maxLength) {
          let e6 = Math.ceil(n7 / this.m_maxLength);
          e6 > ds() && (e6 = ds());
          const i3 = 1 / e6;
          let r2, a4, h3;
          u.compare(t5) < 0 ? (o.setStartXY(u), o.setEndXY(t5), r2 = 0, a4 = 1) : (o.setStartXY(t5), o.setEndXY(u), r2 = e6 - 2, a4 = -1);
          for (let t6 = 0, n8 = e6 - 1; t6 < n8; t6++, r2 += a4) {
            this.progress_(), h3 = i3 * (r2 + 1);
            const t7 = new mi();
            o.queryCoord2D(h3, t7), s4.lineTo(t7), this.m_bSetDensifyFlag && s4.setAttributeNoCurves(10, s4.getPointCount() - 1, 0, 1);
          }
        } else this.progress_();
        e5.lineTo(t5), u.assign(t5);
      }
      if (t4) {
        const t5 = mi.distance(u, h2);
        if (t5 > this.m_maxLength) {
          const e6 = h2;
          let n7 = Math.ceil(t5 / this.m_maxLength);
          n7 > ds() && (n7 = ds());
          const i3 = 1 / n7;
          let r2, a4;
          u.compare(e6) < 0 ? (o.setStartXY(u), o.setEndXY(e6), r2 = 0, a4 = 1) : (o.setStartXY(e6), o.setEndXY(u), r2 = n7 - 2, a4 = -1);
          const m3 = new mi(0, 0);
          let l2;
          for (let t6 = 0, h3 = n7 - 1; t6 < h3; t6++, r2 += a4) this.progress_(), l2 = i3 * (r2 + 1), o.queryCoord2D(l2, m3), s4.lineTo(m3), this.m_bSetDensifyFlag && s4.setAttributeNoCurves(10, s4.getPointCount() - 1, 0, 1);
        }
        s4.closePathWithLine();
      }
    }
    return e5;
  }
  densifySegmentByLength(t3, e5, n6, r, o, h2) {
    n2(t3.getGeometryType() !== a.enumBezier);
    let u = t3.getStartXY().compare(t3.getEndXY());
    if (0 === u && e5 < 1) {
      t3.getGeometryType() === a.enumEllipticArc ? u = t3.getSweepAngle() < 0 ? 1 : -1 : z("densify segment by length");
    }
    let m3 = 0;
    if (r && (n6 ? (t3.queryStart(this.m_dummyPoint), n6.startPathPoint(this.m_dummyPoint)) : h2.push(0), ++m3), e5 * this.m_maxSegmentsPerCurve < 1 && (e5 = 1 / this.m_maxSegmentsPerCurve), e5 < 1) {
      this.m_segmentBuffer || (this.m_segmentBuffer = new fm());
      let s4 = Math.ceil(1 / e5);
      s4 > ds() && (s4 = ds()), e5 = 1 / s4, this.m_segmentBuffer.create(t3.getGeometryType());
      let i2, r2, o2, a2 = t3;
      u < 0 ? (i2 = 0, r2 = 1) : (t3.copyTo(this.m_segmentBuffer.get()), this.m_segmentBuffer.get().reverse(), i2 = s4 - 2, r2 = -1, a2 = this.m_segmentBuffer.get());
      const l2 = s4 - 1;
      for (let t4 = 0; t4 < l2; t4++, i2 += r2) o2 = e5 * (i2 + 1), n6 ? (a2.queryCoord(o2, this.m_dummyPoint), n6.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== o2 && 0 !== o2 && n6.setAttribute(10, n6.getPointCount() - 1, 0, 1)) : h2.push(u > 0 ? 1 - o2 : o2), this.progress_();
      o2 = 1, m3 += l2;
    }
    (!o || o && r && m3 < 2) && (n6 ? (t3.queryEnd(this.m_dummyPoint), n6.lineToPoint(this.m_dummyPoint)) : h2.push(1));
  }
  densifyCubicBezier(t3, e5, s4, n6, i2) {
    const r = new ia();
    let o = t3;
    const a2 = t3.calculateUpperLength2D();
    let h2 = t3.getStartXY().compare(t3.getEndXY());
    if (0 === h2 && a2 > 0) {
      const e6 = Ot(mi, 4);
      t3.queryControlPoints(e6), h2 = e6[1].compare(e6[2]), 0 === h2 && (h2 = e6[1].compare(e6[0]));
    }
    h2 > 0 && (t3.copyTo(r), r.reverse(), o = r);
    let u = 0;
    s4 && (e5 ? (t3.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++u);
    const m3 = [], l2 = [], c = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));
    let g2 = true, d2 = 0;
    if (h2 > 0) for (m3.push([o.getStartXY(), o.getControlPoint1(), o.getControlPoint2(), o.getEndXY(), new mi(0, 1)]), l2.push(0); m3.length; ) {
      this.progress_();
      const t4 = m3.at(-1), r2 = l2.at(-1), a3 = t4[4].x, h3 = t4[4].y;
      if (r2 < c && this.bezierNeedsSplit(t4)) {
        g2 && (d2 = o.findMinDeriv(), g2 = false);
        let e6 = 0.5 * (a3 + h3);
        Math.abs(d2 - e6) < 0.4 * (h3 - a3) && (e6 = d2);
        const s5 = (e6 - a3) / (h3 - a3), n7 = t4[0].mul(1 - s5).add(t4[1].mul(s5)), i3 = t4[1].mul(1 - s5).add(t4[2].mul(s5)), u2 = t4[2].mul(1 - s5).add(t4[3].mul(s5)), c2 = n7.mul(1 - s5).add(i3.mul(s5)), _ = i3.mul(1 - s5).add(u2.mul(s5)), p3 = c2.mul(1 - s5).add(_.mul(s5)), f3 = t4[3];
        t4[1] = n7, t4[2] = c2, t4[3] = p3, t4[4].setCoords(a3, e6);
        const P5 = [p3, _, u2, f3, new mi(e6, h3)];
        m3.push(P5), l2[l2.length - 1] = r2 + 1, l2.push(r2 + 1);
      } else m3.pop(), l2.pop(), (m3.length > 0 || !n6 || n6 && s4 && u < 2) && (e5 ? (o.queryCoord(a3, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== a3 && 0 !== a3 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(1 - a3), ++u);
    }
    else for (m3.push([o.getStartXY(), o.getControlPoint1(), o.getControlPoint2(), o.getEndXY(), new mi(0, 1)]), l2.push(0); m3.length; ) {
      this.progress_();
      const t4 = m3.at(-1), r2 = l2.at(-1), a3 = t4[4].x, h3 = t4[4].y;
      if (r2 < c && this.bezierNeedsSplit(t4)) {
        g2 && (d2 = o.findMinDeriv(), g2 = false);
        let e6 = 0.5 * (a3 + h3);
        Math.abs(d2 - e6) < 0.4 * (h3 - a3) && (e6 = d2);
        const s5 = (e6 - a3) / (h3 - a3), n7 = t4[0].mul(1 - s5).add(t4[1].mul(s5)), i3 = t4[1].mul(1 - s5).add(t4[2].mul(s5)), u2 = t4[2].mul(1 - s5).add(t4[3].mul(s5)), c2 = n7.mul(1 - s5).add(i3.mul(s5)), _ = i3.mul(1 - s5).add(u2.mul(s5)), p3 = c2.mul(1 - s5).add(_.mul(s5)), f3 = t4[0];
        t4[0] = p3, t4[1] = _, t4[2] = u2, t4[4].setCoords(e6, h3);
        const P5 = [f3, n7, c2, p3, new mi(a3, e6)];
        m3.push(P5), l2[l2.length - 1] = r2 + 1, l2.push(r2 + 1);
      } else m3.pop(), l2.pop(), (m3.length > 0 || !n6 || n6 && s4 && u < 2) && (e5 ? (o.queryCoord(h3, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== h3 && 0 !== h3 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(h3), ++u);
    }
  }
  densifyRationalBezier2(t3, e5, s4, n6, i2) {
    const r = new En();
    let o = t3;
    const a2 = t3.calculateUpperLength2D();
    let h2 = t3.getStartXY().compare(t3.getEndXY());
    0 === h2 && a2 > 0 && (h2 = 0), h2 > 0 && (t3.copyTo(r), r.reverse(), o = r);
    let u = 0;
    s4 && (e5 ? (t3.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++u);
    const m3 = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new En(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t4 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < m3 && this.rationalBezier2NeedsSplit(o, l2, t4.vmin, t4.vmax)) {
        const e6 = t4.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e6, c.push(new x2(e6, t4.vmax))) : (c.at(-1).vmin = e6, c.push(new x2(t4.vmin, e6))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
      } else if (c.pop(), g2.pop(), c.length > 0 || !n6 || n6 && s4 && u < 2) {
        const s5 = h2 > 0 ? t4.vmin : t4.vmax;
        e5 ? (o.queryCoord(s5, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s5 && 0 !== s5 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s5 : s5), ++u;
      }
    }
  }
  densifyBezier2(t3, e5, s4, n6, i2) {
    const r = new wn();
    let o = t3;
    const a2 = t3.calculateUpperLength2D();
    let h2 = t3.getStartXY().compare(t3.getEndXY());
    0 === h2 && a2 > 0 && (h2 = 0), h2 > 0 && (t3.copyTo(r), r.reverse(), o = r);
    let u = 0;
    s4 && (e5 ? (t3.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++u);
    const m3 = Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new wn(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t4 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < m3 && this.bezier2NeedsSplit(o, l2, t4.vmin, t4.vmax)) {
        const e6 = t4.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e6, c.push(new x2(e6, t4.vmax))) : (c.at(-1).vmin = e6, c.push(new x2(t4.vmin, e6))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
      } else if (c.pop(), g2.pop(), c.length > 0 || !n6 || n6 && s4 && u < 2) {
        const s5 = h2 > 0 ? t4.vmin : t4.vmax;
        e5 ? (o.queryCoord(s5, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s5 && 0 !== s5 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s5 : s5), ++u;
      }
    }
  }
  densifyEllipticArc(t3, e5, s4, n6, i2) {
    const r = new Xh();
    let o = t3;
    const a2 = t3.calculateUpperLength2D();
    let h2 = t3.getStartXY().compare(t3.getEndXY());
    0 === h2 && a2 > 0 && (h2 = t3.isClockwise() ? 0 : 1), h2 > 0 && (t3.copyTo(r), r.reverse(), o = r);
    let u = 0;
    s4 && (e5 ? (t3.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++u);
    const m3 = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new Xh(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t4 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < m3 && this.ellipticArcNeedsSplit(o, l2, t4.vmin, t4.vmax)) {
        const e6 = t4.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e6, c.push(new x2(e6, t4.vmax))) : (c.at(-1).vmin = e6, c.push(new x2(t4.vmin, e6))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
      } else if (c.pop(), g2.pop(), c.length > 0 || !n6 || n6 && s4 && u < 2) {
        const s5 = h2 > 0 ? t4.vmin : t4.vmax;
        e5 ? (o.queryCoord(s5, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s5 && 0 !== s5 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s5 : s5), ++u;
      }
    }
  }
  calculateLengthSubdivisionStep(t3, e5) {
    const s4 = t3.calculateUpperLength2D();
    if (!t3.isCurve()) return s4 ? e5 / s4 : 1;
    if (t3.getGeometryType() === a.enumEllipticArc) {
      const n6 = t3;
      if (n6.isCircular() || n6.isDegenerate(0) || n6.isDegenerateToLine()) {
        let t4 = e5 / s4;
        return t4 < this.m_minStep && (t4 = this.m_minStep), t4;
      }
      return e5 / s4 * n6.getSemiAxes().y / n6.getSemiAxes().x;
    }
    t3.getGeometryType() === a.enumBezier && z(""), z("");
  }
  calculateDeviationSubdivisionStep(t3, e5) {
    if (!t3.isCurve()) return 1;
    if (t3.getGeometryType() === a.enumEllipticArc) {
      const s4 = t3;
      if (s4.isDegenerate(0) || s4.isDegenerateToLine()) return 1;
      {
        const n6 = s4.getSemiMajorAxis(), i2 = 1 - e5 / n6;
        let r = Math.PI / 2;
        if (i2 > 0) {
          const t4 = 4 * Math.sqrt(e5 / n6 * 0.5);
          r = Math.min(Math.PI / 2, Math.abs(t4));
        }
        r = Math.max(r, 2 * Math.PI / this.m_maxSegmentsPerCurve);
        const o = r * n6;
        return this.calculateLengthSubdivisionStep(t3, o);
      }
    }
    z("");
  }
  calculateAngularSubdivisionStep(t3, e5) {
    if (!t3.isCurve()) return 1;
    if (t3.getGeometryType() === a.enumEllipticArc) {
      const s4 = t3;
      return s4.isDegenerate(0) || s4.isDegenerateToLine() ? 1 : this.calculateLengthSubdivisionStep(t3, e5 * s4.getSemiMinorAxis());
    }
    z("");
  }
  rationalBezier2NeedsSplit(t3, e5, s4, n6) {
    t3.cutBezierIgnoreAttributes(s4, n6, e5);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e5.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    const r = Ot(mi, 3);
    e5.queryControlPoints(r);
    const o = [0, 0, 0];
    return e5.queryWeights(o), !i2 && this.m_maxDeviation > 0 && (i2 = !_jh.checkRationalBezier2MaxDeviation(r, o, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_jh.checkRationalBezier2MaxAngle(r, o, this.m_cosMaxAngle)), i2;
  }
  bezier2NeedsSplit(t3, e5, s4, n6) {
    t3.cutBezierIgnoreAttributes(s4, n6, e5);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e5.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    const r = Ot(mi, 3);
    return e5.queryControlPoints(r), !i2 && this.m_maxDeviation > 0 && (i2 = !_jh.checkBezier2MaxDeviation(r, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_jh.checkBezier2MaxAngle(r, this.m_cosMaxAngle)), i2;
  }
  ellipticArcNeedsSplit(t3, e5, s4, n6) {
    t3.cutArcIgnoreAttributes(s4, n6, e5);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e5.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    return !i2 && this.m_maxDeviation > 0 && (i2 = !_jh.checkEllipticArcMaxDeviation(e5, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_jh.checkEllipticArcMaxAngle(e5, this.m_cosMaxAngle)), i2;
  }
  bezierNeedsSplit(t3) {
    let e5 = false;
    if (this.m_maxLength > 0) {
      if (mi.distance(t3[0], t3[1]) + mi.distance(t3[1], t3[2]) + mi.distance(t3[2], t3[3]) > this.m_maxLength) return e5 = true, true;
    }
    return !e5 && this.m_maxDeviation > 0 && (e5 = !_jh.checkBezierMaxDeviation(t3, this.m_maxDeviation)), !e5 && this.m_maxAngle > 0 && (e5 = !_jh.checkBezierMaxAngle(t3, this.m_cosMaxAngle)), e5;
  }
  progress_() {
  }
  static checkBezierMaxDeviation(t3, e5) {
    const s4 = t3[3].sub(t3[0]);
    if (s4.sqrLength() > 0) {
      const n6 = s4.clone();
      n6.leftPerpendicularThis(), n6.normalize();
      const i2 = n6.dotProduct(t3[0].sub(t3[1])), r = n6.dotProduct(t3[0].sub(t3[2]));
      if (Math.max(Math.abs(i2), Math.abs(r)) <= e5) {
        const e6 = new mi();
        Po(t3, 0.5, e6, false);
        const n7 = e6.sub(t3[0]).dotProduct(s4);
        return n7 >= 0 && n7 <= s4.sqrLength();
      }
      return false;
    }
    return Math.max(t3[0].sub(t3[1]).sqrLength(), t3[0].sub(t3[2]).sqrLength()) <= e5 * e5;
  }
  static checkBezierMaxAngle(t3, e5) {
    if (t3[0].equals(t3[3])) return !(!t3[0].equals(t3[1]) || !t3[1].equals(t3[2]));
    const s4 = t3[3].sub(t3[0]);
    s4.normalize();
    {
      const n6 = t3[1].sub(t3[0]), i2 = n6.dotProduct(s4);
      if (i2 < 0) return false;
      if (n6.length() * e5 > i2) return false;
    }
    {
      const n6 = t3[2].sub(t3[0]), i2 = n6.dotProduct(s4);
      if (i2 < 0) return false;
      if (n6.length() * e5 > i2) return false;
    }
    {
      const n6 = t3[2].sub(t3[1]), i2 = n6.dotProduct(s4);
      if (i2 < 0) return false;
      if (n6.length() * e5 > i2) return false;
    }
    return true;
  }
  static checkRationalBezier2MaxDeviation(t3, e5, s4) {
    if (0 === e5[1]) return false;
    const n6 = t3[2].sub(t3[0]);
    if (n6.sqrLength() > 0) {
      const e6 = n6.clone();
      e6.leftPerpendicularThis(), e6.normalize();
      const i2 = e6.dotProduct(t3[0].sub(t3[1]));
      if (Math.abs(i2) <= s4) {
        const e7 = t3[1].sub(t3[0]).dotProduct(n6);
        return e7 >= 0 && e7 <= n6.sqrLength();
      }
      return false;
    }
    return t3[0].sub(t3[1]).sqrLength() <= s4 * s4;
  }
  static checkRationalBezier2MaxAngle(t3, e5, s4) {
    if (0 === e5[1]) return false;
    if (t3[0].equals(t3[2])) return !!t3[0].equals(t3[1]);
    const n6 = t3[2].sub(t3[0]);
    n6.normalize();
    {
      const e6 = t3[1].sub(t3[0]), i2 = e6.dotProduct(n6);
      if (i2 < 0) return false;
      if (e6.length() * s4 > i2) return false;
    }
    return true;
  }
  static checkBezier2MaxDeviation(t3, e5) {
    const s4 = t3[2].sub(t3[0]);
    if (s4.sqrLength() > 0) {
      const n6 = s4.clone();
      n6.leftPerpendicularThis(), n6.normalize();
      const i2 = n6.dotProduct(t3[0].sub(t3[1]));
      if (Math.abs(i2) <= e5) {
        const e6 = t3[1].sub(t3[0]).dotProduct(s4);
        return e6 >= 0 && e6 <= s4.sqrLength();
      }
      return false;
    }
    return t3[0].sub(t3[1]).sqrLength() <= e5 * e5;
  }
  static checkBezier2MaxAngle(t3, e5) {
    if (t3[0].equals(t3[2])) return !!t3[0].equals(t3[1]);
    const s4 = t3[2].sub(t3[0]);
    s4.normalize();
    {
      const n6 = t3[1].sub(t3[0]), i2 = n6.dotProduct(s4);
      if (i2 < 0) return false;
      if (n6.length() * e5 > i2) return false;
    }
    return true;
  }
  static checkEllipticArcMaxDeviation(t3, e5) {
    if (Math.abs(t3.getSweepAngle()) < Math.PI) {
      const s5 = t3.getEndXY().sub(t3.getStartXY()), n7 = [0, 0];
      if (1 === tm(t3, s5, n7)) {
        const s6 = t3.getCoord2D(n7[0]), i2 = mi.getClosestCoordinate(t3.getStartXY(), t3.getEndXY(), s6), r = new mi();
        Y(t3.getStartXY(), t3.getEndXY(), i2, r);
        return mi.distance(s6, r) <= e5;
      }
    }
    const s4 = t3.getCoord2D(0.5), n6 = new mi();
    Y(t3.getEndXY(), t3.getStartXY(), 0.5, n6);
    return mi.distance(s4, n6) <= e5;
  }
  static checkEllipticArcMaxAngle(t3, e5) {
    const s4 = t3.getTangent(0), n6 = t3.getTangent(1), i2 = s4.dotProduct(n6);
    return !(i2 < 0) && !(s4.length() * n6.length() * e5 > i2);
  }
  static checkTypeForReplace(t3, e5) {
    return t3.getGeometryType() === e5 && (e5 !== a.enumEllipticArc || t3.isCircular());
  }
};
function Zh(t3, e5, s4) {
  const n6 = s4.length;
  if (e5 <= 0 || n6 <= 2) return n6;
  let i2 = 0;
  const r = Yt(n6 - 1, Number.NaN);
  for (let o = 1, a2 = n6; o < a2; o++) {
    const e6 = t3.tToLength(s4[o]);
    r[o - 1] = e6 - i2, i2 = e6;
  }
  for (; r.length > 1; ) {
    const t4 = r.findIndex((t5) => t5 <= 2 * e5);
    if (-1 === t4) break;
    let n7 = t4 + 1, i3 = t4 + 1;
    if (t4 > 0) {
      const e6 = t4 - 1;
      (i3 === r.length || r[e6] > r[i3]) && (i3 = e6, n7--);
    }
    r[i3] += r[t4], r.splice(t4, 1), s4.splice(n7, 1);
  }
  return s4.length;
}
function Qh(t3, e5, s4, n6, i2, r, o, a2) {
  const h2 = e5.clone();
  h2.dropAllAttributes();
  const u = (t4, e6, s5, n7) => (e6 && (t4 && e6.push(n7.getStartXY()), e6.push(mi.getNAN()), e6.push(mi.getNAN()), e6.push(n7.getEndXY())), s5 && (t4 && s5.push(0), s5.push(1)), 1);
  if (h2.isDegenerateToLine() || h2.isDegenerate(0)) return u(t3, r, o, e5);
  const m3 = h2.getStartXY(), l2 = h2.getEndXY(), c = h2.getSemiAxes(), g2 = new x3();
  if (h2.isCircular()) g2.setIdentity();
  else {
    const t4 = h2.getAxisXRotation();
    g2.setScaleCoords(1, h2.getMinorMajorRatio()), g2.rotateAngle(t4);
  }
  const d2 = h2.getCenter();
  g2.shift(d2);
  const _ = g2.clone();
  _.invertThis(), h2.applyTransformation(_);
  const p3 = h2.getSweepAngle();
  if (0 === p3) return u(t3, r, o, e5);
  const f3 = n4.constructEmpty();
  f3.setCoords({ center: d2, width: 2 * c.x, height: 2 * c.x });
  const P5 = 0.05 * f3.calculateToleranceFromEnvelope(), y2 = Math.max(s4 / c.x, P5 / c.x);
  let x4 = 4 * Math.pow(y2 / 0.0741, 1 / 6);
  x4 = Math.min(x4, Math.PI / 2);
  const C3 = Ih(h2.getStartAngle());
  let v3 = p3 > 0 ? Math.floor(C3 / x4) : Math.ceil(C3 / x4);
  v3 *= x4;
  const b2 = p3 > 0 ? x4 : -x4;
  v3 + b2 === C3 && (v3 += b2);
  let S3 = 4 / 3 * Math.tan(Math.abs(x4) / 4);
  p3 > 0 && (S3 = -S3), o && t3 && o.push(0);
  const E2 = x4 / Math.abs(p3);
  let D3 = (v3 - C3) / p3;
  const w4 = m3.clone(), A4 = new mi();
  h2.queryCoord2D(0, A4);
  const T3 = A4.clone(), I4 = 1 - 0.01 * E2;
  let M2 = 0, Y3 = 0;
  for (; D3 < 1; ) {
    let s5;
    if (D3 += E2, Y3 > 0 && D3 < I4) s5 = S3;
    else {
      D3 >= I4 && (D3 = 1);
      const t4 = (D3 - Y3) * p3;
      s5 = 4 / 3 * Math.tan(Math.abs(t4) / 4), p3 > 0 && (s5 = -s5);
    }
    h2.queryCoord2D(D3, A4);
    const a3 = new mi();
    g2.queryTransform(A4, a3);
    const u2 = e5.getClosestCoordinate(a3, false);
    if (e5.queryCoord2D(u2, a3), 1 !== D3 && (mi.distance(w4, a3) <= 2 * n6 || mi.distance(a3, l2) <= 2 * n6)) continue;
    w4.setCoordsPoint2D(a3);
    const c2 = Ot(mi, 4);
    c2[0].assign(T3), c2[3].assign(A4), c2[1].rightPerpendicularOther(T3), c2[1].scaleAddThis(s5, T3), c2[2].leftPerpendicularOther(A4), c2[2].scaleAddThis(s5, A4), g2.transformPoints2D(c2, 3, c2), c2[3].assign(a3), 0 === Y3 && c2[0].setCoordsPoint2D(m3), 1 === D3 && c2[3].setCoordsPoint2D(l2), i2 && co(c2);
    let d3 = true;
    for (let t4 = 1; t4 < 4; t4++) if (!c2[t4].isEqualPoint2D(c2[0])) {
      d3 = false;
      break;
    }
    d3 || (o && o.push(u2), r && (0 === Y3 && t3 && r.push(c2[0].clone()), r.push(c2[1].clone()), r.push(c2[2].clone()), r.push(c2[3].clone())), M2++), Y3 = D3, T3.setCoordsPoint2D(A4);
  }
  return M2;
}
function Kh(t3, e5, s4, n6, i2, r, o, a2) {
  e5.clone().dropAllAttributes();
  const h2 = new n4();
  e5.queryLooseEnvelope(h2);
  const u = 0.05 * h2.calculateToleranceFromEnvelope(), m3 = Math.max(s4, u);
  o && t3 && o.push(0);
  let l2 = 0;
  const c = Ot(mi, 3);
  e5.queryControlPoints(c);
  const g2 = [0, 0, 0];
  e5.queryWeights(g2);
  const d2 = [], _ = Yt(9, Number.NaN);
  let p3 = 0;
  i2 ? (p3 = e5.getMonotonicPartParams(_.length, _), _.length = p3, p3 = Zh(e5, n6, _)) : (_.length = 2, p3 = 2, _[0] = 0, _[1] = 1);
  let f3 = 0, P5 = t3;
  for (let y2 = 1; y2 < p3; y2++) {
    const t4 = _[y2];
    for (d2.length = 0, d2.push(t4), d2.push(f3); d2.length > 1; ) {
      const t5 = d2.at(-1);
      d2.pop();
      const e6 = d2.at(-1), s5 = Ot(mi, 3), n7 = [0, 0, 0];
      Qa(c, g2, t5, e6, s5, n7);
      const i3 = Ot(mi, 4), a3 = Ja(s5, n7, i3), h3 = 16, u2 = d2.length > h3;
      m3 >= a3 || u2 ? (o.push(e6), r && (P5 && (r.push(i3[0]), P5 = false), r.push(i3[1]), r.push(i3[2]), r.push(i3[3])), l2++) : (d2.push(0.5 * (t5 + e6)), d2.push(t5));
    }
    f3 = t4;
  }
  return l2;
}
function eu() {
  return { e2: 0, completeE: 0 };
}
var su = class {
  constructor(t3, e5) {
    this.m_arc = t3, this.m_sqrChordLength = e5;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t3, e5) {
    return 0 === t3 ? mi.sqrDistance(this.m_arc.getCoord2D(e5), this.m_arc.getCoord2D(1 - e5)) - this.m_sqrChordLength : 0;
  }
  getError(t3) {
    return 0;
  }
};
function nu(t3, e5, s4) {
  if (Su(t3)) {
    Cs(new pm({ start: t3.getStartXY(), end: t3.getEndXY() }), e5, s4);
  } else if (0 === e5.value()) s4.set(t3.getStartXY());
  else if (1 === e5.value()) s4.set(t3.getEndXY());
  else {
    const n6 = new p2();
    gu(t3, e5, n6);
    const i2 = new p2(), r = new p2();
    p2.st_cosAndSin(n6, i2, r);
    const o = Ye.constructCoordsE(new p2(t3.m_semiMajorAxis).mulThisE(i2), new p2(t3.m_semiMajorAxis).mulThis(t3.m_minorMajorRatio).mulThisE(r)), a2 = new p2(t3.m_rotation);
    p2.st_cosAndSin(a2, i2, r), o.rotateDirect(i2, r), o.addThisE(Ye.constructPoint2D(t3.m_center)), s4.setE(o);
  }
}
function iu(t3, e5) {
  return t3.convertToCanonic(e5);
}
function ru(t3, e5) {
  const s4 = new x2(t3.getStartAngle(), t3.getEndAngle());
  s4.normalize();
  const n6 = $s(), i2 = ct(e5, n6);
  if (i2 < s4.vmin) {
    let t4 = i2 + n6;
    for (; t4 < s4.vmin; ) t4 += n6;
    return s4.containsCoordinate(t4) ? t4 : s4.vmin - i2 < t4 - s4.vmax ? i2 : t4;
  }
  if (i2 > s4.vmax) {
    let t4 = i2 - n6;
    for (; t4 > s4.vmax; ) t4 -= n6;
    return s4.containsCoordinate(t4) || s4.vmin - t4 < i2 - s4.vmax ? t4 : i2;
  }
  return i2;
}
function ou(t3, e5, s4, n6) {
  let i2 = t3.m_startAngle, r = t3.m_sweepAngle;
  const o = 1e-12;
  for (; i2 > Hs(); ) i2 -= 2 * Hs();
  for (; i2 <= -Hs(); ) i2 += 2 * Hs();
  if (!Number.isNaN(e5)) {
    for (; e5 > Hs(); ) e5 -= 2 * Hs();
    for (; e5 <= -Hs(); ) e5 += 2 * Hs();
    !s4 && e5 > i2 && (e5 -= 2 * Hs()), s4 && e5 < i2 && (e5 += 2 * Hs()), r = e5 - i2, Math.abs(r) < o && !n6 && (r = s4 ? 2 * Hs() : -2 * Hs()), Math.abs(r) > 2 * Hs() - o && n6 && (r = 0);
  }
  Math.abs(r) > 2 * Hs() - o && (r = r >= 0 ? 2 * Hs() : -2 * Hs(), t3.setEndXY(t3.getStartXY())), Math.abs(r) < o && (r = 0, t3.setEndXY(t3.getStartXY())), n6 = Math.abs(r) <= Hs(), r && (s4 = r > 0), t3.m_startAngle = au(i2), t3.m_sweepAngle = r, qu(t3, !n6), Nu(t3, s4);
}
function au(t3) {
  let e5 = t3, s4 = false;
  return e5 <= -Hs() ? (e5 += $s(), s4 = true) : e5 > Hs() && (e5 -= $s(), s4 = true), e5 <= -Hs() ? (e5 = ct(e5, $s()), e5 <= -Hs() && (e5 += $s()), s4 = true) : e5 > Hs() && (e5 = ct(e5, $s()), e5 > Hs() && (e5 -= $s()), s4 = true), s4 && (e5 > Hs() || e5 <= -Hs()) && (e5 = Hs()), e5;
}
function hu(t3, e5, s4) {
  const n6 = s4, i2 = n6.getSemiAxes();
  let r = new mi(i2.x * Math.cos(t3[0]), i2.y * Math.sin(t3[0]));
  return r = n6.convertFromCanonic(r), mi.sqrDistance(r, n6.getStartXY());
}
function uu(t3, e5, s4) {
  const n6 = s4, i2 = n6.getSemiAxes(), r = t3[0] + n6.getStartAngle();
  let o = new mi(i2.x * Math.cos(r), i2.y * Math.sin(r));
  return o = n6.convertFromCanonic(o), mi.sqrDistance(o, n6.getEndXY());
}
function mu(t3) {
  if (t3.m_center.isNAN()) return t3.m_startAngle = 0, void (t3.m_sweepAngle = 0);
  const e5 = t3.getStartXY(), s4 = t3.getEndXY(), n6 = e5.equals(s4), i2 = Fu(t3), r = Xu(t3), o = t3.projectionBehavior();
  if (n6) {
    const s5 = t3.convertToCanonic(e5), n7 = new mi(t3.m_semiMajorAxis, t3.m_semiMajorAxis * t3.m_minorMajorRatio);
    s5.x /= n7.x, s5.y /= n7.y, t3.m_startAngle = au(Math.atan2(s5.y, s5.x)), t3.m_sweepAngle = i2 ? r ? $s() : -$s() : 0;
  } else {
    const n7 = t3.convertToCanonic(e5), a2 = new mi(t3.m_semiMajorAxis, t3.m_semiMajorAxis * t3.m_minorMajorRatio);
    n7.x /= a2.x, n7.y /= a2.y;
    const h2 = t3.convertToCanonic(s4);
    h2.x /= a2.x, h2.y /= a2.y, t3.m_startAngle = Math.atan2(n7.y, n7.x), t3.m_sweepAngle = mi.calculateAngle(n7, h2), r ? t3.m_sweepAngle < 0 && (t3.m_sweepAngle += $s()) : t3.m_sweepAngle > 0 && (t3.m_sweepAngle -= $s()), t3.m_startAngle = au(t3.m_startAngle);
    let u = hu([t3.m_startAngle], 1, t3);
    if (u = Math.sqrt(u), u > 0.25 * is(t3)) {
      const e6 = t3.m_startAngle - 1e-4, s5 = t3.m_startAngle + 1e-4, n8 = [0];
      rn(hu, t3, 1, [t3.m_startAngle], [e6], [s5], 1e-14, n8), t3.m_startAngle = au(n8[0]);
    }
    if (u = uu([t3.m_sweepAngle], 1, t3), u = Math.sqrt(u), u > 0.25 * is(t3)) {
      const e6 = t3.m_sweepAngle - 1e-4, s5 = t3.m_sweepAngle + 1e-4, n8 = [0];
      rn(uu, t3, 1, [t3.m_sweepAngle], [e6], [s5], 1e-14, n8), t3.m_sweepAngle = n8[0];
    }
    const m3 = Math.abs(t3.m_sweepAngle) > Hs();
    if (qu(t3, m3), i2 !== m3 && !i2 && Math.abs(t3.m_sweepAngle) > 1.5 * Hs()) return void bu(t3, e5, s4, o);
    if (0 === t3.m_sweepAngle || r !== t3.m_sweepAngle > 0) return void bu(t3, e5, s4, o);
  }
}
function lu(t3, e5) {
  return (ru(t3, e5) - t3.getStartAngle()) / t3.getSweepAngle();
}
function cu(t3, e5) {
  return t3.m_startAngle + e5 * t3.m_sweepAngle;
}
function gu(t3, e5, s4) {
  s4.assign(new p2(t3.m_startAngle).addE(e5.mulE(new p2(t3.m_sweepAngle))));
}
function du(t3, e5) {
  const s4 = new p2(t3.m_cosr).sqrThis(), n6 = new p2(t3.m_sinr).sqrThis(), i2 = new p2(t3.m_minorMajorRatio), r = new p2(1 / t3.m_minorMajorRatio), o = i2.mulE(s4).addThisE(r.mulE(n6)), a2 = i2.subE(r).mulThis(2 * t3.m_cosr * t3.m_sinr), h2 = i2.mulE(n6).addThisE(r.mulE(s4));
  e5[0] = o, e5[1] = a2, e5[2] = h2, e5[3] = new p2(-t3.m_semiMajorAxis).mulThis(t3.m_semiMajorAxis).mulThis(t3.m_minorMajorRatio);
}
function _u(t3, e5) {
  const s4 = new Ne();
  s4.a11.setE(t3[0]), s4.a12 = p2.st_mulByPower2(t3[1], 0.5), s4.a21.setE(s4.a12), s4.a22.setE(t3[2]);
  const n6 = [mi.getNAN(), mi.getNAN()], i2 = [new p2(), new p2()];
  s4.eigenSymmetric(i2, n6);
  const r = t3[3].clone();
  r.negateThis(), r.invThis(), i2[0].mulThisE(r), i2[1].mulThisE(r), i2[0].sqrtThis().invThis(), i2[1].sqrtThis().invThis(), e5.x = i2[0].toDouble(), e5.y = i2[1].toDouble();
  return Math.atan2(n6[0].y, n6[0].x);
}
function pu(t3, e5, s4) {
  if (Su(t3)) return (s4 - e5) * mi.distance(t3.getStartXY(), t3.getEndXY());
  if (1 === t3.m_minorMajorRatio) return Math.abs(t3.getSweepAngle() * (e5 - s4)) * t3.m_semiMajorAxis;
  const n6 = Eu(t3, e5);
  return Eu(t3, s4) - n6;
}
function fu(t3) {
  return t3.m_cachedValues;
}
function Pu(t3) {
  if (t3.m_cachedValues) return t3.m_cachedValues;
  const e5 = eu();
  return e5.e2 = Cu(t3), e5.completeE = ft(e5.e2), t3.m_cachedValues = e5, e5;
}
function yu(t3, e5, s4, n6) {
  if (!e5.isEqual(t3.m_XStart, t3.m_YStart) || !s4.isEqual(t3.m_XEnd, t3.m_YEnd)) {
    if (Su(t3)) return t3.m_XStart = e5.x, t3.m_YStart = e5.y, t3.m_XEnd = s4.x, t3.m_YEnd = s4.y, Hu(t3), void t3.afterCompletedModification();
    if (n6 && Math.abs(t3.getSweepAngle()) <= 1.01 * Js()) {
      const n7 = Ot(mi, 3), i2 = Bu(t3, n7);
      if (ja(n7)) {
        n7[0].assign(e5), n7[2].assign(s4), Ha(n7);
        if (0 === t3.projectionBehavior()) {
          let e6 = 0, s5 = 2;
          mi.sqrDistance(n7[1], n7[0]) < mi.sqrDistance(n7[1], n7[2]) && (s5 = Pt(e6, e6 = s5));
          const i3 = n7[s5].sub(n7[e6]), r = i3.length();
          i3.divThis(r);
          const o = n7[1].sub(n7[e6]), a2 = o.length(), h2 = o.dotProduct(i3) / a2, u = o.crossProduct(i3) / a2, m3 = new mi();
          Y(n7[e6], n7[s5], 0.5, m3);
          const l2 = 0.5 * r / u * Us(1 - h2, 0, 1), c = n7[1].side(n7[e6], n7[s5]), g2 = i3.clone();
          c ? g2.leftPerpendicularThis() : g2.rightPerpendicularThis();
          const d2 = m3.sub(g2.mul(l2));
          t3.constructCircularArcThreePoint(n7[0], n7[2], d2);
        } else ku(n7, i2 * i2, null, false, t3);
        return;
      }
    }
    0 === t3.projectionBehavior() ? nm(t3, e5, s4) : im(t3, e5, s4);
  }
}
function xu(t3, e5, s4) {
  const n6 = 0 === t3.projectionBehavior();
  if (s4 <= 2) return void bu(t3, e5[0], e5[s4 - 1], n6 ? 0 : 1);
  if (n6) {
    t3.constructCircularArcThreePoint(e5[0], e5[s4 - 1], e5[Math.trunc(s4 / 2)]);
    const n7 = new mi();
    return t3.queryCoord2D(0.5, n7), void t3.m_interior.setCoordsPoint2D(n7);
  }
  const i2 = t3.getSemiMajorAxis(), r = t3.getMinorMajorRatio(), o = t3.getAxisXRotation(), a2 = t3.getCenter(), h2 = new Array(4);
  h2[0] = t3.isMajor(), h2[1] = !h2[0], h2[2] = h2[0], h2[3] = !h2[0];
  const u = new Array(4);
  u[0] = t3.isClockwise(), u[1] = u[0], u[2] = !u[0], u[3] = !u[0];
  const m3 = Math.trunc(s4 < 5 ? 1 : (s4 + 4) / 5), l2 = Ot(Xh, 4), c = Yt(4, Number.NaN);
  let g2 = 0;
  for (let d2 = 0; d2 < 4; d2++) {
    l2[d2].constructEllipticArcEndPointsCenter(e5[0], e5[s4 - 1], i2, r, o, h2[d2], u[d2], a2), c[d2] = 0;
    let t4 = 0;
    for (let n7 = m3; n7 < s4 - 1; n7 += m3) {
      const s5 = l2[d2].getClosestCoordinate(e5[n7], false);
      c[d2] += mi.sqrDistance(l2[d2].getCoord2D(s5), e5[n7]), t4++;
    }
    c[d2] /= t4, c[d2] < c[g2] && (g2 = d2);
  }
  t3.assignCopy(l2[g2]);
}
function Cu(t3) {
  return 1 - H(t3.m_minorMajorRatio);
}
function vu(t3, e5, s4, n6, i2, r, o, a2, h2) {
  return t3.m_bits = 0, t3.m_rotation = r, We(t3, e5), Ze(t3, s4), t3.m_cosr = Math.cos(r), t3.m_sinr = Math.sin(r), qu(t3, o), Nu(t3, a2), void 0 !== h2 ? t3.m_center.assign(h2) : t3.m_center.setNAN(), t3.setProjectionBehavior(1), t3.m_semiMajorAxis = n6, t3.m_minorMajorRatio = i2, zu(t3, void 0 === h2);
}
function bu(t3, e5, s4, n6) {
  t3.m_bits = 0, t3.m_rotation = 0, We(t3, e5), Ze(t3, s4), t3.m_interior.assign(e5.add(s4).mul(0.5)), t3.m_startAngle = 0, t3.m_sweepAngle = 0, t3.m_cosr = 1, t3.m_sinr = 0, qu(t3, false), Nu(t3, false), t3.m_center.setNAN(), t3.m_semiMajorAxis = 1, t3.m_minorMajorRatio = 0, t3.setProjectionBehavior(n6), t3.afterCompletedModification();
}
function Su(t3) {
  return t3.m_center.isNAN();
}
function Eu(t3, e5) {
  if (0 === e5) return 0;
  const s4 = Pu(t3), n6 = cu(t3, e5), i2 = Js(), r = wu(t3), o = _t(n6 + i2, s4.e2, s4.completeE), a2 = t3.m_semiMajorAxis * (o - r);
  return Math.abs(a2);
}
function Du(t3, e5) {
  if (Su(t3)) {
    const s5 = mi.distance(t3.getStartXY(), t3.getEndXY());
    return 0 === s5 ? 0 : e5 / s5;
  }
  if (1 === t3.m_minorMajorRatio) {
    const s5 = Math.abs(t3.getSweepAngle() * t3.m_semiMajorAxis);
    return 0 === s5 ? 0 : e5 / s5;
  }
  if (0 === e5) return 0;
  const s4 = t3.getSweepAngle();
  if (0 === s4) return 0.5;
  const n6 = Pu(t3), i2 = Js(), r = wu(t3);
  s4 < 0 && (e5 = -e5);
  const o = e5 / t3.m_semiMajorAxis + r;
  let a2 = vt(o, n6.e2, n6.completeE);
  a2 -= i2, a2 -= t3.getStartAngle();
  return a2 / s4;
}
function wu(t3) {
  const e5 = Pu(t3);
  return _t(t3.getStartAngle() + Js(), e5.e2, e5.completeE);
}
function Au(t3, e5, n6, i2, r) {
  if (2 === e5.m_TransformationType) return void n2(0);
  if (n2(!Lu(t3)), e5.isIdentity() && (!i2 || i2.equals(t3.getStartXY()) && r.equals(t3.getEndXY()))) return;
  Mu(t3);
  let o = mi.getNAN(), a2 = mi.getNAN();
  if (null === i2 ? (o.x = t3.m_XStart, o.y = t3.m_YStart, e5.transformInPlace(o), a2.x = t3.m_XEnd, a2.y = t3.m_YEnd, e5.transformInPlace(a2)) : (o = i2, a2 = r), Su(t3)) return t3.m_XStart = o.x, t3.m_YStart = o.y, t3.m_XEnd = a2.x, void (t3.m_YEnd = a2.y);
  const h2 = t3.m_center.clone();
  if (e5.transformInPlace(h2), n6 || e5.isUniformNoRotation()) {
    let s4 = Xu(t3);
    e5.isReflective() && (s4 = !s4);
    if (0 === t3.projectionBehavior()) {
      if (!o.equals(a2)) {
        const s5 = t3.m_interior.clone();
        return e5.transformInPlace(s5), void t3.constructCircularArcThreePoint(o, a2, s5);
      }
      return void Tu(t3, o, a2, h2, s4, false);
    }
    const n7 = new mi(t3.m_cosr, t3.m_sinr);
    e5.transformWithoutTranslateInPlace(n7);
    const i3 = Math.atan2(n7.y, n7.x), r2 = t3.getSemiAxes();
    e5.transformWithoutTranslateInPlace(r2);
    const u = t3.m_center.clone();
    return e5.transformInPlace(u), void t3.constructEllipticArcEndPointsCenter(o, a2, r2.x, r2.y / r2.x, i3, t3.isMajor(), s4, u);
  }
  {
    {
      const s5 = new Array(4);
      du(t3, s5);
      const n8 = new Ne();
      n8.a11.setE(s5[0]), n8.a12.setE(s5[1]), n8.a12.mulThisByPower2(0.5), n8.a21.setE(n8.a12), n8.a22.setE(s5[2]);
      if (!n8.det().isZero()) {
        const i4 = new Ne();
        if (i4.a11.set(e5.xx), i4.a12.set(e5.xy), i4.a21.set(e5.yx), i4.a22.set(e5.yy), i4.invertThis()) {
          const r3 = i4.clone();
          r3.transposeThis();
          const u2 = n8.clone();
          u2.mulThis(i4), u2.mulLeftThis(r3);
          if (!u2.det().isZero()) {
            const n9 = Ot(p2, 4);
            n9[0].setE(u2.a11), n9[1].setE(u2.a12), n9[1].mulThisByPower2(2), n9[2].setE(u2.a22), n9[3].setE(s5[3]);
            const i5 = mi.getNAN(), r4 = _u(n9, i5);
            let m3 = Xu(t3);
            return e5.isReflective() && (m3 = !m3), void t3.constructEllipticArcEndPointsCenter(o, a2, i5.x, i5.y / i5.x, r4, t3.isMajor(), m3, h2);
          }
        }
      }
    }
    const s4 = [mi.getNAN(), mi.getNAN(), mi.getNAN()];
    s4[0].setCoords(t3.getSemiMajorAxis(), 0), s4[0].rotateDirect(t3.m_cosr, t3.m_sinr), s4[1].setCoords(t3.getSemiMajorAxis(), t3.getSemiMinorAxis()), s4[1].rotateDirect(t3.m_cosr, t3.m_sinr), s4[2].setCoords(0, t3.getSemiMinorAxis()), s4[2].rotateDirect(t3.m_cosr, t3.m_sinr);
    let n7 = t3.isClockwise();
    n7 && (s4[2] = Pt(s4[0], s4[0] = s4[2]));
    const i3 = 0.5;
    e5.transformWithoutTranslateArray(s4, 3, s4), e5.isReflective() && (n7 = !n7);
    const r2 = new mi(0, 0), u = t3.createInstance();
    ku(s4, i3, r2, false, u), t3.constructEllipticArcEndPointsCenter(o, a2, u.getSemiMajorAxis(), u.getMinorMajorRatio(), u.getAxisXRotation(), t3.isMajor(), !n7, h2);
  }
}
function Tu(t3, e5, s4, n6, i2, r) {
  const o = 0.5 * (n6.sub(e5).length() + n6.sub(s4).length());
  t3.m_center.assign(n6), t3.m_startAngle = Math.atan2(e5.y - t3.m_center.y, e5.x - t3.m_center.x);
  ou(t3, Math.atan2(s4.y - t3.m_center.y, s4.x - t3.m_center.x), i2, r);
  const a2 = t3.constructEllipticArcEndPointsCenter(e5, s4, o, 1, 0, Math.abs(t3.m_sweepAngle) > Math.PI, t3.m_sweepAngle > 0, n6);
  return t3.setProjectionBehavior(0), a2;
}
function Iu(t3, e5) {
  t3.m_cachedValues = e5;
}
function Mu(t3) {
  t3.m_cachedValues = null;
}
function Yu(t3, e5) {
  e5.m_cachedValues = Pt(t3.m_cachedValues, t3.m_cachedValues = e5.m_cachedValues);
}
function Nu(t3, e5) {
  const s4 = e5 ? 1 : 0;
  t3.m_bits = -2 & t3.m_bits | s4;
}
function Xu(t3) {
  return !!(1 & t3.m_bits);
}
function qu(t3, e5) {
  const s4 = e5 ? 1 : 0;
  t3.m_bits = -3 & t3.m_bits | s4 << 1;
}
function Fu(t3) {
  return !!(2 & t3.m_bits);
}
function Vu(t3) {
  if (t3.m_center.isNAN()) return false;
  const e5 = 8, s4 = new Ye();
  s4.setWithEps(t3.getStartXY(), e5), s4.subThisE(new Ye().setWithEps(t3.m_center, e5));
  const n6 = new p2();
  n6.setWithEps(t3.m_rotation, e5);
  const i2 = new p2(), r = new p2();
  p2.st_cosAndSin(n6, i2, r), s4.rotateReverse(i2, r);
  const o = new Ye();
  o.setWithEps(t3.getEndXY()), o.subThisE(Ye.constructPoint2D(t3.m_center)), o.rotateReverse(i2, r);
  const a2 = new p2();
  a2.setWithEps(t3.m_semiMajorAxis, e5);
  const h2 = a2.clone(), u = new p2();
  u.setWithEps(t3.m_minorMajorRatio), h2.mulThisE(u), s4.x.divThisE(a2), s4.y.divThisE(h2), o.x.divThisE(a2), o.y.divThisE(h2);
  const m3 = s4.x.sqr().addThisE(s4.y.sqr()).subThisE(w2), l2 = o.x.sqr().addThisE(o.y.sqr()).subThisE(w2);
  return !m3.isZero() || !l2.isZero();
}
function Lu(t3) {
  return !!(8 & t3.m_bits);
}
function Ru(t3) {
  t3.m_bits &= -9;
}
function zu(t3, e5) {
  Ru(t3);
  const n6 = t3.getStartXY(), i2 = t3.getEndXY();
  let r = false;
  const o = Fu(t3), a2 = Xu(t3), h2 = t3.projectionBehavior(), u = n6.equals(i2);
  let m3 = 0 === t3.m_minorMajorRatio || 0 === t3.m_semiMajorAxis;
  if (Number.isNaN(t3.m_minorMajorRatio) && (0 === t3.m_semiMajorAxis ? t3.m_minorMajorRatio = 1 : v("NAN minor major ratio and non-zero major axis")), m3 ||= e5 ? u : t3.m_center.isNAN(), m3) return bu(t3, n6, i2, h2), true;
  t3.m_semiMajorAxis = Math.abs(t3.m_semiMajorAxis), t3.m_minorMajorRatio = Math.abs(t3.m_minorMajorRatio), t3.m_minorMajorRatio > 1 && (t3.m_semiMajorAxis *= t3.m_minorMajorRatio, t3.m_minorMajorRatio = 1 / t3.m_minorMajorRatio);
  const l2 = new mi(t3.m_semiMajorAxis, t3.m_semiMajorAxis * t3.m_minorMajorRatio);
  if (n2(l2.y > 0 && l2.x >= l2.y), u) {
    const e6 = t3.convertToCanonic(n6);
    n2(!l2.isZero()), e6.x /= l2.x, e6.y /= l2.y;
    const i3 = Math.sqrt(H(e6.x) + H(e6.y));
    if (r = 1 !== i3, t3.m_semiMajorAxis *= i3, l2.mulThis(i3), t3.m_startAngle = au(Math.atan2(e6.y, e6.x)), !o) return t3.m_interior.assign(n6), t3.m_sweepAngle = 0, t3.afterCompletedModification(), r;
    t3.m_sweepAngle = a2 ? $s() : -$s();
  } else {
    let e6 = t3.m_center.isNAN() || Vu(t3);
    if (!e6) {
      const s4 = t3.convertToCanonic(n6);
      s4.x /= l2.x, s4.y /= l2.y;
      const r2 = new mi(1, 0);
      t3.m_startAngle = mi.calculateAngle(r2, s4);
      const o2 = t3.convertToCanonic(i2);
      o2.x /= l2.x, o2.y /= l2.y, t3.m_sweepAngle = mi.calculateAngle(s4, o2), e6 = !Wu(t3);
    }
    if (e6) {
      r = true;
      const e7 = n6.sub(i2).mulThis(0.5);
      e7.rotateReverse(t3.m_cosr, t3.m_sinr);
      let s4 = H(e7.x / l2.x) + H(e7.y / l2.y);
      s4 > 1 && (s4 = Math.sqrt(s4), t3.m_semiMajorAxis *= s4, l2.mulThis(s4));
      const h3 = new mi(0, 0);
      {
        const t4 = l2.x * l2.x, s5 = l2.y * l2.y, n7 = t4 * e7.y * e7.y + s5 * e7.x * e7.x, i3 = t4 * s5 - n7;
        if (i3 > 0) {
          const t5 = Math.sqrt(i3 / n7);
          h3.setCoords(l2.x * e7.y / l2.y, -l2.y * e7.x / l2.x), h3.mulThis(t5), o === a2 && h3.negateThis();
        }
      }
      {
        const e8 = new mi(h3.x, h3.y);
        e8.rotateDirect(t3.m_cosr, t3.m_sinr), e8.addThis(n6.add(i2).mulThis(0.5)), t3.m_center.assign(e8);
      }
    }
    if (mu(t3), !Wu(t3)) return bu(t3, n6, i2, h2), true;
  }
  return Hu(t3), t3.afterCompletedModification(), r;
}
function Bu(t3, e5) {
  n2(Math.abs(t3.getSweepAngle()) < 15 * Math.PI / 16);
  const n6 = t3.getSemiMajorAxis(), i2 = t3.getSemiMinorAxis();
  let r;
  if (0 === n6) return e5[0].setCoordsPoint2D(t3.getStartXY()), e5[1].setCoordsPoint2D(t3.getStartXY()), e5[2].setCoordsPoint2D(t3.getStartXY()), r = 1, r;
  if (0 === i2) return e5[0].setCoordsPoint2D(t3.getStartXY()), e5[2].setCoordsPoint2D(t3.getEndXY()), e5[1] = mi.lerp(e5[0], e5[2], 0.5), r = 1, r;
  const o = t3.getSweepAngle(), a2 = t3.getStartAngle(), h2 = a2 + o, u = new mi(-n6 * Math.sin(a2), i2 * Math.cos(a2)), m3 = new mi(-n6 * Math.sin(h2), i2 * Math.cos(h2));
  u.normalize(), m3.normalize(), u.rotateDirect(t3.m_cosr, t3.m_sinr), m3.rotateDirect(t3.m_cosr, t3.m_sinr), e5[0].setCoordsPoint2D(t3.getStartXY()), e5[2].setCoordsPoint2D(t3.getEndXY()), e5[1].setSub(e5[2], e5[0]);
  const l2 = u.crossProduct(m3);
  e5[1].assign(u.mul(e5[1].crossProduct(m3) / l2)), e5[1].addThis(e5[0]);
  return r = Math.cos(0.5 * o), r;
}
function ku(t3, e5, n6, i2, r) {
  if (i2) {
    const s4 = 0.5, n7 = Math.sqrt(e5), i3 = H(1 - s4) + 2 * n7 * s4 * (1 - s4) + H(s4), o2 = t3[0].mul(H(1 - s4)).add(t3[1].mul(2 * n7 * s4 * (1 - s4))).add(t3[2].mul(H(s4))).divThis(i3);
    return r.constructCircularArcThreePoint(t3[0], t3[2], o2), true;
  }
  const o = t3[0].sub(t3[1]), a2 = t3[2].sub(t3[1]), h2 = o.crossProduct(a2), u = o.dotProduct(a2), m3 = e5;
  n2(m3 <= 1), n2(m3 > 0);
  const l2 = 0.5 / (1 - m3), c = o.sqrLength(), g2 = u, d2 = a2.sqrLength(), _ = H(h2), p3 = o.sub(a2).sqrLength();
  if (0 === _) return bu(r, t3[0], t3[2], 1), false;
  if (u <= -Math.sqrt(c) * Math.sqrt(d2)) return bu(r, t3[0], t3[2], 1), false;
  const f3 = [0, 0], P5 = new x2();
  P5.setInfinite();
  const y2 = sn(2 * _, -(p3 / m3 + 4 * g2), 2 * (1 - m3) / m3, P5, false, f3);
  if (0 === y2) return bu(r, t3[0], t3[2], 1), false;
  1 === y2 && (f3[1] = f3[0]);
  const x4 = Math.sqrt(l2 / f3[0]), C3 = Math.sqrt(l2 / f3[1]), v3 = 0.5 / m3;
  let b2 = v3 - d2 * f3[0], S3 = v3 - c * f3[0];
  Math.abs(b2) > Math.abs(S3) ? S3 = g2 * f3[0] - v3 + 1 : b2 = g2 * f3[0] - v3 + 1;
  const E2 = o.mul(b2).add(a2.mul(S3)), D3 = E2.norm(1) < 1e-15 * x4 ? 0 : Math.atan2(E2.y, E2.x) + Math.PI, w4 = o.add(a2), A4 = n6 ? n6.clone() : t3[1].add(w4.mul(l2)), T3 = t3[0].sub(A4), I4 = t3[2].sub(A4), M2 = T3.crossProduct(I4) < 0, Y3 = false;
  new Xh();
  return r.constructEllipticArcEndPointsCenter(t3[0], t3[2], x4, C3 / x4, D3, Y3, !M2, A4);
}
function Gu(t3, e5, s4, n6, i2) {
  return ku(t3, e5, s4, n6, i2);
}
function Wu(t3) {
  const e5 = is(t3);
  let s4 = false;
  {
    const n7 = new mi(t3.m_semiMajorAxis * Math.cos(t3.m_startAngle), t3.getSemiMinorAxis() * Math.sin(t3.m_startAngle));
    n7.rotateDirect(t3.m_cosr, t3.m_sinr), n7.addThis(t3.m_center);
    s4 = mi.distance(t3.getStartXY(), n7) > e5;
  }
  let n6 = false;
  if (!s4) {
    const s5 = new mi(t3.m_semiMajorAxis * Math.cos(t3.m_startAngle + t3.m_sweepAngle), t3.getSemiMinorAxis() * Math.sin(t3.m_startAngle + t3.m_sweepAngle));
    s5.rotateDirect(t3.m_cosr, t3.m_sinr), s5.addThis(t3.m_center);
    n6 = mi.distance(t3.getEndXY(), s5) > e5;
  }
  return !s4 && !n6;
}
function ju(t3, s4, n6, i2) {
  0 === n6 && P("construct_enclosing_circle");
  const r = [0, 0, 0], o = Fh(s4, n6, r);
  if (1 === o) t3.constructCircleRadius(0, s4[r[0]], i2);
  else if (2 === o) {
    const e5 = mi.lerp(s4[r[0]], s4[r[1]], 0.5), n7 = mi.distance(s4[r[0]], e5), o2 = mi.distance(s4[r[1]], e5);
    t3.constructCircleRadius(Math.max(n7, o2), e5, i2);
  } else if (3 === o) {
    const e5 = mi.calculateCircleCenterFromThreePoints(s4[r[0]], s4[r[1]], s4[r[2]]), n7 = mi.distance(s4[r[0]], e5), o2 = mi.distance(s4[r[1]], e5), a2 = mi.distance(s4[r[2]], e5);
    t3.constructCircleRadius(Math.max(n7, o2, a2), e5, i2);
  } else b("unexpected");
}
function Zu(t3) {
  if (Su(t3)) return 0;
  if (t3.isDegenerate(0)) return 0;
  const e5 = t3.m_semiMajorAxis, s4 = t3.getSemiMinorAxis(), n6 = e5 * e5 + s4 * s4, i2 = t3.getStartAngle(), r = t3.getEndAngle(), o = t3.m_center.y - t3.m_YStart, a2 = t3.m_cosr, h2 = t3.m_sinr;
  let u = 1, m3 = 0;
  t3.m_rotation && (u = (a2 - h2) * (a2 + h2), m3 = 2 * a2 * h2);
  const l2 = ((-0.5 * (r - i2) + 0.25 * u * (2 * Math.cos(r + i2) * Math.sin(r - i2))) * s4 + -2 * Math.sin(0.5 * (r + i2)) * Math.sin(0.5 * (r - i2)) * a2 * o) * e5 / n6;
  let c = 0;
  if (t3.m_rotation) {
    c = 0.125 * (-2 * Math.sin(r + i2) * Math.sin(r - i2)) * m3 - s4 * o / n6 * (2 * Math.cos(0.5 * (r + i2)) * Math.sin(0.5 * (r - i2))) * h2;
  }
  return n6 * (l2 + c) + -0.5 * (t3.m_XEnd - t3.m_XStart) * (t3.m_YEnd - t3.m_YStart);
}
function Hu(t3) {
  t3.queryCoord2D(0.5, t3.m_interior);
}
function Uu(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== Qu(t3, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Ou(t3, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== am(e5, s4)) return 2;
  } else if (Le(e5, s4)) return 1;
  return 0 !== Ju(t3, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Qu(t3, e5, n6, i2, r, o, a2, h2, u, m3) {
  if (Su(e5)) {
    return Ds2(new pm({ start: e5.getStartXY(), end: e5.getEndXY() }), n6, i2, r, o, a2, h2, m3);
  }
  null !== r && (r.length = 0), null !== o && (o.length = 0), null !== i2 && (i2.length = 0);
  const l2 = rs2(e5, n6);
  if (os(e5, n6, a2 = Math.max(l2, a2))) return 0;
  const c = n6.getStartXY();
  c.subThis(e5.m_center);
  const g2 = n6.getEndXY();
  g2.subThis(e5.m_center), c.rotateReverse(e5.m_cosr, e5.m_sinr), g2.rotateReverse(e5.m_cosr, e5.m_sinr);
  const d2 = g2.clone();
  d2.subThis(c);
  const _ = e5.m_semiMajorAxis, p3 = 1 / _, f3 = e5.getSemiMinorAxis(), P5 = 1 / f3, y2 = d2.clone();
  y2.leftPerpendicularThis();
  const x4 = Math.atan2(f3 * y2.y, _ * y2.x), C3 = Yt(16, Number.NaN), v3 = Yt(16, Number.NaN);
  let b2 = 0;
  const S3 = [x4, x4 + Math.PI];
  for (let s4 = 0; s4 < 2; ++s4) {
    const t4 = lu(e5, S3[s4]);
    if (t4 >= 0 && t4 <= 1) {
      C3[b2] = t4;
      const s5 = e5.getCoord2D(C3[b2]);
      v3[b2] = n6.getClosestCoordinate(s5, false), mi.distance(s5, n6.getCoord2D(v3[b2])) <= a2 && b2++;
    }
  }
  const E2 = c.x * p3, D3 = c.y * P5, w4 = d2.x * p3, A4 = d2.y * P5;
  let T3 = sn(w4 * w4 + A4 * A4, 2 * (E2 * w4 + D3 * A4), E2 * E2 + D3 * D3 - 1, x2.unit(), false, v3);
  n2(T3 >= 0);
  for (let s4 = 0; s4 < T3; s4++) {
    const t4 = d2.mul(v3[s4]).add(c);
    t4.x *= p3, t4.y *= P5;
    const i3 = lu(e5, Math.atan2(t4.y, t4.x));
    if (i3 >= 0 && i3 <= 1) {
      C3[b2] = i3;
      const t5 = e5.getCoord2D(i3);
      v3[b2] = n6.getClosestCoordinate(t5, false), mi.distance(t5, n6.getCoord2D(v3[b2])) <= a2 && b2++;
    }
  }
  n2(b2 < C3.length + 4);
  const I4 = Yt(16, Number.NaN);
  T3 = e5.intersectPoint(n6.getStartXY(), I4, a2);
  for (let s4 = 0; s4 < T3; s4++, b2++) C3[b2] = I4[s4], v3[b2] = 0;
  T3 = e5.intersectPoint(n6.getEndXY(), I4, a2);
  for (let s4 = 0; s4 < T3; s4++, b2++) C3[b2] = I4[s4], v3[b2] = 1;
  T3 = n6.intersectPoint(e5.getStartXY(), I4, a2);
  for (let s4 = 0; s4 < T3; s4++, b2++) C3[b2] = 0, v3[b2] = I4[s4];
  T3 = n6.intersectPoint(e5.getEndXY(), I4, a2);
  for (let s4 = 0; s4 < T3; s4++, b2++) C3[b2] = 1, v3[b2] = I4[s4];
  return 0 === b2 ? 0 : cm(t3, e5, n6, C3, v3, b2, i2, r, o, a2, h2, u, m3);
}
function Ju(t3, e5, n6, i2, r, o, a2, h2, u, m3) {
  if (Su(e5)) {
    const s4 = new pm({ start: e5.getStartXY(), end: e5.getEndXY() });
    return Qu(t3, n6, s4, i2, o, r, a2, h2, u, true);
  }
  if (Su(n6)) {
    const s4 = new pm({ start: n6.getStartXY(), end: n6.getEndXY() });
    return Qu(t3, e5, s4, i2, r, o, a2, h2, u, m3);
  }
  const l2 = rs2(e5, n6);
  a2 = Math.max(a2, l2);
  let c = false;
  {
    const t4 = e5.getSemiAxes(), i3 = e5.getCenter(), m4 = n6.getSemiAxes(), l3 = n6.getCenter(), g3 = mi.distance(l3, i3), d3 = t4.x + m4.x;
    if (g3 > d3 + a2) return 0;
    if (t4.y > m4.x) {
      if (g3 + m4.x + a2 < t4.y) return 0;
    } else if (m4.y > t4.x && g3 + t4.x + a2 < m4.y) return 0;
    if (u && !h2) {
      const i4 = 1 === e5.m_minorMajorRatio && e5.isClosed() && e5.isMajor(), a3 = 1 === n6.m_minorMajorRatio && n6.isClosed() && n6.isMajor();
      if (i4 && a3 && (c = true, g3 <= d3)) {
        if (Math.max(t4.x, m4.x) <= Math.min(t4.x, m4.x) + g3) return n2(!r && !o), 1;
      }
    }
  }
  if (!c && os(e5, n6, a2)) return 0;
  const g2 = [], d2 = [], _ = false, p3 = false, f3 = Wh(e5, 0, 0, _, p3, g2, d2, null), P5 = [], y2 = [], x4 = Wh(n6, 0, 0, _, p3, P5, y2, null);
  if (1 === f3 && 1 === x4) {
    const t4 = new En({ points: g2, weights: d2 }), s4 = new En({ points: P5, weights: y2 }), l3 = [], c2 = [], _2 = rh(false, t4, s4, i2, null === r ? null : l3, null === o ? null : c2, a2, h2, u, m3);
    if (_2 > 0 && null !== r || null !== o) {
      r && (r.length = 0), o && (o.length = 0);
      for (let i3 = 0; i3 < _2; ++i3) {
        if (r) if (Vs(l3[i3], 0, 1)) r.push(l3[i3]);
        else {
          const s5 = t4.tToLength(l3[i3]), n7 = e5.lengthToT(s5);
          r.push(n7);
        }
        if (o) if (Vs(c2[i3], 0, 1)) o.push(c2[i3]);
        else {
          const t5 = s4.tToLength(c2[i3]), e6 = n6.lengthToT(t5);
          o.push(e6);
        }
      }
    }
    return _2;
  }
  let C3 = [];
  const v3 = [];
  let b2 = 0;
  const S3 = u && !h2;
  for (let s4 = 0; s4 < f3; s4++) {
    const t4 = new En({ points: g2.slice(2 * s4, 2 * s4 + 3), weights: d2.slice(2 * s4, 2 * s4 + 3) });
    let i3 = 0;
    for (let r2 = 0; r2 < x4; r2++) {
      v3.length <= r2 && v3.push(new En({ points: P5.slice(2 * r2, 2 * r2 + 3), weights: y2.slice(2 * r2, 2 * r2 + 3) }));
      const o2 = [], h3 = [], u2 = S3 ? null : o2, m4 = S3 ? null : h3, l3 = rh(false, t4, v3[r2], null, u2, m4, a2, false, S3, false);
      if (l3 > 0 && S3) return 1;
      for (let a3 = 0; a3 < l3; ++a3) {
        if (0 === o2[a3] && 0 === s4) o2[a3] = 0;
        else if (1 === o2[a3] && s4 === f3 - 1) o2[a3] = 1;
        else {
          const s5 = t4.tToLength(o2[a3]) + b2, n7 = e5.lengthToT(s5);
          o2[a3] = n7;
        }
        if (0 === h3[a3] && 0 === r2) h3[a3] = 0;
        else if (1 === h3[a3] && r2 === x4 - 1) h3[a3] = 1;
        else {
          const t5 = v3[r2].tToLength(h3[a3]) + i3, e6 = n6.lengthToT(t5);
          h3[a3] = e6;
        }
        C3.push($t(o2[a3], h3[a3]));
      }
      i3 += v3[r2].calculateLength2D();
    }
    b2 += t4.calculateLength2D();
  }
  if (0 === C3.length) return 0;
  if (h2 && (C3 = C3.filter((t4) => !Vs(t4.first, 0, 1) || !Vs(t4.second, 0, 1) || !e5.getCoord2D(t4.first).equals(n6.getCoord2D(t4.second)))), u) return C3.length;
  const E2 = [], D3 = [];
  for (const s4 of C3) E2.push(s4.first), D3.push(s4.second);
  return cm(t3, e5, n6, E2, D3, E2.length, i2, r, o, a2, h2, u, m3);
}
function Ku(t3, e5, s4) {
  if (s4.setCoords(t3.getCoord2D(e5.vmin)), s4.mergeNe(t3.getCoord2D(e5.vmax)), Su(t3)) return;
  const n6 = t3.getSemiAxes(), i2 = [0, 0, 0, 0];
  {
    const e6 = Math.atan2(-n6.y * t3.m_sinr, n6.x * t3.m_cosr), s5 = e6 + Math.PI, r2 = Math.atan2(n6.y * t3.m_cosr, n6.x * t3.m_sinr), o = r2 + Math.PI;
    i2[0] = lu(t3, e6), i2[1] = lu(t3, s5), i2[2] = lu(t3, r2), i2[3] = lu(t3, o);
  }
  const r = new mi();
  for (let o = 0; o < 4; o++) {
    const n7 = i2[o];
    e5.containsExclusiveCoordinate(n7) && (t3.queryCoord2D(n7, r), s4.mergeNe(r));
  }
}
function $u(t3, e5, n6, i2, r) {
  if (0 === t3.m_semiMajorAxis) return n6.vmin;
  let o = mi.getNAN();
  t3.queryCoord2D(n6.vmin, o);
  let a2 = mi.getNAN();
  if (t3.queryCoord2D(n6.vmax, a2), Su(t3)) {
    return new pm({ start: o, end: a2 }).getClosestCoordinate(e5, i2);
  }
  const h2 = iu(t3, e5);
  if (o = iu(t3, o), a2 = iu(t3, a2), 1 === t3.m_minorMajorRatio) {
    if (h2.isEqual(0, 0)) return n6.vmin;
    const e6 = lu(t3, Math.atan2(h2.y, h2.x));
    if (i2 || n6.containsCoordinate(e6)) return e6;
    return mi.distance(h2, o) <= mi.distance(h2, a2) ? n6.vmin : n6.vmax;
  }
  const u = t3.getSemiMajorAxis(), m3 = t3.getSemiMinorAxis(), l2 = (u - m3) * (u + m3), c = H(l2), g2 = h2.x, d2 = h2.y, _ = H(m3 * d2), p3 = m3 * l2 * d2 * 2, f3 = [new p2(_), new p2(p3), new p2(c - H(u * g2) - _), new p2(-p3), new p2(-c)], P5 = Ot(p2, 4), y2 = _n(f3, 4, new x2(-1, 1), false, P5, 4);
  let x4 = n6.vmin, C3 = mi.sqrDistance(h2, o);
  {
    const t4 = mi.sqrDistance(h2, a2);
    t4 < C3 && (x4 = n6.vmax, C3 = t4);
  }
  n2(!i2);
  let v3 = Yt(8, Number.NaN);
  for (let s4 = 0; s4 < y2; ++s4) {
    const e6 = P5[s4].value(), n7 = Math.sqrt(1 - e6 * e6), i3 = Math.atan2(e6, n7), r2 = Math.atan2(e6, -n7);
    v3[2 * s4] = lu(t3, i3), v3[2 * s4 + 1] = lu(t3, r2);
  }
  v3 = v3.slice(0, 2 * y2), qt(v3);
  for (let s4 = 0, b2 = 2 * y2; s4 < b2; ++s4) if (v3[s4] > n6.vmin && v3[s4] < n6.vmax) {
    const n7 = mi.sqrDistance(e5, t3.getCoord2D(v3[s4]));
    C3 > n7 && (C3 = n7, x4 = v3[s4]);
  }
  return x4;
}
function tm(t3, e5, n6) {
  n2(!Su(t3));
  const i2 = new x3();
  i2.setRotateAngle(-t3.getAxisXRotation());
  const r = new mi();
  i2.queryTransform(e5, r);
  const o = Math.atan2(-r.x * t3.getMinorMajorRatio(), r.y), a2 = o + Hs();
  let h2 = lu(t3, o), u = lu(t3, a2);
  u < h2 && (u = Pt(h2, h2 = u));
  let m3 = 0;
  return h2 >= 0 && h2 <= 1 && (n6[m3++] = h2), u >= 0 && u <= 1 && (n6[m3++] = u), m3;
}
function em(t3, e5, s4) {
  return t3.m_semiMajorAxis === e5.m_semiMajorAxis && (t3.isMajor() !== e5.isMajor() && (!!t3.m_center.equals(e5.m_center) && (t3.m_sinr === e5.m_sinr && (t3.m_cosr === e5.m_cosr && (t3.m_minorMajorRatio === e5.m_minorMajorRatio && (s4 ? t3.isClockwise() !== e5.isClockwise() : t3.isClockwise() === e5.isClockwise()))))));
}
function sm(t3, e5, s4) {
  if (Su(t3)) s4.setE(Ye.constructPoint2D(t3.getEndXY()).subE(Ye.constructPoint2D(t3.getStartXY())));
  else {
    const n6 = new p2();
    gu(t3, e5, n6);
    const i2 = new Ye();
    if (i2.setCoordsE(new p2(t3.m_semiMajorAxis).negate().mulE(new p2().setSin(n6)), new p2(t3.getSemiMinorAxis()).mulE(new p2().setCos(n6))), t3.m_rotation) {
      const e6 = new p2(t3.m_rotation);
      i2.rotateDirect(new p2().setCos(e6), new p2().setSin(e6));
    }
    i2.scaleThis(new p2(t3.getSweepAngle())), s4.setE(i2);
  }
}
function nm(t3, e5, s4, n6) {
  const i2 = t3.getStartXY(), r = t3.getEndXY(), o = i2.equals(r), a2 = e5.equals(s4);
  if (!o && !a2) {
    const n7 = new x3();
    n7.setShiftCoords(-t3.m_XStart, -t3.m_YStart);
    const o2 = mi.distance(e5, s4), a3 = mi.distance(i2, r), h3 = o2 / a3;
    n7.scale(h3, h3);
    const u2 = r.sub(i2);
    u2.divThis(a3);
    const m4 = s4.sub(e5);
    m4.divThis(o2);
    const l3 = u2.crossProduct(m4), c2 = m4.dotProduct(u2);
    return n7.rotate(c2, l3), n7.shiftCoords(e5.x, e5.y), void Au(t3, n7, true, e5, s4);
  }
  const h2 = new mi();
  if (t3.queryCoord2D(0.5, h2), a2) {
    if (o) {
      const n7 = t3.m_center.add(e5.sub(i2));
      t3.constructEllipticArcEndPointsCenter(e5, s4, t3.getSemiMajorAxis(), 1, 0, true, !t3.isClockwise(), n7), t3.setProjectionBehavior(0);
    } else if (t3.isMajor()) {
      const n7 = h2.sub(e5).getUnitVector().mul(2 * t3.getSemiMajorAxis()).add(e5);
      t3.constructCircularArcThreePoint(e5, s4, n7);
    } else t3.constructCircularArcThreePoint(e5, s4, e5);
    return;
  }
  const u = e5.add(s4).mul(0.5), m3 = s4.sub(e5);
  m3.rightPerpendicularThis();
  const l2 = u.add(m3), c = mi.getClosestCoordinate(u, l2, t3.getCenter(), true), g2 = new mi();
  Y(u, l2, c, g2);
  const d2 = mi.distance(e5, g2);
  t3.constructEllipticArcEndPointsCenter(e5, s4, d2, 1, 0, true, !t3.isClockwise(), g2), t3.setProjectionBehavior(0);
}
function im(t3, e5, n6, i2) {
  const r = t3.getStartXY(), o = t3.getEndXY(), a2 = r.equals(o), h2 = e5.equals(n6);
  if (!a2 && !h2) {
    const s4 = new x3();
    return s4.initializeFromTwoPoints(r, o, e5, n6), Au(t3, s4, true, e5, n6), t3.endPointModified(), void t3.normalizeAfterEndpointChange();
  }
  if (!t3.isMajor()) return void bu(t3, e5, n6, 1);
  if (a2 && h2) {
    const s4 = t3.m_center.add(e5.sub(r));
    return void t3.constructEllipticArcEndPointsCenter(e5, n6, t3.getSemiMajorAxis(), t3.getMinorMajorRatio(), t3.getAxisXRotation(), true, !t3.isClockwise(), s4);
  }
  if (!a2) {
    const s4 = 0.5 * ($s() - Math.abs(t3.getSweepAngle())), i3 = (t3.getSweepAngle() + s4 * K(t3.getSweepAngle())) / t3.getSweepAngle(), r2 = new mi();
    t3.queryCoord2D(i3, r2), t3.constructEllipticArcEndPointsCenter(r2, r2, t3.getSemiMajorAxis(), t3.getMinorMajorRatio(), t3.getAxisXRotation(), true, !t3.isClockwise(), t3.getCenter());
    const o2 = t3.getCenter().add(e5.sub(r2));
    return void t3.constructEllipticArcEndPointsCenter(e5, n6, t3.getSemiMajorAxis(), t3.getMinorMajorRatio(), t3.getAxisXRotation(), true, !t3.isClockwise(), o2);
  }
  const u = mi.sqrDistance(e5, n6);
  let m3 = 0.25, l2 = 0.75;
  if (u < mi.sqrDistance(t3.getCoord2D(0.25), t3.getCoord2D(0.75))) {
    const e6 = [0], n7 = tn(new su(t3, u), x2.construct(0, 0.25), 1, e6);
    n7 > 0 && (n2(1 === n7), m3 = e6[0], l2 = 1 - e6[0]);
  }
  const c = t3.getCoord2D(m3), g2 = t3.getCoord2D(l2);
  n2(!c.equals(g2)), t3.constructEllipticArcEndPointsCenter(c, g2, t3.getSemiMajorAxis(), t3.getMinorMajorRatio(), t3.getAxisXRotation(), true, !t3.isClockwise(), t3.m_center), im(t3, e5, n6);
}
function rm(t3, e5, s4, n6, i2) {
  return om(t3, false, e5, s4, n6, i2);
}
function om(t3, e5, s4, n6, r, o) {
  const a2 = s4.getGeometryType(), u = n6.getGeometryType(), m3 = Math.max(r, rs2(s4, n6));
  if (a2 === a.enumLine && u === a.enumLine) return Es(s4, n6, m3, o);
  let l2 = s4, c = n6, g2 = s4.getStartXY(), d2 = s4.getEndXY();
  if (g2.compare(d2) > 0 && (l2 = s4.clone().reverse()), g2 = n6.getStartXY(), d2 = n6.getEndXY(), g2.compare(d2) > 0 && (c = n6.clone().reverse()), e5) {
    if (s4.equals(n6)) return 2;
    if (Ge(s4, n6, m3)) return 4;
  }
  switch (a2) {
    case a.enumLine:
      switch (u) {
        case a.enumEllipticArc:
          return Uu(t3, c, l2, m3, o);
        case a.enumBezier:
          return So(t3, c, l2, m3, o);
        case a.enumRationalBezier2:
          return $a(t3, c, l2, m3, o);
        case a.enumBezier2:
          return Xi(t3, c, l2, m3, o);
        default:
          b("");
      }
      break;
    case a.enumEllipticArc:
      switch (u) {
        case a.enumLine:
          return Uu(t3, l2, c, m3, o);
        case a.enumEllipticArc:
          return Ou(t3, l2, c, m3, o);
        case a.enumBezier:
          return Eo(t3, c, l2, m3, o);
        case a.enumRationalBezier2:
          return th(t3, c, l2, m3, o);
        case a.enumBezier2:
          return qi(t3, c, l2, m3, o);
        default:
          b("");
      }
      break;
    case a.enumBezier:
      switch (u) {
        case a.enumLine:
          return So(t3, l2, c, m3, o);
        case a.enumEllipticArc:
          return Eo(t3, l2, c, m3, o);
        case a.enumBezier:
          return Do(t3, l2, c, m3, o);
        case a.enumRationalBezier2:
          return wo(t3, l2, c, m3, o);
        case a.enumBezier2:
          return Ao(t3, l2, c, m3, o);
        default:
          b("");
      }
      break;
    case a.enumRationalBezier2:
      switch (u) {
        case a.enumLine:
          return $a(t3, l2, c, m3, o);
        case a.enumEllipticArc:
          return th(t3, l2, c, m3, o);
        case a.enumBezier:
          return wo(t3, c, l2, m3, o);
        case a.enumRationalBezier2:
          return eh(t3, l2, c, m3, o);
        case a.enumBezier2:
          return sh(t3, l2, c, m3, o);
        default:
          b("");
      }
      break;
    case a.enumBezier2:
      switch (u) {
        case a.enumLine:
          return Xi(t3, l2, c, m3, o);
        case a.enumEllipticArc:
          return qi(t3, l2, c, m3, o);
        case a.enumBezier:
          return Ao(t3, c, l2, m3, o);
        case a.enumRationalBezier2:
          return sh(t3, c, l2, m3, o);
        case a.enumBezier2:
          return Fi(t3, l2, c, m3, o);
        default:
          b("");
      }
      break;
    default:
      b("");
  }
}
function am(t3, e5, s4 = true) {
  if (!s4 && !hm(t3, e5)) return 0;
  const n6 = t3.isLine() && e5.isLine();
  if (t3.getStartXY().equals(e5.getStartXY()) && t3.getEndXY().equals(e5.getEndXY())) {
    const s5 = 1;
    if (n6) return s5;
    const r = t3.getGeometryType();
    if (r !== e5.getGeometryType()) return 0;
    if (r === a.enumBezier) {
      const n7 = t3, i2 = e5;
      return n7.getControlPoint1().equals(i2.getControlPoint1()) && n7.getControlPoint2().equals(i2.getControlPoint2()) ? s5 : 0;
    }
    if (r === a.enumEllipticArc) {
      return em(t3, e5, false) ? s5 : 0;
    }
    if (r === a.enumRationalBezier2) {
      const n7 = t3, i2 = e5;
      if (n7.getControlPoint1().equals(i2.getControlPoint1()) && n7.getStandardFormWeight() === i2.getStandardFormWeight()) return s5;
    } else if (r === a.enumBezier2) {
      const n7 = e5;
      if (t3.getControlPoint1().equals(n7.getControlPoint1())) return s5;
    }
    return 0;
  }
  if (t3.getStartXY().equals(e5.getEndXY()) && t3.getEndXY().equals(e5.getStartXY())) {
    const s5 = -1;
    if (n6) return s5;
    const r = t3.getGeometryType();
    if (r !== e5.getGeometryType()) return 0;
    if (r === a.enumBezier) {
      const n7 = t3, i2 = e5;
      return n7.getControlPoint1().equals(i2.getControlPoint2()) && n7.getControlPoint2().equals(i2.getControlPoint1()) ? s5 : 0;
    }
    if (r === a.enumEllipticArc) {
      return em(t3, e5, true) ? s5 : -1;
    }
    if (r === a.enumRationalBezier2) {
      const n7 = t3, i2 = e5;
      if (n7.getControlPoint1().equals(i2.getControlPoint1()) && n7.getStandardFormWeight() === i2.getStandardFormWeight()) return s5;
    } else if (r === a.enumBezier2) {
      const n7 = e5;
      if (t3.getControlPoint1().equals(n7.getControlPoint1())) return s5;
    }
    return 0;
  }
  return 0;
}
function hm(t3, e5) {
  const s4 = t3.getGeometryType();
  return s4 === e5.getGeometryType() && (s4 !== a.enumEllipticArc || t3.projectionBehavior() === e5.projectionBehavior());
}
function um(t3, s4, n6, r, o, a2, u) {
  !o && a2 && P("");
  const m3 = s4.getGeometryType(), l2 = n6.getGeometryType(), c = Math.max(u, rs2(s4, n6));
  if (r && (r.length = 0), o && (o.length = 0), a2 && (a2.length = 0), m3 === a.enumLine && l2 === a.enumLine) return Ds2(s4, n6, r, o, a2, c, false, false);
  let g2 = s4, d2 = n6, _ = s4.getStartXY(), p3 = s4.getEndXY(), f3 = false, P5 = false;
  _.compare(p3) > 0 && (g2 = s4.clone(true).reverse(), f3 = true), _ = n6.getStartXY(), p3 = n6.getEndXY(), _.compare(p3) > 0 && (d2 = n6.clone(true).reverse(), P5 = true);
  let y2 = 0;
  switch (m3) {
    case a.enumLine:
      switch (l2) {
        case a.enumEllipticArc:
          y2 = Qu(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        case a.enumBezier:
          y2 = To(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = nh(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = Vi(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        default:
          b("");
      }
      break;
    case a.enumEllipticArc:
      switch (l2) {
        case a.enumLine:
          y2 = Qu(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = Ju(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = Io(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = ih(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = Li(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        default:
          b("");
      }
      break;
    case a.enumRationalBezier2:
      switch (l2) {
        case a.enumLine:
          y2 = nh(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = ih(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = Yo(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = rh(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumBezier2:
          y2 = oh(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    case a.enumBezier2:
      switch (l2) {
        case a.enumLine:
          y2 = Vi(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = Li(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = No(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = oh(t3, d2, g2, r, a2, o, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = Ri(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    case a.enumBezier:
      switch (l2) {
        case a.enumLine:
          y2 = To(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = Io(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = Mo(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumRationalBezier2:
          y2 = Yo(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        case a.enumBezier2:
          y2 = No(t3, g2, d2, r, o, a2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    default:
      b("");
  }
  if (f3) {
    if (o) {
      for (let t4 = 0; t4 < y2; t4++) o[t4] = 1 - o[t4];
      o.reverse();
    }
    r && r.reverse(), a2 && a2.reverse();
  }
  if (P5 && a2) for (let e5 = 0; e5 < y2; e5++) a2[e5] = 1 - a2[e5];
  return y2;
}
function mm(t3, e5, s4) {
  if (e5 === s4) return 0;
  e5 > s4 && (s4 = Pt(e5, e5 = s4));
  return t3.cut(e5, s4, true).calculateUpperLength2D();
}
function lm(t3, e5, s4, n6, i2) {
  const r = [], o = [], a2 = [];
  for (let u = 0, m3 = i2; u < m3; u++) r.push(t3.calculateSubLengthFromStart(s4[u])), o.push(e5.calculateSubLengthFromStart(n6[u])), Vs(s4[u], 0, 1) && Vs(n6[u], 0, 1) && t3.getCoord2D(s4[u]).equals(e5.getCoord2D(n6[u])) && a2.push(u);
  if (0 === a2.length || a2.length === i2) return;
  a2.sort((t4, e6) => s4[t4] < s4[e6] ? -1 : s4[t4] > s4[e6] ? 1 : n6[t4] < n6[e6] ? -1 : n6[t4] > n6[e6] ? 1 : 0);
  let h2 = -1;
  for (const u of a2) {
    if (h2 >= 0 && s4[u] === s4[h2] && s4[u] === s4[h2]) {
      h2 = u;
      continue;
    }
    h2 = u;
    const a3 = [];
    a3.length = i2;
    for (let t4 = 0; t4 < a3.length; ++t4) a3[t4] = t4;
    a3.sort((t4, e6) => {
      const s5 = r[u], n7 = o[u], i3 = r[t4] - s5, a4 = o[t4] - n7, h3 = i3 * i3 + a4 * a4, m3 = r[e6] - s5, l2 = o[e6] - n7, c = m3 * m3 + l2 * l2;
      return h3 < c ? -1 : h3 > c ? 1 : 0;
    });
    for (let r2 = 0; r2 < i2; r2++) {
      const i3 = a3[r2];
      if (i3 === u || s4[i3] === s4[u] && n6[i3] === n6[u] || Vs(s4[i3], 0, 1) && Vs(n6[i3], 0, 1)) continue;
      const o2 = (s5, n7, i4, r3) => {
        const o3 = new Ye(), a4 = new p2();
        a4.setWithEps(1);
        const h4 = new p2();
        h4.set(n7, a4.eps()), t3.queryCoord2DE(h4, o3);
        const u2 = new Ye();
        t3.queryCoord2DE(new p2(s5), u2);
        let m4 = false;
        return o3.eq(u2) && (h4.set(r3, a4.eps()), e5.queryCoord2DE(h4, o3), e5.queryCoord2DE(new p2(i4), u2), m4 = o3.eq(u2)), !m4;
      }, h3 = mi.getNAN();
      t3.queryCoord2D(s4[i3], h3);
      const m3 = mi.getNAN();
      e5.queryCoord2D(n6[i3], m3);
      if (0 === mi.distance(h3, m3) && o2(s4[u], s4[i3], n6[u], n6[i3])) break;
      const l2 = new x2(n6[i3], n6[u]);
      l2.normalizeNoNAN();
      const c = new x2(s4[i3], s4[u]);
      c.normalizeNoNAN();
      let g2 = -1, d2 = Number.POSITIVE_INFINITY, _ = Number.POSITIVE_INFINITY, p3 = s4[i3];
      h3.assign(t3.getCoord2D(p3));
      for (let r3 = 0; r3 < 5; r3++) {
        const r4 = e5.getClosestCoordinateOnInterval(h3, l2, -1);
        m3.assign(e5.getCoord2D(r4));
        const a4 = mi.distance(h3, m3);
        if (p3 = t3.getClosestCoordinateOnInterval(m3, c, -1), p3 === s4[u] && r4 === n6[u]) {
          g2 = 1;
          break;
        }
        h3.assign(t3.getCoord2D(p3));
        const f3 = mi.distance(m3, h3);
        if (!(f3 < _ && a4 < d2)) {
          g2 = 0;
          break;
        }
        if (0 === f3 && 0 === a4) {
          o2(s4[u], s4[i3], n6[u], n6[i3]) ? (s4[i3] = p3, n6[i3] = r4, g2 = 0) : g2 = 1;
          break;
        }
        _ = f3, d2 = a4;
      }
      if (-1 === g2 && (g2 = Vs(s4[i3], 0, 1) || Vs(n6[i3], 0, 1) ? 0 : 1), 1 !== g2) break;
      s4[i3] = s4[u], n6[i3] = n6[u];
    }
  }
}
function cm(t3, e5, s4, n6, i2, r, o, a2, h2, u, m3, l2, c) {
  if (!r) return 0;
  const g2 = (t4, e6) => {
    for (let s5 = 0; s5 < r; ++s5) {
      let n7 = e6[s5];
      if (Vs(n7, 0, 1)) {
        n7 = Xs(n7);
        continue;
      }
      const i3 = t4.getCoord2D(n7);
      n7 < 0.5 ? i3.equals(t4.getStartXY()) && mm(t4, 0, n7) <= is(t4) && (e6[s5] = 0) : i3.equals(t4.getEndXY()) && mm(t4, n7, 1) <= is(t4) && (e6[s5] = 1);
    }
  };
  g2(e5, n6), g2(s4, i2), lm(e5, s4, n6, i2, r);
  const d2 = [];
  for (let f3 = 0, P5 = r; f3 < P5; f3++) d2.push(f3);
  const _ = (t4, e6) => c ? Rt(i2[t4], n6[t4], i2[e6], n6[e6]) : Rt(n6[t4], i2[t4], n6[e6], i2[e6]);
  if (d2.length > 1) {
    d2.sort(_);
    const t4 = Math.max(is(e5), is(s4));
    let r2 = 0;
    for (let o2 = 1, a3 = d2.length; o2 < a3; o2++) {
      const a4 = n6[d2[r2]], h3 = n6[d2[o2]], u2 = i2[d2[r2]], m4 = i2[d2[o2]];
      if (a4 !== h3 || u2 !== m4) if (!(mm(e5, a4, h3) <= t4 && mm(s4, u2, m4) <= t4) || Vs(a4, 0, 1) && Vs(u2, 0, 1) || Vs(h3, 0, 1) && Vs(m4, 0, 1)) r2++, d2[r2] = d2[o2];
      else {
        const t5 = mi.distance(e5.getCoord2D(a4), s4.getCoord2D(u2)), n7 = mi.distance(e5.getCoord2D(h3), s4.getCoord2D(m4));
        if (t5 <= n7) continue;
        if (n7 < t5) {
          d2[r2] = d2[o2];
          continue;
        }
      }
    }
    if (d2.length = r2 + 1, 1 === d2.length && 0 !== d2[0] && (n6[0] = n6[d2[0]], i2[0] = i2[d2[0]], d2[0] = 0), d2.length > 2) {
      const t5 = x2.constructEmpty(), r3 = x2.constructEmpty();
      t5.setCoords(n6[d2[0]], n6[d2.at(-1)]), r3.setCoords(i2[d2[0]], i2[d2.at(-1)]);
      let o2 = true;
      for (let e6 = 1, s5 = d2.length - 1; e6 < s5; e6++) if (!t5.containsCoordinate(n6[d2[e6]]) || !r3.containsCoordinate(i2[d2[e6]])) {
        o2 = false;
        break;
      }
      if (o2) {
        const n7 = [0.5, 0.2, 0.7, 0.1, 0.3, 0.4, 0.6, 0.8, 0.9];
        for (let i3 = 0; i3 < n7.length; i3++) {
          let a3 = Q(t5.vmin, t5.vmax, n7[i3]);
          const h3 = e5.getCoord2D(a3);
          if (!s4.isCloserThanDistance(h3, r3, u)) {
            o2 = false;
            break;
          }
          a3 = Q(r3.vmin, r3.vmax, n7[i3]);
          const m4 = s4.getCoord2D(a3);
          if (!e5.isCloserThanDistance(m4, t5, u)) {
            o2 = false;
            break;
          }
        }
      }
      o2 && (d2[1] = d2.at(-1), d2.length = 2);
    }
  }
  if (1 === d2.length && t3) {
    const t4 = 0, r2 = 0;
    ke(e5, s4, n6[0], i2[0], u, 1, [t4], [r2]) && (d2.push(1), n6[1] = t4, i2[1] = r2, d2.sort(_));
  }
  if (m3 && 1 === d2.length) {
    let t4 = true;
    for (let r2 = 0, o2 = d2.length; r2 < o2; r2++) {
      if (Vs(n6[d2[r2]], 0, 1) && Vs(i2[d2[r2]], 0, 1)) {
        if (0 === mi.distance(e5.getCoord2D(n6[d2[r2]]), s4.getCoord2D(i2[d2[r2]]))) continue;
      }
      t4 = false;
      break;
    }
    if (t4) return 0;
  }
  let p3 = 0;
  for (let f3 = 0, P5 = d2.length; f3 < P5; f3++) {
    if (a2 && a2.push(n6[d2[f3]]), h2 && h2.push(i2[d2[f3]]), o) {
      const t4 = mi.getNAN();
      e5.queryCoord2D(n6[d2[f3]], t4), o.push(t4);
    }
    p3++;
  }
  return p3;
}
function gm(t3, e5, s4, n6, i2, r, o, a2, h2) {
  if (Vs(s4, 0, 1) && Vs(n6, 0, 1)) {
    if (0 === mi.distance(t3.getCoord2D(s4), e5.getCoord2D(n6))) {
      const u = 1e-12, m3 = new Ye(), l2 = Number.EPSILON;
      if (t3.queryDerivative(new p2(s4, l2), m3), m3.isTrueZero()) {
        const e6 = 1 === s4 ? -1e-12 : u;
        t3.queryDerivative(new p2(s4, l2).add(e6), m3);
      }
      1 === s4 && m3.negateThis();
      const c = new Ye();
      if (e5.queryDerivative(new p2(n6, l2), c), c.isTrueZero()) {
        const t4 = 1 === s4 ? -1e-12 : u;
        e5.queryDerivative(new p2(n6, l2).add(t4), c);
      }
      1 === n6 && c.negateThis(), m3.isZero() || m3.normalize(), c.isZero() || c.normalize();
      const g2 = m3.dotProduct(c), d2 = m3.crossProduct(c);
      d2.scaleError(3);
      const _ = () => {
        if (h2) return 1e-3;
        {
          const s5 = t3.calculateUpperLength2D(), n7 = e5.calculateUpperLength2D();
          return Math.min(0.01 * i2 / Math.min(s5, n7), 1e-10);
        }
      };
      if (g2.ge(I2) && (d2.isZero() || Math.abs(d2.value()) < _())) {
        return Be(t3, e5, s4, n6, i2, r, o, a2);
      }
    }
  }
  return 0;
}
function dm(t3, e5, n6, i2, r) {
  let o = -1, a2 = -1, h2 = -1, u = -1;
  {
    const s4 = [0, e5], r2 = [e5, 0], m3 = [0, i2], l2 = [i2, 0];
    for (let e6 = 0; e6 < 2 && -1 === o; ++e6) for (let i3 = 0; i3 < 2; ++i3) if (t3[s4[e6]].equals(n6[m3[i3]])) {
      o = s4[e6], a2 = r2[e6], h2 = m3[i3], u = l2[i3];
      break;
    }
  }
  if (-1 === o) {
    const s4 = new De();
    s4.setFromPoints(t3, e5 + 1);
    const o2 = new De();
    return o2.setFromPoints(n6, i2 + 1), o2.inflate(r), s4.isIntersectingW(o2) ? -1 : 0;
  }
  {
    const m3 = Yt(e5 + 1, Number.NaN), l2 = xr(t3, e5 + 1, m3);
    n2(l2 > 1);
    let c = 0, g2 = 0;
    for (let t4 = 0; t4 < l2; ++t4) o === m3[t4] && (g2 = t4, c++), a2 === m3[t4] && c++;
    if (2 !== c) return -1;
    const d2 = Yt(i2 + 1, Number.NaN), _ = xr(n6, i2 + 1, d2);
    n2(_ > 1), c = 0;
    let p3 = 0;
    for (let t4 = 0; t4 < _; ++t4) h2 === d2[t4] && (p3 = t4, c++), u === d2[t4] && c++;
    if (2 !== c) return -1;
    const f3 = t3[m3[(g2 + l2 - 1) % l2]], P5 = t3[m3[(g2 + 1) % l2]], y2 = n6[d2[(p3 + _ - 1) % _]], x4 = n6[d2[(p3 + 1) % _]], C3 = t3[o], v3 = [f3, P5, y2, x4], b2 = [0, 1, 2, 3];
    b2.sort((t4, e6) => mi.compareVectorsOrigin(C3, v3[t4], v3[e6]));
    let S3 = b2[0];
    for (let t4 = 1; t4 < 4; t4++) {
      if (b2[t4] !== (S3 + 1) % 4) return -1;
      S3 = b2[t4];
    }
    {
      const t4 = f3.sub(C3), e6 = x4.sub(C3), s4 = e6.dotProduct(t4);
      if (s4 > 0) {
        const n7 = e6.crossProduct(t4), i3 = Math.abs(Math.atan2(n7, s4)), o2 = i3 * t4.length(), a3 = i3 * e6.length();
        if (o2 <= r || a3 <= r) return -1;
      }
    }
    {
      const t4 = P5.sub(C3), e6 = y2.sub(C3), s4 = e6.dotProduct(t4);
      if (s4 > 0) {
        const n7 = e6.crossProduct(t4), i3 = Math.abs(Math.atan2(n7, s4)), o2 = i3 * t4.length(), a3 = i3 * e6.length();
        if (o2 <= r || a3 <= r) return -1;
      }
    }
    return 1;
  }
}
var _m = z3;
var pm = class _pm extends ds2 {
  constructor(t3) {
    super(t3 || { XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 });
  }
  assignMove(t3) {
    return this !== t3 && (this.m_description = t3.m_description, t3.m_description = null, this.m_attributes = t3.m_attributes, t3.m_attributes = null, this.m_XStart = t3.m_XStart, t3.m_XStart = Number.NaN, this.m_YStart = t3.m_YStart, this.m_XEnd = t3.m_XEnd, t3.m_XEnd = Number.NaN, this.m_YEnd = t3.m_YEnd), this;
  }
  assignCopy(t3) {
    return this !== t3 && t3.copyTo(this), this;
  }
  calculateLowerLength3D() {
    return n2(0), 0;
  }
  calculateUpperLength3D() {
    return n2(0), 0;
  }
  changeEndPoints3D(t3, e5) {
    n2(0);
  }
  getClosestCoordinate3D(t3, e5, n6) {
    return n2(0), 0;
  }
  getBoundary() {
    return Ks(this);
  }
  getAttributeAsDbl(t3, e5, s4) {
    if (0 === e5) return 0 === s4 ? fs2(this, t3) : Ps2(this, t3);
    const n6 = _m.getInterpolation(e5), i2 = this.getStartAttributeAsDbl(e5, s4), r = this.getEndAttributeAsDbl(e5, s4);
    return It(n6, i2, r, t3, _m.getDefaultValue(e5));
  }
  constructFromCoords(t3, e5, s4, n6) {
    this.dropAllAttributes(), this.setStartXYCoords(t3, e5), this.setEndXYCoords(s4, n6);
  }
  construct(t3, e5) {
    this.dropAllAttributes(), this.setStartXY(t3), this.setEndXY(e5);
  }
  construct3D(t3, e5) {
    n2(0);
  }
  constructPoint(t3, e5) {
    this.assignVertexDescription(t3.getDescription()), this.mergeVertexDescription(e5.getDescription()), this.setStart(t3), this.setEnd(e5);
  }
  getGeometryType() {
    return _pm.type;
  }
  queryEnvelope(t3) {
    if (4 === t3.m_EnvelopeType) {
      t3.setEmpty(), t3.assignVertexDescription(this.m_description);
      const e5 = n4.constructEmpty();
      this.queryEnvelope(e5), t3.setEnvelope(e5);
      for (let s4 = 1, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) {
        const e6 = this.m_description.getSemantics(s4);
        for (let n7 = 0, i2 = _m.getComponentCount(e6); s4 < i2; s4++) {
          const s5 = this.queryInterval(e6, n7);
          t3.setIntervalEnvelope(e6, n7, s5);
        }
      }
    } else 2 === t3.m_EnvelopeType ? t3.setCoords({ xmin: this.m_XStart, ymin: this.m_YStart, xmax: this.m_XEnd, ymax: this.m_YEnd }) : 3 === t3.m_EnvelopeType ? (t3.setEmpty(), t3.mergeCoords(this.m_XStart, this.m_YStart, ts(this, 0, 1, 0)), t3.mergeCoords(this.m_XEnd, this.m_YEnd, ts(this, 1, 1, 0))) : z("env type not impl");
  }
  applyTransformation(t3) {
    n2(t3 instanceof x3);
    const e5 = new mi();
    e5.x = this.m_XStart, e5.y = this.m_YStart, t3.transformInPlace(e5), this.m_XStart = e5.x, this.m_YStart = e5.y, e5.x = this.m_XEnd, e5.y = this.m_YEnd, t3.transformInPlace(e5), this.m_XEnd = e5.x, this.m_YEnd = e5.y;
  }
  createInstance() {
    return new _pm({ vd: this.m_description });
  }
  calculateLength2D() {
    return Math.sqrt(Xs2(this));
  }
  calculateLength3D(t3) {
    return n2(0), 0;
  }
  changeEndPoints2D(t3, e5) {
    this.setStartXY(t3), this.setEndXY(e5), this.normalizeAfterEndpointChange();
  }
  queryControlPointsHelper(t3) {
    return n2(t3.length >= 2), t3[0] = this.getStartXY(), t3[1] = this.getEndXY(), 2;
  }
  queryCoord2D(t3, e5) {
    return _s2(this, t3, e5);
  }
  queryCoord3D(t3, e5) {
    n2(0);
  }
  getCoordZ(t3) {
    return ys(this, t3);
  }
  queryCoord2DE(t3, e5) {
    Cs(this, t3, e5);
  }
  queryCoord2DMP(t3, e5) {
    e5.assignPoint2D(this.getStartXY());
    const s4 = Xe.constructPoint2D(this.getEndXY());
    s4.subThis(e5), s4.mulThis(si.constructDouble(t3)), e5.addThis(s4);
  }
  getCoordX(t3) {
    return fs2(this, t3);
  }
  getCoordY(t3) {
    return Ps2(this, t3);
  }
  cut(t3, e5, s4) {
    const n6 = new fm();
    return this.queryCut(t3, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t3, e5, s4, n6) {
    const i2 = s4.createLine();
    n6 && i2.assignVertexDescription(this.m_description);
    const r = mi.getNAN();
    if (_s2(this, t3, r), i2.setStartXYCoords(r.x, r.y), _s2(this, e5, r), i2.setEndXYCoords(r.x, r.y), !n6) for (let o = 1, a2 = this.m_description.getAttributeCount(); o < a2; o++) {
      const s5 = this.m_description.getSemantics(o), n7 = _m.getComponentCount(s5);
      for (let r2 = 0; r2 < n7; r2++) {
        const n8 = this.getAttributeAsDbl(t3, s5, r2);
        i2.setStartAttribute(s5, r2, n8);
        const o2 = this.getAttributeAsDbl(e5, s5, r2);
        i2.setEndAttribute(s5, r2, o2);
      }
    }
  }
  queryDerivative(t3, e5) {
    xs(this, t3, e5);
  }
  getClosestCoordinate(t3, e5) {
    return mi.getClosestCoordinate(this.getStartXY(), this.getEndXY(), t3, e5);
  }
  getClosestCoordinateOnInterval(t3, e5, s4 = -1) {
    const n6 = new mi();
    this.queryCoord2D(e5.vmin, n6);
    const i2 = new mi();
    this.queryCoord2D(e5.vmax, i2);
    const r = mi.getClosestCoordinate(n6, i2, t3, false);
    return us.recalculateParentT(e5.vmin, e5.vmax, r);
  }
  intersectionOfYMonotonicWithAxisX(t3, e5) {
    const s4 = this.m_YEnd - this.m_YStart;
    if (!s4) return t3 === this.m_YEnd ? e5 : Number.NaN;
    const n6 = (t3 - this.m_YStart) / s4;
    let i2 = fs2(this, n6);
    return 1 === n6 && (i2 = this.m_XEnd), i2;
  }
  isCurve() {
    return false;
  }
  isMonotoneQuickAndDirty() {
    return true;
  }
  isDegenerate(t3) {
    const e5 = this.m_XStart - this.m_XEnd, s4 = this.m_YStart - this.m_YEnd;
    return Math.sqrt(e5 * e5 + s4 * s4) <= t3;
  }
  isDegenerate3D(t3, e5) {
    return n2(0), false;
  }
  queryLooseEnvelope(t3) {
    this.queryEnvelope(t3);
  }
  clone(t3) {
    const e5 = new _pm();
    return this.copyTo(e5), e5;
  }
  tToLength(t3) {
    return t3 * this.calculateLength2D();
  }
  lengthToT(t3) {
    const e5 = this.calculateLength2D();
    return 0 !== e5 ? t3 / e5 : 0;
  }
  calculateWeightedAreaCentroid2D(t3) {
    const e5 = new mi();
    return e5.setCoords(0, 0), e5;
  }
  calculateWeightedCentroid2D() {
    return this.getCoord2D(0.5).mul(this.calculateLength2D());
  }
  getTangent(t3) {
    const e5 = mi.getNAN();
    return e5.setSub(this.getEndXY(), this.getStartXY()), e5;
  }
  getDerivative(t3) {
    const e5 = new mi();
    return e5.setSub(this.getEndXY(), this.getStartXY()), e5;
  }
  getCurvature(t3) {
    return 0;
  }
  isIntersectingPoint(t3, e5, s4) {
    return Is(this, t3, e5, s4) >= 0;
  }
  isIntersectingPoint3D(t3, e5, n6, i2, r = 1) {
    return n2(0), false;
  }
  getYMonotonicParts(t3, e5) {
    return 0;
  }
  getMonotonicParts(t3, e5) {
    return 0;
  }
  getMonotonicPartParams(t3, s4) {
    return s4 && (t3 < 2 && P(""), s4[0] = 0, s4[1] = 1), 2;
  }
  intersectionWithAxis2D(t3, e5, s4, n6) {
    if (t3) {
      const t4 = this.m_YEnd - this.m_YStart;
      if (!t4) return e5 === this.m_YEnd ? -1 : 0;
      const i2 = (e5 - this.m_YStart) / t4;
      return i2 < 0 || i2 > 1 ? 0 : (s4 && (s4[0] = fs2(this, i2)), n6 && (n6[0] = i2), 1);
    }
    {
      const t4 = this.m_XEnd - this.m_XStart;
      if (!t4) return e5 === this.m_XEnd ? -1 : 0;
      const i2 = (e5 - this.m_XStart) / t4;
      return i2 < 0 || i2 > 1 ? 0 : (s4 && (s4[0] = Ps2(this, i2)), n6 && (n6[0] = i2), 1);
    }
  }
  calculateUpperLength2D() {
    return this.calculateLength2D();
  }
  calculateLowerLength2D() {
    return this.calculateLength2D();
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  queryLooseEnvelopeOnInterval(t3, e5) {
    if (2 === e5.m_EnvelopeType) {
      let s4 = Us(t3.vmin, 0, 1);
      const n6 = new mi();
      return this.queryCoord2D(s4, n6), e5.setCoords({ pt: n6 }), s4 = Us(t3.vmax, 0, 1), this.queryCoord2D(s4, n6), void e5.mergeNe(n6);
    }
    z("3d dst not impl");
  }
  orientBottomUp() {
    Ss2(this);
  }
  isLine() {
    return true;
  }
  isDegenerateToLineHelper(t3) {
    return true;
  }
  copyIgnoreAttributes(t3) {
    t3.setStartXY(this.getStartXY()), t3.setEndXY(this.getEndXY()), t3.normalizeAfterEndpointChange();
  }
  calculateArea2DHelper() {
    return 0;
  }
  absNormXYZ(t3) {
    return bs2(this, t3);
  }
  absNorm() {
    return this.getStartXY().norm(1) + this.getEndXY().norm(1);
  }
  queryEnvelopeW(t3, e5) {
    e5.setCoords(this.getCoord2D(t3.vmin)), e5.mergeNe(this.getCoord2D(t3.vmax));
  }
  setSegmentFromCoordsForStitcher(t3, e5) {
    vs2(this, t3[0], t3[e5 - 1]);
  }
  writeInBufferStream(t3, e5) {
    return n2(0), 0;
  }
  readFromBufferStream(t3, e5) {
    n2(0);
  }
  snapControlPoints(t3) {
    return false;
  }
  needsSnapControlPoints(t3) {
    return false;
  }
  calculateSpecialPointsForCracking(t3, e5) {
    return 0;
  }
  ensureXYMonotone() {
    return false;
  }
  setCoordsForIntersector(t3, e5, s4) {
    vs2(this, t3, e5);
  }
  static isIntersectingLineLine(t3, e5, s4, n6) {
    return Es(t3, e5, s4, n6);
  }
  static isIntersectingLineLine_(t3, e5, s4, n6) {
    return Es(t3, e5, s4, n6);
  }
  copyToImpl(t3) {
  }
  reverseImpl() {
  }
  equalsImpl(t3) {
    return true;
  }
  equalsImplTol(t3, e5) {
    return true;
  }
  swapImpl(t3) {
  }
  afterCompletedModification() {
  }
  endPointModified() {
  }
  clearEndPointModified() {
  }
  intersect(t3, e5, s4, n6, i2) {
    return um(false, this, t3, e5, s4, n6, i2);
  }
  intersectPoint(t3, e5, s4) {
    e5.length < 1 && A("");
    const i2 = Is(this, t3, s4, false);
    return i2 >= 0 ? (e5 && (e5[0] = i2), 1) : 0;
  }
  isIntersecting(t3, e5, s4) {
    return 0 !== rm(false, this, t3, e5, s4);
  }
};
pm.type = a.enumLine;
var fm = class _fm {
  constructor(t3) {
    this.m_seg = null, this.m_curves = null, this.m_lineBuffer = new pm(), this.m_mask = 0, this.m_active = 0, void 0 !== t3 && (t3.copy ? t3.copy.copyTo(this, false) : t3.move ? this.assignMove(t3.move) : t3.segment ? this.copyFrom(t3.segment, !!t3.bIgnoreAttributes) : b("bad constructor params"));
  }
  assignCopy(t3) {
    return t3 instanceof _fm ? this !== t3 && t3.copyTo(this, false) : this.copyFrom(t3, false), this;
  }
  assignMove(t3) {
    if (t3 instanceof _fm) {
      if (this === t3) return this;
      this.reset(), 1 & t3.m_mask && (this.m_lineBuffer = t3.m_lineBuffer, t3.m_lineBuffer = null, this.m_mask = 1), this.m_curves = t3.m_curves, this.m_mask = t3.m_mask, this.m_active = t3.m_active, t3.reset(), this.m_seg = this.activeSegment(), t3.m_seg = null;
    } else {
      if (this.m_seg === t3) return this;
      this.create(t3.getGeometryType()), this.m_seg.swap(t3);
    }
    return this;
  }
  activeSegment() {
    switch (this.m_active) {
      case 0:
        return null;
      case 1:
        return this.line();
      case 2:
        return this.arc();
      case 4:
        return this.bezier3();
      case 8:
        return this.bezier2();
      case 16:
        return this.rbezier2();
      default:
        b("");
    }
  }
  get() {
    return this.m_seg;
  }
  reset() {
    1 & this.m_mask && (this.m_lineBuffer = null), this.m_mask > 1 && (this.m_curves = null), this.m_mask = 0, this.m_active = 0;
  }
  empty() {
    return null === this.m_seg;
  }
  copyTo(t3, e5) {
    this !== t3 && (this.empty() ? t3.m_seg = null : t3.copyFrom(this.m_seg, e5));
  }
  copyToWithZ(t3, e5) {
    n2(0);
  }
  createImpl(t3) {
    switch (t3) {
      case a.enumLine:
        1 & this.m_mask || (this.m_lineBuffer = new pm(), this.m_mask |= 1, this.m_active = 1);
        break;
      case a.enumEllipticArc:
        2 & this.m_mask || (this.m_curves = new Xh(), this.m_mask = 1 & this.m_mask | 2, this.m_active = 2);
        break;
      case a.enumBezier:
        4 & this.m_mask || (this.m_curves = new ia(), this.m_mask = 1 & this.m_mask | 4, this.m_active = 4);
        break;
      case a.enumBezier2:
        8 & this.m_mask || (this.m_curves = new wn(), this.m_mask = 1 & this.m_mask | 8, this.m_active = 8);
        break;
      case a.enumRationalBezier2:
        16 & this.m_mask || (this.m_curves = new En(), this.m_mask = 1 & this.m_mask | 16, this.m_active = 16);
        break;
      default:
        P("");
    }
  }
  create(t3) {
    t3 === a.enumLine ? this.createLine() : t3 === a.enumEllipticArc ? this.createEllipticArc() : t3 === a.enumBezier ? this.createCubicBezier() : t3 === a.enumRationalBezier2 ? this.createQuadraticRationalBezier() : t3 === a.enumBezier2 ? this.createQuadraticBezier() : P("Segment_buffer.create");
  }
  copyFrom(t3, e5) {
    this.m_seg !== t3 && (this.create(t3.getGeometryType()), e5 ? t3.copyIgnoreAttributes(this.m_seg) : t3.copyTo(this.m_seg));
  }
  copyFromWithZ(t3, e5) {
    n2(0);
  }
  line() {
    return this.m_lineBuffer;
  }
  arc() {
    return this.m_curves;
  }
  bezier3() {
    return this.m_curves;
  }
  bezier2() {
    return this.m_curves;
  }
  rbezier2() {
    return this.m_curves;
  }
  createLine() {
    return this.createImpl(a.enumLine), this.m_seg = this.line(), this.line();
  }
  createEllipticArc() {
    return this.createImpl(a.enumEllipticArc), this.m_seg = this.arc(), this.arc();
  }
  createCubicBezier() {
    return this.createImpl(a.enumBezier), this.m_seg = this.bezier3(), this.bezier3();
  }
  createQuadraticRationalBezier() {
    return this.createImpl(a.enumRationalBezier2), this.m_seg = this.rbezier2(), this.rbezier2();
  }
  createQuadraticBezier() {
    return this.createImpl(a.enumBezier2), this.m_seg = this.bezier2(), this.bezier2();
  }
  releaseSegment() {
    if (this.m_seg = null, 0 === this.m_active && b("releaseSegment"), 1 & this.m_active) {
      const t4 = this.line();
      return this.m_mask -= 1, this.m_active = 0, this.m_lineBuffer = null, t4;
    }
    let t3;
    return 2 & this.m_active ? t3 = this.arc() : 4 & this.m_active ? t3 = this.bezier3() : 8 & this.m_active ? t3 = this.bezier2() : 16 & this.m_active ? t3 = this.rbezier2() : b("releaseSegment"), this.m_mask -= this.m_active, this.m_active = 0, this.m_curves = null, t3;
  }
  equals(t3) {
    return t3 instanceof _fm ? this === t3 || (this.empty() ? t3.empty() : !t3.empty() && this.get().equals(t3.get())) : (z("seg comparison not yet impl"), false);
  }
};

// node_modules/@arcgis/core/chunks/OperatorClip.js
function f2(e5, t3, s4, i2, n6) {
  return v2(e5, t3, null, s4, i2, n6);
}
function v2(e5, s4, o, x4, p3, c) {
  const l2 = e5.getGeometryType();
  if (l2 === a.enumPoint) {
    const t3 = e5.getXY();
    return s4.contains(t3) ? e5 : e5.createInstance();
  }
  if (l2 === a.enumEnvelope) {
    const t3 = n4.constructEmpty();
    if (e5.queryEnvelope(t3), t3.intersect(s4)) {
      const s5 = e5.clone();
      return s5.setEnvelope(t3), s5;
    }
    return e5.createInstance();
  }
  if (e5.isEmpty()) return e5;
  if (s4.isEmpty()) return e5.createInstance();
  const _ = s4.clone();
  {
    const t3 = new n4();
    if (e5.queryLooseEnvelope(t3), _.containsEnvelope(t3)) return e5;
    if (!_.isIntersecting(t3)) return e5.createInstance();
    0 === p3 && (t3.intersect(_), t3.inflate(Math.max(0.1 * t3.maxDimension(), 1)), t3.intersect(_), _.assign(t3));
  }
  let u = x4;
  if ((null !== o || Number.isNaN(u)) && (u = At(o, _, false).total()), l2 === a.enumGeometryCollection) {
    const t3 = e5, s5 = e5.createInstance();
    for (let e6 = 0, i2 = t3.getGeometryCount(); e6 < i2; e6++) {
      const i3 = t3.getGeometry(e6);
      if (i3.isEmpty()) continue;
      const n6 = f2(i3, _, u, p3, c);
      n6.isEmpty() || (n6 === i3 ? s5.addGeometry(n6.clone()) : s5.addGeometry(n6));
    }
    return s5;
  }
  y(l2) || P("Clip: geometry not supported");
  const g2 = e5.getImpl().getAccelerators();
  if (null !== g2) {
    const e6 = g2.getRasterizedGeometry();
    n2(null === e6);
  }
  switch (l2) {
    case a.enumMultiPoint: {
      const t3 = e5;
      let s5;
      const i2 = t3.getPointCount(), n6 = t3.getImpl().getAttributeStreamRef(0);
      let h2 = 0;
      for (let e6 = 0; e6 < i2; e6++) {
        const i3 = n6.readPoint2D(2 * e6);
        _.contains(i3) || (0 === h2 && (s5 = t3.createInstance()), h2 < e6 && s5.addPoints(t3, h2, e6), h2 = e6 + 1);
      }
      return h2 > 0 && s5.addPoints(t3, h2, i2), 0 === h2 ? t3 : (n2(null !== s5), s5);
    }
    case a.enumPolygon:
    case a.enumPolyline:
      return P4(e5, _, u, p3, c);
    default:
      b("");
  }
}
function d(e5, t3, s4, i2, n6, r) {
  const h2 = new E(t3, r), m3 = new n4();
  return e5.queryLooseEnvelope(m3), t3.containsEnvelope(m3) ? e5 : t3.isIntersecting(m3) ? h2.clipPolesOut(e5, n6) : e5.createInstance();
}
function P4(e5, t3, s4, i2, n6) {
  return new E(t3, n6).clipMultiPath2(e5, s4, i2);
}
var E = class _E {
  constructor(e5, t3) {
    this.m_shape = new Pr(), this.m_geometry = cr, this.m_verticesOnExtentIndex = -1, this.m_verticesOnExtent = [], this.m_progressCounter = 0, this.m_extent = new n4(e5), this.m_progressTracker = t3;
  }
  progress_() {
  }
  clipMultiPath2(e5, t3, s4) {
    return e5.getGeometryType() === a.enumPolygon ? this.clipPolygonOrProjectedPolyline2(e5, s4) : this.clipPolyline(e5, t3);
  }
  clipPolygonOrProjectedPolyline2(e5, t3) {
    const s4 = e5.getGeometryType() === a.enumPolyline;
    if (0 === this.m_extent.width() || 0 === this.m_extent.height()) return e5.createInstance();
    const n6 = n4.constructEmpty();
    e5.queryLooseEnvelope(n6), this.m_geometry = s4 ? this.m_shape.addGeometry(e5) : this.m_shape.addGeometry(e5, this.m_extent);
    const h2 = n4.constructEmpty(), m3 = n4.constructEmpty(), o = new mi(), c = new mi(), g2 = Yt(9, Number.NaN), y2 = Yt(9, Number.NaN), f3 = Ot(mi, 9);
    let v3 = null;
    const d2 = new pm(), P5 = [];
    let I4 = false;
    for (let i2 = 0; !I4 && i2 < 4; i2++) {
      let e6 = false;
      const t4 = !!(1 & i2);
      let a2 = 0;
      switch (i2) {
        case 0:
          a2 = this.m_extent.xmin, e6 = n6.xmin <= a2 && n6.xmax >= a2;
          break;
        case 1:
          a2 = this.m_extent.ymin, e6 = n6.ymin <= a2 && n6.ymax >= a2;
          break;
        case 2:
          a2 = this.m_extent.xmax, e6 = n6.xmin <= a2 && n6.xmax >= a2;
          break;
        case 3:
          a2 = this.m_extent.ymax, e6 = n6.ymin <= a2 && n6.ymax >= a2;
      }
      if (e6) {
        I4 = true;
        for (let e7 = this.m_shape.getFirstPath(this.m_geometry); e7 !== cr; ) {
          let n7 = true, p3 = -1, l2 = -1;
          const _ = this.m_shape.getFirstVertex(e7);
          let u = _;
          do {
            this.progress_(), v3 = this.m_shape.getSegment(u);
            let e8 = v3;
            if (null === e8) {
              const t5 = this.m_shape.getNextVertex(u);
              if (t5 === cr) {
                n2(s4), 0 === p3 && P5.push(u);
                break;
              }
              this.m_shape.queryXY(u, o), d2.setStartXY(o), this.m_shape.queryXY(t5, c), d2.setEndXY(c), e8 = d2;
            }
            e8.queryLooseEnvelope(h2);
            let _2 = _E.checkSegmentIntersection(h2, i2, a2);
            e8.isCurve() && 0 === _2 && e8.isCurve() && (d2.setStartXY(e8.getStartXY()), d2.setEndXY(e8.getEndXY()), this.m_shape.replaceCurveWithLine(u), e8 = d2, d2.queryEnvelope(h2), _2 = _E.checkSegmentIntersection(h2, i2, a2));
            let V5 = 0, X3 = cr;
            if (-1 === _2) {
              const s5 = e8.intersectionWithAxis2D(t4, a2, g2, y2);
              if (s5 > 0) {
                let i3 = null;
                if (e8.isCurve()) {
                  i3 = f3, n2(s5 <= 9);
                  for (let e9 = 0; e9 < s5; e9++) t4 ? f3[e9].setCoords(g2[e9], a2) : f3[e9].setCoords(a2, g2[e9]);
                  V5 = this.m_shape.splitSegmentAxisAware(u, y2, s5, i3, t4 ? 1 : 0);
                } else V5 = this.m_shape.splitSegmentAxisAware(u, y2, s5, null, -1);
              } else V5 = 0;
              V5 += 1;
              let h3 = u, x4 = this.m_shape.getNextVertex(h3);
              e8 = null;
              for (let e9 = 0; e9 < V5; e9++) {
                this.m_shape.queryXY(h3, o), this.m_shape.queryXY(x4, c), v3 = this.m_shape.getSegment(h3);
                let e10 = v3;
                null === e10 && (d2.setStartXY(o), d2.setEndXY(c), e10 = d2), e10.queryEnvelope(m3);
                let s6 = _E.checkSegmentIntersection(m3, i2, a2);
                if (e10.isCurve() && 0 === s6 && (this.m_shape.replaceCurveWithLine(h3), d2.setStartXY(o), d2.setEndXY(c), e10 = d2, e10.queryEnvelope(m3), s6 = _E.checkSegmentIntersection(m3, i2, a2)), -1 === s6) {
                  if (t4) {
                    Math.abs(o.y - a2) < Math.abs(c.y - a2) ? (o.y = a2, this.m_shape.setXY(h3, o)) : (c.y = a2, this.m_shape.setXY(x4, c));
                  } else {
                    Math.abs(o.x - a2) < Math.abs(c.x - a2) ? (o.x = a2, this.m_shape.setXY(h3, o)) : (c.x = a2, this.m_shape.setXY(x4, c));
                  }
                  v3 = this.m_shape.getSegment(h3), e10 = v3, null === e10 && (d2.setStartXY(o), d2.setEndXY(c), e10 = d2), e10.queryEnvelope(m3), s6 = _E.checkSegmentIntersection(m3, i2, a2), -1 === s6 && (s6 = _E.checkSegmentIntersectionLoose(m3, i2, a2));
                }
                const r = p3;
                p3 = s6, -1 === l2 && (l2 = p3), 0 === r && 1 === p3 || 1 === r && 0 === p3 || 0 === r && 0 === p3 && P5.push(h3), 1 === p3 && (I4 = false, n7 = false), h3 = x4, X3 = h3, x4 = this.m_shape.getNextVertex(x4);
              }
            }
            if (0 === V5) {
              const e9 = p3;
              p3 = _2, -1 === l2 && (l2 = p3), 0 === e9 && p3 >= 1 || e9 >= 1 && 0 === p3 || 0 === e9 && 0 === p3 && P5.push(u), 1 === p3 && (I4 = false, n7 = false), X3 = this.m_shape.getNextVertex(u);
            }
            if (u = X3, P5.length >= 256) {
              for (let e9 = 1, t5 = P5.length - 1; e9 < t5; e9++) {
                const t6 = P5[e9];
                s4 ? this.m_shape.snapVertexForPoleClipping(t6, a2) : this.m_shape.removeVertex(t6, false);
              }
              P5[1] = P5.at(-1), P5.length = 2;
            }
          } while (u !== _);
          if (!n7) {
            0 !== l2 || !s4 && 0 !== p3 && 2 !== p3 || P5.push(_);
            for (let e8 = 0, t5 = P5.length; e8 < t5; e8++) {
              const t6 = P5[e8];
              s4 ? this.m_shape.snapVertexForPoleClipping(t6, a2) : this.m_shape.removeVertex(t6, false);
            }
          }
          P5.length = 0, e7 = n7 || 0 === this.m_shape.getPathSize(e7) ? this.m_shape.removePath(e7) : this.m_shape.getNextPath(e7);
        }
      }
    }
    if (I4) return e5.createInstance();
    v3 = null, s4 ? this.removeSpikesAlongPoles() : this.resolveBoundaryOverlaps(), t3 > 0 && this.densifyAlongClipExtent(t3);
    const V4 = this.m_shape.getGeometry(this.m_geometry);
    if (V4.getGeometryType() === a.enumPolygon) {
      V4.setFillRule(e5.getFillRule());
    }
    return V4;
  }
  clipPolyline(e5, t3) {
    const s4 = n4.constructEmpty(), i2 = n4.constructEmpty(), n6 = Yt(9, Number.NaN), r = Yt(9, Number.NaN), h2 = new fm();
    let m3 = e5;
    const o = n4.constructEmpty();
    e5.queryLooseEnvelope(o);
    for (let a2 = 0; a2 < 4; a2++) {
      let t4 = false;
      const x4 = !!(1 & a2);
      let p3 = 0;
      switch (a2) {
        case 0:
          p3 = this.m_extent.xmin, t4 = o.xmin <= p3 && o.xmax >= p3;
          break;
        case 1:
          p3 = this.m_extent.ymin, t4 = o.ymin <= p3 && o.ymax >= p3;
          break;
        case 2:
          p3 = this.m_extent.xmax, t4 = o.xmin <= p3 && o.xmax >= p3;
          break;
        case 3:
          p3 = this.m_extent.ymax, t4 = o.ymin <= p3 && o.ymax >= p3;
      }
      if (!t4) continue;
      const c = m3;
      m3 = e5.createInstance();
      const l2 = c.getImpl().querySegmentIterator();
      l2.resetToFirstPath();
      const _ = new mi(), g2 = new mi();
      for (; l2.nextPath(); ) {
        let e6 = -1, t5 = true;
        for (; l2.hasNextSegment(); ) {
          this.progress_();
          const o2 = l2.nextSegment(), c2 = o2.isDegenerate(0);
          o2.queryLooseEnvelope(s4);
          const u = _E.checkSegmentIntersection(s4, a2, p3);
          if (-1 === u) {
            const s5 = o2.intersectionWithAxis2D(x4, p3, n6, r);
            let l3 = 0;
            _.assign(o2.getStartXY());
            for (let u2 = 0; u2 <= s5; u2++) {
              const y2 = u2 < s5 ? r[u2] : 1;
              if (l3 === y2) continue;
              o2.queryCut(l3, y2, h2, false);
              const f3 = h2.get();
              let v3 = false;
              if (f3.getStartXY().equals(_) || (f3.setStartXY(_), v3 = true), u2 < s5 && (x4 ? (g2.x = n6[u2], g2.y = p3) : (g2.x = p3, g2.y = n6[u2]), f3.getEndXY().equals(g2) || (f3.setEndXY(g2), v3 = true)), v3 && f3.normalizeAfterEndpointChange(), !c2 && f3.isDegenerate(0)) continue;
              f3.queryEnvelope(i2);
              let d2 = _E.checkSegmentIntersection(i2, a2, p3);
              if (-1 === d2) {
                const e7 = f3.getStartXY(), t6 = f3.getEndXY();
                if (v3 = false, x4) {
                  Math.abs(e7.y - p3) < Math.abs(t6.y - p3) ? (e7.y = p3, f3.setStartXY(e7), e7.equals(f3.getStartXY()) || (f3.setStartXY(e7), v3 = true)) : (t6.y = p3, t6.equals(f3.getEndXY()) || (f3.setEndXY(t6), v3 = true));
                } else {
                  Math.abs(e7.x - p3) < Math.abs(t6.x - p3) ? (e7.x = p3, e7.equals(f3.getStartXY()) || (f3.setStartXY(e7), v3 = true)) : (t6.x = p3, t6.equals(f3.getEndXY()) || (f3.setEndXY(t6), v3 = true));
                }
                v3 && f3.normalizeAfterEndpointChange(), f3.queryEnvelope(i2), d2 = _E.checkSegmentIntersection(i2, a2, p3), -1 === d2 && (d2 = _E.checkSegmentIntersectionLoose(i2, a2, p3));
              }
              _.assign(f3.getEndXY()), l3 = y2, e6 = d2, e6 >= 1 ? (m3.addSegment(f3, t5), t5 = false) : t5 = true;
            }
          } else e6 = u, e6 >= 1 ? (m3.addSegment(o2, t5), t5 = false) : t5 = true;
        }
      }
    }
    return m3;
  }
  static checkSegmentIntersection(e5, t3, s4) {
    switch (t3) {
      case 0:
        return e5.xmin < s4 && e5.xmax <= s4 ? 0 : e5.xmin >= s4 ? e5.xmax === s4 ? 2 : 1 : -1;
      case 1:
        return e5.ymin < s4 && e5.ymax <= s4 ? 0 : e5.ymin >= s4 ? e5.ymax === s4 ? 2 : 1 : -1;
      case 2:
        return e5.xmin >= s4 && e5.xmax > s4 ? 0 : e5.xmax <= s4 ? e5.xmin === s4 ? 2 : 1 : -1;
      case 3:
        return e5.ymin >= s4 && e5.ymax > s4 ? 0 : e5.ymax <= s4 ? e5.ymin === s4 ? 2 : 1 : -1;
    }
    return b(""), 0;
  }
  static checkSegmentIntersectionLoose(e5, t3, s4) {
    switch (t3) {
      case 0: {
        const t4 = Math.abs(e5.xmin - s4), i2 = Math.abs(e5.xmax - s4);
        return e5.xmin < s4 ? t4 > i2 ? 0 : 1 : (b(""), 1);
      }
      case 1: {
        const t4 = Math.abs(e5.ymin - s4), i2 = Math.abs(e5.ymax - s4);
        return e5.ymin < s4 ? t4 > i2 ? 0 : 1 : (b(""), 1);
      }
      case 2: {
        const t4 = Math.abs(e5.xmin - s4), i2 = Math.abs(e5.xmax - s4);
        return e5.xmax > s4 ? t4 < i2 ? 0 : 1 : (b(""), 1);
      }
      case 3: {
        const t4 = Math.abs(e5.ymin - s4), i2 = Math.abs(e5.ymax - s4);
        return e5.ymax > s4 ? t4 < i2 ? 0 : 1 : (b(""), 1);
      }
    }
    return b(""), 0;
  }
  resolveBoundaryOverlaps() {
    this.m_verticesOnExtentIndex = -1, this.splitSegments(false, this.m_extent.xmin), this.splitSegments(false, this.m_extent.xmax), this.splitSegments(true, this.m_extent.ymin), this.splitSegments(true, this.m_extent.ymax), this.m_verticesOnExtent.length = 0, this.m_verticesOnExtentIndex = this.m_shape.createUserIndex();
    const e5 = new mi();
    for (let t3 = this.m_shape.getFirstPath(this.m_geometry); t3 !== cr; t3 = this.m_shape.getNextPath(t3)) {
      let s4 = this.m_shape.getFirstVertex(t3);
      for (let i2 = 0, n6 = this.m_shape.getPathSize(t3); i2 < n6; i2++, s4 = this.m_shape.getNextVertex(s4)) this.progress_(), this.m_shape.queryXY(s4, e5), this.m_extent.xmin !== e5.x && this.m_extent.xmax !== e5.x && this.m_extent.ymin !== e5.y && this.m_extent.ymax !== e5.y || (this.m_shape.setUserIndex(s4, this.m_verticesOnExtentIndex, this.m_verticesOnExtent.length), this.m_verticesOnExtent.push(s4));
    }
    this.dbgCheckPathFirst(), this.resolveOverlaps(false, this.m_extent.xmin), this.dbgCheckPathFirst(), this.resolveOverlaps(false, this.m_extent.xmax), this.dbgCheckPathFirst(), this.resolveOverlaps(true, this.m_extent.ymin), this.dbgCheckPathFirst(), this.resolveOverlaps(true, this.m_extent.ymax), this.fixPaths();
  }
  densifyAlongClipExtent(e5) {
    const t3 = new mi(0, 0), s4 = new mi(0, 0), i2 = Yt(2048, Number.NaN);
    for (let n6 = this.m_shape.getFirstPath(this.m_geometry); n6 !== cr; n6 = this.m_shape.getNextPath(n6)) {
      const m3 = this.m_shape.getFirstVertex(n6);
      let a2 = m3;
      do {
        const n7 = this.m_shape.getNextVertex(a2);
        this.m_shape.queryXY(a2, t3);
        let m4 = -1;
        if (t3.x === this.m_extent.xmin ? (this.m_shape.queryXY(n7, s4), s4.x === this.m_extent.xmin && (m4 = 1)) : t3.x === this.m_extent.xmax && (this.m_shape.queryXY(n7, s4), s4.x === this.m_extent.xmax && (m4 = 1)), t3.y === this.m_extent.ymin ? (this.m_shape.queryXY(n7, s4), s4.y === this.m_extent.ymin && (m4 = 0)) : t3.y === this.m_extent.ymax && (this.m_shape.queryXY(n7, s4), s4.y === this.m_extent.ymax && (m4 = 0)), -1 === m4) {
          a2 = n7;
          continue;
        }
        if (this.isCurve(a2)) {
          a2 = n7;
          continue;
        }
        const o = t3.clone(), x4 = new mi(0, 0);
        if (m4) {
          const i3 = t3.y - this.m_extent.ymin;
          x4.y = K(s4.y - t3.y), o.y = e5 * B2(Math.floor(Math.abs(i3) / e5), i3) + this.m_extent.ymin, x4.y < 0 && (o.y += e5);
        } else {
          const i3 = t3.x - this.m_extent.xmin;
          x4.x = K(s4.x - t3.x), o.x = e5 * B2(Math.floor(Math.abs(i3) / e5), i3) + this.m_extent.xmin, x4.x < 0 && (o.x += e5);
        }
        const p3 = m4 ? s4.y - t3.y : s4.x - t3.x, c = Math.abs(p3);
        if (c / e5 > 65536 && b(""), c > 0) {
          const s5 = Math.trunc(c / e5) + 2;
          i2.length < s5 && (i2.length = s5);
          let n8 = 0;
          for (let h2 = 0; ; h2++) {
            const s6 = o.add(x4.mul(h2 * e5)), a3 = (m4 ? s6.y - t3.y : s6.x - t3.x) / p3;
            if (a3 >= 1) break;
            a3 <= 0 || (n2(n8 <= i2.length), i2[n8] = a3, n8++);
          }
          0 !== n8 && this.m_shape.splitSegment(a2, i2, n8);
        }
        a2 = n7;
      } while (a2 !== m3);
    }
  }
  splitSegments(e5, t3) {
    let s4 = -1;
    const i2 = new mi(), n6 = [];
    for (let _ = this.m_shape.getFirstPath(this.m_geometry); _ !== cr; _ = this.m_shape.getNextPath(_)) {
      let r2 = this.m_shape.getFirstVertex(_), h3 = cr;
      for (let m4 = 0, a3 = this.m_shape.getPathSize(_); m4 < a3; m4++, r2 = h3) if (this.progress_(), h3 = this.m_shape.getNextVertex(r2), this.m_shape.queryXY(r2, i2), (e5 ? i2.y === t3 : i2.x === t3) && (this.m_shape.queryXY(h3, i2), e5 ? i2.y === t3 : i2.x === t3)) {
        if (this.isCurve(r2)) continue;
        -1 === s4 && (s4 = this.m_shape.createUserIndex()), 1 !== this.m_shape.getUserIndex(r2, s4) && (n6.push(r2), this.m_shape.setUserIndex(r2, s4, 1)), 1 !== this.m_shape.getUserIndex(h3, s4) && (n6.push(h3), this.m_shape.setUserIndex(h3, s4, 1));
      }
    }
    if (-1 !== s4 && this.m_shape.removeUserIndex(s4), n6.length < 3) return;
    n6.sort((e6, t4) => this.compareVertices(e6, t4));
    const r = new mi(), h2 = new mi(), m3 = new mi();
    h2.setNAN();
    let a2 = -1;
    let o = [], p3 = [];
    const c = this.m_shape.createUserIndex(), l2 = this.m_shape.createUserIndex();
    for (let x4 = 0, _ = n6.length; x4 < _; x4++) {
      const s5 = n6[x4];
      if (this.m_shape.queryXY(s5, i2), !i2.isEqualPoint2D(h2)) {
        if (-1 === a2) {
          a2 = x4, h2.setCoordsPoint2D(i2);
          continue;
        }
        for (let i3 = a2; i3 < x4; i3++) {
          const s7 = n6[i3], m4 = this.m_shape.getNextVertex(s7), a3 = this.m_shape.getPrevVertex(s7);
          let x5 = false;
          this.m_shape.queryXY(m4, r), h2.compare(r) < 0 && (e5 ? r.y === t3 : r.x === t3) && (this.isCurve(s7) || (o.push(s7), x5 = true, this.m_shape.setUserIndex(s7, l2, 1))), this.m_shape.queryXY(a3, r), h2.compare(r) < 0 && (e5 ? r.y === t3 : r.x === t3) && (this.isCurve(a3) || (x5 || o.push(s7), this.m_shape.setUserIndex(s7, c, 1)));
        }
        for (let e6 = 0, t4 = o.length; e6 < t4; e6++) {
          const t5 = o[e6], s7 = this.m_shape.getUserIndex(t5, c), n7 = this.m_shape.getUserIndex(t5, l2);
          if (1 === s7) {
            const e7 = this.m_shape.getPrevVertex(t5);
            this.m_shape.queryXY(e7, m3);
            let s8 = 0;
            if (!m3.isEqualPoint2D(i2)) {
              const n8 = mi.distance(h2, m3);
              s8 = mi.distance(m3, i2) / n8, 0 === s8 ? s8 = Number.EPSILON : 1 === s8 && (s8 = 1 - Number.EPSILON), this.m_shape.splitSegment(e7, [s8], 1);
              const r2 = this.m_shape.getPrevVertex(t5);
              this.m_shape.setXY(r2, i2), p3.push(r2), this.m_shape.setUserIndex(r2, c, 1), this.m_shape.setUserIndex(r2, l2, -1);
            }
          }
          if (1 === n7) {
            const e7 = this.m_shape.getNextVertex(t5);
            this.m_shape.queryXY(e7, m3);
            let s8 = 0;
            if (!m3.isEqualPoint2D(i2)) {
              const e8 = mi.distance(h2, m3);
              s8 = mi.distance(h2, i2) / e8, 0 === s8 ? s8 = Number.EPSILON : 1 === s8 && (s8 = 1 - Number.EPSILON), this.m_shape.splitSegment(t5, [s8], 1);
              const n8 = this.m_shape.getNextVertex(t5);
              this.m_shape.setXY(n8, i2), p3.push(n8), this.m_shape.setUserIndex(n8, c, -1), this.m_shape.setUserIndex(n8, l2, 1);
            }
          }
        }
        const s6 = o;
        o = p3, p3 = s6, p3.length = 0, a2 = x4, h2.setCoordsPoint2D(i2);
      }
    }
    this.m_shape.removeUserIndex(c), this.m_shape.removeUserIndex(l2);
  }
  resolveOverlaps(e5, t3) {
    const s4 = new mi(), i2 = [];
    let n6 = -1;
    for (let r = 0, o = this.m_verticesOnExtent.length; r < o; r++) {
      this.progress_();
      const h3 = this.m_verticesOnExtent[r];
      if (h3 === cr) continue;
      const m4 = this.m_shape.getNextVertex(h3);
      if (this.m_shape.queryXY(h3, s4), (e5 ? s4.y === t3 : s4.x === t3) && (this.m_shape.queryXY(m4, s4), e5 ? s4.y === t3 : s4.x === t3)) {
        if (this.isCurve(h3)) continue;
        -1 === n6 && (n6 = this.m_shape.createUserIndex()), -2 !== this.m_shape.getUserIndex(h3, n6) && (i2.push(h3), this.m_shape.setUserIndex(h3, n6, -2)), -2 !== this.m_shape.getUserIndex(m4, n6) && (i2.push(m4), this.m_shape.setUserIndex(m4, n6, -2));
      }
    }
    if (0 === i2.length) return void (-1 !== n6 && this.m_shape.removeUserIndex(n6));
    n2(-1 !== n6), i2.sort((e6, t4) => this.compareVertices(e6, t4));
    for (let r = 0, o = i2.length; r < o; r++) {
      const e6 = i2[r];
      this.m_shape.setUserIndex(e6, n6, r);
    }
    const h2 = new mi(), m3 = new mi();
    m3.setNAN();
    let a2 = -1;
    for (let r = 0, o = i2.length; r < o; r++) {
      this.progress_();
      const o2 = i2[r];
      if (o2 !== cr && (this.m_shape.queryXY(o2, s4), !s4.isEqualPoint2D(m3))) {
        if (-1 !== a2) for (; ; ) {
          let s5 = false;
          const o3 = r;
          for (let p3 = a2; p3 < o3; p3++) {
            const a3 = i2[p3];
            if (a3 === cr) continue;
            let o4 = cr;
            const c = this.m_shape.getNextVertex(a3);
            this.m_shape.queryXY(c, h2), m3.compare(h2) < 0 && (e5 ? h2.y === t3 : h2.x === t3) && (this.isCurve(a3) || (o4 = c));
            let l2 = cr;
            const _ = this.m_shape.getPrevVertex(a3);
            if (this.m_shape.queryXY(_, h2), m3.compare(h2) < 0 && (e5 ? h2.y === t3 : h2.x === t3) && (this.isCurve(_) || (l2 = _)), o4 === cr || l2 === cr) {
              if (o4 !== cr || l2 !== cr) {
                for (let c2 = p3 + 1; c2 < r; c2++) {
                  const r2 = i2[c2];
                  if (r2 === cr) continue;
                  const p4 = this.m_shape.getNextVertex(r2);
                  let _2 = cr;
                  this.m_shape.queryXY(p4, h2), m3.compare(h2) < 0 && (e5 ? h2.y === t3 : h2.x === t3) && (this.isCurve(r2) || (_2 = p4));
                  const u = this.m_shape.getPrevVertex(r2);
                  let g2 = cr;
                  if (this.m_shape.queryXY(u, h2), m3.compare(h2) < 0 && (e5 ? h2.y === t3 : h2.x === t3) && (this.isCurve(u) || (g2 = u)), _2 !== cr && g2 !== cr) {
                    this.beforeRemoveVertex(r2, i2, n6), this.m_shape.removeVertex(r2, false), this.beforeRemoveVertex(_2, i2, n6), this.m_shape.removeVertex(_2, false), s5 = true;
                    break;
                  }
                  if (o4 !== cr && g2 !== cr) {
                    this.removeOverlap(i2, a3, o4, r2, g2, n6), s5 = true;
                    break;
                  }
                  if (l2 !== cr && _2 !== cr) {
                    this.removeOverlap(i2, r2, _2, a3, l2, n6), s5 = true;
                    break;
                  }
                }
                if (s5) break;
              }
            } else this.beforeRemoveVertex(a3, i2, n6), this.m_shape.removeVertex(a3, false), this.beforeRemoveVertex(o4, i2, n6), this.m_shape.removeVertex(o4, false), s5 = true;
          }
          if (!s5) break;
        }
        a2 = r, m3.setCoordsPoint2D(s4);
      }
    }
    this.m_shape.removeUserIndex(n6);
  }
  beforeRemoveVertex(e5, t3, s4) {
    let i2 = this.m_shape.getUserIndex(e5, s4);
    n2(i2 >= 0), t3[i2] = cr, i2 = this.m_shape.getUserIndex(e5, this.m_verticesOnExtentIndex), n2(i2 >= 0), this.m_verticesOnExtent[i2] = cr;
    const n6 = this.m_shape.getPathFromVertex(e5);
    if (n6 !== cr) {
      this.m_shape.getFirstVertex(n6) === e5 && (this.m_shape.setFirstVertex(n6, cr), this.m_shape.setLastVertex(n6, cr));
    }
  }
  removeOverlap(e5, t3, s4, i2, n6, r) {
    this.m_shape.setNextVertex(t3, i2), this.m_shape.setPrevVertex(i2, t3), this.m_shape.setPrevVertex(s4, n6), this.m_shape.setNextVertex(n6, s4), this.beforeRemoveVertex(i2, e5, r), this.m_shape.removeVertexInternal(i2, false), this.beforeRemoveVertex(n6, e5, r), this.m_shape.removeVertexInternal(n6, true);
  }
  removeSpikesAlongPoles() {
    this.removeSpikesOnPole(this.m_extent.ymin), this.removeSpikesOnPole(this.m_extent.ymax);
  }
  removeSpikesOnPole(e5) {
    for (let t3 = this.m_shape.getFirstPath(this.m_geometry); t3 !== cr; t3 = this.m_shape.getNextPath(t3)) {
      const s4 = this.m_shape.getPathSize(t3);
      if (s4 < 3) continue;
      let i2 = this.m_shape.getFirstVertex(t3);
      const n6 = new mi();
      this.m_shape.queryXY(i2, n6);
      let r = n6.y === e5 && !this.isCurve(i2);
      i2 = this.m_shape.getNextVertex(i2);
      const h2 = new mi();
      this.m_shape.queryXY(i2, h2);
      let m3 = h2.y === e5 && !this.isCurve(i2);
      i2 = this.m_shape.getNextVertex(i2);
      const a2 = new mi();
      for (let t4 = 0, o = s4 - 2; t4 < o; t4++, i2 = this.m_shape.getNextVertex(i2)) {
        this.progress_(), this.m_shape.queryXY(i2, a2);
        const t5 = a2.y === e5;
        if (m3 && r && t5) {
          if ((h2.x - n6.x) * (a2.x - h2.x) <= 0) {
            this.m_shape.removeVertex(this.m_shape.getPrevVertex(i2), false), h2.setCoordsPoint2D(a2), m3 = t5 && !this.isCurve(i2);
            continue;
          }
        }
        n6.setCoordsPoint2D(h2), r = m3, h2.setCoordsPoint2D(a2), m3 = t5 && !this.isCurve(i2);
      }
    }
  }
  fixPaths() {
    for (let n6 = 0, r = this.m_verticesOnExtent.length; n6 < r; n6++) {
      const e6 = this.m_verticesOnExtent[n6];
      e6 !== cr && this.m_shape.setPathToVertex(e6, cr);
    }
    const e5 = this.m_shape.hasCurves();
    let t3 = 0, s4 = 0;
    for (let n6 = this.m_shape.getFirstPath(this.m_geometry); n6 !== cr; ) {
      const e6 = this.m_shape.getFirstVertex(n6);
      if (e6 === cr || n6 !== this.m_shape.getPathFromVertex(e6)) {
        const e7 = n6;
        n6 = this.m_shape.getNextPath(n6), this.m_shape.setFirstVertex(e7, cr), this.m_shape.removePathOnly(e7);
        continue;
      }
      let i3 = e6, r = 0;
      do {
        this.m_shape.setPathToVertex(i3, n6), r++, i3 = this.m_shape.getNextVertex(i3);
      } while (i3 !== e6);
      this.m_shape.setRingAreaValid(n6, false), this.m_shape.setLastVertex(n6, this.m_shape.getPrevVertex(e6)), this.m_shape.setPathSize(n6, r), s4 += r, t3++, n6 = this.m_shape.getNextPath(n6);
    }
    for (let n6 = 0, h2 = this.m_verticesOnExtent.length; n6 < h2; n6++) {
      let i3 = this.m_verticesOnExtent[n6];
      if (i3 === cr) continue;
      let h3 = this.m_shape.getPathFromVertex(i3);
      if (h3 !== cr) continue;
      h3 = this.m_shape.insertPath(this.m_geometry, cr);
      let m3 = false, a2 = 0;
      const o = i3;
      do {
        this.m_shape.setPathToVertex(i3, h3), a2++, e5 && a2 <= 2 && (m3 ||= this.isCurve(i3)), i3 = this.m_shape.getNextVertex(i3);
      } while (i3 !== o);
      if (m3 ? 0 === a2 : a2 <= 2) {
        let e6 = this.m_shape.getUserIndex(o, this.m_verticesOnExtentIndex);
        n2(e6 >= 0), this.m_verticesOnExtent[e6] = cr;
        const t4 = this.m_shape.removeVertex(o, false);
        2 === a2 && (e6 = this.m_shape.getUserIndex(t4, this.m_verticesOnExtentIndex), e6 >= 0 && (this.m_verticesOnExtent[e6] = cr), this.m_shape.removeVertex(t4, false));
        const s5 = h3;
        h3 = this.m_shape.getNextPath(h3), this.m_shape.setFirstVertex(s5, cr), this.m_shape.removePathOnly(s5);
      } else this.m_shape.setClosedPath(h3, true), this.m_shape.setPathSize(h3, a2), this.m_shape.setFirstVertex(h3, o), this.m_shape.setLastVertex(h3, this.m_shape.getPrevVertex(o)), this.m_shape.setRingAreaValid(h3, false), s4 += a2, t3++;
    }
    this.m_shape.setGeometryPathCount(this.m_geometry, t3), this.m_shape.setGeometryVertexCount(this.m_geometry, s4);
    let i2 = 0;
    for (let n6 = this.m_shape.getFirstGeometry(); n6 !== cr; n6 = this.m_shape.getNextGeometry(n6)) i2 += this.m_shape.getPointCount(n6);
    this.m_shape.setTotalPointCount(i2);
  }
  dbgCheckPathFirst() {
  }
  isCurve(e5) {
    return null !== this.m_shape.getSegment(e5);
  }
  compareVertices(e5, t3) {
    const s4 = new mi();
    this.m_shape.queryXY(e5, s4);
    const i2 = new mi();
    this.m_shape.queryXY(t3, i2);
    return s4.compare(i2);
  }
  clipPolesOut(e5, t3) {
    return this.clipPolygonOrProjectedPolyline2(e5, t3);
  }
};
var I3 = class {
  getOperatorType() {
    return 10004;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t3, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  executeMany(e5, t3, s4, i2) {
    return new V3(e5, t3, s4, i2);
  }
  execute(e5, t3, s4, i2) {
    return X2(e5, t3, s4, i2);
  }
};
var V3 = class extends t {
  constructor(e5, s4, i2, n6) {
    super(), this.m_progressTracker = n6, this.m_index = -1, e5 || P(""), this.m_envelope = s4, this.m_inputGeometryCursor = e5, this.m_spatialRefImpl = i2, this.m_tolerance = At(i2, s4, false).total();
  }
  next() {
    let e5;
    return (e5 = this.m_inputGeometryCursor.next()) ? (j(e5), this.m_index = this.m_inputGeometryCursor.getGeometryID(), f2(e5, this.m_envelope, this.m_tolerance, 0, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function X2(e5, t3, s4, i2) {
  return v2(e5, t3, s4, Number.NaN, 0, i2);
}

// node_modules/@arcgis/core/chunks/OperatorDensify.js
var n5 = jh;
var i = class extends t {
  constructor(e5, t3, r, s4, i2, m3) {
    super(), this.m_densificator = new n5(t3, r, s4, m3, false, i2), this.m_index = -1, this.m_inputGeoms = e5;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
  next() {
    let e5 = null;
    for (; e5 = this.m_inputGeoms.next(); ) return j(e5), this.m_index = this.m_inputGeoms.getGeometryID(), this.densify(e5);
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  densify(e5) {
    return this.m_densificator.densify(e5);
  }
};
var m2 = class {
  getOperatorType() {
    return 10202;
  }
  accelerateGeometry(e5, t3, r) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  supportsCurves() {
    return true;
  }
  executeMany(e5, t3, r, s4, n6, m3 = 12e3) {
    return new i(e5, t3, r, s4, m3, n6);
  }
  execute(e5, t3, s4, n6, i2, m3 = 12e3) {
    return zh(e5, t3, s4, n6, i2, m3);
  }
};

// node_modules/@arcgis/core/chunks/ProjectionTransformation.js
var ss2 = class _ss {
  constructor(e5) {
    if (this.m_geom = this.m_sr = null, e5) {
      if (e5.move) return this.m_geom = e5.move.m_geom, e5.move.m_geom = null, this.m_sr = e5.move.m_sr, void (e5.move.m_sr = null);
      if (e5.copy) return this.m_geom = e5.copy.m_geom ? e5.copy.m_geom.clone() : null, void (this.m_sr = e5.copy.m_sr);
      e5.geom && (this.m_geom = e5.geom), e5.sr && (this.m_sr = e5.sr);
    }
  }
  getGeometry() {
    return this.m_geom;
  }
  getSpatialReference() {
    return this.m_sr;
  }
  setGeometry(e5) {
    this.m_geom = e5;
  }
  setSpatialReference(e5) {
    this.m_sr = e5;
  }
  equals(e5, t3) {
    const s4 = e5;
    return !(!this.m_sr && s4.m_sr) && (!(this.m_sr && !s4.m_sr) && (!(!this.m_geom && s4.m_geom) && (!(this.m_geom && !s4.m_geom) && (!(this.m_sr && s4.m_sr && !this.m_sr.equals(s4.m_sr)) && !(this.m_geom && s4.m_geom && !this.m_geom.equals(s4.m_geom, t3))))));
  }
  clone() {
    let e5 = null;
    return this.m_geom && (e5 = this.m_geom.clone()), new _ss({ geom: e5, sr: this.m_sr });
  }
  hasGeom() {
    return !!this.m_geom;
  }
};
var ns2 = class {
  constructor(e5) {
    this.m_factor = 1, this.m_wkid = 0, this.m_peUnit = null, e5 && (this.m_peUnit = e5, this.m_factor = e5.getUnitFactor(), this.m_wkid = e5.getCode(), this.m_wkid < 0 && (this.m_wkid = 0));
  }
  getName() {
    return this.m_peUnit ? this.m_peUnit.getName() : "";
  }
  getID() {
    return this.m_wkid;
  }
  getConversionFactor(e5) {
    return this.getUnitType() !== e5.getUnitType() && P("unit type mismatch"), this.getUnitToBaseFactor() / e5.getUnitToBaseFactor();
  }
  getUnitToBaseFactor() {
    return this.m_factor;
  }
  getHashCode() {
    return As(Zs(this.getUnitType()), Zs(this.getUnitToBaseFactor()));
  }
  equals(e5) {
    return !!e5 && (this.getUnitType() === e5.getUnitType() && this.getUnitToBaseFactor() === e5.getUnitToBaseFactor() && this.getID() === e5.getID() && this.getName() === e5.getName());
  }
  static isValidWkid(e5) {
    return false;
  }
};
var rs3 = { 330: 104878, 500: 104879, 1300: 104899, 1450: 104986, 2230: 104988, 3800: 104978, 5e3: 104919, 6200: 104906, 8200: 104909, 9500: 104927, 9600: 104977, 1e4: [104911, 104936], 11e3: 104941, 11080: 104872, 11100: 104907, 12e3: 104920, 12400: 104995, 13e3: 104948, 14e3: [104923, 104989], 15e3: [104913, 104954], 15100: 104976, 16e3: [104926, 104931], 18e3: [104922, 104982], 21e3: 104947, 21500: 104877, 27e3: [104950, 104957], 29e3: 104964, 3e4: 104921, 31e3: 104949, 33e3: 104946, 4e4: [104914, 104967], 40600: 104897, 41900: 104937, 42e3: 104951, 43100: 104993, 49300: 104924, 50100: 104939, 54e3: 104955, 58200: 104981, 59500: 104930, 74e3: 104961, 77e3: 104956, 79e3: 104962, 83500: 104910, 85e3: 104917, 88800: 104934, 89200: 104985, 96e3: 104997, 104e3: 104963, 106500: 104898, 11e4: 104938, 133e3: 104932, 135e3: 104983, 17e4: 104965, 198200: 104987, 198630: 104935, 208e3: 104966, 235800: 104952, 249400: 104929, 252100: 104980, 255e3: 104973, 47e4: 104972, 529800: 104942, 531e3: 104996, 56e4: 104928, 561400: 104979, 578900: 104945, 584700: 104959, 593e3: 104970, 606e3: 104999, 718e3: 104933, 745700: 104984, 761400: 104953, 763500: 104994, 764e3: 104940, 788900: 104958, 1188300: 104998, 1195e3: 104969, 1352600: 104968, 1560800: 104874, 1562090: 104915, 1737400: 104903, 1821460: 104918, 1821490: 104876, 2409300: 104912, 2410300: 104873, 2439400: 104974, 2439700: 104900, 2575e3: 104943, 2631200: 104875, 2632345: 104916, 3393400: 104904, 3396190: [104905, 104971], 6051e3: 104901, 6051800: 104902, 637e4: 104128, 6370997: [4052, 37008], 6371e3: 4035, 6371007: 4047, 6371228: [4053, 10346], 6376045: [8042, 8043], 6376523: [4027, 4901, 4902], 6376896: 37007, 6378135: [4122, 4322, 4324, 4720, 4985, 4987], 6378136: [4740, 4923, 7678, 7680, 9474, 9475, 104017, 104018], 6378137: [3823, 3824, 3888, 3889, 4017, 4019, 4023, 4031, 4040, 4046, 4055, 4074, 4075, 4080, 4081, 4121, 4126, 4130, 4133, 4140, 4141, 4148, 4151, 4152, 4163, 4166, 4167, 4170, 4171, 4172, 4173, 4176, 4180, 4189, 4190, 4258, 4269, 4283, 4318, 4319, 4326, 4463, 4466, 4469, 4470, 4480, 4482, 4483, 4490, 4557, 4558, 4612, 4617, 4619, 4624, 4627, 4659, 4661, 4667, 4669, 4670, 4674, 4686, 4687, 4693, 4694, 4702, 4737, 4742, 4747, 4749, 4750, 4755, 4756, 4757, 4758, 4759, 4761, 4762, 4763, 4764, 4765, 4883, 4885, 4887, 4889, 4893, 4895, 4898, 4907, 4909, 4921, 4925, 4927, 4929, 4931, 4933, 4935, 4937, 4939, 4941, 4943, 4945, 4947, 4949, 4951, 4953, 4955, 4957, 4959, 4961, 4963, 4965, 4967, 4971, 4975, 4977, 4979, 4981, 4983, 4989, 4997, 4999, 5012, 5013, 5245, 5246, 5251, 5252, 5263, 5264, 5323, 5324, 5340, 5342, 5353, 5354, 5359, 5360, 5364, 5365, 5370, 5371, 5372, 5373, 5380, 5381, 5392, 5393, 5488, 5489, 5545, 5546, 5592, 5593, 5885, 5886, 6134, 6135, 6310, 6311, 6318, 6319, 6321, 6322, 6324, 6325, 6364, 6365, 6667, 6668, 6705, 6706, 6782, 6783, 6980, 6982, 6983, 6987, 6989, 6990, 7034, 7035, 7036, 7037, 7038, 7039, 7040, 7041, 7042, 7072, 7073, 7084, 7085, 7086, 7087, 7133, 7135, 7136, 7138, 7139, 7372, 7373, 7657, 7659, 7661, 7663, 7665, 7685, 7686, 7797, 7798, 7816, 7843, 7844, 7880, 7881, 7885, 7886, 7900, 7901, 7902, 7903, 7904, 7905, 7906, 7907, 7908, 7909, 7910, 7911, 7912, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 8085, 8086, 8231, 8232, 8235, 8237, 8239, 8240, 8244, 8246, 8248, 8249, 8251, 8252, 8254, 8255, 8399, 8403, 8426, 8427, 8449, 8542, 8544, 8545, 8684, 8685, 8698, 8699, 8817, 8818, 8860, 8888, 8899, 8900, 8901, 8902, 8906, 8907, 8916, 8918, 8920, 8922, 8924, 8926, 8928, 8930, 8932, 8934, 8936, 8938, 8940, 8942, 8944, 8946, 8948, 8949, 8972, 8973, 8974, 8975, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995, 8996, 8997, 8998, 8999, 9e3, 9002, 9003, 9005, 9006, 9008, 9009, 9011, 9012, 9013, 9014, 9016, 9017, 9018, 9019, 9053, 9054, 9055, 9056, 9057, 9059, 9060, 9061, 9062, 9063, 9064, 9065, 9066, 9067, 9068, 9069, 9071, 9072, 9074, 9075, 9139, 9140, 9147, 9148, 9152, 9153, 9183, 9184, 9293, 9294, 9299, 9308, 9309, 9332, 9333, 9364, 9372, 9379, 9380, 9384, 9453, 9469, 9470, 9546, 9547, 9695, 9696, 9701, 9702, 9739, 9754, 9755, 9758, 9763, 9776, 9777, 9778, 9779, 9781, 9782, 9783, 9784, 9866, 9871, 9939, 9964, 9969, 9974, 9989, 9990, 10175, 10177, 10178, 10185, 10191, 10196, 10204, 10209, 10214, 10219, 10224, 10229, 10237, 10272, 10277, 10283, 10284, 10298, 10299, 10300, 10304, 10305, 10307, 10309, 10310, 10311, 10312, 10327, 10328, 10413, 10414, 10468, 10474, 10475, 10570, 10571, 10605, 10606, 10623, 10628, 10638, 10639, 10670, 10671, 10672, 10673, 10689, 10690, 10724, 10725, 10738, 10739, 10761, 10762, 10780, 10781, 10784, 10785, 10799, 10800, 20033, 20040, 20041, 20045, 20046, 104009, 104010, 104011, 104012, 104013, 104014, 104015, 104016, 104019, 104020, 104021, 104022, 104024, 104027, 104028, 104050, 104100, 104107, 104108, 104110, 104111, 104114, 104115, 104116, 104117, 104118, 104119, 104120, 104121, 104122, 104123, 104124, 104129, 104133, 104134, 104137, 104141, 104142, 104143, 104144, 104145, 104179, 104180, 104181, 104182, 104183, 104184, 104185, 104186, 104199, 104223, 104257, 104258, 104259, 104260, 104286, 104287, 104602, 104613, 104644, 104645, 104646, 104647, 104653, 104804, 104896, 104991], 6378140: 4610, 6378145: [4025, 4276, 4760, 4891, 37001], 6378150: 37003, 6378155: [37004, 37207], 6378160: [3821, 4003, 4021, 4036, 4202, 4203, 4237, 4238, 4291, 4618, 4708, 5527, 37231, 104023, 104136], 6378166: 37002, 6378200: [4020, 4229, 4286, 4303, 4706], 6378245: [4024, 4147, 4164, 4178, 4179, 4191, 4200, 4205, 4214, 4284, 4317, 4555, 4676, 4677, 4678, 4991, 4993, 5560, 5561, 37257, 104135], 6378270: [4732, 37005, 37229], 6378273: [4054, 10345], 6378300: [4029, 4168, 4174], 6378388: [4022, 4123, 4153, 4154, 4158, 4159, 4160, 4161, 4165, 4181, 4182, 4183, 4184, 4185, 4192, 4194, 4195, 4196, 4199, 4204, 4207, 4208, 4215, 4218, 4221, 4224, 4225, 4230, 4231, 4233, 4235, 4236, 4247, 4248, 4249, 4254, 4255, 4259, 4264, 4265, 4271, 4272, 4274, 4285, 4287, 4288, 4292, 4297, 4309, 4311, 4313, 4316, 4472, 4475, 4611, 4614, 4615, 4616, 4621, 4622, 4623, 4625, 4626, 4628, 4629, 4630, 4631, 4632, 4633, 4636, 4637, 4639, 4641, 4642, 4643, 4644, 4645, 4646, 4658, 4660, 4662, 4663, 4664, 4665, 4668, 4672, 4673, 4684, 4688, 4689, 4690, 4691, 4692, 4698, 4704, 4705, 4707, 4709, 4710, 4711, 4712, 4714, 4715, 4716, 4718, 4719, 4721, 4722, 4724, 4725, 4727, 4728, 4729, 4730, 4733, 4734, 4735, 4739, 4741, 4753, 4754, 4802, 4803, 4806, 4809, 4810, 4823, 4824, 4900, 5524, 6883, 8428, 8430, 8431, 9248, 9251, 9253, 9403, 9893, 10158, 10249, 10252, 10635, 10636, 10735, 10736, 10758, 37201, 37204, 37205, 37212, 37213, 37214, 37215, 37216, 37217, 37218, 37219, 37221, 37222, 37224, 37226, 37227, 37230, 37232, 37233, 37234, 37235, 37237, 37238, 37241, 37242, 37245, 37246, 37247, 37249, 37250, 37251, 37253, 37259, 104104, 104106, 104125, 104126, 104127, 104130, 104138, 104248], 6378523: 104786, 24764e3: 104960, 25559e3: 104944, 60268e3: 104925, 71492e3: 104908, 6957e5: 104975, 6377397155e-3: [3819, 3906, 4004, 4120, 4124, 4125, 4149, 4150, 4156, 4162, 4211, 4219, 4257, 4262, 4280, 4289, 4294, 4295, 4301, 4306, 4308, 4312, 4314, 4613, 4666, 4745, 4746, 4801, 4804, 4805, 4808, 4813, 4814, 4815, 4818, 4820, 4904, 5132, 5228, 5229, 5681, 5830, 8351, 9267, 10268, 37255, 104101, 104102, 104105, 104131, 104648, 104696, 104697, 104990, 104992], 6377563396e-3: [4001, 4188, 4277, 4278, 4279], 6377340189e-3: [4002, 4299, 4300], 6377492018e-3: [4005, 4273, 4817], 6377483865280418e-9: [4006, 4293], 6378293645208759e-9: [4007, 4157, 4302, 4738, 5464], 63782064e-1: [4008, 4127, 4128, 4129, 4135, 4136, 4137, 4138, 4139, 4169, 4216, 4242, 4253, 4267, 4608, 4609, 4638, 4675, 4683, 4695, 4717, 4723, 4726, 4995, 5451, 5467, 37220, 37239, 37243, 37252, 37260, 104e3, 104109, 104112, 104113, 104132], 6378450047e-3: [4009, 4268], 6378300789e-3: [4010, 4281], 63782492e-1: [4011, 4014, 4155, 4193, 4206, 4213, 4223, 4226, 4227, 4228, 4252, 4261, 4266, 4275, 4282, 4296, 4304, 4310, 4315, 4671, 4807, 4811, 4816, 4821, 37223, 37225, 104139, 104140, 104261, 104304], 6378249145e-3: [4012, 4013, 4132, 4134, 4142, 4143, 4175, 4197, 4198, 4201, 4209, 4210, 4212, 4220, 4222, 4232, 4234, 4246, 4250, 4251, 4256, 4260, 4263, 4270, 4305, 4307, 4600, 4601, 4602, 4603, 4604, 4605, 4606, 4607, 4620, 4679, 4680, 4696, 4697, 4699, 4700, 4701, 4703, 4713, 4731, 4736, 4743, 4744, 4812, 4819, 6881, 6882, 6892, 6894, 8694, 37206, 37208, 37211, 37228, 37240, 37254, 104025, 104026, 104103, 104305], 6377276345e-3: [4015, 4131, 4144, 4239, 4240, 4244, 4682, 5233, 6207, 37202, 104256, 104664, 104693], 6377298556e-3: [4016, 4298], 6377304063e-3: [4018, 4245], 63782983e-1: [4028, 4903], 63781362e-1: 4032, 63781363e-1: 4033, 6378249144808011e-9: [4034, 4241], 209229318e-1: [4042, 4243], 6377301243e-3: [4044, 4145, 37203], 6377299151e-3: [4045, 4146], 637701927e-2: [4657, 10256, 10260, 10265], 63783063696e-4: [4748, 4752], 6377295664e-3: [4751, 37006], 63781365e-1: [7682, 7683], 63710087714e-4: 104047, 6378418941e-3: [104700, 104726, 104760], 6378586581e-3: [104701, 104743], 6378505809e-3: 104702, 6378544823e-3: 104703, 6378490569e-3: 104704, 6378470757e-3: [104705, 104776], 6378403701e-3: [104706, 104750], 6378434181e-3: [104707, 104724, 104739, 104764], 6378454907e-3: 104708, 6378400653e-3: 104709, 6378567378e-3: 104710, 6378546957e-3: [104711, 104717, 104780], 6378476853e-3: [104712, 104736], 6378411321e-3: [104713, 104728], 6378647541e-3: [104714, 104715], 6378514953e-3: [104716, 104782], 6378421989e-3: [104718, 104770], 6378481425e-3: [104719, 104753, 104774, 104781], 6378518001e-3: [104720, 104725], 6378521049e-3: [104721, 104723, 104731, 104745, 104748], 6378464661e-3: 104722, 6378436619e-3: 104727, 6378574389e-3: [104729, 104730], 6378472281e-3: [104732, 104756], 6378498189e-3: [104733, 104746], 6378449421e-3: [104734, 104766], 6378525621e-3: [104735, 104754], 6378466185e-3: 104737, 6378496665e-3: 104738, 6378643579e-3: 104740, 6378559758e-3: 104741, 6378414369e-3: [104742, 104763, 104772], 6378441801e-3: 104744, 6378502761e-3: [104747, 104759, 104773, 104775], 6378617061e-3: 104749, 6378624681e-3: [104751, 104765], 6378468623e-3: 104752, 6378445763e-3: [104755, 104758, 104761], 6378670401e-3: 104757, 6378438753e-3: 104762, 6378543909e-3: 104767, 6378605783e-3: 104768, 6378540861e-3: 104769, 6378443325e-3: [104771, 104784], 6378548481e-3: 104777, 6378463746e-3: 104778, 6378426561e-3: 104779, 6378453688e-3: 104783, 6378530193e-3: 104785, 6378376271e-3: [104800, 104828], 637847192e-2: 104801, 6378472931e-3: 104802, 6378411351e-3: 104803, 6378380991e-3: 104805, 637841496e-2: 104806, 637834509e-2: [104807, 104819, 104844, 104870], 6378412542e-3: 104808, 6378470401e-3: 104809, 6378376331e-3: 104810, 6378379031e-3: 104811, 6378407621e-3: 104812, 6378376811e-3: [104813, 104827], 637831392e-2: 104814, 637841493e-2: 104815, 6378413021e-3: 104816, 6378380381e-3: 104817, 6378530851e-3: 104818, 6378591521e-3: 104820, 6378378881e-3: 104821, 6378408481e-3: [104822, 104832], 6378375601e-3: [104823, 104838], 6378408041e-3: 104824, 6378655071e-3: 104825, 6378409151e-3: 104826, 63783157e-1: [104829, 104840, 104845, 104851], 637828586e-2: [104830, 104835, 104859], 6378379301e-3: 104831, 6378560121e-3: 104833, 6378531821e-3: 104834, 63785006e-1: 104836, 6378376041e-3: 104837, 6378406601e-3: 104839, 6378438991e-3: 104841, 637834542e-2: 104842, 637859386e-2: 104843, 6378381271e-3: [104846, 104847], 6378413671e-3: 104848, 6378344377e-3: 104849, 6378563891e-3: 104850, 6378408091e-3: 104852, 6378377671e-3: 104853, 6378472751e-3: 104854, 6378412511e-3: 104855, 6378407281e-3: 104856, 6378534451e-3: 104857, 6378406051e-3: 104858, 6378532921e-3: 104860, 6378380091e-3: 104861, 6378408941e-3: 104862, 6378624171e-3: 104863, 6378377411e-3: 104864, 6378474591e-3: 104865, 6378407141e-3: 104866, 6378376871e-3: 104867, 6378375251e-3: 104868, 6378405971e-3: 104869, 6378437651e-3: 104871 };
function is2() {
  for (const e5 in rs3) delete rs3[e5];
}
var os2 = class extends ns2 {
  constructor(e5) {
    if ("number" == typeof e5) return super(), this.m_factor = e5, void (this.m_wkid = 0);
    super(e5);
  }
  getUnitType() {
    return 1;
  }
  convertFromRadians(e5) {
    return e5 / this.getUnitToBaseFactor();
  }
  convertToRadians(e5) {
    return e5 * this.getUnitToBaseFactor();
  }
};
function as2(e5) {
  return new bu2();
}
function hs2(e5) {
  return e5.getType() === bc.PE_TYPE_LINUNIT ? new bu2(e5) : e5.getType() === bc.PE_TYPE_ANGUNIT ? new os2(e5) : void P("peUnit");
}
function ms2(e5) {
  const s4 = Hc(null);
  return e5.getType() === bc.PE_TYPE_PROJCS || e5.getType() === bc.PE_TYPE_GEOGCS ? s4.reset(e5.getUnit()) : P("PE_coord_sys"), s4.get() || b("cannot create units from coord sys"), hs2(s4.get());
}
var ls3 = class _ls {
  constructor(e5, s4, n6) {
    void 0 === e5 ? (this.x = new p2(), this.y = new p2(), this.z = new p2()) : e5 instanceof X ? (this.x = new p2(e5.x), this.y = new p2(e5.y), this.z = new p2(e5.z)) : e5 instanceof p2 ? (this.x = e5.clone(), this.y = s4.clone(), this.z = n6.clone()) : P("EPoint3D constructor");
  }
  dotProduct(e5) {
    return this.x.mulE(e5.x).addE(this.y.mulE(e5.y)).addE(this.z.mulE(e5.z));
  }
  crossProduct(e5) {
    return new _ls(this.y.mulE(e5.z).subE(this.z.mulE(e5.y)), this.z.mulE(e5.x).subE(this.x.mulE(e5.z)), this.x.mulE(e5.y).subE(this.y.mulE(e5.x)));
  }
  crossProductVector(e5) {
    const t3 = this.y.mulE(e5.z).subE(e5.y.mulE(this.z)), s4 = e5.x.mulE(this.z).subE(this.x.mulE(e5.z)), n6 = this.x.mulE(e5.y).subE(e5.x.mulE(this.y));
    return new _ls(t3, s4, n6);
  }
  sqrLength() {
    return this.x.mulE(this.x).addE(this.y.mulE(this.y)).addE(this.z.mulE(this.z));
  }
  length() {
    return this.sqrLength().sqrt();
  }
  static distance(e5, t3) {
    return e5.sub(t3).length();
  }
  negate() {
    return new _ls(this.x.negate(), this.y.negate(), this.z.negate());
  }
  add(e5) {
    return new _ls(this.x.addE(e5.x), this.y.addE(e5.y), this.z.addE(e5.z));
  }
  sub(e5) {
    return new _ls(this.x.subE(e5.x), this.y.subE(e5.y), this.z.subE(e5.z));
  }
  subThis(e5) {
    return this.x.subThisE(e5.x), this.y.subThisE(e5.y), this.z.subThisE(e5.z), this;
  }
  addThis(e5) {
    return this.x.addThisE(e5.x), this.y.addThisE(e5.y), this.z.addThisE(e5.z), this;
  }
  mul(e5) {
    return new _ls(this.x.mulE(e5), this.y.mulE(e5), this.z.mulE(e5));
  }
  div(e5) {
    return new _ls(this.x.divE(e5), this.y.divE(e5), this.z.divE(e5));
  }
  eq(e5) {
    return this.x.eq(e5.x) && this.y.eq(e5.y) && this.z.eq(e5.z);
  }
  isZero() {
    return this.x.isZero() && this.y.isZero() && this.z.isZero();
  }
  value() {
    return X.construct(this.x.value(), this.y.value(), this.z.value());
  }
};
var gs2 = class {
  constructor(e5) {
    if (this.m_origin = new X(), this.m_normal = new X(), this.m_axisX = new X(), this.m_axisY = new X(), !e5) return this.m_origin = new X(), this.m_normal = new X(0, 0, 1), this.m_axisX = new X(1, 0, 0), void (this.m_axisY = new X(0, 1, 0));
    e5.pt0 && e5.pt1 && e5.pt2 ? this.setFromPoints(e5.pt0, e5.pt1, e5.pt2) : n2(0, `unimplemented constructor options ${JSON.stringify(e5)}`);
  }
  assign(e5) {
    return n2(0), this;
  }
  set(e5, t3, s4, n6) {
    n2(0);
  }
  setFromPoints(e5, t3, s4) {
    let n6 = t3.sub(e5);
    const r = s4.sub(e5);
    this.m_normal = n6.crossProductVector(r);
    let i2 = true;
    if (this.m_normal.isZero()) {
      if (i2 = false, n6.isZero() && (n6 = r), n6.isZero()) {
        const t4 = 0, s5 = 1;
        return this.m_normal.setCoords(t4, t4, s5), this.m_axisX.setCoords(s5, t4, t4), this.m_axisY.setCoords(t4, s5, t4), this.m_origin = e5, false;
      }
      this.m_axisX = n6.getUnitVector(), this.m_normal = this.m_axisX.createAPerpendicular();
    } else this.m_normal.normalizeThis(), this.m_axisX = n6.getUnitVector();
    return this.m_axisY = this.m_normal.crossProductVector(this.m_axisX), this.m_origin = e5, i2;
  }
  getCoord(e5, t3) {
    return n2(0), {};
  }
  getCoord2D(e5) {
    return n2(0), {};
  }
  getCoordX(e5, t3) {
    return n2(0), 0;
  }
  getCoordY(e5, t3) {
    return n2(0), 0;
  }
  getCoordZ(e5, t3) {
    return n2(0), 0;
  }
  setPreferredAxisX(e5) {
    n2(0);
  }
  getOrigin() {
    return n2(0), {};
  }
  getNormal() {
    return n2(0), {};
  }
  getAxisX() {
    return this.m_axisX.clone();
  }
  getAxisY() {
    return this.m_axisY.clone();
  }
  setAxisX(e5, t3 = false) {
    n2(0);
  }
  setAxisY(e5, t3 = false) {
    n2(0);
  }
  recalculateAxisY() {
    n2(0);
  }
  setOrigin(e5) {
    n2(0);
  }
  setNormal(e5, t3) {
    n2(0);
  }
  intersect(e5, t3) {
    return n2(0), false;
  }
  intersectLine(e5) {
    return n2(0), 0;
  }
  intersectLineEx(e5, t3) {
    return n2(0), 0;
  }
  closestCoordinate(e5) {
    const t3 = e5.sub(this.m_origin), s4 = new mi();
    return s4.x = t3.dotProduct(this.m_axisX), s4.y = t3.dotProduct(this.m_axisY), s4;
  }
  projectVector(e5) {
    return n2(0), {};
  }
  signedDistance(e5) {
    return n2(0), 0;
  }
  distance(e5) {
    return n2(0), 0;
  }
};
function us2(e5, t3) {
  return false;
}
function cs3(e5, t3, s4, n6, r = 100, i2 = us2) {
  let o, h2, m3, l2, g2, u, c, _, d2;
  n2(n6 > 0);
  let p3, f3, x4, y2 = 0, P5 = 0;
  const E2 = Os();
  t3 > s4 && (s4 = Pt(t3, t3 = s4));
  const S3 = e5(t3), C3 = e5(s4);
  S3 < C3 ? (o = h2 = m3 = t3, l2 = g2 = u = S3) : (o = h2 = m3 = s4, l2 = g2 = u = C3);
  let I4 = 0;
  for (; I4 < r && (x4 = 0.5 * (s4 - t3), d2 = t3 + x4, p3 = n6 * (Math.abs(o) + 0.25), f3 = 2 * p3, !(i2(o, l2) || Math.abs(o - d2) <= f3 - x4)); ++I4) {
    if (Math.abs(P5) > p3) {
      const e6 = (o - h2) * (l2 - u);
      let n7 = (o - m3) * (l2 - g2), r2 = (o - m3) * n7 - (o - h2) * e6;
      n7 = 2 * (n7 - e6), n7 > 0 && (r2 = -r2), n7 = Math.abs(n7);
      const i3 = P5;
      P5 = y2, Math.abs(r2) >= Math.abs(n7 * i3 * 0.5) || r2 <= n7 * (t3 - o) || r2 >= n7 * (s4 - o) ? (P5 = o >= d2 ? t3 - o : s4 - o, y2 = Os() * P5) : (y2 = r2 / n7, _ = o + y2, (_ - t3 < f3 || s4 - _ < f3) && (y2 = d2 - o < 0 ? -Math.abs(p3) : Math.abs(p3)));
    } else P5 = o >= d2 ? t3 - o : s4 - o, y2 = P5 * E2;
    _ = o + y2, c = e5(_), c < l2 ? (_ >= o ? t3 = o : s4 = o, m3 = h2, h2 = o, o = _, u = g2, g2 = l2, l2 = c) : (_ < o ? t3 = _ : s4 = _, c <= g2 || h2 === o ? (m3 = h2, h2 = _, u = g2, g2 = c) : (c <= u || m3 === o || m3 === h2) && (m3 = _, u = c));
  }
  return $t(o, l2);
}
function _s3(e5, t3, s4) {
  if (e5 > s4) {
    e5 -= Math.ceil((e5 - s4) / Kt) * Kt;
  } else if (e5 < t3) {
    e5 += Math.ceil((t3 - e5) / Kt) * Kt;
  }
  return e5;
}
function ds3(e5, t3, s4) {
  return ps2(e5, t3, s4, 0);
}
function ps2(e5, t3, s4, n6) {
  const r = s4.x, i2 = s4.y;
  return xs2(e5, t3, Math.cos(r), Math.sin(r), Math.cos(i2), Math.sin(i2), n6);
}
function fs3(e5, t3, s4, n6, r, i2) {
  return xs2(e5, t3, s4, n6, r, i2, 0);
}
function xs2(e5, t3, s4, n6, r, i2, o) {
  const a2 = e5 / Math.sqrt(1 - t3 * i2 * i2), h2 = a2 + o, m3 = h2 * r * s4, l2 = h2 * r * n6, g2 = (a2 * (1 - t3) + o) * i2;
  return X.construct(m3, l2, g2);
}
function ys2(e5, t3, s4) {
  const n6 = new p2(), r = new p2(), i2 = new p2(), o = new p2();
  n6.setCos(s4.x), r.setSin(s4.x), i2.setCos(s4.y), o.setSin(s4.y);
  const a2 = o.negate().mulE(o.mul(t3)).add(1).sqrt(), h2 = new p2(e5).divE(a2), m3 = h2.mulE(i2).mulE(n6), l2 = h2.mulE(i2).mulE(r), g2 = h2.mul(1 - t3).mulE(o);
  return new ls3(m3, l2, g2);
}
function Ps3(e5, t3, s4) {
  const n6 = s4.x, r = s4.y, i2 = s4.z, o = Math.atan2(r, n6), a2 = Math.sqrt(n6 * n6 + r * r), h2 = Math.atan2(i2, (1 - t3) * a2);
  return mi.construct(o, h2);
}
function Es2(e5, t3, s4) {
  const n6 = 1 - t3, r = e5 / Math.sqrt(H(s4.x) + H(s4.y) + H(s4.z) / n6);
  return s4.mul(r);
}
function Ss3(e5, t3, s4, n6, r) {
  const i2 = ds3(e5, t3, s4), o = ds3(e5, t3, n6);
  return Ps3(e5, t3, X.lerp(i2, o, r));
}
function Cs2(e5, t3, s4) {
  const n6 = new X();
  return n6.setCrossProductVector(t3, s4), Math.abs(Math.atan2(n6.length(), t3.dotProduct(s4))) * e5;
}
function Is2(e5, t3, s4, n6, r) {
  const i2 = s4.getUnitVector(), o = n6.getUnitVector(), a2 = t3.getUnitVector(), h2 = new X();
  if (h2.setCrossProductVector(i2, o), !h2.isZero()) {
    h2.normalizeThis();
    const t4 = a2.sub(h2.mul(h2.dotProduct(a2)));
    if (!t4.isZero()) {
      t4.normalizeThis();
      const s5 = i2.add(o).mul(0.5);
      if (s5.dotProduct(t4) > s5.dotProduct(i2)) {
        const s6 = Math.abs(h2.dotProduct(a2)), n7 = Math.asin(s6);
        return r.assign(t4.getUnitVector().mul(e5)), n7 * e5;
      }
    }
  }
  const m3 = Cs2(1, i2, a2), l2 = Cs2(1, o, a2);
  return m3 <= l2 ? (r.assign(s4), m3 * e5) : (r.assign(n6), l2 * e5);
}
function bs3(e5, t3, s4, n6) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const i2 = n(r, new Cc(), false);
    return Dc.geodeticDistance(e5, t3, s4.x, s4.y, n6.x, n6.y, i2, null, null, bc.PE_LINETYPE_GEODESIC), i2.val;
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    s(r);
  }
}
function ws2(e5, t3, s4, n6, r) {
  switch (n2(s4.isFinite() && n6.isFinite()), r) {
    case 0:
      return bs3(e5, t3, s4, n6);
    case 1:
      return Ts(e5, t3, s4);
    case 2:
    case 3: {
      const r2 = ds3(e5, t3, s4), i2 = ds3(e5, t3, n6);
      return X.distance(r2, i2);
    }
    default:
      z("");
  }
}
function vs3(e5, t3, s4, n6, r, i2 = 0, o) {
  if (2 === i2 || 3 === i2) return Ns2(e5, t3, s4, n6, r, 3 === i2, o);
  const a2 = Ps3(e5, t3, s4), h2 = (s5) => {
    const o2 = Ps3(e5, t3, X.lerp(n6, r, s5));
    return ws2(e5, t3, a2, o2, i2);
  }, m3 = X.distance(n6, r);
  if (m3 > 0) {
    const s5 = Os3(e5, m3), { first: i3, second: a3 } = cs3(h2, 0, 1, s5);
    return o && o.assign(Es2(e5, t3, X.lerp(n6, r, i3))), $t(i3, a3);
  }
  {
    const e6 = h2(0);
    return o && o.assign(n6), $t(0.5, e6);
  }
}
function Ns2(e5, t3, s4, n6, r, i2 = false, o) {
  const a2 = Es2(e5, t3, s4);
  if (i2) {
    const i3 = new gs2({ pt0: new X(0, 0, 0), pt1: n6, pt2: r }), h3 = i3.closestCoordinate(s4), m4 = i3.closestCoordinate(n6), l2 = i3.closestCoordinate(r), g2 = mi.getClosestCoordinate(m4, l2, h3), u = Es2(e5, t3, X.lerp(n6, r, g2)), c = X.distance(u, a2);
    return o && o.assign(u), $t(g2, c);
  }
  const h2 = (s5) => {
    const i3 = Es2(e5, t3, X.lerp(n6, r, s5));
    return X.distance(i3, a2);
  }, m3 = X.distance(n6, r);
  if (m3 > 0) {
    const s5 = Os3(e5, m3), { first: i3, second: a3 } = cs3(h2, 0, 1, s5);
    return o && o.assign(Es2(e5, t3, X.lerp(n6, r, i3))), $t(i3, a3);
  }
  {
    const e6 = X.distance(s4, n6);
    return o && o.assign(s4), $t(0.5, e6);
  }
}
function Ts(e5, t3, s4, n6) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const n7 = n(r, new Cc(), false);
    return Dc.greatEllipticDistance(e5, t3, s4.x, s4.y, s4.x, s4.y, n7, null, null), n7.val;
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    s(r);
  }
}
function Gs3(e5, t3, s4, n6, r) {
  if (Math.abs(s4.x - n6.x) > Math.PI) return Number.NaN;
  if (Math.abs(s4.y) > Wt || Math.abs(n6.y) > Wt) return Number.NaN;
  if ((Math.abs(s4.y) === Wt || Math.abs(n6.y) === Wt) && s4.x !== n6.x) return Number.NaN;
  const { first: i2, second: o } = R2(s4.x, n6.x);
  let a2 = r;
  a2 = _s3(a2, i2, o);
  if (!x2.construct(s4.x, n6.x).containsCoordinate(a2)) return Number.NaN;
  const h2 = Ye.constructPoint2D(s4), m3 = Ye.constructPoint2D(n6), l2 = ys2(1, t3, h2), g2 = ys2(1, t3, m3), u = l2.crossProductVector(g2);
  if (u.z.isZero()) {
    return s4.y;
  }
  const c = u.x.divE(u.z.negate()), _ = u.y.divE(u.z.negate()), d2 = c.mulE(c).addE(_.mulE(_)).sqrt();
  if (d2.isZero() || c.isZero() && _.isZero()) {
    return s4.y;
  }
  const p3 = Math.atan2(_.value(), c.value());
  let f3 = Math.atan2(d2.value() * Math.cos(p3 - a2), 1 - t3);
  const x4 = ds3(1, t3, mi.construct(a2, f3)), y2 = X.construct(x4.x, x4.y, -x4.z), P5 = u.value().dotProduct(x4), E2 = u.value().dotProduct(y2);
  return Math.abs(E2) < Math.abs(P5) && (f3 = -f3), f3;
}
function Ds3(e5, t3, s4, n6, r, i2) {
  if (i2[0] = Number.NaN, i2[1] = Number.NaN, Math.abs(s4.x - n6.x) > Math.PI) return 0;
  if (Math.abs(s4.y) > Wt || Math.abs(n6.y) > Wt) return 0;
  if ((Math.abs(s4.y) === Wt || Math.abs(n6.y) === Wt) && s4.x !== n6.x) return 0;
  if (Math.abs(r) >= Wt) return 0;
  if (s4.y > 0 && n6.y > 0 && s4.y > r && n6.y > r || s4.y < 0 && n6.y < 0 && s4.y < r && n6.y < r) return 0;
  const o = Ye.constructPoint2D(s4), a2 = Ye.constructPoint2D(n6), h2 = ys2(1, t3, o), m3 = ys2(1, t3, a2), l2 = h2.crossProductVector(m3);
  if (l2.z.isZero()) {
    return x2.construct(s4.y, n6.y).containsCoordinate(r) ? (i2[0] = s4.x, 1) : 0;
  }
  const g2 = l2.x.divE(l2.z.negate()), u = l2.y.divE(l2.z.negate()), c = g2.mulE(g2).addE(u.mulE(u)).sqrt();
  if (c.isZero() || g2.isZero() && u.isZero()) return 0 === r ? (i2[0] = s4.x, i2[1] = n6.x, 2) : 0;
  const _ = (1 - t3) * Math.tan(r) / c.value();
  if (Math.abs(_) > 1) return 0;
  const d2 = Math.acos(_), p3 = Math.atan2(u.value(), g2.value()), f3 = p3 - d2;
  let x4 = p3 + d2;
  const y2 = Math.min(s4.x, n6.x), P5 = Math.max(s4.x, n6.x);
  _s3(f3, y2, P5), 0 !== r ? _s3(x4, y2, P5) : x4 = f3;
  let E2 = 0;
  return y2 <= f3 && f3 <= P5 && (i2[E2] = f3, E2++), x4 !== f3 && y2 <= x4 && x4 <= P5 && (i2[E2] = x4, E2++), E2;
}
function Vs3(e5, t3) {
  t3[0] > 0.5 * Math.PI ? (e5[0] += Math.PI, t3[0] = Math.PI - t3[0]) : t3[0] < 0.5 * -Math.PI && (e5[0] -= Math.PI, t3[0] = -Math.PI - t3[0]), n2(t3[0] >= 0.5 * -Math.PI && t3[0] <= 0.5 * Math.PI);
}
function Fs2(e5, t3) {
  return e5 * Math.sqrt(1 - t3);
}
function Hs3(e5) {
  return 1 - e5;
}
function ks2(e5, t3, s4, n6, r) {
  n6 = Us(n6, -Wt, Wt), r = Us(r, -Wt, Wt);
  const i2 = Wt - 0.03;
  let o;
  o = n6 > i2 && r > i2 || n6 < -i2 && r < -i2 ? As3(e5, n6, r) : Ms2(e5, r) - Ms2(e5, n6);
  return 0.5 * (s4 - t3) * o * Hs3(e5);
}
function As3(e5, t3, s4) {
  let n6 = 1;
  if (t3 < 0 && (n6 = -1, t3 = -t3, s4 = -s4), 0 !== e5) {
    const r = e5 * e5, i2 = r * e5, o = [1, (1 + 11 * e5) / 12, (1 + 118 * e5 + 241 * r) / 360, (1 + 1089 * e5 + 10419 * r + 8651 * i2) / 20160, (1 + 9836 * e5 + 318246 * r + 1027436 * i2 + 458881 * (i2 * e5)) / 1814400], a2 = (t4) => {
      let s5 = 0;
      const n7 = H(t4) / (e5 - 1);
      for (let e6 = o.length - 1; e6 >= 0; --e6) s5 = o[e6] + s5 * n7;
      return s5 *= -H(t4 / (1 - e5)), s5;
    }, h2 = a2(Wt - t3);
    return (a2(Wt - s4) - h2) * n6;
  }
  {
    const e6 = Wt - t3, r = Wt - s4, i2 = -4 * H(Math.sin(e6 / 2));
    return (-4 * H(Math.sin(r / 2)) - i2) * n6;
  }
}
function Ms2(e5, t3) {
  if (0 === t3) return 0;
  const s4 = Math.sin(t3);
  let n6 = s4, r = s4;
  if (0 !== e5) {
    n6 /= 1 - e5 * s4 * s4;
    const t4 = Math.sqrt(e5);
    r = s4 * z2(t4 * s4);
  }
  return n6 + r;
}
function Us3(e5, t3) {
  return e5 / Math.sqrt(1 - t3);
}
function qs3(e5, t3) {
  return (1 - t3) * e5;
}
function Bs3(e5, t3, s4) {
  const n6 = s4 / (2 * qs3(e5, t3)), r = n6 * n6;
  return s4 * (1 - r * (0.16666666666666666 - 0.008333333333333333 * r));
}
function Os3(e5, t3) {
  if (0 !== t3) {
    const s4 = e5 * rs() / t3;
    return Math.min(s4, 1e-10);
  }
  return 0;
}
var Ys3 = class _Ys {
  constructor(e5) {
    this.m_currentShift = 63n, this.m_currentElt = 0n, this.m_iCurrentElt = -1, this.m_parent = e5, this.m_aiSetElts = e5.m_bits.flatMap((e6, t3) => t3);
  }
  next() {
    if (this.m_currentShift++, 64n === this.m_currentShift) {
      if (this.m_iCurrentElt++, this.m_iCurrentElt === this.m_aiSetElts.length) return _Ys.npos();
      this.m_currentShift = 0n, this.m_currentElt = this.m_parent.m_bits[this.m_aiSetElts[this.m_iCurrentElt]];
    }
    for (; this.m_currentShift < 63n && !(this.m_currentElt & 1n << this.m_currentShift); ) this.m_currentShift++;
    return this.m_currentElt & 1n << this.m_currentShift ? 64 * this.m_aiSetElts[this.m_iCurrentElt] + Number(this.m_currentShift) : this.next();
  }
  static npos() {
    return Number.MAX_SAFE_INTEGER;
  }
};
function Rs2(e5) {
  return 1n << (0x3fn & BigInt(e5));
}
function Xs3(e5) {
  return e5 >> 6;
}
var Ls3 = class {
  constructor(e5) {
    this.m_bits = [], void 0 !== e5 && e5.copy && (this.m_bits = e5.copy.m_bits.slice());
  }
  assignMove() {
    return this;
  }
  assignCopy() {
    return this;
  }
  hasBit(e5) {
    const t3 = Rs2(e5), s4 = Xs3(e5);
    return void 0 !== this.m_bits[s4] && !!(this.m_bits[s4] & t3);
  }
  setBit(e5) {
    const t3 = Rs2(e5), s4 = Xs3(e5);
    void 0 === this.m_bits[s4] && (this.m_bits[s4] = 0n), this.m_bits[s4] |= t3;
  }
  clearBit(e5) {
  }
  flipBit(e5) {
    const t3 = Rs2(e5), s4 = Xs3(e5);
    return void 0 === this.m_bits[s4] && (this.m_bits[s4] = 0n), this.m_bits[s4] ^= t3, 0n !== (this.m_bits[s4] & t3);
  }
  clear() {
    this.m_bits.length = 0;
  }
  isZero() {
    let e5 = 0;
    return this.m_bits.forEach((t3) => {
      e5 |= t3 ? 2 : 1;
    }), !(2 & e5);
  }
  equals(e5) {
    if (this === e5) return true;
    if (this.m_bits.length !== e5.m_bits.length) return false;
    let t3 = 0;
    return this.m_bits.forEach((s4, n6) => {
      t3 |= s4 === e5.m_bits[n6] ? 2 : 1;
    }), !(1 & t3) && (e5.m_bits.forEach((e6, s4) => {
      t3 |= e6 === this.m_bits[s4] ? 2 : 1;
    }), !(1 & t3));
  }
  notEquals(e5) {
    return !this.equals(e5);
  }
  assignOr(e5) {
    return e5.m_bits.forEach((e6, t3) => {
      void 0 === this.m_bits[t3] ? this.m_bits[t3] = e6 : this.m_bits[t3] |= e6;
    }), this;
  }
  assignSubtract(e5) {
    return e5.m_bits.forEach((e6, t3) => {
      void 0 !== this.m_bits[t3] && (this.m_bits[t3] &= ~e6);
    }), this;
  }
  assignAnd(e5) {
    return e5.m_bits.forEach((e6, t3) => {
      void 0 !== this.m_bits[t3] && (this.m_bits[t3] &= e6);
    }), this;
  }
  assignXor(e5) {
    return e5.m_bits.forEach((e6, t3) => {
      void 0 === this.m_bits[t3] ? this.m_bits[t3] = e6 : this.m_bits[t3] ^= e6;
    }), this;
  }
  getHashCode() {
    return this.m_bits.reduce((e5, t3) => Ps(e5, t3), Zs(0));
  }
  getUnorderedBitIterator() {
    return new Ys3(this);
  }
};
var zs3 = class {
  constructor(e5, t3) {
    this.m_map = /* @__PURE__ */ new Map(), this.m_hf = e5, this.m_ef = t3;
  }
  add(e5) {
    const t3 = this.m_hf(e5);
    if (!this.m_map.has(t3)) return this.m_map.set(t3, e5), this;
    const s4 = this.m_map.get(t3);
    return s4 instanceof Array ? s4.find((t4) => this.m_ef(t4, e5)) || s4.push(e5) : this.m_ef(s4, e5) || this.m_map.set(t3, [s4, e5]), this;
  }
  clear() {
    this.m_map.clear();
  }
  delete(e5) {
    return false;
  }
  has(e5) {
    const t3 = this.m_hf(e5);
    if (!this.m_map.has(t3)) return false;
    const s4 = this.m_map.get(t3);
    return s4 instanceof Array ? void 0 !== s4.find((t4) => this.m_ef(t4, e5)) : this.m_ef(s4, e5);
  }
  get(e5) {
    const t3 = this.m_hf(e5), s4 = this.m_map.get(t3);
    if (void 0 !== s4) return s4 instanceof Array ? s4.find((t4) => this.m_ef(t4, e5)) : s4;
  }
  get size() {
    let e5 = 0;
    for (const t3 of this.m_map.values()) e5 += t3 instanceof Array ? t3.length : 1;
    return e5;
  }
  forEach(e5, t3) {
  }
  [Symbol.iterator]() {
    return (/* @__PURE__ */ new Set())[Symbol.iterator]();
  }
  entries() {
    return (/* @__PURE__ */ new Set()).entries();
  }
  keys() {
    return (/* @__PURE__ */ new Set()).keys();
  }
  values() {
    return (/* @__PURE__ */ new Set()).values();
  }
  get [Symbol.toStringTag]() {
    return "ValueSet";
  }
};
var Ws3 = class extends dt {
  constructor(e5) {
    super(), this.m_bufferLeft = new fm(), this.m_bufferRight = new fm(), this.m_intervalLeft = x2.constructEmpty(), this.m_intervalRight = x2.constructEmpty(), this.m_yScanline = Number.NaN, this.m_helper = e5;
  }
  compare(e5, t3, s4) {
    const n6 = t3, r = e5.getElement(s4);
    this.m_helper.querySegmentXY(n6, this.m_bufferLeft), this.m_helper.querySegmentXY(r, this.m_bufferRight);
    const i2 = this.m_bufferLeft.get(), o = this.m_bufferRight.get();
    if (this.m_intervalLeft.setCoords(i2.getStartX(), i2.getEndX()), this.m_intervalRight.setCoords(o.getStartX(), o.getEndX()), this.m_intervalLeft.vmax < this.m_intervalRight.vmin) return -1;
    if (this.m_intervalLeft.vmin > this.m_intervalRight.vmax) return 1;
    const a2 = i2.getStartY() === i2.getEndY(), h2 = o.getStartY() === o.getEndY();
    if (a2 || h2) {
      if (a2 && h2) return 0;
      if (i2.getStartY() === o.getStartY() && i2.getStartX() === o.getStartX()) return a2 ? 1 : -1;
      if (i2.getEndY() === o.getEndY() && i2.getEndX() === o.getEndX()) return a2 ? -1 : 1;
    }
    let m3 = i2.intersectionOfYMonotonicWithAxisX(this.m_yScanline, this.m_intervalLeft.vmin), l2 = o.intersectionOfYMonotonicWithAxisX(this.m_yScanline, this.m_intervalRight.vmin);
    if (m3 === l2) {
      const e6 = i2.getEndY(), t4 = o.getEndY(), s5 = Math.min(e6, t4);
      let n7 = 0.5 * (s5 + this.m_yScanline);
      n7 === this.m_yScanline && (n7 = s5), m3 = i2.intersectionOfYMonotonicWithAxisX(n7, this.m_intervalLeft.vmin), l2 = o.intersectionOfYMonotonicWithAxisX(n7, this.m_intervalRight.vmin);
    }
    return m3 < l2 ? -1 : m3 > l2 ? 1 : 0;
  }
  setY(e5) {
    this.m_yScanline = e5;
  }
};
var js3 = class {
  constructor(e5) {
    this.m_segmentBuffer = new fm(), this.m_point = mi.getNAN(), this.m_parent = e5;
  }
  setPointXY(e5) {
    this.m_point.assign(e5);
  }
  compare(e5, t3) {
    const s4 = e5.getElement(t3);
    this.m_parent.querySegmentXY(s4, this.m_segmentBuffer);
    const n6 = this.m_segmentBuffer.get(), r = new x2();
    if (r.setCoords(n6.getStartX(), n6.getEndX()), this.m_point.x < r.vmin) return -1;
    if (this.m_point.x > r.vmax) return 1;
    const i2 = n6.intersectionOfYMonotonicWithAxisX(this.m_point.y, this.m_point.x);
    return this.m_point.x < i2 ? -1 : this.m_point.x > i2 ? 1 : 0;
  }
};
var Zs3;
var Ks2;
function Qs3(e5, t3) {
  return { parentage: e5, rank: t3 };
}
function Js3(e5, t3) {
  const s4 = e5.length;
  if (s4 !== t3.length) return false;
  const n6 = e5[0].parentage;
  if (n6 !== t3[0].parentage) return false;
  if (-1 === n6) return true;
  for (let r = 1; r < s4; ++r) if (e5[r].parentage !== t3[r].parentage) return false;
  return true;
}
function $s3(e5, t3, s4) {
  s4.length = 0;
  let n6 = false;
  {
    let r = e5.getHalfEdgeVertexIterator(t3);
    for (; r !== cr; ) {
      const t4 = e5.getVertexFromVertexIterator(r), i2 = e5.getShape().getSegmentRank(t4), o = e5.getShape().getSegmentParentage(t4);
      n6 ||= o >= 0, s4.push(Qs3(o, i2)), r = e5.incrementVertexIterator(r);
    }
  }
  {
    let r = e5.getHalfEdgeVertexIterator(e5.getHalfEdgeTwin(t3));
    for (; r !== cr; ) {
      const t4 = e5.getVertexFromVertexIterator(r), i2 = e5.getShape().getSegmentRank(t4), o = e5.getShape().getSegmentParentage(t4);
      n6 ||= o >= 0, s4.push(Qs3(o, i2)), r = e5.incrementVertexIterator(r);
    }
  }
  n6 && s4.sort((e6, t4) => e6.rank > t4.rank ? -1 : e6.rank < t4.rank ? 1 : e6.parentage < t4.parentage ? -1 : e6.parentage > t4.parentage ? 1 : 0), -1 === s4[0].parentage && (s4.length = 1);
}
function en2() {
  return new zs3((e5) => e5.getHashCode(), (e5, t3) => e5.equals(t3));
}
!function(e5) {
  e5[e5.enumInputModeBuildGraph = 0] = "enumInputModeBuildGraph", e5[e5.enumInputModeSimplifyAlternate = 1] = "enumInputModeSimplifyAlternate", e5[e5.enumInputModeSimplifyWinding = 2] = "enumInputModeSimplifyWinding";
}(Zs3 || (Zs3 = {})), function(e5) {
  e5[e5.enumSegmentParentageBreakNode = 1] = "enumSegmentParentageBreakNode", e5[e5.enumPathBreakNode = 2] = "enumPathBreakNode";
}(Ks2 || (Ks2 = {}));
var tn2 = class _tn {
  constructor() {
    this.m_shape = null, this.m_clusterData = new at(8), this.m_clusterVertices = new at(2), this.m_firstCluster = cr, this.m_lastCluster = cr, this.m_halfEdgeData = new at(8), this.m_chainData = new at(8), this.m_chainAreas = null, this.m_chainPerimeters = null, this.m_universeChain = -1, this.m_simplifiedGeometry = -1, this.m_edgeIndices = [], this.m_clusterIndices = [], this.m_chainIndices = [], this.m_bBuildGeometryParentageSets = false, this.m_chainBitSetIndex = -1, this.m_edgeBitSetIndex = -1, this.m_edgeBitSetIndexLeft = -1, this.m_emptyBitSet = null, this.m_geometryMapID = null, this.m_uniqueBitSets = null, this.m_chainBitSets = [], this.m_edgeBitSets = [], this.m_checkDirtyPlanesweepTolerance = Number.NaN, this.m_geometryIDIndex = -1, this.m_clusterIndex = -1, this.m_halfEdgeIndex = -1, this.m_tmpHalfEdgeParentageIndex = -1, this.m_tmpHalfEdgeParentageIndexLeft = -1, this.m_tmpHalfEdgeWindingNumberIndex = -1, this.m_tmpHalfEdgeOddEvenNumberIndex = -1, this.m_segmentParentageIndex = -1, this.m_segmentIndexHe = -1, this.m_clusterBreakNodeIndex = -1, this.m_universeGeomID = -1, this.m_pointCount = 0, this.m_progressCounter = 0, this.m_bBuildChains = true, this.m_bDirtyCheckFailed = false;
  }
  setCheckDirtyPlanesweepTolerance(e5) {
    this.m_checkDirtyPlanesweepTolerance = e5;
  }
  dirtyCheckFailed() {
    return this.m_bDirtyCheckFailed;
  }
  getShape() {
    return this.m_shape;
  }
  setEditShape(e5, t3, s4 = true, n6 = false) {
    n6 ? this.setEditShapeImpl3D_(e5, Zs3.enumInputModeBuildGraph, null, t3, false) : this.setEditShapeImpl_(e5, Zs3.enumInputModeBuildGraph, null, t3, s4);
  }
  setAndSimplifyEditShapeAlternate(e5, t3, s4 = null, r = false) {
    const i2 = [];
    i2.push(t3), this.m_simplifiedGeometry = t3, r ? this.setEditShapeImpl3D_(e5, Zs3.enumInputModeSimplifyAlternate, i2, s4, false) : this.setEditShapeImpl_(e5, Zs3.enumInputModeSimplifyAlternate, i2, s4, e5.getGeometryType(t3) === a.enumPolygon);
  }
  setAndSimplifyEditShapeWinding(e5, t3, s4 = null) {
    const n6 = [];
    n6.push(t3), this.m_simplifiedGeometry = t3, this.setEditShapeImpl_(e5, Zs3.enumInputModeSimplifyWinding, n6, s4, true);
  }
  removeShape() {
    null !== this.m_shape && (-1 !== this.m_geometryIDIndex && (this.m_shape.removeGeometryUserIndex(this.m_geometryIDIndex), this.m_geometryIDIndex = -1), -1 !== this.m_clusterIndex && (this.m_shape.removeUserIndex(this.m_clusterIndex), this.m_clusterIndex = -1), -1 !== this.m_halfEdgeIndex && (this.m_shape.removeUserIndex(this.m_halfEdgeIndex), this.m_halfEdgeIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), -1 !== this.m_tmpHalfEdgeWindingNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex), this.m_tmpHalfEdgeWindingNumberIndex = -1), -1 !== this.m_tmpHalfEdgeOddEvenNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex), this.m_tmpHalfEdgeOddEvenNumberIndex = -1), -1 !== this.m_segmentParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_segmentParentageIndex), this.m_segmentParentageIndex = -1), -1 !== this.m_segmentIndexHe && (this.deleteUserIndexForHalfEdges(this.m_segmentIndexHe), this.m_segmentIndexHe = -1), -1 !== this.m_clusterBreakNodeIndex && (this.deleteUserIndexForClusters(this.m_clusterBreakNodeIndex), this.m_clusterBreakNodeIndex = -1), this.deleteEdgeBitSets_(), this.deleteChainBitSets_(), this.m_emptyBitSet = null, this.m_geometryMapID = null, this.m_shape = null, this.m_clusterData.deleteAll(true), this.m_clusterVertices.deleteAll(true), this.m_firstCluster = cr, this.m_lastCluster = cr, this.m_halfEdgeData.deleteAll(true), this.m_edgeIndices.length = 0, this.m_clusterIndices.length = 0, this.m_chainIndices.length = 0, this.m_chainData.deleteAll(true), this.m_universeChain = cr, this.m_chainAreas = null);
  }
  getClusterHalfEdge(e5) {
    return this.m_clusterData.getField(e5, 2);
  }
  queryXY(e5, t3) {
    const s4 = this.getClusterVertexIndex_(e5);
    t3.assign(this.m_shape.getXYWithIndex(s4));
  }
  queryXYZ(e5, t3) {
    n2(0);
  }
  getClusterParentage(e5) {
    return this.m_clusterData.getField(e5, 1);
  }
  getFirstCluster() {
    return this.m_firstCluster;
  }
  getPrevCluster(e5) {
    return this.m_clusterData.getField(e5, 3);
  }
  getNextCluster(e5) {
    return this.m_clusterData.getField(e5, 4);
  }
  getClusterChain(e5) {
    return this.m_clusterData.getField(e5, 6);
  }
  getClusterVertexIterator(e5) {
    return this.m_clusterData.getField(e5, 7);
  }
  incrementVertexIterator(e5) {
    return this.m_clusterVertices.getField(e5, 1);
  }
  getVertexFromVertexIterator(e5) {
    return this.m_clusterVertices.getField(e5, 0);
  }
  getClusterUserIndex(e5, t3) {
    const s4 = this.getClusterIndex_(e5), n6 = this.m_clusterIndices[t3];
    return n6.size() <= s4 ? -1 : n6.read(s4);
  }
  setClusterUserIndex(e5, t3, s4) {
    const n6 = this.getClusterIndex_(e5), r = this.m_clusterIndices[t3];
    r.size() <= n6 && r.resize(this.m_clusterData.size(), -1), r.write(n6, s4);
  }
  hasClusterUserIndexFlags(e5, t3, s4) {
    if (-1 === t3) return false;
    const n6 = this.getClusterUserIndex(e5, t3);
    return -1 !== n6 && 0 !== (s4 & n6);
  }
  setClusterUserIndexFlags(e5, t3, s4) {
    const n6 = this.getClusterIndex_(e5), r = this.m_clusterIndices[t3];
    r.size() <= n6 && r.resize(this.m_clusterData.size(), -1);
    let i2 = r.read(n6);
    -1 === i2 && (i2 = 0), r.write(n6, s4 | i2);
  }
  clearClusterUserIndexFlags(e5, t3, s4) {
    const n6 = this.getClusterIndex_(e5), r = this.m_clusterIndices[t3];
    r.size() <= n6 && r.resize(this.m_clusterData.size(), -1);
    let i2 = r.read(n6);
    -1 === i2 && (i2 = 0), r.write(n6, ~s4 & i2);
  }
  createUserIndexForClusters(e5 = -1) {
    const t3 = new st2(this.m_clusterData.capacity(), e5);
    for (let s4 = 0, n6 = this.m_clusterIndices.length; s4 < n6; s4++) if (null === this.m_clusterIndices[s4]) return this.m_clusterIndices[s4] = t3, s4;
    this.m_clusterIndices.push(t3);
    return this.m_clusterIndices.length - 1;
  }
  deleteUserIndexForClusters(e5) {
    this.m_clusterIndices[e5] = null;
  }
  getHalfEdgeOrigin(e5) {
    return this.m_halfEdgeData.getField(e5, 1);
  }
  getHalfEdgeTo(e5) {
    return this.getHalfEdgeOrigin(this.getHalfEdgeTwin(e5));
  }
  getHalfEdgeTwin(e5) {
    return this.m_halfEdgeData.getField(e5, 4);
  }
  getHalfEdgePrev(e5) {
    return this.m_halfEdgeData.getField(e5, 5);
  }
  getHalfEdgeNext(e5) {
    return this.m_halfEdgeData.getField(e5, 6);
  }
  getHalfEdgeChain(e5) {
    return this.m_halfEdgeData.getField(e5, 2);
  }
  getHalfEdgeFaceParentage(e5) {
    return this.getChainParentage(this.getHalfEdgeChain(e5));
  }
  getHalfEdgeVertexIterator(e5) {
    return this.m_halfEdgeData.getField(e5, 7);
  }
  getHalfEdgeFromXY(e5, t3) {
    this.queryXY(this.getHalfEdgeOrigin(e5), t3);
  }
  getHalfEdgeToXY(e5, t3) {
    this.queryXY(this.getHalfEdgeTo(e5), t3);
  }
  isHalfEdgeCurve(e5) {
    if (-1 !== this.m_segmentIndexHe) {
      return -1 !== this.getHalfEdgeUserIndex(e5, this.m_segmentIndexHe);
    }
    return false;
  }
  getHalfEdgeFromXYZ(e5, t3) {
    n2(0);
  }
  getHalfEdgeToXYZ(e5, t3) {
    n2(0);
  }
  getHalfEdgeParentage(e5) {
    return this.m_halfEdgeData.getField(e5, 3) & _tn.c_EdgeParentageMask;
  }
  getHalfEdgeUserIndex(e5, t3) {
    const s4 = this.getHalfEdgeIndex_(e5), n6 = this.m_edgeIndices[t3];
    return n6.size() <= s4 ? -1 : n6.read(s4);
  }
  setHalfEdgeUserIndex(e5, t3, s4) {
    const n6 = this.getHalfEdgeIndex_(e5), r = this.m_edgeIndices[t3];
    r.size() <= n6 && r.resize(this.m_halfEdgeData.size(), -1), r.write(n6, s4);
  }
  createUserIndexForHalfEdges(e5) {
    void 0 === e5 && (e5 = -1);
    const t3 = new st2(this.m_halfEdgeData.capacity(), e5);
    for (let n6 = 0, r = this.m_edgeIndices.length; n6 < r; n6++) if (null === this.m_edgeIndices[n6]) return this.m_edgeIndices[n6] = t3, n6;
    this.m_edgeIndices.push(t3);
    const s4 = this.m_edgeIndices.length - 1;
    return n2(s4 >= 0 && s4 <= Number.MAX_SAFE_INTEGER), s4;
  }
  deleteUserIndexForHalfEdges(e5) {
    this.m_edgeIndices[e5] = null;
  }
  deleteEdgesBreakFaces_(e5) {
    for (let t3 = 0, s4 = e5.length; t3 < s4; t3++) {
      const s5 = e5[t3], n6 = this.getHalfEdgeChain(s5), r = this.getHalfEdgeTwin(s5), i2 = this.getHalfEdgeChain(r);
      this.setChainHalfEdge_(n6, cr), this.setChainHalfEdge_(i2, cr), this.updateVertexToHalfEdgeConnection_(s5, true), this.deleteEdgeImpl_(s5);
    }
  }
  doesHalfEdgeBelongToAPolygonInterior(e5, t3) {
    return n2(0), false;
  }
  doesHalfEdgeBelongToAPolygonExterior(e5, t3) {
    return n2(0), false;
  }
  doesHalfEdgeBelongToAPolygonBoundary(e5, t3) {
    return n2(0), false;
  }
  doesHalfEdgeBelongToAPolylineInterior(e5, t3) {
    return n2(0), false;
  }
  doesHalfEdgeBelongToAPolylineExterior(e5, t3) {
    return n2(0), false;
  }
  doesClusterBelongToAPolygonInterior(e5, t3) {
    return n2(0), false;
  }
  doesClusterBelongToAPolygonExterior(e5, t3) {
    return n2(0), false;
  }
  doesClusterBelongToAPolygonBoundary(e5, t3) {
    return n2(0), false;
  }
  getFirstChain() {
    return this.m_universeChain;
  }
  getChainHalfEdge(e5) {
    return this.m_chainData.getField(e5, 1);
  }
  getChainParentage(e5) {
    return this.m_chainData.getField(e5, 2);
  }
  getChainParent(e5) {
    return this.m_chainData.getField(e5, 3);
  }
  getChainFirstIsland(e5) {
    return this.m_chainData.getField(e5, 4);
  }
  getChainNextInParent(e5) {
    return this.m_chainData.getField(e5, 5);
  }
  getChainNext(e5) {
    return this.m_chainData.getField(e5, 7);
  }
  getChainArea(e5) {
    const t3 = this.getChainIndex_(e5);
    let s4 = this.m_chainAreas.read(t3);
    return Number.isNaN(s4) && (this.updateChainAreaAndPerimeter_(e5), s4 = this.m_chainAreas.read(t3)), s4;
  }
  getChainPerimeter(e5) {
    return n2(0), 0;
  }
  getChainUserIndex(e5, t3) {
    const s4 = this.getChainIndex_(e5), n6 = this.m_chainIndices[t3];
    return n6.size() <= s4 ? -1 : n6.read(s4);
  }
  setChainUserIndex(e5, t3, s4) {
    const n6 = this.getChainIndex_(e5), r = this.m_chainIndices[t3];
    r.size() <= n6 && r.resize(this.m_chainData.size(), -1), r.write(n6, s4);
  }
  createUserIndexForChains() {
    const e5 = new st2(this.m_chainData.capacity(), -1);
    for (let t3 = 0, s4 = this.m_chainIndices.length; t3 < s4; t3++) if (null === this.m_chainIndices[t3]) return this.m_chainIndices[t3] = e5, t3;
    this.m_chainIndices.push(e5);
    return this.m_chainIndices.length - 1;
  }
  deleteUserIndexForChains(e5) {
    this.m_chainIndices[e5] = null;
  }
  extractPolygonFromChainAndIslands(e5, t3, s4, r) {
    const i2 = t3 === cr ? e5.createGeometry(a.enumPolygon) : t3, o = new fm();
    this.extractPolygonPathFromChain_(e5, i2, s4, r, o);
    for (let n6 = this.getChainFirstIsland(s4); n6 !== cr; n6 = this.getChainNextInParent(n6)) this.extractPolygonPathFromChain_(e5, i2, n6, r, o);
    return i2;
  }
  getGeometryID(e5) {
    const t3 = this.m_shape.getGeometryUserIndex(e5, this.m_geometryIDIndex);
    return n2(t3 >= 0), 1 << Math.min(t3, 31);
  }
  getClusterFromVertex(e5) {
    return this.m_shape.getUserIndex(e5, this.m_clusterIndex);
  }
  getHalfEdgeFromVertex(e5) {
    return this.m_shape.getUserIndex(e5, this.m_halfEdgeIndex);
  }
  buildGeometryParentageSets() {
    this.m_bBuildGeometryParentageSets = true;
  }
  getChainBitSet(e5) {
    if (n2(this.m_bBuildGeometryParentageSets), -1 === this.m_chainBitSetIndex) return this.getEmptySet();
    const t3 = this.getChainUserIndex(e5, this.m_chainBitSetIndex);
    n2(t3 >= 0);
    let s4 = this.m_chainBitSets.at(t3);
    return s4 || (s4 = this.getEmptySet()), s4;
  }
  getChainBoundaryBitSet(e5) {
    n2(this.m_bBuildGeometryParentageSets);
    const t3 = new Ls3(), s4 = (e6) => {
      const s5 = this.getChainHalfEdge(e6);
      let n6 = s5;
      do {
        const e7 = this.getEdgeBitSet_(n6);
        null !== e7 && t3.assignOr(e7);
        const s6 = this.getEdgeBitSet_(this.getHalfEdgeTwin(n6));
        null !== s6 && t3.assignOr(s6), n6 = this.getHalfEdgeNext(n6);
      } while (n6 !== s5);
    };
    s4(e5);
    for (let n6 = this.getChainFirstIsland(e5); n6 !== cr; n6 = this.getChainNextInParent(n6)) s4(e5);
    return t3;
  }
  getChainPolygons(e5) {
    return n2(0), [];
  }
  getGeometriesFromBits(e5) {
    if (!this.m_bBuildGeometryParentageSets || null === e5) return [];
    if (null === this.m_geometryMapID) {
      this.m_geometryMapID = /* @__PURE__ */ new Map();
      for (let e6 = this.m_shape.getFirstGeometry(); e6 !== cr; e6 = this.m_shape.getNextGeometry(e6)) this.m_geometryMapID.set(this.m_shape.getGeometryUserIndex(e6, this.m_geometryIDIndex), e6);
    }
    const t3 = [], s4 = e5.getUnorderedBitIterator();
    for (let n6 = s4.next(); n6 !== Ys3.npos(); n6 = s4.next()) n2(this.m_geometryMapID.has(n6)), t3.push(this.m_geometryMapID.get(n6));
    return t3;
  }
  getVertexDominant(e5, t3) {
    if (t3 === cr) return e5;
    const s4 = this.getClusterFromVertex(e5);
    return this.getVertexDominantFromCluster(s4, t3);
  }
  getVertexDominantFromCluster(e5, t3) {
    if (t3 !== cr) {
      let s4 = cr;
      for (let n6 = this.getClusterVertexIterator(e5); n6 !== cr; n6 = this.incrementVertexIterator(n6)) {
        const e6 = this.getVertexFromVertexIterator(n6);
        s4 === cr && (s4 = e6);
        const r = this.m_shape.getPathFromVertex(e6);
        if (this.m_shape.getGeometryFromPath(r) === t3) {
          s4 = e6;
          break;
        }
      }
      return s4;
    }
    {
      const t4 = this.getClusterVertexIterator(e5);
      if (t4 !== cr) {
        return this.getVertexFromVertexIterator(t4);
      }
      return cr;
    }
  }
  isBreakNode(e5) {
    return this.hasClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ks2.enumSegmentParentageBreakNode);
  }
  setBreakNode(e5, t3) {
    n2(-1 !== this.m_clusterBreakNodeIndex), t3 ? this.setClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ks2.enumSegmentParentageBreakNode) : this.clearClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ks2.enumSegmentParentageBreakNode);
  }
  isStrongPathNode(e5) {
    return this.hasClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ks2.enumPathBreakNode);
  }
  setStrongPathNode(e5, t3) {
    if (-1 === this.m_clusterBreakNodeIndex) {
      if (!t3) return;
      this.m_clusterBreakNodeIndex = this.createUserIndexForClusters();
    }
    t3 ? this.setClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ks2.enumPathBreakNode) : this.clearClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ks2.enumPathBreakNode);
  }
  getSegmentParentage(e5) {
    if (-1 === this.m_segmentParentageIndex) return -1;
    const t3 = this.getHalfEdgeUserIndex(e5, this.m_segmentParentageIndex);
    return t3 >= 0 ? t3 : -1;
  }
  isCrossroadAhead(e5) {
    const t3 = this.getHalfEdgeNext(e5);
    if (this.isStrongPathNode(this.getHalfEdgeOrigin(t3))) return true;
    const s4 = this.getHalfEdgeTwin(t3), n6 = this.getHalfEdgeNext(s4);
    return e5 !== this.getHalfEdgeTwin(n6);
  }
  isCrossroadBehind(e5) {
    return n2(0), false;
  }
  getHalfEdgeConnector(e5, t3) {
    const s4 = this.getClusterHalfEdge(e5);
    if (s4 === cr) return cr;
    let n6 = s4, r = cr, i2 = cr;
    do {
      if (this.getHalfEdgeTo(n6) === t3) return n6;
      if (r === cr) {
        if (r = this.getClusterHalfEdge(t3), r === cr) return cr;
        i2 = r;
      }
      if (this.getHalfEdgeTo(i2) === e5) return n6 = this.getHalfEdgeTwin(i2), n6;
      n6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n6)), i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
    } while (n6 !== s4 && i2 !== r);
    return cr;
  }
  querySegmentXY(e5, t3) {
    if (-1 !== this.m_segmentIndexHe) {
      let s5 = this.getHalfEdgeUserIndex(e5, this.m_segmentIndexHe);
      if (-1 !== s5) {
        if (-2 !== s5) {
          const e6 = this.m_shape.getSegmentFromIndex(s5);
          t3.copyFrom(e6, true);
        } else {
          s5 = this.getHalfEdgeUserIndex(this.getHalfEdgeTwin(e5), this.m_segmentIndexHe);
          const n7 = this.m_shape.getSegmentFromIndex(s5);
          t3.copyFrom(n7, true), t3.get().reverse();
        }
        return;
      }
    }
    t3.createLine();
    const s4 = t3.get(), n6 = mi.getNAN();
    this.getHalfEdgeFromXY(e5, n6), s4.setStartXY(n6), this.getHalfEdgeToXY(e5, n6), s4.setEndXY(n6);
  }
  isCurveEdge(e5) {
    if (-1 !== this.m_segmentIndexHe) {
      return -1 !== this.getHalfEdgeUserIndex(e5, this.m_segmentIndexHe);
    }
    return false;
  }
  compareEdgeAnglesCurveHelper_(e5, t3, s4) {
    const n6 = new fm(), r = new fm();
    this.querySegmentXY(e5, n6), this.querySegmentXY(t3, r);
    const i2 = n6.get(), o = r.get();
    if (i2.equals(o)) return 0;
    const h2 = new mi();
    this.getHalfEdgeFromXY(e5, h2);
    const m3 = new mi();
    this.getHalfEdgeToXY(e5, m3);
    const l2 = new mi();
    this.getHalfEdgeToXY(t3, l2), n2(!m3.isEqualPoint2D(l2));
    return ze(i2, o);
  }
  compareEdgeAnglesHelper_(e5, t3, s4) {
    if (e5 === t3) return 0;
    if (this.isHalfEdgeCurve(e5) || this.isHalfEdgeCurve(t3)) return this.compareEdgeAnglesCurveHelper_(e5, t3, s4);
    const n6 = mi.getNAN();
    this.getHalfEdgeToXY(e5, n6);
    const r = mi.getNAN();
    if (this.getHalfEdgeToXY(t3, r), n6.isEqualPoint2D(r)) return 0;
    const i2 = mi.getNAN();
    this.getHalfEdgeFromXY(e5, i2);
    const o = mi.getNAN();
    o.setSub(n6, i2);
    const a2 = mi.getNAN();
    if (a2.setSub(r, i2), !s4 || a2.y >= 0 && o.y > 0) {
      return mi.compareVectors(o, a2);
    }
    return 0;
  }
  compareEdgeAngles_(e5, t3) {
    return this.compareEdgeAnglesHelper_(e5, t3, false);
  }
  compareEdgeAnglesForPair_(e5, t3) {
    return this.compareEdgeAnglesHelper_(e5, t3, true);
  }
  compareEdgeAngles3D_(e5, t3) {
    return n2(0), 0;
  }
  compareEdgeAnglesForPair3D_(e5, t3) {
    return n2(0), 0;
  }
  dbgDumpChains_() {
  }
  dbgDumpChainToPolygon_(e5, t3) {
  }
  deleteEdgeInternal_(e5) {
    const t3 = this.getHalfEdgeChain(e5), s4 = this.getHalfEdgeTwin(e5), n6 = this.getHalfEdgeChain(s4);
    n2(n6 === t3), n2(e5 === this.getHalfEdgeNext(s4) || s4 === this.getHalfEdgeNext(e5));
    let r = this.getHalfEdgeNext(e5);
    r === s4 && (r = this.getHalfEdgeNext(r), r === e5 && (r = cr));
    const i2 = this.getChainIndex_(t3), o = this.m_chainAreas.read(i2);
    Number.isNaN(o) || (this.setChainArea_(t3, Number.NaN), this.setChainPerimeter_(t3, Number.NaN));
    const h2 = this.getChainHalfEdge(t3);
    h2 !== e5 && h2 !== s4 || this.setChainHalfEdge_(t3, r), this.updateVertexToHalfEdgeConnection_(e5, true), this.deleteEdgeImpl_(e5);
  }
  getFirstUnvisitedHalfEdgeOnCluster_(e5, t3, s4) {
    let n6 = t3 !== cr ? t3 : this.getClusterHalfEdge(e5);
    if (n6 === cr) return cr;
    const r = n6;
    for (; ; ) {
      if (1 !== this.getHalfEdgeUserIndex(n6, s4)) return n6;
      const e6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n6));
      if (e6 === r) return cr;
      n6 = e6;
    }
  }
  removeSpikes_() {
    let e5 = false;
    const t3 = this.createUserIndexForHalfEdges();
    for (let s4 = this.getFirstCluster(); s4 !== cr; s4 = this.getNextCluster(s4)) {
      let n6 = cr;
      for (; ; ) {
        let r = this.getFirstUnvisitedHalfEdgeOnCluster_(s4, n6, t3);
        if (r === cr) break;
        n6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(r));
        let i2 = r;
        for (; ; ) {
          const s5 = this.getHalfEdgeNext(i2), o = this.getHalfEdgePrev(i2), a2 = this.getHalfEdgeTwin(i2);
          if (o === a2) {
            if (this.deleteEdgeInternal_(i2), e5 = true, n6 !== i2 && n6 !== a2 || (n6 = cr), i2 === r || o === r) {
              if (r = s5, i2 === r || o === r) break;
              i2 = s5;
              continue;
            }
          } else this.setHalfEdgeUserIndex(i2, t3, 1);
          if (i2 = s5, i2 === r) break;
        }
      }
    }
    return this.deleteUserIndexForHalfEdges(t3), e5;
  }
  progress_(e5, t3 = false) {
  }
  newCluster_() {
    const e5 = this.m_clusterData.newElement();
    return this.m_clusterData.setField(e5, 1, 0), e5;
  }
  newHalfEdgePair_() {
    const e5 = this.m_halfEdgeData.newElement();
    this.m_halfEdgeData.setField(e5, 2, 0), this.m_halfEdgeData.setField(e5, 3, 0);
    const t3 = this.m_halfEdgeData.newElement();
    return this.m_halfEdgeData.setField(t3, 2, 0), this.m_halfEdgeData.setField(t3, 3, 0), this.setHalfEdgeTwin_(e5, t3), this.setHalfEdgeTwin_(t3, e5), e5;
  }
  newChain_() {
    const e5 = this.m_chainData.newElement();
    return this.m_chainData.setField(e5, 2, 0), e5;
  }
  deleteChain_(e5) {
    return n2(0), 0;
  }
  getClusterIndex_(e5) {
    return this.m_clusterData.elementToIndex(e5);
  }
  setClusterVertexIterator_(e5, t3) {
    this.m_clusterData.setField(e5, 7, t3);
  }
  setClusterHalfEdge_(e5, t3) {
    this.m_clusterData.setField(e5, 2, t3);
  }
  setClusterParentage_(e5, t3) {
    this.m_clusterData.setField(e5, 1, t3);
  }
  setPrevCluster_(e5, t3) {
    this.m_clusterData.setField(e5, 3, t3);
  }
  setNextCluster_(e5, t3) {
    this.m_clusterData.setField(e5, 4, t3);
  }
  setClusterVertexIndex_(e5, t3) {
    this.m_clusterData.setField(e5, 5, t3);
  }
  getClusterVertexIndex_(e5) {
    return this.m_clusterData.getField(e5, 5);
  }
  setClusterChain_(e5, t3) {
    this.m_clusterData.setField(e5, 6, t3);
  }
  addClusterToExteriorChain_(e5, t3) {
    this.setClusterChain_(t3, e5);
  }
  getHalfEdgeIndex_(e5) {
    return this.m_halfEdgeData.elementToIndex(e5);
  }
  setHalfEdgeOrigin_(e5, t3) {
    this.m_halfEdgeData.setField(e5, 1, t3);
  }
  setHalfEdgeTwin_(e5, t3) {
    this.m_halfEdgeData.setField(e5, 4, t3);
  }
  setHalfEdgePrev_(e5, t3) {
    this.m_halfEdgeData.setField(e5, 5, t3);
  }
  setHalfEdgeNext_(e5, t3) {
    this.m_halfEdgeData.setField(e5, 6, t3);
  }
  setHalfEdgeChain_(e5, t3) {
    this.m_halfEdgeData.setField(e5, 2, t3);
  }
  setHalfEdgeParentage_(e5, t3) {
    this.m_halfEdgeData.setField(e5, 3, t3);
  }
  getHalfEdgeParentageMask_(e5) {
    return this.m_halfEdgeData.getField(e5, 3);
  }
  setHalfEdgeVertexIterator_(e5, t3) {
    this.m_halfEdgeData.setField(e5, 7, t3);
  }
  updateVertexToHalfEdgeConnectionHelper_(e5, t3) {
    const s4 = t3 ? cr : e5;
    for (let n6 = this.getHalfEdgeVertexIterator(e5); n6 !== cr; n6 = this.incrementVertexIterator(n6)) {
      const e6 = this.getVertexFromVertexIterator(n6);
      this.m_shape.setUserIndex(e6, this.m_halfEdgeIndex, s4);
    }
  }
  updateVertexToHalfEdgeConnection_(e5, t3) {
    e5 !== cr && (this.updateVertexToHalfEdgeConnectionHelper_(e5, t3), this.updateVertexToHalfEdgeConnectionHelper_(this.getHalfEdgeTwin(e5), t3));
  }
  getChainIndex_(e5) {
    return this.m_chainData.elementToIndex(e5);
  }
  setChainHalfEdge_(e5, t3) {
    this.m_chainData.setField(e5, 1, t3);
  }
  setChainParentage_(e5, t3) {
    this.m_chainData.setField(e5, 2, t3);
  }
  setChainParent_(e5, t3) {
    this.m_chainData.setField(e5, 3, t3);
    const s4 = this.getChainFirstIsland(t3);
    this.setChainNextInParent_(e5, s4), this.setChainFirstIsland_(t3, e5);
  }
  setChainFirstIsland_(e5, t3) {
    this.m_chainData.setField(e5, 4, t3);
  }
  setChainNextInParent_(e5, t3) {
    this.m_chainData.setField(e5, 5, t3);
  }
  setChainPrev_(e5, t3) {
    this.m_chainData.setField(e5, 6, t3);
  }
  setChainNext_(e5, t3) {
    this.m_chainData.setField(e5, 7, t3);
  }
  setChainArea_(e5, t3) {
    const s4 = this.getChainIndex_(e5);
    this.m_chainAreas.write(s4, t3);
  }
  setChainPerimeter_(e5, t3) {
    const s4 = this.getChainIndex_(e5);
    this.m_chainPerimeters.write(s4, t3);
  }
  updateChainAreaAndPerimeter_(e5) {
    const t3 = this.m_shape.hasCurves(), s4 = new n3(0), n6 = new n3(0), r = this.getChainHalfEdge(e5), i2 = mi.getNAN(), o = mi.getNAN(), a2 = mi.getNAN();
    this.getHalfEdgeFromXY(r, i2), o.setCoordsPoint2D(i2);
    let h2 = r;
    do {
      this.getHalfEdgeToXY(h2, a2), t3 && this.isCurveEdge(h2) || n6.pe(mi.distance(o, a2));
      this.getHalfEdgeChain(this.getHalfEdgeTwin(h2)) !== e5 && s4.pe((a2.x - i2.x - (o.x - i2.x)) * (a2.y - i2.y + (o.y - i2.y)) * 0.5), o.setCoordsPoint2D(a2), h2 = this.getHalfEdgeNext(h2);
    } while (h2 !== r);
    if (t3) {
      const t4 = new fm();
      h2 = r;
      do {
        this.getHalfEdgeToXY(h2, a2);
        const r2 = this.isCurveEdge(h2);
        r2 && (this.querySegmentXY(h2, t4), n6.pe(t4.get().calculateLength2D()));
        if (this.getHalfEdgeChain(this.getHalfEdgeTwin(h2)) !== e5 && r2) {
          const e6 = t4.get().calculateArea2DHelper();
          s4.pe(e6);
        }
        h2 = this.getHalfEdgeNext(h2);
      } while (h2 !== r);
    }
    const m3 = this.getChainIndex_(e5);
    this.m_chainAreas.write(m3, s4.getResult()), this.m_chainPerimeters.write(m3, n6.getResult());
  }
  getChainTopmostEdge_(e5) {
    return n2(0), 0;
  }
  planeSweepParentage_(e5, t3) {
    const s4 = new Ws3(this), n6 = new ct2();
    n6.setCapacity(Math.trunc(this.m_pointCount / 2)), n6.setComparator(s4);
    const r = [], i2 = this.createUserIndexForHalfEdges();
    let o = null;
    const a2 = mi.getNAN();
    for (let h2 = this.getFirstCluster(); h2 !== cr; h2 = this.getNextCluster(h2)) {
      this.progress_(t3);
      const m3 = this.getClusterHalfEdge(h2);
      if (m3 !== cr) {
        if (r.length = 0, !this.tryOptimizedInsertion_(n6, i2, r, h2, m3)) {
          this.queryXY(h2, a2), s4.setY(a2.y);
          let e6 = m3;
          do {
            const t4 = this.getHalfEdgeUserIndex(e6, i2);
            -1 !== t4 && (n6.deleteNode(t4), this.setHalfEdgeUserIndex(e6, i2, at.impossibleIndex2())), e6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(e6));
          } while (m3 !== e6);
          e6 = m3;
          do {
            if (-1 === this.getHalfEdgeUserIndex(e6, i2)) {
              const t4 = n6.addElement(e6);
              r.push(t4);
            }
            e6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(e6));
          } while (m3 !== e6);
        }
        for (let t4 = r.length - 1; t4 >= 0; t4--) {
          const s5 = r[t4], o2 = n6.getElement(s5), a3 = this.getHalfEdgeTwin(o2);
          this.setHalfEdgeUserIndex(a3, i2, s5), this.planeSweepParentagePropagateParentage_(n6, s5, e5);
        }
      } else if (this.getClusterChain(h2) === cr) {
        null === o && (o = new js3(this)), this.queryXY(h2, a2), o.setPointXY(a2);
        const e6 = n6.searchLowerBound(o);
        let t4 = this.m_universeChain;
        if (-1 !== e6) {
          let s5 = n6.getElement(e6);
          this.getHalfEdgeChain(s5) === this.getHalfEdgeChain(this.getHalfEdgeTwin(s5)) && (s5 = this.getLeftSkipPolylines_(n6, e6)), s5 !== cr && (t4 = this.getHalfEdgeChain(s5));
        }
        this.addClusterToExteriorChain_(t4, h2);
      }
    }
    this.deleteUserIndexForHalfEdges(i2);
  }
  planeSweepParentagePropagateParentage_(e5, t3, s4) {
    const n6 = e5.getElement(t3), r = this.getHalfEdgeChain(n6);
    if (this.getChainParent(r) !== cr) return;
    const i2 = this.getLeftSkipPolylines_(e5, t3), o = this.getHalfEdgeTwin(n6), h2 = this.getHalfEdgeChain(o);
    let m3 = this.getChainParent(r), l2 = this.getChainParent(h2);
    if (i2 === cr) m3 === cr && (h2 === r ? (this.setChainParent_(h2, this.m_universeChain), l2 = this.m_universeChain, m3 = l2) : (l2 === cr && (this.setChainParent_(h2, this.m_universeChain), l2 = this.m_universeChain), this.setChainParent_(r, h2), m3 = h2));
    else {
      const e6 = this.getHalfEdgeChain(i2);
      if (l2 === cr) {
        if (this.getChainArea(e6) <= 0) {
          const t4 = this.getChainParent(e6);
          this.setChainParent_(h2, t4), l2 = t4;
        } else this.setChainParent_(h2, e6), l2 = e6;
        h2 === r && (m3 = l2);
      }
    }
    m3 === cr && (this.trySetChainParentFromTwin_(r, h2), m3 = this.getChainParent(r)), n2(m3 !== cr), s4 === Zs3.enumInputModeBuildGraph ? this.propagateParentageBuildGraph_(e5, t3, n6, i2) : s4 === Zs3.enumInputModeSimplifyWinding ? this.propagateParentageWinding_(e5, t3, n6, i2, o, r, h2) : s4 === Zs3.enumInputModeSimplifyAlternate && this.propagateParentageAlternate_(e5, t3, n6, i2, o, r, h2);
  }
  propagateParentageBuildGraph_(e5, t3, s4, n6) {
    let r, i2 = t3;
    n6 === cr ? (i2 = e5.getNext(i2), r = this.getHalfEdgeChain(s4)) : r = this.getHalfEdgeChain(n6);
    let o = null, a2 = this.getChainParentage(r);
    for (this.m_bBuildGeometryParentageSets && (o = this.getChainBitSet(r)); -1 !== i2; i2 = e5.getNext(i2)) {
      const t4 = e5.getElement(i2), s5 = this.getHalfEdgeTwin(t4);
      r = this.getHalfEdgeChain(t4);
      const n7 = this.getHalfEdgeChain(s5);
      if (this.m_bBuildGeometryParentageSets) {
        let e6 = this.getChainBitSet(n7);
        e6 = new Ls3({ copy: e6 }), e6.assignOr(o), this.setChainBitSet_(n7, e6);
        let s6 = this.getChainBitSet(r);
        const i3 = this.getLeftEdgeBitSet_(t4), a3 = new Ls3({ copy: o });
        if (a3.assignSubtract(i3), a3.isZero()) break;
        s6 = new Ls3({ copy: s6 }), s6.assignOr(a3), this.setChainBitSet_(r, s6), o = s6;
      }
      const h2 = this.getChainParentage(n7), m3 = h2 | a2;
      m3 !== h2 && this.setChainParentage_(n7, m3);
      let l2 = this.getChainParentage(r);
      const g2 = a2 & ~this.getHalfEdgeUserIndex(t4, this.m_tmpHalfEdgeParentageIndexLeft);
      if (g2 && (l2 |= g2, this.setChainParentage_(r, l2)), 0 === g2) break;
      a2 = l2;
    }
  }
  propagateParentageWinding_(e5, t3, s4, n6, r, i2, o) {
    if (i2 === o) return;
    let h2 = this.getHalfEdgeUserIndex(s4, this.m_tmpHalfEdgeWindingNumberIndex);
    h2 += this.getHalfEdgeUserIndex(r, this.m_tmpHalfEdgeWindingNumberIndex);
    let m3 = 0;
    const l2 = [], g2 = [];
    g2.push(0);
    for (let u = e5.getFirst(); u !== t3; u = e5.getNext(u)) {
      const t4 = e5.getElement(u), s5 = this.getHalfEdgeTwin(t4), n7 = this.getHalfEdgeChain(t4), r2 = this.getHalfEdgeChain(s5);
      if (n7 !== r2) {
        let e6 = this.getHalfEdgeUserIndex(t4, this.m_tmpHalfEdgeWindingNumberIndex);
        e6 += this.getHalfEdgeUserIndex(s5, this.m_tmpHalfEdgeWindingNumberIndex), m3 += e6;
        let i3 = false;
        0 !== l2.length && l2.at(-1) === r2 && (g2.pop(), l2.pop(), i3 = true), n2(this.getChainParent(r2) !== cr), i3 && this.getChainParent(r2) === n7 || (g2.push(m3), l2.push(n7));
      }
    }
    if (m3 += h2, 0 !== l2.length && l2.at(-1) === o && (g2.pop(), l2.pop()), 0 !== m3) {
      if (0 === g2.at(-1)) {
        const e6 = this.m_simplifiedGeometry, t4 = this.getGeometryID(e6);
        this.setChainParentage_(i2, t4);
      }
    } else if (0 !== g2.at(-1)) {
      const e6 = this.m_simplifiedGeometry, t4 = this.getGeometryID(e6);
      this.setChainParentage_(i2, t4);
    }
  }
  propagateParentageAlternate_(e5, t3, s4, n6, r, i2, o) {
    const a2 = this.m_simplifiedGeometry, h2 = this.getGeometryID(a2);
    if (n6 === cr) {
      this.setChainParentage_(o, this.m_universeGeomID);
      1 & this.getHalfEdgeUserIndex(s4, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, h2) : this.setChainParentage_(i2, this.m_universeGeomID);
    } else {
      const e6 = this.getChainParentage(o);
      if (0 === e6) {
        const e7 = this.getHalfEdgeChain(n6), t4 = this.getChainParentage(e7);
        this.setChainParentage_(o, t4);
        1 & this.getHalfEdgeUserIndex(s4, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, t4 === h2 ? this.m_universeGeomID : h2) : this.setChainParentage_(i2, t4);
      } else {
        1 & this.getHalfEdgeUserIndex(s4, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, e6 === h2 ? this.m_universeGeomID : h2) : this.setChainParentage_(i2, e6);
      }
    }
  }
  tryOptimizedInsertion_(e5, t3, s4, n6, r) {
    let i2 = r, o = -1, a2 = cr, h2 = 0;
    do {
      if (2 === h2) return false;
      const e6 = this.getHalfEdgeUserIndex(i2, t3);
      if (-1 !== e6) {
        if (-1 !== o) return false;
        o = e6;
      } else {
        if (a2 !== cr) return false;
        a2 = i2;
      }
      h2++, i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
    } while (r !== i2);
    return a2 !== cr && -1 !== o && (this.setHalfEdgeUserIndex(e5.getElement(o), t3, at.impossibleIndex2()), e5.setElement(o, a2), s4.push(o), true);
  }
  trySetChainParentFromTwin_(e5, t3) {
    const s4 = this.getChainArea(e5);
    if (0 === s4) return false;
    const n6 = this.getChainArea(t3);
    if (s4 > 0 && n6 < 0 || s4 < 0 && n6 > 0) return this.setChainParent_(e5, t3), true;
    {
      const s5 = this.getChainParent(t3);
      if (s5 !== cr) return this.setChainParent_(e5, s5), true;
    }
    return false;
  }
  createHalfEdges_(e5, t3) {
    this.m_halfEdgeIndex = this.m_shape.createUserIndex();
    for (let s4 = 0, r = t3.size(); s4 < r; s4++) {
      const r2 = t3.read(s4), i2 = this.m_shape.getUserIndex(r2, this.m_clusterIndex), a2 = this.m_shape.getPathFromVertex(r2), h2 = this.m_shape.getGeometryFromPath(a2), m3 = this.m_shape.getGeometryType(h2);
      if (h(m3)) {
        const t4 = this.m_shape.getNextVertex(r2);
        if (t4 === cr) continue;
        const s5 = this.m_shape.getUserIndex(t4, this.m_clusterIndex);
        if (i2 === s5) continue;
        const o = this.newHalfEdgePair_(), a3 = this.getHalfEdgeTwin(o), l2 = this.m_clusterVertices.newElement();
        this.m_clusterVertices.setField(l2, 0, r2), this.m_clusterVertices.setField(l2, 1, -1), this.setHalfEdgeVertexIterator_(o, l2), this.m_shape.setUserIndex(r2, this.m_halfEdgeIndex, o), this.setHalfEdgeOrigin_(o, i2);
        const g2 = this.getClusterHalfEdge(i2);
        if (g2 === cr) this.setClusterHalfEdge_(i2, o), this.setHalfEdgePrev_(o, a3), this.setHalfEdgeNext_(a3, o);
        else {
          const e6 = this.getHalfEdgePrev(g2);
          this.setHalfEdgePrev_(g2, a3), this.setHalfEdgeNext_(a3, g2), this.setHalfEdgeNext_(e6, o), this.setHalfEdgePrev_(o, e6);
        }
        this.setHalfEdgeOrigin_(a3, s5);
        const u = this.getClusterHalfEdge(s5);
        if (u === cr) this.setClusterHalfEdge_(s5, a3), this.setHalfEdgeNext_(o, a3), this.setHalfEdgePrev_(a3, o);
        else {
          const e6 = this.getHalfEdgePrev(u);
          this.setHalfEdgePrev_(u, o), this.setHalfEdgeNext_(o, u), this.setHalfEdgeNext_(e6, a3), this.setHalfEdgePrev_(a3, e6);
        }
        const c = this.getGeometryID(h2);
        if (e5 === Zs3.enumInputModeBuildGraph) {
          const e6 = m3 === a.enumPolygon ? c : 0;
          if (this.setHalfEdgeUserIndex(a3, this.m_tmpHalfEdgeParentageIndex, 0), this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndex, e6), this.setHalfEdgeUserIndex(a3, this.m_tmpHalfEdgeParentageIndexLeft, e6), this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndexLeft, 0), this.m_bBuildGeometryParentageSets) {
            const e7 = new Ls3(), t5 = this.m_shape.getGeometryUserIndex(h2, this.m_geometryIDIndex);
            e7.setBit(t5), this.setEdgeBitSet_(o, e7), this.setEdgeBitSet_(a3, null), this.setLeftEdgeBitSet_(a3, e7), this.setLeftEdgeBitSet_(o, null);
          }
        } else if (e5 === Zs3.enumInputModeSimplifyWinding) {
          const e6 = this.m_shape.getXY(r2), s6 = this.m_shape.getXY(t4);
          let n6 = 0, i3 = 0;
          e6.compare(s6) < 0 ? n6 = 1 : i3 = -1, this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeWindingNumberIndex, n6), this.setHalfEdgeUserIndex(a3, this.m_tmpHalfEdgeWindingNumberIndex, i3);
        } else e5 === Zs3.enumInputModeSimplifyAlternate && (this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeOddEvenNumberIndex, 1), this.setHalfEdgeUserIndex(a3, this.m_tmpHalfEdgeOddEvenNumberIndex, 1));
        const _ = m3 === a.enumPolygon ? _tn.c_EdgeBitMask : 0;
        this.setHalfEdgeParentage_(o, c | _), this.setHalfEdgeParentage_(a3, c | _);
      }
    }
    if (this.m_shape.hasCurves()) {
      this.m_segmentIndexHe = this.createUserIndexForHalfEdges();
      for (let e6 = 0, s4 = t3.size(); e6 < s4; e6++) {
        const s5 = t3.read(e6);
        if (this.m_shape.getSegment(s5)) {
          const e7 = this.m_shape.getUserIndex(s5, this.m_halfEdgeIndex);
          e7 !== cr && (this.setHalfEdgeUserIndex(e7, this.m_segmentIndexHe, this.m_shape.getVertexIndex(s5)), this.setHalfEdgeUserIndex(this.getHalfEdgeTwin(e7), this.m_segmentIndexHe, -2));
        }
      }
    }
  }
  mergeVertexListsOfEdges_(e5, t3) {
    {
      const s5 = this.getHalfEdgeVertexIterator(t3);
      if (s5 !== cr) {
        const n7 = this.getHalfEdgeVertexIterator(e5);
        this.m_clusterVertices.setField(s5, 1, n7), this.setHalfEdgeVertexIterator_(e5, s5), this.setHalfEdgeVertexIterator_(t3, cr);
      }
    }
    const s4 = this.getHalfEdgeTwin(e5), n6 = this.getHalfEdgeTwin(t3);
    {
      const e6 = this.getHalfEdgeVertexIterator(n6);
      if (e6 !== cr) {
        const t4 = this.getHalfEdgeVertexIterator(s4);
        this.m_clusterVertices.setField(e6, 1, t4), this.setHalfEdgeVertexIterator_(s4, e6), this.setHalfEdgeVertexIterator_(n6, cr);
      }
    }
    if (-1 !== this.m_segmentIndexHe) {
      let r = this.getHalfEdgeUserIndex(e5, this.m_segmentIndexHe);
      if (-1 !== r) {
        if (-2 === r) {
          const s5 = this.getHalfEdgeUserIndex(t3, this.m_segmentIndexHe);
          this.setHalfEdgeUserIndex(e5, this.m_segmentIndexHe, s5);
        }
        if (r = this.getHalfEdgeUserIndex(s4, this.m_segmentIndexHe), -2 === r) {
          const e6 = this.getHalfEdgeUserIndex(n6, this.m_segmentIndexHe);
          this.setHalfEdgeUserIndex(s4, this.m_segmentIndexHe, e6);
        }
      }
    }
  }
  sortHalfEdgesByAngle_(e5) {
    const t3 = [];
    for (let s4 = this.getFirstCluster(); s4 !== cr; s4 = this.getNextCluster(s4)) {
      t3.length = 0;
      const n6 = this.getClusterHalfEdge(s4);
      if (n6 !== cr) {
        let r = n6;
        do {
          t3.push(r), r = this.getHalfEdgeNext(this.getHalfEdgeTwin(r));
        } while (r !== n6);
        if (t3.length > 1) {
          let r2 = true;
          t3.length > 2 ? (t3.sort((e6, t4) => this.compareEdgeAngles_(e6, t4)), t3.push(t3[0])) : this.compareEdgeAnglesForPair_(t3[0], t3[1]) > 0 ? t3[1] = Pt(t3[0], t3[0] = t3[1]) : r2 = false;
          let i2 = t3[0], o = i2, a2 = this.getHalfEdgeTo(o), h2 = this.getHalfEdgeTwin(o), m3 = cr;
          for (let s5 = 1, n7 = t3.length; s5 < n7; s5++) {
            const n8 = t3[s5], r3 = this.getHalfEdgeTwin(n8), l2 = this.getHalfEdgeOrigin(r3);
            if (l2 !== a2 || n8 === o) this.updateVertexToHalfEdgeConnection_(m3, false), m3 = cr, o = n8, a2 = l2, h2 = r3;
            else {
              if (e5 === Zs3.enumInputModeBuildGraph) {
                const e6 = this.getHalfEdgeParentageMask_(o) | this.getHalfEdgeParentageMask_(n8);
                if (this.setHalfEdgeParentage_(o, e6), this.setHalfEdgeParentage_(h2, e6), this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndex, this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndex) | this.getHalfEdgeUserIndex(n8, this.m_tmpHalfEdgeParentageIndex)), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndex, this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndex) | this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeParentageIndex)), this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndexLeft, this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndexLeft) | this.getHalfEdgeUserIndex(n8, this.m_tmpHalfEdgeParentageIndexLeft)), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndexLeft, this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndexLeft) | this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeParentageIndexLeft)), this.m_bBuildGeometryParentageSets) {
                  let e7, t4, s6;
                  e7 = this.getEdgeBitSet_(o), t4 = this.getEdgeBitSet_(n8), s6 = new Ls3({ copy: e7 }), s6.assignOr(t4), this.setEdgeBitSet_(o, s6), e7 = this.getEdgeBitSet_(h2), t4 = this.getEdgeBitSet_(r3), s6 = new Ls3({ copy: e7 }), s6.assignOr(t4), this.setEdgeBitSet_(h2, s6), e7 = this.getLeftEdgeBitSet_(o), t4 = this.getLeftEdgeBitSet_(n8), s6 = new Ls3({ copy: e7 }), s6.assignOr(t4), this.setLeftEdgeBitSet_(o, s6), e7 = this.getLeftEdgeBitSet_(h2), t4 = this.getLeftEdgeBitSet_(r3), s6 = new Ls3({ copy: e7 }), s6.assignOr(t4), this.setLeftEdgeBitSet_(h2, s6);
                }
              } else if (-1 !== this.m_tmpHalfEdgeWindingNumberIndex) {
                const e6 = this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeWindingNumberIndex) + this.getHalfEdgeUserIndex(n8, this.m_tmpHalfEdgeWindingNumberIndex), t4 = this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeWindingNumberIndex) + this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeWindingNumberIndex);
                this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeWindingNumberIndex, e6), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeWindingNumberIndex, t4);
              } else if (-1 !== this.m_tmpHalfEdgeOddEvenNumberIndex) {
                const e6 = this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeOddEvenNumberIndex) + this.getHalfEdgeUserIndex(n8, this.m_tmpHalfEdgeOddEvenNumberIndex), t4 = this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeOddEvenNumberIndex) + this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeOddEvenNumberIndex);
                this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeOddEvenNumberIndex, e6), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeOddEvenNumberIndex, t4);
              }
              this.mergeVertexListsOfEdges_(o, n8), this.deleteEdgeImpl_(n8), m3 = o, t3[s5] = cr, n8 === i2 && (t3[0] = cr, i2 = cr);
            }
          }
          if (this.updateVertexToHalfEdgeConnection_(m3, false), m3 = cr, !r2) {
            i2 = cr;
            for (let e6 = 0, s5 = t3.length; e6 < s5; e6++) {
              const s6 = t3[e6];
              if (s6 !== cr) {
                i2 = s6;
                break;
              }
            }
            n6 !== i2 && this.setClusterHalfEdge_(s4, i2);
            continue;
          }
          i2 = cr;
          for (let e6 = 0, s5 = t3.length; e6 < s5; e6++) {
            const s6 = t3[e6];
            if (s6 === cr) continue;
            if (i2 === cr) {
              i2 = s6, o = i2, a2 = this.getHalfEdgeTo(o), h2 = this.getHalfEdgeTwin(o);
              continue;
            }
            if (s6 === o) continue;
            const n7 = this.getHalfEdgeTwin(s6), r3 = this.getHalfEdgeOrigin(n7);
            this.setHalfEdgeNext_(h2, s6), this.setHalfEdgePrev_(s6, h2), o = s6, a2 = r3, h2 = n7;
          }
          this.setClusterHalfEdge_(s4, i2);
        }
      }
    }
  }
  sortHalfEdgesByAngle3D_(e5) {
    n2(0);
  }
  buildChains_(e5) {
    this.m_universeChain = this.newChain_(), this.setChainHalfEdge_(this.m_universeChain, cr);
    let t3 = this.m_universeChain;
    const s4 = this.createUserIndexForHalfEdges();
    for (let n6 = this.getFirstCluster(); n6 !== cr; n6 = this.getNextCluster(n6)) {
      const e6 = this.getClusterHalfEdge(n6);
      if (e6 !== cr) {
        let n7 = e6;
        do {
          if (1 !== this.getHalfEdgeUserIndex(n7, s4)) {
            const e7 = this.newChain_();
            this.setChainHalfEdge_(e7, n7), this.setChainPrev_(e7, t3), this.setChainNext_(t3, e7);
            let r = null;
            this.m_bBuildGeometryParentageSets && (r = new Ls3()), t3 = e7;
            let i2 = 0, o = n7;
            do {
              -1 !== this.m_tmpHalfEdgeParentageIndex && (i2 |= this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndex)), this.m_bBuildGeometryParentageSets && r.assignOr(this.getEdgeBitSet_(o)), this.setHalfEdgeChain_(o, e7), this.setHalfEdgeUserIndex(o, s4, 1), o = this.getHalfEdgeNext(o);
            } while (o !== n7);
            this.m_bBuildGeometryParentageSets && this.setChainBitSet_(e7, r), this.setChainParentage_(e7, i2);
          }
          n7 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n7));
        } while (n7 !== e6);
      }
    }
    this.m_chainAreas = new nt(this.m_chainData.size(), Number.NaN), this.m_chainPerimeters = new nt(this.m_chainData.size(), Number.NaN), this.setChainArea_(this.m_universeChain, Number.POSITIVE_INFINITY), this.setChainPerimeter_(this.m_universeChain, Number.POSITIVE_INFINITY), this.deleteUserIndexForHalfEdges(s4);
  }
  simplify_(e5) {
    n2(0);
  }
  simplifyAlternate_() {
    n2(0);
  }
  simplifyWinding_() {
    n2(0);
  }
  setEditShapeImpl_(e5, t3, s4, n6, r) {
    this.removeShape(), this.m_bBuildChains = r, this.m_shape = e5, this.m_geometryIDIndex = this.m_shape.createGeometryUserIndex();
    let i2 = this.m_shape.getTotalPointCount();
    if (s4) {
      i2 = 0;
      for (let e6 = 0, t4 = s4.length; e6 < t4; e6++) i2 += this.m_shape.getPointCount(s4[e6]);
    }
    const o = new st2(0);
    let a2 = 0, h2 = 0;
    {
      let e6 = null != s4 ? s4[0] : this.m_shape.getFirstGeometry(), t4 = 1;
      for (; e6 !== cr; ) {
        this.m_shape.setGeometryUserIndex(e6, this.m_geometryIDIndex, h2++);
        for (let t5 = this.m_shape.getFirstPath(e6); t5 !== cr; t5 = this.m_shape.getNextPath(t5)) {
          let e7 = this.m_shape.getFirstVertex(t5);
          for (let s5 = 0, n7 = this.m_shape.getPathSize(t5); s5 < n7; s5++) o.add(e7), e7 = this.m_shape.getNextVertex(e7);
        }
        l(this.m_shape.getGeometryType(e6)) || (a2 += this.m_shape.getPathCount(e6)), null != s4 ? (e6 = t4 < s4.length ? s4[t4] : cr, t4++) : e6 = this.m_shape.getNextGeometry(e6);
      }
    }
    this.m_universeGeomID = 1 << Math.min(h2, 31), this.m_pointCount = o.size(), this.m_shape.sortVerticesSimpleByY(o, 0, this.m_pointCount), this.m_clusterVertices.setCapacity(this.m_pointCount), this.progress_(n6, true), this.m_clusterData.setCapacity(this.m_pointCount + 10), this.m_halfEdgeData.setCapacity(2 * this.m_pointCount + 32), this.m_chainData.setCapacity(Math.max(32, a2)), this.m_clusterIndex = this.m_shape.createUserIndex();
    const m3 = mi.getNAN();
    let l2 = 0;
    const g2 = mi.getNAN();
    for (let u = 0; u <= this.m_pointCount; u++) {
      if (u < this.m_pointCount) {
        const e6 = o.read(u);
        this.m_shape.queryXY(e6, g2);
      } else g2.setNAN();
      if (!m3.isEqualPoint2D(g2)) {
        if (l2 < u) {
          const e6 = this.newCluster_();
          let t4 = cr, s5 = -1;
          for (let n7 = l2; n7 < u; n7++) {
            s5 = o.read(n7), this.m_shape.setUserIndex(s5, this.m_clusterIndex, e6);
            const r2 = this.m_clusterVertices.newElement();
            this.m_clusterVertices.setField(r2, 0, s5), this.m_clusterVertices.setField(r2, 1, t4), t4 = r2;
            const i3 = this.m_shape.getPathFromVertex(s5), a3 = this.m_shape.getGeometryFromPath(i3), h3 = this.getGeometryID(a3);
            this.setClusterParentage_(e6, this.getClusterParentage(e6) | h3);
          }
          this.setClusterVertexIterator_(e6, t4), this.setClusterVertexIndex_(e6, this.m_shape.getVertexIndex(s5)), this.m_lastCluster !== cr && this.setNextCluster_(this.m_lastCluster, e6), this.setPrevCluster_(e6, this.m_lastCluster), this.m_lastCluster = e6, this.m_firstCluster === cr && (this.m_firstCluster = e6);
        }
        l2 = u, m3.setCoordsPoint2D(g2);
      }
    }
    if (this.m_shape.hasSegmentParentage()) {
      -1 === this.m_clusterBreakNodeIndex && (this.m_clusterBreakNodeIndex = this.createUserIndexForClusters());
      for (let e6 = 0; e6 < this.m_pointCount; e6++) {
        const t4 = o.read(e6);
        if (this.m_shape.getSegmentParentageBreakVertex(t4)) {
          const e7 = this.getClusterFromVertex(t4);
          this.setBreakNode(e7, true);
        }
      }
    }
    this.progress_(n6, true);
    {
      let e6 = null != s4 ? s4[0] : this.m_shape.getFirstGeometry(), t4 = 1;
      for (; e6 !== cr; ) {
        for (let t5 = this.m_shape.getFirstPath(e6); t5 !== cr; t5 = this.m_shape.getNextPath(t5)) {
          if (this.m_shape.isStrongPathStart(t5)) {
            const e7 = this.m_shape.getFirstVertex(t5), s5 = this.getClusterFromVertex(e7);
            this.setStrongPathNode(s5, true);
          }
          if (this.m_shape.isStrongPathEnd(t5)) {
            const e7 = this.m_shape.isClosedPath(t5) ? this.m_shape.getFirstVertex(t5) : this.m_shape.getLastVertex(t5), s5 = this.getClusterFromVertex(e7);
            this.setStrongPathNode(s5, true);
          }
        }
        null != s4 ? (e6 = t4 < s4.length ? s4[t4] : cr, t4++) : e6 = this.m_shape.getNextGeometry(e6);
      }
    }
    if (t3 === Zs3.enumInputModeBuildGraph && (this.m_tmpHalfEdgeParentageIndex = this.createUserIndexForHalfEdges(), this.m_tmpHalfEdgeParentageIndexLeft = this.createUserIndexForHalfEdges()), t3 === Zs3.enumInputModeSimplifyWinding && (this.m_tmpHalfEdgeWindingNumberIndex = this.createUserIndexForHalfEdges()), t3 === Zs3.enumInputModeSimplifyAlternate && (this.m_tmpHalfEdgeOddEvenNumberIndex = this.createUserIndexForHalfEdges()), this.createHalfEdges_(t3, o), this.dbgNavigate_(), this.sortHalfEdgesByAngle_(t3), !Number.isNaN(this.m_checkDirtyPlanesweepTolerance) && !this.checkStructureAfterDirtySweep_()) return this.m_bDirtyCheckFailed = true, void this.cleanSetEditShapeImpl_();
    this.buildChains_(t3), -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), this.m_bBuildChains && this.planeSweepParentage_(t3, n6), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), this.dbgChkChainParents_(), this.dbgDumpChains_(), this.mergeSegmentParentage_(), this.dbgNavigate_(), this.dbgDumpChains_(), this.cleanSetEditShapeImpl_();
  }
  setEditShapeImpl3D_(e5, t3, s4, n6, r) {
    n2(0);
  }
  cleanSetEditShapeImpl_() {
    -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), -1 !== this.m_tmpHalfEdgeWindingNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex), this.m_tmpHalfEdgeWindingNumberIndex = -1), -1 !== this.m_tmpHalfEdgeOddEvenNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex), this.m_tmpHalfEdgeOddEvenNumberIndex = -1);
  }
  cleanSetEditShapeImpl3D_() {
    n2(0);
  }
  dbgNavigate_() {
  }
  dbgChkChainParents_() {
  }
  deleteEdgeImpl_(e5) {
    const t3 = this.getHalfEdgeNext(e5), s4 = this.getHalfEdgePrev(e5), n6 = this.getHalfEdgeTwin(e5), r = this.getHalfEdgeNext(n6), i2 = this.getHalfEdgePrev(n6);
    t3 !== n6 && (this.setHalfEdgeNext_(i2, t3), this.setHalfEdgePrev_(t3, i2)), s4 !== n6 && (this.setHalfEdgeNext_(s4, r), this.setHalfEdgePrev_(r, s4));
    const o = this.getHalfEdgeOrigin(e5);
    this.getClusterHalfEdge(o) === e5 && (r !== e5 ? this.setClusterHalfEdge_(o, r) : this.setClusterHalfEdge_(o, cr));
    const a2 = this.getHalfEdgeOrigin(n6);
    this.getClusterHalfEdge(a2) === n6 && (t3 !== n6 ? this.setClusterHalfEdge_(a2, t3) : this.setClusterHalfEdge_(a2, cr)), this.m_halfEdgeData.deleteElement(e5), this.m_halfEdgeData.deleteElement(n6);
  }
  getLeftSkipPolylines_(e5, t3) {
    let s4 = t3;
    for (; ; ) {
      if (s4 = e5.getPrev(s4), -1 === s4) return cr;
      {
        const t4 = e5.getElement(s4);
        if (this.getHalfEdgeChain(t4) !== this.getHalfEdgeChain(this.getHalfEdgeTwin(t4))) return t4;
      }
    }
  }
  checkStructureAfterDirtySweep_() {
    const e5 = H(this.m_checkDirtyPlanesweepTolerance), t3 = new mi(), s4 = new mi(), n6 = new mi(), r = new mi(), i2 = new mi();
    for (let o = this.getFirstCluster(); o !== cr; o = this.getNextCluster(o)) {
      const a2 = this.getClusterHalfEdge(o);
      if (a2 !== cr) {
        let o2 = a2;
        this.getHalfEdgeFromXY(o2, t3), this.getHalfEdgeToXY(o2, s4), n6.setSub(s4, t3);
        let h2 = n6.sqrLength();
        do {
          const a3 = o2;
          if (o2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(o2)), o2 !== a3) {
            this.getHalfEdgeToXY(o2, r), i2.setSub(r, t3);
            const a4 = i2.sqrLength(), m3 = i2.crossProduct(n6), l2 = m3 * m3 / (a4 * h2);
            if (Math.min(a4, h2) * l2 <= e5) {
              if (i2.dotProduct(n6) >= 0) return false;
            }
            n6.assign(i2), h2 = a4, s4.assign(r);
          }
        } while (o2 !== a2);
      }
    }
    return true;
  }
  extractPolygonPathFromChain_(e5, t3, s4, n6, r) {
    const i2 = this.m_shape.hasSegmentParentage(), o = this.getChainHalfEdge(s4);
    let a2 = o, h2 = cr;
    const m3 = new ee();
    do {
      const o2 = this.getHalfEdgeTwin(a2);
      if (this.getHalfEdgeChain(o2) !== s4) {
        let s5 = cr;
        const o3 = this.getHalfEdgeOrigin(a2);
        if (n6 === cr) {
          const e6 = this.getClusterVertexIterator(o3);
          s5 = this.getVertexFromVertexIterator(e6);
        } else for (let e6 = this.getClusterVertexIterator(o3); e6 !== cr; e6 = this.incrementVertexIterator(e6)) {
          const t4 = this.getVertexFromVertexIterator(e6);
          s5 === cr && (s5 = t4);
          const r2 = this.m_shape.getPathFromVertex(t4);
          if (this.m_shape.getGeometryFromPath(r2) === n6) {
            s5 = t4;
            break;
          }
        }
        let l2;
        if (h2 === cr && (h2 = e5.insertPath(t3, cr), e5.setClosedPath(h2, true)), this.m_shape === e5 ? l2 = e5.addVertex(h2, s5) : (this.m_shape.queryPoint(s5, m3), l2 = e5.addPoint(h2, m3)), this.isHalfEdgeCurve(a2) && (this.querySegmentXY(a2, r), e5.setSegmentToIndex(e5.getVertexIndex(l2), r.get().clone())), i2) {
          const t4 = this.getSegmentParentage(a2);
          e5.setSegmentParentageAndBreak(l2, t4, this.isBreakNode(o3));
        }
      }
      a2 = this.getHalfEdgeNext(a2);
    } while (a2 !== o);
  }
  mergeSegmentParentage_() {
    if (!this.m_shape.hasSegmentParentage()) return;
    n2(-1 !== this.m_clusterBreakNodeIndex), n2(-1 === this.m_segmentParentageIndex);
    for (let n6 = this.getFirstCluster(); n6 !== cr; n6 = this.getNextCluster(n6)) {
      let e6 = 0;
      const t4 = this.getClusterHalfEdge(n6);
      if (t4 !== cr) {
        let s5 = t4;
        do {
          e6++, s5 = this.getHalfEdgeNext(this.getHalfEdgeTwin(s5));
        } while (s5 !== t4 && e6 < 3);
      }
      2 !== e6 && this.setBreakNode(n6, true);
    }
    let e5 = [], t3 = [];
    this.m_segmentParentageIndex = this.createUserIndexForHalfEdges();
    const s4 = this.createUserIndexForHalfEdges();
    for (let n6 = this.getFirstCluster(); n6 !== cr; n6 = this.getNextCluster(n6)) {
      const r = this.getClusterHalfEdge(n6);
      if (r !== cr) {
        let n7 = false, i2 = r;
        do {
          let r2 = i2;
          for (; -1 === this.getHalfEdgeUserIndex(r2, s4); ) {
            const i3 = this.getHalfEdgeNext(r2), o = this.getHalfEdgeTwin(r2);
            $s3(this, r2, t3);
            const a2 = t3.at(-1).parentage;
            if (!n7) {
              const t4 = this.getHalfEdgeOrigin(r2);
              if (!this.isBreakNode(t4)) {
                const t5 = this.getHalfEdgePrev(r2);
                r2 !== t5 && ($s3(this, t5, e5), n7 = true);
              }
            }
            if (n7 && !Js3(t3, e5)) {
              const e6 = this.getHalfEdgeOrigin(r2);
              this.setBreakNode(e6, true);
            }
            e5 = Pt(t3, t3 = e5), n7 = true;
            const h2 = this.getHalfEdgeOrigin(i3);
            this.isBreakNode(h2) && (n7 = false), this.setHalfEdgeUserIndex(r2, this.m_segmentParentageIndex, a2), this.setHalfEdgeUserIndex(o, this.m_segmentParentageIndex, a2), this.setHalfEdgeUserIndex(r2, s4, 1), this.setHalfEdgeUserIndex(o, s4, 1), r2 = i3;
          }
          i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
        } while (i2 !== r);
      }
    }
    this.deleteUserIndexForHalfEdges(s4);
  }
  registerNewBitSet(e5) {
    if (null === this.m_uniqueBitSets && (this.m_uniqueBitSets = en2(), this.m_uniqueBitSets.add(this.getEmptySet())), null === e5) return this.getEmptySet();
    return this.m_uniqueBitSets.has(e5) ? this.m_uniqueBitSets.get(e5) : (this.m_uniqueBitSets.add(e5), e5);
  }
  getLeftEdgeBitSet_(e5) {
    const t3 = this.getHalfEdgeUserIndex(e5, this.m_edgeBitSetIndexLeft);
    return n2(t3 >= 0), n2(this.m_edgeBitSets.at(t3)), this.m_edgeBitSets.at(t3);
  }
  getEdgeBitSet_(e5) {
    const t3 = this.getHalfEdgeUserIndex(e5, this.m_edgeBitSetIndex);
    return n2(t3 >= 0), this.m_edgeBitSets.at(t3);
  }
  setEdgeBitSet_(e5, t3) {
    n2(this.m_bBuildGeometryParentageSets), t3 = this.registerNewBitSet(t3), -1 === this.m_edgeBitSetIndex && (this.m_edgeBitSetIndex = this.createUserIndexForHalfEdges());
    const s4 = this.getHalfEdgeUserIndex(e5, this.m_edgeBitSetIndex);
    -1 !== s4 ? this.m_edgeBitSets[s4] = t3 : (this.setHalfEdgeUserIndex(e5, this.m_edgeBitSetIndex, this.m_edgeBitSets.length), this.m_edgeBitSets.push(t3));
  }
  setLeftEdgeBitSet_(e5, t3) {
    n2(this.m_bBuildGeometryParentageSets), t3 = this.registerNewBitSet(t3), -1 === this.m_edgeBitSetIndexLeft && (this.m_edgeBitSetIndexLeft = this.createUserIndexForHalfEdges());
    const s4 = this.getHalfEdgeUserIndex(e5, this.m_edgeBitSetIndexLeft);
    -1 !== s4 ? this.m_edgeBitSets[s4] = t3 : (this.setHalfEdgeUserIndex(e5, this.m_edgeBitSetIndexLeft, this.m_edgeBitSets.length), this.m_edgeBitSets.push(t3));
  }
  setChainBitSet_(e5, t3) {
    n2(this.m_bBuildGeometryParentageSets), t3 = this.registerNewBitSet(t3), -1 === this.m_chainBitSetIndex && (this.m_chainBitSetIndex = this.createUserIndexForChains());
    const s4 = this.getChainUserIndex(e5, this.m_chainBitSetIndex);
    -1 !== s4 ? this.m_chainBitSets[s4] = t3 : (this.setChainUserIndex(e5, this.m_chainBitSetIndex, this.m_chainBitSets.length), this.m_chainBitSets.push(t3));
  }
  getEmptySet() {
    return this.m_emptyBitSet || (this.m_emptyBitSet = new Ls3()), this.m_emptyBitSet;
  }
  deleteEdgeBitSets_() {
    -1 !== this.m_edgeBitSetIndex && (this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndex), this.m_edgeBitSetIndex = -1), -1 !== this.m_edgeBitSetIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndexLeft), this.m_edgeBitSetIndexLeft = -1), this.m_edgeBitSets.length = 0, this.m_uniqueBitSets = null;
  }
  deleteChainBitSets_() {
    -1 !== this.m_chainBitSetIndex && (this.deleteUserIndexForChains(this.m_chainBitSetIndex), this.m_chainBitSetIndex = -1, this.m_chainBitSets.length = 0);
  }
  dbgPrintEdge_(e5) {
  }
  dbgVerifyEdgeSegment(e5) {
  }
};
tn2.c_EdgeParentageMask = ~(1 << 31), tn2.c_EdgeBitMask = 1 << 31;
var sn2 = class _sn {
  freeNode_(e5) {
    this.m_listNodes.deleteElement(e5);
  }
  newNode_() {
    return this.m_listNodes.newElement();
  }
  freeList_(e5) {
    this.m_lists.deleteElement(e5);
  }
  newList_() {
    return this.m_lists.newElement();
  }
  Init_(e5) {
    n2(0);
  }
  constructor(e5) {
    this.m_listNodes = new at(2), this.m_listOfLists = _sn.st_nullNode(), this.m_bAllowNavigationBetweenLists = true, void 0 === e5 && (e5 = true), this.m_bAllowNavigationBetweenLists = e5, this.m_lists = new at(this.m_bAllowNavigationBetweenLists ? 4 : 2);
  }
  createList() {
    const e5 = this.newList_();
    return this.m_bAllowNavigationBetweenLists && (this.m_lists.setField(e5, 3, this.m_listOfLists), this.m_listOfLists !== _sn.st_nullNode() && this.m_lists.setField(this.m_listOfLists, 2, e5), this.m_listOfLists = e5), e5;
  }
  deleteList(e5) {
    let t3 = this.getFirst(e5);
    for (; t3 !== _sn.st_nullNode(); ) {
      const e6 = t3;
      t3 = this.getNext(t3), this.freeNode_(e6);
    }
    if (this.m_bAllowNavigationBetweenLists) {
      const t4 = this.m_lists.getField(e5, 2), s4 = this.m_lists.getField(e5, 3);
      t4 !== _sn.st_nullNode() ? this.m_lists.setField(t4, 3, s4) : this.m_listOfLists = s4, s4 !== _sn.st_nullNode() && this.m_lists.setField(s4, 2, t4);
    }
    this.freeList_(e5);
  }
  reserveLists(e5) {
    this.m_lists.setCapacity(e5);
  }
  addElement(e5, t3) {
    this.m_lists.getField(e5, 0);
    const s4 = this.m_lists.getField(e5, 1), n6 = this.newNode_();
    return s4 !== _sn.st_nullNode() ? (this.m_listNodes.setField(s4, 1, n6), this.m_lists.setField(e5, 1, n6)) : (this.m_lists.setField(e5, 0, n6), this.m_lists.setField(e5, 1, n6)), this.m_listNodes.setField(n6, 0, t3), n6;
  }
  reserveNodes(e5) {
    this.m_listNodes.setCapacity(e5);
  }
  deleteElementDirect(e5, t3, s4) {
    t3 !== _sn.st_nullNode() ? (this.m_listNodes.setField(t3, 1, this.m_listNodes.getField(s4, 1)), this.m_lists.getField(e5, 1) === s4 && this.m_lists.setField(e5, 1, t3)) : (this.m_lists.setField(e5, 0, this.m_listNodes.getField(s4, 1)), this.m_lists.getField(e5, 1) === s4 && this.m_lists.setField(e5, 1, _sn.st_nullNode())), this.freeNode_(s4);
  }
  deleteElementSearch(e5, t3) {
    let s4 = -1, n6 = this.getFirst(e5);
    for (; n6 !== t3; ) s4 = n6, n6 = this.getNext(n6);
    this.deleteElementDirect(e5, s4, t3);
  }
  concatenateLists(e5, t3) {
    const s4 = this.m_lists.getField(e5, 1), n6 = this.m_lists.getField(t3, 0);
    if (n6 !== _sn.st_nullNode() && (s4 !== _sn.st_nullNode() ? (this.m_listNodes.setField(s4, 1, n6), this.m_lists.setField(e5, 1, this.m_lists.getField(t3, 1))) : (this.m_lists.setField(e5, 0, n6), this.m_lists.setField(e5, 1, this.m_lists.getField(t3, 1)))), this.m_bAllowNavigationBetweenLists) {
      const e6 = this.m_lists.getField(t3, 2), s5 = this.m_lists.getField(t3, 3);
      e6 !== _sn.st_nullNode() ? this.m_lists.setField(e6, 3, s5) : this.m_listOfLists = s5, s5 !== _sn.st_nullNode() && this.m_lists.setField(s5, 2, e6);
    }
    return this.freeList_(t3), e5;
  }
  getElement(e5) {
    return this.m_listNodes.getField(e5, 0);
  }
  getData(e5) {
    return this.getElement(e5);
  }
  setElement(e5, t3) {
    n2(0);
  }
  getNext(e5) {
    return this.m_listNodes.getField(e5, 1);
  }
  getFirst(e5) {
    return this.m_lists.getField(e5, 0);
  }
  getFirstElement(e5) {
    const t3 = this.getFirst(e5);
    return this.getElement(t3);
  }
  static st_nullNode() {
    return -1;
  }
  clear() {
    this.m_listNodes.deleteAll(true), this.m_lists.deleteAll(true), this.m_listOfLists = _sn.st_nullNode();
  }
  isEmpty(e5) {
    return n2(0), false;
  }
  getNodeCount() {
    return this.m_listNodes.size();
  }
  getListCount() {
    return this.m_lists.size();
  }
  getFirstList() {
    return this.m_listOfLists;
  }
  getNextList(e5) {
    return this.m_lists.getField(e5, 3);
  }
};
function nn2(e5 = -1) {
  return { m_value: e5, m_line: new pm(), m_segment: null, m_segmentInfo: new fr(-1), m_env: new x2(0, 0), m_dxdy: 55555555, m_bHorizontal: false, m_bCurve: false };
}
var rn2 = 67;
var on2 = class extends dt {
  constructor(e5, t3, s4) {
    super(true), this.m_bIntersectionDetected = false, this.m_nonSimpleResult = new e(), this.m_tempSimpleEdge1 = nn2(), this.m_tempSimpleEdge2 = nn2(), this.m_prev1 = cr, this.m_prev2 = cr, this.m_vertex1 = cr, this.m_vertex2 = cr, this.m_currentNode = -1, this.m_prevX1 = Number.NaN, this.m_prevX2 = Number.NaN, this.m_prevY = Number.NaN, this.m_prevX = 0, this.m_sweepY = Number.NaN, this.m_sweepX = 0, this.m_ptSweep = new mi(), this.m_simpleEdgesCache = [], this.m_simpleEdgesRecycle = [], this.m_cOutstandingConstructedEdges = 0, this.m_shape = e5, this.m_bShapeHasSegments = this.m_shape.hasCurves(), this.m_tolerance = t3, this.m_tolerance10 = 10 * t3, this.m_bIsSimple = s4;
    const n6 = Math.trunc(Math.min(3 * e5.getTotalPointCount() / 2, rn2)), r = Math.min(7, n6);
    this.m_simpleEdgesCache.length = r;
  }
  tryGetCachedEdge_(e5) {
    const t3 = this.m_simpleEdgesCache[(e5 & vs()) % this.m_simpleEdgesCache.length];
    return t3 && t3.m_value === e5 ? t3 : null;
  }
  tryDeleteCachedEdge_(e5) {
    const t3 = (e5 & vs()) % this.m_simpleEdgesCache.length, s4 = this.m_simpleEdgesCache[t3];
    s4 && s4.m_value === e5 && (this.m_simpleEdgesRecycle.push(s4), this.m_simpleEdgesCache[t3] = null);
  }
  tryCreateCachedEdge_(e5) {
    const t3 = (e5 & vs()) % this.m_simpleEdgesCache.length;
    let s4 = this.m_simpleEdgesCache[t3];
    return s4 ? null : (0 === this.m_simpleEdgesRecycle.length ? (s4 = nn2(), this.m_cOutstandingConstructedEdges++) : s4 = this.m_simpleEdgesRecycle.pop(), s4.m_value = e5, this.m_simpleEdgesCache[t3] = s4, s4);
  }
  initSimpleEdge_(e5, t3) {
    this.m_bShapeHasSegments && this.initSimpleEdgeHelper_(e5, t3) || e5.m_bCurve || (this.m_shape.queryLineConnector(t3, e5.m_line, true), e5.m_segment = e5.m_line, e5.m_env.setCoordsNoNAN(e5.m_line.getStartX(), e5.m_line.getEndX()), e5.m_env.vmax += this.m_tolerance, e5.m_line.orientBottomUp(), e5.m_bHorizontal = e5.m_line.getEndY() === e5.m_line.getStartY(), e5.m_bHorizontal || (e5.m_dxdy = (e5.m_line.getEndX() - e5.m_line.getStartX()) / (e5.m_line.getEndY() - e5.m_line.getStartY())));
  }
  initSimpleEdgeHelper_(e5, t3) {
    if (e5.m_segment = this.m_shape.getSegment(t3), e5.m_segmentInfo = this.m_shape.getOriginalSegmentInfo(t3), e5.m_bCurve = null !== e5.m_segment, e5.m_bCurve) {
      const t4 = e5.m_segment.clone();
      return t4.orientBottomUp(), e5.m_segment = t4, e5.m_env = e5.m_segment.queryInterval(0, 0), e5.m_env.vmax += this.m_tolerance, true;
    }
    return false;
  }
  compareTwoSegments_(e5, t3) {
    const s4 = e5.getStartXY(), n6 = e5.getEndXY(), r = t3.getStartXY(), i2 = t3.getEndXY();
    if (this.m_ptSweep.setCoords(this.m_sweepX, this.m_sweepY), s4.isEqualPoint2D(r) && this.m_sweepY === s4.y) {
      this.m_ptSweep.assign(n6.compare(i2) < 0 ? n6 : i2);
      const s5 = e5.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), r2 = t3.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x);
      if (Math.abs(s5 - r2) > this.m_tolerance) return s5 < r2 ? -1 : 1;
    }
    const o = s4.compare(r) < 0 ? r : s4, a2 = n6.compare(i2) < 0 ? n6 : i2;
    let h2 = 0, m3 = 0;
    for (let l2 = 1; l2 < 5; l2++) {
      Y(o, a2, l2 / 5, this.m_ptSweep);
      const s5 = e5.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), n7 = t3.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), r2 = Math.abs(s5 - n7);
      r2 > h2 && (h2 = r2, m3 = s5 < n7 ? -1 : 1);
    }
    return 0 === m3 ? this.errorCracking() : m3;
  }
  compareNonHorizontal_(e5, t3) {
    if (e5.m_line.getStartY() === t3.m_line.getStartY() && e5.m_line.getStartX() === t3.m_line.getStartX()) return e5.m_line.getEndY() === t3.m_line.getEndY() && e5.m_line.getEndX() === t3.m_line.getEndX() ? this.m_bIsSimple ? this.errorCoincident() : 0 : this.compareNonHorizontalUpperEnd_(e5, t3);
    if (e5.m_line.getEndY() === t3.m_line.getEndY() && e5.m_line.getEndX() === t3.m_line.getEndX()) return this.compareNonHorizontalLowerEnd_(e5, t3);
    const s4 = this.compareNonHorizontalLowerEnd_(e5, t3), n6 = this.compareNonHorizontalUpperEnd_(e5, t3);
    return s4 < 0 && n6 < 0 ? -1 : s4 > 0 && n6 > 0 ? 1 : this.errorCracking();
  }
  compareHorizontal1Case1_(e5, t3) {
    if (e5.getEndX() > t3.getEndX()) {
      if (t3.getEndX() > t3.getStartX() && t3.getEndY() - t3.getStartY() < 2 * this.m_tolerance && e5.isIntersectingPoint(t3.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    } else {
      if ((t3.getEndY() - t3.getStartY()) / (t3.getEndX() - t3.getStartX()) * (e5.getEndX() - e5.getStartX()) < this.m_tolerance10 && t3.isIntersectingPoint(e5.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    }
    return 1;
  }
  compareHorizontal1Case2_(e5, t3) {
    if (e5.getStartX() < t3.getStartX()) {
      if (t3.getEndX() > t3.getStartX() && t3.getEndY() - t3.getStartY() < 2 * this.m_tolerance && e5.isIntersectingPoint(t3.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    } else {
      if ((t3.getEndY() - t3.getStartY()) / (t3.getEndX() - t3.getStartX()) * (e5.getStartX() - e5.getEndX()) < this.m_tolerance10 && t3.isIntersectingPoint(e5.getStartXY(), this.m_tolerance, true)) return this.errorCracking();
    }
    return -1;
  }
  compareHorizontal1Case3_(e5, t3) {
    const s4 = mi.getNAN();
    s4.setSub(t3.getEndXY(), t3.getStartXY()), s4.rightPerpendicularThis(), s4.normalize();
    const n6 = mi.getNAN();
    n6.setSub(e5.getStartXY(), t3.getStartXY());
    const r = mi.getNAN();
    r.setSub(e5.getEndXY(), t3.getStartXY());
    const i2 = n6.dotProduct(s4), o = r.dotProduct(s4), a2 = Math.abs(i2), h2 = Math.abs(o);
    if (a2 < h2) {
      if (a2 < this.m_tolerance10 && t3.isIntersectingPoint(e5.getStartXY(), this.m_tolerance, true)) return this.errorCracking();
    } else if (h2 < this.m_tolerance10 && t3.isIntersectingPoint(e5.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    return i2 < 0 && o < 0 ? -1 : i2 > 0 && o > 0 ? 1 : this.errorCracking();
  }
  compareHorizontal1_(e5, t3) {
    return e5.getStartY() === t3.getStartY() && e5.getStartX() === t3.getStartX() ? this.compareHorizontal1Case1_(e5, t3) : e5.getEndY() === t3.getEndY() && e5.getEndX() === t3.getEndX() ? this.compareHorizontal1Case2_(e5, t3) : this.compareHorizontal1Case3_(e5, t3);
  }
  compareHorizontal2_(e5, t3) {
    return e5.getEndY() === t3.getEndY() && e5.getEndX() === t3.getEndX() && e5.getStartY() === t3.getStartY() && e5.getStartX() === t3.getStartX() ? this.m_bIsSimple ? this.errorCoincident() : 0 : this.errorCracking();
  }
  compareNonHorizontalLowerEnd_(e5, t3) {
    let s4 = 1;
    if (e5.m_line.getStartY() < t3.m_line.getStartY()) {
      s4 = -1;
      const n7 = e5;
      e5 = t3, t3 = n7;
    }
    const n6 = e5.m_line, r = t3.m_line, i2 = n6.getStartX() - r.getStartX(), o = t3.m_dxdy * (n6.getStartY() - r.getStartY()), a2 = this.m_tolerance10;
    return i2 < o - a2 ? -s4 : i2 > o + a2 ? s4 : r.isIntersectingPoint(n6.getStartXY(), this.m_tolerance, true) ? this.errorCracking() : i2 < o ? -s4 : s4;
  }
  compareNonHorizontalUpperEnd_(e5, t3) {
    let s4 = 1;
    if (t3.m_line.getEndY() < e5.m_line.getEndY()) {
      s4 = -1;
      const n7 = e5;
      e5 = t3, t3 = n7;
    }
    const n6 = e5.m_line, r = t3.m_line, i2 = n6.getEndX() - r.getStartX(), o = t3.m_dxdy * (n6.getEndY() - r.getStartY()), a2 = this.m_tolerance10;
    return i2 < o - a2 ? -s4 : i2 > o + a2 ? s4 : r.isIntersectingPoint(n6.getEndXY(), this.m_tolerance, true) ? this.errorCracking() : i2 < o ? -s4 : s4;
  }
  errorCoincident() {
    this.m_bIntersectionDetected = true;
    const e5 = 7;
    return this.m_nonSimpleResult = new e(e5, this.m_vertex1, this.m_vertex2), -1;
  }
  errorCracking() {
    if (this.m_bIntersectionDetected = true, this.m_bIsSimple) {
      const e5 = 6;
      this.m_nonSimpleResult = new e(e5, this.m_vertex1, this.m_vertex2);
    } else this.m_prev1 = cr, this.m_prev2 = cr, this.m_vertex1 = cr, this.m_vertex2 = cr;
    return -1;
  }
  compareSegments_(e5, t3, s4, n6) {
    if (s4.m_env.vmax < n6.m_env.vmin) return -1;
    if (n6.m_env.vmax < s4.m_env.vmin) return 1;
    if (!s4.m_bCurve && !n6.m_bCurve) {
      let e6 = s4.m_bHorizontal ? 1 : 0;
      return e6 |= n6.m_bHorizontal ? 2 : 0, 0 === e6 ? this.compareNonHorizontal_(s4, n6) : 1 === e6 ? this.compareHorizontal1_(s4.m_line, n6.m_line) : 2 === e6 ? -1 * this.compareHorizontal1_(n6.m_line, s4.m_line) : this.compareHorizontal2_(s4.m_line, n6.m_line);
    }
    if (this.m_bIntersectionDetected) return -1;
    const r = this.m_prevY === this.m_sweepY && this.m_prevX === this.m_sweepX;
    let i2, o;
    if (r && e5 === this.m_prev1 ? i2 = this.m_prevX1 : (i2 = Number.NaN, this.m_prev1 = cr), r && t3 === this.m_prev2 ? o = this.m_prevX2 : (o = Number.NaN, this.m_prev2 = cr), this.m_prevY = this.m_sweepY, this.m_prevX = this.m_sweepX, Number.isNaN(i2)) {
      this.m_prev1 = e5;
      const t4 = s4.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY, this.m_sweepX);
      i2 = t4, this.m_prevX1 = t4;
    }
    if (Number.isNaN(o)) {
      this.m_prev2 = t3;
      const e6 = n6.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY, this.m_sweepX);
      o = e6, this.m_prevX2 = e6;
    }
    const a2 = om(true, true, s4.m_segment, n6.m_segment, this.m_tolerance, true);
    return 0 !== a2 ? 2 === a2 ? this.m_bIsSimple ? this.errorCoincident() : s4.m_segmentInfo.equals(n6.m_segmentInfo) ? 0 : this.errorCracking() : this.errorCracking() : Math.abs(i2 - o) <= this.m_tolerance ? this.compareTwoSegments_(s4.m_segment, n6.m_segment) : i2 < o ? -1 : i2 > o ? 1 : 0;
  }
  clearIntersectionDetectedFlag() {
    this.m_bIntersectionDetected = false;
  }
  intersectionDetected() {
    return this.m_bIntersectionDetected;
  }
  getLastComparedNode() {
    return this.m_currentNode;
  }
  getResult() {
    return this.m_nonSimpleResult;
  }
  setSweepY(e5, t3) {
    this.m_sweepY = e5, this.m_sweepX = t3, this.m_prev1 = cr, this.m_prev2 = cr, this.m_vertex1 = cr, this.m_vertex2 = cr;
  }
  compare(e5, t3, s4) {
    if (this.m_bIntersectionDetected) return -1;
    const n6 = e5.getElement(s4), r = t3;
    return this.m_currentNode = s4, this.compareSegments(r, r, n6, n6);
  }
  compareSegments(e5, t3, s4, n6) {
    let r = this.tryGetCachedEdge_(e5);
    null === r ? this.m_vertex1 === t3 ? r = this.m_tempSimpleEdge1 : (this.m_vertex1 = t3, r = this.tryCreateCachedEdge_(e5), null === r && (r = this.m_tempSimpleEdge1, this.m_tempSimpleEdge1.m_value = e5), this.initSimpleEdge_(r, t3)) : this.m_vertex1 = t3;
    let i2 = this.tryGetCachedEdge_(s4);
    return null === i2 ? this.m_vertex2 === n6 ? i2 = this.m_tempSimpleEdge2 : (this.m_vertex2 = n6, i2 = this.tryCreateCachedEdge_(s4), null === i2 && (i2 = this.m_tempSimpleEdge2, this.m_tempSimpleEdge2.m_value = s4), this.initSimpleEdge_(i2, n6)) : this.m_vertex2 = n6, this.compareSegments_(t3, n6, r, i2);
  }
  onDelete(e5) {
    this.tryDeleteCachedEdge_(e5);
  }
  onSet(e5) {
    this.tryDeleteCachedEdge_(e5);
  }
  onEndSearch(e5) {
    this.tryDeleteCachedEdge_(e5);
  }
  onAddUniqueElementFailed(e5) {
    this.tryDeleteCachedEdge_(e5);
  }
};
var an2 = class {
  constructor(e5, t3) {
    this.m_bIntersectionDetected = false, this.m_pointOfInterest = mi.getNAN(), this.m_line1 = new pm(), this.m_seg1 = null, this.m_env = x2.constructEmpty(), this.m_vertex1 = -1, this.m_currentNode = -1, this.m_minDist = Number.MAX_VALUE, this.m_shape = e5, this.m_tolerance = t3;
  }
  getCurrentNode() {
    return this.m_currentNode;
  }
  clearIntersectionDetectedFlag() {
    this.m_bIntersectionDetected = false, this.m_minDist = Number.MAX_VALUE;
  }
  intersectionDetected() {
    return this.m_bIntersectionDetected;
  }
  setPoint(e5) {
    this.m_pointOfInterest.assign(e5);
  }
  compare(e5, t3) {
    const s4 = e5.getElement(t3);
    return this.compareVertex(e5, t3, s4);
  }
  compareVertex(t3, s4, n6) {
    let r, i2 = this.m_shape.getSegment(n6), o = true;
    if (null == i2) this.m_shape.queryLineConnector(n6, this.m_line1, true), this.m_env.setCoordsNoNAN(this.m_line1.getStartX(), this.m_line1.getEndX()), i2 = this.m_line1, r = this.m_line1.getStartY() === this.m_line1.getEndY();
    else {
      const t4 = n4.constructEmpty();
      i2.queryLooseEnvelope(t4), t4.queryIntervalX(this.m_env), r = 0 === t4.height(), o = false;
    }
    if (this.m_pointOfInterest.x + this.m_tolerance < this.m_env.vmin) return -1;
    if (this.m_pointOfInterest.x - this.m_tolerance > this.m_env.vmax) return 1;
    if (r) return this.m_currentNode = s4, this.m_bIntersectionDetected = true, 0;
    let a2 = 0;
    if (o) {
      Ss2(this.m_line1);
      const e5 = this.m_line1.getStartXY(), t4 = new mi();
      t4.setSub(this.m_line1.getEndXY(), e5), t4.rightPerpendicularThis();
      const s5 = new mi();
      s5.setSub(this.m_pointOfInterest, e5), a2 = t4.dotProduct(s5), a2 /= t4.length();
    } else {
      a2 = i2.intersectionOfYMonotonicWithAxisX(this.m_pointOfInterest.y, this.m_pointOfInterest.x) - this.m_pointOfInterest.x;
    }
    if (a2 < 10 * -this.m_tolerance) return -1;
    if (a2 > 10 * this.m_tolerance) return 1;
    if (i2.isIntersectingPoint(this.m_pointOfInterest, this.m_tolerance)) {
      Math.abs(a2) < this.m_minDist && (this.m_currentNode = s4, this.m_minDist = a2), this.m_bIntersectionDetected = true;
    }
    return a2 < 0 ? -1 : a2 > 0 ? 1 : 0;
  }
};
var hn2 = class _hn {
  constructor(e5, t3) {
    this.m_lists = new sn2(false), this.m_hash = t3, this.m_hashBuckets = new Int32Array(e5), this.m_hashBuckets.fill(_hn.st_nullNode()), this.m_bitFilter = new Int32Array(10 * e5 + 31 >> 5);
  }
  reserveElements(e5) {
    this.m_lists.reserveLists(Math.min(this.m_hashBuckets.length, e5)), this.m_lists.reserveNodes(e5);
  }
  addElement(e5, t3) {
    void 0 === t3 && (t3 = this.m_hash.getHash(e5));
    const s4 = t3 % (this.m_bitFilter.length << 5);
    this.m_bitFilter[s4 >> 5] |= 1 << (31 & s4);
    const n6 = t3 % this.m_hashBuckets.length;
    let r = this.m_hashBuckets[n6];
    r === sn2.st_nullNode() && (r = this.m_lists.createList(), this.m_hashBuckets[n6] = r);
    return this.m_lists.addElement(r, e5);
  }
  deleteElement(e5, s4) {
    void 0 === s4 && (s4 = this.m_hash.getHash(e5));
    const n6 = s4 % this.m_hashBuckets.length, r = this.m_hashBuckets[n6];
    r === sn2.st_nullNode() && P("");
    let i2 = this.m_lists.getFirst(r), o = sn2.st_nullNode();
    for (; i2 !== sn2.st_nullNode(); ) {
      const t3 = this.m_lists.getData(i2), s5 = this.m_lists.getNext(i2);
      t3 === e5 ? (this.m_lists.deleteElementDirect(r, o, i2), this.m_lists.getFirst(r) === sn2.st_nullNode() && (this.m_lists.deleteList(r), this.m_hashBuckets[n6] = sn2.st_nullNode())) : o = i2, i2 = s5;
    }
  }
  getFirstInBucket(e5) {
    const t3 = e5 % (this.m_bitFilter.length << 5);
    if (!(this.m_bitFilter[t3 >> 5] & 1 << (31 & t3))) return sn2.st_nullNode();
    const s4 = e5 % this.m_hashBuckets.length, n6 = this.m_hashBuckets[s4];
    return n6 === sn2.st_nullNode() ? sn2.st_nullNode() : this.m_lists.getFirst(n6);
  }
  getNextInBucket(e5) {
    return this.m_lists.getNext(e5);
  }
  findNode(e5) {
    const t3 = this.m_hash.getHash(e5);
    let s4 = this.getFirstInBucket(t3);
    for (; s4 !== sn2.st_nullNode(); ) {
      const t4 = this.m_lists.getData(s4);
      if (this.m_hash.equal(t4, e5)) return s4;
      s4 = this.m_lists.getNext(s4);
    }
    return sn2.st_nullNode();
  }
  deleteNode(e5) {
    const s4 = this.getElement(e5), n6 = this.m_hash.getHash(s4) % this.m_hashBuckets.length, r = this.m_hashBuckets[n6];
    r === sn2.st_nullNode() && P(""), this.m_lists.deleteElementSearch(r, e5), this.m_lists.getFirst(r) === sn2.st_nullNode() && (this.m_lists.deleteList(r), this.m_hashBuckets[n6] = sn2.st_nullNode());
  }
  getElement(e5) {
    return this.m_lists.getData(e5);
  }
  static st_nullNode() {
    return sn2.st_nullNode();
  }
  clear() {
    n2(0);
  }
  size() {
    return this.m_lists.getNodeCount();
  }
  dbgPrintBucketHistogram() {
  }
};
function mn2(e5, t3, s4, n6, r) {
  const i2 = new fn2(r);
  return i2.m_shape = e5, i2.m_sqrTolerance = t3 * t3, i2.m_cellSize = 2 * t3, i2.m_invCellSize = 1 / i2.m_cellSize, i2.m_geometry = s4, i2.m_bTrackChanges = n6, i2.m_bHasSegmentParentage = e5.hasSegmentParentage(), i2.clusterNonReciprocal();
}
function ln2(e5, t3, s4, n6, r) {
  const i2 = e5 - s4, o = t3 - n6;
  return i2 * i2 + o * o <= r;
}
function gn2() {
  return { pt: new mi(), weight: 0, rank: 0, bMerged: false };
}
function un2(e5, t3, s4, n6, r, i2) {
  const o = gn2(), a2 = s4 + r;
  let h2 = false, m3 = e5.x;
  e5.x !== t3.x && (n6 === i2 && (m3 = (e5.x * s4 + t3.x * r) / a2), h2 = true);
  let l2 = e5.y;
  return e5.y !== t3.y && (n6 === i2 && (l2 = (e5.y * s4 + t3.y * r) / a2), h2 = true), n6 !== i2 ? n6 > i2 ? (o.rank = n6, o.weight = s4, o.pt = e5) : (o.rank = i2, o.weight = r, o.pt = t3) : (o.pt.setCoords(m3, l2), o.weight = a2, o.rank = n6), o.bMerged = h2, o;
}
function cn2(e5, t3, s4, n6, r, i2, o, a2, h2) {
  const m3 = e5.equals(t3);
  if (n6 > i2) return o.assignCopy(e5), h2[0] = n6, a2[0] = s4, m3;
  if (i2 > n6) return o = t3, h2[0] = i2, a2[0] = r, m3;
  o.assignCopy(e5);
  const l2 = un2(e5.getXY(), t3.getXY(), s4, n6, r, i2);
  return o.setXY(l2.pt), a2[0] = l2.weight, h2[0] = l2.rank, m3;
}
function _n2(e5, t3, s4, n6, r) {
  const i2 = new fn2(r);
  return i2.m_shape = e5, i2.m_sqrTolerance = t3 * t3, i2.m_cellSize = 2 * t3, i2.m_invCellSize = 1 / i2.m_cellSize, i2.m_geometry = s4, i2.m_bTrackChanges = false, i2.needsClustering();
}
function dn2(e5, t3) {
  const s4 = qs(e5);
  return zs(s4, t3);
}
var pn2 = class {
  constructor(e5, t3, s4, n6, r) {
    this.m_workPt = new mi(), this.m_shape = e5, this.m_sqrTolerance = s4, this.m_invCellSize = n6, this.m_origin = t3.clone(), this.m_hashValues = r;
  }
  getHash(e5) {
    return this.m_shape.getUserIndex(e5, this.m_hashValues);
  }
  calculateHashFromVertex(e5) {
    this.m_shape.queryXY(e5, this.m_workPt);
    const t3 = this.m_workPt.x - this.m_origin.x, s4 = Math.trunc(t3 * this.m_invCellSize + 0.5), n6 = this.m_workPt.y - this.m_origin.y;
    return dn2(s4, Math.trunc(n6 * this.m_invCellSize + 0.5));
  }
  equal(e5, t3) {
    return n2(0), false;
  }
};
var fn2 = class {
  constructor(e5) {
    this.m_origin = mi.getNAN(), this.m_sqrTolerance = 0, this.m_cellSize = 0, this.m_invCellSize = 0, this.m_geometry = cr, this.m_bucketArray = Yt(4, Number.NaN), this.m_bucketHash = Yt(4, Number.NaN), this.m_dbgCandidateCheckCount = 0, this.m_nsr = new e(), this.m_hashValues = -1, this.m_newClusters = -1, this.m_bTrackChanges = false, this.m_bHasSegmentParentage = false, this.m_shape = null, this.m_clusters = new sn2(), this.m_hashFunction = null, this.m_hashTable = null, this.m_progressCounter = 0, this.m_progressTracker = e5;
  }
  progress_() {
  }
  collectClusterCandidates(e5, t3) {
    const s4 = mi.getNAN();
    this.m_shape.queryXY(e5, s4);
    const n6 = (s4.x - this.m_origin.x) * this.m_invCellSize, r = (s4.y - this.m_origin.y) * this.m_invCellSize, i2 = Math.trunc(n6), o = Math.trunc(r);
    let a2 = 0;
    for (let h2 = 0; h2 <= 1; h2 += 1) for (let e6 = 0; e6 <= 1; e6 += 1) {
      const t4 = dn2(i2 + h2, o + e6), s5 = this.m_hashTable.getFirstInBucket(t4);
      s5 !== hn2.st_nullNode() && (this.m_bucketArray[a2] = s5, this.m_bucketHash[a2] = t4, a2++);
    }
    for (let h2 = a2 - 1; h2 >= 1; h2--) {
      const e6 = this.m_bucketArray[h2];
      for (let t4 = h2 - 1; t4 >= 0; t4--) if (e6 === this.m_bucketArray[t4]) {
        this.m_bucketHash[t4] = -1, a2--, h2 !== a2 && (this.m_bucketHash[h2] = this.m_bucketHash[a2], this.m_bucketArray[h2] = this.m_bucketArray[a2]);
        break;
      }
    }
    for (let h2 = 0; h2 < a2; h2++) this.collectNearestNeighbourCandidates(e5, this.m_bucketHash[h2], s4, this.m_bucketArray[h2], t3);
  }
  collectNearestNeighbourCandidates(e5, t3, s4, n6, r) {
    const i2 = mi.getNAN();
    for (let o = n6; o !== hn2.st_nullNode(); o = this.m_hashTable.getNextInBucket(o)) {
      const n7 = this.m_hashTable.getElement(o);
      e5 === n7 || -1 !== t3 && this.m_shape.getUserIndex(n7, this.m_hashValues) !== t3 || (this.m_shape.queryXY(n7, i2), ln2(s4.x, s4.y, i2.x, i2.y, this.m_sqrTolerance) && r.push(o));
    }
  }
  mergeClusters(e5, t3, s4) {
    let n6 = this.m_shape.getUserIndex(e5, this.m_newClusters);
    const r = this.m_shape.getUserIndex(t3, this.m_newClusters);
    -1 === n6 && (n6 = this.m_clusters.createList(), this.m_clusters.addElement(n6, e5), this.m_shape.setUserIndex(e5, this.m_newClusters, n6)), -1 === r ? this.m_clusters.addElement(n6, t3) : this.m_clusters.concatenateLists(n6, r), this.m_shape.setUserIndex(t3, this.m_newClusters, at.impossibleIndex2());
    const i2 = this.mergeVertices(e5, t3);
    if (s4) {
      const t4 = this.m_hashFunction.calculateHashFromVertex(e5);
      this.m_shape.setUserIndex(e5, this.m_hashValues, t4);
    }
    return i2;
  }
  mergeVertices(e5, t3) {
    const s4 = mi.getNAN();
    this.m_shape.queryXY(e5, s4);
    const n6 = mi.getNAN();
    this.m_shape.queryXY(t3, n6);
    const r = this.m_shape.getRank(e5), i2 = this.m_shape.getRank(t3), o = this.m_shape.getWeight(e5), a2 = this.m_shape.getWeight(t3);
    let h2, m3, l2, g2, u = false;
    if (r === i2 ? (h2 = r, m3 = o + a2, l2 = s4.x, s4.x !== n6.x && (l2 = (s4.x * o + n6.x * a2) / m3, u = true), g2 = s4.y, s4.y !== n6.y && (g2 = (s4.y * o + n6.y * a2) / m3, u = true)) : (r > i2 ? (l2 = s4.x, g2 = s4.y, m3 = o, h2 = r) : (l2 = n6.x, g2 = n6.y, m3 = a2, h2 = i2), u = !s4.equals(n6)), u && (this.m_shape.setXYMonotonic(e5, l2, g2), this.m_bTrackChanges && this.m_shape.setGeometryModifiedWithVertex(e5, true), this.m_bHasSegmentParentage)) {
      const s5 = this.m_shape.getSegmentParentageBreakVertex(e5) || this.m_shape.getSegmentParentageBreakVertex(t3);
      this.m_shape.setSegmentParentageBreakVertex(e5, s5), this.m_shape.setSegmentParentageBreakVertex(t3, s5);
    }
    return this.m_shape.setWeight(e5, m3), this.m_shape.setRank(e5, h2), u;
  }
  needsClustering() {
    const e5 = { stack: [], error: void 0, hasError: false };
    try {
      n(e5, kt(() => {
        this.m_hashTable = null, this.m_hashFunction = null, this.m_shape.removeUserIndex(this.m_hashValues), this.m_shape.removeUserIndex(this.m_newClusters);
      }), false);
      const t3 = this.m_shape.getSelectedCount(), s4 = this.m_shape.getEnvelope2D(this.m_progressTracker);
      this.m_origin.assign(s4.getLowerLeft());
      const n6 = Math.max(s4.height(), s4.width()) / (ds() - 1);
      this.m_cellSize < n6 && (this.m_cellSize = n6, this.m_invCellSize = 1 / this.m_cellSize), this.m_clusters.clear(), this.m_clusters.reserveLists(this.m_shape.getSelectedCount() / 3 + 1), this.m_clusters.reserveNodes(this.m_shape.getSelectedCount() / 3 + 1), this.m_hashValues = this.m_shape.createUserIndex(), this.m_newClusters = this.m_shape.createUserIndex(), this.m_hashFunction = new pn2(this.m_shape, this.m_origin, this.m_sqrTolerance, this.m_invCellSize, this.m_hashValues), this.m_hashTable = new hn2(4 * t3 / 3, this.m_hashFunction), this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());
      let r = false;
      for (let e6 = 0; e6 < 2; e6++) {
        const t4 = [], s5 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
        for (let n7 = s5.next(); n7 !== cr; n7 = s5.next()) {
          if (this.progress_(), e6 > 0 && this.m_shape.getUserIndex(n7, this.m_newClusters) === at.impossibleIndex2()) continue;
          let s6;
          if (0 === e6 ? (s6 = this.m_hashFunction.calculateHashFromVertex(n7), this.m_shape.setUserIndex(n7, this.m_hashValues, s6)) : s6 = this.m_shape.getUserIndex(n7, this.m_hashValues), this.collectClusterCandidates(n7, t4), 0 !== t4.length) {
            for (let e7 = 0, s7 = t4.length; e7 < s7; e7++) {
              this.progress_();
              const s8 = t4[e7], i2 = this.m_hashTable.getElement(s8);
              if (this.m_hashTable.deleteNode(s8), !this.m_shape.isEqualXY(n7, i2)) return this.m_nsr = new e(5, this.m_shape.getVertexIndex(n7), this.m_shape.getVertexIndex(i2)), r = true, r;
              this.mergeClusters(n7, i2, false);
            }
            t4.length = 0;
          }
          0 === e6 && this.m_hashTable.addElement(n7, s6);
        }
      }
      return r;
    } catch (t3) {
      e5.error = t3, e5.hasError = true;
    } finally {
      s(e5);
    }
  }
  clusterNonReciprocal() {
    const e5 = this.m_shape.getSelectedCount(), t3 = this.m_shape.getEnvelope2D(this.m_progressTracker);
    this.m_origin = t3.getLowerLeft();
    const s4 = Math.max(t3.height(), t3.width()) / (ds() - 1);
    this.m_cellSize < s4 && (this.m_cellSize = s4, this.m_invCellSize = 1 / this.m_cellSize), this.m_clusters.clear(), this.m_clusters.reserveLists(Math.trunc(this.m_shape.getSelectedCount() / 3 + 1)), this.m_clusters.reserveNodes(Math.trunc(this.m_shape.getSelectedCount() / 3 + 1)), this.m_hashValues = this.m_shape.createUserIndex(), this.m_newClusters = this.m_shape.createUserIndex(), this.m_hashFunction = new pn2(this.m_shape, this.m_origin, this.m_sqrTolerance, this.m_invCellSize, this.m_hashValues), this.m_hashTable = new hn2(Math.trunc(4 * e5 / 3), this.m_hashFunction), this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());
    let n6 = false;
    {
      const e6 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
      for (let t4 = e6.next(); t4 !== cr; t4 = e6.next()) {
        this.progress_();
        const e7 = this.m_hashFunction.calculateHashFromVertex(t4);
        this.m_shape.setUserIndex(t4, this.m_hashValues, e7), this.m_hashTable.addElement(t4, e7);
      }
    }
    {
      const e6 = [], t4 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
      for (let s5 = t4.next(); s5 !== cr; s5 = t4.next()) {
        if (this.m_shape.getUserIndex(s5, this.m_newClusters) === at.impossibleIndex2()) continue;
        let t5 = this.m_shape.getUserIndex(s5, this.m_hashValues);
        this.m_hashTable.deleteElement(s5, t5);
        let r = false;
        for (; this.collectClusterCandidates(s5, e6), 0 !== e6.length; ) {
          let t6 = 0;
          for (let n7 = 0, r2 = e6.length; n7 < r2; n7++) {
            this.progress_();
            const i2 = e6[n7], o = this.m_hashTable.getElement(i2);
            this.m_hashTable.deleteNode(i2);
            const a2 = n7 + 1 === r2;
            t6 |= this.mergeClusters(s5, o, a2) ? 1 : 0;
          }
          if (r ||= 0 !== t6, n6 ||= 0 !== t6, e6.length = 0, !t6) break;
        }
        r && (t5 = this.m_shape.getUserIndex(s5, this.m_hashValues)), this.m_hashTable.addElement(s5, t5);
      }
      e6.length = 0;
    }
    return n6 && this.applyClusterPositions_(), this.m_hashTable = null, this.m_hashFunction = null, this.m_shape.removeUserIndex(this.m_hashValues), this.m_shape.removeUserIndex(this.m_newClusters), n6;
  }
  applyClusterPositions_() {
    const e5 = mi.getNAN();
    for (let t3 = this.m_clusters.getFirstList(); t3 !== sn2.st_nullNode(); t3 = this.m_clusters.getNextList(t3)) {
      let s4 = this.m_clusters.getFirst(t3);
      const n6 = this.m_clusters.getElement(s4);
      this.m_shape.queryXY(n6, e5);
      const r = this.m_shape.getRank(n6), i2 = this.m_shape.getWeight(n6);
      for (s4 = this.m_clusters.getNext(s4); s4 !== sn2.st_nullNode(); s4 = this.m_clusters.getNext(s4)) {
        const t4 = this.m_clusters.getElement(s4);
        if (this.m_bTrackChanges ? this.m_shape.isEqualXYPoint2D(t4, e5) || (this.m_shape.setXYMonotonicPoint2D(t4, e5), this.m_shape.setGeometryModifiedWithVertex(t4, true)) : this.m_shape.setXYMonotonicPoint2D(t4, e5), this.m_bHasSegmentParentage) {
          const e6 = this.m_shape.getSegmentParentageBreakVertex(n6) || this.m_shape.getSegmentParentageBreakVertex(t4);
          this.m_shape.setSegmentParentageBreakVertex(n6, e6), this.m_shape.setSegmentParentageBreakVertex(t4, e6);
        }
        this.m_shape.setWeight(t4, i2), this.m_shape.setRank(t4, r);
      }
    }
  }
};
var xn2 = class _xn {
  constructor() {
    this.m_inputParts = [], this.m_resultParts1 = [], this.m_resultParts2 = [], this.m_resultSegments = [], this.m_freeSegments = [], this.m_inputSegments = [], this.m_param1 = [], this.m_param2 = [], this.m_tolerance = 0, this.m_toleranceZ = 0, this.m_point = new ee(), this.m_pointWeight = 1, this.m_maxDensifyLimit = 0, this.m_pointRank = 0, this.m_changed1 = false, this.m_changed2 = false, this.m_adaptiveDensify = false;
  }
  clear() {
    this.freeAllResultSegments(), this.m_inputSegments.length = 0, this.m_inputParts.length = 0, this.m_resultParts1.length = 0, this.m_resultParts2.length = 0, this.m_param1.length = 0, this.m_param2.length = 0, this.m_adaptiveDensify = false, this.m_changed1 = false, this.m_changed2 = false;
  }
  newIntersectionPart_(e5, t3, s4, n6, r, i2, o, a2, h2, m3) {
    return Pn2(e5, t3, s4, n6, r, i2, o, a2, h2, m3);
  }
  pushSegment(e5, t3, s4, n6, r, i2, o, a2, h2, m3) {
    return this.m_inputParts.push(this.newIntersectionPart_(this.m_inputSegments.length, t3, s4, n6, r, i2, o, a2, h2, m3)), this.m_inputSegments.push(e5), this.m_inputParts.length - 1;
  }
  getResultSegmentCount(e5) {
    return this.m_adaptiveDensify ? 0 === e5 ? this.m_param1.length - 1 : this.m_param2.length - 1 : 0 === e5 ? this.m_resultParts1.length : this.m_resultParts2.length;
  }
  getResultPart_(e5, t3) {
    return 0 === e5 ? this.m_resultParts1[t3] : this.m_resultParts2[t3];
  }
  getResultSegment(e5, t3) {
    return this.m_resultSegments[this.getResultPart_(e5, t3).segmentIndex].get();
  }
  getSegmentChanged(e5) {
    return 0 === e5 ? this.m_changed1 : this.m_changed2;
  }
  getResultSegmentStartPointWeight(e5, t3) {
    return this.getResultPart_(e5, t3).weightStart;
  }
  getResultSegmentStartPointRank(e5, t3) {
    return this.getResultPart_(e5, t3).rankStart;
  }
  getResultSegmentSegmentParentage(e5, t3) {
    return this.getResultPart_(e5, t3).segmentParentage;
  }
  getResultSegmentStartPointIsBreak(e5, t3) {
    return this.getResultPart_(e5, t3).u.bBreakStart;
  }
  getResultSegmentEndPointWeight(e5, t3) {
    return this.getResultPart_(e5, t3).weightEnd;
  }
  getResultSegmentEndPointRank(e5, t3) {
    return this.getResultPart_(e5, t3).rankEnd;
  }
  getResultSegmentEndPointIsBreak(e5, t3) {
    return this.getResultPart_(e5, t3).u.bBreakEnd;
  }
  getResultSegmentInteriorRank(e5, t3) {
    return this.getResultPart_(e5, t3).rankInterior;
  }
  getResultSegmentInteriorWeight(e5, t3) {
    return this.getResultPart_(e5, t3).weightInterior;
  }
  getResultPoint() {
    return this.m_point;
  }
  getResultPointWeight() {
    return this.m_pointWeight;
  }
  getResultPointRank() {
    return this.m_pointRank;
  }
  getResultPointChanged() {
    return this.m_changed2;
  }
  intersectLines(e5, t3) {
    2 !== this.m_inputSegments.length && b(""), this.m_changed1 = false, this.m_changed2 = false, this.m_tolerance = e5;
    const s4 = H(e5 * _xn.c_smallToleranceFactor);
    let n6 = false;
    const r = this.m_inputParts[0], o = this.m_inputParts[1], a2 = this.m_inputSegments[r.segmentIndex], h2 = this.m_inputSegments[o.segmentIndex];
    if (t3 || 5 & rm(true, a2, h2, e5, true)) {
      const t4 = um(true, a2, h2, null, this.m_param1, this.m_param2, e5);
      0 === t4 && b("");
      const m3 = new Array(t4);
      for (let e6 = 0; e6 < t4; ++e6) m3[e6] = mi.getNAN();
      const l2 = new Float64Array(t4), g2 = new Int32Array(t4), u = new Array(t4), c = new Array(t4);
      for (let e6 = 0; e6 < t4; ++e6) u[e6] = En2(), c[e6] = En2();
      for (let e6 = 0; e6 < t4; e6++) {
        const t5 = this.m_param1[e6], i2 = this.m_param2[e6];
        let _2, d3 = r.rankInterior, p4 = r.weightInterior;
        0 === t5 ? (d3 = r.rankStart, p4 = r.weightStart, _2 = r.u.bBreakStart) : 1 === t5 ? (d3 = r.rankEnd, p4 = r.weightEnd, _2 = r.u.bBreakEnd) : (this.m_changed1 = true, _2 = false);
        let f4, x5 = o.rankInterior, y3 = o.weightInterior;
        0 === i2 ? (x5 = o.rankStart, y3 = o.weightStart, f4 = o.u.bBreakStart) : 1 === i2 ? (x5 = o.rankEnd, y3 = o.weightEnd, f4 = o.u.bBreakEnd) : (this.m_changed2 = true, f4 = false);
        const P6 = d3, E2 = x5;
        let S3 = 1, C3 = 0, I4 = mi.getNAN();
        if (P6 === E2) {
          const n7 = a2.getCoord2D(t5), r2 = h2.getCoord2D(i2);
          S3 = p4 + y3;
          C3 = d3, Y(n7, r2, y3 / S3, I4);
          const o2 = mi.sqrDistance(I4, n7), m4 = mi.sqrDistance(I4, r2);
          u[e6].bBigMove = o2 > s4, c[e6].bBigMove = m4 > s4, this.m_changed1 || n7.equals(I4) || (this.m_changed1 = true), this.m_changed2 || r2.equals(I4) || (this.m_changed2 = true);
        } else if (P6 > E2) {
          I4 = a2.getCoord2D(t5);
          const n7 = h2.getCoord2D(i2);
          S3 = p4, C3 = d3;
          const r2 = mi.sqrDistance(I4, n7);
          u[e6].bBigMove = false, c[e6].bBigMove = r2 > s4, this.m_changed2 || n7.equals(I4) || (this.m_changed2 = true);
        } else {
          I4 = h2.getCoord2D(i2), S3 = y3, C3 = x5;
          const n7 = a2.getCoord2D(t5), r2 = mi.sqrDistance(I4, n7);
          u[e6].bBigMove = r2 > s4, c[e6].bBigMove = false, this.m_changed1 || n7.equals(I4) || (this.m_changed1 = true);
        }
        m3[e6].assign(I4), l2[e6] = S3, g2[e6] = C3, u[e6].bIsBreak = _2 || f4, c[e6].bIsBreak = _2 || f4, n6 ||= u[e6].bBigMove || c[e6].bBigMove;
      }
      const _ = r.rankInterior, d2 = r.weightInterior;
      let p3 = 0, f3 = -1;
      for (let s5 = 0; s5 <= t4; s5++) {
        const n7 = s5 < t4 ? this.m_param1[s5] : 1;
        if (n7 !== p3) {
          const i2 = this.allocResultSegment(), o2 = this.m_resultSegments[i2];
          let h3, c2, x5, y3;
          a2.queryCut(p3, n7, o2, false), o2.get().snapControlPoints(e5 * e5);
          let P6 = false, E2 = false, S3 = false, C3 = false, I4 = false, b2 = mi.getNAN(), w4 = mi.getNAN();
          -1 !== f3 ? (c2 = g2[f3], h3 = l2[f3], P6 = u[f3].bBigMove, b2.assign(m3[f3]), S3 = u[f3].bIsBreak, I4 = true) : (h3 = r.weightStart, c2 = r.rankStart, b2 = o2.get().getStartXY(), S3 = r.u.bBreakStart), s5 < t4 ? (y3 = g2[s5], x5 = l2[s5], E2 = u[s5].bBigMove, w4.assign(m3[s5]), C3 = u[s5].bIsBreak, I4 = true) : (x5 = r.weightEnd, y3 = r.rankEnd, w4 = o2.get().getEndXY(), C3 = r.u.bBreakEnd), I4 && o2.get().setCoordsForIntersector(b2, w4, true), this.m_resultParts1.push(this.newIntersectionPart_(i2, h3, c2, x5, y3, d2, _, S3, C3, r.segmentParentage));
          const v3 = this.m_resultParts1.at(-1);
          v3.u.bBigMoveStart = P6, v3.u.bBigMoveEnd = E2, p3 = n7, f3 = s5;
        } else -1 === f3 && (f3 = s5);
      }
      const x4 = Yt(t4, 0);
      for (let e6 = 0; e6 < t4; e6++) x4[e6] = e6;
      t4 > 2 ? (x4.sort((e6, t5) => this.m_param2[e6] < this.m_param2[t5] ? -1 : this.m_param2[e6] > this.m_param2[t5] ? 1 : 0), qt(this.m_param2)) : 2 === t4 && this.m_param2[0] > this.m_param2[1] && (this.m_param2[1] = Pt(this.m_param2[0], this.m_param2[0] = this.m_param2[1]), x4[1] = Pt(x4[0], x4[0] = x4[1]));
      const y2 = o.rankInterior, P5 = o.weightInterior;
      p3 = 0, f3 = -1;
      for (let s5 = 0; s5 <= t4; s5++) {
        const n7 = s5 < t4 ? this.m_param2[s5] : 1;
        if (n7 !== p3) {
          const r2 = this.allocResultSegment(), i2 = this.m_resultSegments[r2];
          let a3, u2, _2, d3;
          h2.queryCut(p3, n7, i2, false), i2.get().snapControlPoints(e5 * e5);
          let E2 = mi.getNAN(), S3 = mi.getNAN(), C3 = false, I4 = false, b2 = false, w4 = false, v3 = false;
          if (-1 !== f3) {
            const e6 = x4[f3];
            a3 = l2[e6], u2 = g2[e6], E2.assign(m3[e6]), b2 = c[e6].bBigMove, C3 = c[e6].bIsBreak, v3 = true;
          } else a3 = o.weightStart, u2 = o.rankStart, E2 = i2.get().getStartXY(), C3 = o.u.bBreakStart;
          if (s5 !== t4) {
            const e6 = x4[s5];
            _2 = l2[e6], d3 = g2[e6], S3.assign(m3[e6]), w4 = c[e6].bBigMove, I4 = c[e6].bIsBreak, v3 = true;
          } else _2 = o.weightEnd, d3 = o.rankEnd, S3 = i2.get().getEndXY(), I4 = o.u.bBreakEnd;
          v3 && i2.get().setCoordsForIntersector(E2, S3, true), this.m_resultParts2.push(this.newIntersectionPart_(r2, a3, u2, _2, d3, P5, y2, C3, I4, o.segmentParentage));
          const N2 = this.m_resultParts2.at(-1);
          N2.u.bBigMoveStart = b2, N2.u.bBigMoveEnd = w4, p3 = n7, f3 = s5;
        } else -1 === f3 && (f3 = s5);
      }
      return n6 ? 3 : 2;
    }
    return 0;
  }
  intersectLines3D(e5, t3, s4, n6) {
    return n2(0), 1;
  }
  intersect2D(e5, t3) {
    const s4 = this.m_inputParts[0], r = this.m_inputParts[1], i2 = this.m_inputSegments[s4.segmentIndex].getGeometryType(), o = this.m_inputSegments[r.segmentIndex].getGeometryType();
    if (i2 !== a.enumLine || o !== a.enumLine) {
      return new bn2(this).intersectCurves(e5, t3);
    }
    return this.intersectLines(e5, t3);
  }
  intersect2DEx(e5, t3, s4, n6, r) {
    this.m_point.assignCopy(t3), 1 !== this.m_inputSegments.length && b(""), this.m_tolerance = e5, this.m_changed1 = false, this.m_changed2 = false;
    const o = H(e5 * _xn.c_smallToleranceFactor);
    let a2 = false;
    const h2 = this.m_inputParts[0], m3 = this.m_inputSegments[h2.segmentIndex];
    if (r || m3.isIntersectingPoint(t3.getXY(), e5, true)) {
      this.m_param1 = Yt(16, Number.NaN);
      const r2 = m3.getClosestCoordinate(t3.getXY(), false);
      this.m_param1[0] = r2;
      let i2 = h2.rankInterior, l2 = h2.weightInterior;
      0 === r2 ? (i2 = h2.rankStart, l2 = h2.weightStart) : 1 === r2 ? (i2 = h2.rankEnd, l2 = h2.weightEnd) : this.m_changed1 = true;
      let g2 = i2;
      const u = s4, c = n6;
      g2 === u && m3.isCurve() && (g2 = u + 1);
      let _ = 1, d2 = 0;
      const p3 = new mi();
      if (g2 === u) {
        const e6 = m3.getCoord2D(r2), s5 = t3.getXY();
        _ = l2 + c, d2 = i2;
        Y(e6, s5, c / _, p3), this.m_changed1 || e6.equals(p3) || (this.m_changed1 = true), this.m_changed2 || s5.equals(p3) || (this.m_changed2 = true);
        a2 = mi.sqrDistance(p3, e6) > o;
      } else if (g2 > u) p3.assign(m3.getCoord2D(r2)), _ = l2, d2 = i2, this.m_changed2 || p3.equals(t3.getXY()) || (this.m_changed2 = true);
      else {
        p3.assign(m3.getCoord2D(r2)), _ = c, d2 = u, this.m_changed1 || p3.equals(t3.getXY()) || (this.m_changed1 = true);
        a2 = mi.sqrDistance(p3, t3.getXY()) > o;
      }
      let f3 = 0, x4 = -1;
      const y2 = 1;
      for (let t4 = 0; t4 <= y2; t4++) {
        const s5 = t4 < y2 ? this.m_param1[0] : 1;
        if (s5 !== f3) {
          const n7 = this.allocResultSegment(), r3 = this.m_resultSegments[n7];
          m3.queryCut(f3, s5, r3), r3.get().snapControlPoints(e5 * e5);
          let i3 = h2.weightStart, o2 = h2.weightEnd, a3 = h2.rankStart, l3 = h2.rankEnd;
          const g3 = h2.rankInterior, u2 = h2.weightInterior;
          let c2 = h2.u.bBreakStart, P5 = h2.u.bBreakEnd;
          -1 !== x4 && (i3 = _, a3 = d2, c2 = true, r3.get().setCoordsForIntersector(p3, r3.get().getEndXY(), true)), t4 !== y2 && (o2 = _, l3 = d2, P5 = true, r3.get().setCoordsForIntersector(r3.get().getStartXY(), p3, true)), f3 = s5, this.m_resultParts1.push(this.newIntersectionPart_(n7, i3, a3, o2, l3, u2, g3, c2, P5, h2.segmentParentage));
        }
        x4 = t4;
      }
      return this.m_point.setXY(p3), this.m_pointWeight = _, this.m_pointRank = d2, a2 ? 3 : 2;
    }
    return 0;
  }
  intersect3D(e5, t3, s4, n6) {
    return n2(0), 1;
  }
  intersect3DEx(e5, t3, s4, n6, r, i2, o) {
    return n2(0), 1;
  }
  getTolerance() {
    return this.m_tolerance;
  }
  freeAllResultSegments() {
    this.m_resultSegments.length = 0, this.m_freeSegments.length = 0;
  }
  freeResultSegment(e5) {
    this.m_freeSegments.push(e5);
  }
  allocResultSegment() {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const e5 = new fm(), t3 = this.m_resultSegments.length;
    return this.m_resultSegments.push(e5), t3;
  }
  allocResultSegmentFromBuffer(e5) {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const t3 = new fm({ copy: e5 }), s4 = this.m_resultSegments.length;
    return this.m_resultSegments.push(t3), s4;
  }
  allocResultSegmentFromSegment(e5) {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const t3 = new fm({ segment: e5 }), s4 = this.m_resultSegments.length;
    return this.m_resultSegments.push(t3), s4;
  }
};
function yn2(e5, t3) {
  return { bBigMoveStart: false, bBigMoveEnd: false, bBreakStart: e5, bBreakEnd: t3 };
}
function Pn2(e5, t3, s4, n6, r, i2, o, a2, h2, m3) {
  return { segmentIndex: e5, weightStart: t3, rankStart: s4, weightEnd: n6, rankEnd: r, weightInterior: i2, rankInterior: o, segmentParentage: m3, u: yn2(a2, h2) };
}
function En2() {
  return { bBigMove: false, bIsBreak: false };
}
xn2.maxWeight = 0.1 * Number.MAX_VALUE, xn2.c_smallToleranceFactor = 0.01, xn2.c_maxGeometryTypeToRankDelta = 8;
var Sn2 = class {
  constructor() {
    this.start = null, this.end = null, this.equalEdge = null, this.segmentIndex = -1, this.segmentParentage = -1, this.weight = 0, this.rank = 0;
  }
  hasSegment() {
    return this.segmentIndex >= 0;
  }
  transferAttributes(e5, t3, s4) {
    if (1 === t3.getDescription().getAttributeCount()) return;
    const n6 = e5.parent.m_resultSegments[this.segmentIndex].get().getStartXY(), r = e5.parent.m_resultSegments[this.segmentIndex].get().getEndXY(), i2 = new ee();
    t3.queryStart(i2), s4 ? (i2.setXY(n6), e5.parent.m_resultSegments[this.segmentIndex].get().setStart(i2)) : (i2.setXY(r), e5.parent.m_resultSegments[this.segmentIndex].get().setEnd(i2)), t3.queryEnd(i2), s4 ? (i2.setXY(r), e5.parent.m_resultSegments[this.segmentIndex].get().setEnd(i2)) : (i2.setXY(n6), e5.parent.m_resultSegments[this.segmentIndex].get().setStart(i2));
  }
  copyFromWhenOverlap(e5, t3, s4) {
    this.equalEdge = t3, t3.equalEdge = this, this.segmentIndex = e5.parent.allocResultSegmentFromBuffer(e5.parent.m_resultSegments[t3.segmentIndex]), this.segmentParentage = t3.segmentParentage, this.weight = t3.weight, this.rank = t3.rank, s4 ? (this.start.copyFrom(t3.start), this.end.copyFrom(t3.end)) : (this.start.copyFrom(t3.end), this.end.copyFrom(t3.start), e5.parent.m_resultSegments[this.segmentIndex].get().reverse());
  }
  getEnd() {
    return this.end;
  }
  getNextInChain() {
    return this.end.nextInChain;
  }
  getPrevInChain() {
    return this.start.prevInChain;
  }
};
var Cn2 = class {
  constructor() {
    this.hash = 0, this.pt = new mi(), this.prevInChain = null, this.nextInChain = null, this.prevInHash = null, this.nextInHash = null, this.prevEqual = null, this.nextEqual = null, this.weight = 0, this.rank = 0, this.bBigMove = false, this.bIsBreak = false;
  }
  copyFrom(e5) {
    this.pt.assign(e5.pt), this.weight = e5.weight, this.rank = e5.rank, this.bBigMove = e5.bBigMove, this.bIsBreak = e5.bIsBreak;
  }
  nextNode() {
    return this.nextInChain ? this.nextInChain.end : null;
  }
  prevNode() {
    return this.prevInChain ? this.prevInChain.start : null;
  }
  equalListHead() {
    let e5 = this;
    for (; null !== e5.prevEqual; e5 = e5.prevEqual) ;
    return e5;
  }
};
function In2(e5, t3, s4, n6) {
  return { edge1: e5, edge2: t3, recursion: s4, bIsIntersecting: n6 };
}
var bn2 = class {
  constructor(e5) {
    this.m_pairs = [], this.m_chainOrigin1 = null, this.m_chainOrigin2 = null, this.m_newNodes = [], this.m_hashTableOfEquals = [], this.m_hashTableOfEqualsSize = 0, this.m_origin = new mi(), this.m_cell = new mi(), this.parent = e5;
  }
  addSegment(e5, t3, s4, n6, r, i2, o, h2, m3, l2, g2) {
    const u = this.newNode(this.parent.m_resultSegments[e5].get().getStartXY(), s4, n6, m3), c = this.newNode(this.parent.m_resultSegments[e5].get().getEndXY(), r, i2, l2);
    this.newEdge(u, c, e5, o, h2, g2), null === this.m_chainOrigin1 ? this.m_chainOrigin1 = u : null === this.m_chainOrigin2 ? this.m_chainOrigin2 = u : n2(0);
  }
  intersectCurvesHelper(e5, t3, s4, r, o) {
    const h2 = this.getSegment(e5).get(), m3 = this.getSegment(t3).get();
    if (h2.isDegenerate(0) || m3.isDegenerate(0)) return 0;
    const l2 = this.tryOverlapIntersectCurves(e5, t3, s4, r);
    if (0 !== l2) return l2;
    const g2 = H(0.01 * s4);
    let u = false, c = this.processSharpCorners(h2, m3, s4, o > 4);
    const _ = c > 0;
    if (!_) {
      if (!(r || 5 & om(true, false, h2, m3, s4, true))) return 0;
      c = um(true, h2, m3, null, this.parent.m_param1, this.parent.m_param2, s4);
    }
    0 === c && b("");
    const d2 = h2.getGeometryType(), p3 = m3.getGeometryType(), f3 = Ot(mi, c), x4 = Ot(mi, c), y2 = Yt(c, Number.NaN), P5 = Yt(c, Number.NaN), E2 = Yt(c, Number.NaN), S3 = Yt(c, Number.NaN), C3 = Ut(En2, c), I4 = Ut(En2, c);
    let b2 = false, w4 = false;
    for (let n6 = 0; n6 < c; n6++) {
      const r2 = this.parent.m_param1[n6], i2 = this.parent.m_param2[n6];
      let o2 = e5.rank, a2 = e5.weight, l3 = true, c2 = false;
      0 === r2 ? (o2 = e5.start.rank, a2 = e5.start.weight, c2 = e5.start.bIsBreak) : 1 === r2 ? (o2 = e5.end.rank, a2 = e5.end.weight, c2 = e5.end.bIsBreak) : (b2 = true, l3 = false);
      let v4 = t3.rank, N3 = t3.weight, T4 = false, G5 = true;
      0 === i2 ? (v4 = t3.start.rank, N3 = t3.start.weight, T4 = t3.start.bIsBreak) : 1 === i2 ? (v4 = t3.end.rank, N3 = t3.end.weight, T4 = t3.end.bIsBreak) : (w4 = true, G5 = false);
      let D4 = o2, V5 = v4;
      if (D4 === V5 && (D4 *= xn2.c_maxGeometryTypeToRankDelta, V5 *= xn2.c_maxGeometryTypeToRankDelta, D4 += wn2(d2, h2, false), V5 += wn2(p3, m3, false)), l3 && G5 && V5 === D4) {
        const e6 = h2.getCoord2D(r2), t4 = m3.getCoord2D(i2);
        e6.equals(t4) && (V5 = D4 - 1);
      }
      let F4 = 1, H4 = 0, k5 = 1, A5 = 0;
      const M2 = new mi(), U4 = new mi(), q2 = h2.getCoord2D(r2), B4 = m3.getCoord2D(i2);
      if (_ && mi.distance(q2, B4) > s4) M2.setCoordsPoint2D(q2), U4.setCoordsPoint2D(B4), F4 = a2, k5 = N3, H4 = o2, A5 = v4, C3[n6].bBigMove = false, I4[n6].bBigMove = false, c2 = true, T4 = true;
      else if (D4 === V5) {
        k5 = F4 = a2 + N3, A5 = H4 = o2;
        Y(q2, B4, N3 / F4, M2), U4.setCoordsPoint2D(M2);
        const e6 = mi.sqrDistance(M2, q2), t4 = mi.sqrDistance(M2, B4);
        C3[n6].bBigMove = e6 > g2, I4[n6].bBigMove = t4 > g2, b2 || q2.equals(M2) || (b2 = true), w4 || B4.equals(U4) || (w4 = true);
      } else if (D4 > V5) {
        M2.setCoordsPoint2D(q2), U4.setCoordsPoint2D(M2), k5 = F4 = a2, A5 = H4 = o2;
        const e6 = mi.sqrDistance(M2, B4);
        C3[n6].bBigMove = false, I4[n6].bBigMove = e6 > g2, w4 || B4.equals(U4) || (w4 = true);
      } else {
        U4.setCoordsPoint2D(B4), M2.setCoordsPoint2D(U4), k5 = F4 = N3, A5 = H4 = v4;
        const e6 = mi.sqrDistance(M2, q2);
        C3[n6].bBigMove = e6 > g2, I4[n6].bBigMove = false, b2 || q2.equals(M2) || (b2 = true);
      }
      f3[n6].assign(M2), x4[n6].assign(U4), y2[n6] = F4, P5[n6] = k5, E2[n6] = H4, S3[n6] = A5, C3[n6].bIsBreak = c2 || T4, I4[n6].bIsBreak = c2 || T4, u ||= C3[n6].bBigMove || I4[n6].bBigMove, n6 > 0 && (r2 !== this.parent.m_param1[n6 - 1] && i2 !== this.parent.m_param2[n6 - 1] || (E2[n6] <= E2[n6 - 1] ? (f3[n6].assign(x4[n6 - 1]), y2[n6] = P5[n6 - 1], E2[n6] = S3[n6 - 1], x4[n6].assign(x4[n6 - 1]), P5[n6] = P5[n6 - 1], S3[n6] = S3[n6 - 1], C3[n6].bBigMove ||= C3[n6 - 1].bBigMove, I4[n6].bBigMove ||= I4[n6 - 1].bBigMove, C3[n6].bIsBreak ||= C3[n6 - 1].bIsBreak, I4[n6].bIsBreak ||= I4[n6 - 1].bIsBreak) : (f3[n6 - 1].assign(f3[n6]), y2[n6 - 1] = y2[n6], E2[n6 - 1] = E2[n6], x4[n6 - 1].assign(x4[n6]), P5[n6 - 1] = P5[n6], S3[n6 - 1] = S3[n6], C3[n6 - 1].bBigMove ||= C3[n6].bBigMove, I4[n6 - 1].bBigMove ||= I4[n6].bBigMove, C3[n6 - 1].bIsBreak ||= C3[n6].bIsBreak, I4[n6 - 1].bIsBreak ||= I4[n6].bIsBreak)));
    }
    if (!(b2 || w4 || 2 !== c || d2 === a.enumLine && p3 === a.enumLine)) {
      if (this.processDoublyConnectedEdges(e5, t3, o + 1, s4)) return this.parent.m_changed1 = true, this.parent.m_changed2 = true, 2;
      n2(0);
    }
    this.parent.m_changed1 ||= b2, this.parent.m_changed2 ||= w4;
    let v3 = e5, N2 = e5.end.weight, T3 = e5.end.rank, G4 = e5.end.bBigMove, D3 = e5.end.bIsBreak, V4 = 0, F3 = -1;
    for (let n6 = 0; n6 <= c; n6++) {
      const t4 = n6 < c ? this.parent.m_param1[n6] : 1;
      if (t4 !== V4) {
        const r2 = this.parent.allocResultSegment(), i2 = this.parent.m_resultSegments[r2];
        let o2, a2, m4, l3;
        h2.queryCut(V4, t4, i2, false), i2.get().snapControlPoints(s4 * s4);
        let g3 = false, u2 = false, _2 = false, d3 = false;
        const p4 = new mi(), x5 = new mi();
        -1 !== F3 ? (a2 = E2[F3], o2 = y2[F3], _2 = C3[F3].bBigMove, g3 = C3[F3].bIsBreak, p4.assign(f3[F3])) : (o2 = e5.start.weight, a2 = e5.start.rank, _2 = e5.start.bBigMove, g3 = e5.start.bIsBreak, p4.assign(i2.get().getStartXY())), n6 < c ? (l3 = E2[n6], m4 = y2[n6], d3 = C3[n6].bBigMove, u2 = C3[n6].bIsBreak, x5.assign(f3[n6])) : (m4 = N2, l3 = T3, d3 = G4, u2 = D3, x5.assign(i2.get().getEndXY()));
        let P6 = v3;
        t4 < 1 && (this.splitEdgeInPlace(v3), P6 = v3.getNextInChain()), this.updateSegmentOnly(v3, r2), 0 === v3.start.hash || v3.start.pt.equals(p4) || (this.m_newNodes.push(v3.start), this.removeNodeFromHash(v3.start), v3.start.hash = 0), 0 === v3.end.hash || v3.end.pt.equals(x5) || (this.m_newNodes.push(v3.end), this.removeNodeFromHash(v3.end), v3.end.hash = 0), v3.start.pt.assign(p4), v3.end.pt.assign(x5), v3.start.bBigMove ||= _2, v3.end.bBigMove ||= d3, v3.start.bIsBreak ||= g3, v3.end.bIsBreak ||= u2, v3.start.weight = o2, v3.start.rank = a2, v3.end.weight = m4, v3.end.rank = l3, v3 = P6, V4 = t4, F3 = n6;
      } else -1 === F3 && (F3 = n6);
    }
    const H3 = v3.getNextInChain(), k4 = [];
    k4.length = c;
    for (let n6 = 0; n6 < c; n6++) k4[n6] = n6;
    c > 2 ? (k4.sort((e6, t4) => Ct(this.parent.m_param2[e6], this.parent.m_param2[t4])), this.parent.m_param2.sort(Ct)) : 2 === c && this.parent.m_param2[0] > this.parent.m_param2[1] && (this.parent.m_param2[1] = Pt(this.parent.m_param2[0], this.parent.m_param2[0] = this.parent.m_param2[1]), k4[1] = Pt(k4[0], k4[0] = k4[1])), v3 = t3, N2 = t3.end.weight, T3 = t3.end.rank, G4 = t3.end.bBigMove, D3 = t3.end.bIsBreak, V4 = 0, F3 = -1;
    for (let n6 = 0; n6 <= c; n6++) {
      const e6 = n6 < c ? this.parent.m_param2[n6] : 1;
      if (e6 !== V4) {
        const r2 = this.parent.allocResultSegment(), i2 = this.parent.m_resultSegments[r2];
        let o2, a2, h3, l3;
        m3.queryCut(V4, e6, i2, false), i2.get().snapControlPoints(s4 * s4);
        const g3 = new mi(), u2 = new mi();
        let _2 = false, d3 = false, p4 = false, f4 = false;
        if (-1 !== F3) {
          const e7 = k4[F3];
          o2 = P5[e7], a2 = S3[e7], g3.assign(x4[e7]), p4 = I4[e7].bBigMove, _2 = I4[e7].bIsBreak;
        } else o2 = t3.start.weight, a2 = t3.start.rank, p4 = t3.start.bBigMove, _2 = t3.start.bIsBreak, g3.assign(i2.get().getStartXY());
        if (n6 !== c) {
          const e7 = k4[n6];
          h3 = P5[e7], l3 = S3[e7], u2.assign(x4[e7]), f4 = I4[e7].bBigMove, d3 = I4[e7].bIsBreak;
        } else h3 = N2, l3 = T3, f4 = G4, d3 = D3, u2.assign(i2.get().getEndXY());
        let y3 = v3;
        e6 < 1 && (this.splitEdgeInPlace(v3), y3 = v3.getNextInChain()), this.updateSegmentOnly(v3, r2), 0 === v3.start.hash || v3.start.pt.equals(g3) || (this.m_newNodes.push(v3.start), this.removeNodeFromHash(v3.start), v3.start.hash = 0), 0 === v3.end.hash || v3.end.pt.equals(u2) || (this.m_newNodes.push(v3.end), this.removeNodeFromHash(v3.end), v3.end.hash = 0), v3.start.pt.assign(g3), v3.end.pt.assign(u2), v3.start.bBigMove ||= p4, v3.end.bBigMove ||= f4, v3.start.bIsBreak ||= _2, v3.end.bIsBreak ||= d3, v3.start.weight = o2, v3.start.rank = a2, v3.end.weight = h3, v3.end.rank = l3, v3 = y3, V4 = e6, F3 = n6;
      } else -1 === F3 && (F3 = n6);
    }
    const A4 = v3.getNextInChain();
    return this.postProcessResultPartsForCurves(e5, H3, t3, A4, o + 1), u ? 3 : 2;
  }
  intersectCurves(t3, s4) {
    2 !== this.parent.m_inputSegments.length && b(""), this.parent.m_changed1 = false, this.parent.m_changed2 = false, this.parent.m_tolerance = t3, this.m_hashTableOfEqualsSize = 0, this.m_hashTableOfEquals = Vt(16);
    const n6 = n4.constructEmpty();
    for (let i2 = 0; i2 < 2; i2++) {
      const t4 = this.parent.allocResultSegmentFromSegment(this.parent.m_inputSegments[this.parent.m_inputParts[i2].segmentIndex]), s5 = n4.constructEmpty();
      this.parent.m_inputSegments[this.parent.m_inputParts[i2].segmentIndex].queryLooseEnvelope(s5), n6.mergeEnvelope2D(s5);
      const r2 = this.parent.m_inputParts[i2];
      this.addSegment(t4, 0, r2.weightStart, r2.rankStart, r2.weightEnd, r2.rankEnd, r2.weightInterior, r2.rankInterior, r2.u.bBreakStart, r2.u.bBreakEnd, r2.segmentParentage);
    }
    n6.inflateCoords(100 * t3, 100 * t3), this.m_origin.assign(n6.getLowerLeft()), this.m_cell.setCoords(2 * t3, 2 * t3), this.m_pairs.push(In2(this.m_chainOrigin1.nextInChain, this.m_chainOrigin2.nextInChain, 0, s4));
    let r = 0, o = true;
    for (; this.m_pairs.length; ) {
      const e5 = this.m_pairs.at(-1);
      this.m_pairs.pop(), n2(e5.recursion >= 0), n2(e5.recursion <= 256), this.clusterNodes(t3);
      const s5 = this.intersectCurvesHelper(e5.edge1, e5.edge2, t3, e5.bIsIntersecting, e5.recursion);
      o && (o = false, r = s5);
    }
    for (let e5 = 0; e5 < 2; e5++) {
      const t4 = 0 === e5 ? this.parent.m_resultParts1 : this.parent.m_resultParts2;
      for (let s5 = (0 === e5 ? this.m_chainOrigin1 : this.m_chainOrigin2).nextInChain; null != s5; s5 = s5.getNextInChain()) t4.push(this.parent.newIntersectionPart_(s5.segmentIndex, s5.start.weight, s5.start.rank, s5.end.weight, s5.end.rank, s5.weight, s5.rank, s5.start.bIsBreak, s5.end.bIsBreak, s5.segmentParentage)), t4.at(-1).u.bBigMoveStart = s5.start.bBigMove, t4.at(-1).u.bBigMoveEnd = s5.end.bBigMove;
    }
    return r;
  }
  tryOverlapIntersectCurves(e5, t3, s4, n6) {
    const r = this.parent.m_resultSegments[e5.segmentIndex].get(), i2 = this.parent.m_resultSegments[t3.segmentIndex].get(), o = r.getStartXY().equals(i2.getStartXY()) && r.getEndXY().equals(i2.getEndXY()), h2 = r.getStartXY().equals(i2.getEndXY()) && r.getEndXY().equals(i2.getStartXY());
    if (!o && !h2) return 0;
    const m3 = am(r, i2, true);
    if (0 !== m3 && hm(r, i2) && e5.segmentParentage === t3.segmentParentage) {
      let e6 = false;
      if (m3 > 0) e6 = r.equals(i2);
      else {
        n2(-1 === m3);
        const t4 = new fm({ segment: i2 });
        t4.get().reverse(), e6 = r.equals(t4.get());
      }
      if (e6) return 1;
    }
    const l2 = s4 * xn2.c_smallToleranceFactor;
    let g2 = false;
    if (0 === m3) {
      const e6 = [0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 0.5625, 0.3125];
      for (let t4 = 0, n7 = e6.length; t4 < n7; ++t4) {
        const n8 = e6[t4], o2 = new mi();
        r.queryCoord2D(n8, o2);
        const a2 = i2.getClosestCoordinate(o2, false), h3 = new mi();
        i2.queryCoord2D(a2, h3);
        const m4 = mi.distance(o2, h3);
        if (m4 > s4) return 0;
        g2 ||= m4 > l2;
      }
      for (let t4 = 0, n7 = e6.length; t4 < n7; ++t4) {
        const n8 = e6[t4], o2 = new mi();
        i2.queryCoord2D(n8, o2);
        const a2 = r.getClosestCoordinate(o2, false), h3 = new mi();
        r.queryCoord2D(a2, h3);
        const m4 = mi.distance(o2, h3);
        if (m4 > s4) return 0;
        g2 ||= m4 > l2;
      }
    }
    let u = e5.rank, c = t3.rank;
    return u === c && (u *= xn2.c_maxGeometryTypeToRankDelta, c *= xn2.c_maxGeometryTypeToRankDelta, u += wn2(r.getGeometryType(), r, true), c += wn2(i2.getGeometryType(), i2, true)), u > c ? (t3.copyFromWhenOverlap(this, e5, o), t3.transferAttributes(this, r, o)) : c > u ? (e5.copyFromWhenOverlap(this, t3, o), e5.transferAttributes(this, i2, o)) : e5.segmentParentage <= t3.segmentParentage ? (e5.weight = e5.weight + t3.weight, t3.copyFromWhenOverlap(this, e5, o), t3.transferAttributes(this, r, o)) : (t3.weight = e5.weight + t3.weight, e5.copyFromWhenOverlap(this, t3, o), e5.transferAttributes(this, i2, o)), g2 ? 3 : 2;
  }
  postProcessResultPartsForCurves(e5, t3, s4, n6, r) {
    r === bs() && b("curve_helper");
    for (let i2 = e5; i2 !== t3; i2 = i2.getNextInChain()) this.updateSegmentToNodes(i2);
    for (let i2 = s4; i2 !== n6; i2 = i2.getNextInChain()) this.updateSegmentToNodes(i2);
    for (let o = e5; o !== t3; o = o.getNextInChain()) {
      const e6 = o.end.pt.sub(o.start.pt);
      for (let t4 = s4; t4 !== n6; t4 = t4.getNextInChain()) {
        let s5 = 0;
        if (o.start.pt.equals(t4.start.pt) && o.end.pt.equals(t4.end.pt) ? s5 = 1 : o.start.pt.equals(t4.end.pt) && o.end.pt.equals(t4.start.pt) && (s5 = -1), !s5) {
          let s6 = o.start.pt.equals(t4.start.pt) ? 1 : 0;
          if (s6 || (s6 = o.end.pt.equals(t4.end.pt) ? 2 : 0, s6 || (s6 = o.end.pt.equals(t4.start.pt) ? 3 : 0, s6 || (s6 = o.start.pt.equals(t4.end.pt) ? 4 : 0))), s6) {
            const n8 = t4.end.pt.sub(t4.start.pt), a3 = e6.dotProduct(n8);
            let h3;
            switch (s6) {
              case 1:
              case 2:
                h3 = a3 > 0;
                break;
              case 3:
              case 4:
                h3 = a3 < 0;
                break;
              default:
                b("post_process_result_parts_for_curves_");
            }
            h3 && this.m_pairs.push(In2(o, t4, r, false));
          }
          continue;
        }
        const n7 = this.parent.m_resultSegments[o.segmentIndex], a2 = this.parent.m_resultSegments[t4.segmentIndex], h2 = [0.5, 0.25, 0.75];
        for (let e7 = 0, t5 = h2.length; e7 < t5; ++e7) {
          const t6 = h2[e7], r2 = new mi();
          n7.get().queryCoord2D(t6, r2);
          const i2 = a2.get().getClosestCoordinate(r2, false), o2 = new mi();
          a2.get().queryCoord2D(i2, o2);
          if (mi.distance(r2, o2) > this.parent.m_tolerance) {
            s5 = 0;
            break;
          }
        }
        if (!s5) {
          this.m_pairs.push(In2(o, t4, r, false));
          continue;
        }
        for (let e7 = 0, t5 = h2.length; e7 < t5; ++e7) {
          const t6 = h2[e7], r2 = new mi();
          a2.get().queryCoord2D(t6, r2);
          const i2 = n7.get().getClosestCoordinate(r2, false), o2 = new mi();
          n7.get().queryCoord2D(i2, o2);
          if (mi.distance(r2, o2) > this.parent.m_tolerance) {
            s5 = 0;
            break;
          }
        }
        if (!s5) {
          this.m_pairs.push(In2(o, t4, r, false));
          continue;
        }
        o.equalEdge = t4, t4.equalEdge = o;
        let m3 = o.rank, l2 = t4.rank;
        m3 === l2 && (m3 *= xn2.c_maxGeometryTypeToRankDelta, l2 *= xn2.c_maxGeometryTypeToRankDelta, m3 += wn2(n7.get().getGeometryType(), n7.get(), true), l2 += wn2(a2.get().getGeometryType(), a2.get(), true)), m3 > l2 || m3 === l2 && o.segmentParentage <= t4.segmentParentage ? (n7.copyTo(a2, false), t4.segmentParentage = o.segmentParentage, -1 === s5 && a2.get().reverse()) : (a2.copyTo(n7, false), o.segmentParentage = t4.segmentParentage, -1 === s5 && n7.get().reverse());
        break;
      }
    }
    this.updateAttachedEdgesAfterNodeChange(e5.start), t3 && this.updateAttachedEdgesAfterNodeChange(t3.start), this.updateAttachedEdgesAfterNodeChange(s4.start), n6 && this.updateAttachedEdgesAfterNodeChange(n6.start);
  }
  processDoublyConnectedEdges(e5, t3, s4, n6) {
    s4 === bs() && b("curve_helper");
    const r = this.getSegment(e5).get(), o = this.getSegment(t3).get(), a2 = r.getStartXY().equals(o.getStartXY()) && r.getEndXY().equals(o.getEndXY()) ? 1 : r.getEndXY().equals(o.getStartXY()) && r.getStartXY().equals(o.getEndXY()) ? -1 : 0;
    if (0 !== a2) {
      const i2 = new fm();
      r.queryCut(0, 0.5, i2), i2.get().snapControlPoints(n6 * n6);
      const h2 = new fm();
      r.queryCut(0.5, 1, h2), h2.get().snapControlPoints(n6 * n6), this.splitEdgeInPlace(e5), e5.end.pt = i2.get().getEndXY(), e5.segmentIndex = this.parent.allocResultSegmentFromBuffer(i2), e5.getNextInChain().segmentIndex = this.parent.allocResultSegmentFromBuffer(h2);
      let m3 = o.getClosestCoordinate(e5.end.pt, false);
      return Math.abs(m3 - 0.5) > 0.2 && (m3 = 0.5), o.queryCut(0, m3, i2), i2.get().snapControlPoints(n6 * n6), o.queryCut(m3, 1, h2), h2.get().snapControlPoints(n6 * n6), this.splitEdgeInPlace(t3), t3.end.pt = i2.get().getEndXY(), t3.segmentIndex = this.parent.allocResultSegmentFromBuffer(i2), t3.getNextInChain().segmentIndex = this.parent.allocResultSegmentFromBuffer(h2), a2 > 0 ? (this.m_pairs.push(In2(e5, t3, s4, false)), this.m_pairs.push(In2(e5.getNextInChain(), t3.getNextInChain(), s4, false))) : (this.m_pairs.push(In2(e5, t3.getNextInChain(), s4, false)), this.m_pairs.push(In2(e5.getNextInChain(), t3, s4, false))), true;
    }
    return false;
  }
  newNode(e5, t3, s4, n6) {
    const r = new Cn2();
    return this.m_newNodes.push(r), r.pt = e5, r.rank = s4, r.weight = t3, r.bIsBreak = n6, r;
  }
  newEdge(e5, t3, s4, n6, r, i2) {
    const o = new Sn2();
    return o.start = e5, o.end = t3, e5.nextInChain = o, t3.prevInChain = o, o.segmentIndex = s4, o.segmentParentage = i2, o.rank = r, o.weight = n6, o;
  }
  splitEdgeInPlace(e5) {
    e5.segmentIndex = -1;
    const t3 = new Sn2(), s4 = new Cn2();
    this.m_newNodes.push(s4), s4.pt.setNAN(), s4.nextInChain = t3, s4.prevInChain = e5, s4.prevInHash = null, s4.nextInHash = null, s4.prevEqual = null, s4.nextEqual = null, s4.weight = e5.weight, s4.rank = e5.rank, s4.bIsBreak = false, s4.bBigMove = false, t3.start = s4, t3.segmentIndex = -1, t3.end = e5.end, t3.end.prevInChain = t3, t3.rank = e5.rank, t3.weight = e5.weight, t3.segmentParentage = e5.segmentParentage, e5.end = s4, e5.equalEdge && (e5.equalEdge.equalEdge = null), e5.equalEdge = null;
  }
  updateSegmentOnly(e5, t3) {
    e5.segmentIndex = t3;
  }
  updateAttachedEdgesAfterNodeChange(e5) {
    for (let t3 = e5.equalListHead(); null !== t3; t3 = t3.nextEqual) this.updateAttachedEdgesAfterNodeChangeImpl(t3);
  }
  updateAttachedEdgesAfterNodeChangeImpl(e5) {
    const t3 = e5.prevInChain;
    if (t3 && t3.hasSegment()) {
      const s5 = this.getSegment(t3).get();
      e5.pt.equals(s5.getEndXY()) || (s5.setCoordsForIntersector(t3.start.pt, t3.end.pt, false), s5.ensureXYMonotone());
    }
    const s4 = e5.nextInChain;
    if (s4 && s4.hasSegment()) {
      const t4 = this.getSegment(s4).get();
      e5.pt.equals(t4.getStartXY()) || (t4.setCoordsForIntersector(s4.start.pt, s4.end.pt, false), t4.ensureXYMonotone());
    }
  }
  updateSegmentToNodes(e5) {
    const t3 = this.getSegment(e5).get();
    e5.start.pt.equals(t3.getStartXY()) && e5.end.pt.equals(t3.getEndXY()) || (t3.setCoordsForIntersector(e5.start.pt, e5.end.pt, false), t3.ensureXYMonotone()), this.updateAttachedEdgesAfterNodeChange(e5.start), this.updateAttachedEdgesAfterNodeChange(e5.end);
  }
  getSegment(e5) {
    return this.parent.m_resultSegments[e5.segmentIndex];
  }
  clusterNodes(e5) {
    let t3 = false;
    const s4 = [], n6 = [], r = [];
    for (let i2 = 0, o = this.m_newNodes.length; i2 < o; i2++) {
      const e6 = this.m_newNodes[i2];
      if (null === e6) continue;
      let t4 = e6;
      for (let s5 = i2 + 1; s5 < o; s5++) {
        const n7 = this.m_newNodes[s5];
        null !== n7 && (e6.pt.equals(n7.pt) && (t4.nextInHash = n7, n7.prevInHash = t4, t4 = n7, this.m_newNodes[s5] = null));
      }
    }
    for (let i2 = 0, o = this.m_newNodes.length; i2 < o; i2++) {
      const o2 = this.m_newNodes[i2];
      if (null == o2) continue;
      for (o2.hash = this.calculateHash(o2.pt); ; ) {
        const i3 = Vt(4), a3 = this.hashTableBinsToCheck(o2, i3);
        for (let t4 = 0; t4 < a3; t4++) if (null !== i3[t4]) for (let a4 = i3[t4]; null !== a4; ) {
          const t5 = a4.nextInHash;
          mi.distance(o2.pt, a4.pt) <= e5 && (s4.push(a4), this.removeNodeFromHash(a4), a4.hash = 0, r.push(a4), n6.push(a4)), a4 = t5;
        }
        let h3 = false;
        for (const e6 of s4) if (!o2.pt.equals(e6.pt)) {
          const s5 = un2(o2.pt, e6.pt, o2.weight, o2.rank, e6.weight, e6.rank);
          o2.pt.assign(s5.pt), o2.weight = s5.weight, o2.rank = s5.rank, h3 = true, t3 = true;
        }
        if (s4.length = 0, !h3) break;
        o2.hash = this.calculateHash(o2.pt);
      }
      r.push(o2), n6.push(o2);
      for (let e6 = o2.nextInHash; null !== e6; ) {
        e6.prevInHash = null;
        const t4 = e6.nextInHash;
        e6.nextInHash = null, r.push(e6), n6.push(e6), e6 = t4;
      }
      const a2 = o2.hash;
      let h2 = null, m3 = null;
      for (const e6 of n6) o2 !== e6 && (e6.hash = a2, e6.pt.assign(o2.pt), e6.rank = o2.rank, e6.weight = o2.weight), e6.prevInHash = h2, h2 && (h2.nextInHash = e6), e6.prevEqual = m3, e6.nextEqual = null, m3 && (m3.nextEqual = e6), m3 = e6, h2 = e6;
      const l2 = a2 % this.m_hashTableOfEquals.length;
      h2.nextInHash = this.m_hashTableOfEquals[l2], null !== this.m_hashTableOfEquals[l2] && (this.m_hashTableOfEquals[l2].prevInHash = h2), this.m_hashTableOfEquals[l2] = n6[0], this.m_hashTableOfEqualsSize += n6.length, n6.length = 0, this.rehashIfNeeded();
    }
    if (this.m_newNodes.length = 0, t3) for (const i2 of r) this.updateAttachedEdgesAfterNodeChange(i2);
  }
  rehashIfNeeded() {
    if (2 * this.m_hashTableOfEqualsSize > this.m_hashTableOfEquals.length) {
      const e5 = this.m_hashTableOfEquals;
      this.m_hashTableOfEquals = Vt(2 * e5.length), this.m_hashTableOfEqualsSize = 0;
      for (const t3 of e5) {
        let e6 = t3;
        for (; e6; ) {
          const t4 = e6.nextInHash;
          e6.nextInHash = null, e6.prevInHash = null, this.addNodeToHashImpl(e6), e6 = t4;
        }
      }
    }
  }
  addNodeToHashImpl(e5) {
    const t3 = e5.hash % this.m_hashTableOfEquals.length, s4 = this.m_hashTableOfEquals[t3];
    e5.nextInHash = s4, null !== s4 && (s4.prevInHash = e5), this.m_hashTableOfEquals[t3] = e5, this.m_hashTableOfEqualsSize++;
  }
  removeNodeFromHash(e5) {
    const t3 = e5.hash % this.m_hashTableOfEquals.length, s4 = e5.prevInHash, n6 = e5.nextInHash;
    s4 ? s4.nextInHash = n6 : this.m_hashTableOfEquals[t3] = n6, n6 && (n6.prevInHash = s4), this.m_hashTableOfEqualsSize--, e5.prevInHash = null, e5.nextInHash = null;
  }
  hashTableBinsToCheck(e5, t3) {
    const s4 = (e5.pt.x - this.m_origin.x) / this.m_cell.x, n6 = (e5.pt.y - this.m_origin.y) / this.m_cell.y, r = ds() - 1, i2 = Math.round(Us(s4, -2147483646, r)), o = Math.round(Us(n6, -2147483646, r));
    let a2 = i2 | o << 32;
    a2 = Zs(a2), t3[0] = this.m_hashTableOfEquals[a2 % this.m_hashTableOfEquals.length];
    let h2 = i2 + 1 | o << 32;
    h2 = Zs(h2);
    let m3 = 1;
    t3[1] = this.m_hashTableOfEquals[h2 % this.m_hashTableOfEquals.length], t3[1] !== t3[0] && (m3 = 2);
    let l2 = i2 + 1 | o + 1 << 32;
    l2 = Zs(l2), t3[m3] = this.m_hashTableOfEquals[l2 % this.m_hashTableOfEquals.length];
    for (let u = 0; u < m3; u++) if (t3[m3] === t3[u]) {
      m3--;
      break;
    }
    m3++;
    let g2 = i2 | o + 1 << 32;
    g2 = Zs(g2), t3[m3] = this.m_hashTableOfEquals[g2 % this.m_hashTableOfEquals.length];
    for (let u = 0; u < m3; u++) if (t3[m3] === t3[u]) {
      m3--;
      break;
    }
    return m3++, m3;
  }
  calculateHash(e5) {
    const t3 = (e5.x - this.m_origin.x) / this.m_cell.x, s4 = (e5.y - this.m_origin.y) / this.m_cell.y, n6 = ds() - 1;
    let r = Math.round(Us(t3, -2147483646, n6)) | Math.round(Us(s4, -2147483646, n6)) << 32;
    return r = Zs(r), 0 === r && (r = 1), r;
  }
  processSharpCorners(e5, t3, s4, n6) {
    if (this.parent.m_param1.length = 0, this.parent.m_param2.length = 0, e5.getStartXY().equals(t3.getStartXY())) {
      const r = [0, 0], i2 = [0, 0], o = gm(e5, t3, 0, 0, s4, 2, r, i2, n6);
      if (o) {
        this.parent.m_param1.push(0), this.parent.m_param2.push(0);
        for (let e6 = 0; e6 < o; e6++) this.parent.m_param1.push(r[e6]), this.parent.m_param2.push(i2[e6]);
        return o + 1;
      }
    }
    if (e5.getEndXY().equals(t3.getEndXY())) {
      const r = [0, 0], i2 = [0, 0], o = gm(e5, t3, 1, 1, s4, 2, r, i2, n6);
      if (o) {
        for (let e6 = 0; e6 < o; e6++) this.parent.m_param1.push(r[e6]), this.parent.m_param2.push(i2[e6]);
        return this.parent.m_param1.push(1), this.parent.m_param2.push(1), o + 1;
      }
    }
    if (e5.getStartXY().equals(t3.getEndXY())) {
      const r = [0, 0], i2 = [0, 0], o = gm(e5, t3, 0, 1, s4, 2, r, i2, n6);
      if (o) {
        this.parent.m_param1.push(0), this.parent.m_param2.push(1);
        for (let e6 = 0; e6 < o; e6++) this.parent.m_param1.push(r[e6]), this.parent.m_param2.push(i2[e6]);
        return o + 1;
      }
    }
    if (e5.getEndXY().equals(t3.getStartXY())) {
      const r = [0, 0], i2 = [0, 0], o = gm(e5, t3, 1, 0, s4, 2, r, i2, n6);
      if (o) {
        for (let e6 = 0; e6 < o; e6++) this.parent.m_param1.push(r[e6]), this.parent.m_param2.push(i2[e6]);
        return this.parent.m_param1.push(1), this.parent.m_param2.push(0), o + 1;
      }
    }
    return 0;
  }
};
function wn2(e5, t3, s4) {
  let r = 0;
  switch (e5) {
    case a.enumLine:
      r = 0;
      break;
    case a.enumBezier:
      r = 2;
      break;
    case a.enumRationalBezier2:
      r = 3;
      break;
    case a.enumBezier2:
      r = 1;
      break;
    case a.enumEllipticArc:
      r = 0 === t3.projectionBehavior() ? 5 : 4;
      break;
    default:
      b("");
  }
  return s4 ? 5 - r : r;
}
var vn2 = class extends on2 {
  constructor(e5) {
    super(e5.m_shape, e5.m_tolerance, false), this.m_parent = e5;
  }
  compare(e5, t3, s4) {
    if (this.m_bIntersectionDetected) return -1;
    const n6 = e5.getElement(s4), r = this.m_parent.getEdgeOriginVertices(t3), i2 = this.m_parent.m_edgeVertices.getFirstElement(r), o = this.m_parent.getEdgeOriginVertices(n6), a2 = this.m_parent.m_edgeVertices.getFirstElement(o);
    return this.m_currentNode = s4, this.compareSegments(t3, i2, n6, a2);
  }
};
var Nn2 = class extends an2 {
  constructor(e5) {
    super(e5.m_shape, e5.m_tolerance), this.m_parent = e5;
  }
  compare(e5, t3) {
    if (this.m_bIntersectionDetected) return -1;
    const s4 = e5.getElement(t3), n6 = this.m_parent.getEdgeOriginVertices(s4), r = this.m_parent.m_edgeVertices.getFirstElement(n6);
    return this.m_currentNode = t3, this.compareVertex(e5, t3, r);
  }
};
var Tn2 = class extends dt {
  constructor(e5) {
    super(), this.pt1 = mi.getNAN(), this.pt2 = mi.getNAN(), this.m_shape = e5;
  }
  compare(e5, t3, s4) {
    this.m_shape.queryXY(t3, this.pt1);
    const n6 = e5.getElement(s4);
    return this.m_shape.queryXY(n6, this.pt2), this.pt1.compare(this.pt2);
  }
};
var Gn2 = class {
  constructor(e5) {
    this.m_point = mi.getNAN(), this.m_pt = mi.getNAN(), this.m_shape = e5;
  }
  setPoint(e5) {
    this.m_point.setCoordsPoint2D(e5);
  }
  compare(e5, t3) {
    const s4 = e5.getElement(t3);
    return this.m_shape.queryXY(s4, this.m_pt), this.m_point.compare(this.m_pt);
  }
};
var Dn2 = class {
  constructor(e5, t3) {
    this.m_shape = null, this.m_progressTracker = null, this.m_edges = new at(8), this.m_clusters = new at(5), this.m_clusterVertices = new sn2(false), this.m_edgeVertices = new sn2(false), this.m_helperPoint = new ee(), this.m_eventQ = new ct2(), this.m_sweepStructure = new ct2(), this.m_bComplications = false, this.m_sweepComparator = null, this.m_tempEdgeBuffer = [], this.m_modifiedClusters = [], this.m_edgesToInsertInSweepStructure = [], this.m_prevNeighbour = -1, this.m_nextNeighbour = -1, this.m_bContinuingSegmentChainOptimization = false, this.m_progressCounter = 0, this.m_segmentIntersector = new xn2(), this.m_segBuf1 = new fm(), this.m_segBuf2 = new fm(), this.m_sweepPoint = new mi(0, 0), this.m_tolerance = 0, this.m_toleranceSqr = 0, this.m_sweepPointCluster = -1, this.m_vertexClusterIndex = -1, this.m_bCracked = false, this.m_bSweepPointClusterWasModified = false, this.m_progressTracker = e5, this.m_bTrackChanges = t3;
  }
  hadComplications() {
    return this.m_bComplications;
  }
  sweep(e5, t3) {
    const s4 = new x3();
    s4.setSwapCoordinates(), e5.applyTransformation(s4), this.setEditShape_(e5), this.m_bCracked = false, this.m_tolerance = t3, this.m_toleranceSqr = t3 * t3;
    let n6 = this.sweepImpl_();
    return e5.applyTransformation(s4), n6 || (this.fillEventQueuePass2(), n6 = this.sweepImpl_() || n6), this.m_shape.removeUserIndex(this.m_vertexClusterIndex), this.m_shape = null, this.m_bCracked;
  }
  sweepVertical(e5, t3) {
    this.setEditShape_(e5), this.m_bCracked = false, this.m_tolerance = t3, this.m_toleranceSqr = t3 * t3, this.m_bComplications = false;
    let s4 = this.sweepImpl_();
    if (!this.m_bComplications) {
      const n6 = e5.filterClosePoints(t3, true, false, this.m_bTrackChanges, cr);
      this.m_bComplications = 1 === n6, s4 ||= 1 === n6;
    }
    return -1 !== this.m_vertexClusterIndex && (this.m_shape.removeUserIndex(this.m_vertexClusterIndex), this.m_vertexClusterIndex = -1), this.m_shape = null, s4;
  }
  getEdgeCluster(e5, t3) {
    return this.m_edges.getField(e5, 0 + t3);
  }
  setEdgeCluster_(e5, t3, s4) {
    this.m_edges.setField(e5, 0 + t3, s4);
  }
  getEdgeOriginVertices(e5) {
    return this.m_edges.getField(e5, 2);
  }
  setEdgeOriginVertices_(e5, t3) {
    this.m_edges.setField(e5, 2, t3);
  }
  getNextEdgeEx(e5, t3) {
    return this.m_edges.getField(e5, 3 + t3);
  }
  setNextEdgeEx_(e5, t3, s4) {
    this.m_edges.setField(e5, 3 + t3, s4);
  }
  getEdgeSweepNode(e5) {
    return this.m_edges.getField(e5, 7);
  }
  setEdgeSweepNode_(e5, t3) {
    this.m_edges.setField(e5, 7, t3);
  }
  getNextEdge(e5, t3) {
    const s4 = this.getEdgeEnd(e5, t3);
    return this.m_edges.getField(e5, 3 + s4);
  }
  setNextEdge_(e5, t3, s4) {
    const n6 = this.getEdgeEnd(e5, t3);
    this.m_edges.setField(e5, 3 + n6, s4);
  }
  getPrevEdge(e5, t3) {
    const s4 = this.getEdgeEnd(e5, t3);
    return this.m_edges.getField(e5, 5 + s4);
  }
  setPrevEdge_(e5, t3, s4) {
    const n6 = this.getEdgeEnd(e5, t3);
    this.m_edges.setField(e5, 5 + n6, s4);
  }
  getClusterVertices(e5) {
    return this.m_clusters.getField(e5, 0);
  }
  setClusterVertices_(e5, t3) {
    this.m_clusters.setField(e5, 0, t3);
  }
  getClusterSweepEdgeList(e5) {
    return this.m_clusters.getField(e5, 2);
  }
  setClusterSweepEdgeList_(e5, t3) {
    this.m_clusters.setField(e5, 2, t3);
  }
  getClusterFirstEdge(e5) {
    return this.m_clusters.getField(e5, 1);
  }
  setClusterFirstEdge_(e5, t3) {
    this.m_clusters.setField(e5, 1, t3);
  }
  getClusterEventQNode(e5) {
    return this.m_clusters.getField(e5, 3);
  }
  setClusterEventQNode_(e5, t3) {
    this.m_clusters.setField(e5, 3, t3);
  }
  newCluster_(e5) {
    const t3 = this.m_clusters.newElement(), s4 = this.m_clusterVertices.createList();
    return this.setClusterVertices_(t3, s4), e5 !== cr && (this.m_clusterVertices.addElement(s4, e5), this.m_shape.setUserIndex(e5, this.m_vertexClusterIndex, t3)), t3;
  }
  deleteCluster_(e5) {
    this.m_clusters.deleteElement(e5);
  }
  addVertexToCluster_(e5, t3) {
    const s4 = this.getClusterVertices(e5);
    this.m_clusterVertices.addElement(s4, t3), this.m_shape.setUserIndex(t3, this.m_vertexClusterIndex, e5);
  }
  newEdge_(e5) {
    const t3 = this.m_edges.newElement(), s4 = this.m_edgeVertices.createList();
    return this.setEdgeOriginVertices_(t3, s4), -1 !== e5 && this.m_edgeVertices.addElement(s4, e5), t3;
  }
  addVertexToEdge_(e5, t3) {
    const s4 = this.getEdgeOriginVertices(e5);
    this.m_edgeVertices.addElement(s4, t3);
  }
  deleteEdge_(e5) {
    this.m_edges.deleteElement(e5);
    const t3 = this.m_edgesToInsertInSweepStructure.findIndex((t4) => t4 === e5);
    t3 >= 0 && St(this.m_edgesToInsertInSweepStructure, t3);
  }
  addEdgeToCluster(e5, t3) {
    -1 === this.getEdgeCluster(e5, 0) ? this.setEdgeCluster_(e5, 0, t3) : -1 === this.getEdgeCluster(e5, 1) ? this.setEdgeCluster_(e5, 1, t3) : b(""), this.addEdgeToClusterImpl_(e5, t3);
  }
  addEdgeToClusterImpl_(e5, t3) {
    const s4 = this.getClusterFirstEdge(t3);
    if (-1 !== s4) {
      const n6 = this.getNextEdge(s4, t3);
      this.setPrevEdge_(n6, t3, e5), this.setNextEdge_(e5, t3, n6), this.setNextEdge_(s4, t3, e5), this.setPrevEdge_(e5, t3, s4);
    } else this.setPrevEdge_(e5, t3, e5), this.setNextEdge_(e5, t3, e5), this.setClusterFirstEdge_(t3, e5);
  }
  getEdgeEnd(e5, t3) {
    return this.getEdgeCluster(e5, 0) === t3 ? 0 : 1;
  }
  mergeClusters_(e5, t3) {
    this.dbgCheckCluster_(e5), this.dbgCheckCluster_(t3);
    const s4 = this.getClusterEventQNode(t3);
    -1 !== s4 && (this.m_eventQ.deleteNode(s4), this.setClusterEventQNode_(t3, -1));
    let n6 = this.getClusterFirstEdge(e5), r = this.getClusterFirstEdge(t3);
    if (-1 !== r) {
      let s5 = r, i3 = r, o2 = false;
      do {
        this.dbgCheckEdge_(s5), o2 = false;
        const n7 = this.getEdgeEnd(s5, t3), a2 = this.getNextEdgeEx(s5, n7);
        if (this.getEdgeCluster(s5, n7 + 1 & 1) === e5) {
          this.disconnectEdge_(s5);
          const e6 = this.getEdgeOriginVertices(s5);
          if (this.m_edgeVertices.deleteList(e6), this.deleteEdge_(s5), s5 === a2) {
            r = -1;
            break;
          }
          r === s5 && (r = this.getClusterFirstEdge(t3), i3 = a2, o2 = true);
        }
        s5 = a2;
      } while (s5 !== i3 || o2);
      if (-1 !== r) {
        do {
          const n7 = this.getEdgeEnd(s5, t3), r2 = this.getNextEdgeEx(s5, n7);
          this.setEdgeCluster_(s5, n7, e5), s5 = r2;
        } while (s5 !== i3);
        if (n6 = this.getClusterFirstEdge(e5), -1 !== n6) {
          const t4 = this.getNextEdge(n6, e5), s6 = this.getNextEdge(r, e5);
          t4 === n6 ? (this.setClusterFirstEdge_(e5, r), this.addEdgeToClusterImpl_(n6, e5), this.setClusterFirstEdge_(e5, n6)) : s6 === r && this.addEdgeToClusterImpl_(r, e5), this.setNextEdge_(r, e5, t4), this.setPrevEdge_(t4, e5, r), this.setNextEdge_(n6, e5, s6), this.setPrevEdge_(s6, e5, n6);
        } else this.setClusterFirstEdge_(e5, r);
      }
    }
    const i2 = this.getClusterVertices(e5), o = this.getClusterVertices(t3);
    for (let a2 = this.m_clusterVertices.getFirst(o); -1 !== a2; a2 = this.m_clusterVertices.getNext(a2)) {
      const t4 = this.m_clusterVertices.getElement(a2);
      this.m_shape.setUserIndex(t4, this.m_vertexClusterIndex, e5);
    }
    this.m_clusterVertices.concatenateLists(i2, o), this.deleteCluster_(t3), this.dbgCheckCluster_(e5);
  }
  mergeEdges_(e5, t3) {
    this.dbgCheckEdge_(e5), this.dbgCheckEdge_(t3);
    const s4 = this.getEdgeCluster(e5, 0), n6 = this.getEdgeCluster(e5, 1), r = this.getEdgeCluster(t3, 0), i2 = this.getEdgeCluster(t3, 1), o = this.getEdgeOriginVertices(e5), a2 = this.getEdgeOriginVertices(t3);
    if (this.m_edgeVertices.concatenateLists(o, a2), t3 === this.getClusterFirstEdge(s4) && this.setClusterFirstEdge_(s4, e5), t3 === this.getClusterFirstEdge(n6) && this.setClusterFirstEdge_(n6, e5), this.disconnectEdge_(t3), this.deleteEdge_(t3), !(s4 === r && n6 === i2 || n6 === r && s4 === i2)) {
      const e6 = this.getClusterXY(s4), t4 = this.getClusterXY(r);
      e6.isEqualPoint2D(t4) ? (s4 !== r && this.mergeClusters_(s4, r), n6 !== i2 && this.mergeClusters_(n6, i2)) : (n6 !== r && this.mergeClusters_(n6, r), s4 !== i2 && this.mergeClusters_(s4, i2));
    }
    this.dbgCheckEdge_(e5);
  }
  disconnectEdge_(e5) {
    const t3 = this.getEdgeCluster(e5, 0), s4 = this.getEdgeCluster(e5, 1);
    this.disconnectEdgeFromCluster_(e5, t3), this.disconnectEdgeFromCluster_(e5, s4);
  }
  disconnectEdgeFromCluster_(e5, t3) {
    const s4 = this.getNextEdge(e5, t3), n6 = this.getPrevEdge(e5, t3), r = this.getClusterFirstEdge(t3);
    s4 !== e5 ? (this.setNextEdge_(n6, t3, s4), this.setPrevEdge_(s4, t3, n6), r === e5 && this.setClusterFirstEdge_(t3, s4)) : this.setClusterFirstEdge_(t3, -1);
  }
  applyIntersectorToEditShape_(e5, t3, s4) {
    let n6 = this.m_edgeVertices.getFirst(e5);
    const r = this.m_edgeVertices.getElement(n6), i2 = this.getClusterFromVertex(r), o = this.m_shape.getNextVertex(r), a2 = this.getClusterFromVertex(o), h2 = this.m_shape.getXY(r), m3 = this.m_shape.getXY(o);
    let l2 = false, g2 = false;
    const u = t3.getResultSegment(s4, 0).getStartXY(), c = t3.getResultSegment(s4, t3.getResultSegmentCount(s4) - 1).getEndXY();
    h2.equals(u) || (l2 = true), m3.equals(c) || (g2 = true), this.m_shape.splitSegmentWithIntersector(r, t3, s4, true, true);
    const _ = this.m_bTrackChanges && t3.getSegmentChanged(s4);
    for (_ && this.m_shape.setGeometryModifiedWithVertex(r, true), n6 = this.m_edgeVertices.getNext(n6); -1 !== n6; n6 = this.m_edgeVertices.getNext(n6)) {
      const e6 = this.m_edgeVertices.getElement(n6), r2 = this.getClusterFromVertex(e6) === i2;
      this.m_shape.splitSegmentWithIntersector(e6, t3, s4, r2, true), _ && this.m_shape.setGeometryModifiedWithVertex(e6, true);
    }
    if (l2 && this.updateClusterXY(true, i2, u, t3.getResultSegmentStartPointWeight(s4, 0), t3.getResultSegmentStartPointRank(s4, 0)), g2) {
      const e6 = t3.getResultSegmentCount(s4) - 1;
      this.updateClusterXY(true, a2, c, t3.getResultSegmentEndPointWeight(s4, e6), t3.getResultSegmentEndPointRank(s4, e6));
    }
  }
  createEdgesAndClustersFromSplitEdge_(e5, t3, s4) {
    this.dbgCheckNewEdgesArray_();
    const n6 = this.getEdgeOriginVertices(e5), r = this.getEdgeCluster(e5, 0), i2 = this.getEdgeCluster(e5, 1);
    let o = this.newEdge_(-1);
    this.m_edgesToInsertInSweepStructure.push(o);
    const a2 = at.impossibleIndex3();
    this.setEdgeSweepNode_(o, a2), this.m_tempEdgeBuffer.push(o), this.addEdgeToCluster(o, r);
    const h2 = t3.getResultSegmentCount(s4);
    for (let m3 = 1; m3 < h2; m3++) {
      const e6 = this.newCluster_(-1);
      this.m_modifiedClusters.push(e6), this.m_tempEdgeBuffer.push(e6), this.addEdgeToCluster(o, e6);
      const t4 = this.newEdge_(-1);
      this.m_edgesToInsertInSweepStructure.push(t4), this.setEdgeSweepNode_(t4, a2), this.m_tempEdgeBuffer.push(t4), this.addEdgeToCluster(t4, e6), o = t4;
    }
    this.addEdgeToCluster(o, i2);
    for (let m3 = this.m_edgeVertices.getFirst(n6); -1 !== m3; m3 = this.m_edgeVertices.getNext(m3)) {
      let e6 = this.m_edgeVertices.getElement(m3);
      if (this.getClusterFromVertex(e6) === r) {
        let t4 = 0;
        const s5 = this.m_tempEdgeBuffer.length;
        do {
          if (t4 > 0) {
            const s7 = this.m_tempEdgeBuffer[t4 - 1];
            this.addVertexToCluster_(s7, e6);
          }
          const s6 = this.m_tempEdgeBuffer[t4];
          t4 += 2, this.addVertexToEdge_(s6, e6), e6 = this.m_shape.getNextVertex(e6);
        } while (t4 < s5);
      } else {
        let t4 = this.m_tempEdgeBuffer.length - 1;
        do {
          if (t4 < this.m_tempEdgeBuffer.length - 2) {
            const s6 = this.m_tempEdgeBuffer[t4 + 1];
            this.addVertexToCluster_(s6, e6);
          }
          const s5 = this.m_tempEdgeBuffer[t4];
          t4 -= 2, this.addVertexToEdge_(s5, e6), e6 = this.m_shape.getNextVertex(e6);
        } while (t4 >= 0);
      }
    }
    this.m_tempEdgeBuffer.length = 0, this.dbgCheckNewEdgesArray_();
  }
  getVertexFromClusterIndex(e5) {
    const t3 = this.getClusterVertices(e5);
    return this.m_clusterVertices.getFirstElement(t3);
  }
  getClusterFromVertex(e5) {
    return this.m_shape.getUserIndex(e5, this.m_vertexClusterIndex);
  }
  processSplitHelper1_(e5, t3, s4) {
    const n6 = this.getEdgeCluster(t3, 0), r = this.getClusterXY(n6), i2 = this.getEdgeCluster(t3, 1), o = this.getClusterXY(i2), a2 = s4.getResultSegmentCount(e5);
    let h2 = s4.getResultSegment(e5, 0);
    const m3 = h2.getStartXY();
    if (!r.isEqualPoint2D(m3)) {
      if (!this.m_bComplications) {
        r.compare(this.m_sweepPoint) * m3.compare(this.m_sweepPoint) < 0 && (this.m_bComplications = true);
      }
      this.getAffectedEdges(n6, this.m_tempEdgeBuffer), this.m_modifiedClusters.push(n6);
    }
    if (!this.m_bComplications && a2 > 1) {
      const e6 = r.compare(o), t4 = h2.getEndXY();
      (r.compare(t4) !== e6 || t4.compare(o) !== e6 || t4.compare(this.m_sweepPoint) < 0) && (this.m_bComplications = true);
    }
    h2 = s4.getResultSegment(e5, a2 - 1);
    const l2 = h2.getEndXY();
    if (!o.isEqualPoint2D(l2)) {
      if (!this.m_bComplications) {
        o.compare(this.m_sweepPoint) * l2.compare(this.m_sweepPoint) < 0 && (this.m_bComplications = true);
      }
      this.getAffectedEdges(i2, this.m_tempEdgeBuffer), this.m_modifiedClusters.push(i2);
    }
    this.m_tempEdgeBuffer.push(t3);
    for (let g2 = 0, u = this.m_tempEdgeBuffer.length; g2 < u; g2++) {
      const e6 = this.m_tempEdgeBuffer[g2], s5 = this.getEdgeSweepNode(e6);
      at.isValidElement(s5) && (this.m_sweepStructure.deleteNode(s5), this.setEdgeSweepNode_(e6, -1));
      const n7 = at.impossibleIndex3();
      e6 !== t3 && this.getEdgeSweepNode(e6) !== n7 && (this.m_edgesToInsertInSweepStructure.push(e6), this.setEdgeSweepNode_(e6, n7));
    }
    this.m_tempEdgeBuffer.length = 0;
  }
  checkAndFixIntersection_(e5, t3) {
    const s4 = this.m_sweepStructure.getElement(e5);
    return this.m_sweepComparator.compare(this.m_sweepStructure, s4, t3), !!this.m_sweepComparator.intersectionDetected() && (this.m_sweepComparator.clearIntersectionDetectedFlag(), this.fixIntersection_(e5, t3), true);
  }
  fixIntersection_(e5, t3) {
    this.m_bCracked = true;
    const s4 = this.m_sweepStructure.getElement(e5), n6 = this.m_sweepStructure.getElement(t3);
    let r = null, i2 = null;
    const o = this.getEdgeOriginVertices(s4), a2 = this.m_edgeVertices.getFirstElement(o), h2 = this.getEdgeOriginVertices(n6), m3 = this.m_edgeVertices.getFirstElement(h2);
    this.m_shape.querySegment(a2, this.m_segBuf1, false, false), r = this.m_segBuf1.get();
    const l2 = this.m_shape.getNextVertex(a2), g2 = this.m_shape.getWeight(a2), u = this.m_shape.getSegmentParentageBreakVertex(a2), c = this.m_shape.getWeight(l2), _ = this.m_shape.getSegmentParentageBreakVertex(l2), d2 = this.m_shape.getSegmentWeight(a2), p3 = this.m_shape.getRank(a2), f3 = this.m_shape.getRank(l2), x4 = this.m_shape.getSegmentRank(a2), y2 = this.m_shape.getSegmentParentage(a2);
    this.m_shape.querySegment(m3, this.m_segBuf2, false, false), i2 = this.m_segBuf2.get();
    const P5 = this.m_shape.getNextVertex(m3), E2 = this.m_shape.getWeight(m3), S3 = this.m_shape.getSegmentParentageBreakVertex(m3), C3 = this.m_shape.getWeight(P5), I4 = this.m_shape.getSegmentParentageBreakVertex(P5), b2 = this.m_shape.getSegmentWeight(m3), w4 = this.m_shape.getRank(m3), v3 = this.m_shape.getRank(P5), N2 = this.m_shape.getSegmentRank(m3), T3 = this.m_shape.getSegmentParentage(m3);
    this.m_segmentIntersector.pushSegment(r, g2, p3, c, f3, d2, x4, u, _, y2), this.m_segmentIntersector.pushSegment(i2, E2, w4, C3, v3, b2, N2, S3, I4, T3), 3 === this.m_segmentIntersector.intersect2D(this.m_tolerance, true) && (this.m_bComplications = true), this.splitEdge_(s4, n6, -1, this.m_segmentIntersector), this.m_segmentIntersector.clear();
  }
  fixIntersectionPointSegment_(e5, t3) {
    this.m_bCracked = true;
    const s4 = this.m_sweepStructure.getElement(t3);
    let n6 = null;
    const r = this.getEdgeOriginVertices(s4), i2 = this.m_edgeVertices.getFirstElement(r);
    this.m_shape.querySegment(i2, this.m_segBuf1, false, false), n6 = this.m_segBuf1.get();
    const o = this.m_shape.getNextVertex(i2), a2 = this.m_shape.getWeight(i2), h2 = this.m_shape.getSegmentParentageBreakVertex(i2), m3 = this.m_shape.getWeight(o), l2 = this.m_shape.getSegmentParentageBreakVertex(o), g2 = this.m_shape.getSegmentWeight(i2), u = this.m_shape.getRank(i2), c = this.m_shape.getRank(o), _ = this.m_shape.getSegmentRank(i2), d2 = this.m_shape.getSegmentParentage(i2), p3 = this.getClusterFirstVertex(e5);
    this.m_segmentIntersector.pushSegment(n6, a2, u, m3, c, g2, _, h2, l2, d2), this.m_shape.queryPoint(p3, this.m_helperPoint);
    const f3 = this.m_shape.getWeight(p3), x4 = this.m_shape.getRank(p3);
    this.m_segmentIntersector.intersect2DEx(this.m_tolerance, this.m_helperPoint, x4, f3, true), this.splitEdge_(s4, -1, e5, this.m_segmentIntersector), this.m_segmentIntersector.clear();
  }
  insertNewEdges_() {
    if (0 === this.m_edgesToInsertInSweepStructure.length) return true;
    this.dbgCheckNewEdgesArray_();
    let e5 = true, t3 = 0;
    const s4 = this.m_edgesToInsertInSweepStructure.length, n6 = Math.max(2 * s4 + 200, this.m_sweepStructure.size() + 200);
    for (; this.m_edgesToInsertInSweepStructure.length; ) {
      if (this.m_edgesToInsertInSweepStructure.length > Math.max(100, this.m_shape.getTotalPointCount()) || t3 > n6) {
        this.m_edgesToInsertInSweepStructure.length = 0, this.m_bComplications = true, e5 = false;
        break;
      }
      const s5 = this.m_edgesToInsertInSweepStructure.at(-1);
      this.m_edgesToInsertInSweepStructure.pop(), this.setEdgeSweepNode_(s5, -1);
      const r = this.isEdgeOnSweepLine_(s5);
      at.isValidElement(r) ? (this.insertNewEdgeToSweepStructure_(s5, r), t3++) : r !== at.impossibleIndex2() && (e5 = false), this.m_bContinuingSegmentChainOptimization = false;
    }
    return e5;
  }
  insertNewEdgeToSweepStructure_(e5, t3) {
    let s4;
    if (this.m_bContinuingSegmentChainOptimization ? (s4 = this.m_sweepStructure.addElementAtPosition(this.m_prevNeighbour, this.m_nextNeighbour, e5, true, true), this.m_bContinuingSegmentChainOptimization = false) : s4 = this.m_sweepStructure.addUniqueElement(e5), -1 === s4) {
      const t4 = this.m_sweepStructure.getDuplicateElement(), s5 = this.m_sweepStructure.getElement(t4);
      return this.mergeEdges_(s5, e5), false;
    }
    if (this.setEdgeSweepNode_(e5, s4), this.m_sweepComparator.intersectionDetected()) {
      this.m_sweepComparator.clearIntersectionDetectedFlag();
      const e6 = this.m_sweepComparator.getLastComparedNode();
      return this.m_prevNeighbour === e6 && (this.m_prevNeighbour = -1), this.m_nextNeighbour === e6 && (this.m_nextNeighbour = -1), this.fixIntersection_(e6, s4), true;
    }
    return false;
  }
  isEdgeOnSweepLine_(e5) {
    const t3 = this.getEdgeCluster(e5, 0), s4 = this.getEdgeCluster(e5, 1), n6 = this.getClusterXY(t3), r = this.getClusterXY(s4);
    if (mi.sqrDistance(n6, r) <= this.m_toleranceSqr) return this.m_bComplications = true, -1;
    const i2 = n6.compare(this.m_sweepPoint), o = r.compare(this.m_sweepPoint);
    return i2 <= 0 && o > 0 ? s4 : o <= 0 && i2 > 0 ? t3 : i2 > 0 && o > 0 ? at.impossibleIndex2() : -1;
  }
  fillEventQueue() {
    const e5 = new st2(0), t3 = this.m_shape.queryVertexIteratorOnSelection();
    for (let r = t3.next(); r !== cr; r = t3.next()) -1 !== this.m_shape.getUserIndex(r, this.m_vertexClusterIndex) && e5.add(r);
    this.m_shape.sortVerticesSimpleByY(e5, 0, e5.size()), this.progress_(true), this.m_eventQ.clear(), this.m_eventQ.setCapacity(e5.size()), this.m_eventQ.setComparator(new Tn2(this.m_shape));
    const s4 = mi.getNAN();
    s4.setNAN();
    let n6 = -1;
    for (let r = 0, i2 = e5.size(); r < i2; r++) {
      const t4 = e5.read(r);
      if (this.m_shape.getXY(t4).isEqualPoint2D(s4)) {
        const e6 = this.m_shape.getUserIndex(t4, this.m_vertexClusterIndex);
        this.mergeClusters_(n6, e6);
        continue;
      }
      n6 = this.getClusterFromVertex(t4), this.m_shape.queryXY(t4, s4);
      const i3 = this.m_eventQ.addBiggestElement(t4);
      this.setClusterEventQNode_(n6, i3);
    }
  }
  fillEventQueuePass2() {
    const e5 = new st2(0);
    for (let t3 = this.m_eventQ.getFirst(); -1 !== t3; t3 = this.m_eventQ.getNext(t3)) {
      const s4 = this.m_eventQ.getElement(t3);
      e5.add(s4);
    }
    this.m_eventQ.clear(), this.m_shape.sortVerticesSimpleByY(e5, 0, e5.size()), this.progress_(true);
    for (let t3 = 0, s4 = e5.size(); t3 < s4; t3++) {
      const s5 = e5.read(t3), n6 = this.getClusterFromVertex(s5), r = this.m_eventQ.addBiggestElement(s5);
      this.setClusterEventQNode_(n6, r);
    }
  }
  getAffectedEdges(e5, t3) {
    const s4 = this.getClusterFirstEdge(e5);
    if (-1 === s4) return;
    let n6 = s4;
    do {
      const s5 = this.getEdgeSweepNode(n6);
      at.isValidElement(s5) && t3.push(n6), n6 = this.getNextEdge(n6, e5);
    } while (n6 !== s4);
  }
  updateClusterXY(e5, t3, s4, n6, r) {
    const i2 = this.getClusterVertices(t3);
    for (let o = this.m_clusterVertices.getFirst(i2); -1 !== o; o = this.m_clusterVertices.getNext(o)) {
      const t4 = this.m_clusterVertices.getElement(o);
      this.m_shape.setXYMonotonicPoint2D(t4, s4), this.m_shape.setWeight(t4, n6), this.m_shape.setRank(t4, r), e5 && this.m_bTrackChanges && this.m_shape.setGeometryModifiedWithVertex(t4, true), this.m_shape.setSegmentParentageBreakVertex(t4, true);
    }
  }
  splitEdge_(e5, t3, s4, n6) {
    this.dbgCheckEdge_(e5), -1 !== t3 && this.dbgCheckEdge_(t3), this.disconnectEdge_(e5), -1 !== t3 && this.disconnectEdge_(t3), this.processSplitHelper1_(0, e5, n6), -1 !== t3 && this.processSplitHelper1_(1, t3, n6), -1 !== s4 && n6.getResultPointChanged() && this.m_modifiedClusters.push(s4);
    for (let o = 0, a2 = this.m_modifiedClusters.length; o < a2; o++) {
      const e6 = this.m_modifiedClusters[o], t4 = this.getClusterEventQNode(e6);
      -1 !== t4 && (this.m_eventQ.deleteNode(t4), this.setClusterEventQNode_(e6, -1));
    }
    const r = this.getEdgeOriginVertices(e5), i2 = -1 !== t3 ? this.getEdgeOriginVertices(t3) : -1;
    if (this.applyIntersectorToEditShape_(r, n6, 0), -1 !== i2) this.applyIntersectorToEditShape_(i2, n6, 1);
    else {
      const e6 = n6.getResultPoint().getXY();
      this.updateClusterXY(n6.getResultPointChanged(), s4, e6, n6.getResultPointWeight(), n6.getResultPointRank());
    }
    this.createEdgesAndClustersFromSplitEdge_(e5, n6, 0), -1 !== t3 && this.createEdgesAndClustersFromSplitEdge_(t3, n6, 1), this.m_edgeVertices.deleteList(r), this.deleteEdge_(e5), -1 !== t3 && (this.m_edgeVertices.deleteList(i2), this.deleteEdge_(t3));
    for (let o = 0, a2 = this.m_modifiedClusters.length; o < a2; o++) {
      const e6 = this.m_modifiedClusters[o];
      e6 === this.m_sweepPointCluster && (this.m_bSweepPointClusterWasModified = true);
      let t4 = this.getClusterEventQNode(e6);
      if (-1 === t4) {
        const s5 = this.getClusterFirstVertex(e6);
        if (t4 = this.m_eventQ.addUniqueElement(s5), -1 === t4) {
          const t5 = this.m_eventQ.getDuplicateElement(), s6 = this.m_eventQ.getElement(t5), n7 = this.getClusterFromVertex(s6);
          this.mergeClusters_(n7, e6);
        } else this.setClusterEventQNode_(e6, t4);
      }
    }
    this.m_modifiedClusters.length = 0;
  }
  getClusterXY(e5) {
    const t3 = this.getClusterFirstVertex(e5);
    return this.m_shape.getXY(t3);
  }
  getClusterFirstVertex(e5) {
    const t3 = this.getClusterVertices(e5);
    return this.m_clusterVertices.getFirstElement(t3);
  }
  dbgCheckEdge_(e5) {
  }
  dbgCheckCluster_(e5) {
  }
  dbgCheckNewEdgesArray_() {
  }
  dbgSaveSweepStructure_(e5) {
  }
  sweepImpl_() {
    this.progress_(true), this.m_bSweepPointClusterWasModified = false, this.m_sweepPointCluster = -1, null === this.m_sweepComparator && (this.m_sweepStructure.disableBalancing(), this.m_sweepComparator = new vn2(this), this.m_sweepStructure.setComparator(this.m_sweepComparator));
    const e5 = [];
    let t3 = null, s4 = null;
    this.m_prevNeighbour = -1, this.m_nextNeighbour = -1, this.m_bContinuingSegmentChainOptimization = false;
    const n6 = at.impossibleIndex2(), r = at.impossibleIndex3();
    for (let i2 = this.m_eventQ.getFirst(); -1 !== i2; ) {
      this.progress_(), this.dbgCheckSweepStructure_(), this.m_bContinuingSegmentChainOptimization = false, this.m_prevNeighbour = -1, this.m_nextNeighbour = -1;
      const o = this.m_eventQ.getElement(i2);
      this.m_sweepPointCluster = this.getClusterFromVertex(o), this.m_shape.queryXY(o, this.m_sweepPoint), this.m_sweepComparator.setSweepY(this.m_sweepPoint.y, this.m_sweepPoint.x);
      let a2 = false;
      {
        const t4 = this.getClusterFirstEdge(this.m_sweepPointCluster);
        if (a2 = -1 === t4, !a2) {
          let s5 = t4;
          do {
            const t5 = this.getEdgeSweepNode(s5);
            -1 === t5 ? (this.m_edgesToInsertInSweepStructure.push(s5), this.setEdgeSweepNode_(s5, r)) : t5 !== r && e5.push(t5), s5 = this.getNextEdge(s5, this.m_sweepPointCluster);
          } while (s5 !== t4);
        }
      }
      if (!this.m_sweepStructure.isAutoBalancing() && (this.m_sweepStructure.getMaxDepthEver() > 4 || this.m_edgesToInsertInSweepStructure.length > 10) && this.m_sweepStructure.enableBalancing(), e5.length > 0) {
        this.m_bContinuingSegmentChainOptimization = 1 === e5.length && 1 === this.m_edgesToInsertInSweepStructure.length;
        for (let r2 = 0, i3 = e5.length; r2 < i3; r2++) {
          const t5 = this.m_sweepStructure.getElement(e5[r2]);
          this.setEdgeSweepNode_(t5, n6);
        }
        let t4 = n6, s5 = n6;
        for (let r2 = 0, i3 = e5.length; r2 < i3; r2++) {
          const i4 = e5[r2];
          if (t4 === n6) {
            const e6 = this.m_sweepStructure.getPrev(i4);
            if (-1 !== e6) {
              const s6 = this.m_sweepStructure.getElement(e6);
              this.getEdgeSweepNode(s6) !== n6 && (t4 = e6);
            } else t4 = -1;
          }
          if (s5 === n6) {
            const e6 = this.m_sweepStructure.getNext(i4);
            if (-1 !== e6) {
              const t5 = this.m_sweepStructure.getElement(e6);
              this.getEdgeSweepNode(t5) !== n6 && (s5 = e6);
            } else s5 = -1;
          }
          if (t4 !== n6 && s5 !== n6) break;
        }
        for (let n7 = 0, r2 = e5.length; n7 < r2; n7++) {
          const t5 = e5[n7], s6 = this.m_sweepStructure.getElement(t5);
          this.m_sweepStructure.deleteNode(t5), this.setEdgeSweepNode_(s6, -1);
        }
        e5.length = 0, this.m_prevNeighbour = t4, this.m_nextNeighbour = s5, -1 !== t4 && -1 !== s5 ? this.m_bContinuingSegmentChainOptimization || this.checkAndFixIntersection_(t4, s5) : -1 === t4 && -1 === s5 && (this.m_bContinuingSegmentChainOptimization = false);
      } else a2 && (null === t3 && (t3 = new Nn2(this)), t3.setPoint(this.m_sweepPoint), this.m_sweepStructure.searchUpperBound(t3), t3.intersectionDetected() && (t3.clearIntersectionDetectedFlag(), this.fixIntersectionPointSegment_(this.m_sweepPointCluster, t3.getCurrentNode())));
      const h2 = this.m_bContinuingSegmentChainOptimization;
      !this.insertNewEdges_() && h2 && -1 !== this.m_prevNeighbour && -1 !== this.m_nextNeighbour && this.checkAndFixIntersection_(this.m_prevNeighbour, this.m_nextNeighbour), this.m_bSweepPointClusterWasModified ? (this.m_bSweepPointClusterWasModified = false, null === s4 && (s4 = new Gn2(this.m_shape)), s4.setPoint(this.m_sweepPoint), i2 = this.m_eventQ.searchUpperBound(s4)) : i2 = this.m_eventQ.getNext(i2);
    }
    return this.m_bCracked;
  }
  setEditShape_(e5) {
    this.m_shape = e5, this.m_vertexClusterIndex = this.m_shape.createUserIndex(), this.m_edges.setCapacity(e5.getSelectedCount() + 32), this.m_clusters.setCapacity(e5.getSelectedCount()), this.m_clusterVertices.reserveLists(e5.getSelectedCount()), this.m_clusterVertices.reserveNodes(e5.getSelectedCount()), this.m_edgeVertices.reserveLists(e5.getSelectedCount() + 32), this.m_edgeVertices.reserveNodes(e5.getSelectedCount() + 32);
    for (let t3 = this.m_shape.getFirstGeometry(); t3 !== cr; t3 = this.m_shape.getNextGeometry(t3)) {
      if (h(this.m_shape.getGeometryType(t3))) for (let s4 = this.m_shape.getFirstPath(t3); s4 !== cr; s4 = this.m_shape.getNextPath(s4)) {
        const t4 = this.m_shape.getPathSize(s4), n6 = this.m_shape.getFirstVertex(s4);
        if (n6 === cr) continue;
        let r = this.m_shape.getNextVertex(n6);
        if (r === cr || r === n6) continue;
        let i2 = -1;
        e5.selected(n6) && (i2 = this.newCluster_(n6));
        let o = -1;
        -1 !== i2 && e5.selected(r) && (o = this.newEdge_(n6), this.addEdgeToCluster(o, i2));
        let a2 = o;
        for (let e6 = 0, s5 = t4 - 2; e6 < s5; e6++) {
          const e7 = this.m_shape.getNextVertex(r);
          let t5 = -1;
          if (this.m_shape.selected(r)) {
            const s6 = this.newCluster_(r);
            -1 !== a2 && this.addEdgeToCluster(a2, s6), this.m_shape.selected(e7) && (t5 = this.newEdge_(r), this.addEdgeToCluster(t5, s6));
          }
          a2 = t5, r = e7;
        }
        if (this.m_shape.isClosedPath(s4)) {
          const e6 = this.m_shape.getNextVertex(r);
          if (this.m_shape.selected(r)) {
            const t5 = this.newCluster_(r);
            if (-1 !== a2 && this.addEdgeToCluster(a2, t5), this.m_shape.selected(e6)) {
              const e7 = this.newEdge_(r);
              this.addEdgeToCluster(e7, t5), this.addEdgeToCluster(e7, i2);
            }
          }
        } else {
          let e6 = -1;
          this.m_shape.selected(r) && (e6 = this.newCluster_(r), -1 !== a2 && this.addEdgeToCluster(a2, e6));
        }
      }
      else for (let e6 = this.m_shape.getFirstPath(t3); e6 !== cr; e6 = this.m_shape.getNextPath(e6)) {
        let t4 = this.m_shape.getFirstVertex(e6);
        for (let s4 = 0, n6 = this.m_shape.getPathSize(e6); s4 < n6; s4++) this.m_shape.selected(t4) && this.newCluster_(t4), t4 = this.m_shape.getNextVertex(t4);
      }
    }
    this.fillEventQueue();
  }
  progress_(e5 = false) {
  }
  dbgCheckSweepStructure_() {
  }
};
function Vn2(e5, t3, s4, n6) {
  s4 > 0 && mn2(e5, s4, t3, false, n6);
  new Hn2(n6).executeImpl_(e5, t3);
}
function Fn2(e5, t3, s4) {
  return { vertex0: e5, vertex1: t3, dir: s4 };
}
var Hn2 = class {
  constructor(e5) {
    this.m_shape = null, this.m_spikes = [], this.m_points = new st2(0), this.m_pointsIndex = -1, this.m_dissolvedEdges = 0, this.m_progressTracker = e5;
  }
  executeImpl_(e5, t3) {
    if (this.m_shape = e5, e5.getPathCount(t3) < 2 && e5.getPointCount(t3) < 6) return;
    this.m_points.resize(0);
    for (let a2 = e5.getFirstPath(t3); a2 !== cr; a2 = e5.getNextPath(a2)) {
      let t4 = e5.getFirstVertex(a2);
      for (let s5 = 0, n7 = e5.getPathSize(a2); s5 < n7; s5++, t4 = e5.getNextVertex(t4)) this.m_points.add(t4);
    }
    this.m_pointsIndex = e5.createUserIndex();
    for (let a2 = 0, g2 = this.m_points.size(); a2 < g2; ++a2) e5.setUserIndex(this.m_points.read(a2), this.m_pointsIndex, a2);
    e5.sortVerticesSimpleByY(this.m_points, 0, this.m_points.size());
    let s4 = this.m_points.read(0);
    const n6 = e5.getXY(s4);
    let r = 1, i2 = 0;
    const o = [];
    for (let a2 = 1; a2 < this.m_points.size(); a2++) {
      const t4 = this.m_points.read(a2);
      if (t4 === cr) continue;
      if (-1 === e5.getUserIndex(t4, this.m_pointsIndex)) continue;
      const h3 = e5.getXY(t4);
      if (h3.isEqualPoint2D(n6)) r++;
      else {
        if (r > 1) {
          for (let t5 = i2; t5 < a2; t5++) {
            const s5 = this.m_points.read(t5);
            if (-1 === e5.getUserIndex(s5, this.m_pointsIndex)) continue;
            const r2 = e5.getNextVertex(s5), i3 = e5.getPrevVertex(s5);
            if (s5 !== r2 && !e5.isEqualXYPoint2D(r2, n6)) {
              const e6 = Fn2(s5, r2, 1);
              o.push(e6);
            }
            if (s5 !== i3 && i3 !== r2 && !e5.isEqualXYPoint2D(i3, n6)) {
              const e6 = Fn2(s5, i3, -1);
              o.push(e6);
            }
          }
          o.length > 0 && this.processBunch_(o, n6);
        }
        s4 = t4, n6.assign(h3), r = 1, i2 = a2;
      }
    }
    if (0 === this.m_dissolvedEdges) return e5.removeUserIndex(this.m_pointsIndex), void (this.m_pointsIndex = -1);
    let h2 = e5.getPointCount(t3);
    for (let a2 = 0; a2 < this.m_points.size(); a2++) {
      const t4 = this.m_points.read(a2);
      if (t4 === cr) continue;
      if (-1 !== e5.getUserIndex(t4, this.m_pointsIndex)) {
        e5.setUserIndex(t4, this.m_pointsIndex, -1);
        continue;
      }
      const s5 = e5.getPathFromVertex(t4);
      e5.getFirstVertex(s5) === t4 && e5.setFirstVertex(s5, cr), e5.freeVertex(t4), this.m_points.write(a2, cr), h2--;
    }
    const m3 = e5.createPathUserIndex();
    let l2 = e5.getPathCount(t3);
    for (let g2 = 0, u = this.m_points.size(); g2 < u; ++g2) {
      if (this.m_points.read(g2) === cr) continue;
      let s5 = this.m_points.read(g2);
      if (-1 !== e5.getUserIndex(s5, this.m_pointsIndex)) continue;
      let n7 = e5.getPathFromVertex(s5), r2 = -1;
      if (2 === e5.getPathUserIndex(n7, m3)) {
        n7 = cr;
        for (let t4 = e5.getNextVertex(s5); t4 !== s5; t4 = e5.getNextVertex(t4)) {
          const r3 = e5.getPathFromVertex(t4);
          if (2 !== e5.getPathUserIndex(r3, m3)) {
            n7 = r3, s5 = t4;
            break;
          }
        }
        n7 === cr && (n7 = e5.insertPath(t3, cr), e5.setClosedPath(n7, true), l2++), n2(n7 !== cr);
      }
      e5.setPathUserIndex(n7, m3, 2), r2 = e5.getFirstVertex(n7);
      let i3 = 0, o2 = false, h3 = s5;
      do {
        r2 === h3 && (o2 = true), e5.setUserIndex(h3, this.m_pointsIndex, 1);
        const t4 = e5.getPathFromVertex(h3);
        t4 !== n7 && (2 !== e5.getPathUserIndex(t4, m3) && (e5.setPathUserIndex(t4, m3, 1), e5.setFirstVertex(t4, cr)), e5.setPathToVertex(h3, n7)), i3++, h3 = e5.getNextVertex(h3);
      } while (h3 !== s5);
      o2 || e5.setFirstVertex(n7, s5), e5.setPathSize(n7, i3);
    }
    for (let a2 = e5.getFirstPath(t3); a2 !== cr; ) {
      const t4 = e5.getNextPath(a2);
      1 !== e5.getPathUserIndex(a2, m3) && e5.getFirstVertex(a2) !== cr || (e5.removePathOnly(a2), l2--), a2 = t4;
    }
    e5.setGeometryVertexCount(t3, h2), e5.setGeometryPathCount(t3, l2), e5.removePathUserIndex(m3), e5.removeUserIndex(this.m_pointsIndex), this.m_pointsIndex = -1, e5.dbgVerifyVertexCounts(), e5.filterClosePoints(0, true, false, false, t3);
  }
  processBunch_(e5, t3) {
    e5.sort((e6, s5) => {
      const n7 = this.m_shape.getXY(e6.vertex1).sub(t3), r2 = this.m_shape.getXY(s5.vertex1).sub(t3), i3 = mi.compareVectors(n7, r2);
      return 0 === i3 ? e6.dir < s5.dir ? -1 : 1 : i3;
    });
    let s4 = 0;
    const n6 = this.m_shape.getXY(e5[0].vertex1);
    let r = 1;
    const i2 = this.m_shape.hasCurves();
    for (let o = 1, a2 = e5.length; o < a2; o++) {
      const t4 = this.m_shape.getXY(e5[o].vertex1);
      if (!(t4.isEqualPoint2D(n6) && (r++, o + 1 < a2))) {
        if (2 === r) {
          const t5 = e5[s4], n7 = e5[s4 + 1], r2 = t5.dir;
          if (r2 !== n7.dir) {
            let e6 = true;
            if (i2 && (e6 = !this.m_shape.isCurve(1 === t5.dir ? t5.vertex0 : t5.vertex1) && !this.m_shape.isCurve(1 === n7.dir ? n7.vertex0 : n7.vertex1)), e6) {
              if (1 === r2) {
                const e7 = t5.vertex0, s5 = n7.vertex0;
                this.m_shape.setNextVertex(e7, s5), this.m_shape.setPrevVertex(s5, e7), this.m_shape.getPrevVertex(e7) === s5 && (this.m_shape.setUserIndex(e7, this.m_pointsIndex, -1), this.m_shape.setUserIndex(s5, this.m_pointsIndex, -1));
                const r3 = t5.vertex1, i3 = n7.vertex1;
                this.m_shape.setPrevVertex(r3, i3), this.m_shape.setNextVertex(i3, r3), this.m_shape.getNextVertex(r3) === i3 && (this.m_shape.setUserIndex(r3, this.m_pointsIndex, -1), this.m_shape.setUserIndex(i3, this.m_pointsIndex, -1));
              } else {
                const e7 = t5.vertex0, s5 = n7.vertex0;
                this.m_shape.setPrevVertex(e7, s5), this.m_shape.setNextVertex(s5, e7), this.m_shape.getNextVertex(e7) === s5 && (this.m_shape.setUserIndex(e7, this.m_pointsIndex, -1), this.m_shape.setUserIndex(s5, this.m_pointsIndex, -1));
                const r3 = t5.vertex1, i3 = n7.vertex1;
                this.m_shape.setNextVertex(r3, i3), this.m_shape.setPrevVertex(i3, r3), this.m_shape.getPrevVertex(r3) === i3 && (this.m_shape.setUserIndex(r3, this.m_pointsIndex, -1), this.m_shape.setUserIndex(i3, this.m_pointsIndex, -1));
              }
              this.m_dissolvedEdges += 2;
            }
          }
        }
        n6.assign(t4), s4 = o, r = 1;
      }
    }
    e5.length = 0;
  }
};
function kn2(e5) {
  for (let t3 = e5.getFirstGeometry(); t3 !== cr; t3 = e5.getNextGeometry(t3)) if (h(e5.getGeometryType(t3))) return true;
  return false;
}
function An2(e5, t3, s4, n6) {
  if (!kn2(e5)) return false;
  const r = new Bn2(n6);
  r.m_shape = e5, r.m_tolerance = t3, r.m_bTrackChanges = s4;
  let i2 = false;
  const o = e5.hasCurves() ? 5 : 15;
  return i2 = e5.getTotalPointCount() < o ? r.crackBruteForce_() : r.crackerPlaneSweep_(), i2;
}
function Mn2(e5, t3, s4, n6, r) {
  if (!kn2(t3)) return false;
  let i2 = new Bn2(r);
  if (i2.m_shape = t3, i2.m_tolerance = s4, i2.m_bAllowCoincident = e5, i2.m_bNeedsNonSimpleResult = null !== n6, i2.needsCrackingImpl_()) return n6 && n6.assign(i2.m_nonSimpleResult), true;
  const o = new x3();
  o.setSwapCoordinates(), t3.applyTransformation(o), i2 = new Bn2(r), i2.m_shape = t3, i2.m_tolerance = s4, i2.m_bAllowCoincident = e5, i2.m_bNeedsNonSimpleResult = null !== n6;
  const a2 = i2.needsCrackingImpl_();
  return t3.applyTransformation(o), !!a2 && (n6 && n6.assign(i2.m_nonSimpleResult), true);
}
function Un2(e5, t3, s4, n6) {
  const r = t3.getGeometryType();
  if (h(r)) {
    return new Bn2(n6).crackAWithBMultiPath_(e5, t3, s4);
  }
  z("crack_A_with_B");
}
function qn2(e5, t3) {
  return { t: e5, index: t3 };
}
var Bn2 = class _Bn {
  crackBruteForce_() {
    let e5 = this.crackBruteForceImpl_();
    if (!e5 && this.m_shape.hasCurves()) {
      const t3 = new x3();
      t3.setSwapCoordinates(), this.m_shape.applyTransformation(t3), e5 = this.crackBruteForceImpl_(), this.m_shape.applyTransformation(t3);
    }
    return e5;
  }
  crackBruteForceImpl_() {
    let t3 = false;
    const s4 = new fm(), n6 = new fm(), r = n4.constructEmpty(), i2 = n4.constructEmpty(), o = false, h2 = new ee(), m3 = new xn2(), l2 = this.m_shape.getTotalPointCount(), g2 = l2 * l2 * 2, u = this.m_shape.queryVertexIteratorOnSelection();
    for (let e5 = u.next(); e5 !== cr; e5 = u.next()) {
      const l3 = this.m_shape.getGeometryType(u.currentGeometry());
      let c = 1, _ = 1, d2 = 1, f3 = 0, x4 = 0, y2 = 0;
      const P5 = this.m_shape.getSegmentParentage(e5);
      let E2 = false, S3 = false, C3 = null, I4 = false;
      if (l(l3)) c = this.m_shape.getWeight(e5), f3 = this.m_shape.getRank(e5);
      else {
        if (C3 = this.getSegment_(e5, s4), null === C3) continue;
        const t4 = this.m_shape.getVertexIndex(e5);
        c = this.m_shape.getWeightWithIndex(t4), f3 = this.m_shape.getRankWithIndex(t4), d2 = this.m_shape.getSegmentWeightWithIndex(t4), y2 = this.m_shape.getSegmentRankWithIndex(t4), E2 = this.m_shape.getSegmentParentageBreakVertex(e5);
        {
          const t5 = this.m_shape.getNextVertex(e5);
          _ = this.m_shape.getWeight(t5), x4 = this.m_shape.getRank(t5), S3 = this.m_shape.getSegmentParentageBreakVertex(t5);
        }
        if (C3.queryLooseEnvelope(r), r.inflateCoords(this.m_tolerance, this.m_tolerance), C3.isDegenerate(this.m_tolerance)) {
          if (!C3.isDegenerate(0)) continue;
          I4 = true, C3 = null;
        }
      }
      const b2 = new pr({ copy: u });
      let w4 = b2.next();
      w4 !== cr && (w4 = b2.next());
      let v3 = 0;
      for (; w4 !== cr; w4 = b2.next()) {
        if (0 !== v3) {
          v3--;
          continue;
        }
        if (this.m_shape.getTotalPointCount() > g2) return t3;
        this.progress_();
        const l4 = this.m_shape.getGeometryType(b2.currentGeometry());
        let N2 = null, T3 = false, G4 = 0, D3 = 0, V4 = 0, F3 = 0, H3 = 0, k4 = 0, A4 = false, U4 = false;
        const q2 = this.m_shape.getSegmentParentage(w4);
        if (l(l4)) G4 = this.m_shape.getWeight(w4), F3 = this.m_shape.getRank(w4);
        else {
          if (N2 = this.getSegment_(w4, n6), null === N2) continue;
          const e6 = this.m_shape.getVertexIndex(w4);
          G4 = this.m_shape.getWeightWithIndex(e6), F3 = this.m_shape.getRankWithIndex(e6), V4 = this.m_shape.getSegmentWeightWithIndex(e6), k4 = this.m_shape.getSegmentRankWithIndex(e6), A4 = this.m_shape.getSegmentParentageBreakVertex(w4);
          {
            const e7 = this.m_shape.getNextVertex(w4);
            D3 = this.m_shape.getWeight(e7), H3 = this.m_shape.getRank(e7), U4 = this.m_shape.getSegmentParentageBreakVertex(e7);
          }
          if (N2.queryLooseEnvelope(i2), N2.isDegenerate(this.m_tolerance)) {
            if (!N2.isDegenerate(0)) continue;
            T3 = true, N2 = null;
          }
        }
        let B4 = 0, O3 = 0;
        if (null !== C3 && null !== N2) {
          if (r.isIntersectingNe(i2)) {
            0 !== om(true, true, C3, N2, this.m_tolerance, true) && (m3.pushSegment(C3, c, f3, _, x4, d2, y2, E2, S3, P5), m3.pushSegment(N2, G4, F3, D3, H3, V4, k4, A4, U4, q2), m3.intersect2D(this.m_tolerance, true), t3 ||= m3.getSegmentChanged(0) || m3.getSegmentChanged(1), B4 = m3.getResultSegmentCount(0), O3 = m3.getResultSegmentCount(1), B4 + O3 > 0 && (this.m_shape.splitSegmentWithIntersector(e5, m3, 0, true, true), this.m_shape.splitSegmentWithIntersector(w4, m3, 1, true, true), this.m_bTrackChanges && (m3.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(e5, true), m3.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(w4, true))), O3 > 1 && (v3 += O3 - 1), m3.clear());
          }
        } else if (null !== C3) {
          const s5 = this.m_shape.getXY(w4);
          if (r.contains(s5)) {
            if (m3.pushSegment(C3, c, f3, _, x4, d2, y2, E2, S3, P5), this.m_shape.queryPoint(w4, h2), m3.intersect2DEx(this.m_tolerance, h2, F3, G4, o), t3 ||= m3.getSegmentChanged(0) || m3.getResultPointChanged(), B4 = m3.getResultSegmentCount(0), B4 > 0) if (this.m_bTrackChanges && (m3.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(e5, true), m3.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(w4, true)), this.m_shape.splitSegmentWithIntersector(e5, m3, 0, true, true), T3) {
              let e6 = cr;
              for (let t4 = this.m_shape.getNextVertex(w4); t4 !== cr && t4 !== w4 && (N2 = this.getSegment_(t4, n6), e6 = t4, null != N2 && N2.isDegenerate(0)); t4 = this.m_shape.getNextVertex(t4)) ;
              for (let t4 = w4; t4 !== cr && (this.m_shape.setPoint(t4, m3.getResultPoint(), true), t4 !== e6); t4 = this.m_shape.getNextVertex(t4)) ;
            } else this.m_shape.setPoint(w4, m3.getResultPoint(), true);
            m3.clear();
          }
        } else {
          if (null === N2) continue;
          {
            const s5 = this.m_shape.getXY(e5);
            if (i2.inflateCoords(this.m_tolerance, this.m_tolerance), i2.contains(s5)) {
              if (m3.pushSegment(N2, G4, F3, D3, H3, V4, k4, A4, U4, q2), this.m_shape.queryPoint(e5, h2), m3.intersect2DEx(this.m_tolerance, h2, f3, c, o), t3 ||= m3.getSegmentChanged(0) || m3.getResultPointChanged(), O3 = m3.getResultSegmentCount(0), O3 > 0) if (this.m_bTrackChanges && (m3.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(w4, true), m3.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(e5, true)), this.m_shape.splitSegmentWithIntersector(w4, m3, 0, true, true), v3 += O3 - 1, I4) {
                let t4 = cr;
                for (let s6 = this.m_shape.getNextVertex(e5); s6 !== cr && s6 !== e5 && (N2 = this.getSegment_(s6, n6), t4 = s6, null != N2 && N2.isDegenerate(0)); s6 = this.m_shape.getNextVertex(s6)) ;
                for (let s6 = e5; s6 !== cr && (this.m_shape.setPoint(s6, m3.getResultPoint(), true), s6 !== t4); s6 = this.m_shape.getNextVertex(s6)) ;
              } else this.m_shape.setPoint(e5, m3.getResultPoint(), true);
              m3.clear();
            }
          }
        }
        if (B4 + O3 !== 0 && 0 !== B4) {
          let t4 = false;
          for (; C3 = this.getSegment_(e5, s4), null != C3 && (C3.queryEnvelope(r), C3.isDegenerate(this.m_tolerance)); ) {
            if (!(B4 > 1)) {
              t4 = true;
              break;
            }
            e5 = u.next(), B4--, n2(e5 !== cr);
          }
          if (t4) break;
        }
      }
    }
    return t3;
  }
  crackerPlaneSweep_() {
    return this.planesweep_();
  }
  planesweep_() {
    return new Dn2(this.m_progressTracker, this.m_bTrackChanges).sweep(this.m_shape, this.m_tolerance);
  }
  needsCrackingImpl_() {
    let e5 = false;
    const t3 = new st2(0);
    t3.resize(this.m_shape.getSelectedCount());
    const s4 = this.m_shape.queryVertexIteratorOnSelection();
    for (let i2 = 0, g2 = s4.next(); g2 !== cr; ++i2, g2 = s4.next()) t3.write(i2, g2);
    this.m_shape.sortVerticesSimpleByY(t3, 0, t3.size()), t3.add(cr);
    const n6 = this.m_shape.createUserIndex(), r = this.m_shape.createUserIndex();
    this.m_sweepComparator = new on2(this.m_shape, this.m_tolerance, !this.m_bAllowCoincident), this.m_sweepStructure.setComparator(this.m_sweepComparator);
    let o = null;
    const a2 = [], h2 = [];
    let m3 = 0;
    const l2 = new mi();
    for (let g2 = t3.read(m3++); g2 !== cr; ) {
      this.m_shape.queryXY(g2, l2);
      let s5 = false;
      do {
        let e6 = this.m_shape.getNextVertex(g2), i2 = this.m_shape.getPrevVertex(g2);
        s5 ||= e6 !== cr || i2 !== cr, e6 === cr || this.m_shape.selected(e6) || (e6 = cr), i2 === cr || this.m_shape.selected(i2) || (i2 = cr), e6 !== cr && this.m_shape.compareVerticesSimpleY(g2, e6) < 0 && (h2.push(g2), h2.push(e6)), i2 !== cr && this.m_shape.compareVerticesSimpleY(g2, i2) < 0 && (h2.push(i2), h2.push(i2));
        const o2 = this.m_shape.getUserIndex(g2, n6);
        -1 !== o2 && (a2.push(o2), this.m_shape.setUserIndex(g2, n6, -1));
        const l3 = this.m_shape.getUserIndex(g2, r);
        -1 !== l3 && (a2.push(l3), this.m_shape.setUserIndex(g2, r, -1)), g2 = t3.read(m3++);
      } while (g2 !== cr && this.m_shape.isEqualXYPoint2D(g2, l2));
      if (!s5 && (null === o && (o = new an2(this.m_shape, this.m_tolerance)), o.setPoint(l2), this.m_sweepStructure.searchUpperBound(o), o.intersectionDetected())) {
        e5 = true, this.m_bNeedsNonSimpleResult && (b("needsCrackingIMpl_"), this.m_nonSimpleResult = new e(6, -1, -1));
        break;
      }
      let u = 1 === a2.length && 2 === h2.length;
      const c = 32;
      a2.length > c && qt(a2);
      let _ = -1, d2 = -1;
      if (!u) for (let t4 = 0, n7 = a2.length; t4 < n7; t4++) {
        const s6 = a2[t4], n8 = this.m_sweepStructure.getPrev(s6);
        if (-1 !== n8 && -1 === a2.indexOf(n8)) if (-1 === _) _ = n8;
        else {
          if (e5 = true, !this.m_bNeedsNonSimpleResult) break;
          this.m_nonSimpleResult = new e(6, -1, -1);
        }
        const r2 = this.m_sweepStructure.getNext(s6);
        if (-1 !== r2 && -1 === a2.indexOf(r2)) if (-1 === d2) d2 = r2;
        else {
          if (e5 = true, !this.m_bNeedsNonSimpleResult) break;
          this.m_nonSimpleResult = new e(6, -1, -1);
        }
        if (-1 !== _ && -1 !== d2) break;
      }
      if (e5 && !this.m_bNeedsNonSimpleResult) break;
      if (this.m_sweepComparator.setSweepY(l2.y, l2.x), !u) {
        for (let e6 = 0, t4 = a2.length; e6 < t4; e6++) {
          const t5 = a2[e6];
          this.m_sweepStructure.deleteNode(t5);
        }
        a2.length = 0;
      }
      if (!u && -1 !== _ && -1 !== d2 && this.checkForIntersections_(_, d2)) {
        e5 = true, this.m_bNeedsNonSimpleResult && (this.m_nonSimpleResult = this.m_sweepComparator.getResult());
        break;
      }
      for (let t4 = 0, i2 = h2.length; t4 < i2; t4 += 2) {
        const s6 = h2[t4], i3 = h2[t4 + 1];
        let o2;
        if (u ? (o2 = this.m_sweepStructure.replaceElementAtPosition(a2[0], s6, true, true), a2.length = 0, u = false) : o2 = this.m_sweepStructure.addElement(s6), this.m_sweepComparator.intersectionDetected()) {
          this.m_bNeedsNonSimpleResult && (this.m_nonSimpleResult = this.m_sweepComparator.getResult()), e5 = true;
          break;
        }
        -1 === this.m_shape.getUserIndex(i3, n6) ? this.m_shape.setUserIndex(i3, n6, o2) : this.m_shape.setUserIndex(i3, r, o2);
      }
      if (e5) break;
      h2.length = 0;
    }
    return this.m_shape.removeUserIndex(n6), this.m_shape.removeUserIndex(r), e5;
  }
  checkForIntersections_(e5, t3) {
    const s4 = this.m_sweepStructure.getElement(e5);
    this.m_sweepComparator.compare(this.m_sweepStructure, s4, t3);
    const n6 = this.m_sweepComparator.intersectionDetected();
    return this.m_sweepComparator.clearIntersectionDetectedFlag(), n6;
  }
  getSegment_(e5, t3) {
    return _Bn.st_getSegment(this.m_shape, e5, t3);
  }
  static st_getSegment(e5, t3, s4) {
    return e5.querySegment(t3, s4, false, false) ? s4.get() : null;
  }
  dbgPrintSweepEdge(e5) {
  }
  dbgPrintSweepStructure() {
  }
  dbgSaveSweepStructure(e5 = null) {
  }
  dbgCheckSweepStructure() {
  }
  progress_(e5 = false) {
    this.m_progressCounter++;
  }
  crackAWithBMultiPath_(t3, s4, r) {
    const i2 = n4.constructEmpty();
    t3.queryLooseEnvelope(i2);
    const o = n4.constructEmpty();
    if (s4.queryLooseEnvelope(o), o.inflateCoords(r, r), !o.isIntersecting(i2)) return t3;
    const h2 = t3.getImpl(), m3 = h2.getAccelerators();
    let g2 = null, u = null;
    m3 && (u = m3.getQuadTree()), On2(t3, w(s4)) && (g2 = Wt2(h2, o), u = g2);
    const c = u ? u.getIteratorForQT() : null, _ = s4.querySegmentIterator(), d2 = t3.querySegmentIterator(), p3 = Yt(15, Number.NaN), f3 = [];
    for (; _.nextPath(); ) for (; _.hasNextSegment(); ) {
      const t4 = _.nextSegment();
      if (u) {
        c.resetIterator(t4, r);
        for (let e5 = c.next(); -1 !== e5; e5 = c.next()) {
          this.progress_();
          const s5 = u.getElement(e5);
          if (d2.resetToVertex(s5, -1), d2.hasNextSegment()) {
            const e6 = d2.nextSegment().intersect(t4, null, p3, null, r);
            for (let t5 = 0; t5 < e6; t5++) {
              const e7 = p3[t5];
              if (0 === e7 || 1 === e7) continue;
              const s6 = qn2(e7, d2.getStartPointIndex());
              f3.push(s6);
            }
          }
        }
      } else {
        const s5 = n4.constructEmpty();
        if (t4.queryLooseEnvelope(s5), s5.inflateCoords(r, r), !i2.isIntersecting(s5)) continue;
        for (d2.resetToFirstPath(); d2.nextPath(); ) for (; d2.hasNextSegment(); ) {
          const n6 = d2.nextSegment(), i3 = n4.constructEmpty();
          if (n6.queryLooseEnvelope(i3), !i3.isIntersecting(s5)) continue;
          const o2 = n6.intersect(t4, null, p3, null, r);
          for (let e5 = 0; e5 < o2; e5++) {
            const t5 = p3[e5];
            if (0 === t5 || 1 === t5) continue;
            const s6 = qn2(t5, d2.getStartPointIndex());
            f3.push(s6);
          }
        }
      }
    }
    if (0 === f3.length) return t3;
    f3.sort((e5, t4) => e5.index < t4.index ? -1 : e5.index > t4.index ? 1 : e5.t < t4.t ? -1 : e5.t > t4.t ? 1 : 0);
    const x4 = t3.createInstance();
    if (x4.getGeometryType() === a.enumPolygon) {
      x4.setFillRule(t3.getFillRule());
    }
    for (d2.resetToFirstPath(); d2.nextPath() && !d2.hasNextSegment(); ) ;
    n2(d2.hasNextSegment());
    let y2 = d2.nextSegment();
    const P5 = new fm();
    let E2 = -1;
    for (let e5 = 0, n6 = f3.length; e5 < n6; ) {
      const t4 = f3[e5].index;
      let s5 = e5 + 1;
      for (; s5 < n6 && f3[s5].index === t4; ) ++s5;
      for (; d2.getStartPointIndex() < t4; ) {
        this.progress_();
        const e6 = d2.hasNextSegment(), t5 = d2.getPathIndex();
        if ((e6 || !d2.isClosingSegment() || d2.isCurve()) && (n2(null !== y2), x4.addSegment(y2, E2 !== t5)), E2 = t5, !e6) {
          for (d2.isPathClosed(); d2.nextPath() && !d2.hasNextSegment(); ) ;
          n2(d2.hasNextSegment());
        }
        y2 = d2.nextSegment();
      }
      let r2 = 0;
      for (let n7 = e5; n7 < s5; n7++) {
        const e6 = f3[n7].t;
        if (e6 === r2) continue;
        n2(null !== y2), y2.queryCut(r2, e6, P5), r2 = e6;
        const t5 = d2.getPathIndex();
        x4.addSegment(P5.get(), E2 !== t5), E2 = t5;
      }
      const i3 = d2.hasNextSegment();
      if ((i3 || !d2.isClosingSegment() || d2.isCurve()) && (n2(null != y2), y2.queryCut(r2, 1, P5), x4.addSegment(P5.get(), false)), i3) y2 = d2.nextSegment();
      else {
        for (; d2.nextPath() && !d2.hasNextSegment(); ) ;
        y2 = d2.hasNextSegment() ? d2.nextSegment() : null;
      }
      e5 = s5;
    }
    if (null !== y2) {
      const e5 = d2.getPathIndex();
      (d2.hasNextSegment() || !d2.isClosingSegment() || d2.isCurve()) && x4.addSegment(y2, E2 !== e5), E2 = e5;
    }
    let S3 = d2.hasNextSegment();
    for (; ; ) {
      if (!S3) {
        for (; d2.nextPath() && (S3 = d2.hasNextSegment(), !S3); ) ;
        if (!S3) break;
      }
      y2 = d2.nextSegment();
      const e5 = d2.getPathIndex();
      S3 = d2.hasNextSegment();
      (S3 || !d2.isClosingSegment() || d2.isCurve()) && x4.addSegment(y2, E2 !== e5), E2 = e5;
    }
    return x4;
  }
  constructor(e5) {
    this.m_shape = null, this.m_progressTracker = null, this.m_nonSimpleResult = new e(), this.m_tolerance = 0, this.m_sweepComparator = null, this.m_progressCounter = 0, this.m_bTrackChanges = false, this.m_bNeedsNonSimpleResult = false, this.m_bAllowCoincident = true, this.m_sweepStructure = new ct2(), this.m_progressTracker = e5;
  }
};
function On2(e5, t3) {
  const s4 = e5.getPointCount();
  if (s4 < 16) return false;
  const n6 = 1;
  return 2 * s4 + 1 * (Math.log(s4) / Math.log(2)) * t3 < n6 * s4 * t3;
}
Bn2.s_bForceBruteForce = true;
var Yn2 = class {
  constructor(e5, t3) {
    this.m_monotoneParts = Ot(fm, 16), this.m_xOrds = Yt(16, Number.NaN), this.m_inputPoint = mi.getNAN(), this.m_miny = 0, this.m_maxy = 0, this.m_windnum = 0, this.m_bAlternate = e5, this.m_tolerance = t3, this.m_toleranceSqr = t3 * t3, this.m_bTestBorder = !!t3, this.m_bBreak = false;
  }
  _DoOne(e5) {
    if (!this.m_bTestBorder && (this.m_bAlternate && this.m_inputPoint.equals(e5.getStartXY()) || this.m_inputPoint.equals(e5.getEndXY()))) return void (this.m_bBreak = true);
    if (e5.getStartY() === this.m_inputPoint.y && e5.getStartY() === e5.getEndY()) {
      if (this.m_bAlternate && !this.m_bTestBorder) {
        const t4 = Math.min(e5.getStartX(), e5.getEndX()), s5 = Math.max(e5.getStartX(), e5.getEndX());
        this.m_inputPoint.x > t4 && this.m_inputPoint.x < s5 && (this.m_bBreak = true);
      }
      return;
    }
    let t3 = false;
    const s4 = Math.max(e5.getStartX(), e5.getEndX());
    if (this.m_inputPoint.x > s4) t3 = true;
    else if (this.m_inputPoint.x >= Math.min(e5.getStartX(), e5.getEndX())) {
      const n6 = e5.intersectionOfYMonotonicWithAxisX(this.m_inputPoint.y, s4);
      t3 = !Number.isNaN(n6) && n6 <= this.m_inputPoint.x;
    }
    if (t3) {
      if (this.m_inputPoint.y === e5.getStartY()) {
        if (this.m_inputPoint.y < e5.getEndY()) return;
      } else if (this.m_inputPoint.y === e5.getEndY() && this.m_inputPoint.y < e5.getStartY()) return;
      this.m_bAlternate ? this.m_windnum ^= 1 : this.m_windnum += e5.getStartY() > e5.getEndY() ? 1 : -1;
    }
  }
  _Result() {
    return !!this.m_windnum;
  }
  testBorder(e5) {
    const t3 = e5.getClosestCoordinate(this.m_inputPoint, false), s4 = e5.getCoord2D(t3);
    return mi.sqrDistance(s4, this.m_inputPoint) <= this.m_toleranceSqr;
  }
  setInputPoint(e5) {
    this.m_inputPoint.setCoordsPoint2D(e5), this.m_miny = e5.y - this.m_tolerance, this.m_maxy = e5.y + this.m_tolerance;
  }
  processSegment(e5) {
    const t3 = e5.queryInterval(0, 1);
    if (t3.vmin > this.m_maxy || t3.vmax < this.m_miny) return false;
    if (this.m_bTestBorder && this.testBorder(e5)) return true;
    if (t3.vmin > this.m_inputPoint.y || t3.vmax < this.m_inputPoint.y) return false;
    let s4 = 0;
    if (e5.isCurve() && (0 === this.m_monotoneParts.length && (this.m_monotoneParts.length = 128), s4 = e5.getMonotonicParts(this.m_monotoneParts, true), n2(this.m_monotoneParts.length >= s4)), s4 > 0) for (let n6 = 0; n6 < s4; n6++) {
      const e6 = this.m_monotoneParts[n6].get(), t4 = x2.construct(e6.getStartY(), e6.getEndY());
      if (!(t4.vmin > this.m_inputPoint.y || t4.vmax < this.m_inputPoint.y) && (this._DoOne(e6), this.m_bBreak)) return true;
    }
    else if (this._DoOne(e5), this.m_bBreak) return true;
    return false;
  }
  result() {
    return n2(0), 2;
  }
};
function Rn2(t3, s4, n6, r) {
  const i2 = new n4();
  t3.queryLooseEnvelope(i2), i2.inflateCoords(r, r);
  const o = 0 === t3.getFillRule(), a2 = new Yn2(o, r);
  a2.setInputPoint(n6);
  const h2 = i2.clone();
  h2.xmax = n6.x + r, h2.ymin = n6.y - r, h2.ymax = n6.y + r;
  const m3 = t3.getImpl().querySegmentIterator(), l2 = s4.getIterator(h2, r);
  for (let e5 = l2.next(); -1 !== e5; e5 = l2.next()) if (m3.resetToVertex(s4.getElement(e5), -1), m3.hasNextSegment()) {
    const e6 = m3.nextSegment();
    if (a2.processSegment(e6)) return -1;
  }
  return a2._Result() ? 1 : 0;
}
function Xn2(e5, t3, s4) {
  const n6 = 0 === e5.getFillRule(), r = new Yn2(n6, s4);
  r.setInputPoint(t3);
  const i2 = e5.getImpl().querySegmentIterator();
  for (; i2.nextPath(); ) for (; i2.hasNextSegment(); ) {
    const e6 = i2.nextSegment();
    if (r.processSegment(e6)) return -1;
  }
  return r._Result() ? 1 : 0;
}
function Ln2(e5, t3, s4) {
  return t3.isEmpty() ? 0 : zn2(e5, t3.getXY(), s4);
}
function zn2(t3, s4, n6) {
  if (t3.isEmpty()) return 0;
  const r = n4.constructEmpty();
  if (t3.queryLooseEnvelope(r), r.inflateCoords(n6, n6), !r.contains(s4)) return 0;
  const i2 = t3.getImpl().getAccelerators();
  if (i2) {
    i2.getRasterizedGeometry() && n2(0);
    const e5 = i2.getQuadTree();
    if (e5) return Rn2(t3, e5, s4, n6);
  }
  return Xn2(t3, s4, n6);
}
function Wn2(e5, t3) {
  const s4 = e5.getPointCount();
  if (s4 < 16) return false;
  const n6 = 1;
  return 2 * s4 + 1 * (Math.log(s4) / Math.log(2)) * t3 < n6 * s4 * t3;
}
function jn2(e5, t3, s4, n6, r) {
  const i2 = new $n2(r);
  return i2.m_shape = e5, i2.m_geometry = t3, i2.m_sortedVertices = s4, i2.m_bFixSelfTangency = n6, i2.fixRingOrientation_();
}
function Zn2(e5, t3, s4) {
  const n6 = new $n2(s4);
  return n6.m_shape = e5, n6.m_geometry = t3, n6.m_sortedVertices = null, n6.m_bFixSelfTangency = false, n6.fixRingOrientationForMp2sp_();
}
var Kn2 = class {
  getDirection_(e5) {
    return this.m_shape.getNextVertex(this.getEnd1(e5)) === this.getEnd2(e5);
  }
  getEnd_(e5) {
    const t3 = this.getEnd1(e5), s4 = this.getEnd2(e5);
    return this.m_shape.getNextVertex(t3) === s4 ? s4 : t3;
  }
  constructor(e5) {
    this.m_end1Nodes = [], this.m_end2Nodes = [], this.m_directions = [], this.m_shape = e5, this.m_firstFree = -1;
  }
  getSegment(e5) {
    return this.m_shape.getSegment(this.getStart(e5));
  }
  isBottomUp(e5) {
    let t3 = this.getEnd1(e5), s4 = this.getEnd2(e5);
    this.m_shape.getPrevVertex(t3) === s4 && (s4 = Pt(t3, t3 = s4));
    const n6 = mi.getNAN(), r = mi.getNAN();
    return this.m_shape.queryXY(t3, n6), this.m_shape.queryXY(s4, r), n2(!n6.equals(r)), n6.y < r.y;
  }
  getStart(e5) {
    const t3 = this.getEnd1(e5), s4 = this.getEnd2(e5);
    return this.m_shape.getNextVertex(t3) === s4 ? t3 : s4;
  }
  getEnd1(e5) {
    return this.m_end1Nodes[e5];
  }
  getEnd2(e5) {
    return this.m_end2Nodes[e5];
  }
  freeEdge(e5) {
    this.m_end1Nodes[e5] = this.m_firstFree, this.m_firstFree = e5;
  }
  newEdge(e5) {
    if (-1 !== this.m_firstFree) {
      const t4 = this.m_firstFree;
      return this.m_firstFree = this.m_end1Nodes[t4], this.m_end1Nodes[t4] = e5, this.m_end2Nodes[t4] = this.m_shape.getNextVertex(e5), t4;
    }
    const t3 = this.m_end1Nodes.length;
    return this.m_end1Nodes.push(e5), this.m_end2Nodes.push(this.m_shape.getNextVertex(e5)), t3;
  }
  getShape() {
    return this.m_shape;
  }
  getPath(e5) {
    return this.m_shape.getPathFromVertex(this.getEnd1(e5));
  }
};
var Qn2 = class extends dt {
  constructor(e5) {
    super(), this.m_line1 = new pm(), this.m_line2 = new pm(), this.m_leftElm = -1, this.m_leftx = 0, this.m_seg1 = null, this.m_helper = e5;
  }
  compare(e5, t3, s4) {
    const n6 = e5.getElement(s4), r = this.m_helper.m_edges;
    let i2;
    if (this.m_leftElm === t3) i2 = this.m_leftx;
    else {
      if (this.m_seg1 = r.getSegment(t3), this.m_seg1) i2 = this.m_seg1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
      else {
        r.getShape().queryLineConnector(r.getStart(t3), this.m_line1, true), this.m_seg1 = this.m_line1, i2 = this.m_line1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
      }
      this.m_leftx = i2, this.m_leftElm = t3;
    }
    let o, a2 = r.getSegment(n6);
    if (a2) o = a2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    else {
      r.getShape().queryLineConnector(r.getStart(n6), this.m_line2, true), a2 = this.m_line2, o = this.m_line2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    }
    if (i2 === o) {
      const e6 = r.isBottomUp(t3), s5 = r.isBottomUp(n6), h2 = e6 ? this.m_seg1.getEndY() : this.m_seg1.getStartY(), m3 = s5 ? a2.getEndY() : a2.getStartY(), l2 = Math.min(h2, m3);
      let g2 = 0.5 * (l2 + this.m_helper.m_yScanline);
      g2 === this.m_helper.m_yScanline && (g2 = l2), i2 = this.m_seg1.intersectionOfYMonotonicWithAxisX(g2, 0), o = a2.intersectionOfYMonotonicWithAxisX(g2, 0), i2 === o && k("");
    }
    return i2 < o ? -1 : i2 > o ? 1 : 0;
  }
  reset() {
    this.m_leftElm = -1;
  }
};
var Jn2 = class {
  constructor(e5) {
    this.m_node = -1, this.m_index = 0, this.m_sortedVertices = e5.m_sortedVertices, this.m_sortedVerticesArray = e5.m_sortedVerticesArray, this.m_sortedVertices && (this.m_node = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()));
  }
  next() {
    if (this.m_sortedVertices) {
      const e5 = this.m_node;
      if (-1 === e5) return cr;
      const t3 = this.m_sortedVertices.getData(e5);
      return this.m_node = this.m_sortedVertices.getNext(e5), t3;
    }
    if (this.m_index < this.m_sortedVerticesArray.size()) {
      const e5 = this.m_sortedVerticesArray.read(this.m_index);
      return this.m_index++, e5;
    }
    return cr;
  }
};
var $n2 = class {
  constructor(e5) {
    this.m_edges = null, this.m_shape = null, this.m_AET = new ct2(), this.m_yScanline = 0, this.m_geometry = cr, this.m_unknownRingOrientationCount = -1, this.m_sortedVertices = null, this.m_sortedVerticesArray = null, this.m_unknownNodes = [], this.m_node1UserIndex = -1, this.m_node2UserIndex = -1, this.m_pathOrientationIndex = -1, this.m_pathParentageIndex = -1, this.m_pathParentsIndex = -1, this.m_progressCounter = 0, this.m_bFixSelfTangency = false, this.m_progressTracker = e5, this.m_AET.disableBalancing(), this.m_sweepComparator = new Qn2(this), this.m_AET.setComparator(this.m_sweepComparator);
  }
  fixRingOrientation_() {
    const e5 = this.fixRingOrientationImplMain_();
    return -1 === this.m_pathOrientationIndex || this.fixRingOrientationImplSimplify_(), e5;
  }
  fixRingOrientationForMp2sp_() {
    return this.fixRingOrientationImplMain_(), -1 === this.m_pathOrientationIndex ? -1 : this.fixRingOrientationImplMp2sp_();
  }
  processBunchForRingOrientationTest_(e5) {
    return this.processBunchForRingOrientationTestOddEven_(e5);
  }
  processBunchForRingOrientationTestOddEven_(e5) {
    let t3 = false;
    if (this.m_edges || (this.m_edges = new Kn2(this.m_shape)), this.m_unknownNodes.length = 0, this.processBunchForRingOrientationRemoveEdges_(e5), !this.m_AET.isAutoBalancing()) {
      let t4 = 0;
      for (let s4 = 0, n6 = e5.length; s4 < n6; s4++) {
        -1 !== e5[s4] && t4++;
      }
      (t4 > 10 || this.m_AET.getMaxDepthEver() > 4) && this.m_AET.enableBalancing();
    }
    for (let s4 = 0, n6 = e5.length; s4 < n6; s4++) {
      const t4 = e5[s4];
      t4 !== cr && this.insertEdge_(t4, -1);
    }
    for (let s4 = 0; s4 < this.m_unknownNodes.length && this.m_unknownRingOrientationCount > 0; s4++) {
      const e6 = this.m_unknownNodes[s4], n6 = this.m_AET.getElement(e6), r = this.m_edges.getPath(n6), i2 = this.m_shape.getPathUserIndex(r, this.m_pathOrientationIndex);
      let o = cr;
      if (0 === i2) {
        let s5 = this.m_AET.getPrev(e6), n7 = e6, r2 = false;
        for (; s5 !== ct2.st_nullNode(); ) {
          const e7 = this.m_AET.getElement(s5), t4 = this.m_edges.getPath(e7);
          if (0 !== this.m_shape.getPathUserIndex(t4, this.m_pathOrientationIndex)) {
            o = t4;
            break;
          }
          n7 = s5, s5 = this.m_AET.getPrev(s5);
        }
        if (s5 === ct2.st_nullNode()) r2 = true, s5 = n7;
        else {
          const e7 = this.m_AET.getElement(s5);
          r2 = this.m_edges.isBottomUp(e7), s5 = this.m_AET.getNext(s5), r2 = !r2;
        }
        do {
          const e7 = this.m_AET.getElement(s5), i3 = this.m_edges.getPath(e7);
          if (0 === this.m_shape.getPathUserIndex(i3, this.m_pathOrientationIndex)) {
            if (r2 !== this.m_edges.isBottomUp(e7)) {
              const e8 = this.m_shape.getFirstVertex(i3);
              this.m_shape.reverseRingInternal(e8), this.m_shape.setLastVertex(i3, this.m_shape.getPrevVertex(e8)), t3 = true;
            }
            if (this.m_shape.setPathUserIndex(i3, this.m_pathOrientationIndex, r2 ? 3 : 2), !r2) {
              let e8 = this.m_shape.getPathUserIndex(o, this.m_pathOrientationIndex);
              2 === e8 ? (o = this.m_shape.getPathUserIndex(o, this.m_pathParentsIndex), e8 = this.m_shape.getPathUserIndex(o, this.m_pathOrientationIndex), n2(3 === e8)) : n2(3 === e8);
              const t4 = this.m_shape.getPathUserIndex(o, this.m_pathParentageIndex);
              this.m_shape.setPathUserIndex(o, this.m_pathParentageIndex, i3), this.m_shape.setPathUserIndex(i3, this.m_pathParentageIndex, t4), this.m_shape.setPathUserIndex(i3, this.m_pathParentsIndex, o);
            }
            if (this.m_unknownRingOrientationCount--, !this.m_unknownRingOrientationCount) return t3;
          }
          o = i3, n7 = s5, s5 = this.m_AET.getNext(s5), r2 = !r2;
        } while (n7 !== e6);
      }
    }
    return t3;
  }
  processBunchForRingOrientationRemoveEdges_(e5) {
    for (let t3 = 0, s4 = e5.length; t3 < s4; t3++) {
      const s5 = e5[t3], n6 = this.m_shape.getUserIndex(s5, this.m_node1UserIndex), r = this.m_shape.getUserIndex(s5, this.m_node2UserIndex);
      if (-1 !== n6) {
        const e6 = this.m_AET.getElement(n6);
        this.m_edges.freeEdge(e6), this.m_shape.setUserIndex(s5, this.m_node1UserIndex, -1);
      }
      if (-1 !== r) {
        const e6 = this.m_AET.getElement(r);
        this.m_edges.freeEdge(e6), this.m_shape.setUserIndex(s5, this.m_node2UserIndex, -1);
      }
      let i2 = -1;
      -1 !== n6 && -1 !== r ? (this.m_AET.deleteNode(n6), this.m_AET.deleteNode(r), e5[t3] = cr) : i2 = -1 !== n6 ? n6 : r, -1 !== i2 && (this.insertEdge_(s5, i2) || this.m_AET.deleteNode(i2), e5[t3] = cr);
    }
  }
  dbgVerifyRingOrientation_() {
  }
  insertEdge_(e5, t3) {
    const s4 = mi.getNAN(), n6 = mi.getNAN();
    this.m_shape.queryXY(e5, s4);
    const r = this.m_shape.getNextVertex(e5);
    this.m_shape.queryXY(r, n6);
    let i2 = false;
    if (s4.y < n6.y) {
      i2 = true;
      const s5 = this.m_edges.newEdge(e5);
      let n7;
      -1 === t3 ? n7 = this.m_AET.addElement(s5) : (n7 = t3, this.m_AET.setElement(n7, s5));
      -1 === this.m_shape.getUserIndex(r, this.m_node1UserIndex) ? this.m_shape.setUserIndex(r, this.m_node1UserIndex, n7) : this.m_shape.setUserIndex(r, this.m_node2UserIndex, n7);
      const o2 = this.m_shape.getPathFromVertex(e5);
      0 === this.m_shape.getPathUserIndex(o2, this.m_pathOrientationIndex) && this.m_unknownNodes.push(n7);
    }
    const o = this.m_shape.getPrevVertex(e5);
    if (this.m_shape.queryXY(o, n6), s4.y < n6.y) {
      i2 = true;
      const s5 = this.m_edges.newEdge(o);
      let n7;
      -1 === t3 ? n7 = this.m_AET.addElement(s5) : (n7 = t3, this.m_AET.setElement(n7, s5));
      -1 === this.m_shape.getUserIndex(o, this.m_node1UserIndex) ? this.m_shape.setUserIndex(o, this.m_node1UserIndex, n7) : this.m_shape.setUserIndex(o, this.m_node2UserIndex, n7);
      const r2 = this.m_shape.getPathFromVertex(e5);
      0 === this.m_shape.getPathUserIndex(r2, this.m_pathOrientationIndex) && this.m_unknownNodes.push(n7);
    }
    return i2;
  }
  fixRingSelfTangency_() {
    const e5 = [], t3 = [];
    let s4 = -1, n6 = -1;
    const r = new mi();
    let i2 = cr, o = cr, h2 = -1;
    const m3 = new Jn2(this);
    for (let a2 = m3.next(); a2 !== cr; a2 = m3.next()) {
      const m4 = new mi();
      this.m_shape.queryXY(a2, m4);
      const l2 = this.m_shape.getPathFromVertex(a2);
      if (r.equals(m4) && o === l2) {
        if (-1 === n6 && (s4 = this.m_shape.createPathUserIndex(), this.m_shape.fillPathUserIndexForGeometry(this.m_geometry, s4, -1), n6 = this.m_shape.createUserIndex(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, n6, -1)), -1 === h2) {
          h2 = t3.length, this.m_shape.setUserIndex(i2, n6, h2), t3.push(1);
          -1 === this.m_shape.getPathUserIndex(l2, s4) && (this.m_shape.setPathUserIndex(l2, s4, i2), e5.push(l2));
        }
        this.m_shape.setUserIndex(a2, n6, h2), t3[t3.length - 1]++;
      } else h2 = -1, r.assign(m4);
      i2 = a2, o = l2;
    }
    if (0 === e5.length) return false;
    n2(-1 !== s4);
    for (let a2 = 0, l2 = e5.length; a2 < l2; a2++) {
      const r2 = e5[a2];
      let i3 = this.m_shape.getPathUserIndex(r2, s4);
      const o2 = this.m_shape.getUserIndex(i3, n6), h3 = [], m4 = [];
      h3.push(i3), m4.push(o2);
      for (let e6 = this.m_shape.getNextVertex(i3); e6 !== i3; e6 = this.m_shape.getNextVertex(e6)) {
        const s5 = e6, r3 = this.m_shape.getUserIndex(s5, n6);
        if (-1 !== r3) {
          if (0 === m4.length) {
            m4.push(r3), h3.push(s5);
            continue;
          }
          if (m4.at(-1) === r3) {
            const o3 = h3.at(-1);
            this.m_shape.peelALoopIntoAPath(o3, s5), this.m_shape.setUserIndex(e6, n6, -1), t3[r3]--, 1 === t3[r3] && (t3[r3] = 0, m4.pop(), h3.pop()), i3 = o3, e6 = o3;
          } else h3.push(e6), m4.push(r3);
        }
      }
    }
    return this.m_shape.removePathUserIndex(s4), this.m_shape.removeUserIndex(n6), this.m_shape.dbgVerifyVertexCounts(), true;
  }
  progress_(e5 = false) {
  }
  fixRingOrientationImplMain_() {
    const e5 = { stack: [], error: void 0, hasError: false };
    try {
      let t3, s4 = false;
      const n6 = n(e5, kt(() => {
        this.m_sortedVerticesArray = null;
      }), false);
      if (null === this.m_sortedVertices) {
        const e6 = this.m_shape.getPointCount(this.m_geometry);
        t3 = new st2(0);
        for (let s5 = this.m_shape.getFirstPath(this.m_geometry); s5 !== cr; s5 = this.m_shape.getNextPath(s5)) {
          let e7 = this.m_shape.getFirstVertex(s5);
          for (let n7 = 0, r2 = this.m_shape.getPathSize(s5); n7 < r2; n7++) t3.add(e7), e7 = this.m_shape.getNextVertex(e7);
        }
        this.m_shape.sortVerticesSimpleByY(t3, 0, e6), this.progress_(true), this.m_sortedVerticesArray = t3;
      } else n6.bForget = true;
      if (this.m_bFixSelfTangency && (s4 = this.fixRingSelfTangency_()), 1 === this.m_shape.getPathCount(this.m_geometry)) {
        const e6 = this.m_shape.getFirstPath(this.m_geometry), t4 = this.m_shape.getRingArea(e6);
        if (this.m_shape.setExterior(e6, true), t4 < 0) {
          const t5 = this.m_shape.getFirstVertex(e6);
          return this.m_shape.reverseRingInternal(t5), this.m_shape.setLastVertex(e6, this.m_shape.getPrevVertex(t5)), true;
        }
        return false;
      }
      this.m_shape.dbgVerifyCurves(), this.m_pathOrientationIndex = this.m_shape.createPathUserIndex(), this.m_pathParentageIndex = this.m_shape.createPathUserIndex(), this.m_pathParentsIndex = this.m_shape.createPathUserIndex();
      for (let e6 = this.m_shape.getFirstPath(this.m_geometry); e6 !== cr; e6 = this.m_shape.getNextPath(e6)) this.m_shape.setPathUserIndex(e6, this.m_pathOrientationIndex, 0), this.m_shape.setPathUserIndex(e6, this.m_pathParentageIndex, -1), this.m_shape.setPathUserIndex(e6, this.m_pathParentsIndex, -1);
      const r = [];
      this.m_yScanline = Number.NaN;
      const i2 = mi.getNAN();
      this.m_unknownRingOrientationCount = this.m_shape.getPathCount(this.m_geometry), this.m_node1UserIndex = this.m_shape.createUserIndexUninitialized(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, this.m_node1UserIndex, -1), this.m_node2UserIndex = this.m_shape.createUserIndexUninitialized(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, this.m_node2UserIndex, -1);
      const o = new Jn2(this);
      for (let e6 = o.next(); e6 !== cr && (this.progress_(), this.m_shape.queryXY(e6, i2), i2.y !== this.m_yScanline && r.length && (s4 = this.processBunchForRingOrientationTest_(r) || s4, this.m_sweepComparator.reset(), r.length = 0), r.push(e6), this.m_yScanline = i2.y, 0 !== this.m_unknownRingOrientationCount); e6 = o.next()) ;
      return this.m_unknownRingOrientationCount > 0 && (s4 = this.processBunchForRingOrientationTest_(r) || s4, r.length = 0), this.m_shape.removeUserIndex(this.m_node1UserIndex), this.m_shape.removeUserIndex(this.m_node2UserIndex), this.dbgVerifyRingOrientation_(), s4;
    } catch (t3) {
      e5.error = t3, e5.hasError = true;
    } finally {
      s(e5);
    }
  }
  fixRingOrientationImplSimplify_() {
    const e5 = [];
    for (let t3 = this.m_shape.getFirstPath(this.m_geometry); t3 !== cr; ) if (this.progress_(), 3 === this.m_shape.getPathUserIndex(t3, this.m_pathOrientationIndex)) {
      this.m_shape.setExterior(t3, true);
      for (let r = this.m_shape.getPathUserIndex(t3, this.m_pathParentageIndex); r !== cr; ) {
        const s5 = this.m_shape.getPathUserIndex(r, this.m_pathParentageIndex);
        e5.push(r), this.m_shape.setExterior(r, false), this.m_shape.setPathUserIndex(r, this.m_pathParentageIndex, t3), r = s5;
      }
      let s4 = t3, n6 = e5.length;
      for (let e6 = this.m_shape.getNextPath(t3); n6 > 0 && e6 !== cr; e6 = this.m_shape.getNextPath(e6), --n6) {
        if (this.m_shape.getPathUserIndex(e6, this.m_pathParentageIndex) !== t3) {
          s4 = cr;
          break;
        }
        s4 = e6;
      }
      if (0 !== n6) {
        s4 = t3;
        for (let t4 = 0, n7 = e5.length; t4 < n7; t4++) {
          const n8 = e5[t4];
          this.m_shape.setPathUserIndex(n8, this.m_pathParentageIndex, U3), this.m_shape.movePath(this.m_geometry, this.m_shape.getNextPath(s4), n8), s4 = n8;
        }
      }
      e5.length = 0, t3 = this.m_shape.getNextPath(s4);
    } else t3 = this.m_shape.getNextPath(t3);
    this.m_shape.removePathUserIndex(this.m_pathOrientationIndex), this.m_shape.removePathUserIndex(this.m_pathParentageIndex), this.m_shape.removePathUserIndex(this.m_pathParentsIndex);
  }
  fixRingOrientationImplMp2sp_() {
    const e5 = this.m_shape.createPathUserIndex();
    let t3 = 0;
    const s4 = [];
    for (let n6 = this.m_shape.getFirstPath(this.m_geometry); n6 !== cr; ) if (this.progress_(), 3 === this.m_shape.getPathUserIndex(n6, this.m_pathOrientationIndex)) {
      this.m_shape.setExterior(n6, true), this.m_shape.setPathUserIndex(n6, e5, t3), t3++;
      for (let e6 = this.m_shape.getPathUserIndex(n6, this.m_pathParentageIndex); e6 !== cr; ) {
        const t4 = this.m_shape.getPathUserIndex(e6, this.m_pathParentageIndex);
        s4.push(e6), this.m_shape.setExterior(e6, false), this.m_shape.setPathUserIndex(e6, this.m_pathParentageIndex, n6), e6 = t4;
      }
      let r = n6, i2 = s4.length, o = t3;
      for (let t4 = this.m_shape.getNextPath(n6); i2 > 0 && t4 !== cr; t4 = this.m_shape.getNextPath(t4), --i2) {
        if (this.m_shape.getPathUserIndex(t4, this.m_pathParentageIndex) !== n6) {
          r = cr;
          break;
        }
        r = t4, this.m_shape.setPathUserIndex(t4, e5, -o), o++;
      }
      if (0 !== i2) {
        r = n6, o = t3;
        for (let t4 = 0, n7 = s4.length; t4 < n7; t4++) {
          const n8 = s4[t4];
          this.m_shape.setPathUserIndex(n8, e5, -o), o++, this.m_shape.setPathUserIndex(n8, this.m_pathParentageIndex, U3);
        }
        r = n6;
      }
      t3 = o, s4.length = 0, n6 = this.m_shape.getNextPath(r);
    } else n6 = this.m_shape.getNextPath(n6);
    return this.m_shape.removePathUserIndex(this.m_pathOrientationIndex), this.m_shape.removePathUserIndex(this.m_pathParentageIndex), this.m_shape.removePathUserIndex(this.m_pathParentsIndex), e5;
  }
};
function er2(e5, t3, s4, n6, r, i2) {
  const o = new tr2(i2);
  return o.m_shape = e5, o.m_geometry = t3, o.m_knownSimpleResult = s4, o.m_bFixSelfTangency = n6, o.m_polylineDegeneracies = r, o.m_bHasSegmentParentage = e5.hasSegmentParentage(), o.m_bHasSegments = e5.hasCurves(), o.simplify_();
}
var tr2 = class {
  constructor(e5) {
    this.m_shape = null, this.m_geometry = cr, this.m_sortedVertices = new pt(), this.m_bunchEdgeEndPoints = [], this.m_bunchEdgeCenterPoints = [], this.m_bunchEdgeIndices = [], this.m_sorterSegmentBuffer1 = null, this.m_sorterSegmentBuffer2 = null, this.m_knownSimpleResult = -1, this.m_sortedVerticesListIndex = -1, this.m_polylineDegeneracies = cr, this.m_userIndexSortedIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = -1, this.m_nextVertexToProcess = -1, this.m_firstCoincidentVertex = -1, this.m_progressCounter = 0, this.m_bFixSelfTangency = false, this.m_bHasSegmentParentage = false, this.m_bHasSegments = false, this.m_progressTracker = e5;
  }
  compareAngles_(e5, t3) {
    return this.m_bHasSegments ? this.compareAnglesCurves_(e5, t3) : this.compareAnglesLines_(e5, t3);
  }
  compareAnglesLines_(e5, t3) {
    const s4 = this.m_bunchEdgeEndPoints[e5], n6 = new mi();
    this.m_shape.queryXY(s4, n6);
    const r = new mi(), i2 = this.m_bunchEdgeEndPoints[t3];
    if (this.m_shape.queryXY(i2, r), n6.equals(r)) return 0;
    const o = this.m_bunchEdgeCenterPoints[e5], a2 = new mi();
    this.m_shape.queryXY(o, a2);
    const h2 = this.m_bunchEdgeCenterPoints[t3], m3 = new mi();
    this.m_shape.queryXY(h2, m3);
    const l2 = new mi();
    l2.setSub(n6, a2);
    const g2 = new mi();
    g2.setSub(r, m3), (l2.isZero() || g2.isZero()) && k("");
    return mi.compareVectors(l2, g2);
  }
  compareAnglesCurves_(e5, t3) {
    const s4 = this.m_bunchEdgeEndPoints[e5], n6 = this.m_bunchEdgeEndPoints[t3], r = this.m_bunchEdgeCenterPoints[e5], i2 = this.m_bunchEdgeCenterPoints[t3], o = this.m_shape.getNextVertex(r) === s4, a2 = this.m_shape.getNextVertex(i2) === n6, h2 = o ? this.m_shape.isCurve(r) : this.m_shape.isCurve(s4), m3 = a2 ? this.m_shape.isCurve(i2) : this.m_shape.isCurve(n6);
    if (!h2 && !m3) return this.compareAnglesLines_(e5, t3);
    this.m_sorterSegmentBuffer1 || (this.m_sorterSegmentBuffer1 = new fm()), this.m_sorterSegmentBuffer2 || (this.m_sorterSegmentBuffer2 = new fm()), o ? this.m_shape.querySegment(r, this.m_sorterSegmentBuffer1, false, true) : (this.m_shape.querySegment(s4, this.m_sorterSegmentBuffer1, false, true), this.m_sorterSegmentBuffer1.get().reverse()), a2 ? this.m_shape.querySegment(i2, this.m_sorterSegmentBuffer2, false, true) : (this.m_shape.querySegment(n6, this.m_sorterSegmentBuffer2, false, true), this.m_sorterSegmentBuffer2.get().reverse());
    return ze(this.m_sorterSegmentBuffer1.get(), this.m_sorterSegmentBuffer2.get());
  }
  beforeRemoveVertex_(e5, t3) {
    const s4 = this.m_shape.getUserIndex(e5, this.m_userIndexSortedIndexToVertex);
    if (this.m_nextVertexToProcess === s4 && (this.m_nextVertexToProcess = this.m_sortedVertices.getNext(this.m_nextVertexToProcess)), this.m_firstCoincidentVertex === s4 && (this.m_firstCoincidentVertex = this.m_sortedVertices.getNext(this.m_firstCoincidentVertex)), this.m_sortedVertices.deleteElement(this.m_sortedVerticesListIndex, s4), this.removeAngleSortInfo_(e5), t3) {
      const t4 = this.m_shape.getPathFromVertex(e5);
      if (t4 !== cr) {
        if (this.m_shape.getFirstVertex(t4) === e5) {
          const s5 = this.m_shape.getNextVertex(e5);
          if (s5 !== e5) {
            if (this.m_shape.getPathFromVertex(s5) === t4) return void this.m_shape.setFirstVertex(t4, s5);
            {
              const s6 = this.m_shape.getPrevVertex(e5);
              if (s6 !== e5) {
                if (this.m_shape.getPathFromVertex(s6) === t4) return void this.m_shape.setFirstVertex(t4, s6);
              }
            }
          }
          this.m_shape.setFirstVertex(t4, cr), this.m_shape.setLastVertex(t4, cr);
        }
      }
    }
  }
  processBunch_() {
    let e5 = false;
    const t3 = new mi(0, 0);
    for (; ; ) {
      this.m_bunchEdgeEndPoints.length = 0, this.m_bunchEdgeCenterPoints.length = 0, this.m_bunchEdgeIndices.length = 0;
      let s4 = this.m_firstCoincidentVertex, n6 = 0, r = true;
      for (; s4 !== this.m_nextVertexToProcess; ) {
        const e6 = this.m_sortedVertices.getData(s4);
        r && (this.m_shape.queryXY(e6, t3), r = false);
        const i3 = this.m_shape.getPrevVertex(e6), o = this.m_shape.getNextVertex(e6);
        this.m_shape.getUserIndex(i3, this.m_userIndexSortedAngleIndexToVertex) !== U3 && (this.m_bunchEdgeEndPoints.push(i3), this.m_shape.setUserIndex(i3, this.m_userIndexSortedAngleIndexToVertex, U3), this.m_bunchEdgeCenterPoints.push(e6), this.m_bunchEdgeIndices.push(n6++));
        this.m_shape.getUserIndex(o, this.m_userIndexSortedAngleIndexToVertex) !== U3 && (this.m_bunchEdgeEndPoints.push(o), this.m_shape.setUserIndex(o, this.m_userIndexSortedAngleIndexToVertex, U3), this.m_bunchEdgeCenterPoints.push(e6), this.m_bunchEdgeIndices.push(n6++)), s4 = this.m_sortedVertices.getNext(s4);
      }
      if (this.m_bunchEdgeEndPoints.length < 2) {
        1 === this.m_bunchEdgeEndPoints.length && this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[0], this.m_userIndexSortedAngleIndexToVertex, -1);
        break;
      }
      this.m_bunchEdgeIndices.sort((e6, t4) => this.compareAngles_(e6, t4));
      for (let e6 = 0, t4 = this.m_bunchEdgeIndices.length; e6 < t4; e6++) {
        const t5 = this.m_bunchEdgeIndices[e6], s5 = this.m_bunchEdgeEndPoints[t5];
        this.m_shape.setUserIndex(s5, this.m_userIndexSortedAngleIndexToVertex, e6);
      }
      const i2 = this.processCrossOvers_(t3);
      for (let e6 = 0, t4 = this.m_bunchEdgeIndices.length; e6 < t4; e6++) {
        const t5 = this.m_bunchEdgeIndices[e6];
        if (-1 === t5) continue;
        const s5 = this.m_bunchEdgeEndPoints[t5];
        this.m_shape.setUserIndex(s5, this.m_userIndexSortedAngleIndexToVertex, -1);
      }
      if (!i2) break;
      e5 = true;
    }
    return e5;
  }
  processCrossOvers_(e5) {
    let t3 = false, s4 = true;
    for (; s4; ) {
      s4 = false;
      let n6 = 0;
      -1 === this.m_bunchEdgeIndices[n6] && (n6 = this.getNextEdgeIndex_(n6));
      let r = this.getNextEdgeIndex_(n6);
      for (let i2 = 0, o = this.m_bunchEdgeIndices.length; i2 < o && -1 !== n6 && -1 !== r && n6 !== r; i2++) {
        const i3 = this.m_bunchEdgeIndices[n6], o2 = this.m_bunchEdgeIndices[r], a2 = this.m_bunchEdgeEndPoints[i3], h2 = this.m_bunchEdgeEndPoints[o2];
        let m3 = this.m_shape.getNextVertex(a2), l2 = false;
        this.m_shape.isEqualXYPoint2D(m3, e5) || (m3 = this.m_shape.getPrevVertex(a2), l2 = true);
        let g2 = this.m_shape.getNextVertex(h2), u = false;
        this.m_shape.isEqualXYPoint2D(g2, e5) || (g2 = this.m_shape.getPrevVertex(h2), u = true);
        const c = l2 ? this.m_shape.getPrevVertex(m3) : this.m_shape.getNextVertex(m3), _ = u ? this.m_shape.getPrevVertex(g2) : this.m_shape.getNextVertex(g2);
        let d2 = false;
        (this.removeSpike_(m3) || this.removeSpike_(g2) || this.removeSpike_(a2) || this.removeSpike_(h2) || this.removeSpike_(c) || this.removeSpike_(_)) && (d2 = true), m3 !== g2 && (!d2 && this.m_shape.isEqualXY(a2, h2) && (d2 = this.resolveOverlap_(l2, u, m3, a2, g2, h2)), !d2 && this.m_shape.isEqualXY(c, _) && (d2 = this.resolveOverlap_(!l2, !u, m3, c, g2, _)), !d2 && this.m_shape.isEqualXY(a2, _) && (d2 = this.resolveOverlap_(l2, !u, m3, a2, g2, _)), !d2 && this.m_shape.isEqualXY(c, h2) && (d2 = this.resolveOverlap_(!l2, u, m3, c, g2, h2))), d2 && (t3 = true), s4 ||= d2, n6 = d2 ? this.getNextEdgeIndex_(n6) : r, r = this.getNextEdgeIndex_(n6);
      }
    }
    if (!t3) {
      let s5 = 0;
      -1 === this.m_bunchEdgeIndices[s5] && (s5 = this.getNextEdgeIndex_(s5));
      let n6 = this.getNextEdgeIndex_(s5);
      for (let r = 0, i2 = this.m_bunchEdgeIndices.length; r < i2 && -1 !== s5 && -1 !== n6 && s5 !== n6; r++) {
        const r2 = this.m_bunchEdgeIndices[s5], i3 = this.m_bunchEdgeIndices[n6], o = this.m_bunchEdgeEndPoints[r2], a2 = this.m_bunchEdgeEndPoints[i3];
        let h2 = this.m_shape.getNextVertex(o);
        this.m_shape.isEqualXYPoint2D(h2, e5) || (h2 = this.m_shape.getPrevVertex(o));
        let m3 = this.m_shape.getNextVertex(a2);
        this.m_shape.isEqualXYPoint2D(m3, e5) || (m3 = this.m_shape.getPrevVertex(a2));
        const l2 = this.getDirection_(h2, o), g2 = this.getDirection_(m3, a2), u = l2 ? this.m_shape.getPrevVertex(h2) : this.m_shape.getNextVertex(h2), c = g2 ? this.m_shape.getPrevVertex(m3) : this.m_shape.getNextVertex(m3), _ = this.detectAndResolveCrossOver_(l2, g2, o, h2, u, a2, m3, c);
        1 !== _ ? 0 === _ ? (s5 = this.getNextEdgeIndex_(s5), n6 = this.getNextEdgeIndex_(s5)) : (s5 = this.getPrevEdgeIndex_(s5), n6 = this.getNextEdgeIndex_(s5)) : t3 = true;
      }
    }
    return t3;
  }
  simplify_() {
    if (this.m_shape.getGeometryType(this.m_geometry) === a.enumPolygon && 1 === this.m_shape.getFillRule(this.m_geometry)) {
      new Ka2(this.m_progressTracker).planarSimplifyNoCrackingAndCluster(this.m_bFixSelfTangency, this.m_shape, this.m_geometry, 0);
    }
    let e5 = false;
    this.m_userIndexSortedIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = this.m_shape.createUserIndexUninitialized();
    const t3 = this.m_shape.getPointCount(this.m_geometry), s4 = new st2(0);
    this.m_shape.dbgVerifyMonotone();
    for (let n6 = this.m_shape.getFirstPath(this.m_geometry); n6 !== cr; n6 = this.m_shape.getNextPath(n6)) {
      let e6 = this.m_shape.getFirstVertex(n6);
      for (let t4 = 0, r2 = this.m_shape.getPathSize(n6); t4 < r2; t4++) this.m_shape.setUserIndex(e6, this.m_userIndexSortedAngleIndexToVertex, -1), s4.add(e6), e6 = this.m_shape.getNextVertex(e6);
    }
    this.m_shape.sortVerticesSimpleByY(s4, 0, t3), this.progress_(true), this.m_userIndexSortedIndexToVertex = this.m_shape.createUserIndexUninitialized(), this.m_sortedVertices.reserveNodes(t3), this.m_sortedVerticesListIndex = this.m_sortedVertices.createList(0);
    for (let n6 = 0; n6 < t3; n6++) {
      const e6 = s4.read(n6), t4 = this.m_sortedVertices.addElement(this.m_sortedVerticesListIndex, e6);
      this.m_shape.setUserIndex(e6, this.m_userIndexSortedIndexToVertex, t4);
    }
    this.m_nextVertexToProcess = -1, this.cleanupSpikes_() && (e5 = true);
    let r = 0, o = false;
    do {
      o = false, this.m_nextVertexToProcess = -1, this.m_firstCoincidentVertex = this.m_sortedVertices.getFirst(this.m_sortedVerticesListIndex);
      const t4 = new mi(0, 0);
      this.m_firstCoincidentVertex !== pt.st_nullNode() && this.m_shape.queryXY(this.m_sortedVertices.getData(this.m_firstCoincidentVertex), t4);
      let s5 = 0, n6 = this.m_firstCoincidentVertex;
      for (; n6 !== pt.st_nullNode() && (n6 = this.m_sortedVertices.getNext(n6), n6 !== pt.st_nullNode()); ) {
        this.progress_();
        const e6 = this.m_sortedVertices.getData(n6), r2 = mi.getNAN();
        if (this.m_shape.queryXY(e6, r2), t4.equals(r2)) s5++;
        else {
          if (s5 > 0) {
            this.m_nextVertexToProcess = n6;
            const e7 = this.processBunch_();
            n6 = this.m_nextVertexToProcess, n6 !== pt.st_nullNode() && this.m_shape.queryXY(this.m_sortedVertices.getData(n6), r2), e7 && (o = true);
          }
          t4.setCoordsPoint2D(r2), this.m_firstCoincidentVertex = n6, s5 = 0;
        }
      }
      if (this.m_nextVertexToProcess = -1, s5 > 0) {
        this.processBunch_() && (o = true);
      }
      r++ > 10 && b(""), o && this.fixOrphanVertices_(), this.cleanupSpikes_() && (o = true), e5 ||= o;
    } while (o);
    return this.m_shape.dbgVerifyMonotone(), this.m_shape.dbgVerifyCurves(), this.m_shape.removeUserIndex(this.m_userIndexSortedIndexToVertex), this.m_shape.removeUserIndex(this.m_userIndexSortedAngleIndexToVertex), e5 = jn2(this.m_shape, this.m_geometry, this.m_sortedVertices, this.m_bFixSelfTangency, this.m_progressTracker) || e5, this.m_shape.dbgVerifyCurves(), e5;
  }
  getDirection_(e5, t3) {
    return this.m_shape.getNextVertex(t3) !== e5;
  }
  detectAndResolveCrossOver_(e5, t3, s4, n6, r, i2, o, a2) {
    if (n6 === o) return this.removeAngleSortInfo_(s4), this.removeAngleSortInfo_(i2), -1;
    const h2 = this.m_shape.getUserIndex(s4, this.m_userIndexSortedAngleIndexToVertex), m3 = this.m_shape.getUserIndex(r, this.m_userIndexSortedAngleIndexToVertex), l2 = this.m_shape.getUserIndex(i2, this.m_userIndexSortedAngleIndexToVertex), g2 = this.m_shape.getUserIndex(a2, this.m_userIndexSortedAngleIndexToVertex), u = Yt(8, Number.NaN), c = Yt(4, Number.NaN);
    u[0] = 0, c[0] = h2, u[1] = 0, c[1] = m3, u[2] = 1, c[2] = l2, u[3] = 1, c[3] = g2;
    for (let d2 = 1; d2 < 4; d2++) {
      const e6 = c[d2], t4 = u[d2];
      let s5 = d2 - 1;
      for (; s5 >= 0 && c[s5] > e6; ) c[s5 + 1] = c[s5], u[s5 + 1] = u[s5], s5--;
      c[s5 + 1] = e6, u[s5 + 1] = t4;
    }
    let _ = 0;
    if (u[0] && (_ |= 1), u[1] && (_ |= 2), u[2] && (_ |= 4), u[3] && (_ |= 8), 5 !== _ && 10 !== _) return 0;
    if (e5 !== t3 && (a2 = Pt(i2, i2 = a2)), e5) this.m_shape.setNextVertex(a2, n6), this.m_shape.setPrevVertex(n6, a2), this.m_shape.setNextVertex(r, o), this.m_shape.setPrevVertex(o, r), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageBreakVertex(n6, true), this.m_shape.setSegmentParentageBreakVertex(o, true));
    else {
      if (this.m_shape.setPrevVertex(a2, n6), this.m_shape.setNextVertex(n6, a2), this.m_shape.setPrevVertex(r, o), this.m_shape.setNextVertex(o, r), this.m_bHasSegmentParentage) {
        const e6 = this.m_shape.getSegmentParentage(n6), t4 = this.m_shape.getSegmentParentage(o);
        this.m_shape.setSegmentParentageAndBreak(n6, t4, true), this.m_shape.setSegmentParentageAndBreak(o, e6, true);
      }
      if (this.m_bHasSegments) {
        const e6 = this.m_shape.getVertexIndex(n6), t4 = this.m_shape.getVertexIndex(o), s5 = this.m_shape.getSegmentFromIndex(e6);
        this.m_shape.setSegmentToIndex(e6, null);
        const r2 = this.m_shape.getSegmentFromIndex(t4);
        this.m_shape.setSegmentToIndex(t4, null), this.m_shape.setSegmentToIndex(e6, r2), this.m_shape.setSegmentToIndex(t4, s5);
      }
    }
    return 1;
  }
  resolveOverlap_(e5, t3, s4, n6, r, i2) {
    return this.resolveOverlapOddEven_(e5, t3, s4, n6, r, i2);
  }
  resolveOverlapOddEven_(e5, t3, s4, n6, r, i2) {
    if (e5 !== t3) {
      e5 || (r = Pt(s4, s4 = r), i2 = Pt(n6, n6 = i2));
      const t4 = this.m_shape.getNextVertex(r), o = this.m_shape.getNextVertex(s4);
      if (this.m_shape.setNextVertex(s4, t4), this.m_shape.setPrevVertex(t4, s4), this.m_shape.setNextVertex(r, o), this.m_shape.setPrevVertex(o, r), this.m_bHasSegments) {
        const e6 = this.m_shape.getVertexIndex(s4), t5 = this.m_shape.getVertexIndex(r), n7 = this.m_shape.getSegmentFromIndex(e6);
        this.m_shape.setSegmentToIndex(e6, null);
        const i3 = this.m_shape.getSegmentFromIndex(t5);
        this.m_shape.setSegmentToIndex(t5, null), this.m_shape.setSegmentToIndex(e6, i3), this.m_shape.setSegmentToIndex(t5, n7);
      }
      if (this.m_bHasSegmentParentage) {
        const e6 = this.m_shape.getSegmentParentage(s4), t5 = this.m_shape.getSegmentParentage(r);
        this.m_shape.setSegmentParentageAndBreak(s4, t5, true), this.m_shape.setSegmentParentageAndBreak(r, e6, true), this.m_shape.setSegmentParentageBreakVertex(n6, true), this.m_shape.setSegmentParentageBreakVertex(i2, true);
      }
      this.removeSpike_(r);
    } else {
      const o = e5 ? s4 : n6, a2 = t3 ? r : i2, h2 = e5 ? n6 : s4, m3 = t3 ? i2 : r;
      let l2 = null;
      if (this.m_bHasSegments) {
        const e6 = this.m_shape.getVertexIndex(m3);
        l2 = this.m_shape.getSegmentFromIndex(e6), this.m_shape.setSegmentToIndex(e6, null);
        const t4 = this.m_shape.getVertexIndex(a2);
        this.m_shape.setSegmentToIndex(t4, null);
        const s5 = this.m_shape.getVertexIndex(o);
        this.m_shape.setSegmentToIndex(s5, null);
      }
      let g2 = -1;
      this.m_bHasSegmentParentage && (g2 = this.m_shape.getSegmentParentage(m3));
      let u = false;
      this.m_shape.setNextVertex(o, a2), this.m_shape.setNextVertex(a2, o), this.m_shape.setPrevVertex(h2, m3), this.m_shape.setPrevVertex(m3, h2);
      let c = m3;
      for (; c !== a2; ) {
        const e6 = this.m_shape.getPrevVertex(c), t4 = this.m_shape.getNextVertex(c);
        if (this.m_shape.setPrevVertex(c, t4), this.m_shape.setNextVertex(c, e6), u ||= c === o, this.m_bHasSegments && c !== o) {
          const e7 = this.m_shape.getVertexIndex(t4), s5 = l2;
          l2 = this.m_shape.getSegmentFromIndex(e7), null !== s5 && s5.reverse(), this.m_shape.setSegmentToIndex(e7, s5);
        }
        if (this.m_bHasSegmentParentage) {
          const e7 = this.m_shape.getSegmentParentage(t4);
          this.m_shape.setSegmentParentagePreserveBreak(t4, g2), g2 = e7;
        }
        c = t4;
      }
      let _ = null;
      if (!u) {
        const e6 = this.m_shape.getPrevVertex(a2), t4 = this.m_shape.getNextVertex(a2);
        if (this.m_shape.setPrevVertex(a2, t4), this.m_shape.setNextVertex(a2, e6), this.m_bHasSegments) {
          const e7 = this.m_shape.getVertexIndex(a2);
          _ = this.m_shape.getSegmentFromIndex(e7), this.m_shape.setSegmentToIndex(e7, null);
        }
      }
      let d2 = -1, p3 = -1;
      if (this.m_bHasSegmentParentage && (d2 = u ? this.m_shape.getSegmentParentage(o) : this.m_shape.getSegmentParentage(a2), p3 = this.m_shape.getSegmentParentage(h2)), this.transferVertexData_(a2, o), this.beforeRemoveVertex_(a2, true), this.m_shape.removeVertexInternal(a2, true), this.removeAngleSortInfo_(o), this.transferVertexData_(m3, h2), this.beforeRemoveVertex_(m3, true), this.m_shape.removeVertexInternal(m3, true), this.removeAngleSortInfo_(h2), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageAndBreak(o, d2, true), this.m_shape.setSegmentParentageAndBreak(h2, p3, true)), _) {
        const e6 = this.m_shape.getVertexIndex(o);
        this.m_shape.setSegmentToIndex(e6, _);
      }
    }
    return true;
  }
  cleanupSpikes_() {
    let e5 = false;
    for (let t3 = this.m_shape.getFirstPath(this.m_geometry); t3 !== cr; ) {
      const s4 = this.m_shape.getNextPath(t3);
      let n6 = this.m_shape.getFirstVertex(t3);
      for (let r = 0, i2 = this.m_shape.getPathSize(t3); r < i2 && i2 > 1; ) {
        this.progress_();
        const { v: s5, bModified: o } = this.checkAndCleanupSpike_(t3, n6);
        if (s5 === cr) break;
        o ? (e5 = true, n6 = s5, r = 0, i2 = this.m_shape.getPathSize(t3)) : (n6 = s5, r++);
      }
      t3 = s4;
    }
    return e5;
  }
  checkAndCleanupSpike_(e5, t3) {
    const s4 = { v: cr, bModified: false };
    let n6 = this.m_shape.getPrevVertex(t3), r = this.m_shape.getNextVertex(t3), i2 = cr, o = cr;
    for (; this.m_shape.isEqualXY(n6, r) && (i2 = n6, o = r, r !== t3); ) n6 = this.m_shape.getPrevVertex(n6), r = this.m_shape.getNextVertex(r);
    if (i2 === cr) return s4.v = r, s4;
    s4.bModified = true;
    for (let a2 = this.m_shape.getNextVertex(i2); this.beforeRemoveVertex_(a2, false), a2 !== o; a2 = this.m_shape.getNextVertex(a2)) ;
    if (i2 === t3) return this.m_polylineDegeneracies !== cr ? this.m_shape.movePath(this.m_polylineDegeneracies, cr, e5) : this.m_shape.removePath(e5), s4.v = cr, s4;
    {
      const e6 = this.m_shape.peelALoopIntoAPath(i2, o);
      this.m_polylineDegeneracies !== cr ? this.m_shape.movePath(this.m_polylineDegeneracies, cr, e6) : this.m_shape.removePath(e6);
    }
    return s4.v = i2, s4;
  }
  removeSpike_(e5) {
    let t3 = this.m_shape.getPrevVertex(e5), s4 = this.m_shape.getNextVertex(e5), n6 = cr, r = cr;
    for (; this.m_shape.isEqualXY(t3, s4) && (n6 = t3, r = s4, s4 !== e5); ) t3 = this.m_shape.getPrevVertex(t3), s4 = this.m_shape.getNextVertex(s4);
    if (n6 === cr) return false;
    if (this.m_shape.peelALoop(n6, r), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageBreakVertex(n6, true), this.m_shape.setSegmentParentageBreakVertex(r, true)), this.removeAngleSortInfo_(n6), this.m_polylineDegeneracies === cr) for (let i2 = this.m_shape.getNextVertex(r); ; ) {
      const e6 = this.m_shape.getNextVertex(i2);
      if (this.removeAngleSortInfo_(i2), this.beforeRemoveVertex_(i2, true), this.m_shape.setSegmentToIndex(this.m_shape.getVertexIndex(i2), null), this.m_shape.removeVertexInternal(i2, false), i2 === r) break;
      i2 = e6;
    }
    else {
      for (let t4 = r; ; ) {
        const e7 = this.m_shape.getNextVertex(t4);
        if (this.removeAngleSortInfo_(t4), this.beforeRemoveVertex_(t4, false), t4 = e7, t4 === r) break;
      }
      const e6 = [false];
      this.m_shape.insertClosedPath(this.m_polylineDegeneracies, cr, r, r, e6);
    }
    return true;
  }
  fixOrphanVertices_() {
    let e5 = 0;
    for (let n6 = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()); -1 !== n6; n6 = this.m_sortedVertices.getNext(n6)) {
      const e6 = this.m_sortedVertices.getData(n6);
      this.m_shape.setPathToVertex(e6, cr);
    }
    let t3 = 0;
    for (let n6 = this.m_shape.getFirstPath(this.m_geometry); n6 !== cr; ) {
      const s5 = this.m_shape.getFirstVertex(n6);
      if (s5 === cr || this.m_shape.getPathFromVertex(s5) !== cr) {
        const e6 = n6;
        n6 = this.m_shape.getNextPath(n6), this.m_shape.removePathOnly(e6);
        continue;
      }
      this.m_shape.setPathToVertex(s5, n6);
      let r = 1;
      for (let e6 = this.m_shape.getNextVertex(s5); e6 !== s5; e6 = this.m_shape.getNextVertex(e6)) this.m_shape.setPathToVertex(e6, n6), r++;
      this.m_shape.setRingAreaValid(n6, false), this.m_shape.setPathSize(n6, r), this.m_shape.setLastVertex(n6, this.m_shape.getPrevVertex(s5)), t3 += r, e5++, n6 = this.m_shape.getNextPath(n6);
    }
    for (let n6 = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()); -1 !== n6; n6 = this.m_sortedVertices.getNext(n6)) {
      const s5 = this.m_sortedVertices.getData(n6);
      if (this.m_shape.getPathFromVertex(s5) !== cr) continue;
      const r = [false], i2 = this.m_shape.insertClosedPath(this.m_geometry, cr, s5, s5, r);
      t3 += this.m_shape.getPathSize(i2), e5++;
    }
    this.m_shape.setGeometryPathCount(this.m_geometry, e5), this.m_shape.setGeometryVertexCount(this.m_geometry, t3);
    let s4 = 0;
    for (let n6 = this.m_shape.getFirstGeometry(); n6 !== cr; n6 = this.m_shape.getNextGeometry(n6)) s4 += this.m_shape.getPointCount(n6);
    this.m_shape.setTotalPointCount(s4);
  }
  getNextEdgeIndex_(e5) {
    if (-1 === e5) return -1;
    for (let t3 = 0, s4 = this.m_bunchEdgeIndices.length - 1; t3 < s4; t3++) if (e5 = (e5 + 1) % this.m_bunchEdgeIndices.length, -1 !== this.m_bunchEdgeIndices[e5]) return e5;
    return -1;
  }
  getPrevEdgeIndex_(e5) {
    if (-1 === e5) return -1;
    for (let t3 = 0, s4 = this.m_bunchEdgeIndices.length - 1; t3 < s4; t3++) if (e5 = (this.m_bunchEdgeIndices.length + e5 - 1) % this.m_bunchEdgeIndices.length, -1 !== this.m_bunchEdgeIndices[e5]) return e5;
    return -1;
  }
  transferVertexData_(e5, t3) {
    const s4 = this.m_shape.getUserIndex(t3, this.m_userIndexSortedIndexToVertex), n6 = this.m_shape.getUserIndex(t3, this.m_userIndexSortedAngleIndexToVertex);
    this.m_shape.transferAllDataToTheVertex(e5, t3), this.m_shape.setUserIndex(t3, this.m_userIndexSortedIndexToVertex, s4), this.m_shape.setUserIndex(t3, this.m_userIndexSortedAngleIndexToVertex, n6);
  }
  removeAngleSortInfo_(e5) {
    const t3 = this.m_shape.getUserIndex(e5, this.m_userIndexSortedAngleIndexToVertex);
    -1 !== t3 && (this.m_bunchEdgeIndices[t3] = -1, this.m_shape.setUserIndex(e5, this.m_userIndexSortedAngleIndexToVertex, -1));
  }
  progress_(e5 = false) {
  }
};
function sr2(s4, r, i2, o, a2, h2 = true) {
  switch (ir2(o)) {
    case 0:
      break;
    case 1:
      P("relation string length has to be 9 characters");
      break;
    default:
      P("relation string");
  }
  if (h2) {
    const e5 = xr2(o, s4.getDimension(), r.getDimension());
    if (0 !== e5) return kr2(s4, r, i2, e5, a2);
  }
  let m3 = 0;
  if ("number" == typeof i2) m3 = i2;
  else {
    const t3 = n4.constructEmpty();
    s4.queryEnvelope(t3);
    const n6 = n4.constructEmpty();
    r.queryEnvelope(n6);
    const o2 = n4.constructEmpty();
    o2.setCoords({ env2D: t3 }), o2.mergeEnvelope2D(n6), m3 = zt2(i2, o2, false);
  }
  const l2 = Tr2(s4, m3), g2 = Tr2(r, m3);
  if (l2.isEmpty() || g2.isEmpty()) return fr2(l2, g2, o);
  const u = l2.getGeometryType(), c = g2.getGeometryType();
  let _ = false;
  switch (u) {
    case a.enumPolygon:
      switch (c) {
        case a.enumPolygon:
          _ = or2(l2, g2, m3, o, a2);
          break;
        case a.enumPolyline:
          _ = ar2(l2, g2, m3, o, a2);
          break;
        case a.enumPoint:
          _ = ur2(l2, g2, m3, o);
          break;
        case a.enumMultiPoint:
          _ = hr2(l2, g2, m3, o, a2);
      }
      break;
    case a.enumPolyline:
      switch (c) {
        case a.enumPolygon:
          _ = ar2(g2, l2, m3, Gr2(o), a2);
          break;
        case a.enumPolyline:
          _ = mr2(l2, g2, m3, o, a2);
          break;
        case a.enumPoint:
          _ = cr2(l2, g2, m3, o, a2);
          break;
        case a.enumMultiPoint:
          _ = lr2(l2, g2, m3, o, a2);
      }
      break;
    case a.enumPoint:
      switch (c) {
        case a.enumPolygon:
          _ = ur2(g2, l2, m3, Gr2(o));
          break;
        case a.enumPolyline:
          _ = cr2(g2, l2, m3, Gr2(o), a2);
          break;
        case a.enumPoint:
          _ = dr2(l2, g2, m3, o);
          break;
        case a.enumMultiPoint:
          _ = _r2(g2, l2, m3, Gr2(o));
      }
      break;
    case a.enumMultiPoint:
      switch (c) {
        case a.enumPolygon:
          _ = hr2(g2, l2, m3, Gr2(o), a2);
          break;
        case a.enumPolyline:
          _ = lr2(g2, l2, m3, Gr2(o), a2);
          break;
        case a.enumMultiPoint:
          _ = gr2(l2, g2, m3, o, a2);
          break;
        case a.enumPoint:
          _ = _r2(l2, g2, m3, o);
      }
      break;
    default:
      _ = false;
  }
  return _;
}
function nr2(t3, s4, n6, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_("T*****F**"), i2.setAreaAreaPredicates_();
  const o = n4.constructEmpty(), a2 = n4.constructEmpty();
  t3.queryEnvelope(o), s4.queryEnvelope(a2);
  let h2 = false;
  if (qr2(o, a2, n6) && (i2.areaAreaDisjointPredicates_(t3, s4), h2 = true), h2 || Br2(t3, s4), h2) {
    return pr2(i2.m_matrix, i2.m_scl);
  }
  let m3 = new Pr(), l2 = m3.addGeometry(t3), g2 = m3.addGeometry(s4), u = null, c = 0;
  if (t3.hasNonLinearSegments() || s4.hasNonLinearSegments()) {
    u = new fa2();
    const e5 = _a2(n6, m3.getEnvelope2D(r));
    c = pa2(e5, 0), aa2(m3, e5, n6, 12e3, u, null, r);
  }
  ya2(m3, new Et2(n6, 0).add(c), r, false, false);
  const _ = m3.getGeometry(g2).getBoundary();
  if (m3.filterClosePoints(0, true, true, false, cr), er2(m3, l2, -1, false, cr, r), 0 === m3.getPointCount(l2)) return false;
  er2(m3, g2, -1, false, cr, r), i2.setEditShape_(m3, r);
  const d2 = 0 === m3.getPointCount(g2);
  if (!d2) {
    i2.computeMatrixTopoGraphHalfEdges_(l2, g2), i2.m_topoGraph.removeShape();
    const e5 = pr2(i2.m_matrix, i2.m_scl);
    if (!e5) return e5;
  }
  const p3 = m3.getGeometry(l2);
  m3 = new Pr(), l2 = m3.addGeometry(p3), g2 = m3.addGeometry(_), i2.setEditShape_(m3, r), i2.m_predicateCount = 0, i2.resetMatrix_(), i2.setPredicates_(d2 ? "T*****F**" : "******F**"), i2.setAreaLinePredicates_(), i2.computeMatrixTopoGraphHalfEdges_(l2, g2), i2.m_topoGraph.removeShape();
  return pr2(i2.m_matrix, i2.m_scl);
}
function rr2(t3, s4, n6, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_("T*****F**"), i2.setAreaLinePredicates_();
  const o = n4.constructEmpty(), a2 = n4.constructEmpty();
  t3.queryEnvelope(o), s4.queryEnvelope(a2);
  let h2 = false;
  if (qr2(o, a2, n6) && (i2.areaLineDisjointPredicates_(t3, s4), h2 = true), h2 || Br2(t3, s4), h2) {
    return pr2(i2.m_matrix, i2.m_scl);
  }
  const m3 = new Pr(), l2 = m3.addGeometry(t3), g2 = m3.addGeometry(s4);
  if (i2.setEditShapeCrackAndCluster_(m3, new Et2(n6, 0), r), 0 === m3.getPointCount(l2)) return false;
  i2.computeMatrixTopoGraphHalfEdges_(l2, g2), i2.m_topoGraph.removeShape();
  return pr2(i2.m_matrix, i2.m_scl);
}
function ir2(e5) {
  if (9 !== e5.length) return 1;
  for (let t3 = 0; t3 < 9; t3++) {
    const s4 = e5[t3];
    if ("*" !== s4 && "T" !== s4 && "F" !== s4 && "0" !== s4 && "1" !== s4 && "2" !== s4) return 2;
  }
  return 0;
}
function or2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setAreaAreaPredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t3.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m3 = false;
  if (qr2(a2, h2, n6) && (o.areaAreaDisjointPredicates_(t3, s4), m3 = true), m3 || Br2(t3, s4), !m3) {
    const e5 = new Pr(), r2 = e5.addGeometry(t3), a3 = e5.addGeometry(s4);
    o.setEditShapeCrackAndCluster_(e5, new Et2(n6, 0), i2), o.computeMatrixTopoGraphHalfEdges_(r2, a3), o.m_topoGraph.removeShape();
  }
  return pr2(o.m_matrix, o.m_scl);
}
function ar2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setAreaLinePredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t3.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m3 = false;
  if (qr2(a2, h2, n6) && (o.areaLineDisjointPredicates_(t3, s4), m3 = true), m3 || Br2(t3, s4), !m3) {
    const e5 = new Pr(), r2 = e5.addGeometry(t3), a3 = e5.addGeometry(s4);
    o.setEditShapeCrackAndCluster_(e5, new Et2(n6, 0), i2), o.m_clusterIndexB = o.m_topoGraph.createUserIndexForClusters(), wr2(a3, o.m_topoGraph, o.m_clusterIndexB), o.computeMatrixTopoGraphHalfEdges_(r2, a3), o.m_topoGraph.deleteUserIndexForClusters(o.m_clusterIndexB), o.m_topoGraph.removeShape();
  }
  return pr2(o.m_matrix, o.m_scl);
}
function hr2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setAreaPointPredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t3.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m3 = false;
  if (qr2(a2, h2, n6) && (o.areaPointDisjointPredicates_(t3), m3 = true), m3 || Br2(t3, s4), !m3) {
    const e5 = new Pr(), r2 = e5.addGeometry(t3), a3 = e5.addGeometry(s4);
    o.setEditShapeCrackAndCluster_(e5, new Et2(n6, 0), i2), o.computeMatrixTopoGraphClusters_(r2, a3), o.m_topoGraph.removeShape();
  }
  return pr2(o.m_matrix, o.m_scl);
}
function mr2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setLineLinePredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t3.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m3 = false;
  if (qr2(a2, h2, n6) && (o.lineLineDisjointPredicates_(t3, s4), m3 = true), m3 || Br2(t3, s4), !m3) {
    const e5 = new Pr(), r2 = e5.addGeometry(t3), a3 = e5.addGeometry(s4);
    o.setEditShapeCrackAndCluster_(e5, new Et2(n6, 0), i2), o.m_clusterIndexA = o.m_topoGraph.createUserIndexForClusters(), o.m_clusterIndexB = o.m_topoGraph.createUserIndexForClusters(), wr2(r2, o.m_topoGraph, o.m_clusterIndexA), wr2(a3, o.m_topoGraph, o.m_clusterIndexB), o.computeMatrixTopoGraphHalfEdges_(r2, a3), o.m_topoGraph.deleteUserIndexForClusters(o.m_clusterIndexA), o.m_topoGraph.deleteUserIndexForClusters(o.m_clusterIndexB), o.m_topoGraph.removeShape();
  }
  return pr2(o.m_matrix, o.m_scl);
}
function lr2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setLinePointPredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t3.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m3 = false;
  if (qr2(a2, h2, n6) && (o.linePointDisjointPredicates_(t3), m3 = true), m3 || Br2(t3, s4), !m3) {
    const e5 = new Pr(), r2 = e5.addGeometry(t3), a3 = e5.addGeometry(s4);
    o.setEditShapeCrackAndCluster_(e5, new Et2(n6, 0), i2), o.m_clusterIndexA = o.m_topoGraph.createUserIndexForClusters(), wr2(r2, o.m_topoGraph, o.m_clusterIndexA), o.computeMatrixTopoGraphClusters_(r2, a3), o.m_topoGraph.deleteUserIndexForClusters(o.m_clusterIndexA), o.m_topoGraph.removeShape();
  }
  return pr2(o.m_matrix, o.m_scl);
}
function gr2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setPointPointPredicates_();
  const a2 = new n4(), h2 = new n4();
  t3.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m3 = false;
  if (qr2(a2, h2, n6) && (o.pointPointDisjointPredicates_(), m3 = true), !m3) {
    const e5 = new Pr(), r2 = e5.addGeometry(t3), a3 = e5.addGeometry(s4);
    o.setEditShapeCrackAndCluster_(e5, new Et2(n6, 0), i2), o.computeMatrixTopoGraphClusters_(r2, a3), o.m_topoGraph.removeShape();
  }
  return pr2(o.m_matrix, o.m_scl);
}
function ur2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setAreaPointPredicates_();
  const a2 = n4.constructEmpty();
  t3.queryEnvelope(a2);
  const h2 = s4.getXY();
  let m3 = false;
  if (Or2(h2, a2, n6) && (o.areaPointDisjointPredicates_(t3), m3 = true), !m3) {
    const s5 = Lo2(t3, h2, n6);
    if (1 === s5) o.m_matrix[0] = 0, o.m_matrix[2] = 2, o.m_matrix[3] = -1, o.m_matrix[5] = 1, o.m_matrix[6] = -1;
    else if (2 === s5) {
      o.m_matrix[6] = -1;
      if (0 !== t3.calculateArea2D()) o.m_matrix[0] = -1, o.m_matrix[3] = 0, o.m_matrix[2] = 2, o.m_matrix[5] = 1;
      else {
        o.m_matrix[0] = 0, o.m_matrix[3] = -1, o.m_matrix[5] = -1;
        const s6 = n4.constructEmpty();
        t3.queryEnvelope(s6), o.m_matrix[2] = s6.height() || s6.width() ? 1 : -1;
      }
    } else o.areaPointDisjointPredicates_(t3);
  }
  return pr2(o.m_matrix, r);
}
function cr2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setLinePointPredicates_();
  const a2 = n4.constructEmpty();
  t3.queryEnvelope(a2);
  let h2 = false;
  if (Or2(s4.getXY(), a2, n6) && (o.linePointDisjointPredicates_(t3), h2 = true), !h2) {
    let e5 = null, r2 = false, a3 = false;
    if (o.m_performPredicates[0] || o.m_performPredicates[6]) {
      !kr2(t3, s4, n6, 4, i2) ? (o.m_performPredicates[0] && (e5 = Ks(t3), a3 = !kr2(e5, s4, n6, 4, i2), r2 = true, o.m_matrix[0] = a3 ? -1 : 0), o.m_matrix[6] = -1) : (o.m_matrix[0] = -1, o.m_matrix[6] = 0);
    }
    if (o.m_performPredicates[3] && (null !== e5 && e5.isEmpty() ? o.m_matrix[3] = -1 : (r2 || (null == e5 && (e5 = Ks(t3)), a3 = !kr2(e5, s4, n6, 4, i2), r2 = true), o.m_matrix[3] = a3 ? 0 : -1)), o.m_performPredicates[5]) if (null !== e5 && e5.isEmpty()) o.m_matrix[5] = -1;
    else if (r2 && !a3) o.m_matrix[5] = 0;
    else {
      null === e5 && (e5 = Ks(t3));
      const r3 = kr2(e5, s4, n6, 3, i2);
      o.m_matrix[5] = r3 ? -1 : 0;
    }
    if (o.m_performPredicates[2]) {
      if (0 !== t3.calculateLength2D()) o.m_matrix[2] = 1;
      else {
        const e6 = new Ee({ vd: t3.getDescription() });
        e6.addPoints(t3, 0, t3.getPointCount());
        const r3 = kr2(e6, s4, n6, 3, i2);
        o.m_matrix[2] = r3 ? -1 : 0;
      }
    }
  }
  return pr2(o.m_matrix, o.m_scl);
}
function _r2(t3, s4, n6, r, i2) {
  const o = new vr2();
  o.resetMatrix_(), o.setPredicates_(r), o.setPointPointPredicates_();
  const a2 = n4.constructEmpty();
  t3.queryEnvelope(a2);
  const h2 = s4.getXY(), m3 = new mi();
  let l2 = false;
  if (Or2(h2, a2, n6) && (o.pointPointDisjointPredicates_(), l2 = true), !l2) {
    let e5 = false, s5 = true;
    const r2 = n6 * n6;
    for (let n7 = 0; n7 < t3.getPointCount() && (t3.queryXY(n7, m3), mi.sqrDistance(m3, h2) <= r2 ? e5 = true : s5 = false, !e5 || s5); n7++) ;
    e5 ? (o.m_matrix[0] = 0, o.m_matrix[2] = s5 ? -1 : 0, o.m_matrix[6] = -1) : (o.m_matrix[0] = -1, o.m_matrix[2] = 0, o.m_matrix[6] = 0);
  }
  return pr2(o.m_matrix, r);
}
function dr2(e5, t3, s4, n6, r) {
  const i2 = e5.getXY(), o = t3.getXY(), a2 = Yt(9, -1);
  mi.sqrDistance(i2, o) <= s4 * s4 ? a2[0] = 0 : (a2[2] = 0, a2[6] = 0), a2[8] = 2;
  return pr2(a2, n6);
}
function pr2(e5, t3) {
  for (let s4 = 0; s4 < 9; s4++) switch (t3[s4]) {
    case "T":
      if (-1 === e5[s4]) return false;
      break;
    case "F":
      if (-1 !== e5[s4]) return false;
      break;
    case "0":
      if (0 !== e5[s4]) return false;
      break;
    case "1":
      if (1 !== e5[s4]) return false;
      break;
    case "2":
      if (2 !== e5[s4]) return false;
  }
  return true;
}
function fr2(t3, s4, r) {
  const i2 = Yt(9, -1);
  if (t3.isEmpty() && s4.isEmpty()) return pr2(i2, r);
  let a2, h2 = false;
  t3.isEmpty() ? (a2 = s4, h2 = true) : a2 = t3, i2[0] = -1, i2[1] = -1, i2[3] = -1, i2[4] = -1, i2[6] = -1, i2[7] = -1, i2[8] = 2;
  const m3 = a2.getGeometryType();
  if (h(m3)) if (m3 === a.enumPolygon) {
    if (0 !== a2.calculateArea2D()) i2[2] = 2, i2[5] = 1;
    else {
      i2[5] = -1;
      const t4 = n4.constructEmpty();
      a2.queryEnvelope(t4), i2[2] = t4.height() || t4.width() ? 1 : 0;
    }
  } else {
    const e5 = 0 !== a2.calculateLength2D();
    i2[2] = e5 ? 1 : 0, i2[5] = Js2(a2) ? 0 : -1;
  }
  else i2[2] = 0, i2[5] = -1;
  return h2 && Nr2(i2), pr2(i2, r);
}
function xr2(e5, t3, s4) {
  return yr2(e5) ? 3 : Pr2(e5) ? 4 : Er2(e5, t3, s4) ? 8 : Sr2(e5, t3, s4) ? 16 : Ir2(e5) ? 64 : Cr2(e5) ? 1 : br2(e5, t3, s4) ? 32 : 0;
}
function yr2(e5) {
  return "T*F**FFF*" === e5;
}
function Pr2(e5) {
  return "FF*FF****" === e5;
}
function Er2(e5, t3, s4) {
  return (0 !== t3 || 0 !== s4) && (2 === t3 && 2 === s4 ? "F***T****" === e5 : (2 === t3 || 1 === t3) && 0 === s4 && "F**T*****" === e5);
}
function Sr2(e5, t3, s4) {
  return t3 > s4 ? "T*****T**" === e5 : 1 === t3 && 1 === s4 && "0********" === e5;
}
function Cr2(e5) {
  return "T*****FF*" === e5;
}
function Ir2(e5) {
  return "T**FF*FF*" === e5;
}
function br2(e5, t3, s4) {
  return t3 === s4 && (1 !== t3 ? "T*T***T**" === e5 : "1*T***T**" === e5);
}
function wr2(e5, t3, s4) {
  const n6 = t3.getGeometryID(e5);
  for (let r = t3.getFirstCluster(); r !== cr; r = t3.getNextCluster(r)) {
    if (0 === (t3.getClusterParentage(r) & n6)) continue;
    const e6 = t3.getClusterHalfEdge(r);
    if (e6 === cr) {
      t3.setClusterUserIndex(r, s4, 0);
      continue;
    }
    let i2 = e6, o = 0;
    do {
      const e7 = i2;
      0 !== (t3.getHalfEdgeParentage(e7) & n6) && o++, i2 = t3.getHalfEdgeNext(t3.getHalfEdgeTwin(e7));
    } while (i2 !== e6);
    t3.setClusterUserIndex(r, s4, o);
  }
}
var vr2 = class {
  nullFunc() {
    return b("should not be called"), false;
  }
  constructor() {
    this.m_clusterIndexA = -1, this.m_clusterIndexB = -1, this.m_visitedIndex = -1, this.m_topoGraph = new tn2(), this.m_matrix = Yt(9, 0), this.m_maxDim = Yt(9, 0), this.m_performPredicates = Yt(9, false), this.m_scl = "", this.m_predicateCount = 0, this.m_predicatesHalfEdge = this.nullFunc, this.m_predicatesCluster = this.nullFunc;
  }
  resetMatrix_() {
    this.m_matrix.fill(-2), this.m_maxDim.fill(-2);
  }
  setPredicates_(e5) {
    this.m_scl = e5;
    for (let t3 = 0; t3 < 9; t3++) "*" !== this.m_scl[t3] ? (this.m_performPredicates[t3] = true, this.m_predicateCount++) : this.m_performPredicates[t3] = false;
  }
  setRemainingPredicatesToFalse_() {
    for (let e5 = 0; e5 < 9; e5++) this.m_performPredicates[e5] && -2 === this.m_matrix[e5] && (this.m_matrix[e5] = -1, this.m_performPredicates[e5] = false);
  }
  isPredicateKnown_(e5) {
    return -2 !== this.m_matrix[e5] && (-1 === this.m_matrix[e5] ? (this.m_performPredicates[e5] = false, this.m_predicateCount--, true) : "T" !== this.m_scl[e5] && "F" !== this.m_scl[e5] ? !(this.m_matrix[e5] < this.m_maxDim[e5]) && (this.m_performPredicates[e5] = false, this.m_predicateCount--, true) : (this.m_performPredicates[e5] = false, this.m_predicateCount--, true));
  }
  setAreaAreaPredicates_() {
    this.m_predicatesHalfEdge = this.areaAreaPredicates_, this.m_maxDim[0] = 2, this.m_maxDim[1] = 1, this.m_maxDim[2] = 2, this.m_maxDim[3] = 1, this.m_maxDim[4] = 1, this.m_maxDim[5] = 1, this.m_maxDim[6] = 2, this.m_maxDim[7] = 1, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setAreaLinePredicates_() {
    this.m_predicatesHalfEdge = this.areaLinePredicates_, this.m_predicatesCluster = this.areaPointPredicates_, this.m_maxDim[0] = 1, this.m_maxDim[1] = 0, this.m_maxDim[2] = 2, this.m_maxDim[3] = 1, this.m_maxDim[4] = 0, this.m_maxDim[5] = 1, this.m_maxDim[6] = 1, this.m_maxDim[7] = 0, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setLineLinePredicates_() {
    this.m_predicatesHalfEdge = this.lineLinePredicates_, this.m_predicatesCluster = this.linePointPredicates_, this.m_maxDim[0] = 1, this.m_maxDim[1] = 0, this.m_maxDim[2] = 1, this.m_maxDim[3] = 0, this.m_maxDim[4] = 0, this.m_maxDim[5] = 0, this.m_maxDim[6] = 1, this.m_maxDim[7] = 0, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setAreaPointPredicates_() {
    this.m_predicatesCluster = this.areaPointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 2, this.m_maxDim[3] = 0, this.m_maxDim[4] = -1, this.m_maxDim[5] = 1, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setLinePointPredicates_() {
    this.m_predicatesCluster = this.linePointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 1, this.m_maxDim[3] = 0, this.m_maxDim[4] = -1, this.m_maxDim[5] = 0, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setPointPointPredicates_() {
    this.m_predicatesCluster = this.pointPointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 0, this.m_maxDim[3] = -1, this.m_maxDim[4] = -1, this.m_maxDim[5] = -1, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[3] && (this.m_matrix[3] = -1, this.m_performPredicates[3] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[5] && (this.m_matrix[5] = -1, this.m_performPredicates[5] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  areaAreaDisjointPredicates_(e5, t3) {
    this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.areaGeomContainsOrDisjointPredicates_(e5, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]), this.areaGeomContainsOrDisjointPredicates_(t3, this.m_performPredicates[6] ? 6 : -1, this.m_scl[6], this.m_performPredicates[7] ? 7 : -1, this.m_scl[7]);
  }
  areaGeomContainsOrDisjointPredicates_(t3, s4, n6, r, i2) {
    const o = -1 !== s4, a2 = -1 !== r;
    if (o || a2) {
      if (!("T" !== n6 && "F" !== n6 && o || "T" !== i2 && "F" !== i2 && a2) || 0 !== t3.calculateArea2D()) o && (this.m_matrix[s4] = 2), a2 && (this.m_matrix[r] = 1);
      else if (a2 && (this.m_matrix[r] = -1), o) {
        const n7 = n4.constructEmpty();
        t3.queryEnvelope(n7), this.m_matrix[s4] = n7.height() || n7.width() ? 1 : 0;
      }
    }
  }
  areaAreaContainsPredicates_(e5) {
    this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1, this.m_matrix[7] = -1, this.areaGeomContainsOrDisjointPredicates_(e5, this.m_performPredicates[0] ? 0 : -1, this.m_scl[0], this.m_performPredicates[1] ? 1 : -1, this.m_scl[1]);
  }
  areaAreaWithinPredicates_(e5) {
    this.areaAreaContainsPredicates_(e5), Nr2(this.m_matrix);
  }
  areaLineDisjointPredicates_(e5, t3) {
    if (this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_performPredicates[6]) {
      const e6 = this.m_scl[6], s4 = "T" === e6 || "F" === e6 || 0 !== t3.calculateLength2D();
      this.m_matrix[6] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[7]) {
      const e6 = Js2(t3);
      this.m_matrix[7] = e6 ? 0 : -1;
    }
    this.areaGeomContainsOrDisjointPredicates_(e5, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]);
  }
  areaLineContainsPredicates_(e5, t3) {
    if (this.m_performPredicates[0]) {
      const e6 = this.m_scl[0], s4 = "T" === e6 || "F" === e6 || 0 !== t3.calculateLength2D();
      this.m_matrix[0] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[1]) {
      const e6 = Js2(t3);
      this.m_matrix[1] = e6 ? 0 : -1;
    }
    this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1, this.m_matrix[7] = -1;
  }
  areaPointDisjointPredicates_(e5) {
    this.m_matrix[0] = -1, this.m_matrix[3] = -1, this.m_matrix[6] = 0, this.areaGeomContainsOrDisjointPredicates_(e5, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]);
  }
  areaPointContainsPredicates_(e5) {
    this.m_matrix[0] = 0, this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1;
  }
  lineLineDisjointPredicates_(e5, t3) {
    if (this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_performPredicates[2]) {
      const t4 = this.m_scl[2], s4 = "T" === t4 || "F" === t4 || 0 !== e5.calculateLength2D();
      this.m_matrix[2] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[5]) {
      const t4 = Js2(e5);
      this.m_matrix[5] = t4 ? 0 : -1;
    }
    if (this.m_performPredicates[6]) {
      const e6 = this.m_scl[6], s4 = "T" === e6 || "F" === e6 || 0 !== t3.calculateLength2D();
      this.m_matrix[6] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[7]) {
      const e6 = Js2(t3);
      this.m_matrix[7] = e6 ? 0 : -1;
    }
  }
  linePointDisjointPredicates_(e5) {
    if (this.m_matrix[0] = -1, this.m_matrix[3] = -1, this.m_performPredicates[2]) {
      const t3 = this.m_scl[2], s4 = "T" === t3 || "F" === t3 || 0 !== e5.calculateLength2D();
      this.m_matrix[2] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[5]) {
      const t3 = Js2(e5);
      this.m_matrix[5] = t3 ? 0 : -1;
    }
    this.m_matrix[6] = 0;
  }
  pointPointDisjointPredicates_() {
    this.m_matrix[0] = -1, this.m_matrix[2] = 0, this.m_matrix[6] = 0;
  }
  areaAreaPredicates_(e5, t3, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorArea_(e5, t3, s4);
      const r = this.isPredicateKnown_(0);
      n6 &&= r;
    }
    if (this.m_performPredicates[1]) {
      this.interiorAreaBoundaryArea_(e5, t3, 1);
      const s5 = this.isPredicateKnown_(1);
      n6 &&= s5;
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorArea_(e5, t3, s4, 2);
      const r = this.isPredicateKnown_(2);
      n6 &&= r;
    }
    if (this.m_performPredicates[3]) {
      this.interiorAreaBoundaryArea_(e5, s4, 3);
      const t4 = this.isPredicateKnown_(3);
      n6 &&= t4;
    }
    if (this.m_performPredicates[4]) {
      this.boundaryAreaBoundaryArea_(e5, t3, s4);
      const r = this.isPredicateKnown_(4);
      n6 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorArea_(e5, t3, s4, 5);
      const r = this.isPredicateKnown_(5);
      n6 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.interiorAreaExteriorArea_(e5, s4, t3, 6);
      const r = this.isPredicateKnown_(6);
      n6 &&= r;
    }
    if (this.m_performPredicates[7]) {
      this.boundaryAreaExteriorArea_(e5, s4, t3, 7);
      const r = this.isPredicateKnown_(7);
      n6 &&= r;
    }
    return n6;
  }
  areaLinePredicates_(e5, t3, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorLine_(e5, t3, s4);
      const r = this.isPredicateKnown_(0);
      n6 &&= r;
    }
    if (this.m_performPredicates[1]) {
      this.interiorAreaBoundaryLine_(e5, t3, s4, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(1);
      n6 &&= r;
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorLine_(e5, t3, s4);
      const r = this.isPredicateKnown_(2);
      n6 &&= r;
    }
    if (this.m_performPredicates[3]) {
      this.boundaryAreaInteriorLine_(e5, t3, s4, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(3);
      n6 &&= r;
    }
    if (this.m_performPredicates[4]) {
      this.boundaryAreaBoundaryLine_(e5, t3, s4, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(4);
      n6 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorLine_(e5, t3, s4);
      const r = this.isPredicateKnown_(5);
      n6 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.exteriorAreaInteriorLine_(e5, t3);
      const s5 = this.isPredicateKnown_(6);
      n6 &&= s5;
    }
    if (this.m_performPredicates[7]) {
      this.exteriorAreaBoundaryLine_(e5, t3, s4, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(7);
      n6 &&= r;
    }
    return n6;
  }
  lineLinePredicates_(e5, t3, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorLineInteriorLine_(e5, t3, s4, this.m_clusterIndexA, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(0);
      n6 &&= r;
    }
    if (this.m_performPredicates[1]) {
      this.interiorLineBoundaryLine_(e5, t3, s4, this.m_clusterIndexA, this.m_clusterIndexB, 1);
      const r = this.isPredicateKnown_(1);
      n6 &&= r;
    }
    if (this.m_performPredicates[2]) {
      this.interiorLineExteriorLine_(e5, t3, s4, 2);
      const r = this.isPredicateKnown_(2);
      n6 &&= r;
    }
    if (this.m_performPredicates[3]) {
      this.interiorLineBoundaryLine_(e5, s4, t3, this.m_clusterIndexB, this.m_clusterIndexA, 3);
      const r = this.isPredicateKnown_(3);
      n6 &&= r;
    }
    if (this.m_performPredicates[4]) {
      this.boundaryLineBoundaryLine_(e5, t3, s4, this.m_clusterIndexA, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(4);
      n6 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryLineExteriorLine_(e5, t3, s4, this.m_clusterIndexA, 5);
      const r = this.isPredicateKnown_(5);
      n6 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.interiorLineExteriorLine_(e5, s4, t3, 6);
      const r = this.isPredicateKnown_(6);
      n6 &&= r;
    }
    if (this.m_performPredicates[7]) {
      this.boundaryLineExteriorLine_(e5, s4, t3, this.m_clusterIndexB, 7);
      const r = this.isPredicateKnown_(7);
      n6 &&= r;
    }
    return n6;
  }
  areaPointPredicates_(e5, t3, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorPoint_(e5, t3);
      const s5 = this.isPredicateKnown_(0);
      n6 &&= s5;
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorPoint_(e5, t3);
      const s5 = this.isPredicateKnown_(2);
      n6 &&= s5;
    }
    if (this.m_performPredicates[3]) {
      this.boundaryAreaInteriorPoint_(e5, t3, s4);
      const r = this.isPredicateKnown_(3);
      n6 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorPoint_(e5, t3);
      const s5 = this.isPredicateKnown_(5);
      n6 &&= s5;
    }
    if (this.m_performPredicates[6]) {
      this.exteriorAreaInteriorPoint_(e5, t3);
      const s5 = this.isPredicateKnown_(6);
      n6 &&= s5;
    }
    return n6;
  }
  linePointPredicates_(e5, t3, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorLineInteriorPoint_(e5, t3, s4, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(0);
      n6 &&= r;
    }
    if (this.m_performPredicates[2]) {
      this.interiorLineExteriorPoint_(e5, t3, s4, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(2);
      n6 &&= r;
    }
    if (this.m_performPredicates[3]) {
      this.boundaryLineInteriorPoint_(e5, t3, s4, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(3);
      n6 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryLineExteriorPoint_(e5, t3, s4, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(5);
      n6 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.exteriorLineInteriorPoint_(e5, t3, s4);
      const r = this.isPredicateKnown_(6);
      n6 &&= r;
    }
    return n6;
  }
  pointPointPredicates_(e5, t3, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorPointInteriorPoint_(e5, t3, s4);
      const r = this.isPredicateKnown_(0);
      n6 &&= r;
    }
    if (this.m_performPredicates[2]) {
      this.interiorPointExteriorPoint_(e5, t3, s4, 2);
      const r = this.isPredicateKnown_(2);
      n6 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.interiorPointExteriorPoint_(e5, s4, t3, 6);
      const r = this.isPredicateKnown_(6);
      n6 &&= r;
    }
    return n6;
  }
  interiorAreaInteriorArea_(e5, t3, s4) {
    if (2 === this.m_matrix[0]) return;
    const n6 = this.m_topoGraph.getHalfEdgeFaceParentage(e5);
    0 !== (n6 & t3) && 0 !== (n6 & s4) && (this.m_matrix[0] = 2);
  }
  interiorAreaBoundaryArea_(e5, t3, s4) {
    if (1 === this.m_matrix[s4]) return;
    const n6 = this.m_topoGraph.getHalfEdgeFaceParentage(e5), r = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
    0 !== (n6 & t3) && 0 !== (r & t3) && (this.m_matrix[s4] = 1);
  }
  interiorAreaExteriorArea_(e5, t3, s4, n6) {
    if (2 === this.m_matrix[n6]) return;
    const r = this.m_topoGraph.getHalfEdgeFaceParentage(e5);
    0 !== (r & t3) && 0 === (r & s4) && (this.m_matrix[n6] = 2);
  }
  boundaryAreaBoundaryArea_(e5, t3, s4) {
    if (1 === this.m_matrix[4]) return;
    const n6 = this.m_topoGraph.getHalfEdgeParentage(e5);
    if (0 === (n6 & t3) || 0 === (n6 & s4)) {
      if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
        const n7 = this.m_topoGraph.getHalfEdgeTo(e5), r = this.m_topoGraph.getClusterParentage(n7);
        if (0 !== (r & t3) && 0 !== (r & s4)) return void (this.m_matrix[4] = 0);
      }
    } else this.m_matrix[4] = 1;
  }
  boundaryAreaExteriorArea_(e5, t3, s4, n6) {
    if (1 === this.m_matrix[n6]) return;
    const r = this.m_topoGraph.getHalfEdgeFaceParentage(e5), i2 = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
    0 === (r & s4) && 0 === (i2 & s4) && (this.m_matrix[n6] = 1);
  }
  interiorAreaInteriorLine_(e5, t3, s4) {
    if (1 === this.m_matrix[0]) return;
    const n6 = this.m_topoGraph.getHalfEdgeFaceParentage(e5), r = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
    0 !== (n6 & t3) && 0 !== (r & t3) && (this.m_matrix[0] = 1);
  }
  interiorAreaBoundaryLine_(e5, t3, s4, n6) {
    if (0 !== this.m_matrix[1] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e5), i2 = this.m_topoGraph.getClusterParentage(r);
      if (0 === (i2 & t3)) {
        if (0 !== (this.m_topoGraph.getHalfEdgeFaceParentage(e5) & t3)) {
          const e6 = this.m_topoGraph.getClusterUserIndex(r, n6);
          if (0 !== (i2 & s4) && e6 % 2 != 0) return void (this.m_matrix[1] = 0);
        }
      }
    }
  }
  interiorAreaExteriorLine_(e5, t3, s4) {
    if (2 === this.m_matrix[2]) return;
    0 !== (this.m_topoGraph.getHalfEdgeParentage(e5) & t3) && (this.m_matrix[2] = 2);
  }
  boundaryAreaInteriorLine_(e5, t3, s4, n6) {
    if (1 === this.m_matrix[3]) return;
    const r = this.m_topoGraph.getHalfEdgeParentage(e5);
    if (0 === (r & t3) || 0 === (r & s4)) {
      if (0 !== this.m_matrix[3] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
        const r2 = this.m_topoGraph.getHalfEdgeTo(e5), i2 = this.m_topoGraph.getClusterParentage(r2);
        if (0 !== (i2 & t3)) {
          const e6 = this.m_topoGraph.getClusterUserIndex(r2, n6);
          if (0 !== (i2 & s4) && e6 % 2 == 0) return void (this.m_matrix[3] = 0);
        }
      }
    } else this.m_matrix[3] = 1;
  }
  boundaryAreaBoundaryLine_(e5, t3, s4, n6) {
    if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e5), i2 = this.m_topoGraph.getClusterParentage(r);
      if (0 !== (i2 & t3)) {
        const e6 = this.m_topoGraph.getClusterUserIndex(r, n6);
        if (0 !== (i2 & s4) && e6 % 2 != 0) return void (this.m_matrix[4] = 0);
      }
    }
  }
  boundaryAreaExteriorLine_(e5, t3, s4) {
    if (1 === this.m_matrix[5]) return;
    const n6 = this.m_topoGraph.getHalfEdgeParentage(e5);
    0 !== (n6 & t3) && 0 === (n6 & s4) && (this.m_matrix[5] = 1);
  }
  exteriorAreaInteriorLine_(e5, t3) {
    if (1 === this.m_matrix[6]) return;
    const s4 = this.m_topoGraph.getHalfEdgeFaceParentage(e5), n6 = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
    0 === (s4 & t3) && 0 === (n6 & t3) && (this.m_matrix[6] = 1);
  }
  exteriorAreaBoundaryLine_(e5, t3, s4, n6) {
    if (0 !== this.m_matrix[7] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e5), i2 = this.m_topoGraph.getClusterParentage(r);
      if (0 === (i2 & t3)) {
        if (0 === (this.m_topoGraph.getHalfEdgeFaceParentage(e5) & t3)) {
          const e6 = this.m_topoGraph.getClusterUserIndex(r, n6);
          if (0 !== (i2 & s4) && e6 % 2 != 0) return void (this.m_matrix[7] = 0);
        }
      }
    }
  }
  interiorLineInteriorLine_(e5, t3, s4, n6, r) {
    if (1 === this.m_matrix[0]) return;
    const i2 = this.m_topoGraph.getHalfEdgeParentage(e5);
    if (0 === (i2 & t3) || 0 === (i2 & s4)) {
      if (0 !== this.m_matrix[0] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
        const i3 = this.m_topoGraph.getHalfEdgeTo(e5), o = this.m_topoGraph.getClusterParentage(i3);
        if (0 !== (o & t3) && 0 !== (o & s4)) {
          const e6 = this.m_topoGraph.getClusterUserIndex(i3, n6), t4 = this.m_topoGraph.getClusterUserIndex(i3, r);
          if (e6 % 2 == 0 && t4 % 2 == 0) return void (this.m_matrix[0] = 0);
        }
      }
    } else this.m_matrix[0] = 1;
  }
  interiorLineBoundaryLine_(e5, t3, s4, n6, r, i2) {
    if (0 !== this.m_matrix[i2] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const o = this.m_topoGraph.getHalfEdgeTo(e5), a2 = this.m_topoGraph.getClusterParentage(o);
      if (0 !== (a2 & t3) && 0 !== (a2 & s4)) {
        const e6 = this.m_topoGraph.getClusterUserIndex(o, n6), t4 = this.m_topoGraph.getClusterUserIndex(o, r);
        if (e6 % 2 == 0 && t4 % 2 != 0) return void (this.m_matrix[i2] = 0);
      }
    }
  }
  interiorLineExteriorLine_(e5, t3, s4, n6) {
    if (1 === this.m_matrix[n6]) return;
    const r = this.m_topoGraph.getHalfEdgeParentage(e5);
    0 !== (r & t3) && 0 === (r & s4) && (this.m_matrix[n6] = 1);
  }
  boundaryLineBoundaryLine_(e5, t3, s4, n6, r) {
    if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const i2 = this.m_topoGraph.getHalfEdgeTo(e5), o = this.m_topoGraph.getClusterParentage(i2);
      if (0 !== (o & t3) && 0 !== (o & s4)) {
        const e6 = this.m_topoGraph.getClusterUserIndex(i2, n6), t4 = this.m_topoGraph.getClusterUserIndex(i2, r);
        if (e6 % 2 != 0 && t4 % 2 != 0) return void (this.m_matrix[4] = 0);
      }
    }
  }
  boundaryLineExteriorLine_(e5, t3, s4, n6, r) {
    if (0 !== this.m_matrix[r] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const t4 = this.m_topoGraph.getHalfEdgeTo(e5);
      if (0 === (this.m_topoGraph.getClusterParentage(t4) & s4)) {
        if (this.m_topoGraph.getClusterUserIndex(t4, n6) % 2 != 0) return void (this.m_matrix[r] = 0);
      }
    }
  }
  interiorAreaInteriorPoint_(e5, t3) {
    if (0 === this.m_matrix[0]) return;
    if (0 === (this.m_topoGraph.getClusterParentage(e5) & t3)) {
      const s4 = this.m_topoGraph.getClusterChain(e5);
      if (0 !== (this.m_topoGraph.getChainParentage(s4) & t3)) return void (this.m_matrix[0] = 0);
    }
  }
  interiorAreaExteriorPoint_(e5, t3) {
    if (2 === this.m_matrix[2]) return;
    0 !== (this.m_topoGraph.getClusterParentage(e5) & t3) && (this.m_matrix[2] = 2);
  }
  boundaryAreaInteriorPoint_(e5, t3, s4) {
    if (0 === this.m_matrix[3]) return;
    const n6 = this.m_topoGraph.getClusterParentage(e5);
    0 === (n6 & t3) || 0 === (n6 & s4) || (this.m_matrix[3] = 0);
  }
  boundaryAreaExteriorPoint_(e5, t3) {
    if (1 === this.m_matrix[5]) return;
    0 !== (this.m_topoGraph.getClusterParentage(e5) & t3) && (this.m_matrix[5] = 1);
  }
  exteriorAreaInteriorPoint_(e5, t3) {
    if (0 === this.m_matrix[6]) return;
    if (0 === (this.m_topoGraph.getClusterParentage(e5) & t3)) {
      const s4 = this.m_topoGraph.getClusterChain(e5);
      if (0 === (this.m_topoGraph.getChainParentage(s4) & t3)) return void (this.m_matrix[6] = 0);
    }
  }
  interiorLineInteriorPoint_(e5, t3, s4, n6) {
    if (0 === this.m_matrix[0]) return;
    const r = this.m_topoGraph.getClusterParentage(e5);
    if (0 !== (r & t3) && 0 !== (r & s4)) {
      if (this.m_topoGraph.getClusterUserIndex(e5, n6) % 2 == 0) return void (this.m_matrix[0] = 0);
    }
  }
  interiorLineExteriorPoint_(e5, t3, s4, n6) {
    if (1 === this.m_matrix[2]) return;
    if (-1 === this.m_topoGraph.getClusterHalfEdge(e5)) {
      if (0 !== this.m_matrix[2]) {
        if (0 === (this.m_topoGraph.getClusterParentage(e5) & s4)) return void (this.m_matrix[2] = 0);
      }
    } else this.m_matrix[2] = 1;
  }
  boundaryLineInteriorPoint_(e5, t3, s4, n6) {
    if (0 === this.m_matrix[3]) return;
    const r = this.m_topoGraph.getClusterParentage(e5);
    if (0 !== (r & t3) && 0 !== (r & s4)) {
      if (this.m_topoGraph.getClusterUserIndex(e5, n6) % 2 != 0) return void (this.m_matrix[3] = 0);
    }
  }
  boundaryLineExteriorPoint_(e5, t3, s4, n6) {
    if (0 === this.m_matrix[5]) return;
    const r = this.m_topoGraph.getClusterParentage(e5);
    if (0 !== (r & t3) && 0 === (r & s4)) {
      if (this.m_topoGraph.getClusterUserIndex(e5, n6) % 2 != 0) return void (this.m_matrix[5] = 0);
    }
  }
  exteriorLineInteriorPoint_(e5, t3, s4) {
    if (0 === this.m_matrix[6]) return;
    const n6 = this.m_topoGraph.getClusterParentage(e5);
    0 !== (n6 & t3) || 0 === (n6 & s4) || (this.m_matrix[6] = 0);
  }
  interiorPointInteriorPoint_(e5, t3, s4) {
    if (0 === this.m_matrix[0]) return;
    const n6 = this.m_topoGraph.getClusterParentage(e5);
    0 === (n6 & t3) || 0 === (n6 & s4) || (this.m_matrix[0] = 0);
  }
  interiorPointExteriorPoint_(e5, t3, s4, n6) {
    if (0 === this.m_matrix[n6]) return;
    const r = this.m_topoGraph.getClusterParentage(e5);
    0 === (r & t3) || 0 !== (r & s4) || (this.m_matrix[n6] = 0);
  }
  computeMatrixTopoGraphHalfEdges_(e5, t3) {
    let s4 = false;
    const n6 = this.m_topoGraph.getGeometryID(e5), r = this.m_topoGraph.getGeometryID(t3);
    this.m_visitedIndex = this.m_topoGraph.createUserIndexForHalfEdges();
    for (let i2 = this.m_topoGraph.getFirstCluster(); i2 !== cr; i2 = this.m_topoGraph.getNextCluster(i2)) {
      const e6 = this.m_topoGraph.getClusterHalfEdge(i2);
      if (e6 === cr) {
        if (null !== this.m_predicatesCluster && (s4 = this.m_predicatesCluster(i2, n6, r), s4)) break;
        continue;
      }
      let t4 = e6;
      do {
        let e7 = t4;
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(e7, this.m_visitedIndex)) do {
          if (s4 = this.m_predicatesHalfEdge(e7, n6, r), s4) break;
          this.m_topoGraph.setHalfEdgeUserIndex(e7, this.m_visitedIndex, 1), e7 = this.m_topoGraph.getHalfEdgeNext(e7);
        } while (e7 !== t4 && !s4);
        if (s4) break;
        t4 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(e7));
      } while (t4 !== e6);
      if (s4) break;
    }
    s4 || this.setRemainingPredicatesToFalse_(), this.m_topoGraph.deleteUserIndexForHalfEdges(this.m_visitedIndex);
  }
  computeMatrixTopoGraphClusters_(e5, t3) {
    let s4 = false;
    const n6 = this.m_topoGraph.getGeometryID(e5), r = this.m_topoGraph.getGeometryID(t3);
    for (let i2 = this.m_topoGraph.getFirstCluster(); i2 !== cr && (s4 = this.m_predicatesCluster(i2, n6, r), !s4); i2 = this.m_topoGraph.getNextCluster(i2)) ;
    s4 || this.setRemainingPredicatesToFalse_();
  }
  setEditShape_(e5, t3) {
    this.m_topoGraph.setEditShape(e5, t3);
  }
  setEditShapeCrackAndCluster_(e5, t3, s4) {
    let r = 0;
    if (e5.hasCurves()) {
      const n6 = new fa2(), i2 = e5.getEnvelope2D(s4), o = _a2(t3.total(), i2);
      r = pa2(o, 0), aa2(e5, o, t3.total(), 12e3, n6, null, s4), n6.clearStitcher(e5);
    }
    ya2(e5, t3.add(r), s4, false, false), e5.filterClosePoints(0, true, true, false, cr);
    for (let i2 = e5.getFirstGeometry(); i2 !== cr; i2 = e5.getNextGeometry(i2)) e5.getGeometryType(i2) === a.enumPolygon && er2(e5, i2, -1, false, cr, s4);
    this.setEditShape_(e5, s4);
  }
};
function Nr2(e5) {
  const t3 = e5[1], s4 = e5[2], n6 = e5[5];
  e5[1] = e5[3], e5[2] = e5[6], e5[5] = e5[7], e5[3] = t3, e5[6] = s4, e5[7] = n6;
}
function Tr2(t3, s4, i2) {
  const o = t3.getGeometryType();
  if (f(o)) {
    const e5 = new Os2({ vd: t3.getDescription() });
    return e5.addSegment(t3, true), e5;
  }
  if (o === a.enumEnvelope) {
    const n6 = t3, r = n4.constructEmpty();
    if (t3.queryEnvelope(r), r.height() <= s4 && r.width() <= s4) {
      const e5 = new ee({ vd: t3.getDescription() });
      return n6.getCenter(e5), e5;
    }
    if (r.height() <= s4 || r.width() <= s4) {
      const e5 = new Os2({ vd: t3.getDescription() }), s5 = new ee();
      return n6.queryCornerByVal(0, s5), e5.startPathPoint(s5), n6.queryCornerByVal(2, s5), e5.lineToPoint(s5), e5;
    }
    const i3 = new ur({ vd: t3.getDescription() });
    return i3.addEnvelope(n6, false), i3;
  }
  return t3;
}
function Gr2(e5) {
  return `${e5[0]}${e5[3]}${e5[6]}${e5[1]}${e5[4]}${e5[7]}${e5[2]}${e5[5]}${e5[8]}`;
}
var Dr2 = class {
  nullFunc() {
    return b("should not be called"), false;
  }
  constructor(t3, s4, n6, r = false) {
    this.m_bDone = false, this.m_tolerance = 0, this.m_elementHandle = -1, this.m_query = n4.constructEmpty(), this.m_envInter = n4.constructEmpty(), this.m_quadTree = null, this.m_intersector = null, this.m_function = this.nullFunc;
    const i2 = t3.getAccelerators();
    let a2 = null;
    null != i2 && (a2 = r ? i2.getQuadTreeForPaths() : i2.getQuadTree());
    const h2 = s4.getAccelerators();
    let m3 = null;
    if (null != h2 && (m3 = r ? h2.getQuadTreeForPaths() : h2.getQuadTree()), null === a2 && null === m3 && !r) {
      const r2 = t3.getPointCount(), i3 = s4.getPointCount();
      if (r2 > 10 && i3 > 10) {
        const h3 = n4.constructEmpty(), l2 = n4.constructEmpty(), g2 = n4.constructEmpty();
        t3.queryLooseEnvelope(h3), s4.queryLooseEnvelope(l2), h3.inflateCoords(n6, n6), l2.inflateCoords(n6, n6), g2.setCoords({ env2D: h3 }), g2.intersect(l2), r2 >= i3 ? a2 = h(t3.getGeometryType()) ? Wt2(t3, g2) : Jt2(t3, g2) : m3 = h(s4.getGeometryType()) ? Wt2(s4, g2) : Jt2(s4, g2);
      }
    }
    this.construct_(t3, a2, s4, m3, n6, r);
  }
  next() {
    if (this.m_bQuadTree) {
      if (this.m_bDone) return false;
      for (; this.m_function(); ) ;
      return !this.m_bDone;
    }
    return !!this.m_intersector && this.m_intersector.next();
  }
  getRedElement() {
    return this.m_bQuadTree ? this.m_bSwapElements ? this.m_quadTree.getElement(this.m_elementHandle) : h(this.m_queryType) ? this.m_bPaths ? this.m_pathIndex : this.m_segIter.getStartPointIndex() : this.m_pointIndex : this.m_bSwapElements ? this.m_intersector.getBlueElement(this.m_intersector.getHandleB()) : this.m_intersector.getRedElement(this.m_intersector.getHandleA());
  }
  getBlueElement() {
    return this.m_bQuadTree ? this.m_bSwapElements ? h(this.m_queryType) ? this.m_bPaths ? this.m_pathIndex : this.m_segIter.getStartPointIndex() : this.m_pointIndex : this.m_quadTree.getElement(this.m_elementHandle) : this.m_bSwapElements ? this.m_intersector.getRedElement(this.m_intersector.getHandleA()) : this.m_intersector.getBlueElement(this.m_intersector.getHandleB());
  }
  getRedEnvelope() {
    return this.m_bPaths || C(""), this.m_bQuadTree ? this.m_bSwapElements ? this.m_quadTree.getElementExtent(this.m_elementHandle) : this.m_query : this.m_bSwapElements ? this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB()) : this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA());
  }
  getBlueEnvelope() {
    return this.m_bPaths || C(""), this.m_bQuadTree ? this.m_bSwapElements ? this.m_query : this.m_quadTree.getElementExtent(this.m_elementHandle) : this.m_bSwapElements ? this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA()) : this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB());
  }
  construct_(t3, s4, r, i2, a2, h2) {
    const m3 = n4.constructEmpty(), l2 = n4.constructEmpty();
    t3.queryLooseEnvelope(m3), r.queryLooseEnvelope(l2), m3.inflateCoords(a2, a2), l2.inflateCoords(a2, a2), this.m_envInter.setCoords({ env2D: m3 }), this.m_envInter.intersect(l2), this.m_multiVertexImplA = t3, this.m_multiVertexImplB = r;
    const g2 = t3.getGeometryType(), u = r.getGeometryType();
    this.m_bPaths = h2, this.m_pathIndex = -1, this.m_pointIndex = -1, this.m_bSwapElements = false, this.m_queryType = a.enumUnknown, this.m_bQuadTree = false, null !== s4 && (this.m_bDone = false, this.m_tolerance = a2, this.m_quadTree = s4, this.m_qtIter = this.m_quadTree.getIteratorForQT(), this.m_bQuadTree = true, this.m_bSwapElements = true, h(u) ? (this.m_queryType = u, this.m_function = this.nextPath_, h2 ? this.m_pathIndex = r.getPathCount() : this.m_segIter = r.querySegmentIterator()) : (this.m_queryType = u, this.m_function = this.nextPoint_, this.m_pointIndex = r.getPointCount())), this.m_bQuadTree || null !== i2 && (this.m_bDone = false, this.m_tolerance = a2, this.m_quadTree = i2, this.m_qtIter = this.m_quadTree.getIteratorForQT(), this.m_bQuadTree = true, this.m_bSwapElements = false, h(g2) ? (this.m_queryType = g2, this.m_function = this.nextPath_, h2 ? this.m_pathIndex = t3.getPathCount() : this.m_segIter = t3.querySegmentIterator()) : (this.m_queryType = g2, this.m_function = this.nextPoint_, this.m_pointIndex = t3.getPointCount())), this.m_bQuadTree || (h2 && h(g2) && h(u) ? this.m_intersector = Gt2(t3, r, a2) : h(g2) && h(u) ? (this.m_intersector = Xt2(t3, r, a2), this.m_bSwapElements = false) : h(g2) && !h(u) ? (this.m_intersector = Ut2(t3, r, a2), this.m_bSwapElements = false) : !h(g2) && h(u) ? (this.m_intersector = Ut2(r, t3, a2), this.m_bSwapElements = true) : (this.m_intersector = Zt2(t3, r, a2), this.m_bSwapElements = false));
  }
  nextPath_() {
    return this.m_bPaths ? -1 === --this.m_pathIndex ? (this.m_bDone = true, false) : (this.m_bSwapElements ? this.m_multiVertexImplB.queryPathEnvelope(this.m_pathIndex, this.m_query) : this.m_multiVertexImplA.queryPathEnvelope(this.m_pathIndex, this.m_query), this.m_qtIter.resetIterator(this.m_query, this.m_tolerance), this.m_function = this.iterate_, true) : this.m_segIter.nextPath() ? (this.m_function = this.nextSegment_, true) : (this.m_bDone = true, false);
  }
  nextSegment_() {
    if (!this.m_segIter.hasNextSegment()) return this.m_function = this.nextPath_, true;
    const t3 = this.m_segIter.nextSegment(), s4 = new n4();
    return t3.queryLooseEnvelope(s4), !s4.isIntersecting(this.m_envInter) || (this.m_qtIter.resetIterator(t3, this.m_tolerance), this.m_function = this.iterate_, true);
  }
  nextPoint_() {
    if (-1 === --this.m_pointIndex) return this.m_bDone = true, false;
    const t3 = new mi();
    if (this.m_bSwapElements) {
      const e5 = this.m_multiVertexImplB.getXY(this.m_pointIndex);
      t3.setCoordsPoint2D(e5);
    } else {
      const e5 = this.m_multiVertexImplA.getXY(this.m_pointIndex);
      t3.setCoordsPoint2D(e5);
    }
    return !this.m_envInter.contains(t3) || (this.m_qtIter.resetIterator(n4.construct(t3.x, t3.y, t3.x, t3.y), this.m_tolerance), this.m_function = this.iterate_, true);
  }
  iterate_() {
    return this.m_elementHandle = this.m_qtIter.next(), -1 === this.m_elementHandle && (h(this.m_queryType) ? (this.m_function = this.m_bPaths ? this.nextPath_ : this.nextSegment_, true) : (this.m_function = this.nextPoint_, true));
  }
};
function Vr2(e5) {
  return 2 === e5 ? 1 : 1 === e5 ? 2 : 128 === e5 ? 64 : 64 === e5 ? 128 : e5;
}
function Fr2(t3, s4, n6) {
  let r;
  if (t3 instanceof oc || null === t3) {
    const i2 = n4.constructEmpty();
    i2.setCoords({ pt: s4 }), i2.mergeEnvelope2D(n6), r = zt2(t3, i2, false);
  } else r = t3;
  return r;
}
function Hr2(t3, s4, n6) {
  let r;
  if (t3 instanceof oc || null === t3) {
    const i2 = n4.constructEmpty();
    i2.setCoords({ env2D: s4 }), i2.mergeEnvelope2D(n6), r = zt2(t3, i2, false);
  } else r = t3;
  return r;
}
function kr2(t3, i2, o, a2, h2) {
  if (t3.isEmpty() || i2.isEmpty()) return 4 === a2;
  j(t3), j(i2);
  let m3 = t3.getGeometryType(), l2 = i2.getGeometryType();
  if (m3 === a.enumEnvelope) {
    if (l2 === a.enumEnvelope) return Ar2(t3, i2, o, a2);
    if (l2 === a.enumPoint) return Mr2(i2, t3, o, Vr2(a2));
  } else if (m3 === a.enumPoint) {
    if (l2 === a.enumEnvelope) return Mr2(t3, i2, o, a2);
    if (l2 === a.enumPoint) return Ur2(t3, i2, o, a2);
  }
  const g2 = n4.constructEmpty();
  t3.queryEnvelope(g2);
  const u = n4.constructEmpty();
  i2.queryEnvelope(u);
  const c = Hr2(o, g2, u);
  if (qr2(g2, u, c)) return 4 === a2;
  let _ = false, d2 = null, p3 = null, f3 = null, x4 = null;
  switch (f(m3) ? (d2 = new Os2({ vd: t3.getDescription() }), d2.addSegment(t3, true), f3 = d2, m3 = a.enumPolyline) : f3 = t3, f(l2) ? (p3 = new Os2({ vd: i2.getDescription() }), p3.addSegment(i2, true), x4 = p3, l2 = a.enumPolyline) : x4 = i2, m3 !== a.enumEnvelope && l2 !== a.enumEnvelope ? (f3.getDimension() < x4.getDimension() || m3 === a.enumPoint && l2 === a.enumMultiPoint) && (a2 = Vr2(a2)) : m3 !== a.enumPolygon && l2 !== a.enumEnvelope && (a2 = Vr2(a2)), m3) {
    case a.enumPolygon:
      switch (l2) {
        case a.enumPolygon:
          _ = Yr2(f3, x4, c, a2, h2);
          break;
        case a.enumPolyline:
          _ = Rr2(f3, x4, c, a2, h2);
          break;
        case a.enumPoint:
          _ = Xr2(f3, x4, c, a2);
          break;
        case a.enumMultiPoint:
          _ = Lr2(f3, x4, c, a2);
          break;
        case a.enumEnvelope:
          _ = zr2(f3, x4, c, a2, h2);
      }
      break;
    case a.enumPolyline:
      switch (l2) {
        case a.enumPolygon:
          _ = Rr2(x4, f3, c, a2, h2);
          break;
        case a.enumPolyline:
          _ = Wr2(f3, x4, c, a2, h2);
          break;
        case a.enumPoint:
          _ = jr2(f3, x4, c, a2);
          break;
        case a.enumMultiPoint:
          _ = Zr2(f3, x4, c, a2);
          break;
        case a.enumEnvelope:
          _ = Kr2(f3, x4, c, a2, h2);
      }
      break;
    case a.enumPoint:
      switch (l2) {
        case a.enumPolygon:
          _ = Xr2(x4, f3, c, a2);
          break;
        case a.enumPolyline:
          _ = jr2(x4, f3, c, a2);
          break;
        case a.enumMultiPoint:
          _ = Jr2(x4, f3, c, a2);
      }
      break;
    case a.enumMultiPoint:
      switch (l2) {
        case a.enumPolygon:
          _ = Lr2(x4, f3, c, a2);
          break;
        case a.enumPolyline:
          _ = Zr2(x4, f3, c, a2);
          break;
        case a.enumMultiPoint:
          _ = Qr2(f3, x4, c, a2);
          break;
        case a.enumPoint:
          _ = Jr2(f3, x4, c, a2);
          break;
        case a.enumEnvelope:
          _ = $r2(f3, x4, c, a2);
      }
      break;
    case a.enumEnvelope:
      switch (l2) {
        case a.enumPolygon:
          _ = zr2(x4, f3, c, a2, h2);
          break;
        case a.enumPolyline:
          _ = Kr2(x4, f3, c, a2, h2);
          break;
        case a.enumMultiPoint:
          _ = $r2(x4, f3, c, a2);
      }
  }
  return _;
}
function Ar2(t3, s4, n6, r, i2) {
  if (t3.isEmpty() || s4.isEmpty()) return 4 === r;
  const o = n4.constructEmpty();
  t3.queryEnvelope(o);
  const a2 = n4.constructEmpty();
  s4.queryEnvelope(a2);
  const h2 = Hr2(n6, o, a2);
  switch (r) {
    case 4:
      return qr2(o, a2, h2);
    case 2:
      return go2(a2, o, h2, false);
    case 128:
      return go2(a2, o, h2, true);
    case 1:
      return go2(o, a2, h2, false);
    case 64:
      return go2(o, a2, h2, true);
    case 3:
      return ho2(o, a2, h2);
    case 8:
      return mo2(o, a2, h2);
    case 32:
      return lo2(o, a2, h2);
    case 16:
      return false;
  }
  return false;
}
function Mr2(t3, s4, n6, r, i2) {
  if (t3.isEmpty() || s4.isEmpty()) return 4 === r;
  const o = t3.getXY(), a2 = n4.constructEmpty();
  s4.queryEnvelope(a2);
  const h2 = Fr2(n6, o, a2);
  switch (r) {
    case 4:
      return Or2(o, a2, h2);
    case 2:
    case 128:
      return ao2(o, a2, h2);
    case 1:
    case 64:
      return false;
    case 3:
      return io2(o, a2, h2);
    case 8:
      return oo2(o, a2, h2);
  }
  return false;
}
function Ur2(t3, s4, n6, r, i2) {
  if (t3.isEmpty() || s4.isEmpty()) return 4 === r;
  const o = t3.getXY(), a2 = s4.getXY();
  let h2;
  if (n6 instanceof oc || null === n6) {
    const t4 = n4.constructEmpty();
    t4.setCoords({ pt: o }), t4.merge(a2), h2 = zt2(n6, t4, false);
  } else h2 = n6;
  switch (r) {
    case 4:
      return no2(o, a2, h2);
    case 2:
    case 128:
      return ro2(a2, o, h2);
    case 1:
    case 64:
      return ro2(o, a2, h2);
    case 3:
      return so2(o, a2, h2);
  }
  return false;
}
function qr2(t3, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: s4 }), r.inflateCoords(n6, n6), !t3.isIntersecting(r);
}
function Br2(e5, t3, s4, n6 = false) {
  const r = e5.getGeometryType(), i2 = t3.getGeometryType();
  if (y(r)) {
    const t4 = e5.getImpl().getAccelerators();
    if (null !== t4) {
      const e6 = t4.getRasterizedGeometry();
      n2(null === e6);
    }
  }
  if (y(i2)) {
    const e6 = t3.getImpl().getAccelerators();
    if (null !== e6) {
      const t4 = e6.getRasterizedGeometry();
      n2(null === t4);
    }
  }
  return 0;
}
function Or2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty();
  return i2.setCoords({ env2D: s4 }), i2.inflateCoords(n6, n6), !i2.contains(t3);
}
function Yr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return ti2(e5, t3, s4);
    case 2:
      return ri2(t3, e5, s4, r);
    case 128:
      return ii3(t3, e5, s4);
    case 1:
      return ri2(e5, t3, s4, r);
    case 64:
      return ii3(e5, t3, s4);
    case 3:
      return ei3(e5, t3, s4, r);
    case 8:
      return si3(e5, t3, s4);
    case 32:
      return ni3(e5, t3, s4, r);
  }
  return false;
}
function Rr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return oi3(e5, t3, s4);
    case 1:
      return mi3(e5, t3, s4, r);
    case 64:
      return li2(e5, t3, s4);
    case 8:
      return ai3(e5, t3, s4, r);
    case 16:
      return hi3(e5, t3, s4);
  }
  return false;
}
function Xr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return gi2(e5, t3, s4);
    case 1:
    case 64:
      return ci2(e5, t3, s4);
    case 8:
      return ui2(e5, t3, s4);
  }
  return false;
}
function Lr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return _i2(e5, t3, s4);
    case 1:
      return fi2(e5, t3, s4, false);
    case 64:
      return fi2(e5, t3, s4, true);
    case 8:
      return di2(e5, t3, s4);
    case 16:
      return pi2(e5, t3, s4);
  }
  return false;
}
function zr2(e5, t3, s4, n6, r) {
  if (yi2(e5, t3, s4)) return 4 === n6;
  if (4 === n6) return false;
  switch (n6) {
    case 2:
      return Si2(e5, t3, s4, false);
    case 128:
      return Si2(e5, t3, s4, true);
    case 1:
      return Ci2(e5, t3, s4, false, r);
    case 64:
      return Ci2(e5, t3, s4, true, r);
    case 3:
      return xi2(e5, t3, s4, r);
    case 8:
      return Pi2(e5, t3, s4, r);
    case 32:
      return Ei2(e5, t3, s4, r);
    case 16:
      return false;
  }
  return false;
}
function Wr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return bi2(e5, t3, s4);
    case 2:
      return Ti2(t3, e5, s4, r);
    case 128:
      return Gi2(t3, e5, s4, r);
    case 1:
      return Ti2(e5, t3, s4, r);
    case 64:
      return Gi2(e5, t3, s4, r);
    case 3:
      return Ii2(e5, t3, s4, r);
    case 8:
      return wi2(e5, t3, s4, r);
    case 32:
      return Ni2(e5, t3, s4, r);
    case 16:
      return vi2(e5, t3, s4, r);
  }
  return false;
}
function jr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return Di2(e5, t3, s4);
    case 1:
    case 64:
      return Fi2(e5, t3, s4);
    case 8:
      return Vi2(e5, t3, s4);
  }
  return false;
}
function Zr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return Hi2(e5, t3, s4);
    case 1:
    case 64:
      return Mi2(e5, t3, s4);
    case 8:
      return ki2(e5, t3, s4);
    case 16:
      return Ai2(e5, t3, s4);
  }
  return false;
}
function Kr2(e5, t3, s4, n6, r) {
  if (qi2(e5, t3, s4)) return 4 === n6;
  if (4 === n6) return false;
  switch (n6) {
    case 2:
      return Oi2(e5, t3, s4, false);
    case 128:
      return Oi2(e5, t3, s4, true);
    case 1:
    case 64:
    case 32:
      return false;
    case 3:
      return Ui2(e5, t3, s4);
    case 8:
      return Bi2(e5, t3, s4, r);
    case 16:
      return Yi2(e5, t3, s4);
  }
  return false;
}
function Qr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return Xi2(e5, t3, s4);
    case 2:
    case 128:
      return zi2(t3, e5, s4);
    case 1:
    case 64:
      return zi2(e5, t3, s4);
    case 3:
      return Ri2(e5, t3, s4);
    case 32:
      return Li2(e5, t3, s4);
  }
  return false;
}
function Jr2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return ji2(e5, t3, s4);
    case 2:
    case 128:
      return Zi2(e5, t3, s4);
    case 1:
    case 64:
      return Ki2(e5, t3, s4);
    case 3:
      return Wi2(e5, t3, s4);
  }
  return false;
}
function $r2(e5, t3, s4, n6, r) {
  switch (n6) {
    case 4:
      return Ji(e5, t3, s4);
    case 2:
      return eo2(e5, t3, s4, false);
    case 128:
      return eo2(e5, t3, s4, true);
    case 1:
    case 64:
      return false;
    case 3:
      return Qi(e5, t3, s4);
    case 8:
      return $i2(e5, t3, s4);
    case 16:
      return to2(e5, t3, s4);
  }
  return false;
}
function ei3(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), !ho2(i2, o, n6)) return false;
  if (Br2(t3, s4), yo2(t3, s4, n6)) return true;
  const a2 = t3.calculateLength2D(), h2 = s4.calculateLength2D(), m3 = Math.max(t3.getPointCount(), s4.getPointCount());
  if (Math.abs(a2 - h2) > 4 * m3 * n6) return false;
  if (t3.hasNonLinearSegments() || s4.hasNonLinearSegments()) {
    return sr2(t3, s4, n6, "**F**FFF*", r, false);
  }
  return So2(t3, s4, n6, true);
}
function ti2(e5, t3, s4, n6) {
  Br2(e5, t3, s4, true);
  return 1 === uo2(e5, t3, s4, true);
}
function si3(e5, t3, s4, n6) {
  return Br2(e5, t3), Go2(e5, t3, s4, null);
}
function ni3(e5, t3, s4, n6) {
  return Br2(e5, t3), Do2(e5, t3, s4, n6);
}
function ri2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), !!po2(i2, o, n6) && (Br2(t3, s4), Vo2(t3, s4, n6, r));
}
function ii3(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), !!po2(i2, o, n6) && (Br2(t3, s4), 2 === uo2(t3, s4, n6, false));
}
function oi3(e5, t3, s4, n6) {
  Br2(e5, t3, s4, true);
  return 1 === uo2(e5, t3, s4, true);
}
function ai3(e5, t3, s4, n6) {
  return Br2(e5, t3), Fo2(e5, t3, s4, n6);
}
function hi3(e5, t3, s4, n6) {
  return Br2(e5, t3), Ho2(e5, t3, s4, null);
}
function mi3(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), !!po2(i2, o, n6) && (Br2(t3, s4), ko2(t3, s4, n6, r));
}
function li2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), !!po2(i2, o, n6) && (Br2(t3, s4), 2 === uo2(t3, s4, n6, false));
}
function gi2(e5, t3, s4, n6) {
  return 0 === Xo2(e5, t3, s4);
}
function ui2(e5, t3, s4, n6) {
  return Mo2(e5, t3.getXY(), s4);
}
function ci2(e5, t3, s4, n6) {
  return Ao2(e5, t3.getXY(), s4);
}
function _i2(e5, t3, s4, n6, r) {
  Br2(e5, t3);
  return 1 === co2(e5, t3, s4);
}
function di2(t3, s4, n6, r) {
  Br2(t3, s4);
  const i2 = n4.constructEmpty();
  t3.queryEnvelope(i2), i2.inflateCoords(n6, n6);
  const o = new mi();
  let a2 = false;
  const h2 = t3.getImpl(), m3 = new ur();
  let l2 = t3, g2 = false;
  for (let e5 = 0; e5 < s4.getPointCount(); e5++) {
    if (s4.queryXY(e5, o), i2.contains(o)) {
      const e6 = Lo2(l2, o, n6);
      if (2 === e6) a2 = true;
      else if (1 === e6) return false;
    }
    g2 || (!Wn2(t3, s4.getPointCount() - 1) || null !== h2.getAccelerators() && null !== h2.getAccelerators().getQuadTree() ? l2 = t3 : (t3.copyTo(m3), m3.getImpl().buildQuadTreeAccelerator(1), l2 = m3), g2 = true);
  }
  return !!a2;
}
function pi2(t3, s4, n6, r) {
  Br2(t3, s4);
  const i2 = new n4(), o = new n4(), a2 = new n4();
  t3.queryEnvelope(i2), s4.queryEnvelope(a2), o.setCoords({ env2D: i2 }), o.inflateCoords(n6, n6);
  let h2 = false, m3 = false;
  const l2 = new mi(), g2 = t3.getImpl(), u = new ur();
  let c = t3, _ = false;
  for (let e5 = 0; e5 < s4.getPointCount(); e5++) {
    if (s4.queryXY(e5, l2), o.contains(l2)) {
      const e6 = Lo2(c, l2, n6);
      0 === e6 ? m3 = true : 1 === e6 && (h2 = true);
    } else m3 = true;
    if (h2 && m3) return true;
    _ || (!Wn2(t3, s4.getPointCount() - 1) || null !== g2.getAccelerators() && null !== g2.getAccelerators().getQuadTree() ? c = t3 : (t3.copyTo(u), u.getImpl().buildQuadTreeAccelerator(1), c = u), _ = true);
  }
  return false;
}
function fi2(t3, s4, n6, r, i2) {
  const o = n4.constructEmpty(), a2 = n4.constructEmpty();
  if (t3.queryEnvelope(o), s4.queryEnvelope(a2), !po2(o, a2, n6)) return false;
  Br2(t3, s4);
  let h2 = false;
  const m3 = new mi(), l2 = t3.getImpl(), g2 = new ur();
  let u = t3, c = false;
  for (let e5 = 0; e5 < s4.getPointCount(); e5++) {
    if (s4.queryXY(e5, m3), !o.contains(m3)) return false;
    const i3 = Lo2(u, m3, n6);
    if (1 === i3) h2 = true;
    else if (0 === i3) return false;
    if (r && 2 === i3) return false;
    c || (!Wn2(t3, s4.getPointCount() - 1) || null !== l2.getAccelerators() && null !== l2.getAccelerators().getQuadTree() ? u = t3 : (t3.copyTo(g2), g2.getImpl().buildQuadTreeAccelerator(1), u = g2), c = true);
  }
  return h2;
}
function xi2(t3, s4, n6, r) {
  const i2 = new n4(), o = new n4();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), !ho2(i2, o, n6)) return false;
  const a2 = new ur();
  return a2.addEnvelope(s4, false), ei3(t3, a2, n6, r);
}
function yi2(t3, s4, n6, r) {
  Br2(t3, s4);
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), po2(o, i2, n6)) return false;
  return 0 === Lo2(t3, o.getLowerLeft(), 0) && (!o.contains(t3.getXY(0)) && !To2(t3, o, n6));
}
function Pi2(t3, s4, n6, r) {
  Br2(t3, s4);
  const i2 = new n4(), o = new n4();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), po2(o, i2, n6)) return false;
  if (o.height() <= n6 || o.width() <= n6) return false;
  const a2 = new ur();
  return a2.addEnvelope(s4, false), Go2(t3, a2, n6, r);
}
function Ei2(t3, s4, n6, r) {
  Br2(t3, s4);
  const i2 = new n4(), o = new n4();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), po2(o, i2, n6)) return false;
  if (o.height() <= n6 || o.width() <= n6) return false;
  const a2 = new ur();
  return a2.addEnvelope(s4, false), Do2(t3, a2, n6, r);
}
function Si2(t3, s4, n6, r, i2) {
  const o = n4.constructEmpty(), a2 = n4.constructEmpty();
  return t3.queryEnvelope(o), s4.queryEnvelope(a2), r ? fo2(a2, o, n6) : po2(a2, o, n6);
}
function Ci2(t3, s4, n6, r, i2) {
  const o = n4.constructEmpty(), a2 = n4.constructEmpty();
  if (t3.queryEnvelope(o), s4.queryEnvelope(a2), !po2(o, a2, n6)) return false;
  Br2(t3, s4);
  const h2 = new ur();
  return h2.addEnvelope(s4, false), r ? 2 === uo2(t3, h2, n6, false) : Vo2(t3, h2, n6, i2);
}
function Ii2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), !ho2(i2, o, n6)) return false;
  if (Br2(t3, s4), yo2(t3, s4, n6)) return true;
  if (t3.hasNonLinearSegments() || s4.hasNonLinearSegments()) {
    return sr2(t3, s4, n6, "**F**FFF*", r, false);
  }
  return So2(t3, s4, n6, false);
}
function bi2(e5, t3, s4, n6) {
  Br2(e5, t3);
  const r = e5.getImpl(), i2 = t3.getImpl();
  return !new Dr2(r, i2, s4, true).next() || !Io2(e5, t3, s4);
}
function wi2(t3, s4, n6, r) {
  Br2(t3, s4);
  const i2 = [], o = bo2(t3, s4, n6, i2);
  if (-2 === o) {
    const i3 = n4.constructEmpty(), o2 = n4.constructEmpty(), a3 = n4.constructEmpty();
    let h3, m4;
    if (t3.queryEnvelope(i3), s4.queryEnvelope(o2), i3.inflateCoords(1e3 * n6, 1e3 * n6), o2.inflateCoords(1e3 * n6, 1e3 * n6), a3.setCoords({ env2D: i3 }), a3.intersect(o2), t3.getPointCount() > 10) {
      if (h3 = f2(t3, a3, n6, 0, r), h3.isEmpty()) return false;
    } else h3 = t3;
    if (s4.getPointCount() > 10) {
      if (m4 = f2(s4, a3, n6, 0, r), m4.isEmpty()) return false;
    } else m4 = s4;
    return sr2(h3, m4, n6, "F********", r, false);
  }
  if (0 !== o) return false;
  const a2 = new Ee();
  for (let e5 = 0; e5 < i2.length; e5 += 2) {
    const t4 = i2[e5], s5 = i2[e5 + 1];
    a2.addXY(t4, s5);
  }
  const h2 = t3.getBoundary(), m3 = s4.getBoundary();
  return h2.addPoints(m3, 0, m3.getPointCount()), !h2.isEmpty() && zi2(h2, a2, n6);
}
function vi2(t3, s4, n6, r) {
  Br2(t3, s4);
  const i2 = [], o = bo2(t3, s4, n6, i2);
  if (-2 === o) {
    const i3 = n4.constructEmpty(), o2 = n4.constructEmpty(), a3 = n4.constructEmpty();
    let h3, m4;
    if (t3.queryEnvelope(i3), s4.queryEnvelope(o2), i3.inflateCoords(1e3 * n6, 1e3 * n6), o2.inflateCoords(1e3 * n6, 1e3 * n6), a3.setCoords({ env2D: i3 }), a3.intersect(o2), t3.getPointCount() > 10) {
      if (h3 = f2(t3, a3, n6, 0, r), h3.isEmpty()) return false;
    } else h3 = t3;
    if (s4.getPointCount() > 10) {
      if (m4 = f2(s4, a3, n6, 0, r), m4.isEmpty()) return false;
    } else m4 = s4;
    return sr2(h3, m4, n6, "0********", r, false);
  }
  if (0 !== o) return false;
  const a2 = new Ee();
  for (let e5 = 0; e5 < i2.length; e5 += 2) {
    const t4 = i2[e5], s5 = i2[e5 + 1];
    a2.addXY(t4, s5);
  }
  const h2 = t3.getBoundary(), m3 = s4.getBoundary();
  return h2.addPoints(m3, 0, m3.getPointCount()), !!h2.isEmpty() || !zi2(h2, a2, n6);
}
function Ni2(t3, s4, n6, r) {
  Br2(t3, s4);
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  t3.queryEnvelope(i2), s4.queryEnvelope(o);
  const a2 = xo2(i2, o, n6), h2 = xo2(o, i2, n6), m3 = t3.hasNonLinearSegments(), l2 = s4.hasNonLinearSegments(), g2 = bo2(t3, s4, n6, null);
  if (-1 === g2) return false;
  if (1 === g2) {
    if (a2 && h2) return true;
    if (!m3 && !l2) return a2 && !h2 ? !Co2(s4, t3, n6, false) : h2 && !a2 ? !Co2(t3, s4, n6, false) : !Co2(t3, s4, n6, false) && !Co2(s4, t3, n6, false);
  }
  const u = n4.constructEmpty(), c = n4.constructEmpty(), _ = n4.constructEmpty();
  let d2, p3;
  u.setCoords({ env2D: i2 }), u.inflateCoords(1e3 * n6, 1e3 * n6), c.setCoords({ env2D: o }), c.inflateCoords(1e3 * n6, 1e3 * n6), _.setCoords({ env2D: u }), _.intersect(c);
  let f3 = "";
  if (f3 += "1*", a2) {
    if (s4.getPointCount() > 10) {
      if (p3 = f2(s4, _, n6, 0, r), p3.isEmpty()) return false;
    } else p3 = s4;
    f3 += "****";
  } else p3 = s4, f3 += "T***";
  if (h2) {
    if (t3.getPointCount() > 10) {
      if (d2 = f2(t3, _, n6, 0, r), d2.isEmpty()) return false;
    } else d2 = t3;
    f3 += "***";
  } else d2 = t3, f3 += "T**";
  return sr2(d2, p3, n6, f3, r, false);
}
function Ti2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), !po2(i2, o, n6)) return false;
  if (Br2(t3, s4), t3.hasNonLinearSegments() || s4.hasNonLinearSegments()) {
    return sr2(t3, s4, n6, "******FF*", r, false);
  }
  return Co2(s4, t3, n6, false);
}
function Gi2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), !po2(i2, o, n6)) return false;
  Br2(t3, s4);
  return sr2(t3, s4, n6, "T**FF*FF*", r, false);
}
function Di2(e5, t3, s4, n6) {
  Br2(e5, t3);
  return !vo2(e5, t3.getXY(), s4);
}
function Vi2(e5, t3, s4, n6) {
  Br2(e5, t3);
  return qo2(e5, t3.getXY(), s4);
}
function Fi2(e5, t3, s4, n6) {
  Br2(e5, t3);
  return No2(e5, t3.getXY(), s4);
}
function Hi2(e5, t3, s4, n6) {
  return Br2(e5, t3), !wo2(e5, t3, s4, false);
}
function ki2(e5, t3, s4, n6) {
  Br2(e5, t3);
  const r = e5.getImpl(), i2 = t3.getImpl(), o = new Ee(), a2 = new Dr2(r, i2, s4, false), h2 = r.querySegmentIterator();
  let m3 = false;
  for (; a2.next(); ) {
    const e6 = a2.getRedElement(), t4 = a2.getBlueElement();
    h2.resetToVertex(e6, -1);
    const n7 = h2.nextSegment(), r2 = i2.getXY(t4);
    n7.isIntersectingPoint(r2, s4) && (m3 = true, o.addPoint2D(r2));
  }
  if (!m3) return false;
  const l2 = e5.getBoundary();
  return !l2.isEmpty() && zi2(l2, o, s4);
}
function Ai2(e5, t3, s4, n6) {
  Br2(e5, t3);
  const r = e5.getImpl(), i2 = t3.getImpl(), o = i2.getPointCount(), a2 = Yt(o, false), h2 = new Dr2(r, i2, s4, false), m3 = r.querySegmentIterator();
  let l2 = false;
  for (; h2.next(); ) {
    const e6 = h2.getRedElement(), t4 = h2.getBlueElement();
    m3.resetToVertex(e6, -1);
    const n7 = m3.nextSegment(), r2 = i2.getXY(t4);
    n7.isIntersectingPoint(r2, s4) && (l2 = true, a2[t4] = true);
  }
  if (!l2) return false;
  let g2 = false;
  for (let _ = 0; _ < o; _++) if (!a2[_]) {
    g2 = true;
    break;
  }
  if (!g2) return false;
  const u = e5.getBoundary();
  if (u.isEmpty()) return true;
  const c = new Ee();
  for (let _ = 0; _ < o; _++) a2[_] && c.addPoint2D(i2.getXY(_));
  return !zi2(u, c, s4);
}
function Mi2(t3, s4, n6, r, i2) {
  const o = n4.constructEmpty(), a2 = n4.constructEmpty();
  if (t3.queryEnvelope(o), s4.queryEnvelope(a2), !po2(o, a2, n6)) return false;
  Br2(t3, s4);
  const h2 = wo2(t3, s4, n6, true);
  if (!h2) return h2;
  const m3 = t3.getBoundary();
  return m3.isEmpty() ? h2 : !zi2(m3, s4, n6);
}
function Ui2(t3, s4, n6, r) {
  const i2 = new n4(), o = new n4();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), !(o.height() > n6 && o.width() > n6) && ho2(i2, o, n6);
}
function qi2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  t3.queryEnvelope(i2), s4.queryEnvelope(o);
  const a2 = Bo2(o, i2, n6);
  return 0 === a2 ? !To2(t3, o, n6) : 4 === a2;
}
function Bi2(t3, s4, r, o) {
  const a2 = new n4(), h2 = new n4();
  if (t3.queryEnvelope(a2), s4.queryEnvelope(h2), h2.height() <= r || h2.width() <= r) return false;
  const m3 = new n4(), l2 = new n4();
  if (m3.setCoords({ env2D: h2 }), l2.setCoords({ env2D: h2 }), m3.inflateCoords(r, r), l2.inflateCoords(-r, -r), l2.containsEnvelope(a2) || !a2.isIntersecting(m3)) return false;
  const g2 = t3.getImpl().querySegmentIterator();
  g2.stripAttributes();
  const u = t3.getImpl().getAccelerators();
  let c = null, _ = null;
  null !== u && (c = u.getQuadTree(), null !== c && (_ = c.getIterator(h2, r))), _ || g2.nextPath() || b("relational_operations");
  let d2 = false, p3 = null;
  const f3 = new mi(), x4 = new mi(), y2 = t3.hasNonLinearSegments();
  let P5 = false;
  for (; ; ) {
    if (null !== _) {
      const e5 = _.next();
      if (-1 === e5) break;
      g2.resetToVertex(c.getElement(e5), -1), p3 = g2.nextSegment();
    } else {
      for (; !g2.hasNextSegment() && g2.nextPath(); ) ;
      if (!g2.hasNextSegment()) break;
      p3 = g2.nextSegment();
    }
    if (y2 && p3.getGeometryType() !== a.enumLine) {
      const t4 = new n4();
      if (p3.queryEnvelope(t4), l2.containsEnvelope(t4)) return false;
      if (m3.isIntersecting(t4)) {
        P5 = true;
        break;
      }
    } else {
      f3.assign(p3.getStartXY()), x4.assign(p3.getEndXY());
      let e5 = l2.clipLine(f3, x4);
      if (0 !== e5) return false;
      d2 || (e5 = m3.clipLine(f3, x4), 0 !== e5 && (d2 = true));
    }
  }
  if (!P5) return d2;
  const E2 = new ur();
  return E2.addEnvelope(h2, false), ai3(E2, t3, r, o);
}
function Oi2(t3, s4, r, o, a2) {
  const h2 = n4.constructEmpty(), m3 = n4.constructEmpty();
  if (t3.queryEnvelope(h2), s4.queryEnvelope(m3), m3.height() <= r || m3.width() <= r) return false;
  if (o) return fo2(m3, h2, r);
  if (!po2(m3, h2, r)) return false;
  const l2 = n4.constructEmpty();
  l2.setCoords({ env2D: m3 }), l2.inflateCoords(-r, -r);
  const g2 = n4.constructEmpty();
  if (g2.setCoords({ env2D: m3 }), g2.inflateCoords(r, r), l2.containsEnvelope(h2)) return true;
  const u = t3.getImpl().querySegmentIterator();
  u.stripAttributes(), u.nextPath() || b("relational_operations");
  let c, _, d2, p3, f3, x4, y2 = false;
  const P5 = t3.hasNonLinearSegments();
  for (P5 && (d2 = new pm(), p3 = new pm(), f3 = new pm(), x4 = new pm(), l2.querySide(0, d2), l2.querySide(1, p3), l2.querySide(2, f3), l2.querySide(3, x4)); ; ) {
    for (; !u.hasNextSegment() && u.nextPath(); ) ;
    if (!u.hasNextSegment()) break;
    const e5 = u.nextSegment();
    if (P5 && e5.getGeometryType() !== a.enumLine) {
      if (e5.isIntersecting(d2, r)) {
        y2 = true;
        break;
      }
      if (e5.isIntersecting(p3, r)) {
        y2 = true;
        break;
      }
      if (e5.isIntersecting(f3, r)) {
        y2 = true;
        break;
      }
      if (e5.isIntersecting(x4, r)) {
        y2 = true;
        break;
      }
    } else {
      c = e5.getStartXY(), _ = e5.getEndXY();
      if (0 !== l2.clipLine(c, _)) {
        y2 = true;
        break;
      }
    }
  }
  return y2;
}
function Yi2(t3, s4, r, i2) {
  const o = new n4(), h2 = new n4();
  if (t3.queryEnvelope(o), s4.queryEnvelope(h2), h2.height() <= r || h2.width() <= r) return false;
  const m3 = new n4();
  if (m3.setCoords({ env2D: h2 }), m3.inflateCoords(r, r), m3.containsEnvelope(o)) return false;
  const l2 = true, g2 = new n4();
  if (g2.setCoords({ env2D: h2 }), g2.inflateCoords(-r, -r), !g2.isIntersecting(o)) return false;
  const u = t3.getImpl().querySegmentIterator();
  u.stripAttributes();
  const c = t3.getImpl().getAccelerators();
  let _ = null, d2 = null;
  if (null !== c && (_ = c.getQuadTree(), null !== _ && (d2 = _.getIterator(h2, r))), !d2) {
    const e5 = u.nextPath();
    n2(e5);
  }
  let p3 = false, f3 = null;
  const x4 = new mi(), y2 = new mi();
  let P5 = null, E2 = null, S3 = null, C3 = null;
  for (t3.hasNonLinearSegments() && (P5 = new pm(), E2 = new pm(), S3 = new pm(), C3 = new pm(), g2.querySide(0, P5), g2.querySide(1, E2), g2.querySide(2, S3), g2.querySide(3, C3)); ; ) {
    if (null !== d2) {
      const e5 = d2.next();
      if (-1 === e5) break;
      u.resetToVertex(_.getElement(e5), -1), f3 = u.nextSegment();
    } else {
      for (; !u.hasNextSegment() && u.nextPath(); ) ;
      if (!u.hasNextSegment()) break;
      f3 = u.nextSegment();
    }
    if (f3.getGeometryType() === a.enumLine) {
      x4.assign(f3.getStartXY()), y2.assign(f3.getEndXY());
      if (0 !== g2.clipLine(x4, y2)) {
        p3 = true;
        break;
      }
    } else {
      if (P5.isIntersecting(f3, r)) {
        p3 = true;
        break;
      }
      if (E2.isIntersecting(f3, r)) {
        p3 = true;
        break;
      }
      if (S3.isIntersecting(f3, r)) {
        p3 = true;
        break;
      }
      if (C3.isIntersecting(f3, r)) {
        p3 = true;
        break;
      }
    }
  }
  return p3 && l2;
}
function Ri2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), !!ho2(i2, o, n6) && (!!Po2(t3, s4, n6) || Eo2(t3, s4, n6, false, true, false));
}
function Xi2(e5, t3, s4, n6) {
  const r = e5, i2 = t3, o = new Dr2(r, i2, s4, false), a2 = s4 * s4, h2 = new mi(), m3 = new mi();
  for (; o.next(); ) {
    const e6 = o.getRedElement(), t4 = o.getBlueElement();
    if (r.queryXY(e6, h2), i2.queryXY(t4, m3), mi.sqrDistance(h2, m3) <= a2) return false;
  }
  return true;
}
function Li2(e5, t3, s4, n6) {
  return Eo2(e5, t3, s4, false, false, true);
}
function zi2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), !!po2(i2, o, n6) && Eo2(s4, t3, n6, true, false, false);
}
function Wi2(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), ho2(i2, o, n6);
}
function ji2(e5, t3, s4, n6) {
  return Uo2(e5, t3.getXY(), s4);
}
function Zi2(e5, t3, s4, n6) {
  return Wi2(e5, t3, s4);
}
function Ki2(e5, t3, s4, n6) {
  return !ji2(e5, t3, s4);
}
function Qi(t3, s4, n6, r) {
  const i2 = new n4(), o = new n4();
  return t3.queryEnvelope(i2), s4.queryEnvelope(o), !(o.height() > n6 || o.width() > n6) && ho2(i2, o, n6);
}
function Ji(t3, s4, n6, r) {
  const i2 = n4.constructEmpty(), o = n4.constructEmpty();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), po2(o, i2, n6)) return false;
  const a2 = n4.constructEmpty();
  a2.setCoords({ env2D: o }), a2.inflateCoords(n6, n6);
  const h2 = new mi();
  for (let e5 = 0; e5 < t3.getPointCount(); e5++) if (t3.queryXY(e5, h2), a2.contains(h2)) return false;
  return true;
}
function $i2(t3, s4, n6, r) {
  const i2 = new n4(), o = new n4(), a2 = new n4();
  if (s4.queryEnvelope(i2), i2.height() <= n6 || i2.width() <= n6) return false;
  o.setCoords({ env2D: i2 }), a2.setCoords({ env2D: i2 }), o.inflateCoords(n6, n6), a2.inflateCoords(-n6, -n6);
  const h2 = new mi();
  let m3 = false;
  for (let e5 = 0; e5 < t3.getPointCount(); e5++) if (t3.queryXY(e5, h2), o.contains(h2)) {
    if (a2.containsExclusive(h2)) return false;
    m3 = true;
  }
  return m3;
}
function eo2(t3, s4, n6, r, i2) {
  const o = n4.constructEmpty(), a2 = n4.constructEmpty();
  if (t3.queryEnvelope(o), s4.queryEnvelope(a2), a2.height() <= n6 || a2.width() <= n6) return false;
  if (r) return fo2(a2, o, n6);
  if (!po2(a2, o, n6)) return false;
  let h2 = false;
  const m3 = n4.constructEmpty(), l2 = n4.constructEmpty();
  m3.setCoords({ env2D: a2 }), l2.setCoords({ env2D: a2 }), m3.inflateCoords(-n6, -n6), l2.inflateCoords(n6, n6);
  const g2 = new mi();
  for (let e5 = 0; e5 < t3.getPointCount(); e5++) {
    if (t3.queryXY(e5, g2), !l2.contains(g2)) return false;
    m3.containsExclusive(g2) && (h2 = true);
  }
  return h2;
}
function to2(t3, s4, n6, r) {
  const i2 = new n4(), o = new n4();
  if (t3.queryEnvelope(i2), s4.queryEnvelope(o), po2(o, i2, n6)) return false;
  if (o.height() <= n6 || o.width() <= n6) return false;
  const a2 = new n4(), h2 = new n4();
  a2.setCoords({ env2D: o }), a2.inflateCoords(-n6, -n6), h2.setCoords({ env2D: o }), h2.inflateCoords(n6, n6);
  const m3 = new mi();
  let l2 = false, g2 = false;
  for (let e5 = 0; e5 < t3.getPointCount(); e5++) if (t3.queryXY(e5, m3), !l2 && a2.containsExclusive(m3) && (l2 = true), g2 || h2.contains(m3) || (g2 = true), l2 && g2) return true;
  return false;
}
function so2(e5, t3, s4, n6) {
  return mi.sqrDistance(e5, t3) <= s4 * s4;
}
function no2(e5, t3, s4, n6) {
  return mi.sqrDistance(e5, t3) > s4 * s4;
}
function ro2(e5, t3, s4, n6) {
  return so2(e5, t3, s4);
}
function io2(t3, s4, n6, r) {
  const i2 = new n4();
  return i2.setCoords({ pt: t3 }), ho2(i2, s4, n6);
}
function oo2(t3, s4, n6, r) {
  if (s4.height() <= n6 || s4.width() <= n6) return false;
  const i2 = new n4(), o = new n4();
  return i2.setCoords({ env2D: s4 }), i2.inflateCoords(n6, n6), !!i2.contains(t3) && (o.setCoords({ env2D: s4 }), o.inflateCoords(-n6, -n6), !o.containsExclusive(t3));
}
function ao2(t3, s4, n6, r) {
  if (s4.height() <= n6 || s4.width() <= n6) return false;
  const i2 = n4.constructEmpty();
  i2.setCoords({ env2D: s4 }), i2.inflateCoords(-n6, -n6);
  return i2.containsExclusive(t3);
}
function ho2(e5, t3, s4, n6) {
  return po2(e5, t3, s4) && po2(t3, e5, s4);
}
function mo2(t3, s4, n6, r) {
  if (t3.height() <= n6 || t3.width() <= n6 || s4.height() <= n6 || s4.width() <= n6) return false;
  const i2 = new n4();
  return i2.setCoords({ env2D: t3 }), i2.inflateCoords(-n6, -n6), i2.intersect(s4), !(!i2.isEmpty() && i2.height() > n6 && i2.width() > n6) && (i2.setCoords({ env2D: t3 }), i2.inflateCoords(n6, n6), i2.intersect(s4), !i2.isEmpty());
}
function lo2(t3, s4, n6, r) {
  if (t3.height() <= n6 || t3.width() <= n6 || s4.height() <= n6 || s4.width() <= n6) return false;
  if (po2(t3, s4, n6)) return false;
  if (po2(s4, t3, n6)) return false;
  const i2 = new n4();
  return i2.setCoords({ env2D: t3 }), i2.inflateCoords(-n6, -n6), i2.intersect(s4), !i2.isEmpty() && (i2.height() > n6 || i2.width() > n6);
}
function go2(t3, s4, n6, r, i2) {
  if (t3.height() <= n6 || t3.width() <= n6) return false;
  if (r) return fo2(t3, s4, n6);
  if (!po2(t3, s4, n6)) return false;
  const o = n4.constructEmpty();
  return o.setCoords({ env2D: t3 }), o.inflateCoords(-n6, -n6), o.intersect(s4), !o.isEmpty();
}
function uo2(t3, s4, r, i2, o) {
  const a2 = new mi(), h2 = new mi(), m3 = n4.constructEmpty(), l2 = n4.constructEmpty(), g2 = t3.getImpl(), u = s4.getImpl(), c = u.getGeometryType(), _ = new Dr2(g2, u, r, true);
  if (!_.next()) return 1;
  if (Io2(t3, s4, r)) return i2 ? 4 : 0;
  const d2 = new ur();
  let p3 = t3;
  const f3 = new ur();
  let x4 = null;
  c === a.enumPolygon && (x4 = s4);
  const y2 = c === a.enumPolygon ? Yt(g2.getPathCount(), false) : [], P5 = Yt(u.getPathCount(), false);
  let E2 = false, S3 = false, C3 = false, I4 = false, b2 = false, w4 = false;
  do {
    if (C3 && b2 || I4 && w4) break;
    if (C3 && I4) break;
    const e5 = _.getRedElement(), o2 = _.getBlueElement();
    if (!P5[o2] && (h2.assign(s4.getXY(s4.getPathStart(o2))), m3.setCoords({ env2D: _.getRedEnvelope() }), m3.inflateCoords(r, r), m3.contains(h2))) {
      if (0 !== Lo2(p3, h2, 0)) {
        if (I4 = true, i2) return 4;
      } else w4 = true;
      P5[o2] = true;
    }
    if (c === a.enumPolygon && !y2[e5] && (a2.assign(t3.getXY(t3.getPathStart(e5))), l2.setCoords({ env2D: _.getBlueEnvelope() }), l2.inflateCoords(r, r), l2.contains(a2))) {
      if (0 !== Lo2(x4, a2, 0)) {
        if (C3 = true, i2) return 4;
      } else b2 = true;
      y2[e5] = true;
    }
    if (E2 || (!Wn2(t3, s4.getPathCount() - 1) || null !== g2.getAccelerators() && null !== g2.getAccelerators().getQuadTree() ? p3 = t3 : (t3.copyTo(d2), d2.getImpl().buildQuadTreeAccelerator(1), p3 = d2), E2 = true), c === a.enumPolygon && !S3) {
      const e6 = s4;
      !Wn2(e6, t3.getPathCount() - 1) || null !== u.getAccelerators() && null !== u.getAccelerators().getQuadTree() ? x4 = s4 : (e6.copyTo(f3), f3.getImpl().buildQuadTreeAccelerator(1), x4 = f3), S3 = true;
    }
  } while (_.next());
  if (!C3 && !I4) return 1;
  if (!b2 || !w4) {
    if (c === a.enumPolygon) {
      for (let e5 = 0, t4 = g2.getPathCount(); e5 < t4; e5++) if (!y2[e5]) {
        b2 = true;
        break;
      }
    }
    for (let e5 = 0, t4 = u.getPathCount(); e5 < t4; e5++) if (!P5[e5]) {
      w4 = true;
      break;
    }
  }
  return C3 && b2 || I4 && w4 || C3 && I4 ? 4 : I4 ? 2 : 3;
}
function co2(t3, s4, n6, r, i2) {
  const o = n4.constructEmpty();
  t3.queryEnvelope(o), o.inflateCoords(n6, n6);
  const a2 = new mi(), h2 = t3.getImpl(), m3 = new ur();
  let l2 = t3, g2 = false, u = false, c = false;
  for (let e5 = 0; e5 < s4.getPointCount(); e5++) {
    if (s4.queryXY(e5, a2), o.contains(a2)) {
      const e6 = Lo2(l2, a2, n6);
      if (1 === e6) return u = true, 4;
      if (2 === e6) return 4;
      c = true;
    } else c = true;
    g2 || (!Wn2(t3, s4.getPointCount() - 1) || null !== h2.getAccelerators() && null != h2.getAccelerators().getQuadTree() ? l2 = t3 : (t3.copyTo(m3), m3.getImpl().buildQuadTreeAccelerator(1), l2 = m3), g2 = true);
  }
  return u ? c ? 4 : 2 : 1;
}
function _o2(t3, s4, r, i2, o) {
  i2[0] = false;
  const h2 = t3.getImpl(), m3 = s4.getImpl(), l2 = h2.querySegmentIterator(), g2 = m3.querySegmentIterator(), u = [0, 0], c = [0, 0], _ = new Dr2(h2, m3, r);
  let d2 = false;
  for (; _.next(); ) {
    const e5 = _.getRedElement(), t4 = _.getBlueElement();
    l2.resetToVertex(e5, -1), g2.resetToVertex(t4, -1);
    const s5 = l2.nextSegment(), n6 = g2.nextSegment();
    let o2 = 0;
    if (Oo2(s5, n6) ? !d2 && n6.isIntersecting(s5, r) && (d2 = true) : o2 = n6.intersect(s5, null, c, u, r), 0 !== o2 && (d2 = true, 1 === o2)) {
      const e6 = u[0], t5 = c[0];
      if (e6 > 0 && e6 < 1 && t5 > 0 && t5 < 1) return i2[0] = true, false;
    }
  }
  if (!d2) {
    i2[0] = true;
    const o2 = n4.constructEmpty();
    t3.queryEnvelope(o2), o2.inflateCoords(r, r);
    const l3 = new ur();
    let g3 = t3, u2 = false;
    for (let n6 = 0, r2 = s4.getPathCount(); n6 < r2; n6++) if (s4.getPathSize(n6) > 0) {
      const r3 = n4.constructEmpty();
      if (s4.queryPathEnvelope(n6, r3), !o2.isIntersecting(r3)) return false;
      {
        const e5 = zn2(g3, s4.getXY(s4.getPathStart(n6)), 0);
        if (n2(-1 !== e5), 0 === e5) return false;
      }
      u2 || (!Wn2(t3, s4.getPathCount() - 1) || null !== h2.getAccelerators() && null !== h2.getAccelerators().getQuadTree() ? g3 = t3 : (t3.copyTo(l3), l3.getImpl().buildQuadTreeAccelerator(1), g3 = l3), u2 = true);
    }
    if (1 === t3.getPathCount() || s4.getGeometryType() === a.enumPolyline) return true;
    const c2 = s4, _2 = n4.constructEmpty();
    c2.queryEnvelope(_2), _2.inflateCoords(r, r);
    const d3 = new ur();
    let p3 = c2, f3 = false;
    for (let s5 = 0, n6 = t3.getPathCount(); s5 < n6; s5++) if (t3.getPathSize(s5) > 0) {
      const n7 = n4.constructEmpty();
      if (t3.queryPathEnvelope(s5, n7), _2.isIntersecting(n7)) {
        const e5 = zn2(p3, t3.getXY(t3.getPathStart(s5)), 0);
        if (n2(-1 !== e5), 1 === e5) return false;
      }
      f3 || (!Wn2(c2, t3.getPathCount() - 1) || null !== m3.getAccelerators() && null !== m3.getAccelerators().getQuadTree() ? p3 = c2 : (c2.copyTo(d3), d3.getImpl().buildQuadTreeAccelerator(1), p3 = d3), f3 = true);
    }
    return true;
  }
  return false;
}
function po2(t3, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: t3 }), r.inflateCoords(n6, n6), r.containsEnvelope(s4);
}
function fo2(t3, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: s4 }), r.inflateCoords(n6, n6), t3.containsExclusiveEnvelope(r);
}
function xo2(t3, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: s4 }), r.inflateCoords(n6, n6), !r.contains(t3.getLowerLeft()) || (!r.contains(t3.getLowerRight()) || (!r.contains(t3.getUpperLeft()) || !r.contains(t3.getUpperRight())));
}
function yo2(e5, t3, s4, n6) {
  if (e5.getPathCount() !== t3.getPathCount() || e5.getPointCount() !== t3.getPointCount()) return false;
  if (e5.hasNonLinearSegments() || t3.hasNonLinearSegments()) return e5.equals(t3);
  const r = new mi(), i2 = new mi();
  let o = true;
  const a2 = s4 * s4;
  for (let h2 = 0; h2 < e5.getPathCount(); h2++) {
    if (e5.getPathEnd(h2) !== t3.getPathEnd(h2)) {
      o = false;
      break;
    }
    for (let s5 = e5.getPathStart(h2); s5 < t3.getPathEnd(h2); s5++) if (e5.queryXY(s5, r), t3.queryXY(s5, i2), mi.sqrDistance(r, i2) > a2) {
      o = false;
      break;
    }
    if (!o) break;
  }
  return !!o;
}
function Po2(e5, t3, s4, n6) {
  if (e5.getPointCount() !== t3.getPointCount()) return false;
  const r = new mi(), i2 = new mi();
  let o = true;
  const a2 = s4 * s4;
  for (let h2 = 0; h2 < e5.getPointCount(); h2++) if (e5.queryXY(h2, r), t3.queryXY(h2, i2), mi.sqrDistance(r, i2) > a2) {
    o = false;
    break;
  }
  return !!o;
}
function Eo2(e5, t3, s4, n6, r, i2, o) {
  const a2 = e5.getImpl(), h2 = t3.getImpl(), m3 = a2.getPointCount(), l2 = h2.getPointCount(), g2 = Yt(m3, false), u = r || i2 ? Yt(l2, false) : [], c = s4 * s4, _ = new Dr2(a2, h2, s4);
  for (; _.next(); ) {
    const e6 = _.getRedElement(), t4 = _.getBlueElement(), s5 = a2.getXY(e6), n7 = h2.getXY(t4);
    mi.sqrDistance(s5, n7) <= c && (g2[e6] = true, (r || i2) && (u[t4] = true));
  }
  let d2 = false, p3 = false;
  for (let y2 = 0; y2 < m3; y2++) {
    const e6 = g2[y2];
    if (d2 ||= !e6, p3 ||= e6, (r || n6) && d2) return false;
  }
  if (n6) return true;
  let f3 = false, x4 = false;
  for (let y2 = 0; y2 < l2; y2++) {
    const e6 = u[y2];
    if (f3 ||= !e6, x4 ||= e6, r && f3) return false;
  }
  return !!r || d2 && p3 && f3 && x4;
}
function So2(e5, t3, s4, n6) {
  return Co2(e5, t3, s4, n6) && Co2(t3, e5, s4, n6);
}
function Co2(t3, s4, n6, r) {
  if (N(t3), N(s4), s4.isEmpty()) return false;
  let o = true;
  const a2 = Yt(2, Number.NaN), h2 = Yt(2, Number.NaN), m3 = [], l2 = new Ro2();
  let g2;
  const u = n4.constructEmpty(), c = n4.constructEmpty(), _ = n4.constructEmpty();
  t3.queryEnvelope(u), s4.queryEnvelope(c), u.inflateCoords(n6, n6), c.inflateCoords(n6, n6), _.setCoords({ env2D: u }), _.intersect(c);
  const d2 = t3.getImpl().querySegmentIterator(), p3 = s4.getImpl().querySegmentIterator(), f3 = s4.getImpl().getAccelerators();
  let x4 = null, P5 = null, E2 = null, S3 = null;
  if (null !== f3 && (x4 = f3.getQuadTree(), P5 = f3.getQuadTreeForPaths(), null !== P5 && (S3 = P5.getIteratorForQT())), null === x4) {
    const e5 = t3.getPointCount(), n7 = s4.getPointCount();
    e5 > 10 && n7 > 10 && (x4 = Wt2(s4.getImpl(), _));
  }
  for (null !== x4 && (E2 = x4.getIteratorForQT()); d2.nextPath(); ) for (; d2.hasNextSegment(); ) {
    let e5 = d2.nextSegment();
    if (e5.queryEnvelope(u), !u.isIntersecting(_)) return o = false, false;
    if (null !== S3 && (S3.resetIterator(u, n6), -1 === S3.next())) continue;
    let t4 = 0, s5 = null;
    if (null != E2) E2.resetIterator(e5, n6);
    else if (p3.resetToFirstPath(), !p3.nextPath()) return o = false, false;
    do {
      if (t4 = 0, null !== E2) {
        const r2 = E2.next();
        if (-1 === r2) return o = false, false;
        p3.resetToVertex(x4.getElement(r2), -1), s5 = p3.nextSegment(), t4 = e5.intersect(s5, null, a2, h2, n6);
      } else {
        for (; !p3.hasNextSegment(); ) if (!p3.nextPath()) return o = false, false;
        s5 = p3.nextSegment(), s5.queryEnvelope(c), c.inflateCoords(n6, n6), u.isIntersecting(c) && (t4 = e5.intersect(s5, null, a2, h2, n6));
      }
    } while (2 !== t4 || 0 !== a2[0] || r && !(h2[0] <= h2[1]));
    let f4 = Number.NaN, y2 = false;
    do {
      let r2 = false;
      if (1 === a2[1]) {
        if (!d2.hasNextSegment()) {
          y2 = true;
          break;
        }
        e5 = d2.nextSegment(), r2 = true;
      }
      if (1 === h2[1] && h2[0] <= h2[1]) {
        if (-1 === f4) break;
        if (f4 = 1, !p3.hasNextSegment()) break;
        s5 = p3.nextSegment(), r2 = true;
      }
      if (0 === h2[1] && h2[0] > h2[1]) {
        if (1 === f4) break;
        if (Number.isNaN(f4)) {
          if (!p3.hasPreviousSegment()) break;
          p3.previousSegment(), f4 = -1;
        }
        if (!p3.hasPreviousSegment()) break;
        s5 = p3.previousSegment(), r2 = true;
      }
      if (!r2) break;
      t4 = e5.intersect(s5, null, a2, h2, n6);
    } while (2 === t4 && (!r || h2[0] <= h2[1]));
    if (y2) continue;
    const P6 = e5.calculateLength2D();
    e5.queryEnvelope(u), m3.length = 0, l2.m_overlapEvents.length = 0;
    let C3 = false, I4 = false, b2 = 0;
    const w4 = zt2(null, u, true);
    for (null !== E2 ? E2.resetIterator(e5, n6) : (p3.resetToFirstPath(), p3.nextPath() || b("relational_operations")); ; ) {
      if (t4 = 0, null !== E2) {
        const r2 = E2.next();
        if (-1 === r2) break;
        p3.resetToVertex(x4.getElement(r2), -1), s5 = p3.nextSegment(), t4 = e5.intersect(s5, null, a2, h2, n6);
      } else {
        for (; !p3.hasNextSegment() && p3.nextPath(); ) ;
        if (!p3.hasNextSegment()) break;
        s5 = p3.nextSegment(), s5.queryEnvelope(c), c.inflateCoords(n6, n6), u.isIntersecting(c) && (t4 = e5.intersect(s5, null, a2, h2, n6));
      }
      if (2 === t4 && (!r || h2[0] <= h2[1])) {
        const e6 = d2.getStartPointIndex(), t5 = d2.getPathIndex(), s6 = p3.getStartPointIndex(), r2 = p3.getPathIndex();
        if (g2 = Yo2(e6, t5, a2[0], a2[1], s6, r2, h2[0], h2[1]), l2.m_overlapEvents.push(g2), m3.push(m3.length), !(C3 || g2.m_scalarA0 < b2 && g2.m_scalarA1 < b2)) {
          if (0 === b2 && P6 * (g2.m_scalarA0 - b2) > n6) C3 = true;
          else if (0 !== b2 && P6 * (g2.m_scalarA0 - b2) > w4) C3 = true;
          else if (b2 = g2.m_scalarA1, P6 * (1 - b2) <= n6 || 1 === b2) {
            I4 = true;
            break;
          }
        }
      }
    }
    if (!I4) {
      if (!C3) return o = false, false;
      m3.length > 1 && m3.sort((e6, t5) => l2.compareOverlapEvents(e6, t5)), b2 = 0;
      for (let e6 = 0; e6 < l2.m_overlapEvents.length; e6++) if (g2 = l2.m_overlapEvents[m3[e6]], !(g2.m_scalarA0 < b2 && g2.m_scalarA1 < b2)) {
        if (0 === b2 && P6 * (g2.m_scalarA0 - b2) > n6) return o = false, false;
        if (0 !== b2 && P6 * (g2.m_scalarA0 - b2) > w4) return o = false, false;
        if (b2 = g2.m_scalarA1, P6 * (1 - b2) <= n6 || 1 === b2) break;
      }
      if (P6 * (1 - b2) > n6) return o = false, false;
      m3.length = 0, l2.m_overlapEvents.length = 0;
    }
  }
  return o;
}
function Io2(e5, t3, s4) {
  const n6 = e5.getImpl(), r = t3.getImpl(), i2 = n6.querySegmentIterator(), o = r.querySegmentIterator(), a2 = new Dr2(n6, r, s4);
  for (; a2.next(); ) {
    const e6 = a2.getRedElement(), t4 = a2.getBlueElement();
    i2.resetToVertex(e6, -1), o.resetToVertex(t4, -1);
    const n7 = i2.nextSegment();
    if (o.nextSegment().isIntersecting(n7, s4)) return true;
  }
  return false;
}
function bo2(e5, t3, s4, n6) {
  const r = e5.getImpl(), i2 = t3.getImpl(), o = r.querySegmentIterator(), a2 = i2.querySegmentIterator(), h2 = Yt(2, Number.NaN), m3 = new Dr2(r, i2, s4);
  let l2 = false, g2 = -1;
  for (; m3.next(); ) {
    const e6 = m3.getRedElement(), t4 = m3.getBlueElement();
    o.resetToVertex(e6, -1), a2.resetToVertex(t4, -1);
    const r2 = o.nextSegment(), i3 = a2.nextSegment();
    let u = 0;
    if (Oo2(r2, i3)) {
      if (i3.isIntersecting(r2, s4)) return -2;
    } else u = r2.intersect(i3, null, h2, null, s4);
    if (u) {
      if (2 === u) {
        const e7 = r2.calculateLength2D(), t5 = h2[0];
        if (e7 * (h2[1] - t5) > s4) return g2 = 1, g2;
        l2 = true;
      } else if (g2 = 0, n6) {
        const e7 = h2[0], t5 = new mi();
        r2.queryCoord2D(e7, t5), n6.push(t5.x), n6.push(t5.y);
      }
    }
  }
  return l2 ? -2 : g2;
}
function wo2(e5, t3, s4, n6) {
  const r = e5.getImpl(), i2 = t3, o = i2.getPointCount(), a2 = n6 ? Yt(o, false) : [], h2 = new Dr2(r, i2, s4, false), m3 = r.querySegmentIterator();
  for (; h2.next(); ) {
    const e6 = h2.getRedElement(), t4 = h2.getBlueElement();
    m3.resetToVertex(e6, -1);
    const r2 = m3.nextSegment(), o2 = i2.getXY(t4);
    if (r2.isIntersectingPoint(o2, s4)) {
      if (!n6) return true;
      a2[t4] = true;
    }
  }
  if (!n6) return false;
  for (let l2 = 0; l2 < o; l2++) if (!a2[l2]) return false;
  return true;
}
function vo2(t3, s4, n6) {
  const r = new mi(), i2 = n6 * n6, o = t3.querySegmentIterator(), a2 = t3.getImpl().getAccelerators();
  if (null !== a2) {
    const t4 = a2.getQuadTree();
    if (null !== t4) {
      const a3 = n4.constructEmpty();
      a3.setCoords({ pt: s4 });
      const h3 = t4.getIterator(a3, n6);
      for (let e5 = h3.next(); -1 !== e5; e5 = h3.next()) if (o.resetToVertex(t4.getElement(e5), -1), o.hasNextSegment()) {
        const e6 = o.nextSegment(), t5 = e6.getClosestCoordinate(s4, false);
        if (e6.queryCoord2D(t5, r), mi.sqrDistance(s4, r) <= i2) return true;
      }
      return false;
    }
  }
  const h2 = n4.constructEmpty();
  for (; o.nextPath(); ) for (; o.hasNextSegment(); ) {
    const e5 = o.nextSegment();
    if (e5.queryEnvelope(h2), h2.inflateCoords(n6, n6), !h2.contains(s4)) continue;
    const t4 = e5.getClosestCoordinate(s4, false);
    if (e5.queryCoord2D(t4, r), mi.sqrDistance(s4, r) <= i2) return true;
  }
  return false;
}
function No2(e5, t3, s4) {
  return vo2(e5, t3, s4) && !qo2(e5, t3, s4);
}
function To2(t3, s4, r, i2) {
  const o = t3.querySegmentIterator(), a2 = t3.getImpl().getAccelerators(), h2 = t3.hasNonLinearSegments();
  let m3 = null, l2 = null, g2 = null, u = null;
  if (null !== a2) {
    const t4 = a2.getQuadTree();
    if (null !== t4) {
      const i3 = t4.getIterator(s4, r);
      h2 && (m3 = new pm(), l2 = new pm(), g2 = new pm(), u = new pm(), s4.querySide(0, m3), s4.querySide(1, l2), s4.querySide(2, g2), s4.querySide(3, u));
      const a3 = n4.constructEmpty();
      a3.setCoords({ env2D: s4 }), a3.inflateCoords(r, r);
      for (let e5 = i3.next(); -1 !== e5; e5 = i3.next()) if (o.resetToVertex(t4.getElement(e5), -1), o.hasNextSegment()) {
        const e6 = o.nextSegment();
        if (e6.getGeometryType() === a.enumLine) {
          const t5 = e6.getStartXY(), s5 = e6.getEndXY();
          if (a3.clipLine(t5, s5)) return true;
          continue;
        }
        if (s4.contains(e6.getStartXY()) || s4.contains(e6.getEndXY())) return true;
        if (e6.isIntersecting(m3, r)) return true;
        if (e6.isIntersecting(l2, r)) return true;
        if (e6.isIntersecting(g2, r)) return true;
        if (e6.isIntersecting(u, r)) return true;
      }
      return false;
    }
  }
  if (h2) {
    m3 = new pm(), l2 = new pm(), g2 = new pm(), u = new pm(), s4.querySide(0, m3), s4.querySide(1, l2), s4.querySide(2, g2), s4.querySide(3, u);
    const e5 = t3.querySegmentIterator();
    for (; e5.nextPath(); ) for (; e5.hasNextSegment(); ) {
      const t4 = e5.nextSegment();
      if (s4.contains(t4.getStartXY()) || s4.contains(t4.getEndXY())) return true;
      if (t4.isIntersecting(m3, r)) return true;
      if (t4.isIntersecting(l2, r)) return true;
      if (t4.isIntersecting(g2, r)) return true;
      if (t4.isIntersecting(u, r)) return true;
    }
  } else {
    const n6 = n4.constructEmpty();
    n6.setCoords({ env2D: s4 }), n6.inflateCoords(r, r);
    const i3 = t3.getImpl(), o2 = i3.getAttributeStreamRef(0), a3 = new mi();
    for (let e5 = 0, t4 = i3.getPathCount(); e5 < t4; e5++) {
      let t5 = true;
      const s5 = new mi(), r2 = new mi(), h3 = new mi(), m4 = i3.getPathStart(e5), l3 = new mi();
      for (let g3 = m4, u2 = i3.getPathEnd(e5); g3 < u2; g3++) if (t5) o2.queryPoint2D(2 * g3, s5), l3.assign(s5), t5 = false;
      else {
        if (o2.queryPoint2D(2 * g3, a3), r2.setCoordsPoint2D(s5), h3.setCoordsPoint2D(a3), n6.clipLine(r2, h3)) return true;
        s5.assign(a3);
      }
      if (i3.isClosedPath(e5) && !t5 && (r2.setCoordsPoint2D(s5), h3.setCoordsPoint2D(l3), n6.clipLine(r2, h3))) return true;
    }
  }
  return false;
}
function Go2(t3, s4, n6, r) {
  const i2 = t3.getImpl(), o = s4.getImpl(), a2 = [0], h2 = Ht2(i2.getIsSimple(0, a2)) && Ht2(o.getIsSimple(0, a2)), m3 = i2.querySegmentIterator(), l2 = o.querySegmentIterator(), g2 = Yt(2, 0), u = Yt(2, 0), c = new Dr2(i2, o, n6);
  let _ = false;
  for (; c.next(); ) {
    const e5 = c.getRedElement(), t4 = c.getBlueElement();
    m3.resetToVertex(e5, -1), l2.resetToVertex(t4, -1);
    const s5 = m3.nextSegment(), r2 = l2.nextSegment();
    let i3 = 0;
    if (Oo2(s5, r2)) {
      if (r2.isIntersecting(s5, n6)) {
        _ = true;
        break;
      }
    } else i3 = r2.intersect(s5, null, u, g2, n6);
    if (2 === i3) {
      const e6 = g2[0], t5 = g2[1], r3 = s5.calculateLength2D();
      if (h2 && (t5 - e6) * r3 > n6) return false;
      _ = true;
    } else if (i3) {
      const e6 = g2[0], t5 = u[0];
      if (e6 > 0 && e6 < 1 && t5 > 0 && t5 < 1) return false;
      _ = true;
    }
  }
  if (!_) return false;
  const d2 = n4.constructEmpty(), p3 = n4.constructEmpty(), f3 = n4.constructEmpty();
  let x4, y2;
  if (t3.queryEnvelope(d2), s4.queryEnvelope(p3), d2.inflateCoords(1e3 * n6, 1e3 * n6), p3.inflateCoords(1e3 * n6, 1e3 * n6), f3.setCoords({ env2D: d2 }), f3.intersect(p3), t3.getPointCount() > 10) {
    if (x4 = f2(t3, f3, n6, 0, r), x4.isEmpty()) return false;
  } else x4 = t3;
  if (s4.getPointCount() > 10) {
    if (y2 = f2(s4, f3, n6, 0, r), y2.isEmpty()) return false;
  } else y2 = s4;
  return sr2(x4, y2, n6, "F********", r, false);
}
function Do2(t3, s4, n6, r) {
  const i2 = t3.getImpl(), o = s4.getImpl(), a2 = [0], h2 = Ht2(i2.getIsSimple(0, a2)) && Ht2(o.getIsSimple(0, a2)), m3 = n4.constructEmpty(), l2 = n4.constructEmpty(), g2 = n4.constructEmpty();
  t3.queryEnvelope(m3), s4.queryEnvelope(l2);
  let u = false;
  const c = xo2(m3, l2, n6), _ = xo2(l2, m3, n6), d2 = i2.querySegmentIterator(), p3 = o.querySegmentIterator(), f3 = Yt(2, Number.NaN), x4 = Yt(2, Number.NaN), y2 = new Dr2(i2, o, n6);
  for (; y2.next(); ) {
    const e5 = y2.getRedElement(), t4 = y2.getBlueElement();
    d2.resetToVertex(e5, -1), p3.resetToVertex(t4, -1);
    const s5 = d2.nextSegment(), r2 = p3.nextSegment();
    let i3 = 0;
    if (Oo2(s5, r2)) {
      if (r2.isIntersecting(s5, n6)) break;
    } else i3 = r2.intersect(s5, null, x4, f3, n6);
    if (2 === i3) {
      const e6 = f3[0], t5 = f3[1], r3 = s5.calculateLength2D();
      if (h2 && (t5 - e6) * r3 > n6 && (u = true, c && _)) return true;
    } else if (i3) {
      const e6 = f3[0], t5 = x4[0];
      if (e6 > 0 && e6 < 1 && t5 > 0 && t5 < 1) return true;
    }
  }
  const P5 = n4.constructEmpty(), E2 = n4.constructEmpty();
  let S3, C3;
  P5.setCoords({ env2D: m3 }), P5.inflateCoords(1e3 * n6, 1e3 * n6), E2.setCoords({ env2D: l2 }), E2.inflateCoords(1e3 * n6, 1e3 * n6), g2.setCoords({ env2D: P5 }), g2.intersect(E2);
  let I4 = "";
  if (I4 += u ? "**" : "T*", c) {
    if (s4.getPointCount() > 10) {
      if (C3 = f2(s4, g2, n6, 0, r), C3.isEmpty()) return false;
    } else C3 = s4;
    I4 += "****";
  } else C3 = s4, I4 += "T***";
  if (_) {
    if (t3.getPointCount() > 10) {
      if (S3 = f2(t3, g2, n6, 0, r), S3.isEmpty()) return false;
    } else S3 = t3;
    I4 += "***";
  } else S3 = t3, I4 += "T**";
  return sr2(S3, C3, n6, I4, r, false);
}
function Vo2(t3, s4, n6, r) {
  const i2 = [false], o = _o2(t3, s4, n6, i2);
  if (i2[0]) return o;
  const a2 = n4.constructEmpty();
  let h2;
  if (s4.queryEnvelope(a2), a2.inflateCoords(1e3 * n6, 1e3 * n6), t3.getPointCount() > 10) {
    if (h2 = f2(t3, a2, n6, 0, r), h2.isEmpty()) return false;
  } else h2 = t3;
  return nr2(h2, s4, n6, r);
}
function Fo2(t3, s4, n6, r) {
  const i2 = t3.getImpl(), o = s4.getImpl(), a2 = i2.querySegmentIterator(), h2 = o.querySegmentIterator(), m3 = Yt(2, Number.NaN), l2 = Yt(2, Number.NaN), g2 = new Dr2(i2, o, n6);
  let u = false;
  for (; g2.next(); ) {
    const e5 = g2.getRedElement(), t4 = g2.getBlueElement();
    a2.resetToVertex(e5, -1), h2.resetToVertex(t4, -1);
    const s5 = a2.nextSegment(), r2 = h2.nextSegment();
    let i3 = 0;
    if (Oo2(s5, r2) ? !u && r2.isIntersecting(s5, n6) && (u = true) : i3 = r2.intersect(s5, null, l2, m3, n6), 2 === i3) u = true;
    else if (i3) {
      const e6 = m3[0], t5 = l2[0];
      if (e6 > 0 && e6 < 1 && t5 > 0 && t5 < 1) return false;
      u = true;
    }
  }
  if (!u) return false;
  const c = n4.constructEmpty(), _ = n4.constructEmpty(), d2 = n4.constructEmpty();
  let p3, f3;
  if (t3.queryEnvelope(c), s4.queryEnvelope(_), c.inflateCoords(1e3 * n6, 1e3 * n6), _.inflateCoords(1e3 * n6, 1e3 * n6), d2.setCoords({ env2D: c }), d2.intersect(_), t3.getPointCount() > 10) {
    if (p3 = f2(t3, d2, n6, 0, r), p3.isEmpty()) return false;
  } else p3 = t3;
  if (s4.getPointCount() > 10) {
    if (f3 = f2(s4, d2, n6, 0, r), f3.isEmpty()) return false;
  } else f3 = s4;
  return sr2(p3, f3, n6, "F********", r, false);
}
function Ho2(t3, s4, n6, r) {
  const i2 = t3.getImpl(), o = s4.getImpl(), a2 = i2.querySegmentIterator(), h2 = o.querySegmentIterator(), m3 = Yt(2, Number.NaN), l2 = Yt(2, Number.NaN), g2 = new Dr2(i2, o, n6);
  let u = false;
  for (; g2.next(); ) {
    const e5 = g2.getRedElement(), t4 = g2.getBlueElement();
    a2.resetToVertex(e5, -1), h2.resetToVertex(t4, -1);
    const s5 = a2.nextSegment(), r2 = h2.nextSegment();
    let i3 = 0;
    if (Oo2(s5, r2) ? !u && r2.isIntersecting(s5, n6) && (u = true) : i3 = r2.intersect(s5, null, l2, m3, n6), 2 === i3) u = true;
    else if (i3) {
      const e6 = m3[0], t5 = l2[0];
      if (e6 > 0 && e6 < 1 && t5 > 0 && t5 < 1) return true;
      u = true;
    }
  }
  if (!u) return false;
  const c = n4.constructEmpty(), _ = n4.constructEmpty(), d2 = n4.constructEmpty(), p3 = n4.constructEmpty(), f3 = n4.constructEmpty();
  if (t3.queryEnvelope(c), s4.queryEnvelope(_), xo2(_, c, n6)) {
    let e5, i3;
    if (d2.setCoords({ env2D: c }), d2.inflateCoords(1e3 * n6, 1e3 * n6), p3.setCoords({ env2D: _ }), p3.inflateCoords(1e3 * n6, 1e3 * n6), f3.setCoords({ env2D: d2 }), f3.intersect(p3), t3.getPointCount() > 10) {
      if (e5 = f2(t3, f3, n6, 0, r), e5.isEmpty()) return false;
    } else e5 = t3;
    if (s4.getPointCount() > 10) {
      if (i3 = f2(s4, f3, n6, 0, r), i3.isEmpty()) return false;
    } else i3 = s4;
    return sr2(e5, i3, n6, "T********", r, false);
  }
  return sr2(t3, s4, n6, "T*****T**", r, false);
}
function ko2(t3, s4, n6, r) {
  const i2 = [false], o = _o2(t3, s4, n6, i2);
  if (i2[0]) return o;
  const a2 = n4.constructEmpty();
  let h2;
  if (s4.queryEnvelope(a2), a2.inflateCoords(1e3 * n6, 1e3 * n6), t3.getPointCount() > 10) {
    if (h2 = f2(t3, a2, n6, 0, r), h2.isEmpty()) return false;
  } else h2 = t3;
  return rr2(h2, s4, n6, r);
}
function Ao2(e5, t3, s4, n6) {
  return 1 === Lo2(e5, t3, s4);
}
function Mo2(e5, t3, s4, n6) {
  return 2 === Lo2(e5, t3, s4);
}
function Uo2(e5, t3, s4, n6) {
  const r = new mi(), i2 = s4 * s4;
  for (let o = 0; o < e5.getPointCount(); o++) if (e5.queryXY(o, r), mi.sqrDistance(r, t3) <= i2) return false;
  return true;
}
function qo2(e5, t3, s4) {
  const n6 = e5.getBoundary();
  return !n6.isEmpty() && !Uo2(n6, t3, s4);
}
function Bo2(t3, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: t3 }), r.inflateCoords(n6, n6), r.containsEnvelope(s4) ? 1073741824 : r.isIntersecting(s4) ? t3.isIntersecting(s4) ? t3.xmin < s4.xmin && s4.xmax < t3.xmax ? s4.ymin < t3.ymin && s4.ymax > t3.ymax ? 0 : 1073741824 : t3.ymin < s4.ymin && s4.ymax < t3.ymax ? s4.xmin < t3.xmin && s4.xmax > t3.xmax ? 0 : 1073741824 : 0 : 0 : 4;
}
function Oo2(e5, t3) {
  return e5.getGeometryType() !== a.enumLine || t3.getGeometryType() !== a.enumLine;
}
function Yo2(e5, t3, s4, n6, r, i2, o, a2) {
  return { m_ivertexA: e5, m_ipathA: t3, m_scalarA0: s4, m_scalarA1: n6, m_ivertexB: r, m_ipathB: i2, m_scalarB0: o, m_scalarB1: a2 };
}
var Ro2 = class {
  constructor() {
    this.m_overlapEvents = [];
  }
  compareOverlapEvents(e5, t3) {
    const s4 = this.m_overlapEvents[e5], n6 = this.m_overlapEvents[t3];
    if (s4.m_ipathA < n6.m_ipathA) return -1;
    if (s4.m_ipathA === n6.m_ipathA) {
      if (s4.m_ivertexA < n6.m_ivertexA) return -1;
      if (s4.m_ivertexA === n6.m_ivertexA) {
        if (s4.m_scalarA0 < n6.m_scalarA0) return -1;
        if (s4.m_scalarA0 === n6.m_scalarA0) {
          if (s4.m_scalarA1 < n6.m_scalarA1) return -1;
          if (s4.m_scalarA1 === n6.m_scalarA1 && s4.m_ivertexB < n6.m_ivertexB) return -1;
        }
      }
    }
    return 1;
  }
};
function Xo2(e5, t3, s4) {
  const n6 = Ln2(e5, t3, s4);
  return n6 ? 1 === n6 ? 1 : 2 : 0;
}
function Lo2(e5, t3, s4) {
  const n6 = zn2(e5, t3, s4);
  return n6 ? 1 === n6 ? 1 : 2 : 0;
}
function zo2(e5, t3, s4, n6, r) {
  for (let i2 = 0; i2 < s4; i2++) r[i2] = Lo2(e5, t3[i2], n6);
}
function Wo2(t3, s4, r, i2, o) {
  if (t3.getGeometryType() === a.enumPolygon) zo2(t3, s4, r, i2, o);
  else if (t3.getGeometryType() === a.enumEnvelope) {
    const n6 = n4.constructEmpty();
    t3.queryEnvelope(n6), Zo2(n6, s4, r, i2, o);
  } else C("");
}
function jo2(e5, t3, s4, i2, o) {
  const a2 = e5.getGeometryType();
  a2 === a.enumPolyline ? $o2(e5, t3, s4, i2, o) : f(a2) ? Jo2() : C("");
}
function Zo2(e5, t3, s4, n6, r) {
  if (e5.isEmpty()) {
    for (let e6 = 0; e6 < s4; e6++) r[e6] = 0;
    return;
  }
  const i2 = e5.clone();
  i2.inflateCoords(0.5 * -n6, 0.5 * -n6);
  const o = e5.clone();
  o.inflateCoords(0.5 * n6, 0.5 * n6);
  for (let a2 = 0; a2 < s4; a2++) i2.contains(t3[a2]) ? r[a2] = 1 : o.contains(t3[a2]) ? r[a2] = 2 : r[a2] = 0;
}
function Ko2(e5) {
  if (e5.isEmpty()) return 0;
  switch (e5.getGeometryType()) {
    case a.enumMultiPoint:
      return e5.getImpl().getPointCount();
    case a.enumPolyline:
      return e5.getImpl().getPathCount();
    case a.enumPolygon:
      return e5.getImpl().getOGCPolygonCount();
    case a.enumGeometryCollection:
      return e5.getGeometryCount();
  }
  return 1;
}
function Qo2(e5, t3, s4) {
  if (s4.reset(), t3 < 3) return;
  const n6 = e5[0].clone(), r = n6.x, i2 = n6.y, o = e5[1].clone(), a2 = new mi();
  for (let h2 = 2; h2 < t3; h2++) a2.assign(e5[h2]), s4.pe((a2.x - n6.x) * (o.y - i2)), n6.assign(o), o.assign(a2);
  s4.pe((r - n6.x) * (o.y - i2));
}
function Jo2(e5, t3, s4, n6, r) {
  n2(0);
}
function $o2(t3, s4, n6, r, i2) {
  const o = t3.getImpl(), h2 = o.getAccelerators();
  let m3 = null;
  h2 && (m3 = h2.getRasterizedGeometry());
  let l2 = n6;
  for (let e5 = 0; e5 < n6; e5++) i2[e5] = 1, m3 && n2(0);
  if (l2) {
    if (h2) {
      let t5 = null;
      null !== h2 && null !== h2.getQuadTree() && (t5 = h2.getQuadTree());
      const a2 = o.getPointCount();
      if (null === t5 && a2 > 20 && a2 * n6 > 4 * a2 + Math.log(a2) * n6 && (t5 = Wt2(o)), t5) {
        let a3 = null;
        const h3 = o.querySegmentIterator(), m4 = new n4();
        for (let e5 = 0; e5 < n6 && l2; e5++) if (1 === i2[e5]) {
          m4.setCoords(s4[e5]), null === a3 ? a3 = t5.getIterator(m4, r) : a3.resetIterator(m4, r);
          let n7 = -1;
          for (let o2 = a3.next(); -1 !== o2; o2 = a3.next()) {
            h3.resetToVertex(t5.getElement(o2), n7), n7 = h3.getPathIndex();
            if (h3.nextSegment().isIntersectingPoint(s4[e5], r)) {
              i2[e5] = 2, l2--;
              break;
            }
            i2[e5] = 0;
          }
        }
        return;
      }
    }
    const t4 = o.querySegmentIterator();
    for (; t4.nextPath() && l2; ) for (; t4.hasNextSegment() && l2; ) {
      const e5 = t4.nextSegment();
      for (let t5 = 0; t5 < n6 && l2; t5++) 1 === i2[t5] && e5.isIntersectingPoint(s4[t5], r) && (i2[t5] = 2, l2--);
    }
  }
  for (let e5 = 0; e5 < n6; e5++) 1 === i2[e5] && (i2[e5] = 0);
}
function ea2(e5, t3, s4, n6, r) {
  const i2 = is(t3), o = Math.max(4 * i2, s4);
  return new oa2(t3, null, o, Number.NaN, r).approximateWithCirclesImpl(e5, n6);
}
function ta2() {
  return Number.isNaN(this.radius.value());
}
function sa2() {
  return { ptStart: new mi(), ptEnd: new mi(), center: new Ye(), radius: new p2(), fcenter: new Xe(), fradius2: new si(), maxError: Number.NaN, isLine: ta2 };
}
var na2 = 5;
var ra2 = 1 / 8;
function ia2(e5, t3, s4, n6) {
  return { pt: e5.clone(), t: t3, err: s4, checkCount: n6 };
}
var oa2 = class _oa {
  constructor(e5, t3, s4, n6, r) {
    this.m_left = e5, this.m_tracker = r, this.m_eps = s4, this.m_trackerCounter = 0, this.m_tolerance = n6, this.m_circleCheckCounter = 0, this.m_bReversedLeft = false, this.m_leftArc = sa2();
  }
  closeToCircularArc(e5, t3, s4, n6, r, i2) {
    if (this.m_circleCheckCounter++, i2.maxError = 0, !_oa.checkSweepAngle(e5, t3)) return false;
    if (i2.ptStart.setCoordsPoint2D(s4), i2.ptEnd.setCoordsPoint2D(r), e5.isCircular()) {
      const t4 = e5;
      return i2.fradius2 = si.constructDouble(t4.getSemiMajorAxis()).mulDouble(t4.getSemiMajorAxis()), i2.radius.set(t4.getSemiMajorAxis()), i2.fcenter.assignPoint2D(t4.getCenter()), i2.center.set(t4.getCenter()), true;
    }
    const o = i2.ptEnd.sub(i2.ptStart).clone();
    o.leftPerpendicularThis(), o.normalize();
    if (Math.abs(o.dotProduct(n6.sub(i2.ptStart))) <= this.m_eps) return !!this.confirmIsLine(i2, o) && (i2.radius.set(Number.NaN), i2.center.setCoords(0, 0), true);
    {
      const s5 = i2.ptEnd.sub(i2.ptStart), r2 = n6.sub(i2.ptStart), o2 = s5.crossProduct(r2);
      if (0 === o2) return false;
      const a3 = 0.5 * s5.sqrLength(), h3 = 0.5 * r2.sqrLength();
      let m4 = a3 * r2.y - h3 * s5.y;
      m4 /= o2;
      let l3 = s5.x * h3 - r2.x * a3;
      l3 /= o2;
      const g3 = Math.sqrt(m4 * m4 + l3 * l3);
      if (4 * Number.EPSILON * g3 > this.m_eps) return false;
      const u2 = m4 + i2.ptStart.x, c2 = l3 + i2.ptStart.y;
      i2.radius.set(g3), i2.center.setCoords(u2, c2);
      const _2 = this.maxCircleApproximationError(e5, t3, i2);
      if (_2 > this.m_eps) return i2.maxError = _2, false;
    }
    const a2 = new Xe().assignPoint2D(i2.ptStart), h2 = new Xe().assignPoint2D(i2.ptEnd).sub(a2), m3 = new Xe().assignPoint2D(n6).sub(a2), l2 = h2.crossProduct(m3);
    if (l2.isZero()) return false;
    const g2 = h2.sqrLength().mulDouble(0.5), u = m3.sqrLength().mulDouble(0.5), c = g2.mul(m3.y).sub(u.mul(h2.y)), _ = h2.x.mul(u).sub(m3.x.mul(g2)), d2 = c.mul(c).add(_.mul(_)), p3 = l2.clone();
    p3.invertThis(), i2.fradius2 = d2.mul(p3).mul(p3), i2.fcenter.setCoords(c.mul(p3).add(a2.x), _.mul(p3).add(a2.y)), i2.center.setWithEps(i2.fcenter.asPoint2D()), i2.radius.setWithEps(Math.sqrt(i2.fradius2.toDouble()));
    const f3 = Ye.constructPoint2D(i2.ptStart).subE(i2.center), x4 = Ye.constructPoint2D(i2.ptEnd).subE(i2.center);
    if (!f3.dotProduct(x4).gt(I2)) return false;
    const y2 = this.maxCircleApproximationError(e5, t3, i2);
    return i2.maxError = y2, y2 <= this.m_eps;
  }
  static checkSweepAngle(e5, t3) {
    if (e5.getGeometryType() === a.enumEllipticArc) {
      const s4 = e5, n6 = cu(s4, t3.vmin), r = cu(s4, t3.vmax);
      return !(Math.abs(r - n6) > 0.5 * Wt);
    }
    return true;
  }
  confirmIsLine(e5, t3) {
    const s4 = e5.ptEnd.sub(e5.ptStart);
    return !(Math.abs(t3.dotProduct(s4.mul(0.25))) > this.m_eps) && !(Math.abs(t3.dotProduct(s4.mul(0.75))) > this.m_eps);
  }
  maxCircleApproximationError(e5, t3, s4) {
    const r = [0.25, 0.75], i2 = [0.1, 0.25, 0.75, 0.9];
    let o, a2;
    e5.getGeometryType() === a.enumEllipticArc ? (o = r, a2 = r.length) : (o = i2, a2 = i2.length);
    let h2 = 0;
    for (let n6 = 0; n6 < a2; ++n6) {
      const r2 = new mi();
      e5.queryCoord2D(Q(t3.vmin, t3.vmax, o[n6]), r2);
      const i3 = r2.sub(s4.center.value()).length(), a3 = Math.abs(i3 - s4.radius.value());
      a3 > h2 && (h2 = a3);
    }
    return h2;
  }
  approximateWithCirclesImpl(e5, t3) {
    let s4 = 1;
    t3 && t3.push(0);
    const n6 = Yt(9, Number.NaN);
    let r;
    e5 ? r = this.m_left.getMonotonicPartParams(n6.length, n6) : (n6[0] = 0, n6[1] = 1, r = 2);
    const i2 = [], o = [], a2 = new mi(0, 0);
    for (let h2 = 1; h2 < r; h2++) {
      const e6 = new x2(n6[h2 - 1], n6[h2]);
      for (this.m_bReversedLeft = !_oa.goodOrientation(this.m_left, e6), this.m_bReversedLeft ? (i2.push(ia2(a2, e6.vmin, 0, 0)), i2.push(ia2(a2, e6.vmax, 0, 0))) : (i2.push(ia2(a2, e6.vmax, 0, 0)), i2.push(ia2(a2, e6.vmin, 0, 0))), i2[0].pt = this.m_left.getCoord2D(i2[0].t), i2[1].pt = this.m_left.getCoord2D(i2[1].t); i2.length > 1; ) {
        this.progress_();
        const e7 = i2.at(-1);
        let n7 = e7.checkCount, r2 = e7.err;
        const a3 = e7.pt.clone(), h3 = e7.t, m3 = i2[i2.length - 2].t, l2 = 0.5 * (h3 + m3), g2 = this.m_left.getCoord2D(l2);
        if (r2 <= this.m_eps || n7 >= na2) {
          const e8 = new x2();
          if (e8.setCoords(h3, m3), this.closeToCircularArc(this.m_left, e8, a3, g2, i2[i2.length - 2].pt, this.m_leftArc)) {
            t3 && (this.m_bReversedLeft ? o.push(h3) : t3.push(m3)), s4++, i2.pop();
            continue;
          }
          n7 = 0, r2 = this.m_leftArc.maxError;
        }
        e7.t = l2, e7.pt.setCoordsPoint2D(g2), r2 *= ra2, n7++, e7.err = r2, e7.checkCount = n7, i2.push(ia2(a3, h3, r2, n7));
      }
      this.m_bReversedLeft && t3 && (t3.length = t3.length + o.length, Dt(t3, o.reverse(), t3.length - o.length, 0, o.length), o.length = 0), i2.length = 0;
    }
    return s4;
  }
  approximateWithCirclesImplPolyline(e5) {
    const t3 = new Os2(), s4 = [];
    if (!this.approximateWithCirclesImpl(true, s4)) return t3;
    let n6 = 0;
    const r = this.m_left.getStartXY();
    t3.startPath(r);
    for (let i2 = 1; i2 < s4.length; ++i2) if (e5) t3.lineTo(this.m_left.getCoord2D(s4[i2]));
    else {
      const e6 = new mi();
      this.m_left.queryCoord2D(s4[i2], e6);
      const o = new mi();
      this.m_left.queryCoord2D(0.5 * (s4[i2] + n6), o);
      const a2 = new Xh();
      a2.constructCircularArcThreePoint(r, e6, o), t3.addSegment(a2, false), r.assign(e6), n6 = s4[i2];
    }
    return t3;
  }
  static goodOrientation(e5, t3) {
    const s4 = e5.getCoord2D(t3.vmin), n6 = e5.getCoord2D(t3.vmax);
    return s4.compare(n6) < 0;
  }
  progress_(e5 = false) {
  }
};
function aa2(e5, t3, s4, n6, r, i2, o) {
  ma2(e5, t3, s4, r, i2, o), Ca2(e5, s4, o);
}
function ha2(e5, t3, s4, r) {
  if (!h(e5.getGeometryType())) return e5;
  const i2 = e5.getImpl();
  if (!i2.hasNonLinearSegments()) return e5;
  const a2 = e5.createInstance();
  if (a2.getGeometryType() === a.enumPolygon) {
    a2.setFillRule(e5.getFillRule());
  }
  new Pr();
  const h2 = new ee(), m3 = new fm(), l2 = [], g2 = [], u = [], c = e5.getDescription().getAttributeCount() > 1, _ = i2.querySegmentIterator();
  for (; _.nextPath(); ) {
    let e6 = true;
    for (; _.hasNextSegment(); ) {
      const r2 = _.isClosingSegment(), i3 = _.nextSegment();
      if (!i3.isCurve()) {
        a2.addSegment(i3, e6, r2), e6 = false;
        continue;
      }
      let o, d2 = false;
      const p3 = true, f3 = true;
      switch (i3.getGeometryType()) {
        case a.enumEllipticArc:
        case a.enumRationalBezier2:
          o = Wh(i3, t3, s4, p3, f3, g2, u, l2), d2 = true;
          break;
        default:
          o = kh(i3, t3, s4, true, p3, g2, l2);
      }
      const x4 = d2 ? 2 : 3;
      g2[1].isNAN() ? (m3.createLine(), m3.get().construct(g2[0], g2[x4])) : d2 ? (m3.createQuadraticRationalBezier(), m3.get().constructArrayWeights(g2, u)) : (m3.createCubicBezier(), m3.get().constructPoints(g2)), c && e6 && (i3.queryCoord(l2[0], h2), m3.get().setStart(h2)), c && (i3.queryCoord(l2[1], h2), m3.get().setEnd(h2)), a2.addSegment(m3.get(), e6, r2 && 1 === o), e6 = false;
      for (let e7 = 1, t4 = o, s5 = x4; e7 < t4; ++e7, s5 += x4) g2[s5 + 1].isNAN() ? (m3.createLine(), m3.get().construct(g2[s5], g2[s5 + x4])) : d2 ? (m3.createQuadraticRationalBezier(), m3.get().constructArrayWeights(g2.slice(s5), u.slice(s5))) : (m3.createCubicBezier(), m3.get().constructPoints(g2.slice(s5))), c && (i3.queryCoord(l2[e7 + 1], h2), m3.get().setEnd(h2)), a2.addSegment(m3.get(), false, r2 && e7 + 1 === t4);
    }
  }
  return a2;
}
function ma2(e5, t3, s4, n6, r, i2) {
  e5.hasCurves() ? (e5.setCurveStitcherPointer(n6), n6.m_impl = new xa2(i2, false, null), n6.m_impl.buildMonotonicCurveParentage(e5, t3, s4, r)) : n6.m_impl = null;
}
function la2(e5, t3, s4, n6, r, i2, o, a2) {
  e5.hasCurves() ? (e5.setCurveStitcherPointer(i2), i2.m_impl = new xa2(a2, true, r), i2.m_impl.buildMonotonicCurveParentage(e5, t3, s4, o), Ca2(e5, s4, a2)) : i2.m_impl = null;
}
function ga2(e5) {
  if (!e5.hasSegmentParentage()) return;
  const t3 = e5.queryVertexIteratorOnSelection();
  for (let s4 = t3.next(); s4 !== cr; s4 = t3.next()) if (!e5.getSegmentParentageBreakVertex(s4)) {
    e5.getPathFromVertex(s4);
    const t4 = e5.getPrevVertex(s4), n6 = t4 !== cr ? e5.getSegmentParentage(t4) : -1, r = e5.getSegmentParentage(s4);
    -1 !== r && -1 !== n6 && r !== n6 && e5.setSegmentParentageBreakVertex(s4, true);
  }
}
function ua2(e5) {
  if (!e5.hasSegmentParentage()) return;
  ga2(e5);
  const t3 = new st2(0), s4 = e5.queryVertexIteratorOnSelection();
  for (let o = s4.next(); o !== cr; o = s4.next()) t3.add(o);
  if (0 === t3.size()) return;
  e5.sortVerticesSimpleByY(t3, 0, t3.size()), t3.add(cr);
  const n6 = mi.getNAN();
  e5.queryXY(t3.read(0), n6);
  let r = 0;
  const i2 = mi.getNAN();
  for (let o = 1, a2 = t3.size(); o < a2; o++) {
    {
      const s5 = t3.read(o);
      s5 !== cr ? e5.queryXY(s5, i2) : i2.setNAN();
    }
    if (!i2.isEqualPoint2D(n6)) {
      if (o - r > 1) {
        let s5 = false;
        for (let n7 = r; n7 < o; ++n7) {
          const r2 = t3.read(n7);
          if (e5.getSegmentParentageBreakVertex(r2)) {
            s5 = true;
            break;
          }
        }
        if (!s5) {
          const n7 = (t4, s6, n8) => {
            const r2 = e5.getPrevVertex(t4), i4 = e5.getNextVertex(t4);
            r2 !== cr ? s6.assign(e5.getXY(r2)) : s6.setNAN(), i4 !== cr ? n8.assign(e5.getXY(i4)) : n8.setNAN();
          }, i3 = new mi(), a3 = new mi();
          n7(t3.read(r), i3, a3);
          for (let e6 = r + 1; e6 < o; ++e6) {
            const r2 = t3.read(e6);
            if (r2 === cr) continue;
            const o2 = new mi(), h2 = new mi();
            n7(r2, o2, h2);
            const m3 = (e7, t4) => !!(e7.equals(t4) || e7.isNAN() && t4.isNAN());
            if (!(m3(o2, i3) && m3(h2, a3) || m3(h2, i3) && m3(o2, a3))) {
              s5 = true;
              break;
            }
          }
        }
        if (s5) for (let n7 = r; n7 < o; ++n7) e5.setSegmentParentageBreakVertex(t3.read(n7), true);
      }
      n6.setCoordsPoint2D(i2), r = o;
    }
  }
}
function ca2(e5, t3) {
  let s4 = t3.isEmpty() ? e5 : At(null, t3, true).total();
  return s4 > e5 && (s4 = e5), 0.125 * s4;
}
function _a2(t3, s4) {
  return s4 || (s4 = n4.constructEmpty()), ca2(t3, s4);
}
function da2(e5, t3) {
  return 0.125 * e5;
}
function pa2(e5, t3) {
  return 3 * e5 + 3 * t3;
}
var fa2 = class {
  constructor() {
    this.m_impl = null;
  }
  stitchCurves(e5, t3, s4, n6) {
    this.m_impl && (this.m_impl.stitchCurves(e5, t3, s4), n6 && this.clearStitcher(e5));
  }
  clearStitcher(e5) {
    this.m_impl && (this.m_impl.clearStitcher(e5), this.m_impl = null);
  }
  getOriginalVertexIndex(e5, t3) {
    return this.m_impl.getOriginalVertexIndex(e5, t3);
  }
  getOriginalSegmentTypeInfo(e5) {
    return this.m_impl.getOriginalSegmentTypeInfo(e5);
  }
};
var xa2 = class _xa {
  constructor(e5, t3, s4) {
    this.m_originalPlanarSegments = [], this.m_progressTracker = null, this.m_nsr = null, this.m_progressTracker = e5, this.m_nsr = s4, this.m_tolerance = 0, this.m_originalVertexIndex = -1, this.m_type = 1, this.m_progressCounter = 0, this.m_bIsSimple = t3, this.m_densificationDeviation = NaN, this.m_maxSegmentsPerCurve = -1;
  }
  buildMonotonicCurveParentage(e5, t3, s4, r) {
    const i2 = false, o = true;
    if (!e5.hasCurves()) return;
    n2(!e5.hasSegmentParentage()), this.m_originalPlanarSegments.length = 0, this.m_bIsSimple && (this.m_originalVertexIndex = e5.createUserIndex()), this.m_tolerance = s4;
    const h2 = new ee(), m3 = new fm(), l2 = [], g2 = [], u = [];
    for (let c = e5.getFirstGeometry(); c !== cr; c = e5.getNextGeometry(c)) for (let r2 = e5.getFirstPath(c); r2 !== cr; r2 = e5.getNextPath(r2)) {
      let c2 = e5.getPathSize(r2), _ = e5.getFirstVertex(r2), d2 = 0, p3 = -1;
      for (let f3 = 0; f3 < c2; f3++) {
        let x4 = e5.getNextVertex(_);
        if (!e5.querySegment(_, m3, true, false)) {
          _ = x4;
          continue;
        }
        if (0 === d2) {
          p3 = e5.getVertexIndex(_);
          const t4 = _xa.regularizeCurve(e5, m3.get(), _, s4);
          if (t4 >= 0) {
            this.m_nsr && 0 === this.m_nsr.m_reason && this.m_nsr.assign(new e(13, p3, -1)), d2 = t4, c2 = e5.getPathSize(r2), x4 = e5.getNextVertex(_);
            const s5 = e5.querySegment(_, m3, true, false);
            n2(s5);
          }
        } else d2--;
        const y2 = e5.getVertexIndex(_);
        let P5;
        -1 !== this.m_originalVertexIndex && e5.setUserIndex(_, this.m_originalVertexIndex, p3), e5.setSegmentToIndex(y2, null);
        let E2 = false;
        switch (m3.get().getGeometryType()) {
          case a.enumEllipticArc:
          case a.enumRationalBezier2:
            P5 = Wh(m3.get(), t3, s4, i2, o, g2, u, l2), E2 = true;
            break;
          default: {
            const e6 = !this.m_bIsSimple || !m3.get().isMonotoneQuickAndDirty();
            P5 = kh(m3.get(), t3, s4, e6, i2, g2, l2);
          }
        }
        const S3 = this.m_originalPlanarSegments.length;
        if (e5.setSegmentParentageAndBreak(_, S3, true), !g2[1].isNAN()) {
          let t4 = null;
          t4 = E2 ? new En({ points: g2, weights: u }) : new ia({ cp: g2 }), t4.snapControlPoints(s4 * s4), e5.setSegmentToIndex(y2, t4);
        }
        const C3 = E2 ? 2 : 3;
        for (let t4 = 1, n6 = P5, i3 = C3; t4 < n6; ++t4, i3 += C3) {
          m3.get().queryCoord(l2[t4], h2);
          const n7 = e5.insertVertex(r2, x4, h2);
          if (-1 !== this.m_originalVertexIndex && e5.setUserIndex(n7, this.m_originalVertexIndex, p3), !g2[i3 + 1].isNAN()) if (E2) {
            const t5 = new En({ points: g2.slice(i3), weights: u.slice(i3) });
            t5.snapControlPoints(s4 * s4), e5.setSegmentToIndex(e5.getVertexIndex(n7), t5);
          } else {
            const t5 = new ia({ cp: g2.slice(i3) });
            t5.snapControlPoints(s4 * s4), e5.setSegmentToIndex(e5.getVertexIndex(n7), t5);
          }
          e5.setSegmentParentageAndBreak(n7, S3, false);
        }
        P5 > 1 && (f3 += P5 - 1, c2 = e5.getPathSize(r2)), this.m_originalPlanarSegments.push(m3.releaseSegment()), _ = x4;
      }
    }
  }
  buildLinearSegmentParentage(e5, t3, s4, n6, r) {
    if (this.m_type = 0, this.m_densificationDeviation = t3, this.m_maxSegmentsPerCurve = n6, !e5.hasCurves()) return;
    n2(!e5.hasSegmentParentage()), this.m_tolerance = s4, this.m_originalPlanarSegments = [], this.m_bIsSimple && (this.m_originalVertexIndex = e5.createUserIndex());
    const i2 = new ee(), o = new fm(), h2 = new jh(0, t3, 0, this.m_progressTracker, false, n6), m3 = [];
    for (let l2 = e5.getFirstGeometry(); l2 !== cr; l2 = e5.getNextGeometry(l2)) for (let t4 = e5.getFirstPath(l2); t4 !== cr; t4 = e5.getNextPath(t4)) {
      let n7 = e5.getPathSize(t4), r2 = e5.getFirstVertex(t4);
      for (let l3 = 0; l3 < n7; l3++) {
        let l4 = e5.getNextVertex(r2);
        if (!e5.querySegment(r2, o, true, false)) {
          r2 = l4;
          continue;
        }
        if (_xa.regularizeCurve(e5, o.get(), r2, s4) >= 0) {
          n7 = e5.getPathSize(t4), l4 = e5.getNextVertex(r2);
          const s5 = e5.querySegment(r2, o, true, false);
          n2(s5);
        }
        const g2 = e5.getVertexIndex(r2);
        -1 !== this.m_originalVertexIndex && e5.setUserIndex(r2, this.m_originalVertexIndex, g2), e5.setSegmentToIndex(g2, null), m3.length = 0, h2.densifySegment(o.get(), m3), this.progress_();
        const u = this.m_originalPlanarSegments.length;
        e5.setSegmentParentageAndBreak(r2, u, true);
        for (let s5 = 1, n8 = m3.length - 1; s5 < n8; ++s5) {
          o.get().queryCoord(m3[s5], i2);
          const n9 = e5.insertVertex(t4, l4, i2);
          e5.setSegmentParentageAndBreak(n9, u, false), -1 !== this.m_originalVertexIndex && e5.setUserIndex(n9, this.m_originalVertexIndex, g2);
        }
        this.m_originalPlanarSegments.push(o.releaseSegment()), r2 = l4;
      }
    }
    e5.clearSegments();
  }
  stitchCurves(e5, t3, s4) {
    _xa.st_stitchCurvesImpl(this, e5, t3, s4, false);
  }
  clearStitcher(e5) {
    this.m_originalPlanarSegments.length = 0, -1 !== this.m_originalVertexIndex && (e5.removeUserIndex(this.m_originalVertexIndex), this.m_originalVertexIndex = -1), e5.deleteSegmentParentage();
  }
  static st_verifyParentage(e5) {
    _xa.st_stitchCurvesImpl(null, e5, cr, 0, true);
  }
  getOriginalVertexIndex(e5, t3) {
    return -1 !== this.m_originalVertexIndex && t3 !== cr ? e5.getUserIndex(t3, this.m_originalVertexIndex) : -1;
  }
  getOriginalSegmentTypeInfo(e5) {
    if (-1 !== e5) {
      const t3 = this.m_originalPlanarSegments[e5];
      switch (t3.getGeometryType()) {
        case a.enumEllipticArc:
          return 0 === t3.projectionBehavior() ? 0 : 1;
        case a.enumBezier:
          return 2;
        case a.enumBezier2:
          return 3;
        case a.enumLine:
          return -1;
        case a.enumRationalBezier2:
          return 4;
        default:
          z("");
      }
    }
    return -1;
  }
  progress_(e5 = false) {
    this.m_progressCounter++;
  }
  processSpanSmartTe_(e5, t3, s4, n6, r, i2, o) {
    if (t3 === s4 && 0 === n6) return n2(e5.getNextVertex(t3) === cr), e5.setSegmentToIndex(e5.getVertexIndex(t3), null), void e5.setSegmentParentageAndBreak(t3, -1);
    const h2 = e5.getNextVertex(t3), m3 = e5.getXY(t3), l2 = e5.getXY(s4);
    let g2, u = 0;
    {
      let t4 = 2, r2 = m3;
      for (let n7 = h2; n7 !== s4; n7 = e5.getNextVertex(n7)) {
        const s5 = e5.getXY(n7);
        u += mi.distance(s5, r2), r2 = s5, t4++;
      }
      u += mi.distance(l2, r2), n2(t4 === n6);
    }
    if (null === r) return e5.setSegmentToIndex(e5.getVertexIndex(t3), null), void e5.removeVertices(h2, s4);
    const c = o;
    let _ = r.getClosestCoordinate(m3, false), d2 = r.getClosestCoordinate(l2, false);
    const p3 = r.calculateLength2D();
    let f3 = r.tToLength(_), x4 = r.tToLength(d2);
    const y2 = Math.abs(f3) > 10 * c && Math.abs(f3 - p3) > 10 * c, P5 = Math.abs(x4) > 10 * c && Math.abs(x4 - p3) > 10 * c, E2 = (e6) => {
      const t4 = e6.calculateLength2D();
      return Math.abs(t4 - u) > Math.max(0.2 * u, 4 * c) ? null : e6;
    };
    let S3 = r.isClosed();
    if (!S3) {
      const e6 = mi.distance(r.getStartXY(), r.getEndXY());
      e6 <= c && p3 > 5 * e6 && (S3 = true);
    }
    if (S3) {
      let i3, o2, h3 = new mi();
      if (2 === n6) h3 = mi.lerp(m3, l2, 0.5), i3 = r.getClosestCoordinate(h3, false), o2 = r.tToLength(i3);
      else {
        let s5 = e5.getNextNthVertex(t3, (n6 - 1) / 2);
        h3 = e5.getXY(s5), i3 = r.getClosestCoordinate(h3, false), o2 = r.tToLength(i3);
        let a2 = Math.abs(o2) > 10 * c && Math.abs(o2 - p3) > 10 * c;
        if (!a2 && (n6 - 1 >= 4 && (s5 = e5.getNextNthVertex(t3, (n6 - 1) / 4), i3 = r.getClosestCoordinate(h3, false), o2 = r.tToLength(i3), a2 = Math.abs(o2) > 10 * c && Math.abs(o2 - p3) > 10 * c), !a2)) return;
      }
      let u2 = false;
      const S4 = f3 === x4;
      if (S4) {
        const s5 = 0;
        let i4 = 2, o3 = 4;
        n6 - 1 <= 4 && (i4 = s5 + 1, o3 = s5 + 2);
        const a2 = m3, h4 = e5.getXY(e5.getNextNthVertex(t3, i4)), l3 = e5.getXY(e5.getNextNthVertex(t3, o3));
        u2 = -mi.orientationNonRobust(a2, h4, l3) * K(r.calculateArea2DHelper()) > 0;
      } else P5 ? y2 ? u2 = o2 > f3 : o2 < x4 ? (f3 = 0, _ = 0) : (f3 = p3, _ = 1) : o2 > f3 ? (x4 = p3, d2 = 1) : (x4 = 0, d2 = 0);
      if (S4) g2 = r.clone(), g2.dropAllAttributes(), u2 || g2.reverse(), n2(m3.equals(l2));
      else {
        let e6 = false;
        _ > d2 && (e6 = true, [_, d2] = [d2, _]), g2 = r.cut(_, d2, true), g2.getDescription().getAttributeCount(), e6 && g2.reverse();
      }
      g2.setCoordsForIntersector(m3, l2, false), g2 = E2(g2), g2 && (this.removeSpanBetween(e5, t3, s4), e5.setSegmentToIndex(e5.getVertexIndex(t3), g2));
    } else if (y2 || P5) {
      if (!y2 || !P5) {
        if (mi.distance(r.getStartXY(), r.getEndXY()) < 10 * c) {
          const n8 = [$t(_, d2), $t(_, d2), $t(_, d2)];
          y2 ? (n8[1].second = 0, n8[2].second = 1) : (n8[1].first = 1, n8[2].first = 0);
          const i3 = [null, null, null], o2 = [0, 0, 0];
          let a2 = Number.MAX_VALUE, h3 = 0;
          for (let e6 = 0; e6 < 3; e6++) {
            let t4 = false;
            if (n8[e6].first > n8[e6].second) {
              t4 = true;
              const s6 = n8[e6].first;
              n8[e6].first = n8[e6].second, n8[e6].second = s6;
            }
            i3[e6] = r.cut(n8[e6].first, n8[e6].second, true), i3[e6].dropAllAttributes(), t4 && i3[e6].reverse(), i3[e6].setCoordsForIntersector(m3, l2, false), o2[e6] = i3[e6].calculateLength2D();
            const s5 = Math.abs(u - o2[e6]);
            s5 < a2 && (a2 = s5, h3 = e6);
          }
          return g2 = i3[h3], g2 = E2(g2), void (g2 && (this.removeSpanBetween(e5, t3, s4), e5.setSegmentToIndex(e5.getVertexIndex(t3), g2)));
        }
      }
      let n7 = false;
      _ > d2 && (n7 = true, [_, d2] = [d2, _]), g2 = r.cut(_, d2, true), g2.dropAllAttributes(), n7 && g2.reverse(), g2.setCoordsForIntersector(m3, l2, false), g2 = E2(g2), g2 && (this.removeSpanBetween(e5, t3, s4), e5.setSegmentToIndex(e5.getVertexIndex(t3), g2));
    } else {
      if (g2 = r.clone(), g2.dropAllAttributes(), f3 > x4 && g2.reverse(), u < Math.max(0.75 * p3, p3 - this.m_densificationDeviation * (n6 - 1))) {
        const e6 = _ > d2 ? d2 : _, t4 = g2.tToLength(e6) + u;
        let s5 = g2.lengthToT(t4);
        s5 = Us(s5, e6, 1), g2 = g2.cut(e6, s5, true);
      }
      g2.setCoordsForIntersector(m3, l2, false), g2 = E2(g2), g2 && (this.removeSpanBetween(e5, t3, s4), e5.setSegmentToIndex(e5.getVertexIndex(t3), g2));
    }
  }
  processSpanCurves_(e5, t3, s4, n6, r, i2, o) {
    if (t3 === s4 && 0 === n6) return n2(e5.getNextVertex(t3) === cr), e5.setSegmentToIndex(e5.getVertexIndex(t3), null), void e5.setSegmentParentageAndBreak(t3, -1);
    const h2 = e5.getNextVertex(t3);
    {
      let t4 = 2;
      for (let n7 = h2; n7 !== s4; n7 = e5.getNextVertex(n7)) t4++;
      n2(t4 === n6);
    }
    if (null === r) return e5.setSegmentToIndex(e5.getVertexIndex(t3), null), void e5.removeVertices(h2, s4);
    const m3 = e5.getXY(t3), l2 = e5.getXY(s4);
    if (r.isClosed()) {
      if (m3.isEqualPoint2D(l2) && m3.isEqualPoint2D(r.getStartXY())) {
        let a2;
        if (a2 = this.verifySegmentFitnessCurves(e5, t3, s4, n6, r, i2, o)) {
          const n7 = r.clone();
          return n7.dropAllAttributes(), a2 < 0 && n7.reverse(), this.removeSpanBetween(e5, t3, s4), void e5.setSegmentToIndex(e5.getVertexIndex(t3), n7);
        }
      }
    } else if (m3.isEqualPoint2D(r.getStartXY())) {
      if (l2.isEqualPoint2D(r.getEndXY())) {
        const h3 = r.clone();
        h3.dropAllAttributes();
        const m4 = this.verifySegmentFitnessCurves(e5, t3, s4, n6, h3, i2, o);
        if (m4) return n2(m4 > 0), this.removeSpanBetween(e5, t3, s4), void e5.setSegmentToIndex(e5.getVertexIndex(t3), h3);
      }
    } else if (l2.isEqualPoint2D(r.getStartXY()) && m3.isEqualPoint2D(r.getEndXY())) {
      const h3 = r.getReversed();
      h3.dropAllAttributes();
      const m4 = this.verifySegmentFitnessCurves(e5, t3, s4, n6, h3, i2, o);
      if (m4) return n2(m4 > 0), this.removeSpanBetween(e5, t3, s4), void e5.setSegmentToIndex(e5.getVertexIndex(t3), h3);
    }
    this.processSpanSplitSegmentCurves(e5, t3, s4, n6, r, i2, o);
  }
  processSpan_(e5, t3, s4, n6, r, i2, o) {
    return 0 === this.m_type ? void this.processSpanSmartTe_(e5, t3, s4, n6, r, i2, o) : void this.processSpanCurves_(e5, t3, s4, n6, r, i2, o);
  }
  processSpanSplitSegmentCurves(e5, t3, s4, n6, r, i2, o) {
    if (r.isLine()) return;
    if (this.fitSegmentToSpanCurves(e5, t3, s4, n6, r, i2, o)) return;
    const a2 = o * o;
    let h2 = n6, m3 = t3;
    const l2 = e5.getXY(t3);
    let g2 = r.getClosestCoordinate(l2, false);
    const u = r.getCoord2D(g2);
    let c = false;
    const _ = mi.sqrDistance(l2, u);
    if (_ > a2) {
      const n7 = e5.getNextVertex(t3);
      if (this.approximateSpanSectionCurves(e5, t3, r, i2, o), n7 === s4) return;
      m3 = n7, c = true, h2 -= 1;
    }
    let d2 = s4;
    const p3 = e5.getXY(s4);
    g2 = r.getClosestCoordinate(p3, false);
    const f3 = r.getCoord2D(g2);
    let x4 = false;
    const y2 = mi.sqrDistance(p3, f3);
    if (y2 > a2) {
      const t4 = e5.getPrevVertex(s4);
      if (this.approximateSpanSectionCurves(e5, t4, r, i2, o), t4 === m3) return;
      d2 = t4, x4 = true, h2 -= 1;
    }
    if ((c || x4) && this.fitSegmentToSpanCurves(e5, m3, d2, h2, r, i2, o)) return;
    let P5 = false;
    if (!c && _ > 0) {
      const s5 = e5.getNextVertex(t3);
      if (this.approximateSpanSectionCurves(e5, t3, r, i2, o), s5 === d2) return;
      m3 = s5, c = true, P5 = true, h2 -= 1;
    }
    if (!x4 && y2 > 0) {
      const t4 = e5.getPrevVertex(s4);
      if (this.approximateSpanSectionCurves(e5, t4, r, i2, o), t4 === m3) return;
      d2 = t4, x4 = true, P5 = true, h2 -= 1;
    }
    if (P5 && this.fitSegmentToSpanCurves(e5, m3, d2, h2, r, i2, o)) return;
    let E2 = m3;
    for (; ; ) {
      const t4 = e5.getNextVertex(E2);
      if (this.approximateSpanSectionCurves(e5, E2, r, i2, o), E2 = t4, E2 === d2) return;
    }
  }
  fitSegmentToSpanCurves(e5, t3, s4, n6, r, i2, o) {
    const a2 = [];
    a2.push(e5.getXY(t3));
    let h2 = t3;
    const m3 = new fm();
    for (; ; ) {
      e5.querySegment(h2, m3, false, true);
      const t4 = [0.1, 0.25, 0.4, 0.5, 0.6, 0.75, 0.9, 1];
      let r2 = 0;
      for (const e6 of t4) {
        (2 === n6 || 1 & r2) && a2.push(m3.get().getCoord2D(e6)), r2++;
      }
      if (h2 = e5.getNextVertex(h2), h2 === s4) break;
    }
    const l2 = (() => {
      let e6 = a2[0].compare(a2.at(-1));
      if (0 === e6) {
        const t4 = new n3(0);
        Qo2(a2, a2.length, t4), e6 = t4.getResult() >= 0 ? -1 : 1;
      }
      return e6 > 0;
    })();
    l2 && a2.reverse();
    const g2 = r.clone();
    if (g2.dropAllAttributes(), l2 && g2.reverse(), g2.setSegmentFromCoordsForStitcher(a2, a2.length), l2 && g2.reverse(), g2.snapControlPoints(this.m_tolerance * this.m_tolerance), this.verifySegmentFitnessCurves(e5, t3, s4, n6, g2, i2, o)) {
      this.removeSpanBetween(e5, t3, s4);
      const n7 = e5.getVertexIndex(t3);
      return e5.setSegmentToIndex(n7, g2), true;
    }
    return false;
  }
  approximateSpanSectionCurves(e5, t3, s4, r, o) {
    const a2 = new fm();
    if (!e5.querySegment(t3, a2, true, false)) return;
    const h2 = s4.getGeometryType();
    if (h2 !== a2.get().getGeometryType()) {
      if (h2 === a.enumEllipticArc) {
        if (a2.get().getGeometryType() !== a.enumRationalBezier2) return;
        if (0 === s4.projectionBehavior()) {
          const s5 = [];
          ea2(false, a2.get(), o, s5, this.m_progressTracker);
          const n6 = e5.getNextVertex(t3), r2 = e5.getPathFromVertex(t3), i2 = new ee();
          let h3 = t3;
          for (let t4 = 1, o2 = s5.length; t4 < o2; t4++) {
            const o3 = s5[t4], m3 = a2.get().getCoord2D(s5[t4 - 1]), l2 = a2.get().getCoord2D(Q(s5[t4 - 1], o3, 0.5));
            a2.get().queryCoord(o3, i2);
            const g2 = i2.getXY(), u = new Xh();
            u.constructCircularArcThreePoint(m3, g2, l2);
            let c = cr;
            o3 < 1 && (c = e5.insertVertex(r2, n6, i2)), e5.setSegmentToIndex(e5.getVertexIndex(h3), u), h3 = c;
          }
          return;
        }
        {
          const s5 = Ot(mi, 3);
          a2.get().queryControlPoints(s5);
          const n6 = [0, 0, 0];
          a2.get().queryWeights(n6);
          const r2 = fh(n6), i2 = new Xh();
          return Gu(s5, r2 * r2, null, false, i2), void e5.setSegmentToIndex(e5.getVertexIndex(t3), i2);
        }
      }
      b("approximate_span_section_");
    }
  }
  verifySegmentFitnessCurves(e5, t3, s4, n6, r, i2, o) {
    const a2 = e5.getXY(t3), h2 = e5.getXY(s4);
    if (!a2.isEqualPoint2D(r.getStartXY()) || !h2.isEqualPoint2D(r.getEndXY())) return 0;
    let m3 = 0;
    if (r.isClosed()) {
      const e6 = r.getCoord2D(0.1).sub(a2);
      m3 = r.getCoord2D(0.7).sub(a2).crossProduct(e6) >= 0 ? 1 : -1;
    }
    const l2 = Yt(us.s_maxMonotonicPartParams, Number.NaN);
    let g2 = r.getMonotonicPartParams(l2.length, l2);
    g2--;
    const u = new pm(), c = [1, 0.5, 0.75, 0.25];
    let _ = 0, d2 = t3;
    const p3 = a2.clone();
    for (; ; ) {
      const t4 = e5.getNextVertex(d2);
      let n7 = e5.getSegment(d2);
      null === n7 && (e5.queryLineConnector(d2, u, true), n7 = u);
      for (let e6 = t4 === s4 ? 1 : 0; e6 < c.length; e6++) {
        const t5 = n7.getCoord2D(c[e6]);
        if (!r.isCloserThanDistance(t5, x2.unit(), o)) return 0;
      }
      if (g2 > 1) for (let e6 = 1; e6 < g2; ) {
        const t5 = r.getCoord2D(l2[e6]);
        n7.isCloserThanDistance(t5, x2.unit(), o) ? (l2[g2 - 1] = Pt(l2[e6], l2[e6] = l2[g2 - 1]), g2--) : e6++;
      }
      if (m3) {
        const e6 = n7.getCoord2D(0.25);
        _ += e6.sub(a2).crossProduct(p3.sub(a2)), p3.assign(e6), e6.assign(n7.getCoord2D(0.75)), _ += e6.sub(a2).crossProduct(p3.sub(a2)), p3.assign(e6);
      }
      if (d2 = t4, d2 === s4) return g2 > 1 ? 0 : m3 ? _ < 0 ? -m3 : m3 : 1;
    }
  }
  removeSpanBetween(e5, t3, s4) {
    e5.setSegmentToIndex(e5.getVertexIndex(t3), null);
    const n6 = e5.getNextVertex(t3);
    n6 !== s4 && e5.removeVertices(n6, s4);
  }
  static st_stitchCurvesImpl(e5, t3, s4, n6, r) {
    if (!t3.hasSegmentParentage()) return;
    ga2(t3);
    let i2 = s4 === cr ? t3.getFirstGeometry() : s4;
    for (; i2 !== cr; ) if (p(t3.getGeometryType(i2))) {
      for (let s5 = t3.getFirstPath(i2); s5 !== cr; s5 = t3.getNextPath(s5)) {
        let i3 = t3.getPathSize(s5);
        const o = t3.isClosedPath(s5);
        o && (i3 += 1);
        let h2 = t3.getFirstVertex(s5);
        const m3 = t3.getSegmentParentage(h2);
        if (o) {
          if (-1 !== m3 && !t3.getSegmentParentageBreakVertex(h2)) {
            let e6 = t3.getPrevVertex(h2);
            const s6 = h2;
            for (let n7 = 0; ; n7++) {
              const r2 = t3.getSegmentParentage(e6);
              if (m3 !== r2) {
                n2(-1 === r2);
                break;
              }
              if (h2 = e6, t3.getSegmentParentageBreakVertex(e6)) break;
              if (e6 === s6) {
                h2 = s6, t3.setSegmentParentageBreakVertex(h2, true);
                break;
              }
              e6 = t3.getPrevVertex(e6), n2(n7 < i3);
            }
          }
        } else n2(-1 === m3 || t3.getSegmentParentageBreakVertex(h2));
        let l2 = h2;
        for (let s6 = 0; s6 < i3 && l2 !== cr; ) {
          const o2 = t3.getSegmentParentage(l2);
          if (-1 === o2) {
            if (s6++, l2 = t3.getNextVertex(l2), l2 === h2) break;
            continue;
          }
          let m4 = 0, g2 = cr;
          const u = l2;
          m4 = 1;
          let c = t3.getNextVertex(u);
          for (; s6 < i3 && c !== cr; ) {
            s6++, g2 = c, m4++;
            const e6 = t3.getSegmentParentage(c);
            if (-1 === e6 || t3.getSegmentParentageBreakVertex(c)) break;
            n2(e6 === o2), c = t3.getNextVertex(c);
          }
          if (g2 === cr) {
            n2(0);
            break;
          }
          if (!r) {
            const s7 = e5.m_originalPlanarSegments[o2];
            e5.processSpan_(t3, u, g2, m4, s7, o2, n6);
          }
          if (l2 = g2, l2 === h2) break;
        }
      }
      if (s4 !== cr) break;
      i2 = t3.getNextGeometry(i2);
    } else i2 = s4 === cr ? t3.getNextGeometry(i2) : cr;
  }
  static st_stitchCurvesFromLinesImpl(e5, t3, s4, n6, r) {
    let i2 = s4 === cr ? t3.getFirstGeometry() : s4;
    for (; i2 !== cr; ) {
      for (let s5 = t3.getFirstPath(i2); s5 !== cr; s5 = t3.getNextPath(s5)) {
        let i3 = t3.getPathSize(s5);
        t3.isClosedPath(s5) && (i3 += 1);
        let o = true, h2 = false;
        const m3 = t3.getFirstVertex(s5);
        let l2 = m3;
        for (let s6 = 0; s6 < i3 && l2 !== cr; ) {
          let g2 = t3.getSegmentParentage(l2);
          if (-1 === g2 || o) {
            o = false, s6++, l2 = t3.getNextVertex(l2), h2 = true;
            continue;
          }
          let u, c, _ = 0;
          if (h2 ? (u = t3.getPrevVertex(l2), c = l2, n2(u !== cr), n2(c !== u), n2(-1 === t3.getSegmentParentage(u) || m3 === u)) : (u = l2, c = t3.getNextVertex(u), s6++, n2(c !== cr), n2(c !== u), g2 = t3.getSegmentParentage(c)), _ = 2, h2 = false, -1 === g2 || t3.getSegmentParentageBreakVertex(c)) {
            l2 = c;
            continue;
          }
          let d2 = t3.getNextVertex(c);
          for (s6++; s6 < i3 && d2 !== cr; ) {
            c = d2, _++;
            const e6 = t3.getSegmentParentage(d2);
            if (-1 === e6 || t3.getSegmentParentageBreakVertex(d2)) break;
            n2(e6 === g2), s6++, d2 = t3.getNextVertex(d2);
          }
          if (!r) {
            const s7 = e5.m_originalPlanarSegments[g2];
            e5.processSpan_(t3, u, c, _, s7, g2, n6);
          }
          l2 = c;
        }
      }
      if (s4 !== cr) break;
      i2 = t3.getNextGeometry(i2);
    }
  }
  static st_stitchCurvesFromCurvesImpl(e5, t3, s4, n6, r) {
    let i2 = s4 === cr ? t3.getFirstGeometry() : s4;
    for (; i2 !== cr; ) if (p(t3.getGeometryType(i2))) {
      for (let s5 = t3.getFirstPath(i2); s5 !== cr; s5 = t3.getNextPath(s5)) {
        let i3 = t3.getPathSize(s5);
        const o = t3.isClosedPath(s5);
        o && (i3 += 1);
        let h2 = t3.getFirstVertex(s5);
        if (o) {
          if (-1 !== t3.getSegmentParentage(h2)) {
            let e6 = h2;
            for (let n7 = 0; !t3.getSegmentParentageBreakVertex(e6); n7++) {
              if (n7 === i3) {
                h2 = t3.getFirstVertex(s5), t3.setSegmentParentageBreakVertex(e6, true);
                break;
              }
              e6 = t3.getPrevVertex(e6);
            }
          }
        } else n2(-1 === t3.getSegmentParentage(h2) || t3.getSegmentParentageBreakVertex(h2));
        let m3 = h2;
        for (let s6 = 0; s6 < i3 && m3 !== cr; ) {
          const o2 = t3.getSegmentParentage(m3);
          if (-1 === o2) {
            s6++, m3 = t3.getNextVertex(m3);
            continue;
          }
          let h3 = 0, l2 = cr;
          const g2 = m3;
          h3 = 1;
          let u = t3.getNextVertex(g2);
          for (; s6 < i3 && u !== cr; ) {
            s6++, l2 = u, h3++;
            const e6 = t3.getSegmentParentage(u);
            if (-1 === e6 || t3.getSegmentParentageBreakVertex(u)) break;
            n2(e6 === o2), u = t3.getNextVertex(u);
          }
          if (l2 === cr) break;
          if (!r) {
            const s7 = e5.m_originalPlanarSegments[o2];
            e5.processSpan_(t3, g2, l2, h3, s7, o2, n6);
          }
          m3 = l2;
        }
      }
      if (s4 !== cr) break;
      i2 = t3.getNextGeometry(i2);
    } else i2 = s4 === cr ? t3.getNextGeometry(i2) : cr;
  }
  static regularizeCurve(e5, t3, s4, n6) {
    let r = t3.snapControlPoints(n6 * n6);
    if (r) {
      const n7 = e5.getVertexIndex(s4), r2 = t3.clone();
      e5.setSegmentToIndex(n7, r2);
    }
    if (t3.getGeometryType() === ia.type) {
      const i2 = [], o = t3.calculateSpecialPointsForCracking(n6, i2);
      if (o > 0) {
        const a2 = [];
        if (o > 1) {
          for (let e6 = 0; e6 < o; e6++) if (a2.push(t3.getCoord2D(i2[e6])), e6 > 0) {
            const t4 = (Math.abs(a2[e6].x) + Math.abs(a2[e6].y)) * Ls(), s5 = mi.distance(a2[e6 - 1], a2[e6]);
            if (s5 < t4 && s5 > 0) {
              const t5 = new mi();
              Y(a2[e6 - 1], a2[e6], 0.5, t5), a2[e6 - 1] = t5, a2[e6] = t5;
            }
          }
        }
        e5.splitSegment(s4, i2, o), r = e5.snapControlPoints(s4, o + 1, n6 * n6) || r;
        for (let t4 = 0; t4 < o; t4++) s4 = e5.getNextVertex(s4), e5.setSegmentParentageBreakVertex(s4, true);
        return o;
      }
    }
    return r ? 0 : -1;
  }
};
function ya2(e5, t3, s4, n6, r) {
  return new ba2(e5, s4, t3, n6, r).do_();
}
function Pa2(e5, t3, s4) {
  const n6 = Ft2(e5);
  return ln2(t3.getX(), t3.getY(), s4.getX(), s4.getY(), H(n6));
}
function Ea2(e5, t3, s4 = 1, n6 = 1, r = 1, i2 = 1) {
  if (n6 > i2) return e5;
  if (i2 > n6) return t3;
  const o = [0], a2 = [0], h2 = new ee();
  return cn2(e5, t3, s4, n6, r, i2, h2, a2, o), h2;
}
function Sa2(e5, t3, s4) {
  const n6 = Ft2(t3), r = Pt2(t3);
  return !!_n2(e5, n6, cr, null, s4) || Mn2(true, e5, r, null, s4);
}
function Ca2(e5, t3, s4) {
  return ba2.fixCurveTwoPointLoops(e5, t3, s4);
}
function Ia2(e5) {
  return Ft2(e5);
}
var ba2 = class _ba {
  constructor(e5, t3, s4, n6, r) {
    this.m_shape = e5, this.m_progressTracker = t3, this.m_tolerance = s4, this.m_bFilterDegenerateSegments = n6, this.m_bTrackChanges = r, this.m_progressCounter = 0;
  }
  do_() {
    const e5 = new Et2(this.m_tolerance.tolerance, this.m_tolerance.resolution), t3 = 1e-5, s4 = 1e-6, n6 = Ia2(e5);
    let r = Pt2(e5);
    const o = r * (1 + t3);
    r *= 1 + s4;
    let a2 = false;
    const h2 = this.m_shape.getTotalPointCount() + 10 > 30 ? 1e3 : (this.m_shape.getTotalPointCount() + 10) * (this.m_shape.getTotalPointCount() + 10), m3 = this.m_shape.hasPointFeatures();
    for (let l2 = 0; ; l2++) {
      this.m_shape.dbgCheckSelection(), l2 > h2 && b("crack_and_cluster_iteration_exceeded"), this.m_shape.dbgVerifyMonotone();
      let e6 = -1;
      0 === l2 && (e6 = this.firstCrack_(), a2 ||= e6 > 0);
      const t4 = this.cluster_(n6);
      if (this.m_shape.dbgVerifyMonotone(), a2 ||= t4, this.m_bFilterDegenerateSegments) {
        const e7 = 0 !== this.m_shape.filterClosePoints(n6, true, false, this.m_bTrackChanges, cr);
        a2 ||= e7, this.m_shape.dbgVerifyMonotone();
      }
      const s5 = this.m_shape.snapControlPointsOnSelection(o * o);
      a2 ||= s5, this.m_shape.dbgCheckSelection();
      let g2 = false;
      if ((0 === l2 && -1 === e6 || m3 || Mn2(true, this.m_shape, r, null, this.m_progressTracker)) && (g2 = this.crack_(o), a2 ||= g2, this.m_shape.dbgVerifyMonotone()), !g2 && !_ba.fixCurveTwoPointLoops(this.m_shape, n6, this.m_progressTracker)) {
        this.m_shape.dbgVerifyMonotone();
        break;
      }
    }
    return a2 && ua2(this.m_shape), a2;
  }
  cluster_(e5) {
    return mn2(this.m_shape, e5, cr, this.m_bTrackChanges, this.m_progressTracker);
  }
  crack_(e5) {
    return An2(this.m_shape, e5, this.m_bTrackChanges, this.m_progressTracker);
  }
  static fixCurveTwoPointLoops(e5, t3, s4) {
    if (!e5.hasCurves()) return false;
    e5.dbgVerifyCurves();
    const n6 = e5.createUserIndexUninitialized(), r = new st2(0), i2 = e5.queryVertexIteratorOnSelection();
    for (let a2 = i2.next(); a2 !== cr; a2 = i2.next()) r.add(a2), e5.setUserIndex(a2, n6, -1);
    if (0 === r.size()) return false;
    r.add(cr), e5.sortVerticesSimpleByY(r, 0, r.size() - 1);
    let o = 0;
    const h2 = e5.getXY(r.read(o)), m3 = new mi(Number.NaN, Number.NaN), l2 = [];
    for (let a2 = 1, g2 = r.size(); a2 < g2; ++a2) {
      const t4 = r.read(a2), s5 = t4 !== cr ? e5.getXY(t4) : m3;
      if (s5.equals(h2)) continue;
      const i3 = [];
      for (let m4 = o; m4 < a2; m4++) {
        const t5 = r.read(m4), s6 = e5.getPrevVertex(t5);
        if (s6 !== cr && -1 === e5.getUserIndex(s6, n6)) {
          const t6 = wa2(e5.getXY(s6), e5.getSegment(s6));
          0 !== mi.sqrDistance(h2, t6.otherPt) && (t6.vert = s6, t6.dir = -1, i3.push(t6)), e5.setUserIndex(s6, n6, 1);
        }
        const o2 = e5.getNextVertex(t5);
        if (o2 !== cr && -1 === e5.getUserIndex(t5, n6)) {
          const s7 = wa2(e5.getXY(o2), e5.getSegment(t5));
          0 !== mi.sqrDistance(h2, s7.otherPt) && (s7.vert = t5, s7.dir = 1, i3.push(s7)), e5.setUserIndex(t5, n6, 1);
        }
      }
      if (i3.length > 1) {
        i3.sort((e7, t6) => Ta2(e7, t6));
        const e6 = wa2(m3.clone(), null);
        i3.push(e6);
        let t5 = 0;
        for (let s6 = 1, n7 = i3.length; s6 < n7; s6++) if (!i3[s6].otherPt.equals(i3[s6 - 1].otherPt)) {
          if (s6 - t5 > 1 && null !== i3[t5].seg) {
            let e7 = false;
            const n8 = t5;
            for (let r2 = t5 + 1; r2 < s6; r2++) if (!va2(i3[n8], i3[r2])) {
              e7 = true;
              break;
            }
            if (e7) for (let r2 = t5; r2 < s6 && null !== i3[r2].seg; r2++) l2.push(i3[r2].vert);
          }
          t5 = s6;
        }
      }
      o = a2, h2.setCoordsPoint2D(s5);
    }
    for (const g2 of l2) {
      const s5 = e5.getSegment(g2);
      n2(null !== s5);
      const n7 = e5.getXY(g2), r2 = e5.getXY(e5.getNextVertex(g2));
      if (mi.distance(n7, r2) < 3 * t3) e5.setSegmentToIndex(e5.getVertexIndex(g2), null);
      else {
        const t4 = s5.lengthToT(0.5 * s5.calculateLength2D());
        e5.splitSegment(g2, [t4], 1);
      }
    }
    return e5.removeUserIndex(n6), l2.length > 0;
  }
  firstCrack_() {
    const e5 = this.m_shape.getEnvelope2D(this.m_progressTracker), t3 = At(null, e5, true).total();
    if (4 * t3 < this.m_tolerance.total()) {
      let e6 = false;
      const s4 = 1.1 * t3, n6 = t3, r = this.cluster_(s4);
      e6 ||= r;
      let i2 = 0;
      this.m_bFilterDegenerateSegments && (i2 = this.m_shape.filterClosePoints(0, true, false, this.m_bTrackChanges, cr));
      const o = this.crack_(n6);
      return e6 ||= o, e6 ? 1 : i2 ? 2 : 0;
    }
    return -1;
  }
  progress_(e5 = false) {
    this.m_progressCounter++, !e5 && 4095 & this.m_progressCounter || (this.m_progressCounter = 0);
  }
};
function wa2(e5, t3) {
  return { otherPt: e5, seg: t3, vert: -1, dir: 0 };
}
function va2(e5, t3) {
  if (n2(e5.otherPt.equals(t3.otherPt)), null === e5.seg) return null === t3.seg;
  if (null === t3.seg) return false;
  const s4 = e5.seg.getGeometryType();
  if (s4 !== t3.seg.getGeometryType()) return false;
  if (s4 === a.enumBezier) {
    const s5 = e5.seg, n6 = t3.seg;
    let r = s5.getControlPoint1(), i2 = s5.getControlPoint2();
    -1 === e5.dir && (i2 = Pt(r, r = i2));
    let o = n6.getControlPoint1(), a2 = n6.getControlPoint2();
    return -1 === t3.dir && (a2 = Pt(o, o = a2)), r.equals(o) && i2.equals(a2);
  }
  if (s4 === a.enumRationalBezier2) {
    const s5 = e5.seg, n6 = t3.seg, r = s5.getControlPoint1(), i2 = n6.getControlPoint1();
    if (!r.equals(i2)) return false;
    const o = [0, 0, 0];
    s5.queryWeights(o), -1 === e5.dir && (o[2] = Pt(o[0], o[0] = o[2]));
    const a2 = [0, 0, 0];
    return n6.queryWeights(a2), -1 === t3.dir && (a2[2] = Pt(a2[0], a2[0] = a2[2])), o[0] === a2[0] && o[1] === a2[1] && o[2] === a2[2];
  }
  b("");
}
function Na2(e5, t3) {
  if (null === e5.seg || null === t3.seg) return null !== e5.seg ? -1 : null !== t3.seg ? 1 : 0;
  const s4 = e5.seg.getGeometryType(), n6 = t3.seg.getGeometryType();
  return s4 < n6 ? -1 : s4 > n6 ? 1 : 0;
}
function Ta2(e5, t3) {
  const s4 = e5.otherPt.compare(t3.otherPt);
  return 0 !== s4 ? s4 : Na2(e5, t3);
}
var Ga2 = h;
var Da2 = f;
var Va2 = m;
function Fa2(e5) {
  switch (e5) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 3:
      return 3;
    case 4:
      return 4;
    case 0:
      return 0;
    default:
      n2(0, "unrecognized cut side");
  }
  return 3;
}
function Ha2() {
  return { unsplitBehavior: 0, allCrossRoadsImpassable: false, ogcRule: false };
}
function ka2(e5, t3, s4, n6) {
  return new Ka2(n6).autoCompleteImpl(e5, t3, s4);
}
function Aa2(e5, t3, s4, r, i2, o, a2) {
  const h2 = new Ka2(i2);
  h2.m_bOGCOutput = true;
  const m3 = e5.getGeometryType() === a.enumPolygon && 1 === e5.getFillRule() && !Ht2(r);
  return h2.planarSimplifyImpl_(e5, t3, m3, s4, r, i2, o, a2);
}
function Ma2(e5, t3, s4, n6, r, i2, o, a2) {
  return new Ka2(i2).planarSimplifyImpl_(e5, t3, s4, n6, r, i2, o, a2);
}
function Ua2(e5, t3, s4, n6) {
  const r = new Ka2(n6), i2 = new Pr(), o = i2.addGeometry(t3), h2 = r.planarSimplifyNoCrackingAndCluster(e5, i2, o, s4);
  n2(h2, "planar_simplify_no_cracking_and_cluster");
  return i2.getGeometry(o);
}
function qa2(e5, t3, s4, n6, r, i2, o) {
  return n2(0), {};
}
function Ba2(e5, t3, s4, n6) {
  return n2(0), {};
}
function Oa2(e5, t3, s4) {
  return Ja2(e5, t3, s4);
}
function Ya2(t3, s4, r, i2) {
  if (t3.isEmpty() || s4.isEmpty() || t3.getDimension() > s4.getDimension()) return $a2(eh2(t3), t3, s4, "-");
  const o = new n4();
  t3.queryEnvelope(o);
  const a2 = new n4();
  s4.queryEnvelope(a2);
  const h2 = new n4();
  h2.setCoords({ env2D: o }), h2.mergeEnvelope2D(a2);
  const m3 = At(r, h2, true), l2 = a2.clone(), g2 = Ft2(m3);
  if (l2.inflateCoords(g2, g2), !o.isIntersecting(l2)) return $a2(eh2(t3), t3, s4, "-");
  const u = new Ka2(i2), c = new Pr(), _ = c.addGeometry(eh2(t3)), d2 = c.addGeometry(eh2(s4));
  let p3 = 0, f3 = 0, x4 = null;
  if (c.hasCurves()) {
    x4 = new fa2();
    const e5 = c.getEnvelope2D(i2);
    f3 = da2(m3.total());
    const t4 = _a2(m3.total(), e5);
    p3 = pa2(t4, f3), aa2(c, t4, m3.total(), 12e3, x4, null, i2);
  }
  u.setEditShapeCrackAndCluster(c, m3.add(p3));
  const y2 = u.difference(_, d2);
  null !== x4 && x4.stitchCurves(c, y2, f3, true);
  const P5 = $a2(c.getGeometry(y2), t3, s4, "-");
  return Ga2(P5.getGeometryType()) && (P5.getImpl().setIsSimple(4, m3.total()), P5.getGeometryType() === a.enumPolygon && P5.getImpl().updateOGCFlagsProtected()), P5;
}
function Ra2(t3, s4, r, i2) {
  if (t3.getDimension() > s4.getDimension()) return $a2(eh2(t3), t3, s4, "^");
  if (t3.getDimension() < s4.getDimension()) return $a2(eh2(s4), t3, s4, "^");
  if (t3.isEmpty()) return $a2(eh2(s4), t3, s4, "^");
  if (s4.isEmpty()) return $a2(eh2(t3), t3, s4, "^");
  const o = new n4();
  t3.queryEnvelope(o);
  const a2 = new n4();
  s4.queryEnvelope(a2);
  const h2 = new n4();
  h2.setCoords({ env2D: o }), h2.mergeEnvelope2D(a2);
  const m3 = At(r, h2, true), l2 = new Ka2(i2), g2 = new Pr(), u = g2.addGeometry(eh2(t3)), c = g2.addGeometry(eh2(s4));
  let _ = 0, d2 = null;
  if (g2.hasCurves()) {
    d2 = new fa2();
    const e5 = g2.getEnvelope2D(i2);
    _ = da2(m3.total());
    aa2(g2, _a2(m3.total(), e5), m3.total(), 12e3, d2, null, i2);
  }
  l2.setEditShapeCrackAndCluster(g2, m3);
  const p3 = l2.symmetricDifference(u, c);
  null !== d2 && d2.stitchCurves(g2, p3, _, true);
  const f3 = $a2(g2.getGeometry(p3), t3, s4, "^");
  return Ga2(f3.getGeometryType()) && (f3.getImpl().setIsSimple(4, m3.total()), f3.getGeometryType() === a.enumPolygon && f3.getImpl().updateOGCFlagsProtected()), f3;
}
function Xa2(e5, t3, s4) {
  return Qa2(e5, t3, s4, true);
}
function La2(e5, t3, s4) {
  return e5.isEmpty() || t3.isEmpty() ? e5.createInstance() : Pa2(s4, e5, t3) ? new ee({ copy: Ea2(e5, t3) }) : e5.createInstance();
}
function za2(t3, s4, r, i2) {
  const o = n4.constructEmpty();
  t3.queryEnvelope(o);
  const a2 = n4.constructEmpty();
  s4.queryEnvelope(a2);
  const h2 = n4.constructEmpty();
  h2.setCoords({ env2D: o }), h2.mergeEnvelope2D(a2);
  const m3 = At(r, h2, true), l2 = new n4(a2), g2 = Ft2(m3);
  if (l2.inflateCoords(g2, g2), !o.isIntersecting(l2)) {
    if (t3.getDimension() <= s4.getDimension()) return $a2(eh2(t3.createInstance()), t3, s4, "&");
    if (t3.getDimension() > s4.getDimension()) return $a2(eh2(s4.createInstance()), t3, s4, "&");
  }
  const u = new Ka2(i2), c = new Pr(), _ = c.addGeometry(eh2(t3)), d2 = c.addGeometry(eh2(s4));
  let p3 = 0, f3 = 0, x4 = null;
  if (c.hasCurves()) {
    x4 = new fa2();
    const e5 = c.getEnvelope2D(i2);
    f3 = da2(m3.total());
    const t4 = _a2(m3.total(), e5);
    p3 = pa2(t4, f3), aa2(c, t4, m3.total(), 12e3, x4, null, i2);
  }
  u.setEditShapeCrackAndCluster(c, m3.add(p3));
  const y2 = u.intersection(_, d2);
  null !== x4 && x4.stitchCurves(c, y2, f3, true);
  const P5 = $a2(c.getGeometry(y2), t3, s4, "&");
  return Ga2(P5.getGeometryType()) && (P5.getImpl().setIsSimple(4, m3.total()), P5.getGeometryType() === a.enumPolygon && P5.getImpl().updateOGCFlagsProtected()), P5;
}
function Wa2(t3, s4, r, i2) {
  const o = new Array(3), a2 = n4.constructEmpty();
  t3.queryEnvelope(a2);
  const h2 = n4.constructEmpty();
  s4.queryEnvelope(h2);
  const m3 = n4.constructEmpty();
  m3.setCoords({ env2D: a2 }), m3.mergeEnvelope2D(h2);
  const l2 = At(r, m3, true), g2 = new n4(h2), u = Ft2(l2);
  if (g2.inflateCoords(u, u), !a2.isIntersecting(g2)) {
    if (t3.getDimension() <= s4.getDimension()) {
      const e5 = $a2(eh2(t3.createInstance()), t3, s4, "&");
      return o[e5.getDimension()] = e5, o;
    }
    if (t3.getDimension() > s4.getDimension()) {
      const e5 = $a2(eh2(s4.createInstance()), t3, s4, "&");
      return o[e5.getDimension()] = e5, o;
    }
  }
  const c = new Ka2(i2), _ = new Pr(), d2 = _.addGeometry(eh2(t3)), p3 = _.addGeometry(eh2(s4));
  let f3 = 0, x4 = 0, y2 = null;
  if (_.hasCurves()) {
    y2 = new fa2();
    const e5 = _.getEnvelope2D(i2);
    x4 = da2(l2.total());
    const t4 = _a2(l2.total(), e5);
    f3 = pa2(t4, x4), aa2(_, t4, l2.total(), 12e3, y2, null, i2);
  }
  c.setEditShapeCrackAndCluster(_, l2.add(f3)), _.dbgVerifyCurves();
  const P5 = c.intersectionEx(d2, p3);
  for (const e5 of P5) {
    null !== y2 && y2.stitchCurves(_, e5, x4, false);
    const r2 = $a2(_.getGeometry(e5), t3, s4, "&");
    Ga2(r2.getGeometryType()) && (r2.getImpl().setIsSimple(4, l2.total()), r2.getGeometryType() === a.enumPolygon && r2.getImpl().updateOGCFlagsProtected()), o[r2.getDimension()] = r2;
  }
  return null !== y2 && y2.clearStitcher(_), o;
}
function ja2(e5, s4, n6, r, i2, o = false) {
  0 === s4 && P("not enough geometries to dissolve");
  let a2 = 0;
  for (let t3 = 0, d2 = s4; t3 < d2; t3++) a2 = Math.max(e5[t3].getDimension(), a2);
  if (2 === a2 || 1 === a2) return new Ka2(r).dissolveMultiPaths_(a2, false, e5, s4, n6, i2, o);
  let h2 = 0, m3 = -1;
  for (let t3 = 0, d2 = s4; t3 < d2; t3++) e5[t3].getDimension() === a2 && (-1 === m3 && (m3 = t3), e5[t3].isEmpty() || (m3 = t3, h2++));
  if (h2 < 2) return eh2(e5[m3]);
  const l2 = G3.constructEmpty(), g2 = new Pr();
  let u = cr;
  for (let t3 = 0, d2 = s4; t3 < d2; t3++) if (e5[t3].getDimension() === a2 && !e5[t3].isEmpty()) {
    u === cr ? u = g2.addGeometry(eh2(e5[t3])) : g2.appendGeometry(u, eh2(e5[t3]));
    const s5 = G3.constructEmpty();
    e5[t3].queryLooseEnvelope(s5), l2.mergeEnv3D(s5);
  }
  const c = At(n6, l2.getEnvelope2D(), true), _ = new Ka2(r);
  if (o) {
    const e6 = qt2(n6, l2.getEnvelopeZs(), true);
    return _.planarSimplify3DImpl_(g2, c, e6, 0, true);
  }
  return _.m_bOGCOutput = true, _.planarSimplifyMultiPoints(g2, c, false, -1);
}
function Za2(e5, s4, n6, r, i2, o = false) {
  s4 < 2 && P("not enough geometries to dissolve");
  let a2 = 0;
  for (let t3 = 0, p3 = s4; t3 < p3; t3++) a2 = Math.max(e5[t3].getDimension(), a2);
  if (2 === a2 || 1 === a2) return new Ka2(r).dissolveMultiPaths_(a2, true, e5, s4, n6, i2, o);
  const h2 = G3.constructEmpty(), m3 = new Pr();
  let l2 = cr, g2 = 0, u = -1;
  for (let t3 = 0, p3 = s4; t3 < p3; t3++) if (e5[t3].getDimension() === a2 && (-1 === u && (u = t3), !e5[t3].isEmpty())) {
    u = t3, l2 === cr ? l2 = m3.addGeometry(eh2(e5[t3])) : m3.appendGeometry(l2, eh2(e5[t3]));
    const s5 = G3.constructEmpty();
    e5[t3].queryLooseEnvelope(s5), h2.mergeEnv3D(s5), g2++;
  }
  if (g2 < 2) return eh2(e5[u]);
  const c = 0 === a2 ? n6 : null, _ = At(c, h2.getEnvelope2D(), true), d2 = new Ka2(r);
  if (o) {
    const e6 = qt2(c, h2.getEnvelopeZs(), true);
    return d2.m_bOGCOutput = true, d2.planarSimplify3DImpl_(m3, _, e6, 0, true);
  }
  return d2.planarSimplifyMultiPoints(m3, _, true, -1);
}
var Ka2 = class {
  constructor(e5) {
    this.m_topoGraph = null, this.m_maskLookup = [], this.m_dummyPt1 = mi.getNAN(), this.m_dummyPt2 = mi.getNAN(), this.m_fromEdgeForPolylines = cr, this.m_progressCounter = 0, this.m_bOGCOutput = false, this.m_progressTracker = e5;
  }
  linesToPolygonsImpl(e5, t3) {
    let s4 = 0, n6 = 0, r = null;
    if (e5.hasCurves()) {
      r = new fa2();
      const i3 = e5.getEnvelope2D(this.m_progressTracker);
      n6 = da2(t3.total());
      const o2 = _a2(t3.total(), i3);
      s4 = pa2(o2, n6), aa2(e5, o2, t3.total(), 12e3, r, null, this.m_progressTracker);
    }
    this.setEditShapeCrackAndCluster(e5, t3.add(s4));
    const i2 = this.m_topoGraph.createUserIndexForChains(), o = this.m_topoGraph.getFirstChain();
    this.m_topoGraph.setChainUserIndex(o, i2, 1);
    for (let h2 = this.m_topoGraph.getChainFirstIsland(o); h2 !== cr; h2 = this.m_topoGraph.getChainNextInParent(h2)) this.m_topoGraph.setChainUserIndex(h2, i2, 1);
    const a2 = [];
    for (let h2 = this.m_topoGraph.getFirstChain(); h2 !== cr; h2 = this.m_topoGraph.getChainNext(h2)) {
      if (1 === this.m_topoGraph.getChainUserIndex(h2, i2)) continue;
      this.m_topoGraph.setChainUserIndex(h2, i2, 1);
      for (let e6 = this.m_topoGraph.getChainFirstIsland(h2); e6 !== cr; e6 = this.m_topoGraph.getChainNextInParent(e6)) this.m_topoGraph.setChainUserIndex(e6, i2, 1);
      if (0 === this.m_topoGraph.getChainArea(h2)) continue;
      const t4 = this.m_topoGraph.extractPolygonFromChainAndIslands(e5, cr, h2, cr);
      null != r && r.stitchCurves(e5, t4, n6, false);
      const s5 = e5.getGeometry(t4);
      a2.push(s5);
    }
    return new s2(a2);
  }
  autoCompleteImpl(e5, t3, s4) {
    let n6 = 0, r = 0, i2 = null;
    if (e5.hasCurves()) {
      i2 = new fa2();
      const t4 = e5.getEnvelope2D(this.m_progressTracker);
      r = da2(s4.total());
      const o2 = _a2(s4.total(), t4);
      n6 = pa2(o2, r), aa2(e5, o2, s4.total(), 12e3, i2, null, this.m_progressTracker);
    }
    this.setEditShapeCrackAndCluster(e5, s4.add(n6));
    const o = this.m_topoGraph.getGeometryID(t3), a2 = this.m_topoGraph.createUserIndexForChains(), h2 = this.m_topoGraph.getFirstChain();
    this.m_topoGraph.setChainUserIndex(h2, a2, 1);
    for (let l2 = this.m_topoGraph.getChainFirstIsland(h2); l2 !== cr; l2 = this.m_topoGraph.getChainNextInParent(l2)) this.m_topoGraph.setChainUserIndex(l2, a2, 1);
    const m3 = [];
    for (let l2 = this.m_topoGraph.getFirstChain(); l2 !== cr; l2 = this.m_topoGraph.getChainNext(l2)) {
      if (1 === this.m_topoGraph.getChainUserIndex(l2, a2)) continue;
      this.m_topoGraph.setChainUserIndex(l2, a2, 1);
      for (let e6 = this.m_topoGraph.getChainFirstIsland(l2); e6 !== cr; e6 = this.m_topoGraph.getChainNextInParent(e6)) this.m_topoGraph.setChainUserIndex(e6, a2, 1);
      if (0 !== this.m_topoGraph.getChainParentage(l2)) continue;
      const t4 = this.m_topoGraph.getChainHalfEdge(l2);
      let s5 = t4, n7 = false;
      do {
        const e6 = this.m_topoGraph.getHalfEdgeTwin(s5);
        if (this.m_topoGraph.getHalfEdgeChain(e6) !== l2 && 0 !== (this.m_topoGraph.getHalfEdgeParentage(s5) & o)) {
          n7 = true;
          break;
        }
        s5 = this.m_topoGraph.getHalfEdgeNext(s5);
      } while (s5 !== t4);
      if (!n7) continue;
      if (0 === this.m_topoGraph.getChainArea(l2)) continue;
      const h3 = this.m_topoGraph.extractPolygonFromChainAndIslands(e5, cr, l2, cr);
      null !== i2 && i2.stitchCurves(e5, h3, r, false);
      const g2 = e5.getGeometry(h3);
      m3.push(g2);
    }
    return new s2(m3);
  }
  setEditShape(e5, t3 = false) {
    null === this.m_topoGraph && (this.m_topoGraph = new tn2()), this.m_topoGraph.setEditShape(e5, this.m_progressTracker, true, t3);
  }
  setEditShapeCrackAndCluster(e5, t3) {
    ya2(e5, t3, this.m_progressTracker, true, false);
    for (let s4 = e5.getFirstGeometry(); s4 !== cr; s4 = e5.getNextGeometry(s4)) e5.getGeometryType(s4) === a.enumPolygon && er2(e5, s4, -1, this.m_bOGCOutput, cr, this.m_progressTracker);
    this.setEditShape(e5);
  }
  setHalfEdgeOrientations_(e5, t3) {
    const s4 = this.m_topoGraph.getShape();
    for (let n6 = s4.getFirstGeometry(); n6 !== cr; n6 = s4.getNextGeometry(n6)) if (n6 === t3) for (let t4 = s4.getFirstPath(n6); t4 !== cr; t4 = s4.getNextPath(t4)) {
      let n7 = s4.getFirstVertex(t4);
      if (n7 === cr) continue;
      let r = s4.getNextVertex(n7);
      for (; r !== cr; ) {
        const t5 = this.m_topoGraph.getClusterFromVertex(n7), i2 = this.m_topoGraph.getClusterFromVertex(r), o = this.m_topoGraph.getHalfEdgeConnector(t5, i2);
        if (o !== cr) {
          const t6 = this.m_topoGraph.getHalfEdgeTwin(o);
          this.m_topoGraph.setHalfEdgeUserIndex(o, e5, 1), this.m_topoGraph.setHalfEdgeUserIndex(t6, e5, 2);
        }
        n7 = r, r = s4.getNextVertex(n7);
      }
    }
  }
  flushVertices_(e5, t3) {
    const s4 = this.m_topoGraph.getShape(), n6 = s4.hasSegmentParentage(), r = new fm(), i2 = s4.insertPath(e5, cr);
    t3.push(t3[0]);
    const o = t3.length;
    let a2 = cr;
    for (let h2 = 0; h2 < o; h2++) {
      const e6 = t3[h2];
      if (a2 = s4.addVertex(i2, e6), !n6) continue;
      const m3 = this.m_topoGraph.getClusterFromVertex(e6);
      if (h2 > 0 && this.m_topoGraph.isBreakNode(m3) && s4.setSegmentParentageBreakVertex(a2, true), h2 < o - 1) {
        const e7 = this.m_topoGraph.getHalfEdgeConnector(m3, this.m_topoGraph.getClusterFromVertex(t3[h2 + 1])), n7 = this.m_topoGraph.getSegmentParentage(e7);
        s4.setSegmentParentageAndBreak(a2, n7, h2 > 0 || this.m_topoGraph.isBreakNode(m3)), this.m_topoGraph.isHalfEdgeCurve(e7) && (this.m_topoGraph.querySegmentXY(e7, r), s4.setSegmentToIndex(s4.getVertexIndex(a2), r.get().clone()));
      }
    }
    if (n6) {
      const e6 = this.m_topoGraph.getClusterFromVertex(t3[o - 1]);
      this.m_topoGraph.isBreakNode(e6) && s4.setSegmentParentageBreakVertex(a2, true);
    }
    s4.setClosedPath(i2, true);
  }
  processPolygonCuts_(e5, t3, s4, r) {
    const i2 = this.m_topoGraph.getGeometryID(s4), o = this.m_topoGraph.getGeometryID(r), a2 = [], h2 = this.m_topoGraph.getShape(), m3 = this.m_topoGraph.createUserIndexForHalfEdges();
    for (let l2 = this.m_topoGraph.getFirstCluster(); l2 !== cr; l2 = this.m_topoGraph.getNextCluster(l2)) {
      const s5 = this.m_topoGraph.getClusterHalfEdge(l2);
      if (s5 === cr) continue;
      let r2 = s5;
      do {
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(r2, m3)) {
          let s6 = r2, l3 = r2, g2 = false, u = 0;
          do {
            if (this.m_topoGraph.setHalfEdgeUserIndex(s6, m3, 1), !g2) {
              if (0 !== (this.m_topoGraph.getHalfEdgeParentage(s6) & o)) {
                0 !== (this.m_topoGraph.getHalfEdgeFaceParentage(s6) & i2) && (l3 = s6, g2 = true);
              }
            }
            if (g2) {
              const t4 = this.m_topoGraph.getHalfEdgeOrigin(s6), n6 = this.m_topoGraph.getClusterVertexIterator(t4), r3 = this.m_topoGraph.getVertexFromVertexIterator(n6);
              if (a2.push(r3), -1 !== e5) {
                if (0 !== (this.m_topoGraph.getHalfEdgeParentage(s6) & o)) {
                  u |= this.m_topoGraph.getHalfEdgeUserIndex(s6, e5);
                }
              }
            }
            s6 = this.m_topoGraph.getHalfEdgeNext(s6);
          } while (s6 !== l3);
          if (g2 && this.m_topoGraph.getChainArea(this.m_topoGraph.getHalfEdgeChain(l3)) > 0) {
            const e6 = h2.createGeometry(a.enumPolygon);
            this.flushVertices_(e6, a2), -1 !== t3 && h2.setGeometryUserIndex(e6, t3, u);
          }
          a2.length = 0;
        }
        r2 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(r2));
      } while (r2 !== s5);
    }
    this.m_topoGraph.deleteUserIndexForHalfEdges(m3);
  }
  cutPolygonPolyline_(e5, t3, s4, n6) {
    this.m_topoGraph.removeSpikes_();
    let r = -1;
    -1 !== e5 && (r = this.m_topoGraph.createUserIndexForHalfEdges(), this.setHalfEdgeOrientations_(r, s4)), this.processPolygonCuts_(r, e5, t3, s4), -1 !== r && (this.m_topoGraph.deleteUserIndexForHalfEdges(r), r = -1);
    const i2 = this.m_topoGraph.getShape();
    for (let o = i2.getFirstGeometry(); o !== cr; o = i2.getNextGeometry(o)) o !== t3 && o !== s4 && n6.push(o);
    n6.sort((e6, t4) => {
      const s5 = i2.getFirstPath(e6), n7 = i2.getRingArea(s5), r2 = i2.getFirstPath(t4), o = i2.getRingArea(r2);
      return n7 < o ? -1 : n7 > o ? 1 : 0;
    });
  }
  cut(e5, t3, s4, n6, r) {
    const o = this.m_topoGraph.getShape().getGeometryType(s4), a2 = this.m_topoGraph.getShape().getGeometryType(n6), h2 = m(o), l2 = m(a2);
    if (2 !== h2 || 1 !== l2) if (1 !== h2 || 1 !== l2) b("");
    else {
      new sh2(this, e5, t3, s4, n6, r).Do();
    }
    else this.cutPolygonPolyline_(t3, s4, n6, r);
  }
  progress_(e5 = false) {
  }
  isGoodParentage(e5) {
    return e5 >= 0 && e5 < this.m_maskLookup.length && this.m_maskLookup[e5];
  }
  normalizeInputGeometry(e5) {
    const s4 = e5.getGeometryType();
    if (s4 === a.enumEnvelope) {
      const t3 = new ur({ vd: e5.getDescription() });
      return e5.isEmpty() || t3.addEnvelope(e5, false), t3;
    }
    if (s4 === a.enumPoint) {
      const t3 = new Ee({ vd: e5.getDescription() });
      return e5.isEmpty() || t3.add(e5), t3;
    }
    if (f(s4)) {
      const t3 = new Os2({ vd: e5.getDescription() });
      return e5.isEmpty() || t3.addSegment(e5, true), t3;
    }
    return s4 !== a.enumMultiPoint && s4 !== a.enumPolyline && s4 !== a.enumPolygon && P("Unexpected geometry type"), e5;
  }
  dissolveNonSimplePolygons(e5, t3, s4, n6) {
    n2(t3 > 0);
    const r = new Pr();
    let i2 = 0, o = -1;
    for (let a2 = 0, h2 = t3; a2 < h2; a2++) 2 === e5[a2].getDimension() && (-1 === o && (o = a2), e5[a2].isEmpty() || (i2++, r.addGeometry(e5[a2])));
    return 0 === i2 ? (n2(o >= 0), this.normalizeInputGeometry(e5[o])) : this.planarSimplifyPolygons(r, s4, true, false, -1, true);
  }
  dissolveMultiPaths_(t3, s4, i2, h2, m3, g2, u) {
    n2(t3 >= 1 && t3 <= 2), n2(h2 > 0);
    const c = 8 & g2 ? 1 : 2, _ = G3.constructEmpty();
    let d2 = 0, p3 = -1, f3 = true;
    for (let e5 = 0, r = h2; e5 < r; e5++) if (i2[e5].getDimension() === t3 && (-1 === p3 && (p3 = e5), !i2[e5].isEmpty())) {
      p3 = e5, d2++;
      const s5 = G3.constructEmpty();
      if (i2[e5].queryLooseEnvelope(s5), _.mergeEnv3D(s5), 2 === t3 && f3 && i2[e5].getGeometryType() === a.enumPolygon) if (16 & g2) {
        const t4 = [0], s6 = i2[e5].getImpl().getIsSimple(0, t4), n6 = this.m_bOGCOutput ? 5 === s6 : Ot2(s6);
        f3 &&= n6;
      } else {
        const t4 = Vt2(i2[e5], 0);
        f3 &&= t4;
      }
    }
    if (d2 < 2 && (n2(p3 >= 0), 0 === d2 || !(16 & g2))) return this.normalizeInputGeometry(i2[p3]);
    if (!f3) {
      const e5 = At(s4 ? null : m3, _.getEnvelope2D(), true);
      return this.dissolveNonSimplePolygons(i2, h2, e5, g2);
    }
    const x4 = i2.slice(0, h2), y2 = At(m3, _.getEnvelope2D(), true), P5 = 10 * Ft2(y2);
    let E2 = new Et2(0, 0);
    if (u && (E2 = qt2(m3, _.getEnvelopeZs(), true)), 1 === d2 && 1 === t3 && 2 === c && !s4) return u ? qa2() : this.m_bOGCOutput ? Aa2(x4[p3], y2, false, -1, this.m_progressTracker, c, false) : Ma2(x4[p3], y2, false, false, -1, this.m_progressTracker, c, false);
    const S3 = new yt();
    S3.startConstruction();
    let C3 = 2 === t3 ? 3 : 4, b2 = 0;
    for (let l2 = 0, I4 = h2; l2 < I4; l2++) {
      if (x4[l2].getDimension() !== t3 || x4[l2].isEmpty()) continue;
      let i3 = x4[l2].getGeometryType();
      if (i3 !== a.enumEnvelope) {
        if (f(i3) ? (x4[l2] = this.normalizeInputGeometry(x4[l2]), i3 = a.enumPolyline) : n2(h(i3)), 1 === t3) {
          n2(i3 === a.enumPolyline);
          let e5 = -1;
          if (u) n2(0, "3d not implemented yet");
          else {
            const t4 = [0];
            e5 = x4[l2].getImpl().getIsSimple(y2.total(), t4);
          }
          if (this.m_bOGCOutput ? 5 !== e5 : !Ot2(e5)) if (s4) C3 = -1;
          else {
            u ? n2(0, "3d not implemented yet") : this.m_bOGCOutput ? x4[l2] = Aa2(x4[l2], y2, false, -1, this.m_progressTracker, c, false) : x4[l2] = Ma2(x4[l2], y2, false, false, -1, this.m_progressTracker, c, false);
            const e6 = [0];
            n2(Ot2(x4[l2].getImpl().getIsSimple(y2.total(), e6)));
          }
        } else {
          n2(i3 === a.enumPolygon);
          const e5 = [0], t4 = x4[l2].getImpl().getIsSimple(0, e5);
          n2(Ht2(t4));
        }
        const h3 = x4[l2].getImpl();
        for (let t4 = 0, s5 = h3.getPathCount(); t4 < s5; t4++) {
          const s6 = n4.constructEmpty();
          h3.queryLoosePathEnvelope(t4, s6), s6.inflateCoords(P5, P5), S3.addEnvelope(b2, s6), b2++;
        }
      } else {
        n2(i3 === a.enumEnvelope);
        const t4 = n4.constructEmpty();
        x4[l2].queryLooseEnvelope(t4), t4.inflateCoords(P5, P5), S3.addEnvelope(b2, t4), b2++, C3 = -1;
      }
    }
    S3.endConstruction();
    const w4 = b2, N2 = Yt(w4, -2147483647), T3 = Yt(w4, -1);
    let D3 = 0;
    p3 = -1, b2 = 0;
    for (let e5 = 0, r = h2; e5 < r; e5++) {
      if (x4[e5].getDimension() !== t3) continue;
      if (-1 === p3 && (p3 = e5), x4[e5].isEmpty()) continue;
      p3 = e5, D3++;
      const s5 = x4[e5].getGeometryType();
      if (h(s5)) {
        for (let t4 = 0, s6 = x4[e5].getPathCount(); t4 < s6; t4++) T3[b2] = e5, N2[b2] = -t4 - 1, b2++;
      } else n2(s5 === a.enumEnvelope), T3[b2] = e5, N2[b2] = -1, b2++;
    }
    if (D3 < 2 && 2 === t3) return n2(p3 >= 0), this.normalizeInputGeometry(x4[p3]);
    let V4 = w4;
    for (; S3.next() && V4 > 0; ) {
      this.progress_();
      const e5 = S3.getHandleA(), t4 = S3.getHandleB(), s5 = S3.getElement(e5), n6 = S3.getElement(t4);
      T3[s5] !== T3[n6] && (N2[s5] < 0 && (V4--, N2[s5] = -(N2[s5] + 1)), N2[n6] < 0 && (V4--, N2[n6] = -(N2[n6] + 1)));
    }
    const F3 = new Pr();
    let H3 = false, k4 = 0;
    for (let e5 = 0, r = h2; e5 < r; e5++) {
      if (x4[e5].getDimension() !== t3 || x4[e5].isEmpty()) continue;
      const s5 = x4[e5].getGeometryType(), r2 = k4;
      let i3 = 0, h3 = 0;
      const m4 = h(s5) ? x4[e5] : null;
      for (let t4 = r2, n6 = N2.length; t4 < n6 && T3[t4] === e5; t4++) N2[t4] >= 0 && (i3++, h3 += m4 ? m4.getPathSize(N2[t4]) : w(x4[e5])), k4++;
      if (h3 > 0.95 * w(x4[e5])) {
        F3.addGeometry(this.normalizeInputGeometry(x4[e5]));
        for (let e6 = r2; e6 < k4; e6++) N2[e6] < 0 && (N2[e6] = -(N2[e6] + 1));
      } else {
        if (0 === i3) {
          H3 = true;
          continue;
        }
        {
          H3 = true, n2(h(s5)), n2(null != m4);
          const t4 = new ur({ vd: x4[e5].getDescription() }), i4 = new Os2({ vd: x4[e5].getDescription() }), h4 = s5 === a.enumPolygon ? t4 : i4;
          for (let e6 = r2; e6 < k4; e6++) N2[e6] >= 0 && h4.addPath(m4, N2[e6], true);
          F3.addGeometry(h4);
        }
      }
    }
    let A4;
    if (F3.getFirstGeometry() !== cr) {
      const e5 = 2 === t3, n6 = s4 ? At(null, _.getEnvelope2D(), true) : y2;
      let r = new Et2(0, 0);
      if (u && (r = s4 ? qt2(null, _.getEnvelopeZs(), true) : E2), 2 === t3 && !(2 & g2)) {
        F3.collapseAllGeometriesToFirst();
        let e6 = 0, t4 = null;
        if (F3.hasCurves() && !F3.hasSegmentParentage()) {
          t4 = new fa2();
          const s5 = F3.getEnvelope2D(this.m_progressTracker);
          e6 = da2(n6.total());
          aa2(F3, _a2(n6.total(), s5), n6.total(), 12e3, t4, null, this.m_progressTracker);
        }
        Vn2(F3, F3.getFirstGeometry(), n6.total(), this.m_progressTracker), null !== t4 && t4.stitchCurves(F3, cr, e6, true);
      }
      if (u) A4 = this.planarSimplify3DImpl_(F3, n6, r, c, true);
      else if (2 === t3) A4 = this.planarSimplifyPolygons(F3, n6, e5, s4, -1, false);
      else {
        const e6 = Ha2();
        e6.ogcRule = this.m_bOGCOutput, e6.allCrossRoadsImpassable = true, e6.unsplitBehavior = c, A4 = this.planarSimplifyPolylines(F3, n6, s4, e6, -1);
      }
      if (!H3) {
        const e6 = [0];
        C3 = A4.getImpl().getIsSimple(n6.total(), e6);
      }
    } else n2(H3), n2(p3 >= 0), A4 = 2 === t3 ? new ur({ vd: x4[p3].getDescription() }) : new Os2({ vd: x4[p3].getDescription() });
    if (H3) {
      let e5 = 0;
      for (let t4 = 0, s5 = N2.length; t4 < s5; t4++) {
        const s6 = T3[t4];
        if (!(s6 < 0) && N2[t4] < 0) {
          const n6 = x4[s6].getGeometryType(), r = h(n6) ? x4[s6] : null;
          if (r) {
            const s7 = -(N2[t4] + 1);
            e5 += r.getPathSize(s7);
          } else e5 += 4;
        }
      }
      A4.reserve(A4.getPointCount() + e5);
      for (let t4 = 0, s5 = N2.length; t4 < s5; t4++) {
        const e6 = T3[t4];
        if (!(e6 < 0) && N2[t4] < 0) {
          const s6 = x4[e6].getGeometryType(), i3 = h(s6) ? x4[e6] : null;
          if (i3) {
            const e7 = -(N2[t4] + 1);
            A4.addPath(i3, e7, true);
          } else s6 === a.enumEnvelope ? A4.addEnvelope(x4[e6], false) : (n2(f(s6)), A4.addSegment(x4[e6], true));
        }
      }
    }
    let U4 = 0;
    if (2 === t3 ? -1 !== C3 && (C3 = 3, U4 = s4 ? 0 : y2.total()) : (n2(1 === t3), s4 || -1 === C3 || (U4 = y2.total())), u || A4.getImpl().setIsSimple(C3, U4), !s4 && H3) if (2 === t3) {
      if (!u) return new Eh2().execute(A4, m3, false, this.m_progressTracker);
      n2(0, "3d not yet implemented");
    } else 1 === t3 && 1 !== c && (A4 = u ? Ba2() : Ua2(this.m_bOGCOutput, A4, c, this.m_progressTracker), A4.getImpl().setIsSimple(C3, U4));
    return A4;
  }
  dissolveTopoGraphCommonEdges_() {
    const e5 = this.m_topoGraph.createUserIndexForHalfEdges(), t3 = [];
    for (let s4 = this.m_topoGraph.getFirstCluster(); s4 !== cr; s4 = this.m_topoGraph.getNextCluster(s4)) {
      const n6 = this.m_topoGraph.getClusterHalfEdge(s4);
      let r = n6;
      if (n6 !== cr) do {
        this.progress_();
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(r, e5)) {
          const s5 = this.m_topoGraph.getHalfEdgeTwin(r);
          this.m_topoGraph.setHalfEdgeUserIndex(s5, e5, 1), this.m_topoGraph.setHalfEdgeUserIndex(r, e5, 1);
          const n7 = this.m_topoGraph.getHalfEdgeFaceParentage(r);
          if (this.isGoodParentage(n7)) {
            const e6 = this.m_topoGraph.getHalfEdgeFaceParentage(s5);
            this.isGoodParentage(e6) && t3.push(r);
          }
        }
        r = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(r));
      } while (r !== n6);
    }
    this.m_topoGraph.deleteUserIndexForHalfEdges(e5), this.m_topoGraph.deleteEdgesBreakFaces_(t3);
  }
  chooseVertexByOrder(e5, t3, s4, n6) {
    let r = vs(), i2 = cr;
    for (let a2 = this.m_topoGraph.getClusterVertexIterator(e5); a2 !== cr; a2 = this.m_topoGraph.incrementVertexIterator(a2)) {
      const e6 = this.m_topoGraph.getVertexFromVertexIterator(a2), n7 = t3.getUserIndex(e6, s4);
      n7 >= 0 && n7 < r && (r = n7, i2 = e6);
    }
    n2(i2 !== cr);
    let o = t3.getUserIndex(i2, n6);
    return o > 0 && (t3.setUserIndex(i2, n6, --o), 0 === o && t3.setUserIndex(i2, s4, -1)), i2;
  }
  chooseVertexFromCluster_(e5, t3) {
    return this.m_topoGraph.getVertexDominantFromCluster(e5, t3);
  }
  chooseVertexFromVertexCluster_(e5, t3) {
    return this.m_topoGraph.getVertexDominant(e5, t3);
  }
  collectPolygonPathsPreservingFrom_(e5, t3, s4, r, i2) {
    const o = this.m_topoGraph.getShape();
    if (o.getGeometryType(e5) !== a.enumPolygon) return;
    const a2 = o.hasSegmentParentage(), h2 = new fm();
    for (let n6 = o.getFirstPath(e5); n6 !== cr; n6 = o.getNextPath(n6)) {
      const e6 = o.getFirstVertex(n6);
      this.m_topoGraph.getClusterFromVertex(e6);
      const m3 = this.m_topoGraph.getHalfEdgeFromVertex(e6);
      if (m3 === cr) continue;
      const l2 = this.m_topoGraph.getHalfEdgeUserIndex(m3, s4);
      if (1 === l2 || 2 === l2) continue;
      const g2 = this.m_topoGraph.getHalfEdgeFaceParentage(m3);
      if (!this.isGoodParentage(g2)) {
        this.m_topoGraph.setHalfEdgeUserIndex(m3, s4, 2);
        continue;
      }
      this.m_topoGraph.setHalfEdgeUserIndex(m3, s4, 1);
      const u = o.insertPath(t3, cr);
      o.setClosedPath(u, true);
      let c = m3, _ = e6, d2 = this.m_topoGraph.getClusterFromVertex(_), p3 = 1;
      do {
        this.progress_();
        const e7 = this.chooseVertexFromVertexCluster_(_, i2), t4 = o.addVertex(u, e7);
        if (this.m_topoGraph.isHalfEdgeCurve(c) && (this.m_topoGraph.querySegmentXY(c, h2), o.setSegmentToIndex(o.getVertexIndex(t4), h2.get().clone())), a2) {
          const e8 = this.m_topoGraph.getSegmentParentage(c);
          o.setSegmentParentageAndBreak(t4, e8, this.m_topoGraph.isBreakNode(d2));
        }
        let n7, m4;
        -1 !== r && this.m_topoGraph.setClusterUserIndex(d2, r, 1), this.m_topoGraph.setHalfEdgeUserIndex(c, s4, 1), c = this.m_topoGraph.getHalfEdgeNext(c);
        do {
          n7 = 1 === p3 ? o.getNextVertex(_) : o.getPrevVertex(_), m4 = n7 !== cr ? this.m_topoGraph.getClusterFromVertex(n7) : cr;
        } while (m4 === d2);
        const l3 = this.m_topoGraph.getHalfEdgeOrigin(c);
        if (l3 !== m4) {
          do {
            n7 = 1 === p3 ? o.getPrevVertex(_) : o.getNextVertex(_), m4 = n7 !== cr ? this.m_topoGraph.getClusterFromVertex(n7) : cr;
          } while (m4 === d2);
          if (l3 !== m4) {
            m4 = l3;
            const e8 = this.m_topoGraph.getClusterVertexIterator(m4);
            n7 = this.m_topoGraph.getVertexFromVertexIterator(e8);
          } else p3 = -p3;
        }
        d2 = m4, _ = n7;
      } while (c !== m3);
    }
  }
  topoOperationPolygonPolygonHelper_(e5, t3, s4, n6, r, i2) {
    this.progress_(true), e5 !== cr && this.collectPolygonPathsPreservingFrom_(e5, s4, r, i2, n6), t3 !== cr && this.collectPolygonPathsPreservingFrom_(t3, s4, r, i2, n6);
    const o = new fm(), a2 = this.m_topoGraph.getShape();
    a2.dbgVerifyCurves();
    const h2 = a2.hasSegmentParentage();
    for (let m3 = this.m_topoGraph.getFirstCluster(); m3 !== cr; m3 = this.m_topoGraph.getNextCluster(m3)) {
      const e6 = this.m_topoGraph.getClusterHalfEdge(m3);
      if (e6 === cr) continue;
      let t4 = e6;
      do {
        this.progress_();
        const e7 = this.m_topoGraph.getHalfEdgeUserIndex(t4, r);
        if (1 !== e7 && 2 !== e7) {
          const e8 = this.m_topoGraph.getHalfEdgeFaceParentage(t4);
          if (this.isGoodParentage(e8)) {
            const e9 = a2.insertPath(s4, cr);
            a2.setClosedPath(e9, true);
            let m4 = t4;
            do {
              const t5 = this.m_topoGraph.getHalfEdgeVertexIterator(m4);
              let s5 = cr;
              if (t5 !== cr) s5 = this.m_topoGraph.getVertexFromVertexIterator(t5);
              else {
                const e10 = this.m_topoGraph.getHalfEdgeVertexIterator(this.m_topoGraph.getHalfEdgeTwin(m4));
                s5 = this.m_topoGraph.getVertexFromVertexIterator(e10), s5 = a2.getNextVertex(s5);
              }
              const l2 = this.chooseVertexFromVertexCluster_(s5, n6), g2 = a2.addVertex(e9, l2);
              if (h2) {
                const e10 = this.m_topoGraph.getSegmentParentage(m4), t6 = this.m_topoGraph.getHalfEdgeOrigin(m4);
                a2.setSegmentParentageAndBreak(g2, e10, this.m_topoGraph.isBreakNode(t6));
              }
              if (this.m_topoGraph.isHalfEdgeCurve(m4) && (this.m_topoGraph.querySegmentXY(m4, o), a2.setSegmentToIndex(a2.getVertexIndex(g2), o.get().clone())), this.m_topoGraph.setHalfEdgeUserIndex(m4, r, 1), -1 !== i2) {
                const e10 = this.m_topoGraph.getClusterFromVertex(l2);
                this.m_topoGraph.setClusterUserIndex(e10, i2, 1);
              }
              m4 = this.m_topoGraph.getHalfEdgeNext(m4);
            } while (m4 !== t4);
          } else this.m_topoGraph.setHalfEdgeUserIndex(t4, r, 2);
        }
        t4 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t4));
      } while (t4 !== e6);
    }
  }
  topoOperationPolygonPolygon_(e5, t3, s4, r = false) {
    this.dissolveTopoGraphCommonEdges_();
    const i2 = this.m_topoGraph.getShape(), o = i2.createGeometry(a.enumPolygon), a2 = this.m_topoGraph.createUserIndexForHalfEdges();
    return this.topoOperationPolygonPolygonHelper_(e5, t3, o, s4, a2, -1), this.m_topoGraph.deleteUserIndexForHalfEdges(a2), r || er2(i2, o, 3, this.m_bOGCOutput, cr, this.m_progressTracker), o;
  }
  topoOperationPolyline_(e5, t3) {
    const s4 = Ha2();
    return s4.allCrossRoadsImpassable = false, s4.ogcRule = t3, s4.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(cr, e5, false, s4).first;
  }
  topoOperationMultiPoint_() {
    const e5 = this.m_topoGraph.getShape(), t3 = e5.createGeometry(a.enumMultiPoint), s4 = e5.insertPath(t3, cr);
    for (let n6 = this.m_topoGraph.getFirstCluster(); n6 !== cr; n6 = this.m_topoGraph.getNextCluster(n6)) {
      const t4 = this.m_topoGraph.getClusterParentage(n6);
      if (this.isGoodParentage(t4)) {
        let t5 = cr;
        for (let s5 = this.m_topoGraph.getClusterVertexIterator(n6); s5 !== cr; s5 = this.m_topoGraph.incrementVertexIterator(s5)) {
          const n7 = this.m_topoGraph.getVertexFromVertexIterator(s5);
          t5 === cr && (t5 = n7);
          const r = e5.getGeometryFromPath(e5.getPathFromVertex(n7)), i2 = this.m_topoGraph.getGeometryID(r);
          if (this.isGoodParentage(i2)) {
            t5 = n7;
            break;
          }
        }
        e5.addVertex(s4, t5);
      }
    }
    return t3;
  }
  intersection(e5, t3) {
    const s4 = this.m_topoGraph.getShape().getGeometryType(e5), n6 = this.m_topoGraph.getShape().getGeometryType(t3), r = m(s4), o = m(n6), h2 = this.m_topoGraph.getGeometryID(e5), l2 = this.m_topoGraph.getGeometryID(t3);
    n2(h2 >= 0), n2(l2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (h2 | l2), this.m_maskLookup[h2 | l2] = true;
    let g2 = cr;
    return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (g2 = e5), 2 === r && 2 === o ? this.topoOperationPolygonPolygon_(e5, t3, g2) : 1 === r && o > 0 || 1 === o && r > 0 ? this.topoOperationPolyline_(g2, this.m_bOGCOutput) : 0 === r || 0 === o ? this.topoOperationMultiPoint_() : void b("");
  }
  topoOperationPolygonPolygonEx(e5, t3, s4) {
    const r = this.m_topoGraph.getShape(), i2 = r.createGeometry(a.enumPolygon), o = r.createGeometry(a.enumPolyline), a2 = r.createGeometry(a.enumMultiPoint);
    this.dissolveTopoGraphCommonEdges_();
    let h2 = cr;
    const m3 = this.m_topoGraph.createUserIndexForHalfEdges(), l2 = this.m_topoGraph.createUserIndexForClusters();
    r.dbgVerifyCurves(), this.topoOperationPolygonPolygonHelper_(e5, t3, i2, s4, m3, l2), r.dbgVerifyCurves();
    const g2 = r.hasSegmentParentage(), u = new fm();
    for (let n6 = this.m_topoGraph.getFirstCluster(); n6 !== cr; n6 = this.m_topoGraph.getNextCluster(n6)) {
      const e6 = this.m_topoGraph.getClusterHalfEdge(n6);
      if (e6 === cr) continue;
      let t4 = e6;
      do {
        let e7 = this.m_topoGraph.getHalfEdgeUserIndex(t4, m3), i3 = this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(t4), m3), a3 = e7 | i3;
        if (2 === a3) {
          let h3 = this.m_topoGraph.getHalfEdgeParentage(t4);
          if (this.isGoodParentage(h3)) {
            const c2 = r.insertPath(o, cr);
            let _ = t4;
            const d2 = this.chooseVertexFromCluster_(n6, s4);
            let p3 = r.addVertex(c2, d2);
            if (g2) {
              const e8 = this.m_topoGraph.getSegmentParentage(t4), s5 = this.m_topoGraph.getHalfEdgeOrigin(t4);
              r.setSegmentParentageAndBreak(p3, e8, this.m_topoGraph.isBreakNode(s5));
            }
            this.m_topoGraph.isHalfEdgeCurve(t4) && (this.m_topoGraph.querySegmentXY(t4, u), r.setSegmentToIndex(r.getVertexIndex(p3), u.get().clone())), this.m_topoGraph.setClusterUserIndex(n6, l2, 1);
            do {
              this.progress_();
              const n7 = this.m_topoGraph.getHalfEdgeTo(_), o2 = this.chooseVertexFromCluster_(n7, s4);
              if (p3 = r.addVertex(c2, o2), g2) {
                const e8 = this.m_topoGraph.getSegmentParentage(t4), s5 = this.m_topoGraph.getHalfEdgeOrigin(t4);
                r.setSegmentParentageAndBreak(p3, e8, this.m_topoGraph.isBreakNode(s5));
              }
              if (this.m_topoGraph.setHalfEdgeUserIndex(_, m3, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m3, 1), this.m_topoGraph.setClusterUserIndex(n7, l2, 1), _ = this.m_topoGraph.getHalfEdgeNext(_), e7 = this.m_topoGraph.getHalfEdgeUserIndex(_, m3), i3 = this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m3), a3 = e7 | i3, 2 !== a3) break;
              if (h3 = this.m_topoGraph.getHalfEdgeParentage(_), !this.isGoodParentage(h3)) {
                this.m_topoGraph.setHalfEdgeUserIndex(_, m3, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m3, 1);
                break;
              }
              this.m_topoGraph.isHalfEdgeCurve(t4) && _ !== t4 && (this.m_topoGraph.querySegmentXY(t4, u), r.setSegmentToIndex(r.getVertexIndex(p3), u.get().clone()));
            } while (_ !== t4);
          } else this.m_topoGraph.setHalfEdgeUserIndex(t4, m3, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(t4), m3, 1);
        }
        t4 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t4));
      } while (t4 !== e6);
    }
    for (let n6 = this.m_topoGraph.getFirstCluster(); n6 !== cr; n6 = this.m_topoGraph.getNextCluster(n6)) {
      this.progress_();
      if (1 === this.m_topoGraph.getClusterUserIndex(n6, l2)) continue;
      const e6 = this.m_topoGraph.getClusterParentage(n6);
      if (this.isGoodParentage(e6)) {
        h2 === cr && (h2 = r.insertPath(a2, cr));
        const e7 = this.m_topoGraph.getClusterVertexIterator(n6);
        let t4 = cr;
        if (e7 !== cr) {
          t4 = this.m_topoGraph.getVertexFromVertexIterator(e7);
          const n7 = this.chooseVertexFromVertexCluster_(t4, s4);
          r.addVertex(h2, n7);
        }
      }
    }
    this.m_topoGraph.deleteUserIndexForClusters(l2), this.m_topoGraph.deleteUserIndexForHalfEdges(m3), r.dbgVerifyCurves(), er2(r, i2, 3, this.m_bOGCOutput, cr, this.m_progressTracker);
    const c = [cr, cr, cr];
    return c[0] = a2, c[1] = o, c[2] = i2, c;
  }
  topoOperationPolylinePolylineOrPolygonEx(e5, t3) {
    const s4 = Ha2();
    return s4.allCrossRoadsImpassable = false, s4.ogcRule = t3, s4.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(cr, e5, true, s4);
  }
  topoOperationMultiPoint() {
    const e5 = this.m_topoGraph.getShape(), t3 = e5.createGeometry(a.enumMultiPoint), s4 = e5.insertPath(t3, cr);
    for (let n6 = this.m_topoGraph.getFirstCluster(); n6 !== cr; n6 = this.m_topoGraph.getNextCluster(n6)) {
      const t4 = this.m_topoGraph.getClusterParentage(n6);
      if (this.isGoodParentage(t4)) {
        let t5 = cr;
        for (let s5 = this.m_topoGraph.getClusterVertexIterator(n6); s5 !== cr; s5 = this.m_topoGraph.incrementVertexIterator(s5)) {
          const n7 = this.m_topoGraph.getVertexFromVertexIterator(s5);
          t5 === cr && (t5 = n7);
          const r = e5.getGeometryFromPath(e5.getPathFromVertex(n7)), i2 = this.m_topoGraph.getGeometryID(r);
          if (this.isGoodParentage(i2)) {
            t5 = n7;
            break;
          }
        }
        e5.addVertex(s4, t5);
      }
    }
    return t3;
  }
  intersectionEx(e5, t3) {
    const s4 = this.m_topoGraph.getShape().getGeometryType(e5), n6 = this.m_topoGraph.getShape().getGeometryType(t3), r = Va2(s4), o = Va2(n6), h2 = this.m_topoGraph.getGeometryID(e5), m3 = this.m_topoGraph.getGeometryID(t3);
    n2(h2 >= 0), n2(m3 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (h2 | m3), this.m_maskLookup[h2 | m3] = true;
    let l2 = cr;
    if (this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (l2 = e5), 2 === r && 2 === o) return this.topoOperationPolygonPolygonEx(e5, t3, l2);
    if (1 === r && o > 0 || 1 === o && r > 0) {
      const { first: e6, second: t4 } = this.topoOperationPolylinePolylineOrPolygonEx(l2, this.m_bOGCOutput);
      return [t4, e6];
    }
    if (0 === r || 0 === o) {
      const e6 = [];
      return e6.push(this.topoOperationMultiPoint()), e6;
    }
    b("");
  }
  getCombinedHalfEdgeParentage(e5) {
    return this.m_topoGraph.getHalfEdgeParentage(e5) | this.m_topoGraph.getHalfEdgeFaceParentage(e5) | this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
  }
  prevailingDirection(e5, t3) {
    const s4 = this.getCombinedHalfEdgeParentage(t3), n6 = this.m_topoGraph.getHalfEdgeOrigin(t3), r = this.m_topoGraph.getHalfEdgeTo(t3);
    let i2 = 0, o = 0;
    for (let a2 = this.m_topoGraph.getClusterVertexIterator(n6); a2 !== cr; a2 = this.m_topoGraph.incrementVertexIterator(a2)) {
      const n7 = this.m_topoGraph.getVertexFromVertexIterator(a2), h2 = e5.getPathFromVertex(n7), m3 = e5.getGeometryFromPath(h2), l2 = this.m_topoGraph.getGeometryID(m3), g2 = e5.getFirstVertex(h2), u = 0 !== (l2 & s4);
      u && g2 === n7 && (this.m_fromEdgeForPolylines = t3);
      const c = e5.getNextVertex(n7);
      if (c !== cr && this.m_topoGraph.getClusterFromVertex(c) === r) {
        if (i2++, u) {
          if (this.m_fromEdgeForPolylines === cr && g2 === c) {
            const e6 = this.m_topoGraph.getHalfEdgeNext(t3);
            this.isGoodParentage(this.getCombinedHalfEdgeParentage(e6)) && (this.m_fromEdgeForPolylines = e6);
          }
          o++;
        }
      } else {
        const s5 = e5.getPrevVertex(n7);
        if (s5 !== cr && this.m_topoGraph.getClusterFromVertex(s5) === r && (i2--, u)) {
          if (this.m_fromEdgeForPolylines === cr && g2 === s5) {
            const e6 = this.m_topoGraph.getHalfEdgeNext(t3);
            this.isGoodParentage(this.getCombinedHalfEdgeParentage(e6)) && (this.m_fromEdgeForPolylines = e6);
          }
          o--;
        }
      }
    }
    this.m_topoGraph.queryXY(n6, this.m_dummyPt1), this.m_topoGraph.queryXY(r, this.m_dummyPt2);
    return (0 !== o ? o : i2) * mi.distance(this.m_dummyPt1, this.m_dummyPt2);
  }
  tryMoveThroughCrossroadBackwards(e5, t3) {
    const s4 = this.m_topoGraph.getHalfEdgePrev(e5), n6 = this.m_topoGraph.getHalfEdgeTwin(s4);
    if (!t3) {
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e5))) return cr;
      const t4 = this.m_topoGraph.getHalfEdgeTwin(e5);
      if (n6 === this.m_topoGraph.getHalfEdgeNext(t4)) return s4;
    }
    let r = n6, i2 = cr;
    for (; r !== e5; ) {
      const e6 = this.getCombinedHalfEdgeParentage(r);
      if (this.isGoodParentage(e6)) {
        if (i2 !== cr) return cr;
        i2 = this.m_topoGraph.getHalfEdgeTwin(r);
      }
      r = this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgePrev(r));
    }
    return i2;
  }
  tryMoveThroughCrossroadForward(e5, t3) {
    const s4 = this.m_topoGraph.getHalfEdgeNext(e5), n6 = this.m_topoGraph.getHalfEdgeTwin(s4);
    if (!t3) {
      const t4 = this.m_topoGraph.getHalfEdgeTwin(e5);
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t4))) return cr;
      if (n6 === this.m_topoGraph.getHalfEdgePrev(t4)) return s4;
    }
    let r = n6, i2 = cr;
    for (; r !== e5; ) {
      const e6 = this.getCombinedHalfEdgeParentage(r);
      if (this.isGoodParentage(e6)) {
        if (i2 !== cr) return cr;
        i2 = this.m_topoGraph.getHalfEdgeTwin(r);
      }
      r = this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgeNext(r));
    }
    return i2;
  }
  isOnALoop(e5, t3) {
    let s4 = e5;
    const n6 = 2 * this.m_topoGraph.getShape().getTotalPointCount() + 10;
    for (let r = 0; r < n6; r++) {
      if (1 === this.m_topoGraph.getHalfEdgeUserIndex(s4, t3)) return false;
      const n7 = this.m_topoGraph.getHalfEdgeNext(s4);
      if (n7 === this.m_topoGraph.getHalfEdgeTwin(s4)) return false;
      if (s4 = n7, s4 === e5) return true;
    }
    b("is_on_a_loop_");
  }
  restorePolylineParts(e5, t3, s4, n6, r, i2, o, h2, m3, l2) {
    n2(r === cr && i2 >= 0 && o >= 0 || -1 === i2 && -1 === o), n2(-1 === h2 && 1 !== l2.unsplitBehavior || -1 !== h2 && 1 === l2.unsplitBehavior);
    const g2 = l2.ogcRule, u = l2.allCrossRoadsImpassable, c = 1 === l2.unsplitBehavior, _ = 0 === l2.unsplitBehavior, d2 = this.m_topoGraph.getShape(), p3 = d2.hasSegmentParentage();
    let f3 = e5, x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
    const y2 = new fm();
    this.m_fromEdgeForPolylines = cr;
    let P5 = this.prevailingDirection(d2, f3), E2 = f3, S3 = cr, C3 = false, I4 = false, b2 = false;
    if (!c) for (; ; ) {
      const t4 = this.m_topoGraph.getHalfEdgePrev(f3);
      if (t4 === x4) {
        b2 = true;
        break;
      }
      const n7 = this.m_topoGraph.getHalfEdgeNext(x4);
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(n7))) {
        C3 = true;
        break;
      }
      if (this.m_topoGraph.getHalfEdgeTwin(t4) !== n7) {
        if (u) {
          C3 = true;
          break;
        }
        if (f3 = this.tryMoveThroughCrossroadBackwards(f3, true), f3 === cr) {
          C3 = true;
          break;
        }
        x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
      } else f3 = t4, x4 = n7;
      if (1 === this.m_topoGraph.getHalfEdgeUserIndex(f3, s4)) {
        b2 = true;
        break;
      }
      if (f3 === e5) {
        S3 = e5, I4 = true;
        break;
      }
      const r2 = this.getCombinedHalfEdgeParentage(f3);
      if (!this.isGoodParentage(r2)) break;
      E2 = f3, P5 += this.prevailingDirection(d2, f3);
    }
    if (S3 === cr) {
      for (f3 = e5, x4 = this.m_topoGraph.getHalfEdgeTwin(f3), S3 = f3; ; ) {
        const e6 = this.m_topoGraph.getHalfEdgeNext(f3), t5 = this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e6));
        if (t5) {
          C3 = true;
          break;
        }
        if (e6 === x4) {
          b2 = true;
          break;
        }
        if (-1 !== h2) {
          const e7 = this.m_topoGraph.getHalfEdgeOrigin(x4);
          if (1 === this.m_topoGraph.getClusterUserIndex(e7, h2)) {
            C3 = true;
            break;
          }
        }
        const n7 = this.m_topoGraph.getHalfEdgePrev(x4);
        if (this.m_topoGraph.getHalfEdgeTwin(e6) !== n7) {
          if (t5 || u) {
            C3 = true;
            break;
          }
          if (f3 = this.tryMoveThroughCrossroadForward(f3, true), f3 === cr) {
            C3 = true;
            break;
          }
          x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
        } else f3 = e6, x4 = n7;
        if (1 === this.m_topoGraph.getHalfEdgeUserIndex(f3, s4)) {
          b2 = true;
          break;
        }
        const r2 = this.getCombinedHalfEdgeParentage(f3);
        if (!this.isGoodParentage(r2)) break;
        S3 = f3, P5 += this.prevailingDirection(d2, f3);
      }
      const t4 = this.m_topoGraph.getHalfEdgeOrigin(E2);
      I4 = this.m_topoGraph.getHalfEdgeTo(S3) === t4;
    } else if (this.m_fromEdgeForPolylines !== cr) {
      E2 = e5, S3 = this.tryMoveThroughCrossroadBackwards(E2, false), n2(S3 !== cr);
      const t4 = this.m_topoGraph.getHalfEdgeTwin(E2);
      this.m_topoGraph.getHalfEdgeNext(t4);
    }
    let w4 = I4;
    I4 || b2 || m3 && (w4 = this.isOnALoop(e5, s4), w4 || (w4 = this.isOnALoop(x4, s4)));
    const v3 = P5 >= 0;
    let N2 = false;
    w4 && C3 && (I4 ? (N2 = g2, v3 && (N2 || c || _) && E2 !== e5 && (n2(!c), E2 = e5, N2 = false)) : (c || v3 && _) && (E2 = e5));
    let T3 = 0;
    for (f3 = E2; x4 = this.m_topoGraph.getHalfEdgeTwin(f3), this.m_topoGraph.setHalfEdgeUserIndex(f3, s4, 1), this.m_topoGraph.setHalfEdgeUserIndex(x4, s4, 1), T3++, f3 !== S3; ) f3 = u ? this.m_topoGraph.getHalfEdgeNext(f3) : this.tryMoveThroughCrossroadForward(f3, false);
    v3 || (S3 = Pt(E2, E2 = S3), S3 = this.m_topoGraph.getHalfEdgeTwin(S3), E2 = this.m_topoGraph.getHalfEdgeTwin(E2));
    let G4 = d2.insertPath(t3, cr);
    f3 = E2;
    const D3 = this.m_topoGraph.getHalfEdgeOrigin(E2);
    let V4;
    V4 = -1 !== i2 ? this.chooseVertexByOrder(D3, d2, i2, o) : this.chooseVertexFromCluster_(D3, r), this.m_topoGraph.isStrongPathNode(D3) && d2.setStrongPathStart(G4, true);
    let H3 = d2.addVertex(G4, V4), k4 = H3;
    -1 !== n6 && this.m_topoGraph.setClusterUserIndex(D3, n6, 1);
    let A4 = 0;
    const U4 = N2 ? Math.trunc((T3 + 1) / 2) : -1;
    let q2 = cr, B4 = true, O3 = cr;
    for (; ; ) {
      if (p3) {
        const e7 = this.m_topoGraph.getSegmentParentage(f3), t4 = this.m_topoGraph.getHalfEdgeOrigin(f3);
        d2.setSegmentParentageAndBreak(k4, e7, B4 || this.m_topoGraph.isBreakNode(t4));
      }
      B4 = false, this.m_topoGraph.isHalfEdgeCurve(f3) && (this.m_topoGraph.querySegmentXY(f3, y2), d2.setSegmentToIndex(d2.getVertexIndex(k4), y2.get().clone())), q2 !== cr && -1 !== o && d2.addToUserIndex(q2, o, -1);
      const e6 = u ? this.m_topoGraph.getHalfEdgeNext(f3) : this.tryMoveThroughCrossroadForward(f3, false), s5 = this.m_topoGraph.getHalfEdgeTo(f3);
      let a2;
      if (a2 = -1 !== i2 ? this.chooseVertexByOrder(s5, d2, i2, o) : this.chooseVertexFromCluster_(s5, r), H3 = d2.addVertex(G4, a2), O3 = s5, -1 !== n6 && this.m_topoGraph.setClusterUserIndex(s5, n6, 1), p3 && this.m_topoGraph.isBreakNode(s5) && d2.setSegmentParentageBreakVertex(H3, true), q2 = a2, A4++, N2 && A4 === U4 && (G4 = d2.insertPath(t3, cr), H3 = d2.addVertex(G4, a2), B4 = true, -1 !== o && d2.addToUserIndex(a2, o, -1), q2 = cr), f3 === S3) break;
      f3 = e6, k4 = H3;
    }
    O3 !== cr && this.m_topoGraph.isStrongPathNode(O3) && d2.setStrongPathEnd(G4, true);
  }
  topoOperationPolylineSimplify_(e5, t3) {
    return this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e5, cr, false, t3).first;
  }
  topoOperationPolylineSimplifyOrPolylineTopoHelper_(e5, t3, s4, r) {
    n2(t3 === cr || e5 === cr);
    const i2 = this.m_topoGraph.getShape(), o = (t4) => t4 = e5 === cr ? t4 === cr ? i2.getFirstGeometry() : i2.getNextGeometry(t4) : t4 === cr ? e5 : cr, h2 = i2.createGeometry(a.enumPolyline);
    let m3 = -1;
    s4 && (m3 = this.m_topoGraph.createUserIndexForClusters());
    const l2 = this.m_topoGraph.createUserIndexForHalfEdges(), g2 = t3 === cr ? i2.createUserIndex() : -1, u = t3 === cr ? i2.createUserIndex() : -1;
    let c = -1;
    if (1 === r.unsplitBehavior) {
      c = this.m_topoGraph.createUserIndexForClusters();
      for (let e6 = o(cr); e6 !== cr; e6 = o(e6)) for (let t4 = i2.getFirstPath(e6); t4 !== cr; t4 = i2.getNextPath(t4)) {
        {
          const e7 = i2.getFirstVertex(t4), s5 = this.m_topoGraph.getClusterFromVertex(e7);
          this.m_topoGraph.setClusterUserIndex(s5, c, 1);
        }
        if (!i2.isClosedPath(t4)) {
          const e7 = i2.getLastVertex(t4), s5 = this.m_topoGraph.getClusterFromVertex(e7);
          this.m_topoGraph.setClusterUserIndex(s5, c, 1);
        }
      }
    }
    if (t3 === cr) {
      let e6 = 0;
      for (let t4 = o(cr); t4 !== cr; t4 = o(t4)) for (let s5 = i2.getFirstPath(t4); s5 !== cr; s5 = i2.getNextPath(s5)) {
        if (i2.isClosedPath(s5)) {
          let t5 = i2.getFirstVertex(s5);
          for (let n6 = 0, r2 = i2.getPathSize(s5); n6 < r2; n6++, t5 = i2.getNextVertex(t5)) i2.setUserIndex(t5, g2, e6++), i2.setUserIndex(t5, u, 2);
        } else {
          const t5 = i2.getFirstVertex(s5);
          i2.setUserIndex(t5, g2, e6++), i2.setUserIndex(t5, u, 1);
          let n6 = i2.getNextVertex(t5);
          for (let r2 = 1, o2 = i2.getPathSize(s5) - 1; r2 < o2; ++r2) i2.setUserIndex(n6, g2, e6++), i2.setUserIndex(n6, u, 2), n6 = i2.getNextVertex(n6);
          i2.setUserIndex(n6, g2, e6++), i2.setUserIndex(n6, u, 1);
        }
      }
    }
    for (let n6 = o(cr); n6 !== cr; n6 = o(n6)) for (let e6 = i2.getFirstPath(n6); e6 !== cr; e6 = i2.getNextPath(e6)) {
      let s5 = i2.getFirstVertex(e6);
      for (let n7 = 0, o2 = i2.getPathSize(e6); n7 < o2; n7++, s5 = i2.getNextVertex(s5)) {
        const e7 = this.m_topoGraph.getHalfEdgeFromVertex(s5);
        if (e7 === cr) continue;
        if (1 === this.m_topoGraph.getHalfEdgeUserIndex(e7, l2)) continue;
        const i3 = this.getCombinedHalfEdgeParentage(e7);
        if (this.isGoodParentage(i3)) {
          const s6 = 0 === n7;
          this.restorePolylineParts(e7, h2, l2, m3, t3, g2, u, c, s6, r);
        }
      }
    }
    let _ = cr;
    if (s4) {
      _ = i2.createGeometry(a.enumMultiPoint);
      let e6 = cr;
      for (let s5 = this.m_topoGraph.getFirstCluster(); s5 !== cr; s5 = this.m_topoGraph.getNextCluster(s5)) {
        this.progress_();
        if (1 !== this.m_topoGraph.getClusterUserIndex(s5, m3)) {
          const n6 = this.m_topoGraph.getClusterParentage(s5);
          if (this.isGoodParentage(n6)) {
            e6 === cr && (e6 = i2.insertPath(_, cr));
            const n7 = this.m_topoGraph.getClusterVertexIterator(s5);
            if (n7 !== cr) {
              let r2;
              this.m_topoGraph.getVertexFromVertexIterator(n7), r2 = -1 !== g2 ? this.chooseVertexByOrder(s5, i2, g2, u) : this.chooseVertexFromCluster_(s5, t3), i2.addVertex(e6, r2);
            }
          }
        }
      }
    }
    return -1 !== u && i2.removeUserIndex(u), -1 !== g2 && i2.removeUserIndex(g2), -1 !== m3 && i2.removeUserIndex(m3), this.m_topoGraph.deleteUserIndexForHalfEdges(l2), $t(h2, _);
  }
  difference(e5, t3) {
    const s4 = this.m_topoGraph.getShape().getGeometryType(e5), n6 = this.m_topoGraph.getShape().getGeometryType(t3), r = m(s4), o = m(n6);
    if (r > o) return e5;
    const a2 = this.m_topoGraph.getGeometryID(e5), h2 = this.m_topoGraph.getGeometryID(t3);
    if (this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (a2 | h2), this.m_maskLookup[a2] = true, 2 === r && 2 === o) {
      let s5 = cr;
      return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (s5 = e5), this.topoOperationPolygonPolygon_(e5, t3, s5);
    }
    if (1 === r && 2 === o) {
      const t4 = Ha2();
      return t4.allCrossRoadsImpassable = false, t4.ogcRule = this.m_bOGCOutput, t4.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e5, cr, false, t4).first;
    }
    if (1 === r && 1 === o) {
      const t4 = Ha2();
      return t4.allCrossRoadsImpassable = true, t4.ogcRule = this.m_bOGCOutput, t4.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e5, cr, false, t4).first;
    }
    if (0 === r) return this.topoOperationMultiPoint_();
    b("");
  }
  symmetricDifference(e5, t3) {
    const s4 = this.m_topoGraph.getShape().getGeometryType(e5), n6 = this.m_topoGraph.getShape().getGeometryType(t3), r = Va2(s4), o = Va2(n6), h2 = this.m_topoGraph.getGeometryID(e5), m3 = this.m_topoGraph.getGeometryID(t3);
    return n2(h2 >= 0), n2(m3 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (h2 | m3), this.m_maskLookup[h2] = true, this.m_maskLookup[h2] = true, this.m_maskLookup[m3] = true, 2 === r && 2 === o ? this.topoOperationPolygonPolygon_(e5, t3, cr) : 1 === r && 1 === o ? this.topoOperationPolyline_(cr, this.m_bOGCOutput) : 0 === r && 0 === o ? this.topoOperationMultiPoint() : void b("");
  }
  planarSimplifyNoCrackingAndCluster(e5, t3, s4, r) {
    this.m_bOGCOutput = e5, this.m_topoGraph = new tn2();
    const o = t3.getFillRule(s4), h2 = t3.getGeometryType(s4);
    if (1 !== o || h2 === a.enumMultiPoint ? this.m_topoGraph.setAndSimplifyEditShapeAlternate(t3, s4, this.m_progressTracker) : this.m_topoGraph.setAndSimplifyEditShapeWinding(t3, s4, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return false;
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const m3 = this.m_topoGraph.getGeometryID(s4);
    if (n2(m3 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = m3 + 1, this.m_maskLookup[m3] = true, t3.getGeometryType(s4) === a.enumPolygon || 1 === o && t3.getGeometryType(s4) !== a.enumMultiPoint) {
      t3.setFillRule(s4, 0);
      const n6 = this.topoOperationPolygonPolygon_(s4, cr, cr);
      if (t3.swapGeometry(n6, s4), t3.removeGeometry(n6), 1 === o && this.m_bOGCOutput) return this.planarSimplifyNoCrackingAndCluster(e5, t3, s4, r);
    } else if (t3.getGeometryType(s4) === a.enumPolyline) {
      const e6 = Ha2();
      e6.ogcRule = this.m_bOGCOutput, e6.allCrossRoadsImpassable = true, e6.unsplitBehavior = r;
      const n6 = this.topoOperationPolylineSimplify_(t3.getFirstGeometry(), e6);
      t3.swapGeometry(n6, s4), t3.removeGeometry(n6);
    } else if (t3.getGeometryType(s4) === a.enumMultiPoint) {
      const e6 = this.topoOperationMultiPoint_();
      t3.swapGeometry(e6, s4), t3.removeGeometry(e6);
    } else b("");
    return true;
  }
  unsplitPolylineExact(e5) {
    return n2(0), new Os2();
  }
  planarSimplifyPolylines(e5, t3, s4, r, i2) {
    for (let _ = e5.getFirstGeometry(); _ !== cr; _ = e5.getNextGeometry(_)) {
      const t4 = e5.getGeometryType(_);
      n2(t4 === a.enumPolyline);
    }
    let o = 0, h2 = 0, m3 = null;
    if (e5.hasCurves() && !e5.hasSegmentParentage()) {
      m3 = new fa2();
      const s5 = e5.getEnvelope2D(this.m_progressTracker);
      h2 = da2(t3.total());
      const n6 = _a2(t3.total(), s5);
      o = pa2(n6, h2), aa2(e5, n6, t3.total(), 12e3, m3, null, this.m_progressTracker);
    }
    {
      const s5 = Ia2(t3.add(o));
      e5.filterClosePoints(s5, false, false, false, cr);
    }
    if (this.m_topoGraph = new tn2(), 4 !== i2 && 5 !== i2) if (null === m3 && s4) {
      const n6 = new Dn2(this.m_progressTracker, false);
      n6.sweepVertical(e5, t3.total()), n6.hadComplications() ? (ya2(e5, t3, this.m_progressTracker, true, false), s4 = false) : this.m_topoGraph.setCheckDirtyPlanesweepTolerance(t3.total());
    } else ya2(e5, t3.add(o), this.m_progressTracker, true, false), s4 = false;
    else s4 = false;
    e5.removeSelection(), e5.collapseAllGeometriesToFirst();
    const l2 = e5.getFirstGeometry();
    if (this.m_topoGraph.setAndSimplifyEditShapeAlternate(e5, l2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n2(s4 && null === m3), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyPolylines(e5, t3, false, r, -1);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const g2 = this.m_topoGraph.getGeometryID(l2);
    n2(g2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = g2 + 1, this.m_maskLookup[g2] = true;
    const u = this.topoOperationPolylineSimplify_(e5.getFirstGeometry(), r);
    null !== m3 && m3.stitchCurves(e5, u, h2, true);
    const c = e5.getGeometry(u);
    return s4 || c.getImpl().setIsSimple(4, t3.total()), c;
  }
  planarSimplifyMultiPoints(e5, t3, s4, r) {
    for (let l2 = e5.getFirstGeometry(); l2 !== cr; l2 = e5.getNextGeometry(l2)) {
      const t4 = e5.getGeometryType(l2);
      n2(t4 === a.enumMultiPoint);
    }
    this.m_topoGraph = new tn2(), 4 !== r && 5 !== r ? (ya2(e5, t3, this.m_progressTracker, true, false), s4 = false) : s4 = false, e5.removeSelection(), e5.collapseAllGeometriesToFirst();
    const i2 = e5.getFirstGeometry();
    if (this.m_topoGraph.setAndSimplifyEditShapeAlternate(e5, i2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n2(s4), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyMultiPoints(e5, t3, false, -1);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const o = this.m_topoGraph.getGeometryID(i2);
    n2(o >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = o + 1, this.m_maskLookup[o] = true;
    const h2 = this.topoOperationMultiPoint(), m3 = e5.getGeometry(h2);
    return s4 || m3.getImpl().setIsSimple(4, t3.total()), m3;
  }
  planarSimplifyPolygons(e5, t3, s4, r, i2, o) {
    for (let f3 = e5.getFirstGeometry(); f3 !== cr; f3 = e5.getNextGeometry(f3)) {
      const t4 = e5.getGeometryType(f3);
      n2(t4 === a.enumPolygon || t4 === a.enumPolyline && s4);
    }
    let h2 = 0, m3 = 0, l2 = null;
    if (e5.hasCurves() && !e5.hasSegmentParentage()) {
      l2 = new fa2();
      const s5 = e5.getEnvelope2D(this.m_progressTracker);
      m3 = da2(t3.total());
      const n6 = _a2(t3.total(), s5);
      h2 = pa2(n6, m3), aa2(e5, n6, t3.total(), 12e3, l2, null, this.m_progressTracker);
    }
    if (o) {
      ya2(e5, t3.add(h2), this.m_progressTracker, true, false);
      for (let t4 = e5.getFirstGeometry(); t4 !== cr; t4 = e5.getNextGeometry(t4)) e5.getGeometryType(t4) === a.enumPolygon && er2(e5, t4, -1, false, cr, this.m_progressTracker);
    }
    if (this.m_topoGraph = new tn2(), o || 4 === i2 || 5 === i2) r = false;
    else if (null === l2 && r) {
      const s5 = new Dn2(this.m_progressTracker, false);
      s5.sweepVertical(e5, t3.total()), s5.hadComplications() ? (ya2(e5, t3, this.m_progressTracker, true, false), r = false) : this.m_topoGraph.setCheckDirtyPlanesweepTolerance(t3.total());
    } else ya2(e5, t3.add(h2), this.m_progressTracker, true, false), r = false;
    e5.removeSelection(), e5.collapseAllGeometriesToFirst();
    const g2 = e5.getFirstGeometry();
    if (s4 ? this.m_topoGraph.setAndSimplifyEditShapeWinding(e5, g2, this.m_progressTracker) : this.m_topoGraph.setAndSimplifyEditShapeAlternate(e5, g2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n2(r && null === l2), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyPolygons(e5, t3, s4, false, -1, false);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const u = this.m_topoGraph.getGeometryID(g2);
    n2(u >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = u + 1, this.m_maskLookup[u] = true, e5.setFillRule(g2, 0);
    const c = this.m_bOGCOutput && s4, _ = c;
    let d2 = this.topoOperationPolygonPolygon_(g2, cr, cr, _);
    if (c) {
      this.m_topoGraph.removeShape(), this.m_topoGraph = null, e5.removeGeometry(g2), this.m_topoGraph = new tn2(), this.m_topoGraph.setAndSimplifyEditShapeAlternate(e5, d2, this.m_progressTracker);
      d2 = this.topoOperationPolygonPolygon_(d2, cr, cr, false);
    }
    null !== l2 && l2.stitchCurves(e5, d2, m3, true);
    const p3 = e5.getGeometry(d2);
    return p3.setFillRule(0), r ? p3.getImpl().setIsSimple(3, 0) : (p3.getImpl().setIsSimple(4, t3.total()), p3.getImpl().updateOGCFlagsProtected()), p3;
  }
  planarSimplify3DImpl_(e5, t3, s4, n6, r) {
    return n2(0), {};
  }
  planarSimplifyImpl_(e5, t3, s4, r, o, a2, h2, m3) {
    if (e5.isEmpty()) return e5.clone();
    const l2 = e5.getGeometryType(), g2 = new Pr(), u = g2.addGeometry(e5);
    if (Ht2(o) && l2 === a.enumPolygon && (s4 = false, g2.setFillRule(u, 0)), m3 && (e5.hasAttribute(1) && g2.replaceNaNs(1, 0), g2.removeNaNVertices()), l2 === a.enumPolygon || l2 === a.enumPolyline && s4) return this.planarSimplifyPolygons(g2, t3, s4, r, o, false);
    if (l2 === Os2.type) {
      const e6 = Ha2();
      return e6.allCrossRoadsImpassable = true, e6.ogcRule = this.m_bOGCOutput, e6.unsplitBehavior = h2, this.planarSimplifyPolylines(g2, t3, r, e6, o);
    }
    if (l2 === a.enumMultiPoint) return this.planarSimplifyMultiPoints(g2, t3, r, o);
    b("what else?");
  }
};
function Qa2(e5, t3, s4, n6) {
  if (e5.isEmpty()) return e5.createInstance();
  if (t3.isEmpty()) return n6 ? e5.createInstance() : new ee({ copy: e5 });
  const r = [new mi()], o = [0], a2 = 2 === t3.getDimension();
  return 1 !== t3.getDimension() && 2 !== t3.getDimension() && b(""), r[0] = e5.getXY(), a2 ? Wo2(t3, r, 1, s4.total(), o) : jo2(t3, r, 1, s4.total(), o), 0 === o[0] ? e5.createInstance() : e5;
}
function Ja2(e5, t3, s4, n6) {
  const r = e5.createInstance(), o = Ot(mi, 100), a2 = new Array(100), h2 = e5.getPointCount();
  let m3 = true;
  const l2 = 2 === t3.getDimension();
  1 !== t3.getDimension() && 2 !== t3.getDimension() && b("");
  for (let i2 = 0; i2 < h2; ) {
    const n7 = e5.queryCoordinates(o, o.length, i2, -1) - i2;
    l2 ? Wo2(t3, o, n7, s4.total(), a2) : jo2(t3, o, n7, s4.total(), a2);
    let h3 = 0;
    for (let t4 = 0; t4 < n7; t4++) {
      0 === a2[t4] && (m3 && (m3 = false, r.addPoints(e5, 0, i2)), h3 !== t4 && r.addPoints(e5, i2 + h3, i2 + t4), h3 = t4 + 1);
    }
    m3 || h3 === n7 || r.addPoints(e5, i2 + h3, i2 + n7), i2 += n7;
  }
  return m3 ? e5 : r;
}
function $a2(e5, t3, s4, r) {
  const i2 = e5.getGeometryType();
  if (i2 === a.enumEnvelope) {
    const t4 = new ur({ vd: e5.getDescription() });
    return e5.isEmpty() || t4.addEnvelope(e5, false), t4;
  }
  if (i2 === a.enumPoint && ("|" === r || "^" === r)) {
    const t4 = new Ee({ vd: e5.getDescription() });
    return e5.isEmpty() || t4.add(e5), t4;
  }
  if (i2 === a.enumLine) {
    const t4 = new Os2({ vd: e5.getDescription() });
    return e5.isEmpty() || t4.addSegment(e5, true), t4;
  }
  if (i2 === a.enumMultiPoint && "-" === r && t3.getGeometryType() === a.enumPoint) {
    const t4 = new ee({ vd: e5.getDescription() });
    return e5.isEmpty() || e5.getPointByVal(0, t4), t4;
  }
  if (i2 === a.enumMultiPoint && "&" === r && t3.getGeometryType() === a.enumPoint) {
    const t4 = new ee({ vd: e5.getDescription() });
    return e5.isEmpty() || e5.getPointByVal(0, t4), t4;
  }
  return e5;
}
function eh2(e5) {
  const s4 = e5.getGeometryType();
  if (s4 === a.enumEnvelope) {
    const t3 = new ur({ vd: e5.getDescription() });
    return e5.isEmpty() || t3.addEnvelope(e5, false), t3;
  }
  if (s4 === a.enumPoint) {
    const t3 = new Ee({ vd: e5.getDescription() });
    return e5.isEmpty() || t3.add(e5), t3;
  }
  if (Da2(s4)) {
    const t3 = new Os2({ vd: e5.getDescription() });
    return e5.isEmpty() || t3.addSegment(e5, true), t3;
  }
  return s4 !== a.enumMultiPoint && s4 !== a.enumPolyline && s4 !== a.enumPolygon && P("Unexpected geometry type"), e5;
}
function th2(e5, t3, s4, n6) {
  const r = s4 === cr ? e5.getClusterHalfEdge(t3) : s4;
  let i2 = r;
  n2(e5.getHalfEdgeOrigin(r) === t3);
  do {
    n6(i2), i2 = e5.getHalfEdgeNext(e5.getHalfEdgeTwin(i2));
  } while (i2 !== r);
}
var sh2 = class {
  constructor(e5, t3, s4, n6, r, i2) {
    this.m_rParent = e5, this.m_rTopoGraph = e5.m_topoGraph, this.m_rShape = this.m_rTopoGraph.getShape(), this.m_IDCuttee = this.m_rTopoGraph.getGeometryID(n6), this.m_IDCutter = this.m_rTopoGraph.getGeometryID(r), this.m_IDBoth = this.m_IDCuttee | this.m_IDCutter, this.m_bConsiderTouch = t3, this.m_sideIndex = s4, this.m_cuttee = n6, this.m_cutter = r, this.m_rCutHandles = i2, this.m_cutteeBreadcrumbsIndex = this.m_rShape.createUserIndexUninitialized(), this.m_clusterParentageIndex = this.m_rShape.createUserIndexUninitialized();
    for (let o = this.m_rShape.getFirstPath(this.m_cuttee); o !== cr; o = this.m_rShape.getNextPath(o)) {
      let e6 = 0;
      const t4 = this.m_rShape.getPathSize(o);
      for (let s5 = this.m_rShape.getFirstVertex(o); e6 < t4; e6++, s5 = this.m_rShape.getNextVertex(s5)) this.m_rShape.setUserIndex(s5, this.m_clusterParentageIndex, this.m_rTopoGraph.getClusterParentage(this.m_rTopoGraph.getClusterFromVertex(s5)));
    }
  }
  Do() {
    this.cutPolylinePolyline_(), this.m_rShape.removeUserIndex(this.m_cutteeBreadcrumbsIndex), this.m_rShape.removeUserIndex(this.m_clusterParentageIndex);
  }
  setTbd(e5) {
    return 8 | e5;
  }
  classifyStandardCut(e5, t3, s4, n6) {
    const r = this.m_rShape.getPrevVertex(e5), i2 = this.m_rShape.getNextVertex(e5), o = r === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(r)), a2 = i2 === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(i2)), h2 = this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(s4)), m3 = this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(n6));
    let l2 = 1, g2 = 32, u = 32;
    if (th2(this.m_rTopoGraph, t3, m3, (e6) => {
      e6 === h2 && (l2 = 2), e6 === o && (g2 = l2), e6 === a2 && (u = l2);
    }), this.m_bConsiderTouch) 32 !== g2 && this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | g2), 32 !== u && this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex) | u);
    else {
      if (32 === g2 || 32 === u) return 1;
      if (g2 === u && !(o === h2 || o === m3 || a2 === h2 || a2 === m3)) return 1;
      this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | g2), this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex) | u);
    }
    return 0;
  }
  classifyTouchCut(e5, t3, s4, n6) {
    const r = this.m_rShape.getPrevVertex(e5), i2 = this.m_rShape.getNextVertex(e5), o = r === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(r)), a2 = i2 === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(i2)), h2 = s4 === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(s4)), m3 = n6 === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(n6));
    if (!this.m_bConsiderTouch) {
      let t4;
      return (t4 = h2 === o || m3 === o) ? this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))) : (t4 = h2 === a2 || m3 === a2) && this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), t4 ? 0 : 1;
    }
    if (o === cr) return this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))), 0;
    if (a2 === cr) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
    if (o === a2) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))), 0;
    if (m3 !== cr) {
      if (o === m3) return this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))), 0;
      if (a2 === m3) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
      let s5 = 1;
      th2(this.m_rTopoGraph, t3, m3, (t4) => {
        if (t4 === o) {
          const e6 = this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | s5;
          this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, e6), s5 = 2;
        } else if (t4 === a2) {
          const t5 = this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex) | s5;
          this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, t5), s5 = 2;
        }
      });
    } else {
      if (o === h2) return this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))), 0;
      if (a2 === h2) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
      let s5 = 2;
      th2(this.m_rTopoGraph, t3, h2, (t4) => {
        if (t4 === o) {
          const e6 = this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | s5;
          this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, e6), s5 = 1;
        } else if (t4 === a2) {
          const t5 = this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex) | s5;
          this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, t5), s5 = 1;
        }
      });
    }
    return 0;
  }
  classifyCutVertex(e5, t3) {
    let s4 = 0, n6 = 0;
    for (let r = this.m_rTopoGraph.getClusterVertexIterator(t3); r !== cr; r = this.m_rTopoGraph.incrementVertexIterator(r)) {
      const i2 = this.m_rTopoGraph.getVertexFromVertexIterator(r);
      if (this.m_rShape.getGeometryFromVertex(i2) === this.m_cutter) {
        n6++;
        const r2 = this.m_rShape.getPrevVertex(i2), o = this.m_rShape.getNextVertex(i2);
        s4 += r2 === cr || o === cr ? this.classifyTouchCut(e5, t3, r2, o) : this.classifyStandardCut(e5, t3, r2, o);
      }
    }
    n6 && s4 === n6 && !this.m_bConsiderTouch && this.m_rShape.setUserIndex(e5, this.m_clusterParentageIndex, this.m_IDCuttee);
  }
  cutPolylinePolyline_() {
    this.m_rShape.getGeometryType(this.m_cuttee), this.m_rShape.getGeometryType(this.m_cutter), this.m_rParent.m_maskLookup.length = 0, this.m_rParent.m_maskLookup.length = this.m_IDBoth + 1, this.m_rParent.m_maskLookup[this.m_IDBoth] = true;
    for (let n6 = this.m_rShape.getFirstPath(this.m_cuttee); n6 !== cr; n6 = this.m_rShape.getNextPath(n6)) {
      const e6 = this.m_rShape.getPathSize(n6);
      let t4 = this.m_rShape.getFirstVertex(n6);
      for (let s5 = 0; s5 < e6; ++s5, t4 = this.m_rShape.getNextVertex(t4)) this.m_rShape.setUserIndex(t4, this.m_cutteeBreadcrumbsIndex, 0);
      t4 = this.m_rShape.getFirstVertex(n6);
      for (let s5 = 0; s5 < e6; ++s5, t4 = this.m_rShape.getNextVertex(t4)) {
        const e7 = this.m_rTopoGraph.getClusterFromVertex(t4);
        this.m_rTopoGraph.getClusterParentage(e7) === this.m_IDBoth && this.classifyCutVertex(t4, e7);
      }
    }
    const e5 = (e6, t4) => {
      let s5 = this.m_rShape.getUserIndex(e6, this.m_cutteeBreadcrumbsIndex);
      const n6 = this.m_rTopoGraph.getHalfEdgeConnector(this.m_rTopoGraph.getClusterFromVertex(e6), this.m_rTopoGraph.getClusterFromVertex(t4));
      return (this.m_rTopoGraph.getHalfEdgeParentage(n6) & this.m_IDBoth) === this.m_IDBoth && (s5 |= 4), s5;
    };
    for (let n6 = this.m_rShape.getFirstPath(this.m_cuttee); n6 !== cr; n6 = this.m_rShape.getNextPath(n6)) {
      let t4 = this.m_rShape.getFirstVertex(n6);
      const s5 = this.m_rShape.isClosedPath(n6), r2 = this.m_rShape.getPathSize(n6) + (s5 ? 1 : 0);
      let i3 = 1, o2 = 32;
      for (let n7 = this.m_rShape.getNextVertex(t4); i3 < r2; ++i3, t4 = n7, n7 = this.m_rShape.getNextVertex(n7)) {
        const s6 = e5(t4, n7);
        this.m_rShape.getUserIndex(t4, this.m_clusterParentageIndex) === this.m_IDBoth && (o2 = s6), 32 !== o2 && this.m_rShape.setUserIndex(t4, this.m_cutteeBreadcrumbsIndex, o2 | s6);
      }
      t4 = this.m_rShape.getLastVertex(n6);
      let a2 = 32;
      i3 = 1;
      for (let n7 = this.m_rShape.getPrevVertex(t4); i3 < r2; ++i3, t4 = n7, n7 = this.m_rShape.getPrevVertex(n7)) {
        const s6 = e5(n7, t4);
        this.m_rShape.getUserIndex(t4, this.m_clusterParentageIndex) === this.m_IDBoth && (a2 = s6), 32 !== a2 && this.m_rShape.setUserIndex(n7, this.m_cutteeBreadcrumbsIndex, a2 | s6);
      }
    }
    let t3 = cr, s4 = cr, r = 32;
    const i2 = this.m_rShape.hasSegmentParentage(), o = new fm();
    for (let a2 = this.m_rShape.getFirstPath(this.m_cuttee); a2 !== cr; a2 = this.m_rShape.getNextPath(a2)) {
      const e6 = this.m_rShape.isClosedPath(a2), h2 = this.m_rShape.getPathSize(a2) + (e6 ? 1 : 0);
      let m3 = 1, l2 = this.m_rShape.getFirstVertex(a2), g2 = cr, u = true;
      for (let a3 = this.m_rShape.getNextVertex(l2); m3 < h2; ++m3, a3 = this.m_rShape.getNextVertex(a3)) {
        let e7 = this.m_rShape.getUserIndex(l2, this.m_cutteeBreadcrumbsIndex);
        8 === e7 ? e7 = 3 : (e7 &= -9, 4 & e7 ? e7 = 4 : 3 & ~e7 || (e7 = 3)), e7 !== r ? (t3 !== cr && (g2 = this.m_rShape.addVertex(s4, l2), i2 && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), this.m_rCutHandles.push(t3), this.m_rShape.setGeometryUserIndex(t3, this.m_sideIndex, r)), t3 = this.m_rShape.createGeometry(a.enumPolyline), s4 = this.m_rShape.insertPath(t3, cr), r = e7, u = true) : this.m_rShape.getUserIndex(l2, this.m_clusterParentageIndex) === this.m_IDBoth && 4 !== e7 && (g2 = this.m_rShape.addVertex(s4, l2), i2 && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), s4 = this.m_rShape.insertPath(t3, cr), u = true), g2 = this.m_rShape.addVertex(s4, l2);
        const h3 = this.m_rTopoGraph.getClusterFromVertex(l2);
        !u && i2 && this.m_rTopoGraph.isBreakNode(h3) && this.m_rShape.setSegmentParentageBreakVertex(g2, true);
        const m4 = this.m_rTopoGraph.getHalfEdgeFromVertex(l2);
        if (i2) {
          const e8 = this.m_rTopoGraph.getSegmentParentage(m4);
          this.m_rShape.setSegmentParentageAndBreak(g2, e8, u || this.m_rTopoGraph.isBreakNode(h3));
        }
        this.m_rTopoGraph.isHalfEdgeCurve(m4) && (this.m_rTopoGraph.querySegmentXY(m4, o), this.m_rShape.setSegmentToIndex(this.m_rShape.getVertexIndex(g2), o.get().clone())), l2 = a3, u = false;
      }
      g2 = this.m_rShape.addVertex(s4, l2), i2 && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), this.m_rCutHandles.push(t3), this.m_rShape.setGeometryUserIndex(t3, this.m_sideIndex, r), t3 = cr, s4 = cr, r = 32;
    }
  }
};
function nh2(e5, t3, s4) {
  return new Ka2(s4).linesToPolygonsImpl(e5, t3);
}
function rh2(t3, s4, o, a2, h2) {
  if (a2 && (a2.m_reason = 0, a2.m_vertexIndex1 = -1, a2.m_vertexIndex2 = -1), t3.isEmpty()) return 5;
  const m3 = t3.getGeometryType();
  if (m3 === a.enumPoint) return mh2(t3, a2);
  const l2 = Bt2(s4, t3, false).total();
  if (m3 === a.enumEnvelope) {
    const s5 = t3, n6 = new n4();
    return s5.queryEnvelope(n6), n6.isDegenerate(l2) ? (a2 && (a2.m_reason = 4, a2.m_vertexIndex1 = -1, a2.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(m3)) {
    const e5 = t3, n6 = new Os2({ vd: e5.getDescription() });
    return n6.addSegment(e5, true), oh2(n6, s4, o, a2, h2);
  }
  const g2 = [0], u = t3.getImpl().getIsSimple(l2, g2);
  let c = o ? -1 : u;
  if (Ot2(c) || 0 === c) return c;
  const _ = new Ph2(t3, s4, c, h2, false);
  m3 === a.enumMultiPoint || m3 === a.enumPolyline || m3 === a.enumPolygon ? c = _.isSimplePlanarImpl() : b("");
  return t3.getImpl().setIsSimple(c, l2), a2 && a2.assign(_.m_nonSimpleResult), c;
}
function ih2(t3, s4, o, a2, h2) {
  if (a2 && (a2.m_reason = 0, a2.m_vertexIndex1 = -1, a2.m_vertexIndex2 = -1), t3.isEmpty()) return 5;
  const m3 = t3.getGeometryType();
  if (m3 === a.enumPoint) return mh2(t3, a2);
  const l2 = Bt2(s4, t3, false).total();
  if (m3 === a.enumEnvelope) {
    const s5 = t3, n6 = new n4();
    return s5.queryEnvelope(n6), n6.isDegenerate(l2) ? (a2 && (a2.m_reason = 4, a2.m_vertexIndex1 = -1, a2.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(m3)) {
    const e5 = t3, n6 = new Os2({ vd: e5.getDescription() });
    return n6.addSegment(e5, true), ih2(n6, s4, o, a2, h2);
  }
  I(m3), y(m3) || z("OGC simplify is not implemented for this geometry type");
  const g2 = [0], c = t3.getImpl().getIsSimple(l2, g2);
  let _ = o ? -1 : c;
  if (5 === _ || 0 === _) return _;
  const p3 = new Ph2(t3, s4, _, h2, true);
  m3 === a.enumMultiPoint || m3 === a.enumPolyline || m3 === a.enumPolygon ? (_ = p3.isSimplePlanarImpl(), Ot2(_) && (_ = 5)) : b("");
  return t3.getImpl().setIsSimple(_, l2), a2 && a2.assign(p3.m_nonSimpleResult), _;
}
function oh2(t3, s4, o, a2, h2) {
  if (a2 && (a2.m_reason = 0, a2.m_vertexIndex1 = -1, a2.m_vertexIndex2 = -1), t3.isEmpty()) return 5;
  const m3 = t3.getGeometryType();
  if (m3 === a.enumPoint) return mh2(t3, a2);
  const l2 = Bt2(s4, t3, false).total();
  if (m3 === a.enumEnvelope) {
    const s5 = t3, n6 = n4.constructEmpty();
    return s5.queryEnvelope(n6), n6.isDegenerate(l2) ? (a2 && (a2.m_reason = 4, a2.m_vertexIndex1 = -1, a2.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(m3)) {
    const e5 = t3, n6 = new Os2({ vd: e5.getDescription() });
    return n6.addSegment(e5, true), oh2(n6, s4, o, a2, h2);
  }
  const g2 = [0], u = t3.getImpl().getIsSimple(l2, g2);
  let c = o ? -1 : u;
  if (-1 !== c) return c;
  const _ = new Ph2(t3, s4, c, h2, false);
  return m3 === a.enumMultiPoint ? c = _.multipointIsSimpleAsFeature() : m3 === a.enumPolyline ? c = _.polylineIsSimpleAsFeature() : m3 === a.enumPolygon ? c = _.polygonIsSimpleAsFeature() : b(""), t3.getImpl().setIsSimple(c, l2), a2 && a2.assign(_.m_nonSimpleResult), c;
}
function ah2(t3, s4, o, a2) {
  if (t3.isEmpty()) return t3;
  const h2 = t3.getGeometryType();
  if (h2 === a.enumPoint) {
    const e5 = new e();
    if (mh2(t3, e5), 3 === e5.m_reason) {
      const e6 = t3.clone();
      return e6.replaceNaNs(1, 0), e6;
    }
    return 2 === e5.m_reason ? t3.createInstance() : t3;
  }
  if (h2 === a.enumEnvelope) {
    const n6 = Bt2(s4, t3, true).total(), r = t3, i2 = n4.constructEmpty();
    return r.queryEnvelope(i2), i2.isDegenerate(n6) ? r.createInstance() : t3;
  }
  if (f(h2)) {
    const e5 = t3, n6 = new Os2({ vd: e5.getDescription() });
    return n6.addSegment(e5, true), ah2(n6, s4, o, a2);
  }
  I(h2);
  const m3 = Bt2(s4, t3, false).total(), l2 = [0], g2 = t3.getImpl().getIsSimple(m3, l2), u = o ? -1 : g2;
  if (Ot2(u)) {
    if (h2 === a.enumPolygon && 0 !== t3.getFillRule()) {
      const e5 = t3.clone();
      return e5.setFillRule(0), e5;
    }
    return t3;
  }
  if ((h2 === a.enumMultiPoint || h2 === a.enumPolyline) && u >= 1) return t3;
  const c = new Ph2(t3, s4, u, a2, false);
  let _;
  return h2 === a.enumMultiPoint ? _ = c.multipointSimplifyAsFeature() : h2 === a.enumPolyline ? _ = c.polylineSimplifyAsFeature() : h2 === a.enumPolygon ? _ = c.polygonSimplifyAsFeature() : b(""), _;
}
function hh2(t3, s4, i2, o) {
  if (t3.isEmpty()) return t3;
  const a2 = t3.getGeometryType();
  if (a2 === a.enumPoint) {
    const e5 = new e();
    if (mh2(t3, e5), 3 === e5.m_reason) {
      const e6 = t3.clone();
      return e6.replaceNaNs(1, 0), e6;
    }
    return 2 === e5.m_reason ? t3.createInstance() : t3;
  }
  if (a2 === a.enumEnvelope) {
    const n6 = t3, r = new n4();
    n6.queryEnvelope(r);
    const i3 = Bt2(s4, t3, true).total();
    return r.isDegenerate(i3) ? n6.createInstance() : t3;
  }
  if (f(a2)) {
    const e5 = t3, n6 = new Os2({ vd: e5.getDescription() });
    return n6.addSegment(e5, true), hh2(n6, s4, i2, o);
  }
  I(a2), y(a2) || z("OGC simplify is not implemented for this geometry type");
  const h2 = Bt2(s4, t3, false).total(), m3 = [0], l2 = t3.getImpl().getIsSimple(h2, m3), g2 = i2 ? -1 : l2;
  if (5 === g2) {
    if (a2 === a.enumPolygon && 0 !== t3.getFillRule()) {
      const e5 = t3.clone();
      return e5.setFillRule(0), e5;
    }
    return t3;
  }
  return Aa2(t3, Bt2(s4, t3, true), false, g2, o, 0, true);
}
function mh2(e5, t3) {
  const s4 = e5.getX(), n6 = e5.getY();
  if (!Number.isFinite(s4) || !Number.isFinite(n6)) return t3 && (t3.m_reason = 2, t3.m_vertexIndex1 = -1, t3.m_vertexIndex2 = -1), 0;
  if (e5.hasAttribute(1)) {
    const s5 = e5.getZ();
    if (!Number.isFinite(s5)) return t3 && (t3.m_reason = Number.isNaN(s5) ? 3 : 2, t3.m_vertexIndex1 = -1, t3.m_vertexIndex2 = -1), 0;
  }
  return 5;
}
var lh2 = class {
  constructor() {
    this.m_segment = null, this.m_vertexIndex = -1, this.m_pathIndex = -1, this.m_flags = 0;
  }
  setReversed(e5) {
    this.m_flags &= -2, this.m_flags = this.m_flags | (e5 ? 1 : 0);
  }
  getReversed() {
    return !!(1 & this.m_flags);
  }
  getRightSide() {
    return this.getReversed() ? 0 : 1;
  }
};
function gh2() {
  return { x: -1, y: -1, ipath: -1, ivertex: -1, ipolygon: -1 };
}
function uh2(e5, t3, s4, n6, r) {
  return { x: e5, y: t3, ipath: s4, ivertex: n6, ipolygon: r };
}
function ch2(e5, t3) {
  return e5.x === t3.x && e5.y === t3.y && e5.ipath === t3.ipath && e5.ivertex === t3.ivertex && e5.ipolygon === t3.ipolygon;
}
function _h2(e5, t3) {
  e5.x = t3.x, e5.y = t3.y, e5.ipath = t3.ipath, e5.ivertex = t3.ivertex, e5.ipolygon = t3.ipolygon;
}
function dh2() {
  return { x: -1, y: -1, ipath: -1, ivertex: -1, bBoundary: false, bEndPoint: false };
}
function ph2(e5, t3, s4, n6, r, i2) {
  return { x: e5, y: t3, ipath: s4, ivertex: n6, bBoundary: r, bEndPoint: i2 };
}
function fh2(e5, t3) {
  e5.x = t3.x, e5.y = t3.y, e5.ipath = t3.ipath, e5.ivertex = t3.ivertex, e5.bBoundary = t3.bBoundary, e5.bEndPoint = t3.bEndPoint;
}
var xh2 = class extends dt {
  constructor(e5) {
    super(), this.m_helper = e5;
  }
  compare(e5, t3, s4) {
    const n6 = e5.getElement(s4), r = this.m_helper.m_xy.read(2 * t3) - this.m_helper.m_xy.read(2 * n6);
    return r < 0 ? -1 : r > 0 ? 1 : 0;
  }
};
var yh2 = class extends dt {
  constructor(e5) {
    super(), this.m_helper = e5;
  }
  compare(e5, t3, s4) {
    const n6 = e5.getElement(s4), r = this.m_helper.m_edges[t3], i2 = this.m_helper.m_edges[n6], o = r.getReversed(), a2 = i2.getReversed();
    let h2 = r.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0), m3 = i2.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    if (h2 === m3) {
      const e6 = o ? r.m_segment.getStartY() : r.m_segment.getEndY(), t4 = a2 ? i2.m_segment.getStartY() : i2.m_segment.getEndY(), s5 = Math.min(e6, t4);
      let n7 = 0.5 * (s5 - this.m_helper.m_yScanline) + this.m_helper.m_yScanline;
      n7 === this.m_helper.m_yScanline && (n7 = s5), h2 = r.m_segment.intersectionOfYMonotonicWithAxisX(n7, 0), m3 = i2.m_segment.intersectionOfYMonotonicWithAxisX(n7, 0);
    }
    return h2 < m3 ? -1 : h2 > m3 ? 1 : 0;
  }
};
var Ph2 = class _Ph {
  constructor(e5, t3, s4, n6, r) {
    this.m_multiVertexGeom = null, this.m_edges = [], this.m_freeEdges = [], this.m_lineEdgesRecycle = [], this.m_newEdges = [], this.m_recycledSegIter = null, this.m_crossOverHelperList = new pt(), this.m_progressTracker = null, this.m_progressCounter = 0, this.m_AET = new ct2(), this.m_xyToNode1 = null, this.m_xyToNode2 = null, this.m_pathOrientations = null, this.m_pathParentage = null, this.m_xy = null, this.m_pairs = [], this.m_pairIndices = null, this.m_pathsForOGCTests = [], this.m_curveStitcher = null, this.m_editShape = null, this.m_multiPathStitcher = null, this.m_nonSimpleResult = new e(), this.m_progressCounter = 0, this.m_progressTracker = n6, this.m_geometry = e5, this.m_knownSimpleResult = s4, this.m_sr = t3;
    const i2 = Bt2(t3, e5, false);
    this.m_toleranceIsSimple = i2, this.m_toleranceIsSimpleClustering = Ft2(i2), this.m_toleranceIsSimpleCracking = Pt2(i2), this.m_toleranceSimplify = Bt2(t3, e5, true), this.m_description = this.m_geometry.getDescription(), this.m_attributeCount = this.m_description.getAttributeCount(), this.m_bOGCRestrictions = r, this.m_bPlanarSimplify = this.m_bOGCRestrictions, this.m_unknownOrientationPathCount = -1, this.m_yScanline = 0, this.m_progressCounter = 0;
  }
  isSimplePlanarImpl() {
    if (this.m_bPlanarSimplify = true, !this.checkStructure()) return 0;
    const e5 = this.m_geometry.getGeometryType();
    return h(e5) && !this.checkDegenerateSegments(false) ? 0 : this._CheckClustering() ? h(e5) ? this._CheckCracking() ? this.m_geometry.getGeometryType() === a.enumPolyline ? this.checkSelfIntersectionsPolylinePlanar() ? 4 : 0 : this._CheckSelfIntersections() ? this._CheckValidRingOrientation() : 0 : 0 : 5 : 0;
  }
  isSimplePlanarImpl3D() {
    return n2(0), 7;
  }
  generateSortedPairs(e5) {
    let t3 = null;
    h(e5.getGeometryType()) && (t3 = e5);
    const s4 = (this.m_bPlanarSimplify || this.m_bOGCRestrictions) && null !== t3, n6 = e5.getPointCount();
    this.m_xy = e5.getAttributeStreamRef(0), this.m_pairs.length = 0, this.m_pairIndices = new st2(0), s4 && (this.m_pathsForOGCTests.length = 0);
    let r = 0;
    for (let o = 0; o < n6; o++) if (this.m_pairs.push(2 * o), this.m_pairs.push(2 * o + 1), this.m_pairIndices.add(2 * o), this.m_pairIndices.add(2 * o + 1), s4) {
      for (; o >= t3.getPathEnd(r); ) r++;
      this.m_pathsForOGCTests.push(r);
    }
    const i2 = new ot(), a2 = { parent: this, workPt: new mi(), userSort(e6, t4, n7) {
      n7.sort(e6, t4, (e7, t5) => this.parent.compareVerticesForPlanarClustering(e7, t5, s4));
    }, getValue(e6) {
      const t4 = this.parent.m_pairs[e6], s5 = t4 >> 1;
      this.parent.m_xy.queryPoint2D(2 * s5, this.workPt);
      return this.workPt.y + (1 & t4 ? this.parent.m_toleranceIsSimpleClustering : -this.parent.m_toleranceIsSimpleClustering);
    } };
    i2.sort(this.m_pairIndices, 0, 2 * n6, a2);
  }
  _TestToleranceDistancePlanar(e5, t3) {
    const s4 = this.m_xy.read(2 * e5), n6 = this.m_xy.read(2 * e5 + 1), r = this.m_xy.read(2 * t3), i2 = this.m_xy.read(2 * t3 + 1);
    if (!!ln2(s4, n6, r, i2, this.m_toleranceIsSimpleClustering * this.m_toleranceIsSimpleClustering)) {
      if (0 === this.m_geometry.getDimension()) return false;
      return s4 === r && n6 === i2;
    }
    return true;
  }
  checkStructure() {
    const e5 = this.m_geometry.getGeometryType();
    if (h(e5)) {
      const e6 = this.m_geometry.getImpl(), t3 = this.m_geometry.getGeometryType() === a.enumPolygon ? 3 : 2;
      for (let s4 = 0, n6 = e6.getPathCount(); s4 < n6; s4++) if (e6.getPathSize(s4) < t3) {
        if (e6.hasNonLinearSegments() && e6.hasNonLinearSegmentsPath(s4) && e6.getPathSize(s4) > 0) continue;
        return this.m_nonSimpleResult = new e(1, s4, 0), false;
      }
    }
    if (y(e5)) {
      const e6 = this.m_geometry.getImpl(), t3 = e6.getAttributeStreamRef(0);
      for (let s4 = 0, n6 = e6.getPointCount(); s4 < n6; s4++) {
        if (!t3.readPoint2D(2 * s4).isFinite()) return this.m_nonSimpleResult = new e(2, s4, 0), false;
      }
      if (this.m_geometry.hasAttribute(1)) {
        const t4 = e6.getAttributeStreamRef(1);
        for (let s4 = 0, n6 = e6.getPointCount(); s4 < n6; s4++) {
          const e7 = t4.read(s4);
          if (!Number.isFinite(e7)) return Number.isNaN(e7) ? this.m_nonSimpleResult = new e(3, s4, 0) : this.m_nonSimpleResult = new e(2, s4, 0), false;
        }
      }
    }
    return true;
  }
  checkDegenerateSegments(e5) {
    const t3 = this.m_geometry.getImpl(), s4 = t3.querySegmentIterator(), n6 = t3.hasAttribute(1), r = n6 ? wt2(this.m_sr, t3, false).total() : 0, i2 = t3.hasNonLinearSegments(), o = this.m_toleranceIsSimple.total();
    for (; s4.nextPath(); ) for (; s4.hasNextSegment(); ) {
      const t4 = s4.nextSegment();
      let a2 = t4.calculateLowerLength2D();
      if (!(a2 > o) && !(i2 && t4.isCurve() && (a2 = t4.calculateLength2D(), a2 > o))) {
        if (e5 && n6) {
          const e6 = t4.getStartAttributeAsDbl(1, 0), s5 = t4.getEndAttributeAsDbl(1, 0);
          if (Math.abs(s5 - e6) > r) continue;
        }
        return this.m_nonSimpleResult = new e(4, s4.getStartPointIndex(), -1), false;
      }
    }
    return true;
  }
  checkDegenerateSegments3D() {
    return n2(0), false;
  }
  _CheckClustering() {
    const e5 = this.m_geometry.getImpl();
    this.generateSortedPairs(e5);
    const t3 = e5.getPointCount();
    this.m_AET.clear(), this.m_AET.setComparator(new xh2(this)), this.m_AET.setCapacity(t3);
    for (let s4 = 0, n6 = 2 * t3; s4 < n6; s4++) {
      this.progress_();
      const e6 = this.m_pairIndices.read(s4), t4 = this.m_pairs[e6], n7 = t4 >> 1;
      if (1 & t4) {
        const e7 = this.m_AET.search(n7), t5 = this.m_AET.getPrev(e7), s5 = this.m_AET.getNext(e7);
        if (this.m_AET.deleteNode(e7), t5 !== ct2.st_nullNode() && s5 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(t5), this.m_AET.getElement(s5))) return this.m_nonSimpleResult = new e(5, this.m_AET.getElement(t5), this.m_AET.getElement(s5)), false;
      } else {
        const e7 = this.m_AET.addElement(n7), t5 = this.m_AET.getPrev(e7);
        if (t5 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(t5), n7)) return this.m_nonSimpleResult = new e(5, n7, this.m_AET.getElement(t5)), false;
        const s5 = this.m_AET.getNext(e7);
        if (s5 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(s5), n7)) return this.m_nonSimpleResult = new e(5, n7, this.m_AET.getElement(s5)), false;
      }
    }
    return true;
  }
  _CheckCracking() {
    const e5 = this.m_geometry.getImpl(), t3 = e5.getPointCount();
    return !e5.hasNonLinearSegments() && t3 < 10 ? this._CheckCrackingBrute() : this._CheckCrackingPlanesweep();
  }
  _CheckCrackingPlanesweep() {
    if (this.m_editShape = new Pr(), this.m_editShape.addGeometry(this.m_geometry), this.m_editShape.hasCurves()) {
      this.m_curveStitcher = new fa2();
      const t4 = n4.constructEmpty();
      this.m_geometry.queryEnvelope(t4);
      const s4 = _a2(this.m_toleranceSimplify.total(), t4), n6 = new e();
      if (la2(this.m_editShape, s4, this.m_toleranceSimplify.total(), 12e3, n6, this.m_curveStitcher, null, this.m_progressTracker), 0 !== n6.m_reason) return this.m_editShape = null, this.m_nonSimpleResult.assign(n6), false;
    }
    const t3 = new e();
    return Mn2(false, this.m_editShape, this.m_toleranceIsSimpleCracking, t3, this.m_progressTracker) ? (null != this.m_curveStitcher ? (t3.m_vertexIndex1 = this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape, t3.m_vertexIndex1), t3.m_vertexIndex2 = this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape, t3.m_vertexIndex2), this.m_curveStitcher = null) : (t3.m_vertexIndex1 = this.m_editShape.getVertexIndex(t3.m_vertexIndex1), t3.m_vertexIndex2 = this.m_editShape.getVertexIndex(t3.m_vertexIndex2)), this.m_editShape = null, this.m_nonSimpleResult.assign(t3), false) : (null == this.m_curveStitcher && (this.m_editShape = null), true);
  }
  _CheckCrackingBrute() {
    const e5 = this.m_geometry.getImpl(), t3 = e5.querySegmentIterator(), s4 = e5.querySegmentIterator();
    for (; t3.nextPath(); ) for (; t3.hasNextSegment(); ) {
      const e6 = t3.nextSegment();
      if (!t3.isLastSegmentInPath() || !t3.isLastPath()) {
        s4.resetTo(t3);
        do {
          for (; s4.hasNextSegment(); ) {
            const n6 = s4.nextSegment(), r = rm(true, e6, n6, this.m_toleranceIsSimpleCracking, true);
            if (r) {
              const e7 = 2 === r ? 7 : 6;
              return this.m_nonSimpleResult = new e(e7, t3.getStartPointIndex(), s4.getStartPointIndex()), false;
            }
          }
        } while (s4.nextPath());
      }
    }
    return true;
  }
  _CheckSelfIntersections() {
    let e5 = this.m_geometry.getImpl();
    null !== this.m_curveStitcher && (this.m_multiPathStitcher = this.m_editShape.getGeometry(this.m_editShape.getFirstGeometry()), e5 = this.m_multiPathStitcher.getImpl(), this.generateSortedPairs(e5)), this.m_edges.length = 0, this.m_lineEdgesRecycle.length = 0, this.m_recycledSegIter = e5.querySegmentIterator(), this.m_recycledSegIter.setCirculator(true);
    const t3 = [], s4 = e5.getPointCount();
    let n6 = Number.NaN, r = 0;
    for (let i2 = 0, o = 2 * s4; i2 < o; i2++) {
      this.progress_();
      const e6 = this.m_pairIndices.read(i2), s5 = this.m_pairs[e6];
      if (1 & s5) continue;
      const o2 = s5 >> 1, a2 = this.m_xy.read(2 * o2), h2 = this.m_xy.read(2 * o2 + 1);
      if (t3.length && (a2 !== n6 || h2 !== r)) {
        if (!this.processBunchForSelfIntersectionTest(t3)) return false;
        t3.length = 0;
      }
      t3.push(o2), n6 = a2, r = h2;
    }
    return !!this.processBunchForSelfIntersectionTest(t3);
  }
  checkSelfIntersectionsPolylinePlanar() {
    const e5 = this.m_geometry.getImpl(), t3 = [];
    for (let o = 0, a2 = e5.getPathCount(); o < a2; o++) t3.push(e5.isClosedPathInXYPlane(o));
    const s4 = dh2();
    let n6, r, i2;
    {
      const o = this.m_pairIndices.read(0), a2 = this.m_pairs[o] >> 1, h2 = this.m_xy.readPoint2D(2 * a2), m3 = this.m_pathsForOGCTests[a2];
      n6 = t3[m3], r = e5.getPathStart(m3), i2 = e5.getPathEnd(m3) - 1, s4.bEndPoint = a2 === r || a2 === i2, this.m_bOGCRestrictions ? s4.bBoundary = !n6 && s4.bEndPoint : s4.bBoundary = s4.bEndPoint, s4.ipath = m3, s4.x = h2.x, s4.y = h2.y, s4.ivertex = a2;
    }
    for (let o = 1, a2 = this.m_pairIndices.size(); o < a2; o++) {
      const a3 = this.m_pairIndices.read(o), h2 = this.m_pairs[a3];
      if (1 & h2) continue;
      const m3 = h2 >> 1, l2 = this.m_xy.readPoint2D(2 * m3), g2 = this.m_pathsForOGCTests[m3];
      let u;
      g2 !== s4.ipath && (n6 = t3[g2], r = e5.getPathStart(g2), i2 = e5.getPathEnd(g2) - 1);
      const c = m3 === r || m3 === i2;
      u = this.m_bOGCRestrictions ? !n6 && c : c;
      const _ = ph2(l2.x, l2.y, g2, m3, u, c);
      if (_.x === s4.x && _.y === s4.y) {
        if (this.m_bOGCRestrictions) {
          if (!(_.bBoundary && s4.bBoundary || _.ipath === s4.ipath && _.bEndPoint && s4.bEndPoint)) return this.m_nonSimpleResult = new e(10, _.ivertex, s4.ivertex), false;
        } else if (!_.bEndPoint || !s4.bEndPoint) return this.m_nonSimpleResult = new e(7, _.ivertex, s4.ivertex), false;
      }
      fh2(s4, _);
    }
    return true;
  }
  checkSelfIntersectionsPolylinePlanar3D(e5) {
    return n2(0), false;
  }
  checkSelfIntersectionsPolygonsOGC() {
    const e5 = this.m_geometry.getImpl(), t3 = [];
    let s4 = -1, n6 = false;
    for (let l2 = 0, g2 = e5.getPathCount(); l2 < g2; l2++) e5.isExteriorRingOGC(l2) && (n6 = false, s4++, l2 < g2 - 1 && (e5.isExteriorRingOGC(l2 + 1) || (n6 = true))), t3.push(n6 ? s4 : -1);
    const r = gh2();
    {
      const e6 = this.m_pairIndices.read(0), s5 = this.m_pairs[e6] >> 1, n7 = this.m_xy.readPoint2D(2 * s5), i3 = this.m_pathsForOGCTests[s5];
      r.ipath = i3, r.x = n7.x, r.y = n7.y, r.ivertex = s5, r.ipolygon = t3[i3];
    }
    const i2 = [];
    for (let l2 = 1, g2 = this.m_pairIndices.size(); l2 < g2; l2++) {
      const e6 = this.m_pairIndices.read(l2), s5 = this.m_pairs[e6];
      if (1 & s5) continue;
      const n7 = s5 >> 1, o2 = this.m_xy.readPoint2D(2 * n7), a3 = this.m_pathsForOGCTests[n7], h3 = uh2(o2.x, o2.y, a3, n7, t3[a3]);
      if (h3.x === r.x && h3.y === r.y) {
        if (h3.ipath === r.ipath) return this.m_nonSimpleResult = new e(11, h3.ivertex, r.ivertex), false;
        t3[h3.ipath] >= 0 && t3[h3.ipath] === t3[r.ipath] && (0 !== i2.length && ch2(i2.at(-1), r) || i2.push({ ...r }), i2.push(h3));
      }
      _h2(r, h3);
    }
    if (0 === i2.length) return true;
    const o = new pt(true);
    t3.fill(-1);
    let a2 = -1;
    const h2 = new mi();
    for (let l2 = 0, g2 = i2.length; l2 < g2; l2++) {
      const e6 = i2[l2];
      e6.x === h2.x && e6.y === h2.y || (a2 = o.createList(0), h2.x = e6.x, h2.y = e6.y);
      let s5 = t3[e6.ipath];
      -1 === s5 && (s5 = o.createList(2), t3[e6.ipath] = s5), o.addElement(s5, a2), o.addElement(a2, s5);
    }
    const m3 = [];
    for (let l2 = o.getFirstList(); -1 !== l2; l2 = o.getNextList(l2)) {
      const e6 = o.getListData(l2);
      if (1 & e6 || !(2 & e6)) continue;
      let s5 = -1;
      for (m3.push(l2), m3.push(-1); m3.length; ) {
        const e7 = m3.at(-1);
        m3.pop();
        const t4 = m3.at(-1);
        m3.pop();
        const n7 = o.getListData(t4);
        if (1 & n7) {
          s5 = 2 & n7 ? t4 : e7;
          break;
        }
        o.setListData(t4, 1 | n7);
        for (let s6 = o.getFirst(t4); -1 !== s6; s6 = o.getNext(s6)) {
          const n8 = o.getData(s6);
          n8 !== e7 && (m3.push(n8), m3.push(t4));
        }
      }
      if (-1 !== s5) {
        const e7 = t3.indexOf(s5);
        return this.m_nonSimpleResult = new e(12, e7, -1), false;
      }
    }
    return true;
  }
  _CheckValidRingOrientation() {
    const e5 = null !== this.m_multiPathStitcher ? this.m_multiPathStitcher.getImpl() : this.m_geometry.getImpl();
    if (e5.calculateArea2D() <= 0) return this.m_nonSimpleResult = new e(8, 1 === e5.getPathCount() ? 1 : -1, -1), 0;
    if (1 === e5.getPathCount()) return this.m_bOGCRestrictions && !this.checkSelfIntersectionsPolygonsOGC() ? 0 : 4;
    this.m_pathOrientations = new et(e5.getPathCount(), 0), this.m_pathParentage = new st2(e5.getPathCount(), -1);
    let t3 = -1, s4 = 0;
    for (let i2 = 0, o = e5.getPathCount(); i2 < o; i2++) {
      const n7 = e5.calculateRingArea2D(i2);
      if (this.m_pathOrientations.write(i2, n7 < 0 ? 0 : 8), n7 > 0) t3 = i2, s4 = n7;
      else {
        if (0 === n7) return this.m_nonSimpleResult = new e(8, i2, -1), 0;
        if ((t3 < 0 || s4 < Math.abs(n7)) && (this.m_nonSimpleResult = new e(9, i2, -1), this.m_bOGCRestrictions)) return 0;
        this.m_pathParentage.write(i2, t3);
      }
    }
    this.m_unknownOrientationPathCount = e5.getPathCount(), this.m_newEdges.length = 0;
    const n6 = e5.getPointCount();
    this.m_yScanline = Number.NaN;
    const r = [];
    this.m_xyToNode1 = new st2(n6, ct2.st_nullNode()), this.m_xyToNode2 = new st2(n6, ct2.st_nullNode()), this.m_freeEdges.length = 0, this.m_AET.clear(), this.m_AET.setComparator(new yh2(this));
    for (let i2 = 0, o = 2 * n6; this.m_unknownOrientationPathCount > 0 && i2 < o; i2++) {
      const e6 = this.m_pairIndices.read(i2), t4 = this.m_pairs[e6];
      if (1 & t4) continue;
      const s5 = t4 >> 1, n7 = this.m_xy.read(2 * s5 + 1);
      if (n7 !== this.m_yScanline && r.length) {
        if (!this.processBunchForRingOrientationTest(r)) return 0;
        r.length = 0;
      }
      r.push(s5), this.m_yScanline = n7;
    }
    return this.m_unknownOrientationPathCount > 0 && !this.processBunchForRingOrientationTest(r) ? 0 : this.m_bOGCRestrictions ? 0 !== this.m_nonSimpleResult.m_reason ? 0 : this.checkSelfIntersectionsPolygonsOGC() ? 5 : 0 : 0 === this.m_nonSimpleResult.m_reason ? 4 : 3;
  }
  processBunchForSelfIntersectionTest(e5) {
    if (1 === e5.length) return true;
    for (let o = 0, a2 = e5.length; o < a2; o++) {
      const t4 = e5[o];
      this.m_recycledSegIter.resetToVertex(t4, -1);
      const s5 = this.m_recycledSegIter.previousSegment();
      this.m_edges.push(this.createEdge(s5, t4, this.m_recycledSegIter.getPathIndex(), true)), this.m_recycledSegIter.nextSegment();
      const n7 = this.m_recycledSegIter.nextSegment();
      this.m_edges.push(this.createEdge(n7, t4, this.m_recycledSegIter.getPathIndex(), false));
    }
    this.m_edges.sort((e6, t4) => this.edgeAngleCompare(e6, t4));
    let t3 = this.m_crossOverHelperList.getFirstList();
    -1 === t3 && (t3 = this.m_crossOverHelperList.createList(0)), this.m_crossOverHelperList.reserveNodes(this.m_edges.length);
    for (let o = 0, a2 = this.m_edges.length; o < a2; o++) this.m_crossOverHelperList.addElement(t3, o);
    let s4 = true, n6 = -1, r = -1;
    for (; s4; ) {
      s4 = false;
      let e6 = this.m_crossOverHelperList.getFirst(t3);
      if (-1 === e6) break;
      let i3 = this.m_crossOverHelperList.getNext(e6);
      for (; -1 !== i3; ) {
        const o = this.m_crossOverHelperList.getData(e6), a2 = this.m_crossOverHelperList.getData(i3);
        if (n6 = this.m_edges[o].m_vertexIndex, r = this.m_edges[a2].m_vertexIndex, n6 !== r) e6 = i3, i3 = this.m_crossOverHelperList.getNext(e6);
        else if (s4 = true, this.m_crossOverHelperList.deleteElement(t3, e6), e6 = this.m_crossOverHelperList.getPrev(i3), i3 = this.m_crossOverHelperList.deleteElement(t3, i3), -1 === i3 || -1 === e6) break;
      }
    }
    const i2 = this.m_crossOverHelperList.getListSize(t3);
    if (this.m_crossOverHelperList.clear(t3), i2 > 0) return this.m_nonSimpleResult = new e(7, n6, r), false;
    for (let o = 0, a2 = e5.length; o < a2; o++) this.recycleEdge(this.m_edges[o]);
    return this.m_edges.length = 0, true;
  }
  processBunchForRingOrientationTest(e5) {
    for (let t3 = 0, s4 = e5.length; t3 < s4; t3++) {
      const s5 = e5[t3];
      let n6 = this.m_xyToNode1.read(s5);
      if (n6 !== ct2.st_nullNode()) {
        const e6 = this.m_AET.getElement(n6);
        this.m_freeEdges.push(e6), this.m_AET.deleteNode(n6), this.recycleEdge(this.m_edges[e6]), this.m_edges[e6] = null, this.m_xyToNode1.write(s5, ct2.st_nullNode());
      }
      if (n6 = this.m_xyToNode2.read(s5), n6 !== ct2.st_nullNode()) {
        const e6 = this.m_AET.getElement(n6);
        this.m_freeEdges.push(e6), this.m_AET.deleteNode(n6), this.recycleEdge(this.m_edges[e6]), this.m_edges[e6] = null, this.m_xyToNode2.write(s5, ct2.st_nullNode());
      }
    }
    for (let t3 = 0, s4 = e5.length; t3 < s4; t3++) {
      const s5 = e5[t3];
      this.m_recycledSegIter.resetToVertex(s5, -1);
      const n6 = this.m_recycledSegIter.previousSegment();
      if (n6.getStartY() > n6.getEndY()) {
        const e6 = this.m_recycledSegIter.getStartPointIndex(), t4 = this.createEdge(n6, s5, this.m_recycledSegIter.getPathIndex(), true);
        let r2;
        this.m_freeEdges.length > 0 ? (r2 = this.m_freeEdges.at(-1), this.m_freeEdges.pop(), this.m_edges[r2] = t4) : (r2 = this.m_edges.length, this.m_edges.push(t4));
        const i2 = this.m_AET.addElement(r2);
        this.m_xyToNode1.read(e6) === ct2.st_nullNode() ? this.m_xyToNode1.write(e6, i2) : this.m_xyToNode2.write(e6, i2), 3 & this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex()) || this.m_newEdges.push(i2);
      }
      this.m_recycledSegIter.nextSegment();
      const r = this.m_recycledSegIter.nextSegment();
      if (r.getStartY() < r.getEndY()) {
        const e6 = this.m_recycledSegIter.getEndPointIndex(), t4 = this.createEdge(r, s5, this.m_recycledSegIter.getPathIndex(), false);
        let n7;
        this.m_freeEdges.length > 0 ? (n7 = this.m_freeEdges.at(-1), this.m_freeEdges.pop(), this.m_edges[n7] = t4) : (n7 = this.m_edges.length, this.m_edges.push(t4));
        const i2 = this.m_AET.addElement(n7);
        this.m_xyToNode1.read(e6) === ct2.st_nullNode() ? this.m_xyToNode1.write(e6, i2) : this.m_xyToNode2.write(e6, i2), 3 & this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex()) || this.m_newEdges.push(i2);
      }
    }
    for (let t3 = 0, s4 = this.m_newEdges.length; t3 < s4 && this.m_unknownOrientationPathCount > 0; t3++) {
      const e6 = this.m_newEdges[t3], s5 = this.m_AET.getElement(e6), n6 = this.m_edges[s5].m_pathIndex;
      if (!(3 & this.m_pathOrientations.read(n6))) {
        let t4 = -1, s6 = this.m_AET.getPrev(e6), n7 = e6, r = 0;
        {
          let e7 = -1, i2 = null, o = -1, a2 = 0;
          for (; s6 !== ct2.st_nullNode() && (e7 = this.m_AET.getElement(s6), i2 = this.m_edges[e7], o = i2.m_pathIndex, a2 = this.m_pathOrientations.read(o), !(3 & a2)); ) n7 = s6, s6 = this.m_AET.getPrev(s6);
          s6 === ct2.st_nullNode() ? (r = 1, s6 = n7) : (t4 = 1 == (3 & a2) ? o : this.m_pathParentage.read(o), r = i2.getRightSide() ? 0 : 1, s6 = this.m_AET.getNext(s6));
        }
        do {
          const e7 = this.m_AET.getElement(s6), i2 = this.m_edges[e7], o = i2.m_pathIndex;
          let a2 = this.m_pathOrientations.read(o);
          if (!(3 & a2)) {
            if (r !== i2.getRightSide()) return this.m_nonSimpleResult = new e(8, o, -1), false;
            const e8 = r && !i2.getReversed() ? 1 : 2;
            if (a2 = -4 & a2 | e8, this.m_pathOrientations.write(o, a2), 2 === e8 && 0 === this.m_nonSimpleResult.m_reason) {
              const e9 = this.m_pathParentage.read(o);
              if (e9 !== t4 && (this.m_nonSimpleResult = new e(9, o, e9), this.m_bOGCRestrictions)) return false;
            }
            if (this.m_unknownOrientationPathCount--, !this.m_unknownOrientationPathCount) return true;
          }
          t4 = 1 == (3 & a2) ? o : this.m_pathParentage.read(o), n7 = s6, s6 = this.m_AET.getNext(s6), r = r ? 0 : 1;
        } while (n7 !== e6);
      }
    }
    return this.m_newEdges.length = 0, true;
  }
  createEdge(e5, t3, s4, r) {
    let i2;
    return e5.getGeometryType() === a.enumLine ? i2 = this.createEdgeLine(e5) : (i2 = new lh2(), i2.m_segment = e5.clone()), i2.m_vertexIndex = t3, i2.m_pathIndex = s4, i2.m_flags = 0, i2.setReversed(r), i2;
  }
  createEdgeLine(e5) {
    let t3;
    return this.m_lineEdgesRecycle.length > 0 ? (t3 = this.m_lineEdgesRecycle.at(-1), this.m_lineEdgesRecycle.pop(), e5.copyTo(t3.m_segment)) : (t3 = new lh2(), t3.m_segment = e5.clone()), t3;
  }
  recycleEdge(e5) {
    e5.m_segment.getGeometryType() === a.enumLine && this.m_lineEdgesRecycle.push(e5);
  }
  static isShortSegment(e5, t3, s4, n6) {
    let r = e5.calculateLowerLength2D();
    if (r <= s4) {
      let i2 = true;
      if (e5.isCurve() && (r = e5.calculateLength2D(), i2 = r <= s4), i2) {
        if (t3) {
          let t4 = e5.getEndAttributeAsDbl(1, 0);
          Number.isNaN(t4) && (t4 = 0);
          let s5 = e5.getStartAttributeAsDbl(1, 0);
          return Number.isNaN(s5) && (s5 = 0), Math.abs(s5 - t4) <= n6;
        }
        return true;
      }
      return false;
    }
    return false;
  }
  static isShortSegmentPoints(e5, t3, s4, n6, r) {
    if (s4) {
      const s5 = e5.getXYZ(), i2 = t3.getXYZ();
      return Mt(s5, i2, n6, r);
    }
    {
      const s5 = e5.getXY(), r2 = t3.getXY();
      return mi.sqrDistance(s5, r2) <= n6 * n6;
    }
  }
  removeDegenerateSegmentsFromCurvedPath(e5, t3, s4, n6) {
    const r = e5.hasAttribute(1), i2 = e5.querySegmentIterator();
    i2.resetToPath(t3), n2(i2.nextPath());
    const o = this.m_toleranceSimplify.total();
    let h2 = false, m3 = true;
    const l2 = new ee(), g2 = new ee(), u = new mi();
    for (; i2.hasNextSegment(); ) {
      this.progress_();
      const e6 = i2.nextSegment();
      if (_Ph.isShortSegment(e6, r, o, s4)) if (h2) {
        if (e6.queryEnd(g2), _Ph.isShortSegmentPoints(l2, g2, r, o, s4)) continue;
        m3 && (n6.startPathPoint(l2), m3 = false), e6.queryEnd(l2), n6.lineToPoint(l2), h2 = false;
      } else u.assign(e6.getStartXY()), e6.queryStart(l2), h2 = true;
      else if (h2) if (e6.isCurve()) {
        const t4 = e6.clone();
        if (t4.setCoordsForIntersector(u, e6.getEndXY(), false), t4.setStart(l2), _Ph.isShortSegment(t4, r, o, s4)) continue;
        n6.addSegment(t4, m3), m3 = false, h2 = false;
      } else {
        if (e6.queryEnd(g2), _Ph.isShortSegmentPoints(l2, g2, r, o, s4)) continue;
        m3 && (n6.startPathPoint(l2), m3 = false), n6.lineToPoint(g2), h2 = false;
      }
      else n6.addSegment(e6, m3), m3 = false;
    }
    if (m3) return;
    if (!h2) return;
    e5.isClosedPath(t3) ? e5.getPointByVal(e5.getPathStart(t3), l2) : e5.getPointByVal(e5.getPathEnd(t3) - 1, l2);
    const c = n6.querySegmentIterator();
    c.resetToLastPath(), c.resetToLastSegment();
    const _ = n6.getDescription().getAttributeCount() > 1;
    for (n2(c.previousPath()); c.hasPreviousSegment(); ) {
      const e6 = c.previousSegment();
      if (e6.isCurve()) {
        const t4 = e6.clone();
        if (t4.setCoordsForIntersector(e6.getStartXY(), l2.getXY(), false), !_Ph.isShortSegment(t4, r, o, s4)) {
          _ && t4.setEnd(l2);
          const e7 = c.getEndPointIndex();
          for (let t5 = n6.getPointCount() - 1; t5 >= e7; t5--) n6.removePoint(t5);
          return void n6.addSegment(t4, false);
        }
      } else if (e6.queryStart(g2), !_Ph.isShortSegmentPoints(g2, l2, r, o, s4)) {
        const e7 = c.getEndPointIndex();
        for (let t4 = n6.getPointCount() - 1; t4 >= e7; t4--) n6.removePoint(t4);
        return void n6.lineToPoint(l2);
      }
    }
    n6.removePath(n6.getPathCount() - 1);
  }
  multipointIsSimpleAsFeature() {
    if (!this.checkStructure()) return 0;
    const e5 = this.m_geometry.getImpl();
    this.m_multiVertexGeom = e5;
    const t3 = e5.getPointCount(), s4 = Yt(t3, 0);
    for (let n6 = 0; n6 < t3; n6++) s4[n6] = n6;
    s4.sort((e6, t4) => this.compareVerticesMultiPoint(e6, t4));
    for (let n6 = 1; n6 < t3; n6++) if (0 === this.compareVerticesMultiPoint(s4[n6 - 1], s4[n6])) return this.m_nonSimpleResult = new e(5, s4[n6 - 1], s4[n6]), 0;
    return 1;
  }
  polylineIsSimpleAsFeature() {
    return this.checkStructure() && this.checkDegenerateSegments(true) ? 1 : 0;
  }
  polygonIsSimpleAsFeature() {
    return this.isSimplePlanarImpl();
  }
  multipointSimplifyAsFeature() {
    let e5 = this.m_geometry.getImpl();
    const t3 = _Ph.hasNanZs(e5);
    let s4, n6 = this.m_geometry;
    t3 && (s4 = this.m_geometry.clone(), e5 = s4.getImpl(), s4.replaceNaNs(1, z3.getDefaultValue(1)), n6 = s4), this.m_multiVertexGeom = e5;
    const r = e5.getPointCount(), i2 = Yt(r, 0);
    for (let g2 = 0; g2 < r; g2++) i2[g2] = g2;
    i2.sort((e6, t4) => this.compareVerticesMultiPoint(e6, t4));
    const o = new Array(r);
    o.fill(false);
    let a2 = -1;
    for (let g2 = 0; g2 < r; g2++) {
      const t4 = i2[g2];
      e5.getXY(t4).isFinite() && ((a2 < 0 || 0 !== this.compareVerticesMultiPoint(a2, t4)) && (o[t4] = true), a2 = t4);
    }
    const h2 = this.m_geometry.createInstance();
    let m3 = 0, l2 = 0;
    for (let g2 = 0; g2 < r; g2++) o[g2] ? l2 = g2 + 1 : (m3 < l2 && h2.addPoints(n6, m3, l2), m3 = g2 + 1);
    return m3 < l2 && h2.addPoints(n6, m3, l2), h2.getImpl().setIsSimple(1, this.m_toleranceSimplify.total()), h2;
  }
  polylineSimplifyAsFeature() {
    const e5 = this.m_geometry.getImpl(), t3 = e5.querySegmentIterator(), s4 = e5.querySegmentIterator(), n6 = this.m_geometry.createInstance(), r = this.m_geometry, i2 = e5.hasAttribute(1), o = i2 ? wt2(this.m_sr, e5, true).total() : 0, a2 = [], h2 = [];
    let m3 = null;
    i2 && (m3 = e5.getAttributeStreamRef(1));
    const l2 = new ee(), g2 = e5.hasNonLinearSegments(), u = this.m_toleranceSimplify.total();
    for (; t3.nextPath(); ) {
      if (s4.nextPath(), e5.getPathSize(t3.getPathIndex()) < 2) continue;
      if (g2 && e5.hasNonLinearSegmentsPath(t3.getPathIndex())) {
        this.removeDegenerateSegmentsFromCurvedPath(e5, t3.getPathIndex(), o, n6);
        continue;
      }
      s4.resetToLastSegment();
      let c = 0, _ = 0, d2 = true, p3 = true;
      for (; t3.hasNextSegment(); ) {
        this.progress_();
        const n7 = t3.nextSegment(), r2 = s4.previousSegment();
        if (t3.getStartPointIndex() > s4.getStartPointIndex()) break;
        if (d2) {
          const s5 = t3.getStartPointIndex();
          e5.getXY(s5).isNAN() || (d2 = false, a2.push(s5));
        }
        if (p3) {
          const t4 = s4.getEndPointIndex();
          e5.getXY(t4).isNAN() || (h2.push(t4), p3 = false);
        }
        if (!d2) {
          const s5 = a2.at(-1), r3 = t3.getEndPointIndex();
          if (r3 - s5 > 1) {
            const t4 = new mi();
            t4.setSub(e5.getXY(s5), e5.getXY(r3)), c = t4.length();
          } else c = n7.calculateLength2D();
          if (c > u) a2.push(r3), c = 0;
          else if (i2) {
            let e6 = m3.read(s5);
            Number.isNaN(e6) && (e6 = 0);
            let t4 = m3.read(r3);
            Number.isNaN(t4) && (t4 = 0), Math.abs(t4 - e6) > o && (a2.push(r3), c = 0);
          }
        }
        if (!p3) {
          const t4 = h2.at(-1), n8 = s4.getStartPointIndex();
          if (n8 - t4 > 1) {
            const s5 = new mi();
            s5.setSub(e5.getXY(t4), e5.getXY(n8)), _ = s5.length();
          } else _ = r2.calculateLength2D();
          if (_ > u) h2.push(n8), _ = 0;
          else if (i2) {
            let e6 = m3.read(t4);
            Number.isNaN(e6) && (e6 = 0);
            let s5 = m3.read(n8);
            Number.isNaN(s5) && (s5 = 0), Math.abs(s5 - e6) > o && (h2.push(n8), _ = 0);
          }
        }
      }
      if (a2.length > 0 && h2.length > 0 && (a2.at(-1) < h2.at(-1) ? a2.length > h2.length ? a2.pop() : h2.pop() : (a2.at(-1) === h2.at(-1) || h2.pop(), h2.pop())), h2.length + a2.length >= 2) {
        let e6 = false;
        for (let t4 = 0, s5 = a2.length; t4 < s5; t4++) r.getPointByVal(a2[t4], l2), e6 ? n6.lineToPoint(l2) : (n6.startPathPoint(l2), e6 = true);
        for (let t4 = h2.length - 1; t4 > 0; t4--) r.getPointByVal(h2[t4], l2), e6 ? n6.lineToPoint(l2) : (n6.startPathPoint(l2), e6 = true);
        r.isClosedPath(t3.getPathIndex()) ? n6.closePathWithLine() : h2.length > 0 && (r.getPointByVal(h2[0], l2), n6.lineToPoint(l2));
      }
      a2.length = 0, h2.length = 0;
    }
    return i2 && n6.replaceNaNs(1, 0), n6.getImpl().setIsSimple(1, u), n6;
  }
  polygonSimplifyAsFeature() {
    return this.simplifyPlanar();
  }
  simplifyPlanar() {
    if (1 === this.m_geometry.getFillRule() && !Ht2(this.m_knownSimpleResult)) return Ma2(this.m_geometry, this.m_toleranceSimplify, true, false, this.m_knownSimpleResult, this.m_progressTracker, 0, true);
    const t3 = new Pr();
    if (t3.addGeometry(this.m_geometry), this.m_geometry.hasAttribute(1) && t3.replaceNaNs(1, 0), t3.removeNaNVertices(), 0 !== t3.getTotalPointCount()) {
      let s5 = null, r = 0, i2 = 0;
      if (t3.hasCurves()) {
        s5 = new fa2();
        const n6 = n4.constructEmpty();
        this.m_geometry.queryEnvelope(n6);
        const o = _a2(this.m_toleranceSimplify.total(), n6);
        r = da2(this.m_toleranceSimplify.total()), i2 = pa2(o, r), aa2(t3, o, this.m_toleranceSimplify.total(), 12e3, s5, null, this.m_progressTracker);
      }
      if (!Ht2(this.m_knownSimpleResult)) {
        ya2(t3, this.m_toleranceSimplify.add(i2), this.m_progressTracker, true, false);
      }
      this.m_geometry.getGeometryType() === a.enumPolygon && er2(t3, t3.getFirstGeometry(), this.m_knownSimpleResult, false, -1, this.m_progressTracker), null !== s5 && s5.stitchCurves(t3, t3.getFirstGeometry(), r, true);
    }
    const s4 = t3.getGeometry(t3.getFirstGeometry());
    return s4.getGeometryType() === a.enumPolygon && (s4.getImpl().updateOGCFlagsProtected(), s4.setFillRule(0)), s4.getImpl().setIsSimple(4, this.m_toleranceSimplify.total()), s4;
  }
  progress_() {
  }
  static hasNanZs(e5) {
    if (e5.hasAttribute(1)) {
      const t3 = e5.getAttributeStreamRef(1);
      for (let s4 = 0, n6 = e5.getPointCount(); s4 < n6; s4++) {
        const e6 = t3.read(s4);
        if (Number.isNaN(e6)) return true;
      }
    }
    return false;
  }
  compareVerticesForPlanarClustering(e5, t3, s4) {
    if (e5 === t3) return 0;
    const n6 = this.m_pairs[e5], r = this.m_pairs[t3], i2 = n6 >> 1, o = r >> 1, a2 = this.m_xy.readPoint2D(2 * i2);
    a2.y += 1 & n6 ? this.m_toleranceIsSimpleClustering : -this.m_toleranceIsSimpleClustering;
    const h2 = this.m_xy.readPoint2D(2 * o);
    h2.y += 1 & r ? this.m_toleranceIsSimpleClustering : -this.m_toleranceIsSimpleClustering;
    const m3 = a2.compare(h2);
    if (0 === m3 && s4) {
      const e6 = this.m_pathsForOGCTests[i2] - this.m_pathsForOGCTests[o];
      return K(e6);
    }
    return m3;
  }
  compareVerticesMultiPoint(e5, t3) {
    if (e5 === t3) return 0;
    const s4 = this.m_multiVertexGeom.getXY(e5), n6 = this.m_multiVertexGeom.getXY(t3), r = !s4.isFinite(), i2 = !n6.isFinite();
    if (r || i2) return r < i2 ? -1 : r > i2 ? 1 : 0;
    if (s4.y < n6.y) return -1;
    if (s4.y > n6.y) return 1;
    if (s4.x < n6.x) return -1;
    if (s4.x > n6.x) return 1;
    for (let o = 1; o < this.m_attributeCount; o++) {
      const s5 = this.m_description.getSemantics(o), n7 = z3.getComponentCount(s5);
      for (let r2 = 0; r2 < n7; r2++) {
        const n8 = this.m_multiVertexGeom.getAttributeAsDbl(s5, e5, r2), i3 = this.m_multiVertexGeom.getAttributeAsDbl(s5, t3, r2), o2 = _s(n8, i3);
        if (0 !== o2) return o2;
      }
    }
    return 0;
  }
  edgeAngleCompare(e5, t3) {
    if (e5 === t3) return 0;
    const s4 = e5.m_segment.getTangent(e5.getReversed() ? 1 : 0);
    e5.getReversed() && s4.negateThis();
    const n6 = t3.m_segment.getTangent(t3.getReversed() ? 1 : 0);
    t3.getReversed() && n6.negateThis();
    const r = s4.getQuarter(), i2 = n6.getQuarter();
    if (i2 === r) {
      const e6 = s4.crossProduct(n6);
      return e6 < 0 ? 1 : e6 > 0 ? -1 : 0;
    }
    return r < i2 ? -1 : 1;
  }
};
var Eh2 = class {
  getOperatorType() {
    return 10103;
  }
  accelerateGeometry(e5, t3, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  supportsCurves() {
    return true;
  }
  isSimpleAsFeature(e5, t3, s4, n6, r) {
    const i2 = oh2(e5, t3, s4, n6, r);
    return Yt2(e5.getGeometryType(), i2);
  }
  isSimplePlanarDONOTUSE(e5, t3, s4, n6, r) {
    const i2 = rh2(e5, t3, s4, n6, r);
    return Ot2(i2);
  }
  executeMany(e5, t3, s4, n6) {
    return new Sh2(e5, t3, s4, n6);
  }
  execute(e5, t3, s4, n6) {
    const r = new s2([e5]), o = this.executeMany(r, t3, s4, n6).next();
    return o || b("null geometry"), o;
  }
};
var Sh2 = class extends t {
  constructor(e5, t3, s4, n6) {
    super(), this.m_progressTracker = n6, this.m_bForceSimplify = s4, this.m_index = -1, this.m_inputGeometryCursor = e5, this.m_spatialReference = t3;
  }
  next() {
    const e5 = this.m_inputGeometryCursor.next();
    return e5 ? (this.m_index = this.m_inputGeometryCursor.getGeometryID(), this.simplify(e5)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return false;
  }
  getRank() {
    return 1;
  }
  simplify(e5) {
    if (e5 || P(""), e5.getGeometryType() === a.enumGeometryCollection) {
      const t3 = cs2(e5, -1), s4 = new Eh2().executeMany(t3, this.m_spatialReference, this.m_bForceSimplify, this.m_progressTracker), n6 = e5.createInstance();
      for (let e6 = s4.next(); null != e6; e6 = s4.next()) n6.addGeometry(e6);
      return n6;
    }
    return ah2(e5, this.m_spatialReference, this.m_bForceSimplify, this.m_progressTracker);
  }
};
function Ch2(t3, s4, r) {
  const i2 = new n4();
  t3.queryEnvelope(i2);
  const o = new n4();
  s4.queryEnvelope(o);
  const a2 = new n4(o);
  if (a2.inflate(2 * r), !a2.isIntersecting(i2)) return 4;
  const h2 = t3.getGeometryType(), m3 = s4.getGeometryType();
  if (h2 === a.enumEnvelope && i2.containsEnvelope(a2)) return 1;
  if (m3 === a.enumEnvelope) {
    const t4 = new n4(i2);
    if (t4.inflate(2 * r), o.containsEnvelope(t4)) return 2;
  }
  return 0;
}
var Ih2 = class _Ih {
  constructor(e5, t3, s4, r) {
    this.m_intersectorGeom = null, this.m_sr = null, this.m_dimensionMask = -1, this.m_progressTracker = null, this.m_intersectorGeomType = a.enumUnknown, this.m_geomIntersectorEmptyGeom = null, this.m_intersectorGeom = e5, this.m_sr = t3, this.m_dimensionMask = s4, this.m_progressTracker = r, this.m_intersectorGeomType = e5.getGeometryType();
  }
  intersect(t3) {
    const s4 = this.tryFastImplementation(t3);
    if (null !== s4) return s4;
    const n6 = It2(this.m_intersectorGeom, t3), r = At(this.m_sr, n6, true).total(), i2 = n4.constructEmpty();
    this.m_intersectorGeom.queryEnvelope(i2);
    const o = n4.constructEmpty();
    t3.queryEnvelope(o), i2.inflateCoords(2 * r, 2 * r), i2.intersect(o), i2.inflateCoords(100 * r, 100 * r);
    const a2 = 0;
    let h2 = f2(this.m_intersectorGeom, i2, a2, 0, this.m_progressTracker), m3 = f2(t3, i2, a2, 0, this.m_progressTracker);
    return t3.getDimension() > this.m_intersectorGeom.getDimension() && (h2 = Pt(m3, m3 = h2)), za2(m3, h2, this.m_sr, this.m_progressTracker);
  }
  intersectEx(t3) {
    const s4 = this.tryFastImplementation(t3);
    if (null !== s4) {
      const e5 = [];
      return e5.length = 3, e5[s4.getDimension()] = s4, this.prepareVector(t3.getDescription(), this.m_dimensionMask, e5);
    }
    const n6 = It2(this.m_intersectorGeom, t3), r = At(this.m_sr, n6, true).total(), i2 = n4.constructEmpty();
    this.m_intersectorGeom.queryEnvelope(i2);
    const o = n4.constructEmpty();
    t3.queryEnvelope(o), i2.inflateCoords(2 * r, 2 * r), i2.intersect(o), i2.inflateCoords(100 * r, 100 * r);
    const a2 = 0;
    let h2 = f2(this.m_intersectorGeom, i2, a2, 0, this.m_progressTracker), m3 = f2(t3, i2, a2, 0, this.m_progressTracker);
    t3.getDimension() > this.m_intersectorGeom.getDimension() && (h2 = Pt(m3, m3 = h2));
    const l2 = Wa2(m3, h2, this.m_sr, this.m_progressTracker);
    return this.prepareVector(t3.getDescription(), this.m_dimensionMask, l2);
  }
  init(e5, t3, s4, n6 = null) {
    n2(0);
  }
  static intersectPoints(e5, t3, s4) {
    const n6 = It2(e5, t3);
    return La2(e5, t3, At(s4, n6, true));
  }
  tryFastImplementation(t3) {
    const s4 = t3.getGeometryType();
    if (this.m_intersectorGeomType === a.enumPoint && s4 === a.enumPoint) {
      const e5 = _Ih.intersectPoints(t3, this.m_intersectorGeom, this.m_sr);
      if (-1 !== this.m_dimensionMask) {
        const t4 = new Ee({ vd: e5.getDescription() });
        return e5.isEmpty() || t4.add(e5), t4;
      }
      return e5;
    }
    if (s4 === a.enumEnvelope && this.m_intersectorGeomType === a.enumEnvelope && (-1 === this.m_dimensionMask || 4 === this.m_dimensionMask)) {
      const e5 = t3, s5 = this.m_intersectorGeom, n6 = new re({ copy: e5 });
      return n6.intersect(s5), n6;
    }
    const r = It2(t3, this.m_intersectorGeom), o = At(this.m_sr, r, true), a2 = t3.isEmpty(), h2 = this.m_intersectorGeom.isEmpty();
    let l2 = a2 || h2;
    if (!l2) {
      const e5 = Ch2(this.m_intersectorGeom, t3, o.total());
      if (4 === e5) l2 = true;
      else {
        if (2 & e5) return this.m_intersectorGeom;
        if (1 & e5) return t3;
      }
    }
    if (l2) {
      const e5 = m(s4), r2 = m(this.m_intersectorGeomType);
      return e5 < r2 ? _Ih.ReturnEmpty(t3, a2) : e5 > r2 || 0 === e5 && s4 === a.enumMultiPoint && this.m_intersectorGeomType === a.enumPoint ? this.ReturnEmptyIntersector() : _Ih.ReturnEmpty(t3, a2);
    }
    if (s4 === a.enumEnvelope && 0 === m(this.m_intersectorGeomType) || this.m_intersectorGeomType === a.enumEnvelope && 0 === m(s4)) {
      const r2 = s4 === a.enumEnvelope ? t3 : this.m_intersectorGeom, i2 = s4 === a.enumEnvelope ? this.m_intersectorGeom : t3, a3 = n4.constructEmpty();
      return r2.queryEnvelope(a3), f2(i2, a3, o.total(), 0, this.m_progressTracker);
    }
    if (0 === m(s4) && m(this.m_intersectorGeomType) > 0 || m(s4) > 0 && 0 === m(this.m_intersectorGeomType)) {
      if (s4 === a.enumMultiPoint) return Oa2(t3, this.m_intersectorGeom, o);
      if (s4 === a.enumPoint) return Xa2(t3, this.m_intersectorGeom, o);
      if (this.m_intersectorGeomType === a.enumMultiPoint) return Oa2(this.m_intersectorGeom, t3, o);
      if (this.m_intersectorGeomType === a.enumPoint) return Xa2(this.m_intersectorGeom, t3, o);
      b("");
    }
    return null;
  }
  ReturnEmptyIntersector() {
    return null === this.m_geomIntersectorEmptyGeom && (this.m_geomIntersectorEmptyGeom = this.m_intersectorGeom.createInstance()), this.m_geomIntersectorEmptyGeom;
  }
  static ReturnEmpty(e5, t3) {
    return t3 ? e5 : e5.createInstance();
  }
  prepareVector(e5, t3, s4) {
    let n6 = 0;
    return 1 & t3 ? (s4[0] || (s4[0] = new Ee({ vd: e5 })), n6++) : s4.shift(), 2 & t3 ? (s4[n6] || (s4[n6] = new Os2({ vd: e5 })), n6++) : s4.splice(n6, 1), 4 & t3 ? s4[n6] || (s4[n6] = new ur({ vd: e5 })) : s4.splice(n6, 1), new s2(s4);
  }
};
var bh2 = class extends t {
  constructor(e5, s4, n6, r, i2) {
    super(), this.m_smallCursor = null, this.m_progressTracker = r, this.m_geomIntersector = s4.next(), this.m_intersector = new Ih2(this.m_geomIntersector, n6, i2, r), this.m_index = -1, this.m_inputGeoms = e5, this.m_dimensionMask = i2, -1 !== this.m_dimensionMask && (this.m_dimensionMask <= 0 || this.m_dimensionMask > 7) && P("bad dimension mask");
  }
  next() {
    if (!this.m_geomIntersector) return null;
    let e5;
    if (null !== this.m_smallCursor) {
      if (e5 = this.m_smallCursor.next(), e5) return e5;
      this.m_smallCursor = null;
    }
    for (; e5 = this.m_inputGeoms.next(); ) {
      if (j(e5), this.m_index = this.m_inputGeoms.getGeometryID(), -1 === this.m_dimensionMask) {
        return this.m_intersector.intersect(e5);
      }
      this.m_smallCursor = this.m_intersector.intersectEx(e5);
      return this.m_smallCursor.next();
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
var wh2 = class {
  getOperatorType() {
    return 1e4;
  }
  accelerateGeometry(e5, t3, s4) {
    if (!this.canAccelerateGeometry(e5)) return false;
    Bt2(t3, e5, true);
    let r = 0;
    return e5.getGeometryType() !== a.enumPolygon && e5.getGeometryType() !== a.enumPolyline || !Ls2(e5) || 0 === s4 || (r |= e5.getImpl().buildQuadTreeAccelerator(s4) ? 1 : 0), !!r;
  }
  canAccelerateGeometry(e5) {
    return Ls2(e5);
  }
  supportsCurves() {
    return true;
  }
  executeMany(e5, t3, s4, n6, r = -1) {
    return new bh2(e5, t3, s4, n6, r);
  }
  execute(e5, t3, s4, r) {
    if (e5.getGeometryType() === a.enumPoint && t3.getGeometryType() === a.enumPoint) return Ih2.intersectPoints(e5, t3, s4);
    const o = new s2([e5]), a2 = new s2([t3]), h2 = this.executeMany(o, a2, s4, r, -1).next();
    return h2 || b("null output"), h2;
  }
};
function vh2(e5, t3, s4) {
  return t3.m_projector.project(e5, s4);
}
function Nh2(e5, t3, s4, n6, r) {
  e5.m_projector.transformInPlaceZ(t3, null, s4, n6, null, r);
  const i2 = n6.slice(0, s4).filter((e6) => !e6.isNAN());
  for (let o = 0, a2 = i2.length; o < a2; ++o) n6[o].assign(i2[o]);
  return i2.length;
}
function Th2(e5, t3, s4, n6, r) {
  return e5.m_projector.transformInPlaceZ(t3, null, s4, n6, null, r);
}
function Gh(s4, i2, a2, h2) {
  if (s4 && i2 && i2.isPannable() || P("fold_into_360_range_geodetic"), s4.isEmpty()) return s4;
  if (4 === a2) return Dh2(s4, i2, h2);
  let m3 = s4;
  const l2 = m3.getGeometryType();
  if (h(l2)) {
    m3 = Al(s4, i2);
    const t3 = new n4();
    m3.queryEnvelope(t3);
    const n6 = At(i2, t3, false).total(), r = i2.getPannableExtent();
    let o = Math.floor((t3.xmin - r.xmin) / r.width()) * r.width() + r.xmin, h3 = m3;
    for (; o < t3.xmax; ) o > t3.xmin + n6 && o < t3.xmax - n6 && (h3 = Hl(h3, i2, a2, true, o)), o += r.width();
    m3 = h3;
  } else {
    if (l2 === a.enumEnvelope) {
      const e5 = new ur({ vd: m3.getDescription() });
      return e5.addEnvelope(m3, false), Gh(e5, i2, a2, h2);
    }
    if (f(l2)) {
      const e5 = new Os2({ vd: m3.getDescription() });
      return e5.addSegment(m3, true), Gh(e5, i2, a2, h2);
    }
  }
  return Dh2(m3, i2, h2);
}
function Dh2(e5, s4, i2) {
  if (e5 && s4 && s4.isPannable() || P(""), e5.isEmpty()) return e5;
  let o;
  const a2 = e5.getGeometryType();
  if (a2 === a.enumEnvelope) {
    const t3 = new ur({ vd: e5.getDescription() });
    t3.addEnvelope(e5, false), o = t3;
  } else if (f(a2)) {
    const t3 = new Os2({ vd: e5.getDescription() });
    t3.addSegment(e5, true), o = t3;
  } else o = e5;
  const h2 = Al(o, s4);
  return h2.isEmpty() ? h2 : vl(h2, s4, 0, h2 !== e5, 0, i2);
}
function Vh(e5, t3, s4) {
  if (!t3.isPannable() || e5.isEmpty()) return e5;
  const n6 = t3.getPannableExtent().width(), r = 0.5 * n6, i2 = e5.queryInterval(0, 0);
  if (i2.width() < r || !y(e5.getGeometryType())) {
    if (Number.isNaN(s4)) return e5;
    const t4 = i2.getCenter();
    if (Math.abs(t4 - s4) <= r) return e5;
    {
      const r2 = new x3(), i3 = S((s4 - t4) / n6) * n6;
      r2.setShiftCoords(i3, 0);
      const o = e5.clone();
      return o.applyTransformation(r2), o;
    }
  }
  const a2 = e5.getGeometryType(), h2 = e5, m3 = h2.getAttributeStreamRef(0), l2 = e5.clone(), g2 = l2.getAttributeStreamRef(0);
  let u = 0, c = 0, _ = 0, p3 = h(a2) ? 0 : -1;
  const f3 = x2.constructEmpty();
  let x4 = false;
  for (let d2 = 0, y2 = h2.getPointCount(); d2 < y2; d2++) {
    const e6 = m3.read(2 * d2);
    d2 === c && (h(a2) ? (0 === p3 && Number.isNaN(s4) && (x4 = true), p3 > 0 && Number.isNaN(s4) && (s4 = f3.getCenter(), x4 = false), c = h2.getPathEnd(p3), p3++) : c = h2.getPointCount(), Number.isNaN(s4) ? _ = e6 : (_ = s4, u = 0));
    let t4 = e6 - _;
    Math.abs(t4) > r && (t4 = S(t4 / n6) * n6, u -= t4, Math.abs(u) < 0.1 * n6 && (u = 0));
    const i3 = e6 + u;
    g2.write(2 * d2, i3), x4 && f3.mergeCoordinate(i3), _ = e6;
  }
  return l2.notifyModified(), l2;
}
var Fh2 = "missing implementation";
function Hh(t3, s4, n6, r) {
  const o = s4.getCoordinateSystemType();
  if (0 === o) {
    const e5 = new ac();
    return s4.queryPrecisionDescriptor(e5), kh2(t3, e5, s4, n6);
  }
  let a2 = t3;
  2 !== r && 3 !== r || !s4.isPannable() || (a2 = Dh2(a2, s4, n6));
  const h2 = new ac();
  if (s4.queryPrecisionDescriptor(h2), a2 = kh2(a2, h2, s4, n6), 0 === r || a2.isEmpty()) return a2;
  if (1 === o) {
    if (1 === r) {
      const t4 = new n4();
      a2.queryLooseEnvelope(t4);
      const r2 = s4.getPannableExtent(), i2 = 0.01 * r2.width();
      return r2.xmin = t4.xmin - i2, r2.xmax = t4.xmax + i2, new I3().execute(a2, r2, s4, n6);
    }
    return a2;
  }
  if (2 === o) {
    const e5 = s4.getPCSHorizon();
    if (1 === r || 2 === r) {
      const t4 = new wh2().execute(a2, e5, s4, n6);
      return t4 === e5 ? t4.clone() : t4;
    }
    return a2;
  }
  if (3 === o) return a2;
  b(Fh2);
}
function kh2(e5, t3, s4, n6) {
  const r = t3.getXYGridRange(), i2 = e5.hasAttribute(1), o = e5.hasAttribute(2);
  let a2 = new x2(), h2 = new x2();
  i2 && (a2 = t3.getZGridRange()), o && (h2 = t3.getMGridRange());
  let m3 = new I3().execute(e5, r, s4, n6);
  if (i2) {
    const t4 = m3.queryInterval(1, 0);
    a2.contains(t4) || (e5 === m3 && (m3 = m3.clone()), $t2(m3, a2, 1, 0));
  }
  if (o) {
    const t4 = m3.queryInterval(2, 0);
    h2.contains(t4) || (e5 === m3 && (m3 = m3.clone()), $t2(m3, h2, 2, 0));
  }
  return m3;
}
var Ah2 = class {
  constructor(e5) {
    this.m_inputPCSHorizonClipOption = 0, this.m_outputPCSHorizonClipOption = 0, this.m_bDontGeonormalizePolygon = false, this.m_bClipOutCurvedPoles = false, this.m_bNormalizeOutputGeometry = false, this.m_bDontHackPolesInGeogToGeog = false, this.m_centralMeridianOfOutputGCS = 0, this.m_densificationStepInput = 0, e5 || P(""), this.m_projTransform = e5, this.m_bClipOutCurvedPoles = false;
    const s4 = this.m_projTransform.getExtendedParamsImpl();
    this.m_bNormalizeOutputGeometry = s4.normalizeResultGeometry, this.m_bNormalizeOutputGeometry && (s4.legacyHorizonClipping ? this.m_bNormalizeOutputGeometry = false : this.m_projTransform.getOutputSR().isPannable() || (this.m_bNormalizeOutputGeometry = false)), s4.clipWithInputHorizon ? (this.m_inputPCSHorizonClipOption = 0, !s4.legacyHorizonClipping && this.m_projTransform.getInputSR().isPannable() && (this.m_inputPCSHorizonClipOption = this.m_bNormalizeOutputGeometry ? 4 : 2)) : this.m_inputPCSHorizonClipOption = 1, s4.clipWithOutputHorizon ? (this.m_outputPCSHorizonClipOption = 0, !s4.legacyHorizonClipping && this.m_projTransform.getOutputSR().isPannable() && (this.m_outputPCSHorizonClipOption = this.m_bNormalizeOutputGeometry ? 4 : 2)) : this.m_outputPCSHorizonClipOption = 1, this.m_centralMeridianOfOutputGCS = s4.centralMeridianOfOutputGCS, this.m_densificationStepInput = s4.densificationStep;
    const n6 = this.m_projTransform.getExtendedParamsInternal();
    this.m_bDontGeonormalizePolygon = n6.hasFlag(2147483648), this.m_bDontHackPolesInGeogToGeog = n6.hasFlag(1073741824), this.m_bClipOutCurvedPoles = n6.hasFlag(536870912);
  }
  project(e5, t3) {
    if (this.m_projTransform.isIdentity() || e5.isEmpty()) return e5;
    const s4 = e5.getGeometryType();
    if (s4 === a.enumPoint) return this.projectPoint(e5, t3);
    const r = this.m_projTransform.getInputSR().getCoordinateSystemType(), o = this.m_projTransform.getOutputSR().getCoordinateSystemType(), a2 = this.m_projTransform.getInputSR(), h2 = this.m_projTransform.getOutputSR();
    if (0 === r && r === o) {
      const t4 = Uh(a2, h2), s5 = e5.clone();
      return s5.applyTransformation(t4), s5;
    }
    switch (s4) {
      case a.enumPolyline:
      case a.enumPolygon:
        return this.projectMultiPath(e5, t3);
      case a.enumMultiPoint:
        return this.projectMultiPoint(e5, t3);
      case a.enumEnvelope:
        return this.projectEnvelope(e5, t3);
      case a.enumGeometryCollection:
        return this.projectGeometryCollection(e5, t3);
      default:
        b("");
    }
  }
  projectPoint(e5, t3) {
    const s4 = [e5.getXY()];
    let n6, r = null;
    (n6 = e5.hasAttribute(1)) && (r = [e5.getZ()]), this.transformInPlaceZ(s4, r, 1, s4, r, null);
    const i2 = e5.clone();
    return i2.setXY(s4[0]), n6 && i2.setZ(r[0]), i2;
  }
  projectMultiPoint(e5, t3) {
    let s4 = new Ee({ copy: e5 });
    const n6 = this.m_projTransform.getInputSR(), r = this.m_projTransform.getOutputSR(), i2 = n6.getCoordinateSystemType(), o = r.getCoordinateSystemType();
    if (3 === i2 && n2(0), s4 = Xl(s4, n6, this.m_inputPCSHorizonClipOption, t3), s4.isEmpty()) return s4;
    2 === i2 && $l(n6, 0, s4), gg(this.m_projTransform, s4, false);
    let h2 = 0;
    3 === o && n2(0);
    const m3 = 2 === o;
    return m3 ? h2 = r.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (h2 = this.m_centralMeridianOfOutputGCS), m3 && 0 !== this.m_outputPCSHorizonClipOption || (s4 = vl(s4, Zu2(r), h2, false, 0, t3)), m3 && (s4 = Sl(s4, r, this.m_outputPCSHorizonClipOption, t3), Kl(r, s4, this.m_bNormalizeOutputGeometry), s4.isEmpty()), s4;
  }
  projectMultiPath(e5, t3) {
    const s4 = e5.getGeometryType();
    return s4 === a.enumPolygon ? this.projectPolygon(e5, t3) : s4 === a.enumPolyline ? this.projectPolyline(e5, t3) : void b("project_multi_path_");
  }
  projectEnvelope(e5, t3) {
    this.m_projTransform.getInputSR(), this.m_projTransform.getOutputSR();
    const s4 = this.m_projTransform.isVertical() && e5.hasAttribute(1);
    let n6 = x2.constructEmpty();
    if (s4 && (n6 = e5.queryInterval(1, 0)), n6.width() > 0) {
      const s5 = e5.clone();
      s5.setInterval(1, 0, n6.vmin, n6.vmin);
      const r = this.projectEnvelopeHelper(s5, t3);
      s5.setInterval(1, 0, n6.vmax, n6.vmax);
      const i2 = this.projectEnvelopeHelper(s5, t3);
      return r.merge(i2), r;
    }
    return this.projectEnvelopeHelper(e5, t3);
  }
  projectPolygon(t3, s4) {
    n2(t3.getGeometryType() === a.enumPolygon), n2(!this.m_projTransform.isIdentity()), n2(!t3.isEmpty());
    const r = this.m_projTransform.getInputSR(), i2 = this.m_projTransform.getOutputSR(), o = r.getCoordinateSystemType(), h2 = i2.getCoordinateSystemType(), m3 = new ur({ copy: t3 });
    3 === o && n2(0), 3 === h2 && n2(0);
    const l2 = 2 === o, g2 = 2 === h2, u = l2 ? r.getGCS() : r, c = g2 ? i2.getGCS() : i2, _ = !g2 && !this.m_bDontHackPolesInGeogToGeog;
    let d2 = false, p3 = Xl(m3, r, this.m_inputPCSHorizonClipOption, s4);
    if (p3.isEmpty()) return p3;
    let f3 = this.m_densificationStepInput;
    const x4 = !Number.isNaN(f3);
    let y2;
    x4 && (p3 = new m2().execute(p3, f3, 0, 0, s4));
    let P5 = g2 ? i2.getPCSInfo() : null, E2 = Number.NaN;
    l2 && (E2 = r.getCentralMeridian());
    const S3 = null !== i2.getGCSSplitLines();
    if (this.m_bDontGeonormalizePolygon) {
      const e5 = p3;
      if (l2 && (hg(r, E2, e5), x4)) {
        const e6 = r.getUnitsPerMillimeter();
        f3 *= r.getGCS().getUnitsPerMillimeter() / e6;
      }
      if (cg(this.m_projTransform, e5, _), x4) {
        const e6 = r.getGCS().getUnitsPerMillimeter();
        f3 *= i2.getGCS().getUnitsPerMillimeter() / e6;
      }
      y2 = e5;
    } else {
      let t4 = new Os2({ vd: p3.getDescription() });
      if (t4.addAndExplicitlyOpenAllPaths(p3, false), l2) {
        if (hg(r, E2, t4), x4) {
          const e5 = r.getUnitsPerMillimeter();
          f3 *= r.getGCS().getUnitsPerMillimeter() / e5;
        }
        if (this.m_bClipOutCurvedPoles) {
          const n7 = r.getPCSInfo(), i3 = n7.getSouthPoleGeometry() === Nc.PE_POLE_LINE_CURVED, o3 = n7.getNorthPoleGeometry() === Nc.PE_POLE_LINE_CURVED;
          if (i3 || o3) {
            const n8 = n4.constructEmpty();
            t4.queryLooseEnvelope(n8), n8.inflateCoords(1, 1);
            const r2 = 89.9999 * u.getOneDegreeGCSUnit();
            i3 && (n8.ymin = -r2), o3 && (n8.ymax = r2), t4 = d(t4, n8, u, 0, 0, s4);
          }
        }
      }
      if (cg(this.m_projTransform, t4, _), x4) {
        const e5 = Zu2(r).getUnitsPerMillimeter();
        f3 *= Zu2(i2).getUnitsPerMillimeter() / e5;
      }
      let n6 = Number.NaN;
      g2 ? (P5 = i2.getPCSInfo(), n6 = i2.getCentralMeridian()) : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (n6 = this.m_centralMeridianOfOutputGCS);
      let o2 = Mh2(r) | Mh2(i2), a2 = 10 * c.getTolerance(0);
      this.m_bDontHackPolesInGeogToGeog && (o2 = 3, a2 = 10 * c.getTolerance(0)), y2 = Vl(p3, r, t4, c, n6, s4, o2, a2, this.m_bNormalizeOutputGeometry), o2 = 0;
    }
    if (S3 && (n2(!i2.isPannable()), y2 = cl(y2, i2, s4)), g2) {
      if (!d2) {
        const e5 = c.getPannableExtent().width();
        if (y2.queryInterval(0, 0).width() >= e5 - 10 * c.getTolerance(0)) {
          const e6 = P5.getNorthPoleLocation(), t4 = P5.getSouthPoleLocation(), s5 = P5.getNorthPoleGeometry(), n6 = P5.getSouthPoleGeometry();
          let r2 = 0;
          s5 === Nc.PE_POLE_POINT && e6 !== Nc.PE_POLE_OUTSIDE_BOUNDARY && (r2 = 1), n6 === Nc.PE_POLE_POINT && t4 !== Nc.PE_POLE_OUTSIDE_BOUNDARY && (r2 |= 2), d2 ||= 0 !== r2;
        }
      }
      y2 = Sl(y2, i2, this.m_outputPCSHorizonClipOption, s4), x4 && (y2 = new m2().execute(y2, f3, 0, 0, s4)), Jl(i2, y2, this.m_bNormalizeOutputGeometry);
    }
    return y2.isEmpty() || d2 && (y2 = new Eh2().execute(y2, i2, false, s4)), y2;
  }
  projectPolyline(e5, t3) {
    n2(e5.getGeometryType() === a.enumPolyline), n2(!this.m_projTransform.isIdentity()), n2(!e5.isEmpty());
    const s4 = this.m_projTransform.getInputSR(), r = this.m_projTransform.getOutputSR(), i2 = s4.getCoordinateSystemType(), o = r.getCoordinateSystemType(), h2 = new Os2({ copy: e5 });
    3 === i2 && n2(0), 3 === o && n2(0);
    const m3 = 2 === i2, l2 = 2 === o;
    m3 && s4.getGCS();
    const g2 = l2 ? r.getGCS() : r, u = !l2 && !this.m_bDontHackPolesInGeogToGeog;
    let c = Xl(h2, s4, this.m_inputPCSHorizonClipOption, t3);
    if (c.isEmpty()) return c;
    let _ = Number.NaN;
    m3 && (_ = s4.getCentralMeridian());
    const d2 = null !== r.getGCSSplitLines();
    let p3 = this.m_densificationStepInput;
    const f3 = !Number.isNaN(p3);
    let x4;
    if (f3 && (c = new m2().execute(c, p3, 0, 0, t3)), this.m_bDontGeonormalizePolygon) {
      if (m3 && (hg(s4, _, c), f3)) {
        const e6 = s4.getUnitsPerMillimeter();
        p3 *= s4.getGCS().getUnitsPerMillimeter() / e6;
      }
      if (cg(this.m_projTransform, c, u), f3) {
        const e6 = s4.getGCS().getUnitsPerMillimeter();
        p3 *= r.getGCS().getUnitsPerMillimeter() / e6;
      }
      x4 = c;
    } else {
      const e6 = new Os2({ vd: c.getDescription() });
      if (e6.addAndExplicitlyOpenAllPaths(c, false), m3 && (hg(s4, _, e6), f3)) {
        const e7 = s4.getUnitsPerMillimeter();
        p3 *= s4.getGCS().getUnitsPerMillimeter() / e7;
      }
      if (cg(this.m_projTransform, e6, u), f3) {
        const e7 = s4.getGCS().getUnitsPerMillimeter();
        p3 *= r.getGCS().getUnitsPerMillimeter() / e7;
      }
      let n6 = Number.NaN;
      l2 ? n6 = r.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (n6 = this.m_centralMeridianOfOutputGCS);
      let i3 = Mh2(s4) | Mh2(r), o2 = 10 * g2.getTolerance(0);
      this.m_bDontHackPolesInGeogToGeog && (i3 = 3, o2 = 0), x4 = Fl(c, s4, e6, g2, n6, t3, i3, o2, this.m_bNormalizeOutputGeometry), i3 = 0;
    }
    return d2 && (n2(!r.isPannable()), x4 = cl(x4, r, t3)), l2 && (x4 = Sl(x4, r, this.m_outputPCSHorizonClipOption, t3), f3 && (x4 = new m2().execute(x4, p3, 0, 0, t3)), Jl(r, x4, this.m_bNormalizeOutputGeometry)), x4.isEmpty(), x4;
  }
  projectGeometryCollection(e5, t3) {
    return n2(0), {};
  }
  projectEnvelopeHelper(t3, s4) {
    const n6 = (t3.height() + t3.width()) / 400;
    if (0 !== n6) {
      const r = new m2().execute(t3, n6, 0, 0, s4), i2 = this.projectMultiPath(r, s4), o = new re({ vd: t3.getDescription() });
      if (i2.isEmpty()) {
        const n7 = Math.min(t3.height(), t3.width()), i3 = Bt2(this.m_projTransform.getInputSR(), t3, true).total();
        if (n7 > 100 * i3) {
          const t4 = n4.constructEmpty(), s5 = At(this.m_projTransform.getOutputSR(), t4, true).total(), r2 = this.m_projTransform.getInputSR().getOneMeter() / this.m_projTransform.getOutputSR().getOneMeter();
          if (n7 > 100 * Math.max(i3, s5 * r2)) return o;
        }
        const a2 = new Os2();
        a2.addAndExplicitlyOpenAllPaths(r, false);
        this.projectMultiPath(a2, s4).queryEnvelope(o);
        const h2 = new Ee({ vd: t3.getDescription() });
        h2.reserve(4);
        const m3 = new ee();
        for (let e5 = 0; e5 < 4; e5++) t3.queryCornerByVal(e5, m3), h2.add(m3);
        const l2 = this.projectMultiPoint(h2, s4), g2 = new re();
        return l2.queryEnvelope(g2), o.merge(g2), o;
      }
      return i2.queryEnvelope(o), o;
    }
    {
      const e5 = t3.getCenterXY(), n7 = new ee(e5), r = this.projectPoint(n7, s4), i2 = new re({ vd: t3.getDescription() });
      if (r.isEmpty()) i2.setEmpty();
      else {
        t3.copyTo(i2);
        const e6 = r.getXY();
        i2.setCoords(e6.x, e6.y, e6.x, e6.y);
      }
      return i2;
    }
  }
  transformInPlace(e5, t3, s4, n6) {
    return n2(0), 0;
  }
  transformInPlaceZ(e5, t3, s4, n6, r, i2) {
    if (this.m_projTransform.isIdentity()) return e5 !== n6 && Gt(n6, e5, s4), t3 !== r && Dt(r, t3, 0, 0, s4), s4;
    const o = this.m_projTransform, h2 = o.getInputSR(), m3 = o.getOutputSR(), l2 = h2.getCoordinateSystemType(), g2 = m3.getCoordinateSystemType();
    if (0 === l2 && l2 === g2) {
      return Uh(h2, m3).transformPoints2D(e5, s4, n6), o.isVertical() && n2(0), s4;
    }
    3 === l2 && z("image: transform_in_place_"), 3 === g2 && z("image: transform_in_place_"), Ll(e5, s4, n6, h2, this.m_inputPCSHorizonClipOption), r !== t3 && Dt(r, t3, 0, 0, s4), 2 === l2 && mg(h2, 0, n6, s4), fg(this.m_projTransform, n6, r, s4, false);
    let c = 0;
    const _ = 2 === g2;
    if (_ ? c = m3.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (c = this.m_centralMeridianOfOutputGCS), _ && 0 !== this.m_outputPCSHorizonClipOption || Nl(n6, s4, m3.getGCS(), c), _) {
      if (!wl(n6, s4, m3, this.m_outputPCSHorizonClipOption)) for (let e6 = 0; e6 < s4; ++e6) n6[e6].setNAN();
      Wl(m3, n6, s4, false);
    }
    let d2 = s4;
    for (let a2 = 0; a2 < s4; ++a2) n6[a2].isNAN() && (r && (r[a2] = Number.NaN), d2--);
    return d2;
  }
};
function Mh2(e5) {
  if (2 !== e5.getCoordinateSystemType()) return 0;
  let t3 = 0;
  const s4 = e5.getPCSInfo(), n6 = s4.getNorthPoleLocation(), r = s4.getSouthPoleLocation(), i2 = s4.getNorthPoleGeometry(), o = s4.getSouthPoleGeometry();
  return i2 === Nc.PE_POLE_POINT && n6 !== Nc.PE_POLE_OUTSIDE_BOUNDARY && (t3 = 1), o === Nc.PE_POLE_POINT && r !== Nc.PE_POLE_OUTSIDE_BOUNDARY && (t3 |= 2), t3;
}
function Uh(e5, t3) {
  const s4 = e5.getHorzUnitFactor(), n6 = t3.getHorzUnitFactor();
  let r = 1, i2 = 1;
  const o = 20015077 / 180;
  1 === e5.getUnit().getUnitType() && (r = o), 1 === t3.getUnit().getUnitType() && (i2 = o);
  const a2 = s4 / n6 * (r !== i2 ? r / i2 : 1), h2 = new x3();
  return h2.setScaleCoords(a2, a2), h2;
}
var qh = class {
  getOperatorType() {
    return 10300;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t3, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  executeMany(e5, t3, s4) {
    return !t3 || t3.isIdentity() ? e5 : new Bh(e5, t3, s4);
  }
  execute(e5, t3, s4) {
    return t3.isIdentity() ? e5 : vh2(e5, t3, s4);
  }
  transform(e5, t3, s4, n6, r = true) {
    return r ? Nh2(e5, t3, s4, n6, null) : Th2(e5, t3, s4, n6, null);
  }
  transform3D(e5, t3, s4, n6, r = true) {
    return n2(0), 0;
  }
  foldInto360Range(e5, t3) {
    return Dh2(e5, t3, null);
  }
  foldInto360RangeGeodetic(e5, t3, s4) {
    return Gh(e5, t3, s4, null);
  }
  normalizeGeometryEx(e5, t3, s4, n6, r = 0) {
    return Tm(e5, t3, s4, n6, r);
  }
  normalizeGeometry(e5, t3, s4) {
    return Vh(e5, t3, s4);
  }
  clipToSpatialReference(e5, t3, s4, n6 = 0) {
    return Hh(e5, t3, s4, n6);
  }
};
var Bh = class extends t {
  constructor(e5, s4, n6) {
    super(), this.m_projTrans = s4, this.m_progressTracker = n6, this.m_index = -1, e5 || P(""), this.m_inputGeoms = e5;
  }
  next() {
    const e5 = this.m_inputGeoms.next();
    return null != e5 ? (N(e5), j(e5), this.m_index = this.m_inputGeoms.getGeometryID(), vh2(e5, this.m_projTrans, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function Oh(e5, i2, h2, m3, l2, g2, u = false) {
  e5 || P("Geometry.Geodetic_densify.densify");
  let c = e5.getGeometryType();
  if (j(e5), e5.isEmpty() || l(c)) return e5;
  const _ = new Wh2();
  _.m_sr = i2, _.m_gcs = i2.getGCS(), _.m_transform = _.m_gcs !== i2 ? i2.getSRToGCSTransform() : null, _.m_progressTracker = g2;
  const d2 = Hu2();
  let f3, x4, y2;
  if (_.m_gcs.querySpheroidData(d2), _.m_a = d2.majorSemiAxis, _.m_eSquared = d2.e2, _.m_rpu = _.m_gcs.getUnit().getUnitToBaseFactor(), _.m_gcsTolerance = _.m_gcs.getTolerance(0), _.m_radTolerance = _.m_gcsTolerance * _.m_rpu, _.m_maxLength = m3, _.m_maxDeviation = l2, _.m_curveType = h2, c === a.enumEnvelope) {
    const t3 = new ur({ vd: e5.getDescription() });
    t3.addEnvelope(e5, false), f3 = t3, c = a.enumPolygon;
  } else if (f(c)) {
    const t3 = new Os2({ vd: e5.getDescription() });
    t3.addSegment(e5, true), f3 = t3, c = a.enumPolyline;
  } else f3 = e5;
  if (4 !== _.m_curveType) {
    if (n2(h(c)), x4 = _.replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(f3), x4.isEmpty()) return x4;
    x4 = Yh2(_.m_rpu, x4);
    let e6 = _.geodeticDensify(x4);
    u || (e6 = new qh().foldInto360RangeGeodetic(e6, _.m_gcs, _.m_curveType)), y2 = _.m_transform && !_.m_transform.isIdentity() ? new qh().execute(e6, _.m_transform.getInverse(), g2) : e6;
  } else {
    let e6;
    if (n2(h(c)), i2.isPannable()) e6 = Al(f3, i2);
    else {
      const t3 = i2.getPCSHorizon();
      e6 = new wh2().execute(f3, t3, i2, g2), e6 === t3 && (e6 = t3.clone());
    }
    if (x4 = e6, x4.isEmpty()) return x4;
    y2 = _.shapePreservingDensify(x4);
  }
  return y2;
}
function Yh2(t3, s4) {
  const n6 = new n4();
  if (s4.queryLooseEnvelope(n6), n6.width() * t3 < Math.PI) return s4;
  let r = false;
  const i2 = s4.querySegmentIterator(), o = new mi(), a2 = new mi();
  for (; i2.nextPath(); ) for (; i2.hasNextSegment(); ) {
    const e5 = i2.nextSegment();
    if (o.setCoordsPoint2D(e5.getStartXY()), a2.setCoordsPoint2D(e5.getEndXY()), o.scale(t3), a2.scale(t3), Math.abs(o.x - a2.x) > Math.PI) {
      if (!Xh2(o, a2)) {
        r = true;
        break;
      }
      if (Math.abs(o.x - a2.x) > 2 * Math.PI) {
        r = true;
        break;
      }
    }
  }
  if (!r) return s4;
  const h2 = s4.createInstance();
  h2.reserve(s4.getPointCount());
  const m3 = s4.getDescription().getAttributeCount() > 1, l2 = new mi(), g2 = new mi(), u = new mi(0, 0), c = new mi(0, 0), _ = new ee();
  for (i2.resetToFirstPath(); i2.nextPath(); ) {
    let e5 = Number.NaN, s5 = 0;
    for (; i2.hasNextSegment(); ) {
      const n7 = i2.nextSegment();
      o.setCoordsPoint2D(n7.getStartXY()), a2.setCoordsPoint2D(n7.getEndXY()), o.scale(t3), a2.scale(t3), Number.isNaN(e5) ? (s5 = im2(o.x, Number.NaN, s5), u.setCoordsPoint2D(o)) : u.setCoordsPoint2D(c), e5 = u.x;
      if (Xh2(o, a2)) {
        if (a2.x - o.x > 2 * Math.PI) for (; a2.x - o.x > 2 * Math.PI; ) a2.x -= 2 * Math.PI;
        else if (a2.x - o.x < 2 * -Math.PI) for (; a2.x - o.x < 2 * -Math.PI; ) a2.x += 2 * Math.PI;
        s5 = im2(a2.x, Number.NaN, s5), c.setCoordsPoint2D(a2);
      } else l2.setCoordsPoint2D(a2), gm2(l2), s5 = im2(l2.x, e5, s5), c.setCoords(s5 + l2.x, l2.y);
      if (Math.abs(c.x - a2.x) < 0.5 && c.setCoordsPoint2D(a2), m3) {
        n7.queryCoord(0, _), g2.setCoordsPoint2D(u), g2.scale(1 / t3), _.setXY(g2);
        i2.isFirstSegmentInPath() ? h2.startPathPoint(_) : h2.lineToPoint(_), i2.isLastSegmentInPath() && !i2.isPathClosed() && (n7.queryCoord(1, _), g2.setCoordsPoint2D(c), g2.scale(1 / t3), _.setXY(g2), h2.lineToPoint(_));
      } else {
        i2.isFirstSegmentInPath() && h2.insertPath2D(-1, null, 0, 0, true);
        const e6 = h2.getPathCount() - 1;
        g2.setCoordsPoint2D(u), g2.scale(1 / t3), h2.insertPoint2D(e6, -1, g2), i2.isLastSegmentInPath() && !i2.isPathClosed() && (g2.setCoordsPoint2D(c), g2.scale(1 / t3), h2.insertPoint2D(e6, -1, g2));
      }
    }
  }
  return h2;
}
function Rh2(e5, t3, s4, n6, r, i2, o, a2, h2, m3, l2, g2) {
  const u = new mi(), c = new mi(), _ = n6.compare(r) > 0;
  nm2(_, n6, r, u, c);
  const d2 = Kh2(e5, t3, s4, u, c, i2, o, a2, h2, m3, null, l2, g2);
  return _ && sm2(h2, m3, null, l2), d2;
}
function Xh2(e5, t3) {
  return !(!Pc(e5.y, Wt) || !Pc(t3.y, Wt)) || !(!Pc(e5.y, -Wt) || !Pc(t3.y, -Wt));
}
function Lh2(e5, t3) {
  return !(!Pc(e5.y, Wt) || Pc(t3.y, Wt)) || !(!Pc(e5.y, -Wt) || Pc(t3.y, -Wt));
}
function zh2(e5, t3) {
  return !(!Pc(t3.y, Wt) || Pc(e5.y, Wt)) || !(!Pc(t3.y, -Wt) || Pc(e5.y, -Wt));
}
var Wh2 = class {
  constructor() {
    this.m_sr = null, this.m_gcs = null, this.m_transform = null, this.m_progressTracker = null, this.m_a = 0, this.m_eSquared = 0, this.m_rpu = 0, this.m_gcsTolerance = 0, this.m_radTolerance = 0, this.m_maxLength = 0, this.m_maxDeviation = 0, this.m_curveType = 0;
  }
  geodeticDensify(e5) {
    const t3 = e5.createInstance(), s4 = e5.querySegmentIterator(), n6 = [], r = [], i2 = new fm(), o = e5.getDescription().getAttributeCount() > 1;
    for (; s4.nextPath(); ) {
      const e6 = [0];
      for (; s4.hasNextSegment(); ) {
        const a2 = s4.nextSegment(), h2 = a2.getStartXY(), m3 = a2.getEndXY();
        h2.scale(this.m_rpu), m3.scale(this.m_rpu);
        const l2 = new mi(), g2 = new mi(), u = h2.compare(m3) > 0;
        nm2(u, h2, m3, l2, g2), n6.length = 0, r.length = 0, this.m_maxLength > 0 ? Kh2(this.m_a, this.m_eSquared, this.m_curveType, l2, g2, this.m_maxLength, this.m_maxDeviation, this.m_radTolerance, null, null, o ? r : null, n6, e6) : Qh2(), u && sm2(null, null, o ? r : null, n6), n6[0].setCoordsPoint2D(a2.getStartXY()), n6.at(-1).setCoordsPoint2D(a2.getEndXY());
        const c = 1 / this.m_rpu;
        for (let e7 = 1, t4 = n6.length - 1; e7 < t4; e7++) n6[e7].scale(c);
        if (o) {
          const e7 = rm2(u, a2, i2);
          Zh2(s4.isFirstSegmentInPath(), s4.isLastSegmentInPath() && !s4.isPathClosed(), a2, e7, r, n6, t3);
        } else jh2(s4.isFirstSegmentInPath(), s4.isLastSegmentInPath() && !s4.isPathClosed(), n6, t3);
      }
    }
    return t3;
  }
  shapePreservingDensify(e5) {
    const t3 = e5.createInstance(), s4 = e5.querySegmentIterator(), n6 = [], r = [], i2 = new fm(), o = e5.getDescription().getAttributeCount() > 1;
    for (; s4.nextPath(); ) for (; s4.hasNextSegment(); ) {
      const e6 = s4.nextSegment(), a2 = e6.getStartXY(), h2 = e6.getEndXY(), m3 = a2.compare(h2) > 0, l2 = rm2(m3, e6, i2);
      n6.length = 0, r.length = 0, tm2(this.m_a, this.m_eSquared, this.m_rpu, l2, this.m_sr, this.m_maxLength, this.m_maxDeviation, o ? r : null, n6), m3 && sm2(null, null, o ? r : null, n6), o ? Zh2(s4.isFirstSegmentInPath(), s4.isLastSegmentInPath() && !s4.isPathClosed(), e6, l2, r, n6, t3) : jh2(s4.isFirstSegmentInPath(), s4.isLastSegmentInPath() && !s4.isPathClosed(), n6, t3);
    }
    return t3;
  }
  replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(e5) {
    const t3 = e5.hasNonLinearSegments();
    if ((!this.m_transform || this.m_transform.isIdentity()) && (e5 = Al(e5, this.m_gcs), !t3)) return e5;
    const s4 = e5.createInstance();
    s4.reserveParts(e5.getPointCount(), e5.getPathCount());
    for (let n6 = 0, r = e5.getPathCount(); n6 < r; ++n6) {
      let t4 = new Ee();
      const r2 = e5.getPathStart(n6), i2 = e5.getPathEnd(n6);
      t4.addPoints(e5, r2, i2);
      const o = e5.isClosedPath(n6);
      let a2 = false;
      if (o && i2 - r2 === 1 && e5.hasNonLinearSegmentsPath(n6)) {
        const s5 = new ee();
        e5.getPointByVal(r2, s5), t4.add(s5), a2 = true;
      }
      if (this.m_transform && !this.m_transform.isIdentity()) {
        if (o && !a2) {
          const s5 = new ee();
          e5.getPointByVal(r2, s5), t4.add(s5);
        }
        if (t4 = new qh().execute(t4, this.m_transform, this.m_progressTracker), o && t4.getPointCount() > 1) {
          const e6 = t4.getXY(0), s5 = t4.getXY(t4.getPointCount() - 1);
          e6.equals(s5) && t4.removePoint(t4.getPointCount() - 1);
        }
      }
      t4.getPointCount() > 1 && (s4.addPathMultiPoint(t4, 0, -1, true), o && s4.closePathWithLine());
    }
    return s4;
  }
};
function jh2(e5, t3, s4, n6) {
  e5 && n6.insertPath2D(-1, null, 0, 0, true);
  const r = n6.getPathCount() - 1;
  n6.insertPointsFromPoints(r, -1, s4, 0, s4.length - 1, true), t3 && n6.insertPoint2D(r, -1, s4.at(-1));
}
function Zh2(e5, t3, s4, n6, r, i2, o) {
  o.reserve(o.getPointCount() + i2.length - 1);
  const a2 = new ee();
  if (s4.queryStart(a2), e5 ? o.startPathPoint(a2) : o.lineToPoint(a2), i2.length > 2) {
    const e6 = n6.calculateLength2D();
    for (let t4 = 1; t4 < i2.length - 1; t4++) {
      const s5 = n6.lengthToT(r[t4] * e6);
      n6.queryCoord(s5, a2), a2.setXY(i2[t4]), o.lineToPoint(a2);
    }
  }
  t3 && (s4.queryEnd(a2), o.lineToPoint(a2));
}
function Kh2(e5, t3, s4, n6, r, i2, o, a2, h2, m3, l2, g2, u) {
  const c = { stack: [], error: void 0, hasError: false };
  try {
    const _ = n(c, new Cc(), false), d2 = n(c, new Cc(), false), p3 = n(c, new Cc(), false);
    Dc.geodeticDistance(e5, t3, n6.x, n6.y, r.x, r.y, p3, _, d2, s4);
    const f3 = p3.val, x4 = _.val, y2 = d2.val;
    let P5 = x4, E2 = y2;
    P5 < 0 && (P5 += 2 * Math.PI), E2 < 0 && (E2 += 2 * Math.PI), h2 && (h2[0] = P5), m3 && (m3[0] = E2);
    let S3 = Number.NaN, C3 = Number.NaN;
    if (null !== l2) {
      const s5 = Vc.q90(e5, t3), r2 = Vc.q(e5, t3, n6.y);
      S3 = (s5 - r2) / f3, C3 = (s5 + r2) / f3;
    }
    const I4 = Lh2(n6, r), b2 = zh2(n6, r), w4 = I4 || b2, v3 = mm2(n6, r, a2), N2 = n(c, new Ht(new Cc(), new Cc()), false), T3 = new mi(), G4 = new mi(), D3 = new mi();
    u[0] = im2(n6.x, Number.NaN, u[0]);
    let V4 = u[0];
    if (f3 <= i2) return g2.push(n6.clone()), u[0] = im2(r.x, Number.NaN, u[0]), null != l2 && l2.push(0), w4 ? (I4 && om2(n6, r, l2, g2), b2 && am2(n6, r, l2, g2)) : v3 ? hm2(n6, r, x4, S3, C3, l2, g2) : o > 0 && (G4.setCoords(n6.x - V4, n6.y), T3.setCoords(r.x - u[0], r.y), V4 = Jh()), g2.push(r.clone()), f3;
    const F3 = 1 + Math.ceil(f3 / i2), H3 = f3 / (F3 - 1), k4 = new mi();
    g2.push(n6.clone()), k4.setCoordsPoint2D(n6), G4.setCoords(n6.x - u[0], n6.y), null !== l2 && l2.push(0);
    for (let i3 = 1; i3 < F3; i3++) {
      let h3;
      if (i3 < F3 - 1) {
        const r2 = i3 * H3;
        Dc.geodeticCoordinate(e5, t3, n6.x, n6.y, r2, x4, N2.at(0), N2.at(1), s4), T3.setCoords(N2.at(0).val, N2.at(1).val), u[0] = im2(T3.x, k4.x, u[0]), D3.setCoords(u[0] + T3.x, T3.y), h3 = i3 / (F3 - 1);
      } else u[0] = im2(r.x, Number.NaN, u[0]), T3.setCoords(r.x - u[0], r.y), D3.setCoordsPoint2D(r), h3 = 1;
      w4 ? (1 === i3 && I4 && om2(n6, D3, l2, g2), i3 === F3 - 1 && b2 && am2(k4, r, l2, g2)) : v3 ? lm2(k4, D3, a2) && (n6.x < r.x ? k4.x > D3.x && (u[0] += 2 * Math.PI, D3.setCoords(u[0] + T3.x, T3.y)) : k4.x < D3.x && (u[0] -= 2 * Math.PI, D3.setCoords(u[0] + T3.x, T3.y)), hm2(k4, D3, x4, S3, C3, l2, g2)) : o > 0 && Jh(), g2.push(D3.clone()), null != l2 && l2.push(h3), k4.setCoordsPoint2D(D3), G4.setCoordsPoint2D(T3), V4 = u[0];
    }
    return f3;
  } catch (_) {
    c.error = _, c.hasError = true;
  } finally {
    s(c);
  }
}
function Qh2(e5, t3, s4, n6, r, i2, o, h2, m3, l2) {
  n2(0);
}
function Jh(e5, t3, s4, n6, r, i2, o, h2, m3, l2, g2, u, c, _, d2) {
  return n2(0), 0;
}
function $h(e5, t3, s4, n6) {
  const r = ds3(e5, t3, s4), i2 = ds3(e5, t3, n6);
  return X.distance(r, i2);
}
function em2(e5, t3, s4, n6, r, i2, o, h2) {
  const m3 = new Array(), l2 = Ot(Array, 8);
  let g2 = 2, u = r.getCoord2D(i2);
  l2[0][0] = u.x, l2[0][1] = u.y, u = r.getCoord2D(o), l2[1][0] = u.x, l2[1][1] = u.y;
  const c = (e6) => {
    if (null !== s4) {
      const t4 = wc.projToGeog(s4, e6, l2);
      n2(t4 === e6);
    }
    for (const t4 of l2) t4[0] *= n6, t4[1] *= n6;
  };
  c(2), m3.push(ds3(e5, t3, new mi(l2[0][0], l2[0][1]))), m3.push(ds3(e5, t3, new mi(l2[1][0], l2[1][1])));
  let _ = X.distance(m3[0], m3[1]);
  if (_ > h2) return _;
  let d2 = 0;
  for (g2 = 3; g2 <= 17; ) {
    const s5 = 1 / (g2 - 1);
    let n7 = 0;
    for (let e6 = 1; e6 < g2; ++e6) if (1 & e6) {
      const t4 = Q(i2, o, e6 * s5);
      r.queryCoord2D(t4, u), l2[n7][0] = u.x, l2[n7][1] = u.y, n7++;
    }
    c(n7);
    let p3 = 1;
    for (let r2 = 0; r2 < n7; ++r2) m3.splice(p3, 0, ds3(e5, t3, new mi(l2[r2][0], l2[r2][1]))), p3++;
    p3 = 0;
    let f3 = m3[p3];
    p3++;
    let x4 = 0;
    for (; p3 !== m3.length; ++p3) {
      const e6 = m3[p3];
      x4 += X.distance(f3, e6), f3 = e6;
    }
    if (x4 > h2) return x4;
    if (d2 = x4 - _, n2(d2 >= 0 || Math.abs(d2) < 1e-14 * x4), d2 < 0 && (d2 = 0), _ = x4, x4 + d2 <= h2) return x4 + d2;
    g2 = 2 * g2 - 1;
  }
  return _ + d2;
}
function tm2(e5, t3, s4, n6, r, i2, o, h2, m3) {
  const l2 = n6.isCurve(), g2 = Fs2(e5, t3) * Math.PI * 179 / 180;
  let u = i2;
  i2 > 0 && !(i2 > g2) || (u = g2);
  const c = o, _ = c > 0;
  let d2 = Number.NaN;
  _ && (d2 = Bs3(e5, t3, c));
  const p3 = 1 === r.getCoordinateSystemType();
  let f3 = null;
  p3 || (f3 = r.getPECoordSys());
  const x4 = r.getTolerance(0), y2 = n6.getStartXY(), P5 = n6.getEndXY(), E2 = new mi(), S3 = new mi();
  if (p3) E2.setCoordsPoint2D(y2), E2.scale(s4), S3.setCoordsPoint2D(P5), S3.scale(s4);
  else {
    const e6 = [y2.x, y2.y, P5.x, P5.y];
    wc.projToGeog(f3, 2, e6), E2.setCoords(e6[0], e6[1]), E2.scale(s4), S3.setCoords(e6[2], e6[3]), S3.scale(s4);
  }
  let C3 = 0, I4 = 0;
  const b2 = [], w4 = [], v3 = [];
  b2.push(P5.clone()), w4.push(S3.clone()), v3.push(1), m3.push(y2.clone()), null !== h2 && h2.push(I4);
  const N2 = r.isPannable(), T3 = y2.clone(), G4 = [0.5, 0.33333333333333337, 0.6666666666666666, 0.16666666666666669, 0.8333333333333333];
  let D3 = 5;
  l2 || (_ ? (G4[0] = 0.5, G4[1] = 0.25, G4[2] = 0.75, D3 = 3) : D3 = 1), n2(u > 0);
  const V4 = (e6) => {
    if (e6 = e6.clone(), null !== f3) {
      const t4 = [e6.x, e6.y];
      wc.projToGeog(f3, 1, t4), e6.setCoords(t4[0], t4[1]);
    }
    return e6.scale(s4), e6;
  };
  for (; w4.length > 0; ) {
    const i3 = b2.at(-1).clone();
    S3.assign(w4.at(-1));
    const o2 = v3.at(-1);
    let g3 = false, c2 = Number.NaN;
    const y3 = em2(e5, t3, f3, s4, n6, I4, o2, u);
    let P6 = u >= y3 && Math.abs(E2.y - S3.y) < 0.9 * Math.PI;
    p3 && P6 && (P6 = Math.abs(E2.x - S3.x) < 0.9 * Math.PI);
    const F3 = new mi(), H3 = new mi();
    let k4 = false;
    if (!_ && P6 && P6 && (k4 = true), n6.calculateSubLength(I4, o2) <= x4 && (k4 = true), !k4) for (let h3 = 0; h3 < D3; h3++) {
      const m4 = Q(I4, o2, G4[h3]), u2 = new mi();
      n6.queryCoord2D(m4, u2);
      const f4 = V4(u2);
      if (0 === h3 && (c2 = m4, F3.setCoordsPoint2D(u2), H3.setCoordsPoint2D(f4), !P6)) {
        g3 = true;
        break;
      }
      if (n2(_), p3 && Math.abs(E2.x - f4.x) >= Math.PI) {
        g3 = true;
        break;
      }
      let x5 = new mi(), y4 = new mi();
      l2 ? (x5 = mi.lerp(T3, i3, G4[h3]), y4 = V4(x5)) : (x5 = u2.clone(), y4 = f4.clone());
      const C4 = Ss3(e5, t3, E2, S3, G4[h3]), b3 = C4.clone();
      if (p3 ? (b3.x /= s4, b3.y /= s4) : (b3.x /= s4, b3.y /= s4, Th2(r.getGCSToSRTransform(), [b3], 1, [b3], null)), b3.isNAN()) {
        const s5 = ds3(e5, t3, f4), n7 = ds3(e5, t3, E2), r2 = ds3(e5, t3, S3), { second: i4 } = vs3(e5, t3, s5, n7, r2, 2, null);
        if (i4 > d2) {
          g3 = true;
          break;
        }
      } else {
        if (N2) {
          const e6 = r.getPannableExtent().width(), t4 = Q(n6.getStartX(), n6.getEndX(), 0.5);
          for (; b3.x < t4 - 0.5 * e6; ) b3.x += e6;
          for (; b3.x >= t4 + 0.5 * e6; ) b3.x -= e6;
        }
        const s5 = n6.getClosestCoordinateOnInterval(b3, new x2(I4, o2), -1);
        let i4 = n6.getCoord2D(s5);
        i4 = V4(i4);
        let a2 = $h(e5, t3, i4, C4);
        if (a2 > d2) {
          if (a2 < 4 * d2) {
            const s6 = ds3(e5, t3, i4), n7 = ds3(e5, t3, E2), r2 = ds3(e5, t3, S3), { second: o3 } = vs3(e5, t3, s6, n7, r2, 2, null);
            a2 = o3;
          }
          if (a2 > d2) {
            g3 = true;
            break;
          }
        } else if (l2) {
          let s6 = ds3(e5, t3, f4);
          const n7 = ds3(e5, t3, E2), r2 = ds3(e5, t3, S3);
          let { second: i5 } = vs3(e5, t3, s6, n7, r2, 3, null);
          if (i5 <= d2) {
            s6 = ds3(e5, t3, y4);
            const { second: o3 } = vs3(e5, t3, s6, n7, r2, 3, null);
            i5 = o3;
          }
          if (i5 > d2) {
            g3 = true;
            break;
          }
        }
      }
    }
    g3 ? (b2.push(F3.clone()), w4.push(H3.clone()), v3.push(c2)) : (b2.pop(), w4.pop(), v3.pop(), m3.push(i3.clone()), C3 += y3, null !== h2 && h2.push(C3), T3.setCoordsPoint2D(i3), E2.setCoordsPoint2D(S3), I4 = o2);
  }
  if (null !== h2) {
    const e6 = 1 / C3;
    for (let t4 = 0; t4 < h2.length; t4++) h2[t4] *= e6;
  }
}
function sm2(e5, t3, s4, n6) {
  if (n6.reverse(), null !== s4 && s4.reverse(), e5) {
    const s5 = e5[0], n7 = t3[0];
    e5[0] = n7, t3[0] = s5;
  }
}
function nm2(e5, t3, s4, n6, r) {
  e5 ? (n6.setCoordsPoint2D(s4), r.setCoordsPoint2D(t3)) : (n6.setCoordsPoint2D(t3), r.setCoordsPoint2D(s4));
}
function rm2(e5, t3, s4) {
  return e5 ? (s4.create(t3.getGeometryType()), t3.copyTo(s4.get()), s4.get().reverse(), s4.get()) : t3;
}
function im2(e5, t3, s4) {
  if (Number.isNaN(t3)) {
    for (; s4 - e5 > Math.PI; ) s4 -= 2 * Math.PI;
    for (; e5 - s4 > Math.PI; ) s4 += 2 * Math.PI;
    return s4;
  }
  return s4 + e5 - t3 > Math.PI ? s4 -= 2 * Math.PI : t3 - (s4 + e5) > Math.PI && (s4 += 2 * Math.PI), s4;
}
function om2(e5, t3, s4, n6) {
  if (e5.y > 0) {
    const r = new mi();
    r.setCoords(t3.x, Wt), Pc(e5.x, r.x) || Pc(t3.y, r.y) || (n6.push(r), null !== s4 && s4.push(0));
  } else {
    const r = new mi();
    r.setCoords(t3.x, -Wt), Pc(e5.x, r.x) || Pc(t3.y, r.y) || (n6.push(r), null !== s4 && s4.push(0));
  }
}
function am2(e5, t3, s4, n6) {
  if (t3.y > 0) {
    const r = new mi();
    r.setCoords(e5.x, Wt), Pc(t3.x, r.x) || Pc(e5.y, r.y) || (n6.push(r), null !== s4 && s4.push(1));
  } else {
    const r = new mi();
    r.setCoords(e5.x, -Wt), Pc(t3.x, r.x) || Pc(e5.y, r.y) || (n6.push(r), null !== s4 && s4.push(1));
  }
}
function hm2(e5, t3, s4, n6, r, i2, o) {
  if (Sc(s4)) {
    if (Wt - e5.y > 0) {
      const t4 = new mi();
      t4.setCoords(e5.x, Wt), o.push(t4), null !== i2 && i2.push(n6);
    }
    if (Wt - t3.y > 0) {
      const e6 = new mi();
      e6.setCoords(t3.x, Wt), o.push(e6), null !== i2 && i2.push(n6);
    }
  } else {
    if (Wt + e5.y > 0) {
      const t4 = new mi();
      t4.setCoords(e5.x, -Wt), o.push(t4), null !== i2 && i2.push(r);
    }
    if (Wt + t3.y > 0) {
      const e6 = new mi();
      e6.setCoords(t3.x, -Wt), o.push(e6), null !== i2 && i2.push(r);
    }
  }
}
function mm2(e5, t3, s4) {
  return !(!lm2(e5, t3, s4) || Pc(e5.y, Wt) || Pc(e5.y, -Wt) || Pc(t3.y, Wt) || Pc(t3.y, -Wt));
}
function lm2(e5, t3, s4) {
  return Math.abs(Math.abs(e5.x - t3.x) - Math.PI) <= s4;
}
function gm2(e5) {
  if (e5.x < -Math.PI) for (; e5.x < -Math.PI; ) e5.x += 2 * Math.PI;
  else if (e5.x > Math.PI) for (; e5.x > Math.PI; ) e5.x -= 2 * Math.PI;
}
function um2(e5, t3, s4, n6) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const i2 = [s4.x], o = [s4.y - n6], a2 = [s4.x], h2 = [s4.y + n6];
    Vs3(i2, o), Vs3(a2, h2);
    const m3 = n(r, new Cc(), false), l2 = n(r, new Cc(), false);
    Dc.greatEllipticDistance(e5, t3, s4.x, s4.y, i2[0], o[0], m3, null, null), Dc.greatEllipticDistance(e5, t3, s4.x, s4.y, a2[0], h2[0], l2, null, null);
    return Math.min(m3.val, l2.val);
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    s(r);
  }
}
function cm2(t3, s4, n6, r, i2) {
  const o = new n4();
  n6.queryEnvelope(o);
  const a2 = Bt2(null, n6, true).total();
  if (s4.xmin - o.xmin <= a2 && o.xmax - s4.xmax <= a2) return n6;
  const h2 = s4.width();
  let m3 = 0;
  for (; s4.xmin + m3 * h2 < o.xmin; ) m3++;
  for (; s4.xmin + m3 * h2 > o.xmin; ) m3--;
  const l2 = m3 * h2, g2 = new x3();
  g2.setShiftCoords(-l2, 0);
  const u = n6;
  u.applyTransformation(g2);
  const c = new n4();
  u.queryEnvelope(c);
  let _ = null;
  if (c.xmax > s4.xmax) {
    let n7 = 0;
    const r2 = new n4();
    r2.setCoords({ env2D: s4 }), r2.ymin -= 1, r2.ymax += 1;
    let o2 = u;
    for (; r2.xmin < c.xmax; ) {
      c.xmax > r2.xmax && (o2 = Hl(o2, t3, 2, true, r2.xmax));
      const e5 = Dt2(o2, r2), a3 = At(null, e5, true).total(), m4 = f2(o2, r2, a3, Number.NaN, i2);
      null === _ ? _ = m4 === o2 ? m4.clone() : m4 : (g2.setShiftCoords(-n7 * h2, 0), m4.applyTransformation(g2), _.add(m4, false)), n7++, r2.xmin = r2.xmax, r2.xmax = s4.xmax + n7 * h2;
    }
  } else _ = u;
  return _;
}
var _m2 = class {
  constructor(e5, t3) {
    this.m_basisX = new X(), this.m_basisY = new X(), this.m_normal = new X(), n2(1 === e5.getCoordinateSystemType()), this.m_gcs = e5;
    const s4 = Hu2();
    e5.querySpheroidData(s4), this.m_a = s4.majorSemiAxis, this.m_e2 = s4.e2, this.m_rpu = e5.getUnit().getUnitToBaseFactor(), this.m_curvCenterRad = t3.mul(this.m_rpu);
    const n6 = this.m_curvCenterRad.x, r = this.m_curvCenterRad.y, i2 = Math.cos(n6), o = Math.sin(n6), h2 = Math.cos(r), m3 = Math.sin(r);
    this.m_cartCenter3D = fs3(this.m_a, this.m_e2, i2, o, h2, m3), this.m_normal.setCoordsPoint3D(this.m_cartCenter3D), this.m_d = this.m_cartCenter3D.length(), this.m_normal.divThis(this.m_d), X.selectRightHandedBasisFromNormal(this.m_normal, this.m_basisX, this.m_basisY), this.m_northPolePcs = this.projectPoint(mi.construct(0, 0.5 * Math.PI / this.m_rpu)), this.m_southPolePcs = this.projectPoint(mi.construct(0, 0.5 * -Math.PI / this.m_rpu));
  }
  project(e5) {
    const s4 = e5.getGeometryType();
    if (y(s4)) {
      N(e5);
      const t3 = e5;
      return this.projectMultiVertex(t3);
    }
    P("Gnomonic.project");
  }
  unproject(e5, s4, r) {
    const i2 = e5.getGeometryType();
    if (y(i2)) {
      N(e5);
      let t3 = e5;
      const a2 = [];
      if (i2 === a.enumPolygon) {
        const e6 = t3.getPathCount();
        for (let s5 = 0; s5 < e6; s5++) {
          const e7 = t3.calculateRingArea2D(s5);
          a2.push(e7);
        }
      }
      return this.unprojectMultiVertex(s4, t3), h(i2) ? (Cm(this.m_gcs, 0, t3), dm2(a2, this.m_gcs, 0, t3, r)) : t3 = vl(t3, this.m_gcs, 0, true, 0, r), t3;
    }
    P("Gnomonic.unproject");
  }
  projectPoint(e5) {
    const t3 = e5.mul(this.m_rpu), s4 = ds3(this.m_a, this.m_e2, t3), n6 = this.m_normal.dotProduct(s4);
    if (n6 <= 0) return mi.construct(Number.NaN, Number.NaN);
    const r = this.m_d / n6, i2 = s4.mul(r).sub(this.m_cartCenter3D), o = new mi();
    return o.x = this.m_basisX.dotProduct(i2), o.y = this.m_basisY.dotProduct(i2), o;
  }
  unprojectPoint(e5) {
    const t3 = this.m_cartCenter3D.add(this.m_basisX.mul(e5.x).add(this.m_basisY.mul(e5.y)));
    return Ps3(this.m_a, this.m_e2, t3).divide(this.m_rpu);
  }
  projectMultiVertex(e5) {
    const t3 = e5.getImpl();
    let s4 = true;
    const n6 = new mi(), r = new mi();
    for (let i2 = 0, o = t3.getPointCount(); i2 < o; i2++) t3.queryXY(i2, n6), n6.y * this.m_rpu > 0.5 * Math.PI ? r.assign(this.m_northPolePcs) : n6.y * this.m_rpu < 0.5 * -Math.PI ? r.assign(this.m_southPolePcs) : r.assign(this.projectPoint(n6)), t3.setXYNoCurves(i2, r), r.isNAN() && (s4 = false);
    return t3.notifyModifiedFlags(2001), s4;
  }
  unprojectMultiVertex(e5, t3) {
    const s4 = t3.getImpl(), n6 = e5 * e5, r = !this.m_northPolePcs.isNAN(), i2 = !this.m_southPolePcs.isNAN();
    for (let o = 0, a2 = s4.getPointCount(); o < a2; o++) {
      const e6 = s4.getXY(o);
      let t4 = new mi();
      r && mi.sqrDistance(e6, this.m_northPolePcs) <= n6 ? (t4.setCoords(this.m_curvCenterRad.x, 0.5 * Math.PI), t4.scale(1 / this.m_rpu)) : i2 && mi.sqrDistance(e6, this.m_southPolePcs) <= n6 ? (t4.setCoords(this.m_curvCenterRad.x, 0.5 * -Math.PI), t4.scale(1 / this.m_rpu)) : t4 = this.unprojectPoint(e6), s4.setXYNoCurves(o, t4);
    }
    s4.notifyModifiedFlags(2001);
  }
};
function dm2(t3, s4, r, i2, o) {
  const a2 = i2.getGeometryType(), h2 = s4.getPannableExtent();
  let m3 = i2, l2 = false, g2 = false;
  if (a2 === a.enumPolygon) {
    const n6 = new n4(), i3 = mi.construct(r, 0);
    n6.setCoords({ env2D: h2 }), n6.centerAt(i3), l2 = pm2(t3, s4, n6, m3, o);
    const a3 = Sm(s4, n6, m3, o);
    a3 !== m3 && (g2 = true), m3 = a3;
  } else m3 = new qh().foldInto360RangeGeodetic(m3, s4, 2);
  a2 === a.enumPolygon && (l2 || g2) && (m3 = new Eh2().execute(m3, s4, false, o)), m3 !== i2 && (i2.setEmpty(), i2.add(m3, false));
}
function pm2(e5, t3, s4, n6, r) {
  const i2 = fm2(s4, n6), o = xm(e5, t3, s4, n6, r);
  return i2 || o;
}
function fm2(t3, s4) {
  const n6 = new n4();
  s4.queryEnvelope(n6);
  const r = Pc(t3.ymax, n6.ymax), i2 = Pc(t3.ymin, n6.ymin), o = r || i2;
  return !!o && (ym(t3, s4), o);
}
function xm(e5, t3, s4, n6, r) {
  const i2 = [], o = [], a2 = 0.5 * s4.width();
  for (let g2 = 0; g2 < n6.getPathCount(); g2++) {
    const h3 = n6.getXY(n6.getPathStart(g2)), m4 = n6.getXY(n6.getPathEnd(g2) - 1), l3 = e5[g2] < 0;
    if (Math.abs(h3.x - m4.x) > a2) {
      const e6 = Pm(l3, t3, s4, g2, n6, r);
      i2.push(e6), o.push(g2);
    } else if (!l3) {
      if (n6.calculateRingArea2D(g2) < 0) {
        const e6 = Em(t3, s4, g2, n6, r);
        i2.push(e6), o.push(g2);
      }
    }
  }
  if (0 === i2.length) return false;
  const h2 = new ur({ vd: n6.getDescription() });
  let m3 = 0, l2 = o[m3];
  for (let g2 = 0; g2 < n6.getPathCount(); g2++) g2 === l2 ? (h2.add(i2[m3], false), m3++, m3 < o.length && (l2 = o[m3])) : h2.addPath(n6, g2, true);
  return n6.setEmpty(), n6.add(h2, false), true;
}
function ym(t3, s4) {
  const n6 = new ur(), r = new n4();
  for (let e5 = 0; e5 < s4.getPathCount(); e5++) {
    s4.queryPathEnvelope(e5, r);
    let i2 = Pc(t3.ymax, r.ymax), o = Pc(t3.ymin, r.ymin);
    if (!(i2 || o)) {
      n6.addPath(s4, e5, true);
      continue;
    }
    n6.insertPath2D(-1, null, 0, 0, true);
    const a2 = s4.getPathStart(e5), h2 = s4.getPathEnd(e5), m3 = h2 - a2;
    let l2 = -1;
    for (l2 = a2; l2 < h2; l2++) {
      const e6 = s4.getXY(l2);
      if (i2 = Pc(t3.ymax, e6.y), o = Pc(t3.ymin, e6.y), !i2 && !o) break;
    }
    let g2 = l2, u = false, c = Number.NaN;
    do {
      const r2 = s4.getXY(g2);
      i2 = Pc(t3.ymax, r2.y), o = Pc(t3.ymin, r2.y);
      const h3 = a2 + (g2 + 1 - a2) % m3;
      if (i2 || o) {
        let i3 = mi.construct(c, r2.y);
        n6.insertPoint2D(e5, -1, i3);
        const o2 = s4.getXY(h3), a3 = Pc(t3.ymax, o2.y), m4 = Pc(t3.ymin, o2.y);
        a3 || m4 || (i3 = mi.construct(o2.x, r2.y), u ? n6.setXYNoCurves(n6.getPointCount() - 1, i3) : n6.insertPoint2D(e5, -1, i3)), u = true;
      } else n6.insertPoint2D(e5, -1, r2), c = r2.x, u = false;
      g2 = h3;
    } while (g2 !== l2);
  }
  s4.setEmpty(), s4.add(n6, false);
}
function Pm(t3, s4, n6, r, i2, o) {
  const a2 = new ur(), h2 = new ur(), m3 = new x3(), l2 = i2.getXY(i2.getPathStart(r)), g2 = i2.getXY(i2.getPathEnd(r) - 1), u = n6.width(), c = 0.5 * u, _ = new n4();
  i2.queryEnvelope(_);
  const d2 = Math.ceil(_.width() / u) + 1;
  let p3, f3;
  l2.x > g2.x ? (p3 = -u, f3 = t3 ? n6.ymin : n6.ymax) : (p3 = u, f3 = t3 ? n6.ymax : n6.ymin), m3.setShiftCoords(p3, 0), a2.addPath(i2, r, true), h2.add(a2, false);
  const x4 = new ee();
  for (let e5 = 0; e5 < d2; e5++) h2.applyTransformation(m3), h2.getPointByVal(0, x4), a2.lineToPoint(x4), a2.addSegmentsFromPath(h2, 0, 0, h2.getSegmentCount() - 1, false);
  const y2 = a2.getXY(0), P5 = a2.getXY(a2.getPointCount() - 1);
  y2.y = f3, P5.y = f3, a2.lineTo(P5);
  const E2 = new mi();
  for (E2.setCoordsPoint2D(P5), E2.x -= 0.5 * p3; Math.abs(E2.x - y2.x) > c; ) a2.lineTo(E2), E2.x -= 0.5 * p3;
  a2.lineTo(y2);
  const S3 = n6.getCenter().x, C3 = new n4();
  a2.queryEnvelope(C3);
  let I4 = 0;
  const b2 = C3.getCenter().x;
  b2 - S3 > c ? I4 = -Math.ceil((b2 - S3 - c) / u) : S3 - b2 > c && (I4 = Math.ceil((S3 - b2 - c) / u)), 0 !== I4 && (m3.setShiftCoords(I4 * u, 0), a2.applyTransformation(m3));
  const w4 = new Pr(), N2 = w4.addGeometry(a2);
  kl(w4, N2, s4, 0, 2, true, n6.xmin), kl(w4, N2, s4, 0, 2, true, n6.xmax);
  const T3 = w4.getGeometry(N2), D3 = Dt2(T3, n6);
  D3.inflateCoords(0, 1);
  const V4 = At(null, D3, true);
  return f2(T3, n6, V4.total(), Number.NaN, o);
}
function Em(t3, s4, n6, r, i2) {
  const o = s4.width(), a2 = 0.5 * o, h2 = s4.getCenter().x, m3 = new n4();
  r.queryPathEnvelope(n6, m3);
  let l2, g2 = 0, u = m3.getCenter().x;
  if (u - h2 > a2 ? g2 = -Math.ceil((u - h2 - a2) / o) : h2 - u > a2 && (g2 = Math.ceil((h2 - u - a2) / o)), 0 !== g2) {
    const e5 = new x3();
    e5.setShiftCoords(g2 * o, 0), r.getImpl().applyTransformationToPath(e5, n6), r.queryPathEnvelope(n6, m3), u = m3.getCenter().x;
  }
  const c = new n4();
  s4.containsExclusiveEnvelope(m3) ? (l2 = false, c.setCoords({ env2D: s4 })) : (l2 = true, c.setCoords({ env2D: s4 }), c.xmin -= o, c.xmax += o);
  let _ = r.createInstance();
  _.addPathPoint2D(null, 0, true);
  const d2 = new mi();
  if (d2.setCoords(c.xmin, c.ymin), _.insertPoint2D(0, -1, d2), d2.setCoords(c.xmin, c.ymax), _.insertPoint2D(0, -1, d2), d2.setCoords(0.5 * (c.xmin + c.xmax), c.ymax), _.insertPoint2D(0, -1, d2), d2.setCoords(c.xmax, c.ymax), _.insertPoint2D(0, -1, d2), d2.setCoords(c.xmax, c.ymin), _.insertPoint2D(0, -1, d2), d2.setCoords(0.5 * (c.xmin + c.xmax), c.ymin), _.insertPoint2D(0, -1, d2), l2) {
    _.addPath(r, n6, true);
    const e5 = new x3();
    u < h2 ? e5.setShiftCoords(o, 0) : e5.setShiftCoords(-o, 0), r.getImpl().applyTransformationToPath(e5, n6), _.addPath(r, n6, true);
    const a3 = new Pr(), m4 = a3.addGeometry(_);
    kl(a3, m4, t3, 0, 2, true, s4.xmin), kl(a3, m4, t3, 0, 2, true, s4.xmax), _ = a3.getGeometry(m4);
    const l3 = Dt2(_, s4);
    l3.inflateCoords(0, 1);
    const g3 = At(null, l3, true).total();
    _ = f2(_, s4, g3, Number.NaN, i2);
  } else _.addPath(r, n6, true);
  return _;
}
function Sm(t3, s4, n6, r) {
  const i2 = new n4();
  n6.queryEnvelope(i2);
  const o = Bt2(null, n6, true).total();
  if (s4.xmin - i2.xmin <= o && i2.xmax - s4.xmax <= o) return n6;
  const a2 = n6.createInstance();
  let h2 = n6.createInstance();
  const m3 = new n4(), l2 = n6.getPathCount();
  for (let e5 = 0; e5 < l2; e5++) n6.queryPathEnvelope(e5, m3), s4.xmin - m3.xmin <= o && m3.xmax - s4.xmax <= o ? a2.addPath(n6, e5, true) : (h2.setEmpty(), h2.addPath(n6, e5, true), h2 = cm2(t3, s4, h2, true, r), a2.add(h2, true));
  return a2;
}
function Cm(e5, t3, s4) {
  const n6 = e5.getPannableExtent(), r = mi.construct(t3, 0);
  n6.centerAt(r);
  const i2 = n6.width(), o = 0.5 * i2, a2 = new mi();
  a2.setNAN();
  let h2 = Number.NaN;
  for (let m3 = 0; m3 < s4.getPathCount(); m3++) for (let e6 = s4.getPathStart(m3); e6 < s4.getPathEnd(m3); e6++) {
    const t4 = s4.getXY(e6), r2 = Pc(t4.y, n6.ymax) || Pc(n6.ymin, t4.y);
    e6 === s4.getPathStart(m3) ? (a2.setNAN(), h2 = 0) : a2.isNAN() || r2 || (h2 = Im(t4.x, a2.x, o, i2, h2)), t4.x += h2, s4.setXYNoCurves(e6, t4), r2 || a2.setCoordsPoint2D(t4);
  }
  s4.getImpl().notifyModifiedFlags(2001);
}
function Im(e5, t3, s4, n6, r) {
  return r + e5 - t3 > s4 ? r -= n6 : t3 - (r + e5) > s4 && (r += n6), r;
}
function bm(e5, t3, s4, n6, r, i2) {
  const o = t3.getAttributeStreamRef(0), a2 = t3.getPointCount();
  let h2 = false;
  const m3 = new mi();
  for (let P5 = 0; P5 < a2; ++P5) {
    if (o.queryPoint2D(2 * P5, m3), 1 & i2 && m3.y >= s4) {
      h2 = true;
      break;
    }
    if (2 & i2 && m3.y <= -s4) {
      h2 = true;
      break;
    }
  }
  if (!h2) return false;
  let l2 = false;
  e5 && (l2 = t3.getImpl().isClosedPathInXYPlane(0));
  const g2 = new Pr(), u = g2.addGeometry(t3), c = g2.getFirstPath(u);
  let _ = -1, d2 = true;
  const p3 = new mi(), f3 = new ee();
  let x4 = cr;
  const y2 = Gm * r / 360;
  for (let P5 = g2.getFirstVertex(c); P5 !== cr; P5 = g2.getNextVertex(P5)) {
    g2.queryXY(P5, m3);
    let e6 = 1 & i2 && m3.y >= s4 ? 1 : 0;
    if (e6 |= 2 & i2 && m3.y <= -s4 ? 2 : 0, _ > 0 && _ !== e6) {
      if (p3.x !== m3.x) {
        const e7 = g2.getPrevVertex(P5);
        g2.queryPoint(e7, f3);
        const t4 = g2.insertVertex(c, P5, f3);
        p3.x = m3.x, g2.setXY(t4, p3);
      }
      if (l2) {
        let e7 = x4 !== cr ? g2.getNextVertex(x4) : g2.getFirstVertex(c);
        const t4 = g2.getPrevVertex(P5);
        for (; e7 !== t4; ) e7 = g2.removeVertex(e7, false);
        if (x4 !== cr) {
          const e8 = g2.getXY(x4), s5 = g2.getXY(t4);
          if (Math.abs(e8.x - s5.x) > y2) {
            g2.queryPoint(x4, f3);
            const n7 = g2.insertVertex(c, t4, f3);
            e8.x = Q(e8.x, s5.x, 0.5), g2.setXY(n7, e8);
          }
        }
      }
      x4 = cr;
    }
    if (e6 && (m3.y = B2(n6, m3.y), g2.setXY(P5, m3), !d2 && _ !== e6)) if (m3.x !== p3.x) {
      g2.queryPoint(P5, f3);
      const e7 = g2.insertVertex(c, P5, f3);
      g2.setXYCoords(e7, p3.x, m3.y), x4 = e7;
    } else x4 = P5;
    _ = e6, p3.assign(m3), d2 = false;
  }
  if (l2) {
    if (x4 !== cr) {
      let e7 = g2.getNextVertex(x4);
      for (; e7 !== cr; ) e7 = g2.removeVertex(e7, false);
    }
    const e6 = g2.getFirstVertex(c);
    let t4 = g2.getLastVertex(c);
    const s5 = g2.getXY(e6), n7 = g2.getXY(t4);
    if (!s5.equals(n7) && (g2.queryPoint(e6, f3), t4 = g2.insertVertex(c, cr, f3), Math.abs(s5.x - n7.x) > y2)) {
      const e7 = g2.insertVertex(c, t4, f3);
      s5.x = Q(s5.x, n7.x, 0.5), g2.setXY(e7, s5);
    }
  }
  return t3.assignCopy(g2.getGeometry(u)), true;
}
function wm(e5, t3) {
  let s4 = new ur({ vd: e5 });
  s4.addEnvelope(t3, false);
  const n6 = t3.width() / 180;
  return s4 = new m2().execute(s4, n6, 0, 0, null), s4;
}
function vm(e5, t3) {
  const s4 = e5.getPannableExtent();
  return Number.isNaN(t3) || s4.centerAtCoords(t3, 0), s4;
}
function Nm(e5, t3, s4) {
  const n6 = Hu2();
  t3.querySpheroidData(n6);
  const r = t3.getGCS() !== t3 ? t3.getSRToGCSTransform() : null, i2 = Ot(mi, 100), o = new X(0, 0, 0), a2 = e5.getPointCount(), h2 = t3.getGCS().getUnit().getUnitToBaseFactor();
  for (let u = 0, c = a2; u < c; ) {
    const t4 = Math.min(100, c - u);
    e5.queryCoordinates(i2, t4, u, u + t4), r && new qh().transform(r, i2, t4, i2, false);
    for (let e6 = 0; e6 < t4; e6++) {
      if (i2[e6].isNAN()) continue;
      i2[e6].scale(h2);
      const t5 = ds3(n6.majorSemiAxis, n6.e2, i2[e6]);
      o.addThis(t5);
    }
    u += t4;
  }
  const m3 = Ps3(n6.majorSemiAxis, n6.e2, o);
  m3.scale(1 / h2);
  const l2 = e5;
  if (!new _m2(t3.getGCS(), m3).project(l2)) return 0;
  s4.length = e5.getPathCount();
  const g2 = l2.calculateArea2D() < 0;
  for (let u = 0, c = e5.getPathCount(); u < c; u++) {
    const e6 = l2.calculateRingArea2D(u), t4 = g2 ? e6 < 0 : e6 > 0;
    s4[u] = t4;
  }
  return g2 ? -1 : 1;
}
function Tm(e5, t3, s4, r, o) {
  if (!t3.isPannable() || e5.isEmpty()) return e5;
  const a2 = e5.getGeometryType();
  a2 === a.enumGeometryCollection && z("not yet impl for geometry collection");
  const h2 = t3.getPannableExtent();
  Number.isNaN(s4) && (s4 = h2.getCenterX());
  const m3 = h2.width(), l2 = 0.5 * m3, g2 = o > 0, c = e5.queryInterval(0, 0);
  if (!g2 && c.width() < l2 || !y(e5.getGeometryType())) {
    const t4 = c.getCenter();
    if (Math.abs(t4 - s4) <= l2) return e5;
    {
      const n6 = new x3(), r2 = S((s4 - t4) / m3) * m3;
      n6.setShiftCoords(r2, 0);
      const i2 = e5.clone();
      return i2.applyTransformation(n6), i2;
    }
  }
  if (a2 === a.enumPolygon) {
    let n6 = new Os2({ vd: e5.getDescription() });
    n6.addAndExplicitlyOpenAllPaths(e5, false), g2 && (n6 = Oh(n6, t3, 2, o, Number.NaN, null, true));
    const i2 = [];
    if (!r) {
      {
        let s5 = e5;
        g2 && (s5 = new ur(), s5.add(n6, false));
        const r2 = Nm(e5, t3, i2);
        if (r2) r2 < 0 && n6.reverseAllPaths();
        else {
          const e6 = s5.getPathCount();
          for (let t4 = 0; t4 < e6; t4++) i2.push(s5.calculateRingArea2D(t4) > 0);
        }
      }
      r = i2;
    }
    return new Dm(null, r, n6, null, t3, s4, 3, 0, null).geoNormalizePolygonGeometry(true);
  }
  if (a2 === a.enumPolyline) {
    let n6 = new Os2({ vd: e5.getDescription() });
    n6.addAndExplicitlyOpenAllPaths(e5, false), g2 && (n6 = Oh(n6, t3, 2, o, Number.NaN, null, true));
    return new Dm(null, null, n6, null, t3, s4, 3, 0, null).geoNormalizePolylineGeometry(true);
  }
  if (a2 === a.enumMultiPoint) {
    const t4 = e5, n6 = t4.getAttributeStreamRef(0);
    let r2, i2 = null, o2 = s4, a3 = 0;
    const h3 = 0.1 * m3;
    for (let s5 = 0, g3 = t4.getPointCount(); s5 < g3; s5++) {
      const t5 = n6.read(2 * s5);
      let g4 = t5 - o2;
      if (Math.abs(g4) > l2 && (g4 = S(g4 / m3) * m3, a3 -= g4, Math.abs(a3) < h3 && (a3 = 0)), 0 !== a3) {
        i2 || (r2 = e5.clone(), i2 = r2.getAttributeStreamRef(0));
        const n7 = t5 + a3;
        i2.write(2 * s5, n7);
      }
      o2 = t5;
    }
    return i2 ? (r2.notifyModified(), r2) : e5;
  }
  b("");
}
var Gm = 210;
var Dm = class {
  constructor(e5, t3, s4, n6, r, i2, o, h2, m3) {
    this.m_bAdjustedAtPoles = 0, this.m_inputPoly = s4, this.m_progressTracker = m3, this.m_originalGeometry = e5, this.m_originalSR = n6, this.m_polygonRingFlags = t3, this.m_pannableSR = r, this.m_poleSnappingTolerance = h2, this.m_poleFlags = o, this.m_bAdjustedAtPoles = 0, this.m_pannableExtent = vm(this.m_pannableSR, i2), this.m_centralLongitude = Number.isNaN(i2) ? this.m_pannableExtent.getCenterX() : i2, this.m_width360 = this.m_pannableExtent.width(), this.m_degree = this.m_width360 / 360, this.m_GCSLargeDelta = Gm * this.m_degree, n2(null === this.m_originalGeometry && null === this.m_originalSR || null !== this.m_originalGeometry && null !== this.m_originalSR);
  }
  geonormalizeRing(e5, t3, s4, n6, r, o, h2) {
    let m3 = s4;
    const l2 = new Os2({ vd: this.m_inputPoly.getDescription() });
    l2.addPath(this.m_inputPoly, e5, true), 0 !== this.m_poleFlags && (this.m_bAdjustedAtPoles |= bm(true, l2, this.m_pannableExtent.ymax - this.m_poleSnappingTolerance, this.m_pannableExtent.ymax, this.m_pannableExtent.width(), this.m_poleFlags) ? 1 : 0, this.m_bAdjustedAtPoles && (m3 = false));
    let g2 = -1;
    m3 && (g2 = this.m_originalGeometry.getPathStart(e5));
    const u = l2.getAttributeStreamRef(0), c = l2.getPointCount();
    let _ = 0, d2 = u.read(0), p3 = 0;
    const f3 = 3 * this.m_pannableSR.getTolerance(0);
    let x4 = false;
    const y2 = new mi(), P5 = new mi();
    let E2 = false;
    const S3 = l2.hasNonLinearSegments(), C3 = new mi();
    for (let a2 = 1; a2 < c; ++a2) {
      u.queryPoint2D(2 * a2, C3);
      const e6 = C3.x;
      let t4 = e6 + _;
      const s5 = t4 - d2;
      if (C3.x = t4, Math.abs(s5) > this.m_GCSLargeDelta) {
        if (m3) {
          const e7 = g2 + a2 - 1, t5 = g2 + (a2 + 1 < c ? a2 : 0), r2 = o.read(2 * e7), i2 = (o.read(2 * t5) - r2) * n6;
          Math.abs(s5 - i2) > 1 * this.m_degree && (m3 = false);
        }
        if (!m3) {
          _ -= B2(this.m_width360, t4 - d2), t4 = e6 + _, ++p3, E2 = 0 !== _, C3.x = t4;
        }
      } else x4 || bt(y2, P5, C3, f3) && (x4 = true);
      E2 && (S3 && b("error in geonormalize_ring_ for curves"), u.write(2 * a2, t4)), d2 = t4, y2.setCoordsPoint2D(P5), P5.setCoordsPoint2D(C3);
    }
    p3 && l2.notifyModified();
    const b2 = l2.getXY(0), w4 = l2.getXY(c - 1);
    if (mi.distance(b2, w4) < f3) {
      const e6 = this.finalizeGeoNormalizeClosedRing(l2, x4, r);
      h2.add(e6, false);
    } else {
      if (t3 < 0) if (null !== this.m_originalGeometry) {
        n2(null !== this.m_originalGeometry);
        t3 = this.m_originalGeometry.calculateRingArea2D(e5) > 0 ? 1 : 0;
      } else t3 = 1;
      const s5 = this.finalizeGeoNormalizeOpenedRing(t3 > 0, l2);
      h2.add(s5, false);
    }
  }
  geoNormalizePolygonGeometry(t3) {
    n2(this.m_originalSR && this.m_originalGeometry || !this.m_originalGeometry && !this.m_originalSR), n2(this.m_pannableSR.isPannable());
    let s4 = null, n6 = Number.NaN;
    const r = !!this.m_originalSR && this.m_originalSR.isPannable();
    r && (s4 = this.m_originalGeometry.getAttributeStreamRef(0), n6 = this.m_width360 / this.m_originalSR.getPannableExtent().width()), this.m_bAdjustedAtPoles = 0;
    const i2 = new ur({ vd: this.m_inputPoly.getDescription() });
    for (let e5 = 0, a2 = this.m_inputPoly.getPathCount(); e5 < a2; ++e5) {
      const o2 = this.m_polygonRingFlags ? this.m_polygonRingFlags[e5] ? 1 : 0 : -1;
      this.geonormalizeRing(e5, o2, r, n6, t3, s4, i2);
    }
    const o = this.m_pannableSR.getTolerance(0), h2 = this.m_pannableExtent.width() / 180;
    Ol(i2, this.m_pannableExtent, 0.1 * o, false);
    const m3 = n4.constructEmpty();
    if (m3.setCoords({ env2D: this.m_pannableExtent }), t3) {
      let t4 = true;
      for (let s5 = 0; s5 < 2; s5++) {
        t4 = true;
        const s6 = n4.constructEmpty();
        for (let e5 = 0, n7 = i2.getPathCount(); e5 < n7; e5++) if (i2.queryPathEnvelope(e5, s6), !(m3.xmin <= s6.xmin && m3.xmax >= s6.xmax || s6.xmin >= m3.xmax || s6.xmax <= m3.xmin)) {
          t4 = false;
          break;
        }
        if (t4) break;
        m3.move(0.5 * this.m_width360, 0);
      }
      t4 || m3.setCoords({ env2D: this.m_pannableExtent });
    }
    let l2 = f2(i2, m3, o, h2, this.m_progressTracker), g2 = i2 !== l2;
    const u = this.m_originalGeometry ? this.m_originalGeometry.calculateArea2D() : 1, c = l2.calculateArea2D();
    let _ = 0;
    if (c > 0 && u < 0) _ = 1;
    else if (c <= 0 && u > 0) if (0 === c) {
      if (this.m_originalSR) {
        let e5 = Number.NaN;
        2 === this.m_originalSR.getCoordinateSystemType() ? e5 = this.m_originalSR.getPCSHorizon().calculateArea2D() : 1 === this.m_originalSR.getCoordinateSystemType() && (e5 = this.m_originalSR.getPannableExtent().getArea()), u > 0.99 * e5 && (_ = -1);
      }
    } else _ = -1;
    if (0 !== _) {
      const e5 = wm(l2.getDescription(), m3);
      e5.add(l2, false), g2 = true, l2 = e5;
    }
    return g2 && (l2 = new Eh2().execute(l2, this.m_pannableSR, false, this.m_progressTracker)), l2;
  }
  geoNormalizePolylineGeometry(t3) {
    n2(this.m_pannableSR.isPannable());
    let s4 = null;
    const n6 = this.m_originalSR && this.m_originalSR.isPannable();
    let r = 1;
    n6 && (n2(this.m_originalGeometry), r = this.m_width360 / this.m_originalSR.getPannableExtent().width(), s4 = this.m_originalGeometry.getAttributeStreamRef(0));
    const o = this.m_pannableExtent.width(), h2 = o * Qs() * 4;
    let m3 = t3, l2 = Number.NaN;
    const g2 = x2.constructEmpty();
    this.m_bAdjustedAtPoles = 0;
    let u = new Os2({ vd: this.m_inputPoly.getDescription() });
    for (let d2 = 0, p3 = this.m_inputPoly.getPathCount(); d2 < p3; ++d2) {
      let t4 = n6;
      const c2 = new Os2({ vd: this.m_inputPoly.getDescription() });
      c2.addPath(this.m_inputPoly, d2, true);
      const _2 = this.m_inputPoly.isClosedPath(d2);
      0 !== this.m_poleFlags && (this.m_bAdjustedAtPoles |= bm(_2, c2, this.m_pannableExtent.ymax - this.m_poleSnappingTolerance, this.m_pannableExtent.ymax, o, this.m_poleFlags) ? 1 : 0, this.m_bAdjustedAtPoles && (t4 = false));
      let p4 = -1;
      const f3 = c2.getPointCount();
      let x4 = false;
      t4 && (p4 = this.m_originalGeometry.getPathStart(d2), x4 = this.m_originalGeometry.isClosedPath(d2));
      const y2 = c2.getAttributeStreamRef(0);
      let P5 = 0, E2 = y2.read(0), S3 = 0;
      const C3 = new mi(), b2 = new mi();
      let w4 = false;
      const v3 = c2.hasNonLinearSegments(), N2 = new mi();
      for (let e5 = 1; e5 < f3; ++e5) {
        y2.queryPoint2D(2 * e5, N2);
        const n7 = N2.x;
        let o2 = n7 + P5;
        const a2 = o2 - E2;
        if (N2.x = o2, Math.abs(a2) > this.m_GCSLargeDelta) {
          if (t4) {
            const n8 = p4 + e5 - 1;
            let i2 = p4;
            (!x4 || e5 + 1 < f3) && (i2 += e5);
            const o3 = s4.read(2 * n8), h3 = (s4.read(2 * i2) - o3) * r;
            Math.abs(a2 - h3) > 1 * this.m_degree && (t4 = false);
          }
          if (!t4) {
            P5 -= B2(this.m_width360, o2 - E2), o2 = n7 + P5, ++S3, w4 = 0 !== P5, N2.x = o2;
          }
        }
        w4 && (v3 && b("error in geonormalize_ring_ for curves"), y2.write(2 * e5, o2)), E2 = o2, C3.setCoordsPoint2D(b2), b2.setCoordsPoint2D(N2);
      }
      if (S3 && c2.notifyModified(), m3) {
        let t5 = false;
        if (!c2.isEmpty()) {
          const s5 = n4.constructEmpty();
          if (c2.queryEnvelope(s5), s5.width() >= o || s5.ymin <= this.m_pannableExtent.ymin || s5.ymax >= this.m_pannableExtent.ymax) t5 = true;
          else {
            if (Number.isNaN(l2)) {
              const e6 = this.m_centralLongitude - 0.5 * o;
              l2 = s5.xmin, l2 += Math.round((e6 - s5.xmin) / o) * o, l2 > e6 && (l2 -= o), n2(l2 <= e6), l2 < e6 && (l2 += o), n2(l2 >= e6);
            }
            let e5 = Math.round((l2 - s5.xmin) / o) * o;
            if (s5.xmin + e5 > l2 + h2 && (e5 -= o), s5.xmin + e5 < l2 - h2 && (e5 += o), g2.mergeCoordinate(s5.xmin + e5), g2.mergeCoordinate(s5.xmax + e5), t5 = g2.width() >= o, !t5) {
              const t6 = new x3();
              t6.setShiftCoords(e5, 0), c2.applyTransformation(t6);
            }
          }
        }
        u.add(c2, false), t5 && (u = (() => {
          const e5 = new Os2({ vd: u.getDescription() });
          for (let t6 = 0, s5 = u.getPathCount(); t6 < s5; ++t6) {
            const s6 = new Os2({ vd: u.getDescription() });
            s6.addPath(u, t6, true);
            const n7 = vl(s6, this.m_pannableSR, this.m_centralLongitude, true, 0, this.m_progressTracker);
            e5.add(n7, false);
          }
          return e5;
        })(), m3 = false);
      } else {
        const e5 = vl(c2, this.m_pannableSR, this.m_centralLongitude, true, 0, this.m_progressTracker);
        u.add(e5, false);
      }
    }
    if (m3) return u;
    const c = this.m_pannableSR.getTolerance(0), _ = this.m_pannableExtent.width() / 180;
    Ol(u, this.m_pannableExtent, 0.1 * c, false);
    return f2(u, this.m_pannableExtent, c, _, this.m_progressTracker);
  }
  finalizeGeoNormalizeOpenedRing(t3, s4) {
    const n6 = s4.getPointCount(), r = s4.getXY(0), i2 = s4.getXY(n6 - 1);
    {
      const e5 = Math.abs(i2.x - r.x), t4 = Math.round(e5 / this.m_width360) * this.m_width360;
      n2(Math.abs(e5 - t4) < this.m_pannableSR.getTolerance(0));
    }
    const o = K(i2.x - r.x), h2 = n4.constructEmpty();
    s4.queryLooseEnvelope(h2);
    const m3 = this.m_pannableExtent.getCenterX();
    let l2 = 0, g2 = m3 - this.m_width360, u = m3 + this.m_width360;
    if (o >= 0) {
      let e5 = Math.ceil((g2 - h2.xmin) / this.m_width360);
      for (e5 *= this.m_width360; g2 > h2.xmin + e5; ) e5 += this.m_width360;
      for (; g2 < h2.xmax + e5; ) e5 -= this.m_width360;
      for (l2 = e5, h2.width() > 720 && (u = g2 + 360 * Math.ceil(h2.width() / 360)); u < h2.xmax; ) u += this.m_width360;
    } else {
      let e5 = Math.ceil((u - h2.xmax) / this.m_width360);
      for (e5 *= this.m_width360; u < h2.xmax + e5; ) e5 -= this.m_width360;
      for (; u > h2.xmin + e5; ) e5 += this.m_width360;
      for (l2 = e5, h2.width() > 720 && (g2 = u - 360 * Math.ceil(h2.width() / 360)); g2 > h2.xmin; ) g2 -= this.m_width360;
    }
    const c = Math.round(Math.abs(i2.x - r.x) / this.m_width360) * this.m_width360, _ = o * c, d2 = h2.clone();
    d2.move(l2, 0);
    const p3 = new mi(0, 0), f3 = new x3();
    f3.setShiftCoords(l2, 0), s4.applyTransformation(f3);
    const x4 = new Os2({ vd: s4.getDescription() });
    x4.add(s4, false), p3.assign(s4.getXY(n6 - 1));
    let y2 = 0, P5 = x4.getXY(0).x;
    for (; o > 0 ? d2.xmax < u : d2.xmin > g2; ) d2.move(_, 0), f3.xd = _, s4.applyTransformation(f3), P5 += _, this.m_pannableExtent.xmin <= P5 && this.m_pannableExtent.xmax >= P5 && (y2 = x4.getPointCount() - 1), s4.setXY(0, p3), p3.assign(s4.getXY(n6 - 1)), x4.addSegmentsFromPath(s4, 0, 0, n6 - 1, false);
    const E2 = new ur({ vd: x4.getDescription() });
    E2.add(x4, false);
    const S3 = x4.getXY(0), C3 = x4.getXY(x4.getPointCount() - 1), b2 = o < 0 ? t3 : !t3, w4 = E2.getPointCount() - 1;
    if (b2) {
      const e5 = new mi(C3.x, this.m_pannableExtent.ymax);
      E2.lineTo(e5);
      const t4 = new mi(this.m_pannableExtent.getCenterX(), this.m_pannableExtent.ymax);
      E2.lineTo(t4);
      const s5 = new mi(S3.x, this.m_pannableExtent.ymax);
      E2.lineTo(s5);
    } else {
      const e5 = new mi(C3.x, this.m_pannableExtent.ymin);
      E2.lineTo(e5);
      const t4 = new mi(this.m_pannableExtent.getCenterX(), this.m_pannableExtent.ymin);
      E2.lineTo(t4);
      const s5 = new mi(S3.x, this.m_pannableExtent.ymin);
      E2.lineTo(s5);
    }
    if (E2.interpolateAttributesPath(0, w4, 0), E2.getImpl().changeRingStartPoint(y2), c > this.m_width360) {
      const e5 = new ur({ copy: E2 });
      f3.setShiftCoords(this.m_width360, 0), e5.applyTransformation(f3), E2.add(e5, false);
    }
    return E2;
  }
  finalizeGeoNormalizeClosedRing(t3, s4, r) {
    const i2 = new ur({ vd: t3.getDescription() });
    i2.add(t3, false);
    const o = () => {
      const e5 = i2.getPointCount() - 2;
      return i2.getSegmentType(e5) !== a.enumLine;
    };
    if (i2.hasNonLinearSegments() && o()) {
      const e5 = new fm(), t4 = i2.getPointCount() - 2;
      i2.getSegmentBuffer(t4, e5, false), i2.removePointFromPath(0, t4 + 1), i2.closeLastPathWithSegment(e5.get());
    } else i2.removePointFromPath(0, i2.getPointCount() - 1);
    const a2 = n4.constructEmpty();
    i2.queryLooseEnvelope(a2);
    let h2 = Math.ceil((this.m_pannableExtent.xmin - a2.xmin) / this.m_width360);
    for (h2 *= this.m_width360; this.m_pannableExtent.xmin > a2.xmin + h2; ) h2 += this.m_width360;
    for (; this.m_pannableExtent.xmin < a2.xmax + h2; ) h2 -= this.m_width360;
    if (h2 += this.m_width360, 0 !== h2) {
      a2.move(h2, 0);
      const e5 = new x3();
      e5.setShiftCoords(h2, 0), i2.applyTransformation(e5);
    }
    if (this.m_pannableExtent.xmin <= a2.xmin && this.m_pannableExtent.xmax >= a2.xmax) {
      if (s4) {
        const e6 = i2.calculateArea2D(), t4 = new Eh2().execute(i2, this.m_pannableSR, true, this.m_progressTracker);
        if (t4 !== i2) {
          const s5 = t4.calculateArea2D();
          K(e6) !== K(s5) && t4.reverseAllPaths(), i2.assignMove(t4);
        }
      }
      let e5;
      if (e5 = new ur(r ? { copy: i2 } : { move: i2 }), r) for (; a2.xmin < this.m_pannableExtent.xmax; ) {
        a2.move(this.m_width360, 0);
        const t4 = new x3();
        t4.setShiftCoords(this.m_width360, 0), i2.applyTransformation(t4), e5.add(i2, false);
      }
      return e5;
    }
    let m3 = new ur({ vd: t3.getDescription() });
    m3.add(i2, false);
    const l2 = s4 || a2.width() > this.m_width360 - 10 * this.m_pannableSR.getTolerance(0);
    for (; a2.xmin < this.m_pannableExtent.xmax; ) {
      a2.move(this.m_width360, 0);
      const e5 = new x3();
      e5.setShiftCoords(this.m_width360, 0), i2.applyTransformation(e5), m3.add(i2, false);
    }
    if (l2) {
      const e5 = m3.calculateArea2D();
      m3.setFillRule(1), m3 = new Eh2().execute(m3, this.m_pannableSR, true, this.m_progressTracker);
      const t4 = m3.calculateArea2D();
      K(e5) !== K(t4) && m3.reverseAllPaths();
    }
    return m3;
  }
  geonormalize_ring_(e5, t3, s4, n6, r, i2, o) {
    n2(0);
  }
};
function Vm(e5) {
  n2(0);
  const t3 = ou2(e5), s4 = new km();
  return s4.setVertProj_(t3), s4;
}
function Fm(e5, t3 = true) {
  return n2(0), {};
}
function Hm(e5) {
  return Su2();
}
var km = class {
  constructor() {
    this.m_hashCode = 0, this.m_peVertSysVal = null, this.m_verticalUnit = new bu2(), this.m_verticalShift = 0, this.m_userVerticalWKID = 0, this.m_bIsDepth = false;
  }
  getType() {
    return n2(0), 0;
  }
  getID() {
    return n2(0), 0;
  }
  getLatestID() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.getLatestID() : 0;
  }
  getOldID() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.getOldID() : 0;
  }
  getText() {
    return n2(0), "";
  }
  getTextExtended(e5) {
    return n2(0), "";
  }
  getText2(e5) {
    return n2(0), "";
  }
  getUnit() {
    return n2(0), {};
  }
  equals(e5) {
    return n2(0), false;
  }
  equalForProjection(e5) {
    return n2(0), false;
  }
  getPeVertcsCopy() {
    return n2(0), {};
  }
  getOneMeter() {
    return 1 / this.m_verticalUnit.getUnitToBaseFactor();
  }
  getUnitToBaseFactor() {
    return n2(0), 0;
  }
  isDepth() {
    return n2(0), false;
  }
  getVerticalShift() {
    return n2(0), 0;
  }
  isCustomWkid() {
    return !!this.m_peVertSysVal && this.m_peVertSysVal.isCustomWkid();
  }
  getHashCode() {
    return this.m_hashCode;
  }
  setVertProj_(e5) {
    this.m_peVertSysVal = e5;
  }
  getPEVerticalCoordSys() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.m_peVertcs : null;
  }
};
function Am(e5, t3, s4, n6, r) {
  if (e5.equals(t3)) return false;
  if (n6) {
    let s5 = 1, i3 = 0, o2 = 1, a2 = 1, h2 = 0, m3 = 1;
    Number.isNaN(e5.m_heightMetersPerUnit) || (s5 = e5.m_heightMetersPerUnit, i3 = e5.m_heightZ0, o2 = e5.m_heightSign, a2 = t3.m_heightMetersPerUnit, h2 = t3.m_heightZ0, m3 = t3.m_heightSign);
    const l2 = o2 * m3 * s5 / a2;
    for (let e6 = 0; e6 < r; e6++) n6[e6] = (n6[e6] - i3) * l2 + h2;
  }
  let i2 = 1, o = 0;
  if (Number.isNaN(e5.m_XYToRadians) || (i2 = e5.m_XYToRadians / t3.m_XYToRadians, o = e5.m_PrimeMeridianDegrees - t3.m_PrimeMeridianDegrees, 0 !== o && (o = Ah(o), o /= t3.m_XYToRadians)), Array.isArray(s4)) {
    const e6 = s4;
    for (let t4 = 0; t4 < r; t4++) e6[t4][0] = e6[t4][0] * i2 + o, e6[t4][1] = e6[t4][1] * i2;
  } else {
    const e6 = s4;
    for (let t4 = 0; t4 < r; t4++) {
      const s5 = t4 << 1;
      e6[s5] = e6[s5] * i2 + o, e6[s5 + 1] = e6[s5 + 1] * i2;
    }
  }
  return true;
}
function Mm() {
  return { m_heightMetersPerUnit: 0, m_heightSign: 0, m_heightZ0: 0, m_XYToRadians: 0, m_PrimeMeridianDegrees: 0, assign(e5) {
    this.m_heightMetersPerUnit = e5.m_heightMetersPerUnit, this.m_heightSign = e5.m_heightSign, this.m_heightZ0 = e5.m_heightZ0, this.m_XYToRadians = e5.m_XYToRadians, this.m_PrimeMeridianDegrees = e5.m_PrimeMeridianDegrees;
  }, equals(e5) {
    return ls(this.m_heightSign, e5.m_heightSign) && ls(this.m_heightMetersPerUnit, e5.m_heightMetersPerUnit) && ls(this.m_heightZ0, e5.m_heightZ0) && ls(this.m_XYToRadians, e5.m_XYToRadians) && ls(this.m_PrimeMeridianDegrees, e5.m_PrimeMeridianDegrees);
  }, initFromGcsAndVcsPe(e5, t3) {
    this.m_heightSign = 1, this.m_heightMetersPerUnit = Number.NaN, this.m_heightZ0 = 0, this.m_XYToRadians = Number.NaN, this.m_PrimeMeridianDegrees = Number.NaN, t3 && n2(0), e5 && (this.m_XYToRadians = e5.getUnit().getUnitFactor(), this.m_PrimeMeridianDegrees = e5.getPrimem().getLongitude());
  }, initFromGcsAndVcs(e5, t3) {
    const s4 = e5 ? e5.getPECoordSys() : null, n6 = t3 ? t3.getPEVerticalCoordSys() : null;
    this.initFromGcsAndVcsPe(s4, n6);
  }, processUnitParams(e5) {
    Number.isNaN(this.m_heightMetersPerUnit) && (this.m_heightMetersPerUnit = e5.m_heightMetersPerUnit, this.m_heightSign = e5.m_heightSign, this.m_heightZ0 = e5.m_heightZ0), Number.isNaN(this.m_XYToRadians) && (this.m_XYToRadians = e5.m_XYToRadians, this.m_PrimeMeridianDegrees = e5.m_PrimeMeridianDegrees);
  } };
}
var Um = class {
  constructor(e5) {
    this.m_constantsLoaded = -1, this.m_isUsable = -1, this.m_inputSR = null, this.m_outputSR = null, this.m_inputSRHorz = null, this.m_outputSRHorz = null, this.m_inputVCS = null, this.m_outputVCS = null, this.m_hashCode = 0, this.m_areaOfUse = new re(), this.m_inputUnitParams = Mm(), this.m_outputUnitParams = Mm(), n2(e5), this.m_geogTran = e5, this.m_vertTran = null, this.m_latestID = Ic.getCode(this.m_geogTran), this.m_latestID < 0 && (this.m_latestID = 0);
    const t3 = this.m_geogTran.getGeogcs1();
    Ic.getCode(t3);
    const s4 = this.m_geogTran.getGeogcs2();
    Ic.getCode(s4), this.initUnitParams();
  }
  getLatestId() {
    return this.m_latestID;
  }
  getText() {
    return this.m_geogTran ? this.m_geogTran.toString() : (n2(0), "");
  }
  getGeogtran() {
    return this.m_geogTran;
  }
  getVerttran() {
    return null;
  }
  loadConstants(e5) {
    let t3 = this.m_constantsLoaded;
    if (-1 === t3) {
      if (!e5) {
        this.m_geogTran || b("vcs not impl");
        const t4 = this.m_geogTran.getParameters();
        null !== t4[bc.PE_PARM_ND] && (e5 = 0 === t4[bc.PE_PARM_ND].getValue());
      }
      t3 = this.m_geogTran.loadConstants() ? 1 : 0, this.m_constantsLoaded = t3;
    }
    return 0 !== t3;
  }
  isUsable() {
    let e5 = this.m_isUsable;
    return -1 === e5 && (this.m_geogTran ? this.m_isUsable = e5 = this.m_geogTran ? 1 : 0 : this.m_isUsable = e5 = this.m_vertTran ? 1 : 0), 1 === e5;
  }
  getInputSr(e5) {
    return this.updateSrs(), e5 ? this.m_inputSR : this.m_inputSRHorz;
  }
  getOutputSr(e5) {
    return this.updateSrs(), e5 ? this.m_outputSR : this.m_outputSRHorz;
  }
  getHashCode() {
    let e5 = this.m_hashCode;
    return 0 === e5 && (e5 = this.m_latestID > 0 ? Zs(this.m_latestID) : Ds(this.getText()), 0 === e5 && (e5 = 345), this.m_hashCode = e5), e5;
  }
  isGeogtran() {
    return null !== this.m_geogTran;
  }
  prepareOrThrow() {
  }
  getName() {
    return this.isGeogtran() ? this.getGeogtran().getName() : (z("vcs not impl"), "");
  }
  updateSrs() {
    if (this.m_inputSR || this.m_inputVCS) return;
    let e5, t3, s4, n6, r, i2;
    if (this.m_geogTran) {
      const o = this.m_geogTran.getGeogcs1(), a2 = ru2(o), h2 = this.m_geogTran.getGeogcs2(), m3 = ru2(h2);
      let l2 = -1, g2 = -1;
      l2 = a2.getVcsCode(), g2 = m3.getVcsCode(), s4 = Ru2(o, null, null, 1), n6 = Ru2(h2, null, null, 1), l2 > 0 && g2 > 0 ? (r = Vm(l2), i2 = Vm(g2), e5 = zu2(), t3 = zu2()) : (e5 = s4, t3 = n6);
    } else n2(0);
    this.m_inputSR || this.m_inputVCS || (this.m_inputSR = e5, this.m_outputSR = t3, this.m_inputSRHorz = s4, this.m_outputSRHorz = n6, this.m_inputVCS = r, this.m_outputVCS = i2);
  }
  initUnitParams() {
    if (this.m_inputUnitParams.m_heightSign = 1, this.m_inputUnitParams.m_heightMetersPerUnit = Number.NaN, this.m_inputUnitParams.m_heightZ0 = 0, this.m_outputUnitParams.m_heightSign = 1, this.m_outputUnitParams.m_heightMetersPerUnit = Number.NaN, this.m_outputUnitParams.m_heightZ0 = 0, this.m_inputUnitParams.m_XYToRadians = Number.NaN, this.m_inputUnitParams.m_PrimeMeridianDegrees = Number.NaN, this.m_outputUnitParams.m_XYToRadians = Number.NaN, this.m_outputUnitParams.m_PrimeMeridianDegrees = Number.NaN, this.m_vertTran) n2(0);
    else if (this.m_geogTran) {
      const e5 = this.m_geogTran;
      let t3 = e5.getGeogcs1();
      this.m_inputUnitParams.m_XYToRadians = t3.getUnit().getUnitFactor(), this.m_inputUnitParams.m_PrimeMeridianDegrees = t3.getPrimem().getLongitude(), t3 = e5.getGeogcs2(), this.m_outputUnitParams.m_XYToRadians = t3.getUnit().getUnitFactor(), this.m_outputUnitParams.m_PrimeMeridianDegrees = t3.getPrimem().getLongitude();
    }
  }
};
function qm(e5, t3, s4, n6, r, i2, o) {
  let a2 = null;
  if (t3) {
    a2 = t3.getPEVerticalCoordSys();
  }
  let h2 = null;
  if (e5) {
    h2 = e5.getPECoordSys();
  }
  let m3 = null;
  if (n6) {
    m3 = n6.getPEVerticalCoordSys();
  }
  let l2 = null;
  if (s4) {
    l2 = s4.getPECoordSys();
  }
  if (!(h2 || a2 || l2 || m3)) return false;
  const g2 = Mm();
  g2.initFromGcsAndVcsPe(h2, a2);
  const u = Mm();
  return u.initFromGcsAndVcsPe(l2, m3), Am(g2, u, r, i2, o);
}
function Bm(e5, t3, s4, n6, r, i2, o, a2) {
  const h2 = t3, m3 = e5, l2 = Mm();
  l2.initFromGcsAndVcsPe(m3, h2), a2.assign(n6 ? s4.m_outputUnitParams : s4.m_inputUnitParams), a2.processUnitParams(l2), l2.processUnitParams(a2), o > 0 && Am(l2, a2, r, i2, o);
}
function Om(e5, t3, s4, n6, r, i2, o, a2) {
  const h2 = Mm();
  h2.assign(s4 ? t3.m_inputUnitParams : t3.m_outputUnitParams), h2.processUnitParams(e5);
  let m3 = null, l2 = null;
  if (n6) {
    l2 = n6.getPECoordSys();
  }
  const g2 = Mm();
  g2.initFromGcsAndVcsPe(l2, m3), g2.processUnitParams(h2), h2.processUnitParams(g2), a2 > 0 && Am(h2, g2, i2, o, a2);
}
function Ym(e5, t3, s4, n6, r, i2, o, a2, h2) {
  const m3 = Mm(), l2 = Mm();
  m3.assign(s4 ? t3.m_inputUnitParams : t3.m_outputUnitParams), l2.assign(r ? n6.m_outputUnitParams : n6.m_inputUnitParams), m3.processUnitParams(e5), l2.processUnitParams(m3), m3.processUnitParams(l2), a2 > 0 && Am(m3, l2, i2, o, a2), h2.assign(l2);
}
function Rm(e5, t3, s4, n6, r, i2, o) {
  const a2 = t3.getVerttran(), h2 = t3.getGeogtran();
  if (o.assign(s4 ? t3.m_inputUnitParams : t3.m_outputUnitParams), o.processUnitParams(e5), i2 > 0) {
    t3.prepareOrThrow();
    const e6 = s4 ? bc.PE_TRANSFORM_2_TO_1 : bc.PE_TRANSFORM_1_TO_2;
    a2 ? dg() : pg(h2, i2, n6, r, e6);
  }
}
function Xm(e5, t3, s4, n6, r) {
  const i2 = e5.getVerttran(), o = e5.getGeogtran();
  if (r > 0) {
    e5.prepareOrThrow();
    const a2 = t3 ? bc.PE_TRANSFORM_2_TO_1 : bc.PE_TRANSFORM_1_TO_2;
    i2 ? dg() : pg(o, r, s4, n6, a2);
  }
}
var Lm = class {
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t3, s4) {
    return zm(e5, t3, s4);
  }
  canAccelerateGeometry(e5) {
    return Wm(e5);
  }
};
function zm(e5, t3, s4) {
  if (!Wm(e5)) return false;
  Lt2(t3, e5, false);
  let n6 = 0;
  const r = e5.getGeometryType();
  return h(r) && Ls2(e5) && 0 !== s4 && (n6 |= e5.getImpl().buildQuadTreeAccelerator(s4) ? 1 : 0), h(r) && Rs(e5) && 0 !== s4 && (n6 |= e5.getImpl().buildQuadTreeForPathsAccelerator(s4) ? 1 : 0), n6 > 0;
}
function Wm(e5) {
  return Ls2(e5) || Rs(e5);
}
var jm = class extends Lm {
  getOperatorType() {
    return 8;
  }
  execute(e5, t3, s4, n6) {
    return kr2(e5, t3, s4, 1, n6);
  }
};
function Zm(s4, i2, o, a2) {
  if (s4.isEmpty() || i2.isEmpty()) return s4;
  const h2 = s4.getDimension(), m3 = i2.getDimension();
  if (h2 > m3) return s4;
  const l2 = s4.getGeometryType(), g2 = i2.getGeometryType(), u = new n4(), c = new n4(), _ = new n4();
  s4.queryEnvelope(u), i2.queryEnvelope(c), _.setCoords({ env2D: u }), _.mergeEnvelope2D(c);
  const d2 = At(o, _, true), p3 = Ft2(d2), f3 = new n4();
  if (f3.setCoords({ env2D: u }), f3.inflateCoords(p3, p3), !f3.isIntersecting(c)) return s4;
  if (1 === h2 && 2 === m3) {
    const e5 = ol(s4, i2, g2, o, a2);
    if (e5) return e5;
  }
  if (l2 === a.enumPoint) {
    let e5;
    switch (f(g2) ? (e5 = new Os2({ vd: i2.getDescription() }), e5.addSegment(i2, true)) : e5 = i2, g2) {
      case a.enumPolygon:
        return Jm(s4, e5, d2);
      case a.enumPolyline:
        return $m(s4, e5, d2);
      case a.enumMultiPoint:
        return el(s4, e5, d2);
      case a.enumEnvelope:
        return tl(s4, e5, d2);
      case a.enumPoint:
        return sl(s4, e5, d2);
      default:
        P("invalid shape type");
    }
  } else if (l2 === a.enumMultiPoint) switch (g2) {
    case a.enumPolygon:
      return nl(s4, i2, d2);
    case a.enumEnvelope:
      return rl(s4, i2, d2);
    case a.enumPoint:
      return il(s4, i2, d2);
  }
  const x4 = new n4(u);
  x4.inflate(100 * d2.total());
  return Ya2(s4, f2(i2, x4, 0, 0, a2), o, a2);
}
var Km = class {
  getOperatorType() {
    return 10002;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t3, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  executeMany(e5, t3, s4, n6) {
    return new Qm(e5, t3, s4, n6);
  }
  execute(e5, t3, s4, n6) {
    return this.executeMany(new s2([e5]), new s2([t3]), s4, n6).next();
  }
};
var Qm = class extends t {
  constructor(e5, t3, s4, n6) {
    super(), this.m_progressTracker = n6, this.m_index = -1, this.m_inputGeoms = e5, this.m_spatialReference = s4;
    const r = t3.next();
    this.m_geomSubtractor = r || new ur();
  }
  next() {
    const e5 = this.m_inputGeoms.next();
    return e5 ? (j(e5), L(e5), this.m_index = this.m_inputGeoms.getGeometryID(), Zm(e5, this.m_geomSubtractor, this.m_spatialReference, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function Jm(e5, t3, s4, n6) {
  return 0 === Xo2(t3, e5, s4.total()) ? e5 : e5.createInstance();
}
function $m(t3, s4, n6, r) {
  const i2 = t3.getXY(), o = s4.querySegmentIterator(), a2 = Ft2(n6), h2 = a2 * a2;
  for (; o.nextPath(); ) for (; o.hasNextSegment(); ) {
    const s5 = o.nextSegment(), r2 = new n4();
    if (s5.queryEnvelope(r2), r2.inflateCoords(a2, a2), !r2.contains(i2)) continue;
    if (s5.isIntersectingPoint(i2, n6.total())) return t3.createInstance();
    let m3 = s5.getStartXY();
    if (mi.sqrDistance(i2, m3) <= h2) return t3.createInstance();
    if (m3 = s5.getEndXY(), mi.sqrDistance(i2, m3) <= h2) return t3.createInstance();
  }
  return t3;
}
function el(e5, t3, s4, n6) {
  const r = t3.getImpl().getAttributeStreamRef(0), i2 = t3.getPointCount(), o = e5.getXY(), a2 = Ft2(s4), h2 = a2 * a2, m3 = new mi();
  for (let l2 = 0; l2 < i2; l2++) {
    r.queryPoint2D(2 * l2, m3);
    if (mi.sqrDistance(m3, o) <= h2) return e5.createInstance();
  }
  return e5;
}
function tl(t3, s4, n6, r) {
  const i2 = new n4();
  s4.queryEnvelope(i2), i2.inflate(n6.total());
  const o = t3.getXY();
  return i2.contains(o) ? t3.createInstance() : t3;
}
function sl(e5, t3, s4, n6) {
  const r = Ft2(s4), i2 = r * r, o = e5.getXY(), a2 = t3.getXY();
  return mi.sqrDistance(o, a2) <= i2 ? e5.createInstance() : e5;
}
function nl(t3, s4, n6, r) {
  const i2 = new n4();
  s4.queryEnvelope(i2), i2.inflate(n6.total());
  const o = t3.getPointCount();
  let a2 = false;
  const h2 = Yt(o, false), m3 = new mi();
  for (let e5 = 0; e5 < o; e5++) {
    if (t3.queryXY(e5, m3), !i2.contains(m3)) continue;
    0 !== Lo2(s4, m3, n6.total()) && (a2 = true, h2[e5] = true);
  }
  if (!a2) return t3;
  const l2 = t3.createInstance();
  for (let e5 = 0; e5 < o; e5++) h2[e5] || l2.addPoints(t3, e5, e5 + 1);
  return l2;
}
function rl(t3, s4, n6, r) {
  const i2 = new n4();
  s4.queryEnvelope(i2), i2.inflate(n6.total());
  const o = t3.getPointCount();
  let a2 = false;
  const h2 = Yt(o, false), m3 = new mi();
  for (let e5 = 0; e5 < o; e5++) t3.queryXY(e5, m3), i2.contains(m3) && (a2 = true, h2[e5] = true);
  if (!a2) return t3;
  const l2 = t3.createInstance();
  for (let e5 = 0; e5 < o; e5++) h2[e5] || l2.addPoints(t3, e5, e5 + 1);
  return l2;
}
function il(e5, t3, s4, n6) {
  const r = e5.getImpl().getAttributeStreamRef(0), i2 = e5.getPointCount(), o = t3.getXY();
  let a2 = false;
  const h2 = Yt(i2, false), m3 = Ft2(s4), l2 = m3 * m3, g2 = new mi();
  for (let c = 0; c < i2; c++) {
    r.queryPoint2D(2 * c, g2);
    mi.sqrDistance(g2, o) <= l2 && (a2 = true, h2[c] = true);
  }
  if (!a2) return e5;
  const u = e5.createInstance();
  for (let c = 0; c < i2; c++) h2[c] || u.addPoints(e5, c, c + 1);
  return u;
}
function ol(t3, s4, r, i2, o) {
  const a2 = new re();
  t3.queryEnvelope(a2);
  const h2 = new n4();
  s4.queryEnvelope(h2), a2.merge(h2);
  const m3 = 0.1 * a2.width(), l2 = 0.1 * a2.height();
  a2.inflateCoords(m3, l2);
  const g2 = new ur();
  g2.addEnvelope(a2, false);
  const u = g2.getImpl();
  if (r === a.enumPolygon) {
    const e5 = s4.getImpl();
    u.add(e5, true);
  } else u.addEnvelope(s4, true);
  return new Ih2(g2, i2, -1, o).tryFastImplementation(t3);
}
var al = class {
  getOperatorType() {
    return 10001;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t3, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  executeMany(e5, t3, s4, n6 = 0) {
    return new gl(e5, t3, s4, n6);
  }
  execute(e5, t3, s4, n6) {
    const r = new s2([e5, t3]), o = new gl(r, s4, n6, 0).next();
    return o || b("null output"), o;
  }
};
function hl() {
  return { geom: null, vertexCount: -1, bUnioned: false, location: new mi() };
}
function ml(e5, t3) {
  return mi.compareZorder(e5.location, t3.location) ? -1 : e5.location.equals(t3.location) ? 0 : 1;
}
var ll = class {
  constructor() {
    this.binVertexCount = 0, this.geometries = [];
  }
  addPair(e5) {
    this.binVertexCount += e5.vertexCount, this.geometries.push(e5);
  }
  sort() {
    this.geometries.sort((e5, t3) => ml(e5, t3));
  }
  geomCount() {
    return this.geometries.length;
  }
  geomPairs() {
    return this.geometries;
  }
  clear() {
    this.binVertexCount = 0, this.geometries.length = 0;
  }
  getBinVertexCount() {
    return this.binVertexCount;
  }
};
var gl = class _gl extends t {
  constructor(e5, t3, s4, n6, r = false) {
    super(), this.m_index = -1, this.m_currentDim = -1, this.m_bDone = false, this.m_unionBins = [], this.m_readyGeoms = Vt(4), this.m_dimGeomCounts = Yt(4, 0), this.m_addedGeoms = 0, this.m_maxDimension = -1, this.m_bHadGeometry = Yt(4, false), this.m_complexUnionGeoms = Vt(4), this.m_totalNonEmptyGeomCounters = Yt(4, 0), this.m_progressTracker = s4, this.m_bUnionAllDimensions = !!(4 & n6), this.m_bPreserveAllPathEnds = !!(8 & n6), this.m_inputGeoms = e5, this.m_spatialReference = t3, this.m_options = n6, this.m_bIs3D = r;
  }
  next() {
    if (this.m_bDone && this.m_currentDim === this.m_maxDimension) return null;
    for (; !this.step_(); ) ;
    if (-1 === this.m_maxDimension) return null;
    if (this.m_bUnionAllDimensions) {
      if (-1 === this.m_currentDim) {
        for (let e5 = 0; e5 <= this.m_maxDimension; e5++) if (this.m_bHadGeometry[e5]) {
          this.m_complexUnionGeoms[e5] = this.getResultGeometry(e5);
          for (let t3 = e5 + 1; t3 <= this.m_maxDimension; t3++) this.m_complexUnionGeoms[t3] = this.getResultGeometry(t3), this.m_bHadGeometry[t3] && !this.m_complexUnionGeoms[t3].isEmpty() && (this.m_bIs3D ? n2(0) : this.m_complexUnionGeoms[e5] = new Km().execute(this.m_complexUnionGeoms[e5], this.m_complexUnionGeoms[t3], this.m_spatialReference, this.m_progressTracker));
        }
      }
      for (; this.m_currentDim++, (this.m_currentDim > this.m_maxDimension || this.m_currentDim < 0) && b(""), !this.m_bHadGeometry[this.m_currentDim]; ) ;
      if (this.m_index++, 0 === this.m_currentDim && this.m_complexUnionGeoms[this.m_currentDim].getGeometryType() === a.enumPoint) {
        const e5 = new Ee({ vd: this.m_complexUnionGeoms[this.m_currentDim].getDescription() });
        return this.m_complexUnionGeoms[this.m_currentDim].isEmpty() || e5.add(this.m_complexUnionGeoms[this.m_currentDim]), e5;
      }
      return this.m_complexUnionGeoms[this.m_currentDim];
    }
    return this.m_index = 0, this.m_currentDim = this.m_maxDimension, this.getResultGeometry(this.m_maxDimension);
  }
  getGeometryID() {
    return this.m_index;
  }
  getRank() {
    return 1;
  }
  tock() {
    return this.step_();
  }
  getResultGeometry(e5) {
    return this.m_readyGeoms[e5];
  }
  finishDim(e5, t3, s4) {
    let r = t3;
    if (!s4) return 16 & this.m_options ? (r = ja2([r], 1, this.m_spatialReference, this.m_progressTracker, this.m_options, this.m_bIs3D), r) : r;
    if (1 & this.m_options) return r;
    if (1 === e5) {
      if (!(8 & this.m_options) && (!!(16 & this.m_options) || this.m_totalNonEmptyGeomCounters[e5] > 1)) {
        r = ja2([r], 1, this.m_spatialReference, this.m_progressTracker, 16 | this.m_options, this.m_bIs3D);
        const e6 = [0], t4 = r.getImpl().getIsSimple(0, e6);
        n2(this.m_bIs3D || Ot2(t4));
      } else 1 === this.m_totalNonEmptyGeomCounters[e5] && (this.m_bIs3D ? n2(0) : r = new Eh2().execute(r, this.m_spatialReference, false, this.m_progressTracker));
    } else this.m_bIs3D ? n2(0) : r = new Eh2().execute(r, this.m_spatialReference, false, this.m_progressTracker);
    if (0 === e5 && r.getGeometryType() === a.enumPoint) {
      const e6 = new Ee({ vd: r.getDescription() });
      r.isEmpty() || e6.add(r), r = e6;
    }
    return r;
  }
  static getLevel(e5) {
    const t3 = 4, s4 = w(e5);
    let n6 = s4 > 0 ? (Math.log(s4) - Math.log(32)) / Math.log(t3) : 0;
    return n6 < 0 && (n6 = 0), Math.floor(n6);
  }
  step_() {
    if (this.m_bDone) return true;
    let e5;
    if (this.m_inputGeoms ? (e5 = this.m_inputGeoms.next(), null === e5 ? (this.m_bDone = true, this.m_inputGeoms = null) : (this.checkAndThrow(e5), e5.isEmpty() || this.m_totalNonEmptyGeomCounters[e5.getDimension()]++)) : e5 = null, null !== e5) {
      const t3 = e5.getDimension();
      this.m_bHadGeometry[t3] = true, (t3 >= this.m_maxDimension || this.m_bUnionAllDimensions) && (this.addGeom(t3, false, e5), t3 > this.m_maxDimension && !this.m_bUnionAllDimensions && this.removeAllBinsWithLowerDimension(t3));
    }
    if (this.m_addedGeoms > 0) for (let t3 = 0; t3 <= this.m_maxDimension; t3++) {
      for (; this.m_dimGeomCounts[t3] > 1; ) {
        const e6 = this.collectGeometriesToUnion(t3);
        if (null === e6) break;
        {
          let s4;
          s4 = 1 & this.m_options ? ja2(e6, e6.length, this.m_spatialReference, this.m_progressTracker, this.m_options, this.m_bIs3D) : Za2(e6, e6.length, this.m_spatialReference, this.m_progressTracker, 8 | this.m_options, this.m_bIs3D), this.addGeom(t3, true, s4);
        }
      }
      if (this.m_bDone && (n2(this.m_dimGeomCounts[t3] <= 1), 0 !== this.m_dimGeomCounts[t3])) {
        const e6 = this.m_unionBins[t3].entries().next().value, s4 = e6[1].geomPairs()[0].geom, n6 = e6[1].geomPairs()[0].bUnioned;
        this.m_unionBins[t3].clear(), this.m_readyGeoms[t3] = this.finishDim(t3, s4, n6);
      }
    }
    return this.m_bDone;
  }
  addGeom(t3, s4, n6) {
    const r = hl();
    r.geom = n6;
    const i2 = w(n6);
    r.vertexCount = i2;
    const o = n4.constructEmpty();
    n6.queryEnvelope(o), r.location = i2 > 0 ? o.getCenter() : new mi(0, 0);
    const a2 = _gl.getLevel(n6);
    if (t3 + 1 > this.m_unionBins.length) for (; this.m_unionBins.length < Math.max(2, t3 + 1); ) this.m_unionBins.push(/* @__PURE__ */ new Map());
    let h2 = null;
    const m3 = this.m_unionBins[t3].get(a2);
    m3 && (h2 = m3), null === h2 && (h2 = new ll(), this.m_unionBins[t3].set(a2, h2)), r.bUnioned = s4, h2.addPair(r), this.m_dimGeomCounts[t3]++, this.m_addedGeoms++, this.m_maxDimension = Math.max(this.m_maxDimension, t3);
  }
  removeAllBinsWithLowerDimension(e5) {
    for (let t3 = 0; t3 < e5; t3++) this.m_unionBins[t3].clear(), this.m_addedGeoms -= this.m_dimGeomCounts[t3], this.m_dimGeomCounts[t3] = 0;
  }
  collectGeometriesToUnion(e5) {
    if (1 & this.m_options && !this.m_bDone) return null;
    let t3 = null;
    const s4 = [];
    for (const n6 of this.m_unionBins[e5].keys()) s4.push(n6);
    qt(s4);
    for (let n6 = 0; n6 < s4.length; n6++) {
      if (-1 === s4[n6]) continue;
      const r = this.m_unionBins[e5].get(s4[n6]);
      {
        const i2 = 5e3, o = 4, a2 = r.getBinVertexCount() > i2 && r.geomCount() >= o;
        if (this.m_bDone || a2) {
          for (let r2 = 0; r2 < n6; r2++) {
            if (-1 === s4[r2]) continue;
            const n7 = this.m_unionBins[e5].get(s4[r2]);
            n7.sort(), this.m_dimGeomCounts[e5] -= n7.geomCount(), this.m_addedGeoms -= n7.geomCount();
            for (const e6 of n7.geomPairs()) t3 || (t3 = new Array()), t3.push(e6.geom);
            n7.clear(), this.m_unionBins[e5].delete(s4[r2]), s4[r2] = -1;
          }
          r.sort(), this.m_dimGeomCounts[e5] -= r.geomCount(), this.m_addedGeoms -= r.geomCount();
          for (const e6 of r.geomPairs()) t3 || (t3 = new Array()), t3.push(e6.geom);
          if (r.clear(), this.m_unionBins[e5].delete(s4[n6]), s4[n6] = -1, !this.m_bDone) break;
        }
      }
    }
    return t3;
  }
  checkAndThrow(e5) {
    this.m_bIs3D && (e5.getDimension() > 1 && B(), e5.hasAttribute(1) || P("Geometry must have Zs")), j(e5);
  }
};
var ul = class extends Lm {
  getOperatorType() {
    return 3;
  }
  execute(e5, t3, s4, n6 = null) {
    return kr2(e5, t3, s4, 4, n6);
  }
};
function cl(t3, s4, n6) {
  const r = s4.getGCSSplitLines();
  if (null === r) return t3;
  const i2 = s4.getGCS(), o = i2.getPannableExtent().width(), a2 = n4.constructEmpty();
  t3.queryLooseEnvelope(a2);
  const h2 = x2.constructEmpty();
  a2.queryIntervalX(h2);
  const m3 = r.querySegmentIterator();
  let l2 = null;
  const g2 = new x3();
  for (; m3.nextPath(); ) for (; m3.hasNextSegment(); ) {
    const e5 = m3.nextSegment(), t4 = e5.queryInterval(0, 0), s5 = x2.constructEmpty();
    s5.setCoordsFromEnvelope(t4);
    let n7 = 0;
    for (; s5.vmax > h2.vmin; ) s5.move(-o), n7--;
    for (; s5.vmin <= h2.vmax; ) {
      if (s5.isIntersecting(h2)) {
        null === l2 && (l2 = new Os2());
        const t5 = new pm({ start: e5.getStartXY(), end: e5.getEndXY() });
        0 !== n7 && (g2.setShiftCoords(n7 * o, 0), t5.applyTransformation(g2)), l2.addSegment(t5, true);
      }
      s5.move(o), ++n7;
    }
  }
  if (null !== l2) {
    const e5 = Bt2(i2, l2, true);
    return Un2(t3, l2, Ft2(e5), n6);
  }
  return t3;
}
function _l(e5, t3, s4) {
  let n6 = e5.getName();
  return sc(n6) || (s4 || t3 > 0 ? (n6 = e5.toString(bc.PE_STR_NAME_CANON | bc.PE_STR_AUTH_NONE), n6 = yl(n6)) : n6 = e5.toString(bc.PE_STR_AUTH_TOP)), n6;
}
function dl(e5, t3, s4, n6) {
  return n2(0), "";
}
function pl(e5, s4 = -1) {
  if ((s4 > 1 || s4 < -1) && P("verbosity"), -1 === s4) return e5.toString();
  {
    const t3 = 0 === s4 ? bc.PE_STR_AUTH_TOP : bc.PE_STR_AUTH_ALL;
    return e5.toString(t3);
  }
}
function fl(e5, s4) {
  (s4 > 1 || s4 < -1) && P("verbosity");
  let n6 = bc.PE_STR_FMT_WKT2;
  return -1 !== s4 && (n6 |= 0 === s4 ? bc.PE_STR_AUTH_TOP : bc.PE_STR_AUTH_ALL), e5.toString(n6);
}
function xl(e5) {
  return n2(0), "";
}
function yl(e5) {
  return e5.toLocaleUpperCase("en-US");
}
function Pl(e5, s4, r) {
  const i2 = e5.getPCSHorizon();
  if (i2.getGeometryType() !== a.enumPolygon) if (i2.getGeometryType() !== a.enumEnvelope) P("");
  else {
    const e6 = i2;
    for (let t3 = 0; t3 < r; t3++) e6.contains(s4[t3]) || s4[t3].setNAN();
  }
  else {
    const t3 = e5.getDefaultPrecisionSR().getTolerance(0), n6 = i2;
    for (let e6 = 0; e6 < r; e6++) 1 !== Lo2(n6, s4[e6], t3) && s4[e6].setNAN();
  }
}
function El(e5, t3, s4, n6) {
  for (let r = 0; r < t3; r++) {
    if (e5[r].y < s4.ymin || e5[r].y > s4.ymax) {
      e5[r].setNAN();
      continue;
    }
    const t4 = e5[r].x;
    e5[r].x = Gl(t4, s4, n6);
  }
}
function Sl(t3, s4, r, a2) {
  if (t3.isEmpty() || 1 === r) return t3;
  const h2 = t3.getGeometryType();
  if (h2 === a.enumPoint) {
    const e5 = t3, n6 = e5.getXY();
    return 0 === wl([n6], 1, s4, r) || n6.isNAN() ? e5.setEmpty() : e5.setXY(n6), t3;
  }
  if (h2 === a.enumMultiPoint) {
    const e5 = t3, n6 = t3.createInstance(), i2 = e5.getPointCount();
    n6.reserve(i2);
    const o = e5.getAttributeStreamRef(0), a3 = e5.getDescription().getAttributeCount() > 1, h3 = new ee(), m4 = Float64Array.from(o.getArray());
    if (wl(m4, i2, s4, r) > 0) for (let t4 = 0, s5 = 2 * i2; t4 < s5; t4 += 2) Number.isNaN(m4[t4]) || (a3 ? (e5.getPointByVal(t4 >> 1, h3), h3.setXYCoords(m4[t4], m4[t4 + 1]), n6.add(h3)) : n6.addXY(m4[t4], m4[t4 + 1]));
    return n6;
  }
  let m3 = t3;
  const l2 = s4.getOneDegreeGCSUnit(), g2 = 90 * l2, u = 180 * l2, c = 360 * l2, _ = s4.getCentralMeridian(), d2 = 0.5 * l2, p3 = n4.constructEmpty();
  m3.queryEnvelope(p3);
  const f3 = s4.getGCSHorizon(), x4 = s4.getGCSHorisonIsInclusive(), y2 = f3.getGeometryType() === a.enumEnvelope, P5 = n4.constructEmpty();
  f3.queryEnvelope(P5);
  const E2 = s4.getGCS();
  if (2 !== r && 4 !== r || (P5.xmin = _ - u, P5.xmax = P5.xmin + c), 4 === r) {
    if (!(p3.width() > c - l2)) {
      const t4 = n4.constructEmpty();
      t4.setCoords({ xmin: p3.xmin - l2, ymin: P5.ymin, xmax: p3.xmax + l2, ymax: P5.ymax }), m3 = new I3().execute(m3, t4, E2, a2);
      let s5 = Math.floor((_ - p3.getCenterX()) / c);
      for (p3.move(s5 * c, 0); p3.xmin > P5.xmax; ) s5 -= 1, p3.move(-c, 0);
      for (; p3.xmin < P5.xmin; ) s5 += 1, p3.move(c, 0);
      if (0 !== s5) {
        const e5 = new x3();
        e5.setShiftCoords(s5 * c, 0), m3.applyTransformation(e5);
      }
      return m3;
    }
    r = 2;
  }
  if (2 === r && (P5.xmin = _ - u, P5.xmax = P5.xmin + c), p3.ymin < -g2 || p3.ymax > g2) {
    const t4 = n4.constructEmpty();
    if (t4.setCoords({ xmin: p3.xmin - l2, ymin: -g2, xmax: p3.xmax + l2, ymax: g2 }), m3 = new I3().execute(m3, t4, E2, a2), m3.isEmpty()) return m3;
    m3.queryEnvelope(p3);
  }
  if (x4 && (P5.ymax < p3.ymin || P5.ymin > p3.ymax)) return m3.createInstance();
  p3.width() > c && (m3 = ql(m3, _ - u, c, E2, true, 0, true, a2), m3.queryEnvelope(p3));
  let S3 = Ul(p3.xmin, p3.xmax, P5.xmin, P5.xmax, c);
  if (0 !== S3 && p3.move(S3, 0), p3.xmax > P5.xmax || p3.xmin < P5.xmin) {
    if (p3.xmax > P5.xmax) for (; p3.xmin >= P5.xmax; ) p3.move(-c, 0), S3 -= c;
    for (; p3.xmin < P5.xmax - c; ) p3.move(c, 0), S3 += c;
  }
  const C3 = Lt2(E2, f3, false);
  if (0 !== S3) {
    const e5 = new x3();
    e5.setShiftCoords(S3, 0), m3.applyTransformation(e5), S3 = 0;
  }
  if (x4) {
    if (y2 && P5.containsEnvelope(p3)) return m3;
    const e5 = new Array(2);
    for (let t4 = 0; t4 < 2; t4++) {
      let s5;
      if (y2 ? s5 = h(h2) ? f2(m3, P5, C3, d2, a2) : f2(m3, P5, C3, 0, a2) : (s5 = new wh2().execute(m3, f3, E2, a2), s5 === f3 && (s5 = s5.clone())), P5.xmin <= p3.xmin && P5.xmax >= p3.xmax) return s5;
      if (P5.xmin >= p3.xmin && P5.xmax <= p3.xmax) return s5;
      if (e5[t4] = s5, 0 === t4) {
        p3.move(-c, 0);
        const e6 = new x3();
        e6.setShiftCoords(-c, 0), m3.applyTransformation(e6);
      }
    }
    return h(h2) ? e5[0].add(e5[1], false) : b("intersect_with_GCS_horizon: unexpected geometry type"), e5[0];
  }
  {
    if (P5.ymax < p3.ymin || P5.ymin > p3.ymax) return m3;
    let e5 = 0;
    for (; !m3.isEmpty() && p3.xmax > P5.xmin; ) {
      if (0 !== e5) {
        const t4 = new x3();
        t4.setShiftCoords(e5, 0), m3.applyTransformation(t4);
      }
      if (!new ul().execute(m3, f3, E2, a2)) {
        m3 = new Km().execute(m3, f3, E2, a2), f3 === m3 && (m3 = m3.clone());
      }
      if (0 !== e5) {
        const t4 = new x3();
        t4.setShiftCoords(-e5, 0), m3.applyTransformation(t4);
      }
      e5 -= c, p3.move(-c, 0);
    }
    return m3;
  }
}
function Cl(e5, t3, s4, n6, r, i2) {
  const o = { stack: [], error: void 0, hasError: false };
  try {
    if (2 === i2) {
      return Gs3(e5, t3, s4, n6, r);
    }
    if (Math.abs(s4.x - n6.x) >= Math.PI || !Fg(s4.x, n6.x, r)) return Number.NaN;
    s4.x > n6.x && (n6 = Pt(s4, s4 = n6));
    const a2 = n(o, new Cc(), false), h2 = n(o, new Cc(), false), m3 = n(o, new Cc(), false), l2 = s4.clone();
    Dc.geodeticDistance(e5, t3, s4.x, s4.y, n6.x, n6.y, h2, a2, null, i2);
    const g2 = h2.val;
    let u = 0, c = 1;
    for (; g2 * (c - u) > 1e-12 * e5; ) {
      const o2 = 0.5 * (u + c);
      if (Dc.geodeticCoordinate(e5, t3, s4.x, s4.y, g2 * o2, a2.val, h2, m3, i2), l2.x = h2.val, l2.y = m3.val, l2.x === r) return l2.y;
      if (Fg(s4.x, l2.x, r)) c = o2;
      else {
        if (!Fg(n6.x, l2.x, r)) return Number.NaN;
        u = o2;
      }
    }
    return l2.y;
  } catch (a2) {
    o.error = a2, o.hasError = true;
  } finally {
    s(o);
  }
}
function Il(e5, t3) {
  let s4;
  if (Array.isArray(e5)) {
    const n6 = e5;
    s4 = new Float64Array(2 * t3);
    for (let e6 = 0, r = 0; e6 < t3; e6++, r += 2) s4[r] = n6[e6].x, s4[r + 1] = n6[e6].y;
  } else s4 = e5;
  return s4;
}
function bl(e5, t3, s4, n6) {
  for (let r = 0, i2 = 0; r < n6; r++, i2 += 2) t3[s4 + r].x = e5[i2], t3[s4 + r].y = e5[i2 + 1];
}
function wl(t3, s4, r, i2) {
  if (0 === s4 || 1 === i2) return s4;
  const o = Il(t3, s4);
  if (2 === i2) {
    const e5 = r.getPannableExtentInGCS();
    let n6 = s4;
    for (let t4 = 0, r2 = 2 * s4; t4 < r2; t4 += 2) (o[t4 + 1] > e5.ymax || o[t4 + 1] < e5.ymin) && (o[t4] = Number.NaN, n6--);
    return n6 ? (Bl(o, s4, e5.xmin, e5.width(), true), t3 !== o && bl(o, t3, 0, s4), n6) : 0;
  }
  const a2 = r.getOneDegreeGCSUnit(), h2 = 90 * a2, m3 = 180 * a2, l2 = 360 * a2;
  let g2 = s4;
  for (let e5 = 0, n6 = 2 * s4; e5 < n6; e5 += 2) (o[e5 + 1] > h2 || o[e5 + 1] < -h2) && (o[e5] = Number.NaN, g2--);
  if (!g2) return 0;
  const u = n4.constructEmpty();
  u.setFromPoints(o, s4);
  const c = r.getGCSHorizon(), _ = r.getGCSHorisonIsInclusive(), d2 = c.getGeometryType() === a.enumEnvelope, p3 = n4.constructEmpty();
  if (c.queryEnvelope(p3), _ && (p3.ymax < u.ymin || p3.ymin > u.ymax)) return 0;
  if (_) {
    if (Bl(o, s4, p3.getCenterX() - m3, l2, true), g2 = s4, d2) for (let e5 = 0, t4 = 2 * s4; e5 < t4; e5 += 2) p3.containsCoords(o[e5], o[e5 + 1]) || (o[e5] = Number.NaN, g2--);
    else {
      const e5 = Lt2(r.getGCS(), c, false), t4 = new mi();
      for (let n6 = 0, r2 = 2 * s4; n6 < r2; n6 += 2) {
        t4.setCoords(o[n6], o[n6 + 1]);
        0 !== Lo2(c, t4, e5) || (o[n6] = Number.NaN, g2--);
      }
    }
  } else {
    Bl(o, s4, -m3, l2, true), g2 = s4;
    const e5 = Lt2(r.getGCS(), c, false), t4 = new mi();
    for (let n6 = 0, r2 = 2 * s4; n6 < r2; n6 += 2) {
      t4.setCoords(o[n6], o[n6 + 1]), t4.isNAN() && g2--;
      const s5 = Ml(t4.x, p3.xmin, p3.xmax, l2);
      t4.x += s5;
      0 !== Lo2(c, t4, e5) && (o[n6] = Number.NaN, g2--);
    }
  }
  return g2 > 0 && Array.isArray(t3) && bl(o, t3, 0, s4), g2;
}
function vl(e5, s4, n6, r, i2, o) {
  if (s4.isPannable() || P("fold_into_360_degree_range"), e5.isEmpty()) return e5;
  let a2, h2;
  if (2 === s4.getCoordinateSystemType()) {
    const e6 = s4.getPannableExtent();
    h2 = e6.xmin, a2 = e6.width();
  } else {
    const e6 = s4.getOneDegreeGCSUnit();
    a2 = 360 * e6, h2 = n6 - 180 * e6;
  }
  return ql(e5, h2, a2, s4, r, i2, true, o);
}
function Nl(e5, t3, s4, n6) {
  let r, i2;
  if (2 === s4.getCoordinateSystemType()) {
    const e6 = s4.getPannableExtent();
    r = e6.xmin, i2 = e6.width();
  } else {
    const e6 = s4.getOneDegreeGCSUnit();
    i2 = 360 * e6, r = n6 - 180 * e6;
  }
  Bl(e5, t3, r, i2);
}
function Tl(e5, t3) {
  const s4 = t3.width();
  let n6 = ct(e5 - t3.vmin, s4);
  n6 < 0 && (n6 += s4);
  return t3.snapClip(n6 + t3.vmin);
}
function Gl(e5, t3, s4) {
  return e5 > t3.xmax && e5 - t3.xmax < s4 ? t3.xmax : e5 < t3.xmin && t3.xmin - e5 < s4 ? t3.xmin : e5;
}
function Dl(e5, t3, s4) {
  if (e5[0] < t3.vmin || e5[0] > t3.vmax || s4 && e5[0] === t3.vmax) {
    const s5 = t3.width();
    return e5[0] += Math.ceil((t3.vmin - e5[0]) / s5) * s5, e5[0] = t3.snapClip(e5[0]), true;
  }
  return false;
}
function Vl(e5, t3, s4, n6, r, i2, o, a2, h2) {
  return new Dm(e5, null, s4, t3, n6, r, o, a2, i2).geoNormalizePolygonGeometry(h2);
}
function Fl(e5, t3, s4, n6, r, i2, o, a2, h2) {
  return new Dm(e5, null, s4, t3, n6, r, o, a2, i2).geoNormalizePolylineGeometry(h2);
}
function Hl(e5, t3, s4, n6, r) {
  const i2 = new Pr(), o = i2.addGeometry(e5);
  return kl(i2, o, t3, Lt2(t3, e5, false), s4, n6, r), i2.getGeometry(o);
}
function kl(e5, t3, s4, n6, r, i2, o) {
  const h2 = { stack: [], error: void 0, hasError: false };
  try {
    n2(Uu2()), s4.isPannable() || C("insert_geodetic_points");
    const m3 = s4.getPannableExtent(), l2 = s4.getGCS(), g2 = Hu2();
    l2.querySpheroidData(g2);
    const u = l2.getUnit().getUnitToBaseFactor(), _ = g2.majorSemiAxis, d2 = g2.e2;
    let p3 = 0;
    const f3 = new x2();
    m3.queryIntervalX(f3);
    let x4 = null;
    const y2 = Yt(4, Number.NaN);
    2 === s4.getCoordinateSystemType() ? (x4 = s4.getPECoordSys(), i2 ? (y2[0] = Tl(o, f3), y2[1] = m3.getCenterY(), wc.projToGeog(x4, 1, y2), p3 = y2[0] * u) : (y2[0] = m3.getCenterX(), y2[1] = o, wc.projToGeog(x4, 1, y2), p3 = y2[1] * u)) : p3 = o * u, i2 || 0 === p3 || 2 === r || C("insert_geodetic_points: 1");
    const P5 = n(h2, new Cc(), false), E2 = new mi(), S3 = new mi(), C3 = new mi(), I4 = new mi(), b2 = new mi(), w4 = new mi();
    for (let a2 = e5.getFirstPath(t3); a2 !== cr; a2 = e5.getNextPath(a2)) {
      const t4 = e5.getFirstVertex(a2);
      e5.queryXY(t4, C3);
      let h3 = false;
      const m4 = e5.getNextVertex(t4);
      for (let a3 = m4; a3 !== cr; a3 = e5.getNextVertex(a3)) {
        if (a3 === m4) {
          if (h3) break;
          h3 = true;
        }
        if (e5.queryXY(a3, I4), i2 && (n6 < o - C3.x && I4.x - o > n6 || n6 < o - I4.x && C3.x - o > n6) || !i2 && (0 !== o || n6 < -C3.y && I4.y > n6 || n6 < -I4.y && C3.y > n6)) do {
          if (Math.abs(C3.x - I4.x) >= 0.5 * f3.width()) break;
          2 === s4.getCoordinateSystemType() ? (y2[0] = Tl(C3.x, f3), y2[1] = C3.y, y2[2] = Tl(I4.x, f3), y2[3] = I4.y, ag(x4, 2, y2, 0), b2.x = y2[0] * u, b2.y = y2[1] * u, w4.y = y2[3] * u) : (b2.x = C3.x * u, b2.y = C3.y * u, w4.y = I4.y * u), w4.x = (I4.x - C3.x) * Math.PI * 2 / f3.width() + b2.x;
          let t5 = 0;
          const n7 = Ot(mi, 2);
          if (i2) {
            if (S3.x = p3, S3.y = Cl(_, d2, b2, w4, p3, r), Number.isNaN(S3.y)) break;
            n7[0] = S3, t5 = 1;
          } else if (2 === r) {
            const e6 = [0, 0];
            if (t5 = Ds3(_, d2, b2, w4, p3, e6), !t5) break;
            n7[0].x = e6[0], n7[0].y = p3, 2 === t5 && (n7[1].x = e6[1], n7[1].y = p3);
          } else {
            if (S3.x = Hg(_, d2, b2, w4, r), Number.isNaN(S3.x)) break;
            S3.y = 0, n7[0] = S3, t5 = 1;
          }
          let h4 = -1;
          for (let m5 = 0; m5 < t5; m5++) {
            Dc.geodeticDistance(_, d2, b2.x, b2.y, w4.x, w4.y, P5, null, null, r);
            const t6 = P5.val;
            Dc.geodeticDistance(_, d2, b2.x, b2.y, n7[m5].x, n7[m5].y, P5, null, null, r);
            const l3 = P5.val;
            2 === s4.getCoordinateSystemType() ? (y2[0] = n7[m5].x / u, y2[1] = n7[m5].y / u, wc.geogToProj(x4, 1, y2), i2 ? (E2.y = y2[1], E2.x = o) : (E2.x = kg(y2[0], C3.x, I4.x, f3), E2.y = o)) : i2 ? (E2.x = o, E2.y = n7[m5].y / u) : (E2.x = kg(n7[m5].x / u, C3.x, I4.x, f3), E2.y = o);
            const g3 = t6 > 0 ? Us(l3 / t6, 0, 1) : 0.5;
            if (0 === g3 || 1 === g3) continue;
            if (h4 > g3) continue;
            const c = e5.getPrevVertex(a3);
            e5.splitSegment(c, [g3], 1);
            const p4 = e5.getNextVertex(c);
            e5.setXYCoords(p4, E2.x, E2.y), h4 = g3;
          }
        } while (0);
        C3.setCoordsPoint2D(I4);
      }
    }
  } catch (m3) {
    h2.error = m3, h2.hasError = true;
  } finally {
    s(h2);
  }
}
function Al(t3, s4) {
  n2(s4.isPannable());
  const r = s4.getPannableExtent();
  if (t3.getGeometryType() === a.enumPoint) {
    const e5 = t3.getY();
    return r.ymin <= e5 && e5 <= r.ymax ? t3 : t3.createInstance();
  }
  const i2 = n4.constructEmpty();
  t3.queryEnvelope(i2);
  const o = n4.constructEmpty();
  o.setCoords({ env2D: r }), o.xmin = i2.xmin, o.xmax = i2.xmax, o.inflateCoords(0.01 * o.height(), 0);
  const h2 = zt2(s4, i2, false);
  let m3;
  return m3 = o.containsEnvelope(i2) ? t3 : f2(t3, o, h2, 0, null), m3;
}
function Ml(e5, t3, s4, n6) {
  return S((0.5 * (s4 + t3) - e5) / n6) * n6;
}
function Ul(e5, t3, s4, n6, r) {
  if (e5 >= s4 && t3 <= n6) return 0;
  return Ml(0.5 * (t3 + e5), s4, n6, r);
}
function ql(t3, s4, r, i2, o, a2, h2, m3) {
  const l2 = t3.getGeometryType(), g2 = x2.constructEmpty();
  g2.setCoords(s4, s4 + r);
  const u = [0];
  if (l2 === a.enumPoint) {
    const e5 = t3;
    if (u[0] = e5.getX(), Dl(u, g2, h2)) {
      const e6 = o ? t3 : t3.clone();
      return e6.setX(u[0]), e6;
    }
    return t3;
  }
  const c = n4.constructEmpty();
  if (t3.queryEnvelope(c), c.isEmpty()) return t3;
  if (l2 === a.enumMultiPoint) {
    const e5 = o ? t3 : t3.clone(), s5 = e5.getImpl(), n6 = s5.getAttributeStreamRef(0), r2 = 2 * s5.getPointCount();
    let i3 = false;
    for (let t4 = 0; t4 < r2; t4 += 2) u[0] = n6.read(t4), Dl(u, g2, h2) && (n6.write(t4, u[0]), i3 = true);
    return i3 && s5.notifyModifiedFlags(2001), e5;
  }
  const _ = x2.constructEmpty();
  if (c.queryIntervalX(_), g2.contains(_)) return g2.vmax, _.vmax, t3;
  const d2 = n4.constructEmpty();
  if (d2.setCoords({ env2D: c }), 0 === _.width()) {
    let e5 = _.vmin;
    e5 += Math.ceil((g2.vmin - e5) / r) * r, e5 = g2.snapClip(e5);
    const s5 = o ? t3 : t3.clone();
    return s5.setAttributeBasic(0, 0, e5), s5;
  }
  if (l2 === a.enumEnvelope) {
    const e5 = o ? t3 : t3.clone();
    return c.intersect(d2), e5.setEnvelope(c), e5;
  }
  const p3 = 0.1 * Math.max(c.height(), c.width()) * 1;
  d2.inflateCoords(0, p3);
  let f3 = t3;
  const x4 = i2.getTolerance(0), y2 = new x3();
  for (; ; ) {
    const e5 = Math.floor((_.vmin - s4) / r), t4 = Math.ceil((_.vmax - s4) / r);
    if (!(t4 - e5 > 3)) break;
    {
      const o2 = Math.floor(0.5 * (t4 + e5));
      d2.xmin = c.xmin - p3, d2.xmax = s4 + r * o2;
      const h3 = f2(f3, d2, x4, a2, m3);
      d2.xmin = d2.xmax, d2.xmax = c.xmax + p3;
      const g3 = f2(f3, d2, x4, a2, m3);
      y2.setShiftCoords((o2 - t4) * r, 0), g3.applyTransformation(y2), l2 === a.enumPolygon ? f3 = new al().execute(h3, g3, i2, m3) : (f3 = h3, f3.add(g3, false)), f3.queryEnvelope(c), c.queryIntervalX(_);
    }
  }
  d2.xmin = s4, d2.xmax = s4 + r;
  const P5 = n4.constructEmpty();
  P5.setCoords({ env2D: d2 }), P5.inflateCoords(x4, 0);
  const E2 = Math.floor((c.xmin - d2.xmin) / r) * r;
  let S3;
  E2 ? (d2.move(E2, 0), y2.setShiftCoords(-E2, 0)) : y2.setIdentity(), S3 = l2 === a.enumPolyline ? new Os2({ vd: f3.getDescription() }) : new ur({ vd: f3.getDescription() });
  const C3 = n4.constructEmpty(), b2 = n4.constructEmpty();
  for (; c.xmax > d2.xmin; ) {
    const e5 = f2(f3, d2, x4, 0, m3);
    e5.queryEnvelope(b2);
    let t4 = false;
    t4 = l2 === a.enumPolyline ? !e5.isEmpty() && (b2.width() > x4 || b2.height() > x4) : !e5.isEmpty() && (l2 !== a.enumPolygon || b2.width() > x4), t4 && (e5.applyTransformation(y2), e5.queryEnvelope(b2), S3.queryEnvelope(C3), C3.inflateCoords(x4, x4), C3.isIntersecting(b2) && l2 === a.enumPolygon ? S3 = new al().execute(S3, e5, i2, m3) : S3.add(e5, false)), d2.move(r, 0), y2.shiftCoords(-r, 0);
  }
  return S3;
}
function Bl(e5, t3, s4, n6, r = true) {
  const i2 = new x2();
  i2.setCoords(s4, s4 + n6);
  const o = [0];
  if (Array.isArray(e5)) {
    const s5 = e5;
    for (let e6 = 0; e6 < t3; e6++) i2.containsRightExclusive(s5[e6].x) || (o[0] = s5[e6].x, Dl(o, i2, r), s5[e6].x = o[0]);
  } else {
    const s5 = e5;
    for (let e6 = 0; e6 < t3; e6++) {
      const t4 = e6 << 1;
      i2.containsRightExclusive(s5[t4]) || (o[0] = s5[t4], Dl(o, i2, r), s5[t4] = o[0]);
    }
  }
}
function Ol(t3, s4, r, h2 = true) {
  if (t3.isEmpty()) return;
  const m3 = t3.getGeometryType();
  if (!h2 || m3 !== a.enumPolygon) if (y(m3)) {
    let e5 = false;
    if (h(m3) && t3.hasNonLinearSegments()) {
      const n6 = t3.getImpl(), i2 = n6.getAttributeStreamRef(0), o = n6.getSegmentFlagsStreamRef();
      n2(null !== o);
      for (let t4 = 0, a2 = n6.getPathCount(); t4 < a2; t4++) {
        let a3 = true;
        const h3 = n6.isClosedPath(t4), m4 = n6.getPathEnd(t4);
        if (h3 && n6.getPathSize(t4) > 0) {
          a3 = 1 === (31 & o.read(m4 - 1));
        }
        for (let l2 = n6.getPathStart(t4); l2 < m4; l2++) {
          if (1 === (31 & o.read(l2))) {
            if (a3) {
              const t5 = i2.read(2 * l2), n7 = Gl(t5, s4, r);
              n7 !== t5 && (e5 = true, i2.write(2 * l2, n7));
            }
            a3 = true;
          } else a3 = false;
        }
      }
    } else {
      const n6 = t3.getImpl(), i2 = n6.getAttributeStreamRef(0);
      for (let t4 = 0, o = n6.getPointCount(); t4 < o; t4++) {
        const n7 = i2.read(2 * t4), o2 = Gl(n7, s4, r);
        o2 !== n7 && (e5 = true, i2.write(2 * t4, o2));
      }
    }
    e5 && t3.getImpl().notifyModifiedFlags(2001);
  } else if (m3 === a.enumEnvelope) {
    const n6 = t3, i2 = n4.constructEmpty();
    n6.queryEnvelope(i2), i2.xmin = Gl(i2.xmin, s4, r), i2.xmax = Gl(i2.xmax, s4, r), n6.setEnvelope(i2);
  } else if (m3 === a.enumPoint) {
    const e5 = t3;
    e5.setX(Gl(e5.getX(), s4, r));
  } else b("");
}
function Yl(e5, t3, s4) {
  const n6 = new mi();
  return n6.x = Gl(e5.x, t3, s4), n6.y = e5.y, n6;
}
function Rl(t3, s4) {
  if (s4.isEmpty()) return 0;
  const n6 = t3.getPECoordSys();
  if (n6.getProjection().getCode() === bc.PE_PRJ_AZIMUTHAL_EQUIDISTANT) {
    const r = Hu2();
    t3.querySpheroidData(r);
    const i2 = n6.getParameters();
    if (null === i2[bc.PE_PARM_LAM0]) return 0;
    if (null === i2[bc.PE_PARM_PHI0]) return 0;
    const o = [i2[bc.PE_PARM_LAM0].getValue(), i2[bc.PE_PARM_PHI0].getValue()];
    wc.geogToProj(n6, 1, o);
    const a2 = new mi(o[0], o[1]), h2 = n4.constructEmpty();
    s4.queryEnvelope(h2);
    const m3 = Ot(mi, 4);
    h2.queryCorners(m3);
    let l2 = 0;
    const g2 = t3.getOneMeter();
    let u = Math.max(r.majorSemiAxis, r.minorSemiAxis) * Math.PI, c = Math.min(r.majorSemiAxis, r.minorSemiAxis) * Math.PI;
    c -= u / 180, u *= g2, c *= g2;
    for (let e5 = 0; e5 < 4; e5++) {
      const t4 = mi.distance(m3[e5], a2);
      if (t4 > u) l2++;
      else if (t4 > c) return -1;
    }
    if (0 === l2) return 1;
    if (4 === l2) {
      const t4 = n4.constructEmpty();
      return t4.setCoords({ center: a2, width: u, height: u }), h2.isIntersectingNe(t4) ? -1 : 0;
    }
    return -1;
  }
  return -1;
}
function Xl(t3, s4, r, i2) {
  const o = t3.getGeometryType();
  n2(o === a.enumPolygon || o === a.enumPolyline || o === a.enumMultiPoint);
  const h2 = s4.getCoordinateSystemType();
  if (2 === h2) {
    let a2 = t3;
    if (0 === r) {
      const r2 = Rl(s4, t3);
      if (0 === r2) return t3.createInstance();
      if (1 === r2) return t3;
      const o2 = s4.getPCSHorizon(), h3 = o2.getGeometryType(), m3 = s4.getDefaultPrecisionSR();
      if (h3 === a.enumEnvelope) {
        const n6 = n4.constructEmpty();
        o2.queryEnvelope(n6);
        const r3 = zt2(m3, n6, false);
        a2 = f2(t3, n6, r3, 5e4 * s4.getOneMeterPCSUnit(), i2);
      } else new jm().execute(o2, t3, m3, i2) || (a2 = new wh2().execute(a2, o2, m3, i2), a2 === o2 && (a2 = a2.clone()));
    } else if (s4.isPannable()) {
      const t4 = n4.constructEmpty();
      a2.queryEnvelope(t4);
      const h3 = s4.getPannableExtent();
      h3.containsEnvelope(t4) || (Ol(a2, h3, s4.getTolerance(0)), 2 !== r && 4 !== r || (a2 = Al(a2, s4)), 4 !== r ? a2 = vl(a2, s4, 0, true, 1e5 * s4.getOneMeterPCSUnit(), i2) : o === a.enumPolygon && t4.width() > 2 * h3.width() && (a2 = ql(a2, -2 * h3.width(), 2 * h3.width(), s4, true, 0, true, i2)));
    }
    return a2;
  }
  if (n2(1 === h2), o === a.enumMultiPoint) return Ol(t3, s4.getPannableExtent(), s4.getTolerance(0)), t3;
  {
    const r2 = n4.constructEmpty();
    t3.queryEnvelope(r2);
    let a2 = t3;
    const h3 = s4.getPannableExtent();
    if (r2.ymin < h3.ymin || r2.ymax > h3.ymax) {
      const t4 = Math.max(1, r2.calculateToleranceFromEnvelope()), n6 = new n4(r2.xmin - t4, h3.ymin, r2.xmax + t4, h3.ymax);
      if (a2 = new I3().execute(a2, n6, s4, i2), a2.isEmpty()) return a2;
    }
    return o === a.enumPolygon && r2.width() > 2 * h3.width() && (a2 = ql(a2, -2 * h3.width(), 2 * h3.width(), s4, true, 0, true, i2)), a2;
  }
}
function Ll(e5, t3, s4, n6, r, i2) {
  const o = n6.getCoordinateSystemType();
  if (2 === o) {
    if (0 === r) s4 !== e5 && Gt(s4, e5, t3), Pl(n6, s4, t3);
    else if (s4 !== e5 && Gt(s4, e5, t3), n6.isPannable()) {
      const e6 = n6.getTolerance(0);
      El(s4, t3, n6.getPannableExtent(), e6), Nl(s4, t3, n6, 0);
    }
  } else {
    n2(1 === o);
    const r2 = n6.getTolerance(0), i3 = n6.getPannableExtent();
    for (let n7 = 0; n7 < t3; n7++) s4[n7].assign(Yl(e5[n7], i3, r2));
  }
}
function zl(e5, t3) {
  const s4 = t3.getPointCount();
  if (!s4) return;
  const n6 = t3.getImpl(), r = n6.getAttributeStreamRef(0), i2 = e5;
  wc.geogToProj(i2, s4, r.getArray()), n6.notifyModifiedFlags(2001);
}
function Wl(e5, t3, s4, n6) {
  if (!s4) return;
  const r = e5.getPECoordSys();
  if (1 === s4) {
    const s5 = [t3[0].x, t3[0].y];
    if (wc.geogToProj(r, 1, s5), n6) {
      const { first: n7, second: r2 } = e5.m_peCoordSysVal.getGeogToProjFactors();
      s5[0] = n7 * (t3[0].x - e5.getCentralMeridian()) + r2;
    }
    return void t3[0].setCoords(s5[0], s5[1]);
  }
  const i2 = e5.isPannable(), o = i2 ? e5.getPannableExtent().width() : 0, a2 = 179 * o / 360;
  let h2 = 0;
  i2 && (h2 = e5.getCentralMeridian());
  const m3 = 256, l2 = new Float64Array(2 * m3);
  for (let g2 = 0; g2 < s4; ) {
    for (let e6 = g2; e6 < s4 && t3[e6].isNAN(); ++e6) g2++;
    let u = Math.min(m3, s4 - g2);
    if (u > 0) {
      for (let e6 = 1, s5 = g2 + 1; e6 < u; ++e6, ++s5) if (t3[s5].isNAN()) {
        u = e6;
        break;
      }
      for (let e6 = 0; e6 < u; ++e6) {
        const s5 = e6 << 1;
        l2[s5] = t3[g2 + e6].x, l2[s5 + 1] = t3[g2 + e6].y;
      }
      if (wc.geogToProj(r, u, l2), n6) {
        const { first: s5, second: n7 } = e5.m_peCoordSysVal.getGeogToProjFactors();
        for (let e6 = 0; e6 < u; ++e6) {
          l2[e6 << 1] = s5 * (t3[g2 + e6].x - h2) + n7;
        }
      }
      if (i2) for (let e6 = 0, s5 = g2; e6 < u; e6++, s5++) {
        const n7 = e6 << 1, r2 = l2[n7], i3 = K(r2), m4 = t3[s5].x - h2;
        i3 * K(m4) < 0 && Math.abs(r2) > a2 && (l2[n7] -= i3 * o);
      }
      bl(l2, t3, g2, u), g2 += u;
    }
  }
}
function jl(e5, t3, s4, n6) {
  const r = e5.getSRToGCSTransform();
  return new qh().transform(r, t3, s4, n6, false);
}
function Zl(t3, s4, n6, r) {
  const i2 = new Ee({ vd: s4.getDescription() });
  let o;
  i2.addPoints(s4, 0, -1), o = new qh().execute(i2, t3, r);
  const a2 = s4.getPointCount();
  if (n6.setEmpty(), t3.getInputSR().isPannable()) {
    if (a2 !== o.getPointCount()) return false;
    const r2 = new n4();
    s4.queryEnvelope(r2);
    const i3 = new n4();
    o.queryEnvelope(i3);
    const h2 = r2.width(), m3 = i3.width();
    if (0 !== h2 && 0 !== m3) {
      const e5 = m3 / h2, s5 = t3.getOutputSR().getPannableExtent().width() / t3.getInputSR().getPannableExtent().width();
      if (Math.abs(e5 / s5 - 1) > 1e-10) return false;
    } else if (0 !== h2 || 0 !== m3) return false;
    n6.add(s4, false);
    for (let e5 = 0; e5 < a2; e5++) {
      const t4 = o.getXY(e5);
      n6.setXY(e5, t4);
    }
    return true;
  }
  return false;
}
function Kl(e5, t3, s4) {
  n2(!s4 || e5.isPannable());
  const n6 = t3.getPointCount();
  if (!n6) return;
  const r = t3.getImpl(), i2 = r.getAttributeStreamRef(0), o = e5.getPECoordSys();
  let h2 = 0;
  const m3 = i2.readRange(0, 2 * n6);
  let l2 = () => {
    wc.geogToProj(o, n6, m3);
  };
  const g2 = e5.isPannable() && !s4, u = g2 ? e5.getPannableExtent().width() : 0, c = 179 * u / 360;
  if (e5.isPannable() && (h2 = e5.getCentralMeridian(), s4)) {
    const t4 = e5.m_peCoordSysVal.getGeogToProjFactors(), s5 = t4.first, r2 = t4.second;
    l2 = () => {
      wc.geogToProj(o, n6, m3);
      for (let e6 = 0; e6 < n6; e6++) {
        const t5 = e6 << 1, n7 = i2.read(t5), o2 = s5 * (n7 - h2) + r2;
        m3[t5] = o2;
      }
    };
  }
  if (l2(), g2) for (let a2 = 0; a2 < n6; a2++) {
    const e6 = a2 << 1, t4 = m3[e6], s5 = K(t4), n7 = i2.read(e6) - h2;
    s5 * K(n7) < 0 && Math.abs(t4) > c && (m3[e6] += -s5 * u);
  }
  i2.writeRangeFromArray(0, 2 * n6, m3, true, 1), r.notifyModifiedFlags(2001);
}
function Ql(e5, t3, s4) {
  switch (t3.getGeometryType()) {
    case a.enumLine:
      return void Ig(e5, t3, s4);
    case a.enumBezier:
      return void Gg(e5, t3, s4);
    case a.enumEllipticArc:
      return void wg(e5, t3, s4);
    case a.enumBezier2:
      return void Dg();
    case a.enumRationalBezier2:
      return void Vg();
    default:
      b("");
  }
}
function Jl(e5, t3, s4) {
  if (!t3.hasNonLinearSegments()) return void Kl(e5, t3, s4);
  if (n2(!s4 || e5.isPannable()), t3.isEmpty()) return;
  const n6 = 0, r = e5.getPECoordSys(), i2 = e5.isPannable(), o = i2 ? e5.getPannableExtent().width() : 0, h2 = 179 * o / 360;
  let m3 = 0;
  i2 && (m3 = e5.getCentralMeridian());
  const l2 = t3.createInstance();
  l2.reserveParts(t3.getPointCount(), t3.getPathCount());
  const g2 = t3.getImpl(), u = new fm();
  for (let a2 = 0, c = t3.getPathCount(); a2 < c; ++a2) if (g2.hasNonLinearSegmentsPath(a2)) {
    let t4 = true, n7 = -1;
    const r2 = g2.getPathStart(a2), i3 = r2 + g2.getSegmentCountPath(a2);
    g2.isClosedPath(a2) && (n7 = i3 - 1);
    const o2 = new mi();
    for (let a3 = r2; a3 < i3; ++a3) {
      if (g2.getSegmentBuffer(a3, u, false), Ql(e5, u.get(), s4), !t4) {
        u.get().getStartXY().equals(o2) || u.get().moveTo(o2);
      }
      if (a3 !== n7) l2.addSegment(u.get(), t4);
      else {
        if (t4) {
          const e6 = new ee();
          u.get().queryStart(e6), l2.startPathPoint(e6);
        }
        l2.closeLastPathWithSegment(u.get());
      }
      o2.assign(u.get().getEndXY()), t4 = false;
    }
  } else {
    const e6 = 1024;
    let s5, u2 = g2.getPathSize(a2), c2 = Math.min(u2, e6);
    l2.insertPath(-1, t3, a2, true);
    const _ = g2.getAttributeStreamRef(0), d2 = l2.getAttributeStreamRef(0);
    for (let t4 = g2.getPathStart(a2), l3 = g2.getPathEnd(a2); t4 < l3; ) {
      if (s5 = _.readRange(t4, c2), wc.geogToProj(r, c2, s5), i2) for (let e7 = 0; e7 < c2; e7++) {
        const t5 = e7 << 1, r2 = s5[t5], i3 = K(r2), a3 = _.read(2 * (n6 + e7)) - m3;
        i3 * K(a3) < 0 && Math.abs(r2) > h2 && (s5[t5] += -i3 * o);
      }
      d2.writeRangeFromArray(t4, c2, s5, true, 1), t4 += c2, u2 -= c2, c2 = Math.min(u2, e6);
    }
  }
  t3.assignMove(l2);
}
function $l(e5, t3, s4) {
  const n6 = 1e3;
  let r = s4.getPointCount();
  if (!r) return;
  const i2 = s4.getImpl(), o = i2.getAttributeStreamRef(0);
  let a2 = Math.min(r, n6), h2 = 0;
  const m3 = e5.getPECoordSys();
  Number.isNaN(t3) && (t3 = 0);
  const l2 = e5.isPannable(), g2 = e5.getOneDegreeGCSUnit(), u = 360 * g2, c = 179 * g2;
  let _;
  for (; r; ) {
    if (_ = o.readRange(2 * h2, 2 * a2), ag(m3, a2, _, t3), l2) for (let e6 = 0; e6 < a2; e6++) {
      const s5 = e6 << 1, n7 = _[s5] - t3, r2 = K(n7), i3 = o.read(2 * (h2 + e6));
      r2 * K(i3) < 0 && Math.abs(n7) > c && (_[s5] += -r2 * u);
    }
    o.writeRangeFromArray(2 * h2, 2 * a2, _, true, 1), h2 += a2, r -= a2, a2 = Math.min(r, n6);
  }
  i2.notifyModifiedFlags(2001);
}
function eg(e5, t3, s4) {
  switch (s4.getGeometryType()) {
    case a.enumLine:
      return void tg(e5, t3, s4);
    case a.enumBezier:
      return void rg(e5, t3, s4);
    case a.enumEllipticArc:
      return void sg(e5, t3, s4);
    case a.enumBezier2:
      return void ig();
    case a.enumRationalBezier2:
      return void og();
    default:
      b("");
  }
}
function tg(e5, t3, s4) {
  const n6 = [s4.getStartXY(), s4.getEndXY()];
  mg(e5, t3, n6, 2), s4.setStartXY(n6[0]), s4.setEndXY(n6[1]), s4.normalizeAfterEndpointChange();
}
function sg(e5, t3, s4) {
  if (0 === s4.projectionBehavior()) ng(e5, t3, s4);
  else {
    const n6 = s4.isClosed() && s4.isMajor(), r = [s4.getStartXY(), n6 ? s4.getCenter() : s4.getEndXY()], i2 = [r[0].clone(), r[1].clone()];
    vg(e5, t3, i2, 2);
    const o = new x3();
    o.initializeFromTwoPointsArray(r, i2), s4.applyTransformation(o);
    const a2 = n6 ? 0 : 1;
    s4.setCoordsForIntersector(i2[0], i2[a2], false);
  }
}
function ng(e5, t3, s4) {
  Ng(false, e5, t3, s4, false);
}
function rg(e5, t3, s4) {
  const n6 = Ot(mi, 4);
  s4.queryControlPoints(n6), vg(e5, t3, n6, 4), s4.setControlPoints(n6);
}
function ig(e5, t3, s4) {
  n2(0);
}
function og(e5, t3, s4) {
  n2(0);
}
function ag(e5, t3, s4, n6) {
  const r = wc.projToGeogCenter(e5, t3, s4, n6);
  for (let i2 = 0; i2 < t3; ++i2) {
    const e6 = i2 << 1;
    n2(Number.isFinite(s4[e6] + s4[e6 + 1]));
  }
  return r;
}
function hg(e5, t3, s4) {
  if (!s4.hasNonLinearSegments()) return void $l(e5, t3, s4);
  if (s4.isEmpty()) return;
  const n6 = e5.getPECoordSys();
  Number.isNaN(t3) && (t3 = 0);
  const r = e5.isPannable(), i2 = e5.getOneDegreeGCSUnit(), o = 360 * i2, a2 = 179 * i2, h2 = s4.createInstance();
  h2.reserveParts(s4.getPointCount(), s4.getPathCount());
  const m3 = s4.getImpl(), l2 = new fm();
  for (let g2 = 0, u = s4.getPathCount(); g2 < u; ++g2) if (m3.hasNonLinearSegmentsPath(g2)) {
    let s5 = true, n7 = -1;
    const r2 = m3.getPathStart(g2), i3 = r2 + m3.getSegmentCountPath(g2);
    m3.isClosedPath(g2) && (n7 = i3 - 1);
    const o2 = new mi();
    for (let a3 = r2; a3 < i3; ++a3) {
      if (m3.getSegmentBuffer(a3, l2, false), eg(e5, t3, l2.get()), !s5) {
        l2.get().getStartXY().equals(o2) || l2.get().moveTo(o2);
      }
      if (a3 !== n7) h2.addSegment(l2.get(), s5);
      else {
        if (s5) {
          const e6 = new ee();
          l2.get().queryStart(e6), h2.startPathPoint(e6);
        }
        h2.closeLastPathWithSegment(l2.get());
      }
      o2.assign(l2.get().getEndXY()), s5 = false;
    }
  } else {
    const e6 = 1e3;
    let i3, l3 = m3.getPathSize(g2), u2 = Math.min(l3, e6);
    h2.insertPath(-1, s4, g2, true);
    const c = m3.getAttributeStreamRef(0), _ = h2.getAttributeStreamRef(0);
    for (let s5 = m3.getPathStart(g2), h3 = m3.getPathEnd(g2); s5 < h3; ) {
      if (i3 = c.readRange(2 * s5, 2 * u2), ag(n6, u2, i3, t3), r) for (let e7 = 0; e7 < u2; e7++) {
        const n7 = e7 << 1, r2 = i3[n7] - t3, h4 = K(r2), m4 = c.read(2 * s5);
        h4 * K(m4) < 0 && Math.abs(r2) > a2 && (i3[n7] += -h4 * o);
      }
      _.writeRangeFromArray(2 * s5, 2 * u2, i3, true, 1), s5 += u2, l3 -= u2, u2 = Math.min(l3, e6);
    }
  }
  s4.assignMove(h2);
}
function mg(e5, t3, s4, n6) {
  const r = e5.getPECoordSys();
  Number.isNaN(t3) && (t3 = 0);
  const i2 = e5.isPannable(), o = e5.getOneDegreeGCSUnit(), a2 = 360 * o, h2 = 179 * o, m3 = 256, l2 = new Float64Array(2 * m3);
  for (let g2 = 0; g2 < n6; ) {
    for (let t4 = g2; t4 < n6 && s4[t4].isNAN(); ++t4) g2++;
    let e6 = Math.min(m3, n6 - g2);
    if (e6 > 0) {
      for (let t4 = 1, n7 = g2 + 1; t4 < e6; ++t4, ++n7) if (s4[n7].isNAN()) {
        e6 = t4;
        break;
      }
      for (let t4 = 0; t4 < e6; t4++) {
        const e7 = t4 << 1;
        l2[e7] = s4[g2 + t4].x, l2[e7 + 1] = s4[g2 + t4].y;
      }
      if (ag(r, e6, l2, t3), i2) for (let n7 = 0, r2 = g2; n7 < e6; ++n7, ++r2) {
        const e7 = n7 << 1, i3 = s4[r2].x, o2 = l2[e7] - t3, m4 = K(o2);
        m4 * K(i3) < 0 && Math.abs(o2) > h2 && (l2[e7] -= m4 * a2);
      }
      for (let t4 = 0; t4 < e6; t4++) {
        const e7 = t4 << 1;
        s4[g2 + t4].x = l2[e7], s4[g2 + t4].y = l2[e7 + 1];
      }
      g2 += e6;
    }
  }
}
function lg(e5, t3, s4, n6) {
  n2(0);
}
function gg(e5, t3, s4) {
  let n6 = t3.getPointCount();
  if (!n6) return false;
  const r = t3.getImpl(), i2 = r.getAttributeStreamRef(0);
  let o = null;
  const a2 = e5.getInputSR(), h2 = e5.getOutputSR();
  a2.getVCS(), h2.getVCS();
  const m3 = a2.getOneDegreeGCSUnit(), l2 = h2.getOneDegreeGCSUnit(), g2 = e5.isVertical();
  g2 && t3.hasAttribute(1) && (o = r.getAttributeStreamRef(1));
  const u = e5.getDatumTransformation(), c = !!u && 1 === u.getType();
  if (c || null === o || (lg(o.getArray()), o = null), !u || 0 === u.count()) {
    const e6 = a2.getGcsUnitFactor() / h2.getGcsUnitFactor(), t4 = (a2.getPrimeMeridian() - h2.getPrimeMeridian()) * l2, s5 = -90 * m3, o2 = 90 * m3;
    let g3 = 0;
    const u2 = i2.getArray(), c2 = [0];
    for (let r2 = 1, i3 = 2 * n6; r2 < i3; ) c2[0] = u2[r2], g3 |= Ys(c2, s5, o2) ? 1 : 0, u2[r2] = c2[0], r2 += 2;
    if (0 !== t4 || 1 !== e6) {
      g3 = 1;
      const s6 = i2.getArray();
      for (let r2 = 0, i3 = 2 * n6; r2 < i3; ) {
        let n7 = s6[r2];
        n7 *= e6, n7 += t4, s6[r2] = n7, s6[r2 + 1] *= e6, r2 += 2;
      }
    }
    return 0 !== g3 && r.notifyModifiedFlags(2001), !!g3;
  }
  const _ = 1e3;
  let d2 = Math.min(n6, _);
  const p3 = Yt(d2, Number.NaN), f3 = Yt(d2, Number.NaN);
  let x4 = null;
  null !== o && (x4 = new Float64Array(d2));
  let y2 = 0, P5 = Number.NaN, E2 = Number.NaN;
  const S3 = 360 * l2, C3 = l2 / m3;
  s4 && (E2 = 90 * l2, P5 = 89.9 * m3, f3.fill(0));
  let I4 = true, b2 = 0;
  for (; n6; ) {
    let e6 = false;
    const t4 = i2.readRange(2 * y2, 2 * d2);
    for (let s5 = 0; s5 < d2; s5++) p3[s5] = t4[s5 << 1];
    if (s4) for (let s5 = 0; s5 < d2; s5++) {
      const n7 = 1 + (s5 << 1), r3 = Math.abs(t4[n7]) - P5;
      if (r3 > 0) {
        const i3 = t4[n7];
        t4[n7] = B2(P5, i3), f3[s5] = B2(r3, i3), e6 = true;
      }
    }
    const r2 = t4[0];
    if (c) {
      const e7 = u;
      x4 && o.queryRange(y2, d2, x4, true, 1), e7.transform(false, t4, x4, d2), x4 && o.writeRangeFromArray(y2, d2, x4, true, 1);
    } else {
      u.transform(false, t4, d2);
    }
    I4 && (b2 = t4[0] - C3 * r2, I4 = false);
    for (let s5 = 0; s5 < d2; s5++) {
      const e7 = s5 << 1, n7 = t4[e7] - p3[s5] * C3 - b2;
      Math.abs(n7) > 200 && (t4[e7] += n7 > 0 ? -S3 : S3);
    }
    if (e6) {
      for (let e7 = 0; e7 < d2; e7++) if (f3[e7]) {
        const s5 = 1 + (e7 << 1);
        t4[s5] += C3 * f3[e7], t4[s5] > E2 ? t4[s5] = E2 : t4[s5] < -E2 && (t4[s5] = -E2);
      }
      f3.fill(0);
    }
    i2.writeRangeFromArray(2 * y2, 2 * d2, t4, true, 1), g2 && o && o.writeRangeFromArray(y2, d2, x4, true, 1), y2 += d2, n6 -= d2, d2 = Math.min(n6, _);
  }
  return r.notifyModifiedFlags(2001), true;
}
function ug(e5, t3, s4) {
  switch (t3.getGeometryType()) {
    case a.enumLine:
      return xg(e5, t3, s4);
    case a.enumBezier:
      return Eg(e5, t3, s4);
    case a.enumEllipticArc:
      return yg(e5, t3, s4);
    case a.enumBezier2:
      return Sg();
    case a.enumRationalBezier2:
      return Cg();
    default:
      b("");
  }
}
function cg(e5, t3, s4) {
  if (!t3.hasNonLinearSegments()) return gg(e5, t3, s4);
  if (t3.isEmpty()) return false;
  const n6 = t3.createInstance();
  n6.reserveParts(t3.getPointCount(), t3.getPathCount());
  const r = t3.getImpl(), i2 = new fm();
  for (let o = 0, a2 = t3.getPathCount(); o < a2; ++o) {
    let t4 = true, a3 = -1;
    const h2 = r.getPathStart(o), m3 = h2 + r.getSegmentCountPath(o);
    r.isClosedPath(o) && (a3 = m3 - 1);
    const l2 = new mi();
    for (let o2 = h2; o2 < m3; ++o2) {
      if (r.getSegmentBuffer(o2, i2, false), ug(e5, i2.get(), s4), !t4) {
        i2.get().getStartXY().equals(l2) || i2.get().moveTo(l2);
      }
      if (o2 !== a3) n6.addSegment(i2.get(), t4);
      else {
        if (t4) {
          const e6 = new ee();
          i2.get().queryStart(e6), n6.startPathPoint(e6);
        }
        n6.closeLastPathWithSegment(i2.get());
      }
      l2.assign(i2.get().getEndXY()), t4 = false;
    }
  }
  return t3.assignMove(n6), true;
}
function _g(e5, t3, s4, n6, r, i2) {
  if (e5.isIdentityGeogToGeog()) {
    const s5 = 90 * e5.getInputSR().getOneDegreeGCSUnit();
    let r2 = 0;
    const i3 = [0];
    for (let e6 = 0; e6 < n6; e6++) i3[0] = t3[e6].y, r2 |= Ys(i3, -s5, s5) ? 1 : 0, t3[e6].y = i3[0];
    return r2;
  }
  const o = e5.getInputSR(), a2 = e5.getOutputSR(), h2 = o.getVCS(), m3 = a2.getVCS(), l2 = o.getOneDegreeGCSUnit(), g2 = 90 * l2, u = a2.getOneDegreeGCSUnit(), c = e5.isVertical(), _ = e5.getDatumTransformation(), d2 = !!_ && 1 === _.getType();
  if (c || (s4 = null), !_ || 0 === _.count()) {
    let e6 = 0;
    const r2 = [0];
    for (let s5 = 0; s5 < n6; s5++) r2[0] = t3[s5].y, e6 |= Ys(r2, -g2, g2) ? 1 : 0, t3[s5].y = r2[0];
    return e6 |= qm(o.getGCS(), h2, a2.getGCS(), m3, t3, s4, n6) ? 1 : 0, e6;
  }
  d2 || null === s4 || lg();
  const p3 = 1024;
  let f3 = Math.min(n6, p3);
  const x4 = Yt(f3, Number.NaN), y2 = Yt(f3, Number.NaN);
  let P5 = 0, E2 = Number.NaN, S3 = Number.NaN;
  const C3 = 360 * u, I4 = u / l2;
  r && (S3 = 90 * u, E2 = 89.9 * l2);
  let b2 = true, w4 = 0, v3 = n6;
  for (; v3; ) {
    let e6 = false;
    for (let s5 = 0; s5 < f3; s5++) x4[s5] = t3[s5 + P5].x;
    if (r) for (let s5 = 0; s5 < f3; s5++) {
      const n8 = Math.abs(t3[s5 + P5].y) - E2;
      if (n8 > 0) {
        const r2 = t3[s5 + P5].y;
        t3[s5 + P5].y = B2(E2, r2), y2[s5] = B2(n8, r2), e6 = true;
      }
    }
    const n7 = t3[0].x;
    if (d2) {
      _.transform(false, t3, s4, f3);
    } else {
      _.transform(false, t3, f3);
    }
    b2 && (w4 = t3[0].x - I4 * n7, b2 = false);
    for (let s5 = 0; s5 < f3; s5++) {
      const e7 = t3[P5 + s5].x - x4[s5] * I4 - w4;
      Math.abs(e7) > 200 && (e7 > 0 ? t3[P5 + s5].x -= C3 : t3[P5 + s5].x += C3);
    }
    if (e6) {
      for (let e7 = 0; e7 < f3; e7++) y2[e7] && (t3[P5 + e7].y += I4 * y2[e7], t3[P5 + e7].y > S3 ? t3[P5 + e7].y = S3 : t3[P5 + e7].y < -S3 && (t3[P5 + e7].y = -S3));
      y2.fill(0, 0, f3);
    }
    P5 += f3, v3 -= f3, f3 = Math.min(v3, p3);
  }
  return 1;
}
function dg(e5, t3, s4, n6, r) {
  return n2(0), 0;
}
function pg(e5, t3, s4, n6, r) {
  n2(null === n6), n2(t3 < 2147483647);
  const i2 = Array.isArray(s4);
  let o;
  o = i2 ? ai(s4) : s4;
  const h2 = vc.geogToGeog(e5, t3, o, null, r);
  return i2 && hi(o, s4), h2;
}
function fg(e5, t3, s4, n6, r, i2) {
  let o = 0, a2 = true, h2 = 0;
  for (let m3 = 0; m3 < n6; ++m3) t3[m3].isNAN() ? a2 || (o |= _g(e5, t3.slice(h2, m3 - h2), s4 ? s4.slice(h2, m3 - h2) : null, m3 - h2, r), h2 = m3, a2 = true) : a2 && (h2 = m3, a2 = false);
  return a2 || (o |= _g(e5, 0 === h2 ? t3 : t3.slice(h2), s4 ? 0 === h2 ? s4 : s4.slice(h2) : null, n6 - h2, r)), 0 !== o;
}
function xg(e5, t3, s4) {
  const n6 = [t3.getStartXY(), t3.getEndXY()], r = [0, 0];
  let i2 = null;
  t3.hasAttribute(1) && (i2 = r, i2[0] = t3.getAttributeAsDbl(0, 1, 0), i2[1] = t3.getAttributeAsDbl(1, 1, 0));
  const o = fg(e5, n6, i2, 2, s4);
  return t3.setStartXY(n6[0]), t3.setEndXY(n6[1]), i2 && (t3.setStartAttribute(1, 0, i2[0]), t3.setEndAttribute(1, 0, i2[1])), t3.normalizeAfterEndpointChange(), o;
}
function yg(e5, t3, s4) {
  if (0 === t3.projectionBehavior()) return Pg(e5, t3, s4);
  const n6 = t3.getStartXY().equals(t3.getEndXY()), r = Ot(mi, 3), i2 = Ot(mi, 3), o = [0, 0, 0];
  let a2 = null;
  r[0].assign(t3.getStartXY()), r[1].assign(n6 ? t3.getCenter() : t3.getEndXY());
  let h2 = false;
  t3.hasAttribute(1) && (a2 = o, a2[0] = t3.getAttributeAsDbl(0, 1, 0), a2[1] = t3.getAttributeAsDbl(1, 1, 0), a2[2] = Q(a2[0], a2[1], 0.5), n6 && (a2[1] = a2[2])), i2[0].setCoordsPoint2D(r[0]), i2[1].setCoordsPoint2D(r[1]);
  const m3 = new x3();
  if (n6 || t3.isDegenerateToLine()) h2 = fg(e5, i2, a2, 2, s4), m3.initializeFromTwoPoints(r[0], r[1], i2[0], i2[1]);
  else {
    const n7 = new mi();
    t3.queryCoord2D(0.5, n7), r[2].setCoordsPoint2D(n7), i2[2].setCoordsPoint2D(n7), h2 = fg(e5, i2, a2, 3, s4), m3.setFromTwoTriangles(r, i2);
  }
  return m3.isIdentity() || (t3.applyTransformation(m3), t3.setStartXY(i2[0]), t3.setEndXY(n6 ? i2[0] : i2[1]), t3.normalizeAfterEndpointChange()), a2 && (t3.setStartAttribute(1, 0, a2[0]), t3.setEndAttribute(1, 0, n6 ? a2[0] : a2[1])), h2;
}
function Pg(e5, t3, s4) {
  const n6 = [t3.getStartXY(), t3.getEndXY(), t3.getInteriorPoint(), t3.getCenter()];
  let r = 4;
  t3.isDegenerateToLine() && (r = 2);
  const i2 = [0, 0, 0, 0];
  let o = null;
  if (t3.hasAttribute(1)) {
    o = i2, o[0] = t3.getAttributeAsDbl(0, 1, 0), o[1] = t3.getAttributeAsDbl(1, 1, 0);
    const e6 = Q(o[0], o[1], 0.5);
    o[2] = e6, o[3] = e6;
  }
  const a2 = t3.getStartXY().equals(t3.getEndXY()) && !t3.isDegenerateToLine(), h2 = fg(e5, n6, o, r, s4);
  return a2 ? t3.constructCircleCenterAndPoint(n6[3], n6[0], !t3.isClockwise()) : t3.isDegenerateToLine() ? t3.constructLineCircularArc(n6[0], n6[1]) : t3.constructCircularArcThreePoint(n6[0], n6[1], n6[2]), o && (t3.setStartAttribute(1, 0, o[0]), t3.setEndAttribute(1, 0, o[1])), h2;
}
function Eg(e5, t3, s4) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6);
  const r = [0, 0, 0, 0];
  let i2 = null;
  t3.hasAttribute(1) && (i2 = r, i2[0] = t3.getAttributeAsDbl(0, 1, 0), i2[3] = t3.getAttributeAsDbl(1, 1, 0), i2[1] = Q(i2[0], i2[3], 0.5), i2[2] = i2[1]);
  const o = fg(e5, n6, i2 || null, n6.length, s4);
  return t3.setControlPoints(n6), i2 && (t3.setStartAttribute(1, 0, i2[0]), t3.setEndAttribute(1, 0, i2[3])), t3.normalizeAfterEndpointChange(), o;
}
function Sg(e5, t3, s4) {
  return n2(0), false;
}
function Cg(e5, t3, s4) {
  return n2(0), false;
}
function Ig(e5, t3, s4) {
  const n6 = [t3.getStartXY(), t3.getEndXY()];
  Wl(e5, n6, 2, s4), t3.setStartXY(n6[0]), t3.setEndXY(n6[1]), t3.normalizeAfterEndpointChange();
}
function bg(e5, t3, s4, n6) {
  Wl(e5, t3, s4, n6);
}
function wg(e5, t3, s4) {
  if (0 === t3.projectionBehavior()) Tg(e5, t3, s4);
  else {
    const n6 = t3.isClosed() && t3.isMajor(), r = [t3.getStartXY(), n6 ? t3.getCenter() : t3.getEndXY()], i2 = [r[0].clone(), r[1].clone()];
    bg(e5, i2, 2, s4);
    const o = new x3();
    o.initializeFromTwoPointsArray(r, i2), t3.applyTransformation(o);
    const a2 = n6 ? 0 : 1;
    t3.setCoordsForIntersector(i2[0], i2[a2], false);
  }
}
function vg(t3, s4, n6, r) {
  mg(t3, s4, n6, r);
  const i2 = new n4();
  i2.setFromPoints(n6, r);
  const o = t3.getOneDegreeGCSUnit(), a2 = 360 * o, h2 = 180 * o;
  if (i2.width() > h2) {
    for (let e5 = 0; e5 < r; e5++) for (; n6[e5].x < s4; ) n6[e5].x += a2;
    if (i2.setFromPoints(n6, r), i2.xmax > h2 + s4) for (let e5 = 0; e5 < r; e5++) n6[e5].x -= a2;
  }
}
function Ng(e5, t3, s4, n6, r) {
  const i2 = Ot(mi, 3);
  let o = 0, a2 = false, h2 = false;
  const m3 = n6.isDegenerateToLine();
  m3 ? (i2[0].assign(n6.getStartXY()), i2[1].assign(n6.getEndXY()), i2[2].setCoords(0, 0), o = 2) : n6.isClosed() && n6.isMajor() ? (a2 = true, h2 = !n6.isClockwise(), i2[0].assign(n6.getStartXY()), i2[1].assign(n6.getCenter()), i2[2].setCoords(0, 0), o = 2) : (i2[0].assign(n6.getStartXY()), i2[1].assign(n6.getEndXY()), i2[2].assign(n6.getInteriorPoint()), o = 3), e5 ? bg(t3, i2, o, r) : vg(t3, s4, i2, o), m3 ? n6.constructLineCircularArc(i2[0], i2[1]) : a2 ? n6.constructCircleCenterAndPoint(i2[1], i2[0], h2) : n6.constructCircularArcThreePoint(i2[0], i2[1], i2[2]);
}
function Tg(e5, t3, s4) {
  Ng(true, e5, 0, t3, s4);
}
function Gg(e5, t3, s4) {
  const n6 = Ot(mi, 4);
  t3.queryControlPoints(n6), bg(e5, n6, 4, s4), t3.setControlPoints(n6);
}
function Dg(e5, t3, s4) {
  n2(0);
}
function Vg(e5, t3, s4) {
  n2(0);
}
function Fg(e5, t3, s4) {
  const n6 = Th(e5), r = Th(t3), i2 = Yh(n6, r), o = Yh(n6, Th(s4));
  return 0 === o || (i2 > 0 && o > 0 && o <= i2 || i2 < 0 && o < 0 && o >= i2);
}
function Hg(e5, t3, s4, n6, r) {
  const i2 = { stack: [], error: void 0, hasError: false };
  try {
    const o = s4.clone(), h2 = n6.clone();
    if (2 === r) {
      const s5 = [0, 0];
      return Ds3(e5, t3, o, h2, 0, s5), s5[0];
    }
    if (o.y > h2.y) {
      const e6 = new mi();
      e6.assign(o), o.assign(h2), h2.assign(e6);
    }
    const m3 = n(i2, new Cc(), false), l2 = n(i2, new Cc(), false), g2 = n(i2, new Cc(), false), u = new x2();
    if (u.setCoords(o.y, h2.y), !u.containsCoordinate(0) || Math.abs(o.x - h2.x) >= Math.PI) return Number.NaN;
    if (o.x === h2.x) return o.x;
    Dc.geodeticDistance(e5, t3, o.x, o.y, h2.x, h2.y, l2, m3, null, r);
    const c = l2.val;
    let _ = 0, d2 = 1;
    const p3 = o.clone();
    for (; c * (d2 - _) > 1e-12 * e5; ) {
      const s5 = 0.5 * (_ + d2);
      if (Dc.geodeticCoordinate(e5, t3, o.x, o.y, c * s5, m3.val, l2, g2, r), p3.x = l2.val, p3.y = g2.val, u.setCoords(o.y, p3.y), 0 === p3.y) return p3.x;
      if (u.containsCoordinate(0)) d2 = s5;
      else {
        if (u.setCoords(h2.y, p3.y), !u.containsCoordinate(0)) return n2(false), Number.NaN;
        _ = s5;
      }
    }
    return p3.x;
  } catch (o) {
    i2.error = o, i2.hasError = true;
  } finally {
    s(i2);
  }
}
function kg(e5, t3, s4, n6) {
  const r = new x2();
  r.setCoords(t3, s4);
  const i2 = n6.width();
  let o = Math.floor((e5 - t3) / i2) * i2 + e5;
  const a2 = r.getCenter();
  for (; Math.abs(o - a2) > Math.abs(o + i2 - a2); ) o += i2;
  return o;
}
var Ag = class extends t {
  constructor() {
    super(), this.m_geometryDeque = [], this.m_index = -1;
  }
  next() {
    if (this.m_geometryDeque.length > 0) {
      this.m_index++;
      const e5 = this.m_geometryDeque[0];
      return this.m_geometryDeque.shift(), e5;
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tick(e5) {
    this.m_geometryDeque.push(e5);
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function Mg(e5, t3) {
  return e5 === t3 || null !== e5 && null !== t3 && (e5.m_csType === t3.m_csType && (0 === e5.m_WKID && 0 === t3.m_WKID ? e5.m_hashCode === t3.m_hashCode && e5.m_canonicalWkt === t3.m_canonicalWkt : e5.m_WKID === t3.m_WKID));
}
function Ug(e5, t3) {
  return e5 === t3 || null !== e5 && null !== t3 && (e5.m_csType === t3.m_csType && (0 === e5.m_WKID && 0 === t3.m_WKID ? 1 === e5.m_csType ? e5.m_peCoordSys.isEqual(t3.m_peCoordSys) : e5.m_peCoordSys === t3.m_peCoordSys : e5.m_WKID === t3.m_WKID));
}
var qg = class {
  constructor(s4, n6 = true) {
    this.m_PCSHorizon = null, this.m_GCSHorizon = null, this.m_GCSSplitLines = null, this.m_bGCSHorisonIsInclusive = false, this.m_oneMeterPCS = 0, this.m_oneDegreeGCS = 0, this.m_gcsUnitFactor = 0, this.m_northPole = mi.getNAN(), this.m_southPole = mi.getNAN(), this.m_polesUpdated = 0, this.m_domain = n4.constructEmpty(), this.m_primeMeridian = Number.NaN, this.m_geogToProjFactor = 1, this.m_geogToProjOffset = 0, this.m_geogToProjFactorsUpdated = 0, this.m_oneMillimeter = 0, this.m_centralMeridian = 0, this.m_pPCSInfoNoDomain = null, this.m_oldWKID = -1973, this.m_vcsWKID = -1, this.m_bIsPannable = false, this.m_bCached = false, this.m_pannableExtent = n4.constructEmpty(), this.m_pannableExtentGCS = n4.constructEmpty(), this.m_areaOfUse = null, this.m_canonicalWkt = "", this.m_peCoordSys = s4, this.m_WKID = Ic.getCode(s4), this.m_WKID <= 0 ? (this.m_WKID = 0, this.m_canonicalWkt = _l(s4, 0, true), this.m_hashCode = Ds(this.m_canonicalWkt)) : this.m_hashCode = Ss(this.m_WKID);
    const r = this.m_peCoordSys.getType();
    this.m_csType = r === bc.PE_TYPE_PROJCS ? 2 : 1, n2(r === bc.PE_TYPE_PROJCS || r === bc.PE_TYPE_GEOGCS), r === bc.PE_TYPE_PROJCS && (s4.loadConstants() || P("PeProjcs.loadConstants failed"));
    const o = r === bc.PE_TYPE_GEOGCS ? this.m_peCoordSys : this.m_peCoordSys.getGeogcs();
    r !== bc.PE_TYPE_GEOGCS && Ic.getCode(o), this.m_unit = ms2(s4), this.m_primeMeridian = o.getPrimem().getLongitude();
    {
      const e5 = o.getUnit().getUnitFactor();
      this.m_gcsUnitFactor = e5;
      let t3 = Math.PI / (180 * e5);
      Math.abs(t3 - 1) < 1e-10 && (t3 = 1), this.m_oneDegreeGCS = t3;
    }
    if (r === bc.PE_TYPE_PROJCS) {
      const e5 = this.m_peCoordSys, t3 = e5.getUnit().getUnitFactor();
      this.m_oneMeterPCS = 1 / t3, this.m_oneMillimeter = 1e-3 / t3, this.m_pPCSInfoNoDomain = Nc.generate(e5, Nc.PE_PCSINFO_OPTION_NONE), this.m_pPCSInfoNoDomain || b("cannot create pcs info"), this.m_bIsPannable = this.m_pPCSInfoNoDomain.isPannableRectangle(), this.m_centralMeridian = this.m_pPCSInfoNoDomain.getCentralMeridian();
    } else {
      this.m_bIsPannable = true, this.m_polesUpdated = 1, this.m_oneMeterPCS = 0;
      const e5 = 1 / o.getUnit().getUnitFactor(), t3 = o.getDatum().getSpheroid().getAxis();
      this.m_oneMillimeter = 1e-3 / t3 * e5, this.m_centralMeridian = 0;
    }
    this.m_bIsPannable && (this.updateGCSHorizon(), this.updatePCSHorizon(), this.updatePoles(), this.updateDomain(), this.updatePannableExtent(), this.updatePannableExtentGCS());
  }
  [Symbol.dispose]() {
  }
  getHashCode() {
    return this.m_hashCode;
  }
  getPCSHorizonPannable() {
    return this.m_PCSHorizon;
  }
  getGCSHorizonPannable() {
    return this.m_GCSHorizon;
  }
  getPCSInfo() {
    return n2(this.m_pPCSInfoNoDomain), this.m_pPCSInfoNoDomain;
  }
  getCentralMeridian() {
    return this.m_centralMeridian;
  }
  updateGCSHorizon() {
    if (this.m_peCoordSys.getType() !== bc.PE_TYPE_PROJCS) return;
    let t3 = true;
    const s4 = this.m_peCoordSys, n6 = s4.getGeogcs(), r = s4.horizonGcsGenerate();
    if (!r) return;
    n2(r.length > 0);
    const i2 = r[0].getNump(), o = r[0].getKind();
    let h2, m3;
    t3 = r[0].getInclusive() > 0;
    const l2 = this.getOneDegreeGCSUnit(), g2 = 90 * l2, u = 360 * l2, c = 370 * l2, _ = 180 * l2 * bc.PE_HORIZON_DELTA / Math.PI, d2 = n4.constructEmpty();
    let p3 = null;
    if (i2 > 1) {
      for (let e5 = 1; e5 < i2; e5++) if (r[e5].getKind() === bc.PE_HORIZON_LINE) {
        p3 || (p3 = new Os2());
        const t4 = r[e5].getCoord();
        p3.startPathCoords(t4[0][0], t4[0][1]), p3.lineToCoords(t4[1][0], t4[1][1]);
      }
    }
    if (o === bc.PE_HORIZON_RECT) {
      const e5 = r[0].getCoord();
      if (d2.setFromPoints([new mi(e5[0][0], e5[0][1]), new mi(e5[1][0], e5[1][1])], 2), Math.abs(d2.ymax - g2) < 1e-7 * _ && (d2.ymax = g2), Math.abs(d2.ymin + g2) < 1e-7 * _ && (d2.ymin = -g2), d2.width() > c) {
        const e6 = -400 * l2, t4 = e6 + 5 * u;
        d2.setCoords({ xmin: e6, ymin: d2.ymin, xmax: t4, ymax: d2.ymax });
      }
      const s5 = new re({ env2D: d2 });
      this.m_GCSHorizon || (this.m_GCSHorizon = s5, this.m_bGCSHorisonIsInclusive = t3);
    } else {
      let s5 = this.getPCSInfo().isGcsHorizonMultiOverlap();
      const o2 = Ru2(n6, null, null, 1), c2 = [], _2 = new x2();
      for (let t4 = 0; t4 < i2; t4++) {
        if (r[t4].getKind() !== bc.PE_HORIZON_POLY) continue;
        h2 = r[t4].getSize();
        const s6 = r[t4].getCoord(), n7 = n4.constructEmpty();
        n7.setFromPoints(oi(s6), h2), c2.push(new x2(n7.xmin, n7.xmax)), n7.width(), _2.merge(c2.at(-1));
      }
      let d3 = false;
      const f3 = new x2();
      _2.width() > u && c2.length > 1 ? (f3.vmin = this.getCentralMeridian() - u, f3.vmax = f3.vmin + 2 * u, d3 = true, s5 = true) : (f3.vmin = _2.vmin, f3.vmax = f3.vmin + u);
      const x4 = (e5) => {
        let t4 = 0;
        for (; c2[e5].vmin + t4 < f3.vmin; ) t4 += u;
        for (; c2[e5].vmax + t4 - u > f3.vmin; ) t4 -= u;
        return t4;
      };
      let y2 = new ur();
      if (s5) {
        const e5 = new Ag(), t4 = new al().executeMany(e5, o2, null);
        for (let s6 = 0; s6 < i2; s6++) {
          if (r[s6].getKind() !== bc.PE_HORIZON_POLY) continue;
          h2 = r[s6].getSize();
          const n7 = r[s6].getCoord();
          m3 = r[s6].getInclusive() > 0;
          const i3 = new ur();
          if (i3.addPathPoint2D(oi(n7), h2 - 1, true), d3) {
            const t5 = x4(s6), n8 = c2[s6].clone();
            n8.move(t5);
            let r2 = t5;
            const o3 = new x3();
            do {
              o3.setShiftCoords(r2, 0);
              const t6 = i3.clone();
              t6.applyTransformation(o3), e5.tick(t6), e5.tock(), r2 += u, n8.move(u);
            } while (n8.vmin < f3.vmax);
          } else e5.tick(i3), t4.tock();
        }
        y2 = t4.next();
      } else {
        y2 = new ur();
        for (let e5 = 0; e5 < i2; e5++) {
          if (r[e5].getKind() !== bc.PE_HORIZON_POLY) continue;
          h2 = r[e5].getSize();
          const s6 = r[e5].getCoord();
          if (m3 = r[e5].getInclusive() > 0, n2(m3 === t3), d3) {
            const t4 = new ur();
            t4.addPathPoint2D(oi(s6), h2 - 1, true);
            const n7 = x4(e5), r2 = c2[e5].clone();
            r2.move(n7);
            let i3 = n7;
            const o3 = new x3();
            do {
              if (0 !== i3) {
                o3.setShiftCoords(i3, 0);
                const e6 = new ur({ copy: t4 });
                e6.applyTransformation(o3), y2.addPath(e6, 0, true);
              } else y2.addPath(t4, 0, true);
              i3 += u, r2.move(u);
            } while (r2.vmin < f3.vmax);
          } else y2.addPathPoint2D(oi(s6), h2 - 1, true);
        }
      }
      d3 && (y2 = new I3().execute(y2, new n4(f3.vmin, -g2 - l2, f3.vmax, g2 + l2), o2, null)), t3 ? new wh2().accelerateGeometry(y2, o2, 1) : new Km().accelerateGeometry(y2, o2, 1), new ul().accelerateGeometry(y2, o2, 1), null === this.m_GCSHorizon && (this.m_GCSHorizon = y2, this.m_bGCSHorisonIsInclusive = t3, this.m_GCSSplitLines = p3);
    }
  }
  updateAreaOfUse() {
    return null;
  }
  updatePCSHorizon() {
    if (this.m_peCoordSys.getType() !== bc.PE_TYPE_PROJCS) return;
    const t3 = this.m_peCoordSys.horizonPcsGenerate();
    if (!t3) return;
    let s4;
    this.getPCSInfo();
    const n6 = t3[0].getKind();
    t3[0].getInclusive();
    const r = n4.constructEmpty(), i2 = t3[0].getNump();
    let o = false;
    if (n6 === bc.PE_HORIZON_RECT) {
      const e5 = t3[0].getCoord();
      r.setFromPoints(oi(e5), 2), s4 = new re({ env2D: r });
    } else {
      let e5 = -1;
      for (let s5 = 0; s5 < i2; s5++) t3[s5].getKind() === bc.PE_HORIZON_POLY && (e5 = s5);
      n2(e5 >= 0);
      const n7 = t3[e5].getSize() - 1, r2 = t3[e5].getCoord(), h2 = new ur();
      s4 = h2, h2.addPathPoint2D(oi(r2), n7, true), o = true;
    }
    if (this.getPCSInfo().isDensificationNeeded()) {
      n2(n6 !== bc.PE_HORIZON_RECT);
      const e5 = 1e5 * this.getOneMeterPCSUnit();
      s4 = new m2().execute(s4, e5, 0, 0, null);
    }
    if (o) {
      {
        const e5 = new re();
        s4.queryEnvelope(e5), s4.calculateArea2D(), s4.calculateLength2D(), s4.getExteriorRingCount();
      }
      new wh2().accelerateGeometry(s4, null, 1);
    }
    null === this.m_PCSHorizon && (this.m_PCSHorizon = s4);
  }
  updatePannableExtent() {
    const t3 = this.m_peCoordSys.getType();
    if (t3 === bc.PE_TYPE_PROJCS) {
      const t4 = this.m_peCoordSys, s4 = this.getPCSInfo().getCentralMeridian(), n6 = t4.getGeogcs();
      n6 || b("");
      const r = [s4 + 1 / n6.getUnit().getUnitFactor() * Math.PI, 0];
      wc.geogToProj(t4, 1, r);
      const o = r[0], a2 = t4.getParameters()[bc.PE_PARM_X0].getValue(), h2 = this.getPCSHorizon(), m3 = n4.constructEmpty();
      h2.queryEnvelope(m3);
      const l2 = Math.abs(o - a2), g2 = l2 + a2, u = -1 * l2 + a2, c = m3.ymax, _ = m3.ymin;
      this.m_pannableExtent.setCoords({ xmin: u, ymin: _, xmax: g2, ymax: c });
    } else if (t3 === bc.PE_TYPE_GEOGCS) {
      const e5 = 1 / this.m_peCoordSys.getUnit().getUnitFactor() * Math.PI;
      this.m_pannableExtent.setCoords({ xmin: -e5, ymin: -e5 / 2, xmax: e5, ymax: e5 / 2 });
    } else b("");
  }
  updatePannableExtentGCS() {
    const t3 = this.m_peCoordSys.getType();
    if (t3 === bc.PE_TYPE_PROJCS) {
      const t4 = this.m_peCoordSys, s4 = this.m_centralMeridian, n6 = t4.getGeogcs();
      n6 || b("");
      const r = 1 / n6.getUnit().getUnitFactor() * Math.PI, o = this.getGCSHorizon(), a2 = n4.constructEmpty();
      o.queryEnvelope(a2), this.m_pannableExtentGCS.setCoords({ xmin: s4 - r, ymin: a2.ymin, xmax: s4 + r, ymax: a2.ymax });
    } else if (t3 === bc.PE_TYPE_GEOGCS) {
      const e5 = 1 / this.m_peCoordSys.getUnit().getUnitFactor() * Math.PI;
      this.m_pannableExtentGCS.setCoords({ xmin: -e5, ymin: -e5 / 2, xmax: e5, ymax: e5 / 2 });
    } else b("");
  }
  updateDomain() {
    if (1 === this.m_csType) {
      const t3 = 400 * this.getOneDegreeGCSUnit();
      this.m_domain = n4.construct(-t3, -t3, t3, t3);
    } else {
      n2(2 === this.m_csType);
      const t3 = Nc.generate(this.m_peCoordSys, Nc.PE_PCSINFO_OPTION_DOMAIN);
      t3 || b("generate pcs info failed");
      const s4 = new n4(t3.getDomainMinx(), t3.getDomainMiny(), t3.getDomainMaxx(), t3.getDomainMaxy());
      this.m_domain.isEmpty() && this.m_domain.setCoords({ env2D: s4 });
    }
  }
  updatePoles() {
    if (this.m_peCoordSys.getType() === bc.PE_TYPE_PROJCS) {
      const e5 = 90 * this.getOneDegreeGCSUnit(), t3 = [[0, e5], [0, -e5]];
      wc.geogToProj(this.m_peCoordSys, 2, t3);
      const s4 = this.getPCSInfo().getNorthPoleLocation() !== Nc.PE_POLE_OUTSIDE_BOUNDARY, n6 = this.getPCSInfo().getSouthPoleLocation() !== Nc.PE_POLE_OUTSIDE_BOUNDARY;
      this.m_polesUpdated || (s4 && this.m_northPole.setCoords(t3[0][0], t3[0][1]), n6 && this.m_southPole.setCoords(t3[1][0], t3[1][1]), this.m_polesUpdated = 1);
    } else this.m_polesUpdated = 1;
  }
  updateGeogToProjFactors() {
    if (this.m_peCoordSys.getType() === bc.PE_TYPE_PROJCS) {
      const e5 = this.getOneDegreeGCSUnit(), t3 = this.m_pPCSInfoNoDomain.getCentralMeridian(), s4 = [0, 0, 0, 0];
      s4[0] = t3, s4[1] = 0, s4[2] = t3 + e5, s4[3] = 0;
      const n6 = wc.geogToProj(this.m_peCoordSys, 2, s4);
      n2(2 === n6);
      const r = (s4[2] - s4[0]) / e5, i2 = s4[0];
      0 === this.m_geogToProjFactorsUpdated && (this.m_geogToProjFactor = r, this.m_geogToProjOffset = i2, this.m_geogToProjFactorsUpdated = 1);
    } else this.m_geogToProjFactorsUpdated = 1;
  }
  getOneMeterPCSUnit() {
    return this.m_oneMeterPCS;
  }
  getOneDegreeGCSUnit() {
    return this.m_oneDegreeGCS;
  }
  getGcsUnitFactor() {
    return this.m_gcsUnitFactor;
  }
  getUnitsPerMillimeter() {
    return this.m_oneMillimeter;
  }
  getGCSSplitLines() {
    return this.m_bIsPannable ? null : (this.m_GCSHorizon || this.updateGCSHorizon(), this.m_GCSSplitLines);
  }
  getGCSHorizon() {
    return this.m_bIsPannable ? this.getGCSHorizonPannable() : (null !== this.m_GCSHorizon || this.updateGCSHorizon(), this.m_GCSHorizon);
  }
  getGCSHorisonIsInclusive() {
    return this.m_bIsPannable || this.getGCSHorizon(), this.m_bGCSHorisonIsInclusive;
  }
  getPCSHorizon() {
    return this.m_bIsPannable ? this.getPCSHorizonPannable() : (null !== this.m_PCSHorizon || this.updatePCSHorizon(), this.m_PCSHorizon);
  }
  getPole(e5) {
    return this.m_bIsPannable || 0 !== this.m_polesUpdated || this.updatePoles(), e5 ? this.m_southPole : this.m_northPole;
  }
  getGeogToProjFactors() {
    return 0 === this.m_geogToProjFactorsUpdated && this.updateGeogToProjFactors(), $t(this.m_geogToProjFactor, this.m_geogToProjOffset);
  }
  getDomainXY() {
    if (this.m_bIsPannable) return this.m_domain.clone();
    let e5 = false;
    return e5 = this.m_domain.isEmpty(), e5 && this.updateDomain(), this.m_domain.clone();
  }
  getPrimeMeridian() {
    return this.m_primeMeridian;
  }
  getLatestID() {
    return this.m_WKID;
  }
  getOldID() {
    let e5 = this.m_oldWKID;
    if (e5 < 0) {
      if (e5 = 0, this.m_WKID > 0) {
        const t3 = [0], s4 = [0];
        qc(this.m_peCoordSys.getType(), this.m_WKID, t3, s4) || b("query_code_change"), e5 = t3[0];
      }
      this.m_oldWKID = e5;
    }
    return e5;
  }
  isCustomWkid() {
    return false;
  }
  isPannable() {
    return this.m_bIsPannable;
  }
  getPannableExtent() {
    return this.m_pannableExtent.clone();
  }
  getPannableExtentGCS() {
    return this.m_pannableExtentGCS.clone();
  }
  getAreaOfUse() {
    return null !== this.m_areaOfUse ? this.m_areaOfUse : this.updateAreaOfUse();
  }
  getVcsCode() {
    return 0;
  }
  saveMemory() {
  }
  getCSType() {
    return this.m_csType;
  }
  getUnit() {
    return this.m_unit;
  }
  setCached() {
    this.m_bCached = true;
  }
  getCached() {
    return this.m_bCached;
  }
  static equal(e5, t3) {
    return false;
  }
  static equal_for_projection(e5, t3) {
    return false;
  }
};
var Bg = class {
  constructor(e5, t3 = true) {
    this.m_oneMeter = 0, this.m_WKID = -1, this.m_oldWKID = -1, this.m_canonicalWkt = "not yet implemented", this.m_model = 0, this.m_unit = new bu2(), this.m_cached = false;
  }
  setCached(e5 = true) {
    this.m_cached = e5;
  }
  getCached() {
    return this.m_cached;
  }
  getOneMeterUnit() {
    return 0;
  }
  getLatestID() {
    return this.m_WKID;
  }
  getOldID() {
    let e5 = this.m_oldWKID;
    return e5 < 0 && (e5 = 0, this.m_WKID > 0 && (e5 = this.m_WKID), this.m_oldWKID = e5), e5;
  }
  getModel() {
    return 0;
  }
  isCustomWkid() {
    return false;
  }
  getVerticalUnit() {
    return this.m_unit;
  }
  static equal(e5, t3) {
    return false;
  }
  static equal_for_projection(e5, t3) {
    return false;
  }
};
function Og(t3, s4, n6) {
  return Yg(t3, s4, n4.constructEmpty(), n6);
}
function Yg(e5, t3, s4, n6) {
  return Xg(true, e5, t3, s4, n6);
}
function Rg(e5, t3, s4, n6) {
  return Lg(true, e5, t3, s4, n6);
}
function Xg(e5, t3, s4, n6, r) {
  Uu2() || G("cannot create projection transformation");
  return t3.hasVCS() && s4.hasVCS() ? jg() : Zg(t3, s4, n6, r);
}
function Lg(e5, t3, s4, n6, r, i2) {
  return Uu2() || G("cannot create projection transformation"), new eu2(e5 ? 2 : 1, t3, s4, n6, r, i2);
}
function zg(e5, s4, n6, r, i2, o = false) {
  s4 && n6 || P(""), Uu2() || G("cannot obtain geotransformation list");
  if (1 === e5 && s4.hasVCS() && n6.hasVCS()) return z("hv xform not impl"), [];
  {
    const e6 = Qc(s4, n6, r, i2, o), t3 = [];
    for (const s5 of e6) t3.push(s5);
    return t3;
  }
}
function Wg() {
  return { centralMeridianOfOutputGCS: Number.NaN, densificationStep: Number.NaN, clipWithInputHorizon: true, clipWithOutputHorizon: true, legacyHorizonClipping: false, normalizeResultGeometry: false, equals(e5) {
    return ls(this.centralMeridianOfOutputGCS, e5.centralMeridianOfOutputGCS) && ls(this.densificationStep, e5.densificationStep) && this.clipWithInputHorizon === e5.clipWithInputHorizon && this.clipWithOutputHorizon === e5.clipWithOutputHorizon && this.legacyHorizonClipping === e5.legacyHorizonClipping && this.normalizeResultGeometry === e5.normalizeResultGeometry;
  } };
}
function jg(e5, t3, s4, n6) {
  return n2(0), {};
}
function Zg(s4, n6, r, i2) {
  s4 && n6 || P("!inputSR || !outputSR");
  const o = s4.getLatestID(), a2 = n6.getLatestID();
  if (3857 === o && 4326 === a2) {
    if (s4.m_bDefaultDescriptor && n6.m_bDefaultDescriptor) return pu2();
  } else if (4326 === o && 3857 === a2 && s4.m_bDefaultDescriptor && n6.m_bDefaultDescriptor) return fu2();
  const h2 = n4.constructEmpty();
  h2.setCoords({ env2D: r });
  const m3 = s4.getCoordinateSystemType(), l2 = n6.getCoordinateSystemType();
  if (0 === m3 || 0 === l2) return Kg(s4, n6);
  if (i2) {
    const e5 = i2.find(0, s4.getGCS(), n6.getGCS());
    if (e5) return Kg(s4, n6, e5);
  }
  const g2 = s4.getGCS().getLatestID(), u = n6.getGCS().getLatestID();
  if (g2 > 0 && g2 === u) return Kg(s4, n6);
  const c = new mu2(s4, n6, r);
  {
    const e5 = gu2(c);
    if (e5) return e5;
  }
  const _ = zg(0, s4, n6, h2, 1, true);
  return uu2(c, Kg(s4, n6, _.length ? _[0] : void 0));
}
function Kg(e5, t3, s4, n6, r) {
  return new eu2(1, e5, t3, s4, n6, r);
}
function Qg() {
  return { flagsMask: 0, setFlag(e5, t3) {
    t3 ? this.flagsMask |= e5 : this.flagsMask &= ~e5;
  }, hasFlag(e5) {
    return 0 !== (this.flagsMask & e5);
  } };
}
function Jg() {
  return { m_extendedParams: Wg(), m_extendedParamsInternal: Qg() };
}
function $g() {
  return Jg();
}
var eu2 = class e2 {
  constructor(e5, s4, n6, r, i2, o) {
    let h2, m3;
    this.m_datumTran = null, this.m_bIdentity = true, this.m_bIdentityGeogToGeog = true, this.m_bVertical = false, this.m_bNormalize = false, s4 && n6 || P("!inputSR || !outputSR"), r && 0 === r.getType() && (r.m_bReadOnly = true), this.m_bNormalize = false, 1 !== e5 && (h2 = s4.getVCS(), m3 = n6.getVCS(), this.m_bVertical = null != h2 && null != m3), this.m_inputSR = s4, this.m_outputSR = n6, this.m_bIdentity = false, this.m_bIdentityGeogToGeog = false, n2(!this.m_params), i2 && (this.m_params = Jg(), this.m_params.m_extendedParams = i2), o && (this.m_params || (this.m_params = Jg()), this.m_params.m_extendedParamsInternal = o);
    let l2 = false;
    const g2 = null != r, u = s4.getCoordinateSystemType(), c = n6.getCoordinateSystemType();
    if (n6.isPannable() && 0 !== u && i2) {
      const e6 = i2.centralMeridianOfOutputGCS;
      if (!Number.isNaN(e6) && n6.isPannable()) {
        const t3 = n6.getPannableExtent(), s5 = t3.getCenterX();
        if (s5 !== e6) {
          const n7 = Math.ceil(t3.width());
          e6 + n7 !== s5 + n7 && (l2 = true);
        }
      }
    }
    const _ = i2 && i2.normalizeResultGeometry;
    if (s4.equals(n6)) return this.m_bIdentity = !l2, this.m_bIdentityGeogToGeog = true, void this.updateProjector();
    const d2 = !g2 && s4.equalForProjection(n6, this.m_bVertical);
    this.m_bIdentity = d2 && !l2, this.m_bIdentity ? this.m_bIdentityGeogToGeog = true : 0 !== u && 0 !== c && (_ && this.m_outputSR.isPannable() && (this.m_bNormalize = _), this.m_datumTran = r || null, this.m_bIdentityGeogToGeog = (!this.m_datumTran || 0 === this.m_datumTran.count()) && this.m_inputSR.getGCS().equalForProjection(this.m_outputSR.getGCS(), this.m_bVertical)), this.updateProjector();
  }
  getInputSR() {
    return this.m_inputSR;
  }
  getOutputSR() {
    return this.m_outputSR;
  }
  getDatumTransformation() {
    return this.m_datumTran;
  }
  getInverse() {
    const t3 = new e2(1, this.m_outputSR, this.m_inputSR, this.m_datumTran?.createInverse());
    return t3.m_bIdentity = this.m_bIdentity, t3.m_bVertical = this.m_bVertical, t3.m_bIdentityGeogToGeog = this.m_bIdentityGeogToGeog, t3.updateProjector(), t3;
  }
  isIdentity() {
    return this.m_bIdentity;
  }
  getExtendedParams() {
    return this.m_params ? this.m_params.m_extendedParams : $g().m_extendedParams;
  }
  equals(e5) {
    return n2(0), false;
  }
  isVertical() {
    return this.m_bVertical;
  }
  isMatchingTransformation(e5, t3) {
    return n2(0), false;
  }
  getGeographicTransformations() {
    return this.m_datumTran;
  }
  getExtendedParamsImpl() {
    return this.m_params ? this.m_params.m_extendedParams : $g().m_extendedParams;
  }
  getExtendedParamsInternal() {
    return this.m_params ? this.m_params.m_extendedParamsInternal : $g().m_extendedParamsInternal;
  }
  isIdentityGeogToGeog() {
    return this.m_bIdentityGeogToGeog;
  }
  normalizeOutput() {
    return this.m_bNormalize;
  }
  updateProjector() {
    this.m_projector = new Ah2(this);
  }
};
var tu = /* @__PURE__ */ new Map();
var su2 = /* @__PURE__ */ new Map();
var nu2 = /* @__PURE__ */ new Map();
function ru2(e5) {
  let t3 = e5.getCode();
  if (t3 > 0) {
    const e6 = Iu2(t3);
    return e6 || Cu2(Ic.coordsys(t3));
  }
  const s4 = e5.getName();
  if (su2.has(s4)) {
    const t4 = su2.get(s4);
    if (t4 && t4.deref()) {
      const s5 = t4.deref();
      if (s5.m_peCoordSys.isEqual(e5)) return s5;
    }
  }
  return t3 = Ic.getCode(e5), Cu2(t3 > 0 ? Ic.coordsys(t3) : e5);
}
function iu2(e5) {
  e5 <= 0 && R(e5);
  {
    const t4 = Iu2(e5);
    if (t4) return t4;
  }
  const t3 = Hc(Ic.coordsys(e5));
  t3.get() || R(e5);
  const s4 = Cu2(t3.release());
  return s4.getLatestID() !== e5 && tu.set(e5, new WeakRef(s4)), s4;
}
function ou2(e5) {
  const t3 = new Bg({}, true);
  return t3.m_WKID = e5, t3;
}
function au2(e5) {
  const t3 = Hc(Ic.fromString(bc.PE_TYPE_COORDSYS, e5));
  return t3.get() || U(e5), ru2(t3.release());
}
function hu2(e5) {
  su2.delete(e5.m_peCoordSys.getName()), nu2.delete(_l(e5.m_peCoordSys, 0, false));
}
var mu2 = class {
  constructor(e5, t3, s4) {
    this.m_hashCode = -1, e5 && (this.m_inputSR = e5, this.m_outputSR = t3, this.m_env = s4.clone(), this.m_hashCode = this.m_inputSR.getHashCode(), this.m_hashCode = As(this.m_hashCode, this.m_outputSR.getHashCode()), this.m_env.isEmpty() || (this.m_hashCode = As(this.m_hashCode, Bs(this.m_env.xmin)), this.m_hashCode = As(this.m_hashCode, Bs(this.m_env.xmax)), this.m_hashCode = As(this.m_hashCode, Bs(this.m_env.ymin)), this.m_hashCode = As(this.m_hashCode, Bs(this.m_env.ymax))));
  }
  getHashCode() {
    return this.m_hashCode;
  }
  equals(e5) {
    return !(this.m_inputSR && !e5.m_inputSR || !this.m_inputSR && e5.m_inputSR) && (this.m_env.equals(e5.m_env) && this.m_inputSR.equals(e5.m_inputSR) && this.m_outputSR.equals(e5.m_outputSR));
  }
  clear() {
    this.m_inputSR = void 0, this.m_outputSR = void 0, this.m_hashCode = -1, this.m_env = void 0;
  }
};
var lu2 = /* @__PURE__ */ new Map();
function gu2(e5) {
  if (lu2.has(e5.getHashCode())) return lu2.get(e5.getHashCode());
}
function uu2(e5, t3) {
  return lu2.set(e5.getHashCode(), t3), t3;
}
var cu2;
var _u2;
var du2;
function pu2() {
  return cu2 || (cu2 = Rg(hc(), lc())), cu2;
}
function fu2() {
  return _u2 || (_u2 = pu2().getInverse()), _u2;
}
function xu2() {
  return du2 || (du2 = Ic.unit(9001)), du2;
}
function yu2(e5) {
  return null !== Hc(Ic.coordsys(e5)).get();
}
var Pu2 = /* @__PURE__ */ new Map();
function Eu2(e5) {
  if (Pu2.has(e5)) return Pu2.get(e5);
  {
    const t3 = yu2(e5);
    return Pu2.set(e5, t3), t3;
  }
}
function Su2(e5) {
  return false;
}
function Cu2(e5) {
  const t3 = Hc(e5), s4 = e5.getCode();
  if (s4 > 0) {
    const e6 = Iu2(s4);
    if (e6) return e6;
  }
  const n6 = e5.getName();
  let r = su2.get(n6);
  if (r) {
    const t4 = r.deref();
    if (t4 && t4.m_peCoordSys.isEqual(e5)) return t4;
  }
  const i2 = new qg(t3.release());
  if (s4 > 0) return i2.setCached(), tu.set(s4, new WeakRef(i2)), su2.set(n6, new WeakRef(i2)), i2;
  const o = _l(e5, 0, false);
  if (r = nu2.get(o), r) {
    const e6 = r.deref();
    if (e6) return e6;
  }
  return i2.setCached(), nu2.set(o, new WeakRef(i2)), i2;
}
function Iu2(e5) {
  const t3 = tu.get(e5);
  if (t3) return t3.deref();
}
var bu2 = class extends ns2 {
  constructor(e5) {
    return void 0 === e5 ? (super(), this.m_wkid = 9001, void (this.m_peUnit = null)) : "number" == typeof e5 ? (super(), this.m_factor = e5, void (this.m_wkid = 0)) : (super(e5), void (e5 || (this.m_factor = 1, this.m_wkid = 9001, this.m_peUnit = xu2())));
  }
  getUnitType() {
    return 0;
  }
  convertFromMeters(e5) {
    return e5 / this.getUnitToBaseFactor();
  }
  convertToMeters(e5) {
    return e5 * this.getUnitToBaseFactor();
  }
};
var wu2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
function vu2(e5, t3, s4) {
  const n6 = Yt(t3, "R");
  let r = 0, i2 = 0;
  for (let o = 0; o < t3; o++) {
    let s5 = e5[r] >> i2 & 31;
    if (i2 += 5, i2 > 31) {
      const t4 = 37 - i2;
      s5 &= (1 << t4) - 1, i2 -= 32, r++, s5 |= (e5[r] & (1 << i2) - 1) << t4;
    }
    const a2 = wu2[s5];
    n6[t3 - 1 - o] = a2;
  }
  return s4 > t3 ? n6.push(..."0".repeat(s4 - t3)) : s4 < t3 && (n6.length = s4), n6.join("");
}
function Nu2(e5, t3, s4, n6, r) {
  n2(n6 >> 5 < r.length);
  let i2 = t3, o = s4;
  for (let a2 = n6; a2 >= 0; a2 -= 2) {
    const t4 = 31 & a2, s5 = 0.5 * (o + i2);
    e5 >= s5 ? (r[a2 >> 5] |= 1 << t4, i2 = s5) : o = s5;
  }
}
var Tu2 = /* @__PURE__ */ new Set();
var Gu2 = 2147483645n;
var Du2 = 9007199254740990n;
var Vu2 = "operation is not supported for unknown coordinate systems";
var Fu2;
function Hu2() {
  return { majorSemiAxis: 0, e2: 0, minorSemiAxis: 0, flattening: 0, isSphere() {
    return 0 === this.e2;
  } };
}
function ku2(e5, t3, s4) {
  e5.majorSemiAxis = t3, e5.minorSemiAxis = t3 * (1 - s4), e5.e2 = s4 * (2 - s4), e5.flattening = s4;
}
function Au2(e5) {
  if (Ic) return;
  Uc(e5);
  const t3 = Tu2;
  Tu2 = null, t3.forEach((e6) => {
    const t4 = e6.deref();
    t4 && t4.attachToPe();
  });
}
function Mu2(e5) {
  Mc(e5);
}
function Uu2() {
  return !!Ic;
}
function qu2() {
  return !!kc;
}
function Bu2() {
  return !!Ic || !!kc;
}
function Ou2(e5, t3, s4) {
  return n2(Bu2()), dc(e5, void 0 === t3 ? 0 : t3, null, false);
}
function Yu2(e5, t3) {
  n2(Bu2());
  const s4 = new oc();
  let n6;
  return Uu2() ? (n6 = au2(e5), s4.setHorzProj_(n6), s4.m_vertcs = null, s4.m_userWKID = n6.getLatestID()) : (n6 = Ac(e5), s4.m_unit = n6.isPCS ? new bu2(n6.metersOrRadiansPerUnit) : new os2(n6.metersOrRadiansPerUnit)), uc(s4.m_precisionDescriptor, n6, null, 1), s4.m_bDefaultDescriptor = true, s4.m_userWKT = e5, s4.calculateHashCode(), s4.initDbgName(), s4;
}
function Ru2(e5, t3, s4, n6, r = true) {
  let i2 = null;
  return t3 && (i2 = Fm(t3, r)), Xu2(e5, i2, s4, n6, r);
}
function Xu2(e5, s4, n6, r, i2) {
  e5 || P("!PE_coord_sys");
  const o = new oc();
  let a2;
  return a2 = i2 ? ru2(e5) : new qg(e5, false), uc(o.m_precisionDescriptor, a2, s4, r), o.m_bDefaultDescriptor = true, o.setHorzProj_(a2), o.m_vertcs = s4, o.m_userWKID = a2.getLatestID(), o.calculateHashCode(), o.initDbgName(), o;
}
function Lu2(e5, s4, n6 = false) {
  3 === e5.getCoordinateSystemType() && P("image spatial reference cannot be altered");
  const r = new oc(), i2 = e5;
  return r.m_peCoordSysVal = i2.m_peCoordSysVal, r.m_vertcs = i2.m_vertcs, r.m_unit = i2.m_unit, r.m_precisionDescriptor.assign(s4), r.m_localZToXYFactor = i2.m_localZToXYFactor, (Number.isNaN(r.m_precisionDescriptor.m_falseX) || Number.isNaN(r.m_precisionDescriptor.m_falseY)) && (r.m_precisionDescriptor.m_falseX = i2.m_precisionDescriptor.m_falseX, r.m_precisionDescriptor.m_falseY = i2.m_precisionDescriptor.m_falseY), r.m_precisionDescriptor.snapPrecision(), r.m_precisionDescriptor.fixTolerance(), r.m_userWKID = i2.m_userWKID, r.m_precisionDescriptor.equals(i2.m_precisionDescriptor) ? r.m_bDefaultDescriptor = i2.m_bDefaultDescriptor : r.m_bDefaultDescriptor = false, n6 && (r.m_bDefaultDescriptor = true), r.calculateHashCode(), r.initDbgName(), r;
}
function zu2(e5, t3, s4) {
  return {};
}
function Wu2(e5, s4, n6) {
  void 0 === s4 && (s4 = 1), (s4 <= 0 || !Number.isFinite(s4)) && P(""), e5 || 1 === s4 || P("null Unit has to have z_to_xy_factor equal to 1");
  const r = new oc();
  r.m_unit = e5;
  const i2 = e5 || new bu2(9001);
  return _c(r.m_precisionDescriptor, i2, null, 1), r.m_bDefaultDescriptor = true, Number.isNaN(r.m_precisionDescriptor.m_falseX) && P("NAN false X/Y are not allowed here"), r.m_localZToXYFactor = s4, r.calculateHashCode(), r.initDbgName(), r;
}
function ju2(e5, t3) {
  return e5.snapGeometry(t3);
}
function Zu2(e5) {
  const t3 = e5.getCoordinateSystemType();
  return 1 === t3 ? e5 : (3 === t3 && n2(0), e5.getGCS());
}
function Ku2(e5) {
  return n2(Bu2()), qu2() ? Bc(e5) : Eu2(e5);
}
function Qu2(e5) {
  if (Uu2()) {
    return null !== Hc(Ic.fromString(bc.PE_TYPE_COORDSYS, e5)).get();
  }
  try {
    return Ac(e5), true;
  } catch (t3) {
  }
  return false;
}
var Ju2;
function $u2() {
  return Ju2 || (Ju2 = (() => {
    const e5 = Math.trunc(Math.random() * ds()), t3 = Date.now();
    return `|abba_000|${e5.toString(16)}|${t3.toString(16)}|`;
  })()), Ju2;
}
!function(e5) {
  e5[e5.utmDefault = 0] = "utmDefault", e5[e5.utmNorthSouth = 1] = "utmNorthSouth";
}(Fu2 || (Fu2 = {}));
var ec = 0;
function tc(e5 = "") {
  let t3 = `${$u2()}${ec++}`;
  return "" !== e5 && (t3 += `|${e5}`), t3;
}
function sc(e5) {
  return e5.startsWith($u2());
}
var nc;
var rc;
var ic;
var oc = class e3 {
  destroy() {
    hu2(this.m_peCoordSysVal), 1 === this.getCoordinateSystemType() || 2 === this.getCoordinateSystemType() ? this.getPECoordSys().destroy() : b("SpatialReference.destroy");
  }
  constructor() {
    this.m_vertcs = null, this.m_peCoordSysVal = null, this.m_userWKID = 0, this.m_userWKT = null, this.m_geogSpatialReference = null, this.m_srToGcs = null, this.m_gcsToSr = null, this.m_defaultPrecisionSR = null, this.m_localZToXYFactor = -1, this.m_precisionDescriptor = new ac(), this.m_hashCode = 0, this.m_bDefaultDescriptor = false, gc(this.m_precisionDescriptor), Tu2 && Tu2.add(new WeakRef(this));
  }
  attachToPe() {
    (this.m_userWKID > 0 ? Ou2(this.m_userWKID) : Yu2(this.m_userWKT)).copyTo(this, false);
  }
  copyTo(e5, t3 = true) {
    (t3 || e5.m_bDefaultDescriptor) && (e5.m_bDefaultDescriptor = this.m_bDefaultDescriptor, e5.m_precisionDescriptor.assign(this.m_precisionDescriptor)), e5.m_defaultPrecisionSR = null, e5.m_gcsToSr = this.m_gcsToSr, e5.m_geogSpatialReference = this.m_geogSpatialReference, e5.m_hashCode = this.m_hashCode, e5.m_localZToXYFactor = this.m_localZToXYFactor, e5.m_peCoordSysVal = this.m_peCoordSysVal, e5.m_srToGcs = this.m_srToGcs, e5.m_userWKID = this.m_userWKID, e5.m_userWKT = this.m_userWKT, e5.m_vertcs = this.m_vertcs, e5.m_unit = this.m_unit;
  }
  getHashCode() {
    return this.m_hashCode;
  }
  getHashCodeHorizontal() {
    let e5 = 0;
    return e5 = this.m_peCoordSysVal ? this.m_peCoordSysVal.getHashCode() : this.m_unit ? this.m_unit.getHashCode() : 305419891, e5;
  }
  updateTransform(e5) {
    if (1 === this.getCoordinateSystemType()) return Rg(this, this, null);
    let t3 = e5 ? this.m_srToGcs : this.m_gcsToSr;
    if (t3) return t3;
    const s4 = this.getGCS(), n6 = this;
    t3 = e5 ? Rg(n6, s4, null) : Rg(s4, n6, null);
    const r = t3, i2 = e5 ? this.m_srToGcs : this.m_gcsToSr;
    return i2 || (e5 ? this.m_srToGcs = r : this.m_gcsToSr = r, t3);
  }
  getHashCodeVertical() {
    return this.m_vertcs ? this.m_vertcs.getHashCode() : 0;
  }
  calculateHashCode() {
    let e5 = this.getHashCodeHorizontal();
    const t3 = this.getHashCodeVertical(), s4 = this.m_precisionDescriptor.getHashCode();
    e5 = As(e5, t3), this.m_hashCode = As(e5, s4);
  }
  initDbgName() {
  }
  setHorzProj_(e5) {
    this.m_peCoordSysVal = e5, this.m_unit = this.m_peCoordSysVal.getUnit();
  }
  getTolerance(e5 = 0) {
    return this.m_precisionDescriptor.getTolerance(e5);
  }
  getResolution(e5 = 0) {
    return this.m_precisionDescriptor.getResolution(e5);
  }
  getPECoordSys() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.m_peCoordSys : null;
  }
  getPCSInfo() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPCSInfo();
  }
  getCentralMeridian() {
    if (this.throwIfNotGCSOrPCS(), 1 === this.getCoordinateSystemType()) return 0;
    return this.getPCSInfo().getCentralMeridian();
  }
  getCoordinateSystemType() {
    const e5 = this.getPECoordSys();
    if (e5) {
      switch (e5.getType()) {
        case bc.PE_TYPE_GEOGCS:
          return 1;
        case bc.PE_TYPE_PROJCS:
          return 2;
        default:
          return 0;
      }
    } else {
      if ((this.m_userWKID > 0 || this.m_userWKT) && this.m_unit instanceof bu2) return 2;
      if (this.m_unit instanceof os2) return 1;
    }
    return 0;
  }
  getID() {
    return this.m_userWKID;
  }
  getLatestID() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getLatestID() : this.m_userWKID;
  }
  getOldID() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getOldID() : this.m_userWKID;
  }
  getVerticalID() {
    return z("vcs not implemented"), 0;
  }
  getLatestVerticalID() {
    return this.m_vertcs ? this.m_vertcs.getLatestID() : 0;
  }
  getOldVerticalID() {
    return z("vcs not implemented"), 0;
  }
  getPEVerticalCoordSys() {
    return null;
  }
  getPole(e5) {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPole(e5);
  }
  getText() {
    const e5 = this.getPECoordSys();
    return e5 ? pl(e5) : this.m_userWKT ?? "";
  }
  getTextExtended(e5) {
    const t3 = this.getPECoordSys();
    return t3 ? this.getPEVerticalCoordSys() ? dl(null, t3, this.getPEVerticalCoordSys()) : pl(t3, e5) : this.m_userWKT ?? "";
  }
  getText2(e5 = -1) {
    const t3 = this.getPECoordSys();
    return t3 ? fl(t3, e5) : this.m_userWKT ?? "";
  }
  getUnit() {
    return this.m_unit;
  }
  getUnitsPerMillimeter() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getUnitsPerMillimeter() : this.m_unit instanceof bu2 ? 1e-3 / this.m_unit.getUnitToBaseFactor() : this.m_unit instanceof os2 ? 1e-3 / (Ac(this.m_userWKT ?? this.m_userWKID).semiMajor * this.m_unit.getUnitToBaseFactor()) : (C("sr object not in valid state"), 0);
  }
  getAuthorityName() {
    return this.getPECoordSys() ? xl() : "";
  }
  getVerticalUnit() {
    return z("vcs not implemented"), {};
  }
  getVCS() {
    return this.m_vertcs;
  }
  hasVCS() {
    return false;
  }
  getGCSHorisonIsInclusive() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSHorisonIsInclusive();
  }
  getGCSHorizon() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSHorizon();
  }
  getGCS() {
    const e5 = this.getCoordinateSystemType();
    if (0 === e5) C(Vu2);
    else {
      if (1 === e5) return this;
      3 === e5 && C("image cs not supported");
    }
    if (this.m_geogSpatialReference) return this.m_geogSpatialReference;
    let t3;
    if (this === hc() || this === mc()) t3 = lc();
    else {
      n2(this.m_peCoordSysVal);
      const e6 = this.m_peCoordSysVal.m_peCoordSys.getGeogcs();
      e6 || b(""), t3 = Ru2(e6, this.m_vertcs, null, this.m_precisionDescriptor.getPrecision(), this.m_peCoordSysVal.getCached());
    }
    return this.m_geogSpatialReference ? t3 = this.m_geogSpatialReference : this.m_geogSpatialReference = t3, t3;
  }
  getGCSSplitLines() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSSplitLines();
  }
  toGCS(e5, s4) {
    if (0 === e5.length) return 0;
    e5.length > s4.length && P("coordsSrc.size() > coordsDst.size()");
    const n6 = this.getCoordinateSystemType();
    if (0 === n6 && C(Vu2), 1 === n6) return Gt(s4, e5, e5.length), e5.length;
    n2(this.m_peCoordSysVal);
    const r = this.getSRToGCSTransform();
    return new qh().transform(r, e5, e5.length, s4);
  }
  toGeohash(e5, t3 = 8) {
    const s4 = e5.clone();
    s4.scale(9102 === this.getGCS().getUnit().getID() ? 1 : this.getGCS().getUnit().getUnitToBaseFactor() / Math.PI * 180), s4.x < -180 ? (s4.x = ct(s4.x, 360), s4.x < -180 && (s4.x += 360)) : s4.x > 180 && (s4.x = ct(s4.x, 360), s4.x > 180 && (s4.x -= 360)), s4.y > 90 && (s4.y = 90), s4.y < -90 && (s4.y = -90);
    const n6 = 5 * t3, r = new Uint32Array(4);
    Nu2(s4.x, -180, 180, n6 - 1, r), Nu2(s4.y, -90, 90, n6 - 2, r);
    return vu2(r, t3, t3);
  }
  isPannable() {
    const e5 = this.getCoordinateSystemType();
    return 0 !== e5 && 3 !== e5 && (n2(this.m_peCoordSysVal), this.m_peCoordSysVal.isPannable());
  }
  getPannableExtent() {
    return this.isPannable() || P("!is_pannable"), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPannableExtent();
  }
  getPannableExtentInGCS() {
    return this.isPannable() || P("!is_pannable"), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPannableExtentGCS();
  }
  throwIfNotGCSOrPCS() {
    const e5 = this.getCoordinateSystemType();
    1 !== e5 && 2 !== e5 && P("Not a GCS or PCS");
  }
  getDomainXY() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getDomainXY();
  }
  getFullWorldExtent() {
    return this.throwIfNotGCSOrPCS(), this.isPannable() ? this.getPannableExtent() : this.getDomainXY();
  }
  queryPrecisionDescriptor(e5) {
    if (e5.assign(this.m_precisionDescriptor), Number.isNaN(e5.m_falseX)) if (Uu2() || G("cannot query precision descriptor"), n2(null !== this.m_peCoordSysVal), 2 !== this.m_precisionDescriptor.m_precision) {
      const t3 = this.m_peCoordSysVal.getDomainXY();
      e5.m_falseX = t3.xmin, e5.m_falseY = t3.ymin;
    } else e5.m_falseX = -Number.MAX_VALUE, e5.m_falseY = -Number.MAX_VALUE;
  }
  queryPrecisionDescriptorWithoutFalseXY(e5) {
    e5.assign(this.m_precisionDescriptor), e5.m_falseX = Number.NaN, e5.m_falseY = Number.NaN;
  }
  queryDefaultPrecisionDescriptorWithoutFalseXY(e5) {
    if (this.m_bDefaultDescriptor) e5.assign(this.m_precisionDescriptor);
    else {
      const t3 = this.getCoordinateSystemType();
      0 === t3 ? _c(e5, this.m_unit, this.m_vertcs, this.m_precisionDescriptor.getPrecision()) : 3 === t3 ? z("image cs") : uc(e5, this.m_peCoordSysVal, this.m_vertcs, this.m_precisionDescriptor.getPrecision());
    }
    e5.m_falseX = Number.NaN, e5.m_falseY = Number.NaN;
  }
  horizontalEqual(e5) {
    return Mg(this.m_peCoordSysVal, e5.m_peCoordSysVal);
  }
  verticalEqual(e5) {
    return null !== this.m_vertcs == (null !== e5.m_vertcs) && (!this.m_vertcs || this.m_vertcs.equals(e5.m_vertcs));
  }
  equals(e5) {
    const t3 = e5;
    if (this === t3) return true;
    if (!this.horizontalEqual(t3) || !this.verticalEqual(t3)) return false;
    if (!t3.m_peCoordSysVal) {
      if (n2(!this.m_peCoordSysVal), null !== this.m_unit != (null !== t3.m_unit)) return false;
      if (this.m_unit && !this.m_unit.equals(t3.m_unit)) return false;
      if (this.m_localZToXYFactor !== t3.m_localZToXYFactor) return false;
    }
    if (!this.m_bDefaultDescriptor || !t3.m_bDefaultDescriptor) {
      if (this.m_peCoordSysVal) {
        if (!this.m_precisionDescriptor.equalsWithoutFalseXY(t3.m_precisionDescriptor)) return false;
        n2(t3.m_peCoordSysVal);
        let e6 = this.m_precisionDescriptor.m_falseX, s4 = this.m_precisionDescriptor.m_falseY;
        if (Number.isNaN(e6)) {
          const t4 = this.m_peCoordSysVal.getDomainXY();
          e6 = t4.xmin, s4 = t4.ymin;
        }
        let n6 = t3.m_precisionDescriptor.m_falseX, r = t3.m_precisionDescriptor.m_falseY;
        if (Number.isNaN(n6)) {
          const e7 = t3.m_peCoordSysVal.getDomainXY();
          n6 = e7.xmin, r = e7.ymin;
        }
        return e6 === n6 && s4 === r;
      }
      return this.m_precisionDescriptor.equals(t3.m_precisionDescriptor);
    }
    return true;
  }
  equalForProjection(e5, t3) {
    if (this === e5) return true;
    const s4 = this.getCoordinateSystemType(), n6 = e5.getCoordinateSystemType();
    if (0 === s4 || 0 === n6) return 0 === s4 && 0 === n6 ? (!t3 || this.getZToXYFactor() === e5.getZToXYFactor()) && (!this.getUnit() || !e5.getUnit() || this.getUnit().equals(e5.getUnit())) : 3 !== s4 && 3 !== n6 && (null === this.getUnit() || null === e5.getUnit() || (!t3 || this.getZToXYFactor() === e5.getZToXYFactor()) && this.getUnit().equals(e5.getUnit()));
    if (s4 !== n6) return false;
    if (3 === s4) return this.equals(e5);
    if (Ug(this.m_peCoordSysVal, e5.m_peCoordSysVal)) {
      if (!t3) return true;
      if (null !== this.m_vertcs == (null !== e5.m_vertcs)) return !this.m_vertcs || this.m_vertcs.equalForProjection(e5.m_vertcs);
    }
    return false;
  }
  equalHorizontal(e5) {
    return this.horizontalEqual(e5);
  }
  equalVertical(e5) {
    return n2(0), false;
  }
  equalVerticalVCS(e5) {
    return n2(0), false;
  }
  convergenceAngle(e5) {
    return n2(0), 0;
  }
  getPeCoordsysCopy() {
    if (this.m_peCoordSysVal) {
      const e5 = this.m_peCoordSysVal.m_peCoordSys;
      return e5 || b("cannot clone coord sys"), e5;
    }
    return null;
  }
  getPeVertcsCopy() {
    return n2(0), 0;
  }
  throwIfLocal() {
    0 === this.getCoordinateSystemType() && P(Vu2);
  }
  getPrimeMeridian() {
    return this.throwIfLocal(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPrimeMeridian();
  }
  getSRToGCSTransform() {
    return this.updateTransform(true);
  }
  getGCSToSRTransform() {
    return this.updateTransform(false);
  }
  getOneMeter() {
    return 1e3 * this.getUnitsPerMillimeter();
  }
  getOneMeterPCSUnit() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getOneMeterPCSUnit();
  }
  getDefaultPrecisionSR() {
    if (this.m_bDefaultDescriptor) return this;
    if (null === this.m_defaultPrecisionSR) {
      const e5 = new ac();
      this.queryDefaultPrecisionDescriptorWithoutFalseXY(e5), this.m_defaultPrecisionSR = Lu2(this, e5, true);
    }
    return this.m_defaultPrecisionSR;
  }
  getPCSHorizon() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPCSHorizon();
  }
  getHorzUnitFactor() {
    return this.m_unit ? this.m_unit.getUnitToBaseFactor() : 1;
  }
  querySpheroidData(e5) {
    this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal);
    const t3 = this.getGCS().getPECoordSys().getDatum().getSpheroid(), s4 = t3.getFlattening();
    ku2(e5, t3.getAxis(), s4);
  }
  getAreaOfUse() {
    0 === this.getCoordinateSystemType() && C(""), n2(this.m_peCoordSysVal);
    const e5 = this.m_peCoordSysVal.getAreaOfUse();
    return null === e5 ? new ss2() : new ss2({ geom: e5.clone(), sr: Ou2(4326) });
  }
  getZToXYFactor() {
    return 1;
  }
  isCustomWkid() {
    return false;
  }
  getOneDegreeGCSUnit() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getOneDegreeGCSUnit();
  }
  getGcsUnitFactor() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getGcsUnitFactor();
  }
  snapGeometry(e5) {
    if (e5.isEmpty()) return false;
    if (2 === this.m_precisionDescriptor.getPrecision()) return false;
    const t3 = e5.getGeometryType();
    if (y(t3)) return this.snapMultiVertex_(e5);
    if (t3 === a.enumPoint) return this.snapPoint_(e5);
    if (t3 === a.enumEnvelope) return this.snapEnvelope_(e5);
    if (f(t3)) return this.snapSegment_(e5);
    if (t3 === a.enumGeometryCollection) {
      const t4 = e5;
      let s4 = false;
      for (let e6 = 0, n6 = t4.getGeometryCount(); e6 < n6; ++e6) s4 = this.snapGeometry(t4.getGeometry(e6)) || s4;
      return s4;
    }
    b("what else?");
  }
  snapMultiVertex_(e5) {
    if (n2(!e5.isEmpty()), n2(2 !== this.m_precisionDescriptor.getPrecision()), h(e5.getGeometryType())) {
      const t4 = e5;
      if (t4.hasNonLinearSegments()) return this.snapGeometryWithCurves_(t4);
    }
    const t3 = e5.getImpl(), s4 = t3.getDescription();
    let n6 = false;
    for (let r = 0, i2 = s4.getAttributeCount(); r < i2; r++) {
      const e6 = s4.getSemantics(r), i3 = t3.getAttributeStreamRef(e6);
      n6 = this.snapAttributes(e6, i3, 0, t3.getPointCount()) || n6;
    }
    return n6 && t3.notifyModifiedFlags(2001), n6;
  }
  snapPoint_(e5) {
    return false;
  }
  snapEnvelope_(e5) {
    return false;
  }
  snapSegment_(e5) {
    n2(!e5.isEmpty()), n2(2 !== this.m_precisionDescriptor.getPrecision());
    const t3 = new ac();
    this.queryPrecisionDescriptor(t3);
    const s4 = e5.getStartXY(), n6 = new mi();
    n6.x = pc(s4.x, t3.getFalseX(), t3.getGridUnitsXY()), n6.y = pc(s4.y, t3.getFalseY(), t3.getGridUnitsXY());
    let r = !n6.equals(s4);
    const i2 = e5.getEndXY(), o = new mi();
    o.x = pc(i2.x, t3.getFalseX(), t3.getGridUnitsXY()), o.y = pc(i2.y, t3.getFalseY(), t3.getGridUnitsXY()), r ||= !o.equals(i2), r && e5.changeEndPoints2D(n6, o);
    const h2 = (t4, s5, n7) => {
      let r2 = false;
      {
        const i3 = e5.getStartAttributeAsDbl(t4, 0), o2 = pc(i3, s5, n7), a2 = !ls(o2, i3);
        r2 ||= a2, a2 && e5.setStartAttribute(t4, 0, o2);
      }
      {
        const i3 = e5.getEndAttributeAsDbl(t4, 0), o2 = pc(i3, s5, n7), a2 = !ls(o2, i3);
        r2 ||= a2, a2 && e5.setEndAttribute(t4, 0, o2);
      }
      return r2;
    };
    let m3 = r ? 1 : 0;
    return e5.hasAttribute(1) && (m3 |= h2(1, t3.getFalseZ(), t3.getGridUnitsZ()) ? 1 : 0), e5.hasAttribute(2) && (m3 |= h2(2, t3.getFalseM(), t3.getGridUnitsM()) ? 1 : 0), !!m3;
  }
  snapGeometryWithCurves_(e5) {
    n2(!e5.isEmpty()), n2(2 !== this.m_precisionDescriptor.getPrecision());
    const t3 = e5.createInstance(), s4 = new fm();
    let n6 = 0;
    for (let r = 0, i2 = e5.getPathCount(); r < i2; ++r) {
      const i3 = e5.getSegmentCountPath(r);
      if (0 === i3) {
        if (t3.addPath(e5, r, true), 1 === t3.getPathSize(r)) {
          const e6 = new ee();
          t3.getPointByVal(t3.getPointCount() - 1, e6), n6 |= this.snapGeometry(e6) ? 1 : 0, t3.setPointByVal(t3.getPointCount() - 1, e6);
        }
        continue;
      }
      const o = e5.isClosedPath(r);
      for (let a2 = 0, h2 = o ? i3 - 1 : i3; a2 < h2; ++a2) e5.getSegmentFromPath(r, a2, s4, false), n6 |= this.snapGeometry(s4.get()) ? 1 : 0, t3.addSegment(s4.get(), 0 === a2);
      o && (e5.getSegmentFromPath(r, i3 - 1, s4, false), n6 |= this.snapGeometry(s4.get()) ? 1 : 0, 1 === i3 ? t3.addPathFromClosedSegment(s4.get(), false) : t3.closeLastPathWithSegment(s4.get()));
    }
    return n6 && t3.copyTo(e5), !!n6;
  }
  snapAttributes(t3, s4, n6, r) {
    let i2 = false;
    const o = new ac();
    if (this.queryPrecisionDescriptor(o), 0 === t3) {
      const t4 = s4;
      for (let s5 = n6; s5 < r; s5++) {
        const n7 = t4.read(2 * s5), r2 = e3.s_SnapValue(n7, o.getFalseX(), o.getGridUnitsXY()), a2 = t4.read(2 * s5 + 1), h2 = e3.s_SnapValue(a2, o.getFalseY(), o.getGridUnitsXY());
        i2 = i2 || r2 !== n7 || h2 !== a2, i2 && (t4.write(2 * s5, r2), t4.write(2 * s5 + 1, h2));
      }
    } else if (1 === t3) {
      const t4 = s4;
      for (let s5 = n6; s5 < r; s5++) {
        const n7 = t4.read(s5), r2 = e3.s_SnapValue(n7, o.getFalseZ(), o.getGridUnitsZ());
        i2 = i2 || !ls(r2, n7), i2 && t4.write(s5, r2);
      }
    } else if (2 === t3) {
      const t4 = s4;
      for (let s5 = n6; s5 < r; s5++) {
        const n7 = t4.read(s5), r2 = e3.s_SnapValue(n7, o.getFalseM(), o.getGridUnitsM());
        i2 = i2 || !ls(r2, n7), i2 && t4.write(s5, r2);
      }
    }
    return i2;
  }
  static s_SnapValue(e5, t3, s4) {
    return S((e5 - t3) * s4) / s4 + t3;
  }
};
var ac = class _ac {
  constructor() {
    const e5 = Du2, t3 = 1e-4, s4 = 1e-3, n6 = t3 * Number(e5) * 0.5;
    this.m_precision = 1, this.m_falseX = -n6, this.m_falseY = -n6, this.m_unitsXY = Number(e5) / (2 * n6), this.m_falseM = -1e5, this.m_unitsM = 1 / t3, this.m_falseZ = -1e5, this.m_unitsZ = 1 / t3, this.m_toleranceXY = s4, this.m_toleranceM = s4, this.m_toleranceZ = s4;
  }
  getHashCode() {
    let e5 = 7777, t3 = 7777;
    return t3 = As(t3, this.m_falseM), t3 = As(t3, this.m_unitsM), e5 = As(e5, this.m_unitsXY), t3 = As(t3, this.m_toleranceXY), e5 = As(e5, this.m_falseZ), t3 = As(t3, this.m_toleranceZ), e5 = As(e5, this.m_unitsZ), t3 = As(t3, this.m_toleranceM), e5 = As(e5, this.m_precision), As(e5, t3);
  }
  clone() {
    const e5 = new _ac();
    return e5.m_falseX = this.m_falseX, e5.m_falseY = this.m_falseY, e5.m_unitsXY = this.m_unitsXY, e5.m_falseZ = this.m_falseZ, e5.m_unitsZ = this.m_unitsZ, e5.m_falseM = this.m_falseM, e5.m_unitsM = this.m_unitsM, e5.m_toleranceXY = this.m_toleranceXY, e5.m_toleranceZ = this.m_toleranceZ, e5.m_toleranceM = this.m_toleranceM, e5.m_precision = this.m_precision, e5;
  }
  assign(e5) {
    return this.m_falseX = e5.m_falseX, this.m_falseY = e5.m_falseY, this.m_unitsXY = e5.m_unitsXY, this.m_falseZ = e5.m_falseZ, this.m_unitsZ = e5.m_unitsZ, this.m_falseM = e5.m_falseM, this.m_unitsM = e5.m_unitsM, this.m_toleranceXY = e5.m_toleranceXY, this.m_toleranceZ = e5.m_toleranceZ, this.m_toleranceM = e5.m_toleranceM, this.m_precision = e5.m_precision, this;
  }
  initialize2D(e5, t3) {
  }
  getTolerance(e5) {
    switch (e5) {
      case 0:
        return this.m_toleranceXY;
      case 1:
        return this.m_toleranceZ;
      case 2:
        return this.m_toleranceM;
      default:
        return 0;
    }
  }
  getResolution(e5) {
    if (2 === this.m_precision) return 0;
    switch (e5) {
      case 0:
        return 1 / this.m_unitsXY;
      case 1:
        return 1 / this.m_unitsZ;
      case 2:
        return 1 / this.m_unitsM;
      default:
        return 0;
    }
  }
  getFalseX() {
    return this.m_falseX;
  }
  getFalseY() {
    return this.m_falseY;
  }
  getFalseZ() {
    return this.m_falseZ;
  }
  getFalseM() {
    return this.m_falseM;
  }
  getGridUnitsXY() {
    return this.m_unitsXY;
  }
  getGridUnitsZ() {
    return this.m_unitsZ;
  }
  getGridUnitsM() {
    return this.m_unitsM;
  }
  getPrecision() {
    return this.m_precision;
  }
  static getLimit32() {
    return 2147483645;
  }
  static getLimit64() {
    return 9007199254740990n;
  }
  static getLimitFloat() {
    return 0;
  }
  getXYGridRange() {
    const t3 = new n4();
    switch (this.m_precision) {
      case 0:
        {
          const e5 = _ac.getLimit32() / this.getGridUnitsXY();
          t3.setCoords({ xmin: this.getFalseX(), ymin: this.getFalseY(), xmax: this.getFalseX() + e5, ymax: this.getFalseY() + e5 });
        }
        break;
      case 1:
        {
          const e5 = Number(_ac.getLimit64()) / this.getGridUnitsXY();
          t3.setCoords({ xmin: this.getFalseX(), ymin: this.getFalseY(), xmax: this.getFalseX() + e5, ymax: this.getFalseY() + e5 });
        }
        break;
      case 2:
        t3.setCoords({ xmin: -Number.MAX_VALUE, ymin: -Number.MAX_VALUE, xmax: Number.MAX_VALUE, ymax: Number.MAX_VALUE });
        break;
      default:
        t3.setEmpty(), b("");
    }
    return t3;
  }
  getZGridRange() {
    const e5 = new x2();
    switch (this.m_precision) {
      case 0:
        {
          const t3 = _ac.getLimit32() / this.getGridUnitsZ();
          e5.setCoords(this.getFalseZ(), this.getFalseZ() + t3);
        }
        break;
      case 1:
        {
          const t3 = Number(_ac.getLimit64()) / this.getGridUnitsZ();
          e5.setCoords(this.getFalseZ(), this.getFalseZ() + t3);
        }
        break;
      case 2:
        e5.setCoords(-Number.MAX_VALUE, Number.MAX_VALUE);
        break;
      default:
        e5.setEmpty(), b("");
    }
    return e5;
  }
  getMGridRange() {
    const e5 = new x2();
    switch (this.m_precision) {
      case 0:
        {
          const t3 = _ac.getLimit32() / this.getGridUnitsM();
          e5.setCoords(this.getFalseM(), this.getFalseM() + t3);
        }
        break;
      case 1:
        {
          const t3 = Number(_ac.getLimit64()) / this.getGridUnitsM();
          e5.setCoords(this.getFalseM(), this.getFalseM() + t3);
        }
        break;
      case 2:
        e5.setCoords(-Number.MAX_VALUE, Number.MAX_VALUE);
        break;
      default:
        e5.setEmpty(), b("");
    }
    return e5;
  }
  setTolerance(e5, s4) {
    switch (s4 < 0 && P("tol < 0"), Number.isFinite(s4) || P("tol is not finite"), e5) {
      case 0:
        this.m_toleranceXY = s4;
        break;
      case 1:
        this.m_toleranceZ = s4;
        break;
      case 2:
        this.m_toleranceM = s4;
        break;
      default:
        P("cannot set tolerance for this attribute");
    }
  }
  setGridParams(e5, s4, n6) {
    Number.isFinite(e5) && Number.isFinite(s4) && Number.isFinite(n6) || P("grid params are not finite"), n6 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseX = e5, this.m_falseY = s4, this.m_unitsXY = n6;
  }
  setZParams(e5, s4) {
    Number.isFinite(e5) && Number.isFinite(s4) || P("grid params are not finite"), s4 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseZ = e5, this.m_unitsZ = s4;
  }
  setMParams(e5, s4) {
    Number.isFinite(e5) && Number.isFinite(s4) || P("grid params are not finite"), s4 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseM = e5, this.m_unitsM = s4;
  }
  setPrecision(e5) {
  }
  equals(e5) {
    return this === e5 || ls(this.m_falseX, e5.m_falseX) && ls(this.m_falseY, e5.m_falseY) && this.equalsWithoutFalseXY(e5);
  }
  snapPrecision() {
    if (2 === this.m_precision) return;
    const e5 = (e6, t4, s4, n6) => {
      if (!Number.isFinite(t4) || !Number.isFinite(s4)) return s4;
      if (s4 < 1) return 1;
      if (!n6) return s4;
      const r = Number(e6) / s4;
      return Math.trunc((t4 + r - t4) * s4) > e6 && (s4 = e6 / (t4 + r - t4)), Math.max(1, s4);
    }, t3 = Number(0 === this.m_precision ? Gu2 : Du2);
    this.m_unitsXY = e5(t3, this.m_falseX, this.m_unitsXY, true), this.m_unitsXY = e5(t3, this.m_falseY, this.m_unitsXY, true), this.m_unitsZ = e5(t3, this.m_falseZ, this.m_unitsZ, false), this.m_unitsM = e5(t3, this.m_falseM, this.m_unitsM, false);
  }
  verifyPrecision() {
    if (2 === this.m_precision) return true;
    const e5 = (e6, t4, s4, n6) => {
      if (s4 < 1) return false;
      if (!Number.isFinite(t4) || !Number.isFinite(s4)) return false;
      if (!n6) return true;
      const r = Number(e6) / s4;
      return !(BigInt((t4 + r - t4) * s4) > e6);
    }, t3 = 0 === this.m_precision ? Gu2 : Du2;
    return !!e5(t3, this.m_falseX, this.m_unitsXY, true) && (!!e5(t3, this.m_falseY, this.m_unitsXY, true) && (!!e5(t3, this.m_falseZ, this.m_unitsZ, false) && !!e5(t3, this.m_falseM, this.m_unitsM, false)));
  }
  fixTolerance() {
    2 !== this.m_precision && (this.m_toleranceXY = Math.max(2 / this.m_unitsXY, this.m_toleranceXY), this.m_toleranceZ = Math.max(2 / this.m_unitsZ, this.m_toleranceZ), this.m_toleranceM = Math.max(2 / this.m_unitsM, this.m_toleranceM), (Number.isNaN(this.m_falseX) || Number.isNaN(this.m_falseY)) && (this.m_falseX = this.m_falseY = Number.NaN));
  }
  equalsWithoutFalseXY(e5) {
    return this === e5 || this.m_unitsXY === e5.m_unitsXY && this.m_falseZ === e5.m_falseZ && this.m_unitsZ === e5.m_unitsZ && this.m_falseM === e5.m_falseM && this.m_unitsM === e5.m_unitsM && this.m_toleranceXY === e5.m_toleranceXY && this.m_toleranceZ === e5.m_toleranceZ && this.m_toleranceM === e5.m_toleranceM && this.m_precision === e5.m_precision;
  }
  setBestXyDomainFromEnvelope(e5, t3) {
  }
  setBestZDomainFromZRange(e5, t3, s4) {
  }
  setBestMDomainFromMRange(e5, t3, s4) {
  }
};
function hc() {
  return (!nc || Uu2() && null === nc.getPECoordSys()) && (nc = dc(3857, 0, null, true)), nc;
}
function mc() {
  return (!rc || Uu2() && null === rc.getPECoordSys()) && (rc = dc(102100, 0, null, true)), rc;
}
function lc() {
  return (!ic || Uu2() && null === ic.getPECoordSys()) && (ic = dc(4326, 0, null, true)), ic;
}
function gc(e5) {
  e5.m_falseX = 0, e5.m_falseY = 0, e5.m_unitsXY = 1, e5.m_falseZ = 0, e5.m_unitsZ = 1, e5.m_falseM = 0, e5.m_unitsM = 1, e5.m_toleranceXY = 100 * Qs(), e5.m_toleranceZ = 100 * Qs(), e5.m_toleranceM = 100 * Qs(), e5.m_precision = 2;
}
function uc(e5, s4, n6, r) {
  const i2 = s4 instanceof qg;
  gc(e5), e5.m_precision = r, e5.m_falseX = Number.NaN, e5.m_falseY = Number.NaN;
  const o = 1e-4, a2 = 1e-3, h2 = i2 ? s4.m_csType : s4.isPCS ? 2 : 1;
  if (1 === h2) {
    const t3 = (0 === r ? 1 / 18e5 : 1e-9) * (i2 ? s4.getOneDegreeGCSUnit() : Math.PI / s4.metersOrRadiansPerUnit / 180);
    e5.m_unitsXY = 1 / t3;
  } else if (2 === h2) {
    const t3 = (0 === r ? a2 : o) * (i2 ? s4.getOneMeterPCSUnit() : 1 / s4.metersOrRadiansPerUnit);
    e5.m_unitsXY = 1 / t3;
  } else P("unrecognized cs type");
  e5.m_falseM = -1e5, e5.m_unitsM = 1 / (0 === r ? a2 : o), e5.m_unitsM = Math.max(1, e5.m_unitsM), e5.m_unitsXY = Math.max(1, e5.m_unitsXY);
  let m3 = 0, l2 = 0;
  0 !== r && 1 !== r || (m3 = 2 / e5.m_unitsXY, l2 = 2 / e5.m_unitsM), e5.m_toleranceXY = Math.max(m3, i2 ? s4.getUnitsPerMillimeter() : 2 === h2 ? 1e-3 / s4.metersOrRadiansPerUnit : 1e-3 / (s4.semiMajor * s4.metersOrRadiansPerUnit)), e5.m_toleranceM = Math.max(a2, l2), cc(e5, n6);
}
function cc(e5, t3) {
  const s4 = 1e-4, n6 = 1e-3;
  if (e5.m_falseZ = -1e5, t3) {
    const r2 = (0 === e5.m_precision ? n6 : s4) * t3.getOneMeter();
    e5.m_unitsZ = 1 / r2;
  } else e5.m_unitsZ = 1 / (0 === e5.m_precision ? n6 : s4);
  e5.m_unitsZ = Math.max(1, e5.m_unitsZ);
  let r = 0;
  0 !== e5.m_precision && 1 !== e5.m_precision || (r = 2 / e5.m_unitsZ), e5.m_toleranceZ = Math.max(t3 ? t3.getOneMeter() * n6 : n6, r);
}
function _c(e5, t3, s4, n6) {
  gc(e5), e5.m_precision = n6;
  const r = 0 === n6 ? Gu2 : Du2, i2 = 1e-4, o = 1e-3;
  let a2 = 1, h2 = 1, m3 = 1e-3;
  t3 && (h2 = t3.getUnitToBaseFactor()), t3 && 1 === t3.getUnitType() ? (a2 = 400 * Math.PI / 180, m3 = 8983152841195215e-24 * Math.PI / 180 / h2) : (a2 = (0 === n6 ? o : i2) * Number(r) * 0.5, m3 = o / h2), a2 /= h2, e5.m_falseX = -a2, e5.m_falseY = -a2, e5.m_unitsXY = Number(r) / (2 * a2), e5.m_falseM = -1e5, e5.m_unitsM = 1 / (0 === n6 ? o : i2), e5.m_unitsM = Math.max(1, e5.m_unitsM), e5.snapPrecision();
  let l2 = 0, g2 = 0;
  0 !== e5.m_precision && 1 !== e5.m_precision || (g2 = 2 / e5.m_unitsM, l2 = 2 / e5.m_unitsXY), e5.m_toleranceXY = Math.max(l2, m3), e5.m_toleranceM = Math.max(o, g2), cc(e5, s4);
}
function dc(e5, t3, s4, n6) {
  if (!n6 && t3 <= 0) {
    if (3857 === e5) return hc();
    if (102100 === e5) return mc();
    if (4326 === e5) return lc();
  }
  const r = new oc();
  let i2, o = null;
  return Uu2() ? (i2 = iu2(e5), t3 > 0 ? o = null : t3 = 0, r.setHorzProj_(i2), r.m_vertcs = o) : (i2 = Ac(e5), r.m_unit = i2.isPCS ? new bu2(i2.metersOrRadiansPerUnit) : new os2(i2.metersOrRadiansPerUnit)), uc(r.m_precisionDescriptor, i2, o, 1), r.m_bDefaultDescriptor = true, r.m_userWKID = e5, r.calculateHashCode(), r.initDbgName(), r;
}
function pc(e5, t3, s4) {
  return S((e5 - t3) * s4) / s4 + t3;
}
var fc = null;
var xc = 3552713678800501e-30;
function yc(e5, t3, s4) {
  return e5 === t3 || Math.abs(e5 - t3) <= s4 * (1 + (Math.abs(e5) + Math.abs(t3)) / 2);
}
function Pc(e5, t3) {
  return yc(e5, t3, xc);
}
function Ec(e5, t3) {
  return 0 === e5 || Math.abs(e5) <= t3;
}
function Sc(e5) {
  return Ec(e5, xc);
}
var Cc;
var Ic;
var bc;
var wc;
var vc;
var Nc;
var Tc;
var Gc;
var Dc;
var Vc;
var Fc;
function Hc(e5) {
  return { _this: e5, get() {
    return this._this;
  }, reset(e6) {
    this._this = e6;
  }, release() {
    const e6 = this._this;
    return this._this = null, e6;
  } };
}
var kc = null;
function Ac(e5) {
  n2(kc);
  const t3 = kc(e5);
  return t3.semiMajor = t3.isPCS ? Number.NaN : Rc(e5), t3;
}
function Mc(e5) {
  kc = e5, n2(kc);
}
function Uc(e5) {
  const t3 = e5;
  Ic = t3.PeFactory, n2(Ic), Fc = t3.PeGCSExtent, n2(Fc), Dc = t3.PeLineType, n2(Dc), Vc = t3.PeMath, n2(Vc), Cc = t3.PeDouble, n2(Cc), bc = t3.PeDefs, n2(bc), wc = t3.PeCSTransformations, n2(wc), vc = t3.PeGTTransformations, n2(vc), Nc = t3.PePCSInfo, n2(Nc), Tc = t3.PeGTlistExtended, n2(Tc), Ic.initialize(), Gc = t3.PeGTlistExtendedEntry, n2(Gc), bc.PE_TYPE_ANGUNIT = 512, bc.PE_STR_AUTH_ALL = 2, Nc.PE_POLE_LINE_STRAIGHT = 2, Nc.PE_POLE_LINE_CURVED = 3, bc.PE_PARM_LAM0 = 2, bc.PE_PARM_PHI0 = 6, bc.PE_PRJ_AZIMUTHAL_EQUIDISTANT = 43032, bc.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA = 43033, bc.PE_PRJ_ALBERS = 43007, bc.PE_PRJ_CYLINDRICAL_EQAREA = 43034, bc.PE_TYPE_VERTCS = 8, bc.PE_LINETYPE_GEODESIC = 0, bc.PE_LINETYPE_LOXODROME = 1, bc.PE_LINETYPE_GREAT_ELLIPTIC = 2, bc.PE_LINETYPE_NORMAL_SECTION = 3, Tc.PE_GTLIST_OPTS_USABLE = 1, kc = null;
}
function qc(e5, t3, s4, n6) {
  return t3 <= 0 ? (s4[0] = 0, n6[0] = 0, false) : (s4[0] = t3, n6[0] = t3, true);
}
function Bc(e5) {
  n2(qu2());
  return !!kc(e5).isPCS || Oc(e5);
}
function Oc(e5) {
  return Ic && C("pe has been loaded. no-pe methods should not be used at this point."), fc || Xc(), fc.has(e5);
}
var Yc = /(?:ELLIPSOID|SPHEROID)\["(?:\w|[-()])+",(\d+\.\d+)/;
function Rc(e5) {
  if (Ic && C("pe has been loaded. no-pe methods should not be used at this point."), "string" == typeof e5) {
    const s4 = e5.match(Yc);
    s4 && 2 === s4.length || P("bad gcs wkt");
    const n6 = Number.parseFloat(s4[1]);
    return Number.isFinite(n6) || P("bad gcs wkt"), n6;
  }
  return fc || Xc(), fc.has(e5) || C("gcs wkid not found"), fc.get(e5);
}
function Xc() {
  fc = /* @__PURE__ */ new Map();
  for (const e5 in rs3) {
    const t3 = Number.parseFloat(e5), s4 = rs3[e5];
    if (Array.isArray(s4)) for (const e6 of s4) fc.set(e6, t3);
    else fc.set(s4, t3);
  }
  is2();
}
function Lc(e5, t3) {
  const s4 = Ic.geogtran(e5);
  s4 || R(e5);
  return new Kc(s4, t3);
}
function zc(e5, t3) {
  const s4 = Ic.fromString(bc.PE_TYPE_GEOGTRAN, e5);
  s4 || U(e5);
  return new Kc(s4, t3);
}
function Wc(e5, t3) {
  return new Kc(e5, t3);
}
var jc = Zs(0);
var Zc = Zs(1);
var Kc = class e4 {
  constructor(t3, s4) {
    if (t3 instanceof e4) return this.m_geogTranWrapper = t3.m_geogTranWrapper, this.m_bInverted = s4 ? !t3.m_bInverted : t3.m_bInverted, void (this.m_hashCode = As(this.m_geogTranWrapper.getHashCode(), this.m_bInverted ? Zc : jc));
    this.m_geogTranWrapper = new Um(t3), this.m_bInverted = s4, this.m_hashCode = As(this.m_geogTranWrapper.getHashCode(), this.m_bInverted ? Zc : jc);
  }
  getID() {
    return this.m_geogTranWrapper.getLatestId();
  }
  getLatestID() {
    return this.m_geogTranWrapper.getLatestId();
  }
  getText() {
    return this.m_geogTranWrapper.getText();
  }
  getTextExtended(e5) {
    if (!this.m_geogTranWrapper.getGeogtran()) return "";
    if (-1 === e5) return this.m_geogTranWrapper.getGeogtran().toString();
    {
      const t3 = 0 === e5 ? bc.PE_STR_AUTH_TOP : bc.PE_STR_AUTH_ALL;
      return this.m_geogTranWrapper.getGeogtran().toString(t3);
    }
  }
  getText2(e5 = -1) {
    let t3 = bc.PE_STR_FMT_WKT2;
    return -1 !== e5 && (t3 |= 0 === e5 ? bc.PE_STR_AUTH_TOP : bc.PE_STR_AUTH_ALL), this.m_geogTranWrapper.getGeogtran().toString(t3);
  }
  getName() {
    return this.m_geogTranWrapper && this.m_geogTranWrapper.getGeogtran() ? this.m_geogTranWrapper.getGeogtran().getName() : "";
  }
  getInputSpatialReference() {
    return this.m_bInverted ? this.m_geogTranWrapper.getOutputSr(false) : this.m_geogTranWrapper.getInputSr(false);
  }
  getOutputSpatialReference() {
    return this.m_bInverted ? this.m_geogTranWrapper.getInputSr(false) : this.m_geogTranWrapper.getOutputSr(false);
  }
  getInverse() {
    return new e4(this, true);
  }
  isInverted() {
    return this.m_bInverted;
  }
  getHashCode() {
    return this.m_hashCode;
  }
  GetPeGeogtran() {
    return this.m_geogTranWrapper.getGeogtran();
  }
  equals(e5) {
    const t3 = e5;
    return t3 === this || this.m_bInverted === t3.m_bInverted && (this.GetPeGeogtran() === t3.GetPeGeogtran() || this.getID() === t3.getID() && !(0 === this.getID() && !this.GetPeGeogtran().isEqual(t3.GetPeGeogtran())));
  }
  referencesMissingData() {
    return !!this.m_geogTranWrapper && !this.m_geogTranWrapper.isUsable();
  }
  getWrapper() {
    return this.m_geogTranWrapper;
  }
};
function Qc(e5, t3, s4, n6, r) {
  const i2 = e5.getGCS(), o = t3.getGCS(), h2 = i2.getPECoordSys(), m3 = o.getPECoordSys();
  let l2 = null;
  if (!s4.isEmpty()) {
    const t4 = s4.clone();
    if (!t4.isEmpty() && 2 === e5.getCoordinateSystemType()) {
      let s5 = new re({ env2D: t4 });
      const n7 = Rg(e5, i2, null);
      s5 = new qh().execute(s5, n7, null), s5.queryEnvelope(t4);
    }
    if (!t4.isEmpty()) {
      const e6 = h2.getPrimem().getLongitude(), s5 = h2.getUnit().getUnitFactor();
      l2 = new Fc(t4.xmin, t4.ymin, t4.xmax, t4.ymax, e6, s5);
    }
  }
  let g2 = n6;
  g2 >= ds() && (g2 = 0);
  const u = [];
  let c = Tc.PE_GTLIST_OPTS_COMMON;
  r || (c &= ~Tc.PE_GTLIST_OPTS_USABLE);
  for (let _ = 0; _ < 2; _++) {
    u.length = 0;
    const e6 = g2, t4 = Tc.getGTlist(h2, m3, 2, c, l2, e6);
    let s5 = false;
    if (t4 && t4.length > 0) for (let i3 = 0, o2 = t4.length; i3 < o2; i3++) {
      const e7 = Jc([t4[i3]]);
      if (n2(e7), r && e7.referencesMissingData()) s5 = true;
      else if (u.push(e7), n6 > 0 && u.length === n6) break;
    }
    if (!s5) break;
    0 === g2 || (g2 = 0);
  }
  return l2 && l2.destroy(), u;
}
function Jc(e5) {
  n2(null !== e5);
  const t3 = new e_(), s4 = e5[0].getSteps();
  if (s4) {
    const n6 = e5[0].getEntries();
    for (let e6 = 0; e6 < s4; e6++) {
      const s5 = 0 !== n6[e6].getDirection(), r = Wc(n6[e6].getGeogtran(), s5);
      t3.add(r);
    }
    return t3.create();
  }
  return null;
}
var $c = class {
  constructor(e5, t3, s4, n6) {
    this.m_bReadOnly = true, this.m_name = "", this.m_fastTrack = -1, this.m_bNameIsSet = false, this.m_transforms = e5, t3 && (this.m_name = t3, this.m_bNameIsSet = true), this.m_inputSr = s4, this.m_outputSr = n6;
  }
  getType() {
    return 0;
  }
  getName() {
    if (this.m_bNameIsSet) return this.m_name;
    if (0 === this.m_transforms.length) return "";
    let e5 = "";
    for (const t3 of this.m_transforms) e5.length > 0 && (e5 += " + "), t3.isInverted() && (e5 += "~"), e5 += t3.getName();
    return e5;
  }
  count() {
    return this.m_transforms.length;
  }
  createInverse() {
    return this.getInverse();
  }
  getHashCode() {
    let e5 = 1973;
    for (let t3 = 0; t3 < this.m_transforms.length; t3++) e5 = As(e5, this.m_transforms[t3].getHashCode());
    return e5;
  }
  equals(e5) {
    return n2(0), false;
  }
  referencesMissingData() {
    if (0 === this.m_transforms.length) return false;
    for (const e5 of this.m_transforms) if (e5.referencesMissingData()) return true;
    return false;
  }
  isMatchingTransformation(e5, t3) {
    return n2(0), false;
  }
  validateTransformation(e5, t3) {
    return n2(0), false;
  }
  nameIsSet() {
    return n2(0), false;
  }
  getInputSpatialReference() {
    return this.m_inputSr;
  }
  getOutputSpatialReference() {
    return this.m_outputSr;
  }
  getStep(e5) {
    return (e5 < 0 || e5 > this.count()) && A(""), this.m_transforms[e5];
  }
  getInverse() {
    const e5 = new e_();
    return e5.addSteps(this, true), e5.setInputSpatialReference(this.m_outputSr), e5.setOutputSpatialReference(this.m_inputSr), e5.create();
  }
  transform(e5, t3, s4) {
    if (0 === this.count()) return;
    let n6 = this.m_inputSr, r = this.m_outputSr;
    if (e5 && (r = Pt(n6, n6 = r)), 0 === this.m_transforms.length) return void qm(n6, null, r, null, t3, null, s4);
    let i2 = this.m_fastTrack;
    if (1 === i2) return void _e(e5, this.m_transforms, (n7) => {
      Xm(n7.getWrapper(), e5 !== n7.isInverted(), t3, null, s4);
    });
    const o = Mm();
    -1 === i2 && o.initFromGcsAndVcs(n6, null);
    const a2 = Mm();
    let h2 = e5 ? this.m_transforms.length - 1 : 0;
    const m3 = e5 ? -1 : 1;
    for (let g2 = 0, u = this.m_transforms.length; g2 < u; g2++, h2 += m3) {
      if (0 === g2) {
        const r3 = this.m_transforms[h2];
        Bm(n6.getPECoordSys(), null, r3.getWrapper(), e5 !== r3.isInverted(), t3, null, s4, a2), -1 === i2 && (o.equals(a2) || (i2 = 0)), o.assign(a2);
      } else {
        const n7 = this.m_transforms[h2 - m3], r3 = this.m_transforms[h2];
        Ym(o, n7.getWrapper(), e5 !== n7.isInverted(), r3.getWrapper(), e5 !== r3.isInverted(), t3, null, s4, a2), -1 === i2 && (o.equals(a2) || (i2 = 0)), o.assign(a2);
      }
      const r2 = this.m_transforms[h2];
      Rm(o, r2.getWrapper(), e5 !== r2.isInverted(), t3, null, s4, a2), o.assign(a2);
    }
    const l2 = this.m_transforms[h2 - m3];
    Om(o, l2.getWrapper(), e5 !== l2.isInverted(), r, null, t3, null, s4), -1 === i2 && (a2.initFromGcsAndVcs(r, null), o.equals(a2) || (i2 = 0)), this.m_fastTrack = 0 === i2 ? 0 : 1;
  }
};
var e_ = class {
  constructor() {
    this.m_transforms = [], this.m_inputGCS = null, this.m_outputGCS = null, this.m_name = "", this.m_bNameIsSet = false;
  }
  getInputSpatialReference() {
    return null !== this.m_inputGCS ? this.m_inputGCS : this.count() > 0 ? this.m_transforms[0].getInputSpatialReference() : null;
  }
  setInputSpatialReference(e5) {
    this.m_inputGCS = e5 ? e5.getGCS() : null;
  }
  getOutputSpatialReference() {
    return null !== this.m_outputGCS ? this.m_outputGCS : this.count() > 0 ? this.m_transforms.at(-1).getOutputSpatialReference() : null;
  }
  setOutputSpatialReference(e5) {
    this.m_outputGCS = e5 ? e5.getGCS() : null;
  }
  getName() {
    if (this.m_bNameIsSet) return this.m_name;
    if (0 === this.m_transforms.length) return "";
    let e5 = "";
    for (const t3 of this.m_transforms) e5.length > 0 && (e5 += " + "), t3.isInverted() && (e5 += "~"), e5 += t3.getName();
    return e5;
  }
  count() {
    return this.m_transforms.length;
  }
  getStep(e5) {
    return (e5 < 0 || e5 > this.count()) && A(""), this.m_transforms[e5];
  }
  setStep(e5, t3) {
    n2(0);
  }
  add(e5) {
    this.m_transforms.push(e5);
  }
  addSteps(e5, t3) {
    if (t3) for (let s4 = e5.count() - 1; s4 >= 0; --s4) this.add(e5.getStep(s4).getInverse());
    else for (let s4 = 0; s4 < e5.count(); ++s4) this.add(e5.getStep(s4));
  }
  clear() {
    this.m_transforms = [], this.m_name = "", this.m_bNameIsSet = false, this.m_inputGCS = null, this.m_outputGCS = null;
  }
  remove(e5) {
    n2(0);
  }
  create() {
    const e5 = this.getInputSpatialReference(), t3 = this.getOutputSpatialReference(), s4 = new $c(this.m_transforms, this.m_bNameIsSet ? this.m_name : null, e5, t3);
    return s4.m_bReadOnly = true, this.clear(), s4;
  }
};
var t_ = Object.freeze(Object.defineProperty({ __proto__: null, SpatialReference: oc, SpatialReferencePrecisionDescriptor: ac, create: Ou2, createFromWKT: Yu2, createImplFromPe: Ru2, createLocal: Wu2, createWithNewPrecision: Lu2, createWithNewVCS: zu2, getGCS: Zu2, getTempName: tc, hasNoPe: qu2, hasPe: Uu2, injectNoPe: Mu2, injectPe: Au2, isInitialized: Bu2, isTempName: sc, isValidWkid: Ku2, isValidWkt: Qu2, makeSpheroidData: Hu2, snapGeometry: ju2, webMercator: hc, webMercator102100: mc, wgs84: lc }, Symbol.toStringTag, { value: "Module" }));
var s_ = Object.freeze(Object.defineProperty({ __proto__: null, OperatorProject: qh }, Symbol.toStringTag, { value: "Module" }));
var n_ = Object.freeze(Object.defineProperty({ __proto__: null, CompositeGeographicTransformation: $c, CompositeGeographicTransformationEditor: e_, createImpl: Jc, queryGtListImpl: Qc }, Symbol.toStringTag, { value: "Module" }));
var r_ = Object.freeze(Object.defineProperty({ __proto__: null, GeographicTransformation: Kc, create: Lc, createFromPe: Wc, createFromWKT: zc }, Symbol.toStringTag, { value: "Module" }));
var i_ = Object.freeze(Object.defineProperty({ __proto__: null, ProjectionTransformation: eu2, create: Og, createEx: Rg, createFromAoi: Yg, createImplEx: Lg, makeExtendedParams: Wg, makeExtendedParamsInternal: Qg, queryTransformationList: zg }, Symbol.toStringTag, { value: "Module" }));

export {
  X,
  Q2 as Q,
  j3 as j,
  J2 as J,
  K2 as K,
  $2 as $,
  Et2 as Et,
  Dt2 as Dt,
  It2 as It,
  Ct2 as Ct,
  Tt,
  At,
  Bt2 as Bt,
  zt2 as zt,
  Ft2 as Ft,
  Vt2 as Vt,
  kt2 as kt,
  ee,
  re,
  pe,
  Ee,
  cs2 as cs,
  ks,
  Os2 as Os,
  Ks,
  Jn,
  ur,
  cr,
  Pr,
  yr,
  vr,
  Sr,
  wr,
  ia,
  zh,
  jh,
  ou,
  Tu,
  Lu,
  Ru,
  pm,
  fm,
  f2 as f,
  I3 as I,
  m2 as m,
  ss2 as ss,
  as2 as as,
  cs3 as cs2,
  ds3 as ds,
  Ps3 as Ps,
  Cs2 as Cs,
  Is2 as Is,
  vs3 as vs,
  ks2,
  Us3 as Us,
  qs3 as qs,
  Ys3 as Ys,
  tn2 as tn,
  sn2 as sn,
  Zn2 as Zn,
  er2 as er,
  sr2 as sr,
  ir2 as ir,
  kr2 as kr,
  Lo2 as Lo,
  Wo2 as Wo,
  Ko2 as Ko,
  aa2 as aa,
  ha2 as ha,
  la2 as la,
  _a2 as _a,
  da2 as da,
  pa2 as pa,
  fa2 as fa,
  ya2 as ya,
  Sa2 as Sa,
  Fa2 as Fa,
  ka2 as ka,
  Ma2 as Ma,
  Ra2 as Ra,
  Ka2 as Ka,
  nh2 as nh,
  ih2 as ih,
  hh2 as hh,
  Eh2 as Eh,
  wh2 as wh,
  Th2 as Th,
  qh,
  Oh,
  Yh2 as Yh,
  Rh2 as Rh,
  Xh2 as Xh,
  Lh2 as Lh,
  zh2,
  um2 as um,
  cm2 as cm,
  _m2 as _m,
  Hm,
  Lm,
  zm,
  Wm,
  jm,
  Km,
  al,
  ul,
  cl,
  Tl,
  kl,
  Al,
  ql,
  Xl,
  zl,
  Wl,
  jl,
  Zl,
  mg,
  fg,
  Ag,
  Rg,
  Lg,
  Wg,
  Qg,
  Hu2 as Hu,
  Mu2 as Mu,
  Uu2 as Uu,
  Ou2 as Ou,
  Yu2 as Yu,
  Lu2,
  Wu2 as Wu,
  ju2 as ju,
  Ku2 as Ku,
  Qu2 as Qu,
  tc,
  ac,
  Pc,
  Cc,
  Ic,
  bc,
  wc,
  Dc,
  Vc,
  t_,
  s_,
  n_,
  r_,
  i_
};
//# sourceMappingURL=chunk-XOCYWQ7P.js.map
