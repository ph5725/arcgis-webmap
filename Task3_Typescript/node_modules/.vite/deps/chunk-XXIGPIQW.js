import {
  i as i8
} from "./chunk-5FFOLNHT.js";
import {
  i as i7
} from "./chunk-CEMHA5WX.js";
import {
  S
} from "./chunk-YR4BEFGH.js";
import {
  u as u9
} from "./chunk-EEB2RHCK.js";
import {
  a as a4
} from "./chunk-FY4QOUNB.js";
import {
  i as i6,
  n as n4,
  r as r5
} from "./chunk-QYCJPZF2.js";
import {
  F,
  a as a6,
  a2 as a7,
  d2 as d4,
  e as e6,
  m as m6,
  o2 as o7,
  o3 as o8,
  t2 as t4,
  u as u8,
  x2,
  y,
  z as z2
} from "./chunk-G3V62EXP.js";
import {
  I
} from "./chunk-GEY3MNEN.js";
import {
  e as e5
} from "./chunk-3D5Q5QVJ.js";
import {
  t as t3
} from "./chunk-3JKD2XXM.js";
import {
  e as e4
} from "./chunk-I7SMTGBD.js";
import {
  E
} from "./chunk-WGTPS6U6.js";
import {
  n as n3,
  p as p2
} from "./chunk-WEJSS4SJ.js";
import {
  r as r4,
  s as s4
} from "./chunk-C6WRFAXG.js";
import {
  ot
} from "./chunk-DKS7UUDR.js";
import {
  i as i5
} from "./chunk-VXCZZCO4.js";
import {
  R as R2
} from "./chunk-I3A6CJVF.js";
import {
  e as e7
} from "./chunk-T2RAES2T.js";
import {
  a as a5
} from "./chunk-P3YYANTX.js";
import {
  fe,
  o as o6,
  te
} from "./chunk-WKCCXG3E.js";
import {
  o as o5
} from "./chunk-VM7TVSSO.js";
import {
  h2 as h3,
  r as r6
} from "./chunk-IGBV77N3.js";
import {
  c as c2
} from "./chunk-5Y3EUPZN.js";
import {
  E as E2,
  N,
  R as R4
} from "./chunk-3PPDORWL.js";
import {
  h as h2
} from "./chunk-YIXK32VF.js";
import {
  t as t2
} from "./chunk-CHTPXQAG.js";
import {
  e as e3
} from "./chunk-2NTKYBCL.js";
import {
  s as s3
} from "./chunk-NO2XQDLB.js";
import {
  s as s5
} from "./chunk-RP7FUW55.js";
import {
  t as t5
} from "./chunk-XJMFXMGK.js";
import {
  p
} from "./chunk-T4BWGCN6.js";
import {
  d as d3
} from "./chunk-AC7GOP3F.js";
import {
  n as n2
} from "./chunk-E76L26GR.js";
import {
  c
} from "./chunk-GG4VLKUY.js";
import {
  J,
  W
} from "./chunk-UTU6N7VJ.js";
import {
  g as g2
} from "./chunk-B6C7UPBZ.js";
import {
  u as u7
} from "./chunk-K5LVZUBF.js";
import {
  f as f3
} from "./chunk-C3JHRSMA.js";
import {
  i as i4,
  o as o4
} from "./chunk-TMC6HYGQ.js";
import {
  i as i3
} from "./chunk-7CUBIFKN.js";
import {
  m as m3
} from "./chunk-FEGY3M6U.js";
import {
  p as p3
} from "./chunk-ZXGBNDYM.js";
import {
  R
} from "./chunk-7ZMGKXLG.js";
import {
  d as d2
} from "./chunk-2IMSGFJN.js";
import {
  m as m5,
  u as u6
} from "./chunk-HNQNVI5C.js";
import {
  m as m4
} from "./chunk-G34OBNLT.js";
import {
  D as D2,
  L as L3,
  M,
  P,
  Q,
  R as R3,
  T,
  _,
  h,
  j,
  ke,
  w as w2,
  x
} from "./chunk-VCRP2PLV.js";
import {
  e as e2,
  l as l4,
  r as r3,
  u as u5
} from "./chunk-BDLVUYG2.js";
import {
  u as u4
} from "./chunk-MUKDJQWB.js";
import {
  D
} from "./chunk-YBJ5GVXQ.js";
import {
  V
} from "./chunk-X3R5OB6L.js";
import {
  u as u3
} from "./chunk-6GWORUT3.js";
import {
  o as o3
} from "./chunk-YIV2QKTZ.js";
import {
  a as a3,
  l as l3,
  w
} from "./chunk-A3VAC24F.js";
import {
  m as m2,
  r as r2
} from "./chunk-FPSA4NFH.js";
import {
  z
} from "./chunk-O5TPFXRT.js";
import {
  o
} from "./chunk-JUAPMINU.js";
import {
  f as f2
} from "./chunk-PK2ZR2SJ.js";
import {
  l as l2
} from "./chunk-E3KEUGUG.js";
import {
  b as b2,
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2
} from "./chunk-JUAD7TJ6.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import {
  o as o2
} from "./chunk-3NBBZ43U.js";
import {
  g2 as g
} from "./chunk-ZWFY3WY5.js";
import {
  L as L2,
  b,
  d,
  e,
  f2 as f,
  s as s2,
  t,
  u2 as u,
  u3 as u2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2,
  l,
  s
} from "./chunk-XWG6QGFK.js";
import {
  a,
  i
} from "./chunk-GWNLQRNM.js";
import {
  L,
  has,
  n
} from "./chunk-FXKORAMT.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var p4 = class extends d2 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e12 = false) {
    if (this.popupTemplate) return this.popupTemplate;
    const t11 = this.sourceLayer?.featureReduction;
    return t11 && "popupTemplate" in t11 && t11.popupEnabled ? t11.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
r([m({ type: Boolean })], p4.prototype, "isAggregate", void 0), p4 = r([a2("esri.AggregateGraphic")], p4);
var s6 = p4;

// node_modules/@arcgis/core/TrackGraphic.js
var s7 = class extends d2 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e12 = false) {
    if (this.popupTemplate) return this.popupTemplate;
    const r12 = this.sourceLayer?.trackInfo;
    return r12?.enabled && r12.popupEnabled ? r12.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
r([m({ type: Boolean })], s7.prototype, "isAggregate", void 0), s7 = r([a2("esri.TrackGraphic")], s7);
var p5 = s7;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var c3 = class extends b2 {
  constructor(e12) {
    super(e12), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new a5(e12), this._includedEffectView = new a5(e12);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e12) {
    this._get("featureEffect") !== e12 && this._transitionTo(e12);
  }
  get filter() {
    return this._filter || this.featureEffect?.filter || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e12) {
    this._set("scale", e12), this._excludedEffectView.scale = e12, this._includedEffectView.scale = e12;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  get transitioningToEmpty() {
    return !this._excludedEffectView.final && !this._includedEffectView.final;
  }
  transitionStep(e12, t11) {
    this._set("scale", t11), this.transitioning ? (this._includedEffectView.transitionStep(e12, t11), this._excludedEffectView.transitionStep(e12, t11), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t11, this._includedEffectView.scale = t11);
  }
  endTransition() {
    this._includedEffectView.endTransition(), this._excludedEffectView.endTransition(), this._filter = null;
  }
  _transitionTo(e12) {
    const t11 = this._get("featureEffect"), i14 = e12, f6 = i14?.includedEffect, s12 = i14?.excludedEffect, c10 = this._includedEffectView.canTransitionTo(f6) && this._excludedEffectView.canTransitionTo(s12);
    this._includedEffectView.effect = f6, this._excludedEffectView.effect = s12, this._set("featureEffect", i14), this._filter = i14?.filter || t11?.filter || null, c10 || this.endTransition();
  }
};
r([m()], c3.prototype, "_filter", void 0), r([m()], c3.prototype, "_excludedEffectView", void 0), r([m()], c3.prototype, "_includedEffectView", void 0), r([m()], c3.prototype, "duration", void 0), r([m()], c3.prototype, "excludedEffects", null), r([m()], c3.prototype, "featureEffect", null), r([m()], c3.prototype, "filter", null), r([m()], c3.prototype, "hasEffects", null), r([m()], c3.prototype, "includedEffects", null), r([m({ value: 0 })], c3.prototype, "scale", null), r([m()], c3.prototype, "transitioning", null), r([m()], c3.prototype, "transitioningToEmpty", null), c3 = r([a2("esri.layers.effects.FeatureEffectView")], c3);

// node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var c4 = class extends g2 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e12, t11) {
    const o19 = f2.fromJSON(t11.spatialReference), s12 = [];
    for (let a9 = 0; a9 < e12.length; a9++) {
      const t12 = e12[a9], p12 = s6.fromJSON(t12), c10 = t12.geometry?.spatialReference;
      null == p12.geometry || c10 || (p12.geometry.spatialReference = o19);
      const i14 = t12.aggregateGeometries, m16 = p12.aggregateGeometries;
      if (i14 && null != m16) for (const e13 in m16) {
        const r12 = m16[e13], t13 = i14[e13], s13 = t13?.spatialReference;
        null == r12 || s13 || (r12.spatialReference = o19);
      }
      s12.push(p12);
    }
    return s12;
  }
};
r([m({ type: [s6], json: { write: true } })], c4.prototype, "features", void 0), r([o("features")], c4.prototype, "readFeatures", null), c4 = r([a2("esri.rest.support.AggregateFeatureSet")], c4);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/FeatureInstanceStore.js
var n5 = class {
  constructor() {
    this._instanceById = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._instanceById.clear();
  }
  get size() {
    return this._instanceById.size;
  }
  entries() {
    return this._instanceById.entries();
  }
  find(t11) {
    for (const e12 of this.values()) if (e12.techniqueRef.type === t11) return e12;
    return null;
  }
  updateStart(t11) {
    t11 && (this._instanceByIdNext = /* @__PURE__ */ new Map(), this._shaderCountByMesh = /* @__PURE__ */ new Map(), this._shaderIndices = /* @__PURE__ */ new Map());
  }
  updateEnd(t11) {
    if (t11) {
      if (!this._instanceByIdNext) throw new Error("InternalError: Found updateEnd call without corresponding updateStart");
      for (const t12 of this._instanceById.keys()) this._instanceByIdNext.has(t12) || this._instanceById.delete(t12);
      for (const [t12, e12] of this._instanceByIdNext.entries()) {
        const s12 = this._instanceById.get(t12);
        s12 ? s12.setInput(e12.getInput()) : this._instanceById.set(t12, e12);
      }
      this._instanceByIdNext = null, this._shaderCountByMesh = null, this._shaderIndices = null;
    }
  }
  values() {
    return this._instanceById.values();
  }
  ensureInstance(n16, i14) {
    let r12;
    if ("object" == typeof i14 && "optionalAttributes" in i14 && "uniforms" in i14) {
      const t11 = `${n16.type}.${JSON.stringify(i14.optionalAttributes)}`, e12 = t11 + `.${JSON.stringify(i14.uniforms)}`;
      let s12 = 0;
      null != this._instanceByIdNext && (this._shaderIndices.has(e12) ? s12 = this._shaderIndices.get(e12) : (s12 = this._shaderCountByMesh.get(t11) ?? 0, this._shaderCountByMesh.set(t11, s12 + 1), this._shaderIndices.set(e12, s12))), r12 = t11 + `.${s12}`;
    } else r12 = `${n16.type}.${JSON.stringify(i14)}`;
    const a9 = l(r12);
    if (this._instanceByIdNext) {
      const t11 = new i6(r5(a9), n16, i14);
      return this._instanceByIdNext.set(a9, t11), t11;
    }
    if (!this._instanceById.has(a9)) {
      const t11 = new i6(r5(a9), n16, i14);
      this._instanceById.set(a9, t11);
    }
    return this._instanceById.get(a9);
  }
  getInstance(t11) {
    const e12 = this._instanceById.get(t11);
    if (null == e12) throw new Error(`InternalError: Unable to get instance for ${t11}`);
    return e12;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/RenderState.js
var d5 = 1e3;
var l5 = class {
  constructor(t11, i14, s12, o19, n16, r12) {
    this.getStage = t11, this.getSubscriptionVersion = i14, this.version = s12, this._fader = o19, this._container = n16, this._tileInfoView = r12, this._pendingUpdates = new t3(d5), this._locked = false, this._tiles = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const e12 of this.tiles()) e12.destroy();
    this._pendingUpdates.clear(), this._tiles.clear();
  }
  tiles() {
    return this._tiles.values();
  }
  size() {
    return this._tiles.size;
  }
  getTile(e12) {
    return this._tiles.get(e12);
  }
  setTiles(e12) {
    this._tiles.clear();
    for (const t11 of e12) this._tiles.set(t11.key.id, t11);
  }
  lockUploads() {
    this._locked = true;
  }
  unlockUploads() {
    this._locked = false, this.flush();
  }
  enqueueUpdate(e12) {
    this._pendingUpdates.enqueue(e12);
  }
  update(e12) {
    if (!this._locked) for (; this._pendingUpdates.size; ) {
      const t11 = this._pendingUpdates.peek();
      if (null == t11 || t11.inner.attributeEpoch > e12) break;
      this._updateTile(t11), this._pendingUpdates.dequeue();
    }
  }
  removeTile(e12) {
    const t11 = this._tiles.get(e12);
    has("esri-2d-update-debug") && console.debug(`Tile[${e12}] RenderState.removeTile`), t11 && (this._fader.unregisterFeatureTile(t11), t11.destroy()), this._tiles.delete(e12);
  }
  isTileDone(e12) {
    const t11 = this._tiles.get(e12.id);
    return !!t11 && (t11.isReady && t11.decluttered);
  }
  flush() {
    for (; this._pendingUpdates.size; ) {
      const e12 = this._pendingUpdates.dequeue();
      null != e12 && this._updateTile(e12);
    }
    for (const e12 of this._tiles.values()) e12.upload();
  }
  _updateTile(e12) {
    const { inner: t11, objectIdMap: i14 } = e12, s12 = this.getSubscriptionVersion(t11.id);
    if (s12 !== t11.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e13 = `${t11.subscriptionVesrion} != ${s12}`;
        console.debug(`Version[${e13}] Tile[${t11.id}] FeatureContainer - Dropping message, outdated version]`, t11);
      }
      return;
    }
    if (has("esri-2d-update-debug")) {
      const e13 = t11.debugInfo?.chunkId ?? "<EnsureEnd>";
      console.debug(`Version[${t11.version}] Tile[${t11.id}] Chunk[${e13}] RenderState.updateTile [${t11.type}]`, t11);
    }
    const o19 = this._ensureTile(t11.id);
    if ("update" === t11.type) {
      const [e13, ...s13] = t11.modify;
      o19.onMessage({ type: "update", modify: e13, remove: t11.remove, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i14 });
      for (const o20 of s13) {
        const e14 = this._tiles.get(o20.tileId);
        e14 && e14.onMessage({ type: "update", modify: o20, remove: t11.remove, end: false, isPixelBuffer: true, attributeEpoch: null, objectIdMap: i14 });
      }
      return;
    }
    if (null == t11.append) return void o19.onMessage({ type: "append", clear: t11.clear, debugInfo: t11.debugInfo, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i14 });
    const [n16, ...r12] = t11.append;
    o19.onMessage({ type: "append", clear: t11.clear, append: n16, debugInfo: t11.debugInfo, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i14 });
    for (const d9 of r12) {
      const e13 = this._tiles.get(d9.tileId);
      e13 && e13.onMessage({ type: "update", modify: d9, remove: [], sort: false, end: false, isPixelBuffer: true, attributeEpoch: null, objectIdMap: i14 });
    }
  }
  _ensureTile(e12) {
    if (!this._tiles.has(e12)) {
      const t11 = this._createTile(e12);
      this._copyPixelBufferedEntitiesInto(t11), this._tiles.set(e12, t11);
    }
    return this._tiles.get(e12);
  }
  _createTile(e12) {
    has("esri-2d-update-debug") && console.debug(`Version[${this.version}] Tile[${e12}] RenderState.createTile`);
    const d9 = new e3(e12), l10 = this._tileInfoView.getTileBounds(u3(), d9), a9 = l10[0], u18 = l10[3], p12 = this._tileInfoView.getTileResolution(d9.level), c10 = this._container.instanceStore.find(e4.Label)?.instanceId, h4 = new I(d9, p12, a9, u18, this._fader, c10, true);
    if (this._fader.registerFeatureTile(h4), h4.stage = this.getStage(), !h4.stage) {
      const e13 = new s("featurelayerview:webgl", "Cannot create tile with empty stage");
      i2.getLogger("esri.views.2d.layers.features.RenderState").error(e13);
    }
    return h4;
  }
  _copyPixelBufferedEntitiesInto(e12) {
    let t11 = 7;
    const i14 = this._tileInfoView.getLODInfoAt(e12.key);
    for (let s12 = -1; s12 <= 1; s12++) for (let o19 = -1; o19 <= 1; o19++) {
      if (0 === s12 && 0 === o19) continue;
      const n16 = e12.key.getNormalizedNeighbor(o19, s12, i14).id, r12 = this._tiles.get(n16);
      if (null != r12) {
        const i15 = 1 << t11;
        e12.copyPixelBufferedEntitesFrom(r12, i15, o19, s12);
      }
      t11--;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureContainer.js
var c5 = class {
  constructor(e12, s12) {
    this.id = e12, this.version = s12, this._resolver = L2(), this._done = false;
  }
  get done() {
    return this._done;
  }
  get promise() {
    return this._resolver.promise;
  }
  end() {
    this._resolver.resolve(), this._done = true;
  }
  destroy() {
    this._resolver.reject();
  }
};
var _2 = class extends n4 {
  constructor(e12) {
    super(e12.view.featuresTilingScheme), this.updatingHandles = new h2(), this._hitTestsRequests = [], this._store = new n5(), this._visibleTiles = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Map(), this._updateStatisticsRequests = [], this._lockStatisticUpdates = false, this._shouldUnlockAttributeView = false, this._layerView = e12, this.addTransitionable(this._layerView.featureEffectView);
  }
  renderChildren(e12) {
    if (this._updateAttributeView(), this._renderState?.update(this.attributeView.currentEpoch), this._layerView.requestUpdate(), this._renderState) {
      const e13 = Array.from(this._renderState.tiles()).filter((e14) => e14.needsUpload);
      if (e13.length) {
        e13[Math.floor(Math.random() * e13.length)].upload(), e13.length >= 2 && this.requestRender();
      }
      for (const t12 of this._renderState.tiles()) t12.tryReady(this.attributeView.currentEpoch) && (this._subscriptions.get(t12.key.id)?.end(), this._layerView.requestUpdate(), this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this._layerView.view.labelManager.symbolFader.restartDeclutter(), this.requestRender());
    }
    const t11 = this._layerView.subscriptionManager.updateVisibility();
    this.setVisibleTiles(t11);
    for (const s12 of this.children) s12.setTransform(e12.state);
    switch (super.renderChildren(e12), e12.drawPhase) {
      case E2.MAP:
        return this._renderMapPhase(e12);
      case E2.HIGHLIGHT:
        return this._renderHighlightPhase(e12);
      case E2.LABEL:
        return this._renderLabelPhase(e12);
    }
  }
  subscriptions() {
    return this._subscriptions.values();
  }
  get _instanceStore() {
    return this._store;
  }
  get instanceStore() {
    return this._store;
  }
  get layerView() {
    return this._layerView;
  }
  get hasLabels() {
    return this._layerView.labelingCollisionInfos.length > 0;
  }
  get hasHighlight() {
    return this._layerView.hasHighlight;
  }
  get _layer() {
    return this._layerView.layer;
  }
  _getHeatmapInstance(e12) {
    if (null == this._instanceStore || !(e12.drawPhase & F.heatmap.drawPhase)) return null;
    for (const t11 of this._instanceStore.values()) if (p6(t11)) return t11;
    return null;
  }
  get tiles() {
    return this._renderState?.tiles();
  }
  get children() {
    return this._renderState ? Array.from(this._renderState.tiles()).filter((e12) => this._visibleTiles.has(e12.key.id)) : [];
  }
  updateAttributeView(e12) {
    this.requestRender(), this.attributeView.requestUpdate(e12), this.hasLabels && (this._layerView.view.labelManager.requestUpdate(), this._layerView.view.labelManager.symbolFader.restartDeclutter());
  }
  updateSubscriptions(e12) {
    for (const { tileId: t11, version: s12 } of e12.subscribe) if (this._subscriptions.has(t11)) this._subscriptions.get(t11).version = s12;
    else {
      const e13 = new c5(t11, s12);
      this._subscriptions.set(t11, e13), this.updatingHandles.addPromise(e13.promise);
    }
    for (const t11 of e12.unsubscribe) {
      const e13 = this._subscriptions.get(t11);
      e13?.destroy(), this._subscriptions.delete(t11), this.removeTile(t11);
    }
  }
  isDone(e12) {
    return !!this._renderState && this._renderState.isTileDone(e12);
  }
  async updateRenderState(e12) {
    has("esri-2d-update-debug") && console.debug(`Version[${e12}] FeatureContainer.updateRenderState`), this._renderStateNext = new l5(() => this._stage, (e13) => this._subscriptions.get(e13)?.version, e12, this.layerView.view.labelManager.symbolFader, this, this.tileInfoView);
  }
  getDisplayStatistics(e12, t11) {
    const s12 = this._statisticsByLevel.get(e12);
    return s12 ? s12.get(t11) : null;
  }
  updateStatistics(e12, t11) {
    if (this._lockStatisticUpdates) return void this._updateStatisticsRequests.push({ level: e12, statistics: t11 });
    let s12 = this._statisticsByLevel.get(e12);
    s12 || (s12 = /* @__PURE__ */ new Map(), this._statisticsByLevel.set(e12, s12));
    for (const i14 of t11) s12.set(i14.fieldName, { minValue: i14.minValue, maxValue: i14.maxValue });
  }
  lockForOverrides() {
    this._renderState?.lockUploads(), this._lockStatisticUpdates = true, this.attributeView.locked || (this.attributeView.lockTextureUploads(), this._shouldUnlockAttributeView = true);
  }
  unlockForOverrides() {
    this._renderState?.unlockUploads(), this._shouldUnlockAttributeView && (this.attributeView.unlockTextureUploads(), this._shouldUnlockAttributeView = false), this._lockStatisticUpdates = false;
    for (const e12 of this._updateStatisticsRequests) this.updateStatistics(e12.level, e12.statistics);
    this._updateStatisticsRequests = [], this._renderState?.flush(), this.requestRender();
  }
  trySwapRenderState() {
    if (this._renderStateNext) {
      has("esri-2d-update-debug") && console.debug(`Version[${this._renderStateNext.version}] FeatureContainer.update.swapRenderState`);
      const e12 = /* @__PURE__ */ new Map();
      for (const t11 of this._renderState?.tiles() || []) e12.set(t11.id, t11.metricsVisibility);
      this._renderState?.destroy(), this._renderState = this._renderStateNext, this._renderState.flush();
      for (const t11 of this._renderState.tiles()) t11.copyMetricsVisibility(e12.get(t11.id) || /* @__PURE__ */ new Set());
      this._renderStateNext = null;
    }
    this.requestRender();
  }
  setVisibleTiles(e12) {
    this._visibleTiles = e12;
    for (const t11 of this.tiles ?? []) t11.rendering = e12.has(t11.key.id);
  }
  async onMessage(t11, s12) {
    s2(s12);
    const i14 = t11.inner;
    if (!this._subscriptions.has(i14.id)) return;
    const r12 = this._subscriptions.get(i14.id);
    if (r12.version !== i14.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e12 = `${i14.subscriptionVesrion} != ${r12.version}`;
        console.debug(`Version[${e12}] Tile[${i14.id}] FeatureContainer - Dropping message, outdated version]`, i14);
      }
      return;
    }
    const n16 = this._renderStateNext ?? this._renderState;
    if (!n16) throw new Error("InternalError: No renderState defined");
    n16.version !== i14.version && console.error(`InternalError: Version mismatch. [renderState: ${n16.version}, message: ${i14.version}]`), n16.enqueueUpdate(t11), this.requestRender(), this._layerView.view.labelManager.requestUpdate(), this._layerView.requestUpdate();
  }
  removeTile(e12) {
    (this._renderState || this._renderStateNext) && (this._renderState && this._renderState.removeTile(e12), this._renderStateNext && this._renderStateNext.removeTile(e12));
  }
  hitTest(e12) {
    let s12 = this._hitTestsRequests.find(({ x: t11, y: s13 }) => t11 === e12.x && s13 === e12.y);
    const i14 = L2();
    return s12 ? s12.resolvers.push(i14) : (s12 = { x: e12.x, y: e12.y, resolvers: [i14] }, this._hitTestsRequests.push(s12)), this.requestRender(), i14.promise;
  }
  getSortKeys(e12) {
    const t11 = new Set(e12), s12 = /* @__PURE__ */ new Map();
    for (const i14 of this.children) if (i14.getSortKeys(t11).forEach((e13, t12) => s12.set(t12, e13)), s12.size === t11.size) break;
    return s12;
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  doRender(e12) {
    const { minScale: t11, maxScale: s12 } = this._layer.effectiveScaleRange, i14 = e12.state.scale;
    i14 <= (t11 || 1 / 0) && i14 >= s12 && super.doRender(e12);
  }
  afterRender(e12) {
    super.afterRender(e12), this._hitTestsRequests.length && this.requestRender();
  }
  setStencilReference(e12) {
    if (null == this._getHeatmapInstance(e12)) super.setStencilReference(e12);
    else for (const t11 of this.children) t11.stencilRef = F.heatmap.getStencilReference(t11);
  }
  _renderMapPhase(e12) {
    this._layerView.featureEffectView.hasEffects ? (this._renderOutsideEffect(e12), this._renderInsideEffect(e12)) : this._renderFeatures(e12, R4.All), this._hitTestsRequests.length > 0 && this._renderHittest(e12);
  }
  _renderHighlightPhase(e12) {
    this.hasHighlight && h3(e12, false, (e13) => {
      this._renderFeatures(e13, R4.Highlight);
    });
  }
  _renderLabelPhase(e12) {
    this._renderFeatures(e12, R4.All);
  }
  _renderInsideEffect(e12) {
    const t11 = e12.painter.effects.insideEffect;
    t11.bind(e12), this._renderFeatures(e12, R4.InsideEffect), t11.draw(e12, this._layerView.featureEffectView.includedEffects), t11.unbind();
  }
  _renderOutsideEffect(e12) {
    const t11 = e12.painter.effects.outsideEffect;
    t11.bind(e12), this._renderFeatures(e12, R4.OutsideEffect), t11.draw(e12, this._layerView.featureEffectView.excludedEffects), t11.unbind();
  }
  _renderHittest(e12) {
    const { context: t11 } = e12, s12 = e12.painter.effects.hittest, i14 = t11.getBoundFramebufferObject(), a9 = t11.getViewport(), o19 = e12.passOptions, h4 = e12.drawPhase;
    s12.bind(e12), e12.passOptions = s12.createOptions(e12, this._hitTestsRequests), e12.drawPhase = E2.HITTEST;
    const { distance: d9, smallSymbolDistance: l10 } = e12.passOptions, u18 = Math.max(d9, l10);
    for (const r12 of this.children) r12.visible && r12.containsScreenPoint(e12.state, e12.passOptions.position, 2 * u18) && this._renderTile(r12, e12, R4.All);
    s12.draw(e12), s12.unbind(), t11.bindFramebuffer(i14), t11.restoreViewport(a9), e12.passOptions = o19, e12.drawPhase = h4;
  }
  _renderFeatures(e12, t11) {
    const s12 = this._getHeatmapInstance(e12);
    null != s12 ? this._renderHeatmapFeatures(e12, t11, s12) : this._renderGeometryFeatures(e12, t11);
  }
  _renderGeometryFeatures(e12, t11) {
    for (const s12 of this.children) s12.visible && this._renderTile(s12, e12, t11);
  }
  _renderHeatmapFeatures(e12, t11, s12) {
    for (const i14 of this.children) i14.visible && this._renderTile(i14, e12, t11, e4.Heatmap);
    s12.techniqueRef.renderResolvePass(e12, s12);
  }
  _renderTile(e12, t11, s12, i14) {
    const r12 = has("featurelayer-strict-draw-order") ? N.STRICT_ORDER : has("featurelayer-force-marker-text-draw-order") ? N.STRICT_MARKERS_AND_TEXT : N.BATCHING, n16 = e12.getDisplayList(this._instanceStore, r12);
    t11.selection = s12, n16?.render(t11, i14);
  }
};
function p6(e12) {
  return e12.techniqueRef.type === e4.Heatmap;
}

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorkerProxy.js
async function t6(t11) {
  const o19 = await p3("FeaturePipelineWorker", { client: t11, strategy: "dedicated" });
  return new n6(o19);
}
var n6 = class {
  constructor(e12) {
    this._connection = e12, this.pipeline = this._connection.createInvokeProxy(), this.features = this._connection.createInvokeProxy("features"), this.aggregates = this._connection.createInvokeProxy("aggregates"), this.streamMessenger = this._connection.createInvokeProxy("streamMessenger");
  }
  destroy() {
    this._connection.destroy();
  }
  get closed() {
    return this._connection.closed;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSourceEventLog.js
var n7 = 10;
var l6 = class extends b2 {
  constructor() {
    super(...arguments), this.events = new o3(), this._updatingStrategy = true, this._tileToEvent = new s3(), this._fetchStatus = { outstanding: 0, done: 0 };
  }
  get hasAllData() {
    return !this._updatingStrategy && this._hasAllTileData();
  }
  get willQueryAllFeatures() {
    return this._strategyInfo?.willQueryAllFeatures ?? false;
  }
  get willQueryFullResolutionGeometry() {
    return this._strategyInfo?.willQueryAllFeatures ?? false;
  }
  onEvent(t11) {
    switch (t11.type) {
      case "subscribe":
      case "unsubscribe":
      case "loaded":
      case "error":
        this._handleTileEvent(t11);
        break;
      case "updateStrategyStart":
        this._updatingStrategy = true, this._fetchStatus = { done: 0, outstanding: 0 }, this._strategyInfo = t11.about;
        break;
      case "updateStrategyEnd":
        this._updatingStrategy = false;
        break;
      case "updateFieldsStart":
        this._fetchStatus = { done: 0, outstanding: 0 };
        break;
      case "updateFieldsEnd":
        break;
      case "updateFieldsError":
        this.events.emit("error", t11);
        break;
      case "fetchStart":
        this._fetchStatus.outstanding += 1, this.events.emit("status", this._fetchStatus);
        break;
      case "fetchEnd":
        this._fetchStatus.done += 1, this.events.emit("status", this._fetchStatus), t11.done && (this._fetchStatus = { done: 0, outstanding: 0 });
    }
  }
  _hasAllTileData() {
    for (const t11 of this._tileToEvent.values()) {
      const e12 = t11.peekLast();
      if ("loaded" !== e12?.type) return false;
    }
    return true;
  }
  _handleTileEvent(t11) {
    switch (t11.type) {
      case "subscribe": {
        const e12 = new t3(n7);
        e12.enqueue(t11), this._tileToEvent.set(t11.tile, e12);
        break;
      }
      case "unsubscribe":
        this._tileToEvent.delete(t11.tile);
        break;
      case "loaded": {
        const e12 = this._tileToEvent.get(t11.tile);
        if (!e12) return;
        e12.enqueue(t11), this._tileToEvent.set(t11.tile, e12);
        break;
      }
      case "error": {
        const e12 = this._tileToEvent.get(t11.tile);
        if (!e12) return;
        e12.enqueue(t11), this._tileToEvent.set(t11.tile, e12), this.events.emit("error", t11);
        break;
      }
    }
  }
};
r([m({ readOnly: true })], l6.prototype, "hasAllData", null), r([m()], l6.prototype, "willQueryAllFeatures", null), r([m()], l6.prototype, "willQueryFullResolutionGeometry", null), r([m()], l6.prototype, "_updatingStrategy", void 0), r([m()], l6.prototype, "_strategyInfo", void 0), r([m()], l6.prototype, "_tileToEvent", void 0), l6 = r([a2("esri.views.2d.layers.features.FeatureSourceEventLog")], l6);

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/geometryUtils.js
function e8(e12) {
  switch (e12.geometryType) {
    case "point":
      return "esriGeometryPoint";
    case "polyline":
      return "esriGeometryPolyline";
    case "mesh":
    case "polygon":
      return "esriGeometryPolygon";
    case "multipatch":
      return "esriGeometryMultiPatch";
    case "multipoint":
      return "esriGeometryMultipoint";
    default:
      return null;
  }
}

// node_modules/@arcgis/core/views/2d/layers/support/visualVariableSimpleUtils.js
var r7 = Math.PI;
function i9(e12, t11) {
  switch (t11.transformationType) {
    case i3.Additive:
      return s8(e12, t11);
    case i3.Constant:
      return o9(t11, e12);
    case i3.ClampedLinear:
      return u10(e12, t11);
    case i3.Proportional:
      return l7(e12, t11);
    case i3.Stops:
      return c6(e12, t11);
    case i3.RealWorldSize:
      return m7(e12, t11);
    case i3.Identity:
      return e12;
    case i3.Unknown:
      return null;
  }
}
function a8(e12, t11) {
  return "number" == typeof e12 ? e12 : i9(t11, e12);
}
function s8(e12, t11) {
  return e12 + (a8(t11.minSize, e12) || t11.minDataValue);
}
function o9(e12, t11) {
  const n16 = e12.stops;
  let r12 = n16?.length && n16[0].size;
  return null == r12 && (r12 = e12.minSize), a8(r12, t11);
}
function u10(e12, t11) {
  const n16 = t11.minDataValue, r12 = t11.maxDataValue, i14 = (e12 - n16) / (r12 - n16), s12 = a8(t11.minSize, e12), o19 = a8(t11.maxSize, e12);
  return e12 <= n16 ? s12 : e12 >= r12 ? o19 : s12 + i14 * (o19 - s12);
}
function l7(t11, n16) {
  const r12 = t11 / n16.minDataValue, i14 = a8(n16.minSize, t11), s12 = a8(n16.maxSize, t11);
  let o19 = null;
  return o19 = r12 * i14, r2(o19, i14, s12);
}
function c6(e12, t11) {
  const [n16, r12, i14] = p7(e12, t11.cache.ipData);
  if (n16 === r12) return a8(t11.stops[n16].size, e12);
  {
    const s12 = a8(t11.stops[n16].size, e12);
    return s12 + (a8(t11.stops[r12].size, e12) - s12) * i14;
  }
}
function m7(n16, i14) {
  const s12 = m3[i14.valueUnit], o19 = a8(i14.minSize, n16), u18 = a8(i14.maxSize, n16), { valueRepresentation: l10 } = i14;
  let c10 = null;
  return c10 = "area" === l10 ? 2 * Math.sqrt(n16 / r7) / s12 : "radius" === l10 || "distance" === l10 ? 2 * n16 / s12 : n16 / s12, r2(c10, o19, u18);
}
function p7(e12, t11) {
  if (!t11) return;
  let n16 = 0, r12 = t11.length - 1;
  return t11.some((t12, i14) => e12 < t12 ? (r12 = i14, true) : (n16 = i14, false)), [n16, r12, (e12 - t11[n16]) / (t11[r12] - t11[n16])];
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/labelingUtils.js
function l8(n16) {
  return (n16.labelsVisible && n16.labelingInfo?.every((n17) => "none" !== n17.deconflictionStrategy)) ?? false;
}
function r8(n16, i14) {
  const l10 = e7(n16, i14);
  if (l10?.labelsVisible && l10.labelingInfo?.length) return l10.labelingInfo.every((n17) => "none" !== n17.deconflictionStrategy);
}
function t7(e12) {
  return (l10) => u4(i9(l10, e12));
}
function o10(n16) {
  const e12 = null != n16 && "visualVariables" in n16 && n16.visualVariables;
  if (!e12) return null;
  for (const i14 of e12) if ("size" === i14.type) return t7(i14);
  return null;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/SourceSchema.js
function t8(t11, i14, s12, o19) {
  const l10 = null != t11.subtypeCode ? `${t11.subtypeField} = ${t11.subtypeCode}` : null, n16 = r3(t11.definitionExpression, l10), r12 = t11.customParameters ?? {}, a9 = i14.displayFilterEnabled && t11.displayFilterInfo ? t11.displayFilterInfo.toJSON() : null;
  return o19 && (r12.token = o19), { type: "feature", mutable: { sourceRefreshVersion: s12, availableFields: i14.availableFields, displayFilterInfo: a9, dataFilter: { definitionExpression: n16, customParameters: r12, gdbVersion: t11.gdbVersion, historicMoment: t11.historicMoment?.getTime(), queryScaleRanges: t11.queryScaleRanges ?? [], timeExtent: t11.timeExtent?.toJSON() } } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/color.js
function u11(n16, r12, t11 = 0) {
  if (null == r12) return n16[t11] = 0, n16[t11 + 1] = 0, n16[t11 + 2] = 0, void (n16[t11 + 3] = 0);
  const { r: o19, g: u18, b: i14, a: c10 } = r12;
  n16[t11] = o19 * c10 / 255, n16[t11 + 1] = u18 * c10 / 255, n16[t11 + 2] = i14 * c10 / 255, n16[t11 + 3] = c10;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/SymbolSchema.js
async function g3(i14, a9) {
  if (!i14) return [];
  switch (i14.type) {
    case "simple-fill":
      return j2(i14, a9);
    case "picture-fill":
      return F2(i14, a9);
    case "simple-marker":
      return w3(i14, a9);
    case "picture-marker":
      return A(i14, a9);
    case "simple-line":
      return P2(i14, a9, false);
    case "text":
      return L4(i14, a9);
    case "label":
      return R5(i14, a9);
    case "cim":
      return u8(i14.data, a9);
    case "web-style":
      return g3(await i14.fetchSymbol({ acceptedFormats: ["cim", "web"] }), a9);
    case "line-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i14.type}" unsupported in MapView. Defaulting to simple-line`), P2(new m4(), a9, false);
    case "point-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i14.type}" unsupported in MapView. Defaulting to simple-marker`), w3(new u6(), a9);
    case "polygon-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i14.type}" unsupported in MapView. Defaulting to simple-fill`), j2(new m5(), a9);
    case "mesh-3d":
    case "label-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i14.type}" unsupported in MapView. Ignoring`), [];
    case "CIMSymbolReference":
      throw new Error("InternalError: CIMSymbolReference should already be resolved");
  }
}
async function M2(e12, i14) {
  const { schemaOptions: a9 } = i14, { store: r12 } = a9, t11 = new Array(s5), o19 = new Array(s5 / 4);
  for (let l10 = 0; l10 < s5; l10++) {
    const i15 = l10 < e12.attributes.length ? e12.attributes[l10].color : null;
    t11[l10] = [0, 0, 0, 0], u11(t11[l10], i15);
  }
  for (let l10 = 0; l10 < s5 / 4; l10++) o19[l10] = [0, 0, 0, 0], o19[l10][0] = 4 * l10 < e12.attributes.length ? 1 : 0, o19[l10][1] = 4 * l10 + 1 < e12.attributes.length ? 1 : 0, o19[l10][2] = 4 * l10 + 2 < e12.attributes.length ? 1 : 0, o19[l10][3] = 4 * l10 + 3 < e12.attributes.length ? 1 : 0;
  const s12 = { uniforms: { isActive: o19, colors: t11, dotValue: e12.dotValue, dotScale: e12.referenceScale, blending: e12.dotBlendingEnabled, dotSize: e12.dotSize, seed: e12.seed }, optionalAttributes: {} }, n16 = r12.ensureInstance(F.dotDensity, s12).createMeshInfo({ effects: null }), u18 = [], c10 = new m5({ color: e12.backgroundColor ?? [0, 0, 0, 0], outline: null }), p12 = await g3(c10, i14);
  if (u18.push(...p12), u18.push(n16), e12.outline) {
    const a10 = P2(e12.outline, i14, true);
    u18.push(...a10);
  }
  return u18;
}
async function C(e12, l10) {
  const { store: r12 } = l10, { radius: t11, minDensity: o19, maxDensity: s12, referenceScale: n16, field: u18, valueExpression: c10, colorStops: p12 } = e12, f6 = f3(p12);
  return [r12.ensureInstance(F.heatmap, { uniforms: { radius: u4(t11), minDensity: o19, maxDensity: s12, referenceScale: n16, isFieldActive: !(!u18 && !c10), gradient: f6, gradientHash: f6.join(",") }, optionalAttributes: {} }).createMeshInfo({ effects: null })];
}
async function x3(e12, a9) {
  const { store: l10 } = a9, r12 = e12.outline?.width || 0, t11 = y(e12), o19 = l10.ensureInstance(F.pieChart, { uniforms: { shader: { outlineWidth: Math.round(u4(r12)), defaultColor: t4(e12.defaultColor), outlineColor: t4(e12.outline?.color), othersColor: t4(e12.othersCategory?.color), donutRatio: e12.holePercentage, sectorThreshold: e12.othersCategory?.threshold || 0, colors: e12.attributes.map((e13) => t4(e13.color)), visualVariableOpacity: t11.visualVariableOpacity, visualVariableSizeMinMaxValue: t11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t11.visualVariableSizeScaleStops, visualVariableSizeStops: t11.visualVariableSizeStops, visualVariableSizeUnitValue: t11.visualVariableSizeUnitValue, hittestUniforms: null, highlightUniforms: null }, numberOfFields: e12.attributes.length }, optionalAttributes: {} }).createMeshInfo({ size: e12.size, outlineWidth: r12, effects: null, scaleInfo: null, minPixelBuffer: x2(t11) });
  return [...e12.backgroundFillSymbol ? await j2(e12.backgroundFillSymbol, { schemaOptions: a9, uniforms: z2 }) : [], o19];
}
function I2(e12) {
  if ("path" === e12.style) {
    if (null == e12.path) throw new Error("Symbol with a style of type path must define a path");
    return { type: "sprite-rasterization-param", overrides: [], resource: { type: "path", path: e12.path, asFill: true } };
  }
  const i14 = te.fromSimpleMarker(e12);
  if ("outline" in e12 && e12.outline && "none" !== e12.outline.style) {
    if ("solid" !== e12.outline.style) {
      if (!i14 || !i14.symbolLayers) throw new Error("Error handling marker! ");
      return { type: "sprite-rasterization-param", resource: i14.symbolLayers[0], overrides: [] };
    }
  }
  return { type: "sprite-rasterization-param", resource: a4(i14), overrides: [] };
}
async function w3(e12, i14) {
  const { uniforms: a9, schemaOptions: l10 } = i14, { store: r12 } = l10;
  if ("path" === e12.style || e12.outline && "solid" !== e12.outline.style && "none" !== e12.outline.style) {
    const l11 = te.fromSimpleMarker(e12);
    if (!l11 || !l11.symbolLayers) throw new Error("Error handling marker! ");
    if (a9.visualVariableRotation && (l11.angleAlignment = "Map"), "path" !== e12.style) {
      const e13 = l11.symbolLayers[0];
      if (e6(i14.uniforms)) {
        const a10 = x2(i14.uniforms, 0, 1);
        if (a10 > e13.size) {
          const i15 = a10 / e13.size;
          e13.size = a10;
          const l12 = e13.markerGraphics?.[0].symbol;
          (l12.symbolLayers && l12.symbolLayers[0]).width *= i15;
        }
      }
    }
    return u8({ type: "CIMSymbolReference", symbol: l11 }, i14);
  }
  const t11 = r12.ensureInstance(F.marker, { uniforms: { visualVariableColor: a9.visualVariableColor, visualVariableOpacity: a9.visualVariableOpacity, visualVariableSizeMinMaxValue: a9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a9.visualVariableSizeScaleStops, visualVariableSizeStops: a9.visualVariableSizeStops, visualVariableSizeUnitValue: a9.visualVariableSizeUnitValue, visualVariableRotation: a9.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s12 = I2(e12);
  let u18 = e12.color?.toArray() ?? [0, 0, 0, 0];
  "CIMVectorMarker" === s12.resource.type && (u18 = [255, 255, 255, 255]);
  const c10 = "triangle" === e12.style ? 124 / 116 : 1, p12 = e12.size, f6 = p12 * c10, b4 = null != a9.visualVariableColor && ("cross" === e12.style || "x" === e12.style);
  return [t11.createMeshInfo({ type: "simple", color: u18, height: p12, width: f6, offsetX: e12.xoffset, offsetY: e12.yoffset, angle: e12.angle, alignment: a6(a9) ? i4.MAP : i4.SCREEN, outlineColor: e12.outline?.color?.toArray() ?? [0, 0, 0, 0], outlineSize: e12.outline?.width ?? 1, referenceSize: p12, sprite: s12, overrideOutlineColor: b4, hasSizeVV: e6(a9), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: x2(a9) })];
}
function A(e12, i14) {
  const { uniforms: a9, schemaOptions: l10 } = i14, { store: r12 } = l10, t11 = r12.ensureInstance(F.marker, { uniforms: { visualVariableColor: a9.visualVariableColor, visualVariableOpacity: a9.visualVariableOpacity, visualVariableSizeMinMaxValue: a9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a9.visualVariableSizeScaleStops, visualVariableSizeStops: a9.visualVariableSizeStops, visualVariableSizeUnitValue: a9.visualVariableSizeUnitValue, visualVariableRotation: a9.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s12 = te.createPictureMarkerRasterizationParam(e12);
  if (!s12) return [];
  return [t11.createMeshInfo({ type: "picture", color: [255, 255, 255, 255], height: e12.height, width: e12.width, offsetX: e12.xoffset, offsetY: e12.yoffset, angle: e12.angle, alignment: a6(a9) ? i4.MAP : i4.SCREEN, outlineColor: null, outlineSize: 0, referenceSize: e12.height, sprite: s12, overrideOutlineColor: false, hasSizeVV: e6(a9), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: x2(a9) })];
}
function O(e12, i14, a9) {
  const { uniforms: l10, schemaOptions: r12 } = a9, { store: t11 } = r12, o19 = t11.ensureInstance(F.marker, { uniforms: { visualVariableColor: l10.visualVariableColor, visualVariableOpacity: l10.visualVariableOpacity, visualVariableSizeMinMaxValue: l10.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: l10.visualVariableSizeScaleStops, visualVariableSizeStops: l10.visualVariableSizeStops, visualVariableSizeUnitValue: l10.visualVariableSizeUnitValue, visualVariableRotation: l10.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s12 = I2(e12), c10 = 6, p12 = c10 * i14.width, f6 = p12, b4 = e12.color?.toArray() ?? i14.color?.toArray() ?? [0, 0, 0, 0], S3 = "cross" === e12.style || "x" === e12.style;
  let V2;
  switch (e12.placement) {
    case "begin-end":
      V2 = o4.Both;
      break;
    case "begin":
      V2 = o4.JustBegin;
      break;
    case "end":
      V2 = o4.JustEnd;
      break;
    default:
      V2 = o4.None;
  }
  const v = { type: "cim-marker-placement-param", placement: { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: V2, offsetAlongLine: 0 }, overrides: [] };
  return [o19.createMeshInfo({ type: "simple", color: b4, height: f6, width: p12, offsetX: 0, offsetY: 0, angle: 0, alignment: a6(l10) ? i4.MAP : i4.SCREEN, outlineColor: b4, outlineSize: S3 ? i14.width : 0, referenceSize: f6 / c10, sprite: s12, overrideOutlineColor: S3 && null != l10.visualVariableColor, hasSizeVV: e6(l10), placement: v, transforms: null, effects: null, scaleInfo: null, minPixelBuffer: x2(l10) })];
}
function L4(e12, i14) {
  const { uniforms: a9, schemaOptions: l10 } = i14, { store: r12 } = l10;
  return [r12.ensureInstance(F.text, { uniforms: { visualVariableColor: a9.visualVariableColor, visualVariableOpacity: a9.visualVariableOpacity, visualVariableRotation: a9.visualVariableRotation, visualVariableSizeMinMaxValue: a9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a9.visualVariableSizeScaleStops, visualVariableSizeStops: a9.visualVariableSizeStops, visualVariableSizeUnitValue: a9.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false, clipAngle: false, referenceSymbol: false, visibility: false } }).createMeshInfo({ boxBackgroundColor: e12.backgroundColor?.toArray(), boxBorderLineColor: e12.borderLineColor?.toArray(), boxBorderLineSize: e12.borderLineSize ?? 0, color: e12.color?.toArray() ?? [0, 0, 0, 0], offsetX: e12.xoffset, offsetY: e12.yoffset, postAngle: e12.angle, fontSize: e12.font.size, decoration: e12.font.decoration, haloColor: e12.haloColor?.toArray() ?? [0, 0, 0, 0], haloSize: e12.haloSize ?? 0, outlineColor: [0, 0, 0, 0], outlineSize: 0, lineWidth: e12.lineWidth, lineHeightRatio: e12.lineHeight, horizontalAlignment: e12.horizontalAlignment, verticalAlignment: e12.verticalAlignment, useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: e12.font.toJSON(), textString: e12.text, symbol: te.createCIMTextSymbolfromTextSymbol(e12) }, overrides: [] }, referenceSize: null, effects: null, placement: null, scaleInfo: null, transforms: null, scaleFactor: 1, minPixelBuffer: x2(a9), repeatLabel: null, repeatLabelDistance: null, allowOverrun: null, labelPosition: null, labelClassId: -1 })];
}
function R5(e12, a9) {
  const { schemaOptions: l10, uniforms: r12 } = a9, { store: t11 } = l10, s12 = e12.symbol, { allowOverrun: n16, repeatLabel: u18, repeatLabelDistance: c10 } = e12, f6 = { maxScale: e12.maxScale ?? 0, minScale: e12.minScale ?? 0 }, b4 = t11.ensureInstance(F.label, { uniforms: { visualVariableColor: null, visualVariableOpacity: null, visualVariableRotation: r12.visualVariableRotation, visualVariableSizeMinMaxValue: r12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: r12.visualVariableSizeScaleStops, visualVariableSizeStops: r12.visualVariableSizeStops, visualVariableSizeUnitValue: r12.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: true, clipAngle: true, referenceSymbol: true, visibility: true } }), S3 = e12.labelPlacement, [V2, v] = o6(S3);
  return [b4.createMeshInfo({ boxBackgroundColor: s12.backgroundColor?.toArray(), boxBorderLineColor: s12.borderLineColor?.toArray(), boxBorderLineSize: s12.borderLineSize ?? 0, color: s12.color?.toArray() ?? [0, 0, 0, 0], offsetX: s12.xoffset, offsetY: s12.yoffset, postAngle: s12.angle, fontSize: s12.font.size, decoration: s12.font.decoration, outlineColor: [0, 0, 0, 0], outlineSize: 0, haloColor: s12.haloColor?.toArray() ?? [0, 0, 0, 0], haloSize: s12.haloSize ?? 0, lineWidth: s12.lineWidth, lineHeightRatio: s12.lineHeight, horizontalAlignment: V2, verticalAlignment: v, repeatLabel: u18, repeatLabelDistance: u4(c10), allowOverrun: n16, labelPosition: e12.labelPosition, scaleInfo: f6, minPixelBuffer: x2(r12), useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: s12.font.toJSON(), textString: s12.text, symbol: te.createCIMTextSymbolfromTextSymbol(s12), primitiveName: "label-override" }, useLegacyLabelEvaluationRules: null == e12.labelExpressionInfo?.expression, overrides: [{ valueExpressionInfo: { type: "CIMExpressionInfo", expression: e12.labelExpressionInfo?.expression ?? e12.labelExpression, returnType: "String" }, primitiveName: "label-override", propertyName: "textString", defaultValue: "" }] }, referenceSize: null, effects: null, placement: null, transforms: null, scaleFactor: 1, labelClassId: a9.labelClassId })];
}
function k(e12, i14) {
  const a9 = e12.width;
  return { outlineColor: e12.color?.toArray() || [0, 0, 0, 1], width: a9, referenceWidth: a9, capType: e12.cap ?? "round", joinType: e12.join ?? "round", miterLimit: e12.miterLimit, hasSizeVV: i14, outlineUsesColorVV: false };
}
function U(e12, i14) {
  const { uniforms: a9, schemaOptions: l10 } = i14, { store: r12 } = l10, t11 = e12.color?.toArray() ?? [0, 0, 0, 0], o19 = { type: "sprite-rasterization-param", resource: { type: "fill-style", style: e12.style }, overrides: [] };
  if ("solid" === e12.outline?.style) {
    return [r12.ensureInstance(F.patternOutlineFill, { uniforms: { visualVariableColor: a9.visualVariableColor, visualVariableOpacity: a9.visualVariableOpacity, visualVariableSizeScaleStops: a9.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, ...k(e12.outline, !!a9.visualVariableSizeOutlineScaleStops), sprite: o19, scaleInfo: null, effects: null })];
  }
  const s12 = [], n16 = r12.ensureInstance(F.patternFill, { uniforms: { visualVariableColor: a9.visualVariableColor, visualVariableOpacity: a9.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: e12.color?.toArray() ?? [0, 0, 0, 0], sprite: o19, scaleInfo: null, effects: null });
  return s12.push(n16), e12.outline && s12.push(...P2(e12.outline, i14, true)), s12;
}
function E3(e12, i14) {
  const { uniforms: a9, schemaOptions: l10 } = i14, { store: r12 } = l10, t11 = e12.color?.toArray() ?? [0, 0, 0, 0];
  if ("none" !== e12.style && "solid" === e12.outline?.style) {
    return [r12.ensureInstance(F.outlineFill, { uniforms: { visualVariableColor: a9.visualVariableColor, visualVariableOpacity: a9.visualVariableOpacity, visualVariableSizeScaleStops: a9.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, ...k(e12.outline, !!a9.visualVariableSizeOutlineScaleStops), scaleInfo: null, effects: null })];
  }
  const o19 = [];
  if ("none" !== e12.style) {
    const e13 = r12.ensureInstance(F.fill, { uniforms: { visualVariableColor: a9.visualVariableColor, visualVariableOpacity: a9.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, scaleInfo: null, effects: null });
    o19.push(e13);
  }
  return e12.outline && o19.push(...P2(e12.outline, i14, true)), o19;
}
async function j2(e12, i14) {
  if ("cim" === e12.type) return u8(e12.data, i14);
  const { style: a9 } = e12;
  return a9 && "none" !== a9 && "solid" !== a9 ? U(e12, i14) : E3(e12, i14);
}
function F2(e12, i14) {
  const { outline: a9 } = e12, { uniforms: l10, schemaOptions: r12 } = i14, { store: t11 } = r12, s12 = [], n16 = te.createPictureFillRasterizationParam(e12);
  if (!n16) return [];
  const { width: u18, height: c10, xoffset: p12, yoffset: f6, xscale: b4, yscale: S3 } = e12, V2 = { color: [255, 255, 255, 255], sprite: n16, height: c10, aspectRatio: u18 / c10, offsetX: p12, offsetY: f6, scaleX: b4, scaleY: S3, angle: 0, applyRandomOffset: false, sampleAlphaOnly: false, scaleProportionally: false, effects: null, scaleInfo: null };
  if ("solid" === a9?.style) {
    return [t11.ensureInstance(F.complexOutlineFill, { uniforms: { visualVariableColor: l10.visualVariableColor, visualVariableOpacity: l10.visualVariableOpacity, visualVariableSizeScaleStops: l10.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ ...V2, ...k(a9, !!l10.visualVariableSizeOutlineScaleStops) })];
  }
  const y4 = t11.ensureInstance(F.complexFill, { uniforms: { visualVariableColor: l10.visualVariableColor, visualVariableOpacity: l10.visualVariableOpacity }, optionalAttributes: { zoomRange: false } });
  return s12.push(y4.createMeshInfo(V2)), a9 && s12.push(...P2(a9, i14, true)), s12;
}
function P2(e12, i14, a9) {
  const { color: l10, style: r12, width: t11, cap: o19, join: n16 } = e12, { schemaOptions: u18 } = i14, { store: c10 } = u18, p12 = [], f6 = a9 ? { ...z2, visualVariableSizeScaleStops: i14.uniforms.visualVariableSizeOutlineScaleStops } : i14.uniforms, b4 = { uniforms: { visualVariableColor: f6.visualVariableColor, visualVariableOpacity: f6.visualVariableOpacity, visualVariableSizeMinMaxValue: f6.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: f6.visualVariableSizeScaleStops, visualVariableSizeStops: f6.visualVariableSizeStops, visualVariableSizeUnitValue: f6.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false } }, S3 = { color: l10?.toArray() ?? [0, 0, 0, 0], width: t11, referenceWidth: t11, capType: o19, joinType: n16, miterLimit: e12.miterLimit, hasSizeVV: e6(f6), effects: null, scaleInfo: null };
  if (null == r12 || "solid" === r12) {
    const e13 = c10.ensureInstance(F.line, b4).createMeshInfo(S3);
    p12.push(e13);
  } else if ("none" !== r12) {
    const e13 = c10.ensureInstance(F.texturedLine, b4).createMeshInfo({ ...S3, offsetAlongLine: 0, shouldScaleDash: true, shouldSampleAlphaOnly: false, isSDF: true, sprite: { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: fe(r12, o19) }, overrides: [] } });
    p12.push(e13);
  }
  return null != e12.marker && p12.push(...O(e12.marker, e12, i14)), p12;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/LabelMatcherSchema.js
async function o11(e12, a9, o19) {
  const r12 = a9.labelsVisible && a9.labelingInfo || [], i14 = e8(a9), t11 = c(r12, i14);
  return { type: "label", classes: await Promise.all(t11.map((s12, l10) => n8(e12, s12, a9.labelsVisible, a9.layerId, l10, i14, o19))) };
}
async function n8(s12, l10, o19, n16, r12, i14, t11) {
  const m16 = l(`${n16} ${r12}`), c10 = await g3(l10, { schemaOptions: s12, uniforms: t11, labelClassId: m16 });
  return { maxScale: l10.maxScale, minScale: l10.minScale, deconflictionEnabled: "none" !== l10.deconflictionStrategy && o19, expression: l10.labelExpressionInfo?.expression ?? l10.labelExpression, where: l10.where, meshes: c10, labelClassId: m16, geometryType: i14 };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/MatcherSchema.js
async function l9(e12, i14) {
  if (!i14) return { type: "simple", meshes: [] };
  switch (i14.type) {
    case "simple":
      return o12(e12, i14);
    case "dot-density":
      return r9(e12, i14);
    case "class-breaks":
      return u12(e12, i14);
    case "unique-value":
      return m9(e12, i14);
    case "dictionary":
      return c7(i14);
    case "heatmap":
      return p8(e12, i14);
    case "pie-chart":
      return f4(e12, i14);
  }
}
async function o12(i14, a9) {
  const n16 = a9.symbols, t11 = n16.length ? n16[0] : null, l10 = y(a9);
  return { type: "simple", meshes: await g3(t11, { schemaOptions: i14, uniforms: l10 }) };
}
async function r9(i14, a9) {
  const n16 = y(a9);
  return { type: "dot-density", meshes: await M2(a9, { schemaOptions: i14, uniforms: n16 }) };
}
async function u12(a9, n16) {
  const t11 = y(n16), l10 = n16.backgroundFillSymbol, o19 = n16.normalizationType, r12 = "log" === o19 ? "esriNormalizeByLog" : "percent-of-total" === o19 ? "esriNormalizeByPercentOfTotal" : "field" === o19 ? "esriNormalizeByField" : null, u18 = n16.classBreakInfos.map(async (e12) => ({ meshes: await g3(e12.symbol, { path: `renderer-stop-${e12.minValue}-${e12.maxValue}`, schemaOptions: a9, uniforms: t11 }), min: e12.minValue, max: e12.maxValue })), m16 = (await Promise.all(u18)).sort((e12, i14) => e12.min - i14.min), c10 = await g3(l10, { schemaOptions: a9, uniforms: { ...z2, visualVariableSizeOutlineScaleStops: t11.visualVariableSizeOutlineScaleStops } }), p12 = await g3(n16.defaultSymbol, { schemaOptions: a9, uniforms: t11 });
  return { type: "interval", field: n16.field, expression: n16.valueExpression, backgroundFill: c10, defaultSymbol: p12, intervals: m16, normalizationField: n16.normalizationField, normalizationTotal: n16.normalizationTotal, normalizationType: r12, isMaxInclusive: n16.isMaxInclusive };
}
async function m9(a9, n16) {
  const t11 = [], l10 = y(n16), o19 = await g3(n16.backgroundFillSymbol, { schemaOptions: a9, uniforms: { ...z2, visualVariableSizeOutlineScaleStops: l10.visualVariableSizeOutlineScaleStops } }), r12 = await g3(n16.defaultSymbol, { schemaOptions: a9, uniforms: l10 });
  for (const e12 of n16.uniqueValueInfos ?? []) {
    const i14 = await g3(e12.symbol, { path: `renderer-unique-value-${e12.value}`, schemaOptions: a9, uniforms: l10 });
    t11.push({ value: "" + e12.value, symbol: i14 });
  }
  return { type: "map", field: n16.field, expression: n16.valueExpression, field2: n16.field2, field3: n16.field3, fieldDelimiter: n16.fieldDelimiter, backgroundFill: o19, defaultSymbol: r12, map: t11 };
}
async function c7(i14) {
  const a9 = y(i14), n16 = await i14.getDictionaryInfo(), s12 = i14.scaleExpression, t11 = null != s12 && "1" !== s12 ? { valueExpressionInfo: { type: "CIMExpressionInfo", expression: i14.scaleExpression, returnType: "Numeric" }, defaultValue: 1 } : void 0;
  return { type: "dictionary", dictionaryInfo: n16, userConfig: i14.config ?? {}, fieldMap: i14.fieldMap ?? {}, scaleExpression: t11, visualVariableUniforms: a9 };
}
async function p8(e12, i14) {
  return { type: "heatmap", meshes: await C(i14, e12) };
}
async function f4(e12, i14) {
  return { type: "pie-chart", meshes: await x3(i14, e12) };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SimpleProcessorSchema.js
async function o13(e12, r12) {
  const t11 = r12.renderer, n16 = y(t11);
  return { symbology: await l9(e12, t11), labels: await o11(e12, r12, n16) };
}
async function u13(e12, r12, t11, s12) {
  const i14 = t11.featureReduction;
  if (i14) switch (i14.type) {
    case "binning":
      return f5(i14, e12, r12, t11, s12);
    case "cluster":
      return p9(i14, e12, r12, t11, s12);
  }
  if (t11.trackInfo?.enabled) return d6(t11.trackInfo, e12, r12, t11, s12);
  const a9 = b3(t11.orderBy, t11.renderer, t11.objectIdField), l10 = a7(t11.renderer, r12.filters), u18 = await o13(e12, t11), c10 = g4(u18.symbology);
  return { storage: l10, mesh: { properties: { sortKey: a9, timeZone: r12.timeZone, returnMeshObjectId: c10, displayRefreshVersion: s12, currentUser: r12.currentUser }, strategy: { type: "feature" }, factory: u18 }, expressionProperties: { timeExtent: r12.timeExtent?.toJSON() } };
}
function c8(e12, r12) {
  return e12.fields.map((e13) => ({ ...e13.toJSON(), type: y2(e13, r12) }));
}
function y2(e12, r12) {
  const { onStatisticExpression: t11, onStatisticField: s12, statisticType: i14 } = e12;
  switch (i14) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (t11) {
        const { returnType: e14 } = t11;
        return e14 ? "string" === e14 ? "esriFieldTypeString" : "esriFieldTypeDouble" : "esriFieldTypeString";
      }
      const e13 = r12.find((e14) => e14.name === s12);
      return e13 ? e13.type : "esriFieldTypeString";
    }
  }
}
async function f5(r12, t11, a9, o19, u18) {
  const y4 = c8(r12, o19.fields), f6 = r12.renderer, p12 = await l9(t11, f6), d9 = a7(f6, [null, null]), b4 = y(f6), m16 = await o11(t11, { geometryType: "polygon", layerId: o19.layerId, labelingInfo: r12.labelingInfo, labelsVisible: r12.labelsVisible }, b4), v = g4(p12), h4 = "geohash" === r12.binType ? { type: "geohash", fixBinLevel: r12.fixedBinLevel ?? 3 } : { type: "grid", size: u4(r12.size), fixedBinLevel: r12.fixedBinLevel };
  return { storage: d9, mesh: { properties: { sortKey: null, timeZone: a9.timeZone, returnMeshObjectId: v, displayRefreshVersion: u18, currentUser: a9.currentUser }, strategy: { type: "binning", fields: y4, index: h4, featureFilter: a9.filters[0] }, factory: { labels: m16, symbology: p12 } }, expressionProperties: { timeExtent: a9.timeExtent?.toJSON() } };
}
async function p9(r12, t11, a9, o19, u18) {
  const y4 = c8(r12, o19.fields), f6 = { type: "cluster", feature: await l9(t11, r12.effectiveFeatureRenderer), cluster: await l9(t11, r12.effectiveClusterRenderer) }, p12 = y(r12.effectiveFeatureRenderer), d9 = { type: "cluster", feature: await o11(t11, o19, p12), cluster: await o11(t11, { geometryType: "point", layerId: o19.layerId, labelingInfo: r12.labelingInfo, labelsVisible: r12.labelsVisible }, p12) }, b4 = a7(r12.effectiveFeatureRenderer, [null, null]), m16 = g4(f6);
  return { storage: b4, mesh: { properties: { sortKey: null, timeZone: a9.timeZone, displayRefreshVersion: u18, returnMeshObjectId: m16, currentUser: a9.currentUser }, strategy: { type: "cluster", fields: y4, featureFilter: a9.filters[0], clusterRadius: u4(r12.clusterRadius / 2) }, factory: { labels: d9, symbology: f6 } }, expressionProperties: { timeExtent: a9.timeExtent?.toJSON() } };
}
async function d6(e12, r12, t11, n16, o19) {
  const u18 = c8(e12, n16.fields), y4 = { type: "track", previousObservation: await l9(r12, e12.previousObservations.renderer), latestObservation: await l9(r12, e12.latestObservations.renderer), trackLine: await l9(r12, e12.trackLines.renderer) }, f6 = { type: "track", previousObservation: await o11(r12, { geometryType: n16.geometryType, layerId: n16.layerId, labelingInfo: e12.previousObservations.labelingInfo, labelsVisible: e12.previousObservations.labelsVisible }, y(e12.previousObservations.renderer)), latestObservation: await o11(r12, { geometryType: n16.geometryType, layerId: n16.layerId, labelingInfo: e12.latestObservations.labelingInfo, labelsVisible: e12.latestObservations.labelsVisible }, y(e12.latestObservations.renderer)), trackLine: await o11(r12, { geometryType: "polyline", layerId: n16.layerId, labelingInfo: e12.trackLines.labelingInfo, labelsVisible: e12.trackLines.labelsVisible }, y(e12.trackLines.renderer)) }, p12 = o7(e12, [null, null]), d9 = g4(y4);
  return { storage: p12, mesh: { properties: { sortKey: null, timeZone: t11.timeZone, returnMeshObjectId: d9, displayRefreshVersion: o19, currentUser: t11.currentUser }, strategy: { type: "track", featureFilter: t11.filters[0], fields: u18, maxDisplayDuration: e12.maxDisplayDuration?.toMilliseconds() ?? 0, maxDisplayObservationsPerTrack: e12.maxDisplayObservationsPerTrack, showLatestObservation: e12.latestObservations.visible, showPreviousObservations: e12.previousObservations.visible, showTrackLine: e12.trackLines.visible, timeField: e12.timeField }, factory: { labels: f6, symbology: y4 } }, expressionProperties: { timeExtent: t11.timeExtent?.toJSON() } };
}
function b3(e12, t11, s12) {
  const i14 = null != t11 && "unique-value" === t11.type && t11.orderByClassesEnabled;
  if ("default" !== e12 || i14 || (e12 = [new n2({ field: s12, order: "descending" })]), "default" !== e12 && e12?.length) {
    e12.length;
    const r12 = e12[0], t12 = "ascending" === r12.order ? "asc" : "desc";
    return r12.field ? { field: r12.field, order: t12 } : r12.valueExpression ? { expression: r12.valueExpression, order: t12 } : null;
  }
  if (i14) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}
function m10(e12) {
  return e12.techniqueType === e4.AnimatedMarker;
}
function g4(e12) {
  if ("simple" === e12.type && e12.meshes.some(m10)) return true;
  if ("interval" === e12.type) {
    if (e12.intervals.some((e13) => e13.meshes.some(m10))) return true;
    if (e12.backgroundFill.some(m10)) return true;
  }
  if ("map" === e12.type) {
    if (e12.map.some((e13) => e13.symbol.some(m10))) return true;
    if (e12.backgroundFill.some(m10)) return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/CatalogFootprintLayerAdapter.js
var n9 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const t11 = this.layer, r12 = l8(t11);
    return [{ vvEvaluators: { 0: o10(t11.renderer) }, deconflictionEnabled: r12 }];
  }
  async createServiceOptions(o19) {
    const i14 = this.layer, { capabilities: s12, editingInfo: a9, objectIdField: l10, globalIdField: n16, datesInUnknownTimezone: p12, dateFieldsTimeZone: d9, orderBy: u18, parsedUrl: c10 } = i14, y4 = i14.fieldsIndex.toJSON(), m16 = e8(i14), f6 = i14.timeInfo?.toJSON(), h4 = i14.spatialReference.toJSON(), g5 = a(c10);
    let I3 = l10;
    if (u18?.length) {
      const e12 = !u18[0].valueExpression && u18[0].field;
      e12 && (I3 = e12);
    }
    const b4 = g(g5.path), F3 = o19.spatialReference.toJSON();
    return { type: "feature-service", source: g5, isSourceHosted: b4, orderByFields: I3, outSpatialReference: F3, metadata: { timeReferenceUnknownClient: p12, dateFieldsTimeZone: d9, globalIdField: n16, fieldsIndex: y4, geometryType: m16, featureIdInfo: { type: "object-id", fieldName: l10 }, timeInfo: f6, spatialReference: h4, outSpatialReference: F3, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: s12.query.maxRecordCount, supportsCompactGeometry: s12.query.supportsCompactGeometry, supportsDefaultSpatialReference: s12.query.supportsDefaultSpatialReference, supportsFormatPBF: s12.query.supportsFormatPBF, supportsMaxRecordCountFactor: s12.query.supportsMaxRecordCountFactor, supportsQuantization: s12.query.supportsQuantization, lastEditDate: a9?.lastEditDate?.getTime(), snapshotInfo: null } };
  }
  createSourceSchema(e12, t11) {
    const { definitionExpression: r12, displayFilterInfo: o19, customParameters: i14, timeExtent: a9, apiKey: l10 } = this.layer;
    return t8({ definitionExpression: r12, displayFilterInfo: o19, customParameters: i14, timeExtent: a9 }, e12, t11, l10);
  }
  createProcessorSchema(e12, t11, r12) {
    const { fields: o19, geometryType: i14, orderBy: s12, objectIdField: l10, renderer: n16, labelingInfo: p12, labelsVisible: d9 } = this.layer, u18 = { featureReduction: null, layerId: this.layer.id, fields: o19.map((e13) => e13.toJSON()), geometryType: i14, labelingInfo: p12, labelsVisible: d9, objectIdField: l10, orderBy: s12 ?? "default", renderer: n16?.clone() };
    return u13(e12, t11, u18, r12);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => this.layer.outFields, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy];
  }
  setGraphicOrigin(e12) {
    e12.origin = { type: "catalog", layer: this.layer };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureServiceUtils.js
function e9(e12) {
  const { objectIdField: t11, uniqueIdFields: r12 } = e12;
  return r12?.length ? r12.length >= 2 ? { type: "unique-id-composite", fieldNames: r12 } : { type: "unique-id-simple", fieldName: r12[0] } : { type: "object-id", fieldName: t11 };
}
function t9(e12, t11, s12, a9, l10, u18) {
  const m16 = o14(a9);
  if (!(!!has("featurelayer-snapshot-enabled") && s12?.query.supportsPagination && !s12?.operations.supportsEditing && !t11)) return null;
  const h4 = i10(l10, u18), { min: p12, max: c10 } = m16, y4 = h4 ? c10 : p12, d9 = n10(a9);
  let f6 = has("featurelayer-snapshot-initial-tolerance");
  return "esriGeometryPoint" !== a9 && "esriGeometryMultipoint" !== a9 || (f6 = null), { supportsExceedsLimit: r10(e12, s12), initialTolerance: f6, maxFeatureCount: y4, maxVertexCount: d9 };
}
function r10(e12, t11) {
  return !(!e12 && !has("featurelayer-snapshot-non-hosted-exceedslimit-enabled")) && t11?.operations.supportsExceedsLimitStatistics;
}
function n10(e12) {
  switch (e12) {
    case "esriGeometryPoint":
      return null;
    case "esriGeometryPolyline":
    case "esriGeometryPolygon":
    case "esriGeometryMultiPatch":
    case "esriGeometryMultipoint":
      return has("featurelayer-snapshot-max-vertex-count");
  }
}
function i10(e12, t11) {
  const r12 = t11?.clone().intersection(e12), n16 = null != r12 ? r12.width * r12.height : 0, i14 = t11 ? t11.width * t11.height : 0, o19 = 0 === i14 ? 0 : n16 / i14, s12 = has("featurelayer-snapshot-coverage");
  return !isNaN(o19) && o19 >= s12;
}
function o14(e12) {
  switch (e12) {
    case "esriGeometryMultipoint":
      return { min: has("featurelayer-snapshot-multipoint-min-threshold"), max: has("featurelayer-snapshot-multipoint-max-threshold") };
    case "esriGeometryPoint":
      return { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") };
    case "esriGeometryMultiPatch":
    case "esriGeometryPolygon":
      return { min: has("featurelayer-snapshot-polygon-min-threshold"), max: has("featurelayer-snapshot-polygon-max-threshold") };
    case "esriGeometryPolyline":
      return { min: has("featurelayer-snapshot-polyline-min-threshold"), max: has("featurelayer-snapshot-polyline-max-threshold") };
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/floorFilterUtils.js
function o15(e12, l10) {
  return null != e12.floorInfo && (e12.floorInfo.viewAllLevelIds.length > 0 || l10.floors.length > 0);
}
function r11(e12, o19, r12) {
  const t11 = n11(e12, o19?.where, r12);
  return t11 ? (o19 ??= new d3(), o19.where = t11, o19) : o19;
}
function n11(l10, o19, r12) {
  if (null == l10.floorInfo || !r12.floors?.length) return o19;
  let n16 = r12.floors;
  const { floorField: t11, viewAllLevelIds: f6 } = l10.floorInfo;
  f6.length && (n16 = f6);
  const s12 = n16.filter((e12) => "" !== e12).map((e12) => "'" + e12 + "'");
  if (s12.push("''"), o19?.includes(t11)) {
    let e12 = new RegExp("AND \\(" + t11 + ".*NULL\\)", "g");
    o19 = o19.replace(e12, ""), e12 = new RegExp("\\(" + t11 + ".*NULL\\)", "g"), o19 = (o19 = o19.replace(e12, "")).replaceAll(/\s+/g, " ").trim();
  }
  let i14 = "(" + t11 + " IN ({ids}) OR " + t11 + " IS NULL)";
  return i14 = i14.replace("{ids}", s12.join(", ")), r3(o19, i14);
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/FeatureLayerAdapter.js
var m11 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const t11 = this.layer, i14 = r8(t11, e12) ?? l8(t11), s12 = e7(t11, e12), o19 = [...t11.labelingInfo || [], ...s12?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o10(t11.renderer) }, deconflictionEnabled: i14, labelingInfo: o19 }];
  }
  async createServiceOptions(r12) {
    const o19 = this.layer, { capabilities: a9, editingInfo: n16, typeIdField: p12, globalIdField: d9, datesInUnknownTimezone: y4, dateFieldsTimeZone: u18, orderBy: c10, subtypeField: m16, refreshInterval: f6 } = o19, h4 = o19.fieldsIndex.toJSON(), b4 = e8(o19), I3 = o19.timeInfo?.toJSON(), g5 = o19.spatialReference.toJSON(), F3 = o19.types?.map((e12) => e12.toJSON()), S3 = a(this.layer.parsedUrl);
    this.layer.dynamicDataSource && (S3.query = { layer: JSON.stringify({ source: this.layer.dynamicDataSource }) });
    let x4 = this.layer.objectIdField;
    if (c10?.length) {
      const e12 = !c10[0].valueExpression && c10[0].field;
      e12 && (x4 = e12);
    }
    const R6 = g(S3.path), j3 = t9(R6, !(null != n16?.lastEditDate) && f6 > 0, a9, b4, r12.extent, o19.fullExtent), E4 = r12.spatialReference.toJSON();
    return { type: "feature-service", source: S3, isSourceHosted: R6, orderByFields: x4, outSpatialReference: E4, metadata: { typeIdField: p12 ?? void 0, types: F3, timeReferenceUnknownClient: y4, dateFieldsTimeZone: u18, subtypeField: m16, globalIdField: d9, fieldsIndex: h4, geometryType: b4, featureIdInfo: e9(o19), timeInfo: I3, spatialReference: g5, outSpatialReference: E4, subtypes: this.layer.subtypes?.map((e12) => e12.toJSON()) }, queryMetadata: { maxRecordCount: a9.query.maxRecordCount, supportsCompactGeometry: a9.query.supportsCompactGeometry, supportsDefaultSpatialReference: a9.query.supportsDefaultSpatialReference, supportsFormatPBF: a9.query.supportsFormatPBF, supportsMaxRecordCountFactor: a9.query.supportsMaxRecordCountFactor, supportsQuantization: a9.query.supportsQuantization, lastEditDate: n16?.lastEditDate?.getTime(), snapshotInfo: j3 } };
  }
  createSourceSchema(e12, t11) {
    const { apiKey: r12, definitionExpression: i14, displayFilterInfo: s12, customParameters: o19, gdbVersion: a9, historicMoment: l10, subtypeCode: n16, subtypeField: p12, timeExtent: d9 } = this.layer;
    return t8({ definitionExpression: i14, displayFilterInfo: s12, customParameters: o19, gdbVersion: a9, historicMoment: l10, subtypeCode: n16, subtypeField: p12, timeExtent: d9 }, e12, t11, r12);
  }
  createProcessorSchema(e12, t11, i14) {
    const { fields: s12, renderer: o19, geometryType: a9, labelingInfo: l10, labelsVisible: n16, orderBy: p12, objectIdField: d9, trackInfo: y4 } = this.layer, c10 = { fields: s12.map((e13) => e13.toJSON()), renderer: o19?.clone(), layerId: this.layer.id, featureReduction: e7(this.layer, t11), geometryType: a9, labelingInfo: l10, labelsVisible: n16, objectIdField: d9, orderBy: p12 ?? "default", trackInfo: y4 };
    return u13(e12, t11, c10, i14);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  addFilters(e12, t11) {
    return r11(this.layer, e12, t11);
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => e7(this.layer, e12), () => o15(this.layer, e12) ? e12.floors : null, () => this.layer.gdbVersion, () => this.layer.historicMoment, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy, () => this.layer.outFields, () => this.layer.renderer, () => this.layer.subtypeCode, () => this.layer.trackInfo];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/InMemoryLayerAdapter.js
function u14(t11) {
  if (!("openPorts" in t11)) throw new s("featurelayer:source-not-supported", "source is not supported");
}
var p10 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const r12 = this.layer, l10 = r8(r12, e12) ?? l8(r12), s12 = e7(r12, e12), a9 = [...r12.labelingInfo || [], ...s12?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o10(r12.renderer) }, deconflictionEnabled: l10, labelingInfo: a9 }];
  }
  async createServiceOptions(e12) {
    const t11 = this.layer, { capabilities: o19, objectIdField: i14 } = t11, n16 = t11.fieldsIndex.toJSON(), l10 = e8(t11), s12 = t11.timeInfo?.toJSON(), a9 = t11.spatialReference.toJSON();
    u14(t11.source);
    const p12 = await t11.source.openPorts(), d9 = i14, c10 = e12.spatialReference.toJSON();
    return { type: "memory", source: p12, orderByFields: d9, outSpatialReference: c10, metadata: { fieldsIndex: n16, geometryType: l10, featureIdInfo: { type: "object-id", fieldName: t11.objectIdField }, timeInfo: s12, spatialReference: a9, outSpatialReference: c10, subtypes: null, subtypeField: null, globalIdField: null, typeIdField: null, types: null, timeReferenceUnknownClient: "datesInUnknownTimezone" in t11 ? t11.datesInUnknownTimezone : null, dateFieldsTimeZone: "dateFieldsTimeZone" in t11 ? t11.dateFieldsTimeZone : null }, queryMetadata: { maxRecordCount: o19.query.maxRecordCount, supportsCompactGeometry: o19.query.supportsCompactGeometry, supportsDefaultSpatialReference: o19.query.supportsDefaultSpatialReference, supportsFormatPBF: o19.query.supportsFormatPBF, supportsMaxRecordCountFactor: o19.query.supportsMaxRecordCountFactor, supportsQuantization: o19.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e12, t11) {
    const { definitionExpression: r12, timeExtent: o19, displayFilterInfo: i14 } = this.layer;
    return t8({ customParameters: null, definitionExpression: r12, displayFilterInfo: i14, timeExtent: o19 }, e12, t11, null);
  }
  createProcessorSchema(e12, r12, o19) {
    const { fields: i14, renderer: n16, geometryType: l10, labelingInfo: a9, labelsVisible: u18, orderBy: p12, objectIdField: d9 } = this.layer, c10 = "trackInfo" in this.layer ? this.layer.trackInfo : null, y4 = { fields: i14.map((e13) => e13.toJSON()), renderer: n16?.clone(), layerId: this.layer.id, featureReduction: e7(this.layer, r12), geometryType: l10, labelingInfo: a9, labelsVisible: u18, objectIdField: d9, orderBy: p12 ?? "default", trackInfo: c10 };
    return u13(e12, r12, y4, o19);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.definitionExpression, () => this.layer.displayFilterInfo, () => this.layer.orderBy, () => "outFields" in this.layer ? this.layer.outFields : null, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e7(this.layer, e12), () => "trackInfo" in this.layer ? this.layer.trackInfo : null];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/KnowledgeGraphSublayerAdapter.js
var c9 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const r12 = this.layer, t11 = r8(r12, e12) ?? l8(r12);
    return [{ vvEvaluators: { 0: o10(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(e12) {
    const r12 = this.layer, { capabilities: t11, objectIdField: o19 } = r12, i14 = r12.fieldsIndex.toJSON(), a9 = e8(r12), l10 = r12.spatialReference.toJSON(), n16 = await r12.source.openPorts(), p12 = o19, u18 = e12.spatialReference.toJSON();
    return { type: "memory", source: n16, orderByFields: p12, outSpatialReference: u18, metadata: { fieldsIndex: i14, geometryType: a9, featureIdInfo: { type: "object-id", fieldName: r12.objectIdField }, spatialReference: l10, outSpatialReference: u18, globalIdField: null, subtypeField: null, subtypes: null, timeInfo: r12.timeInfo?.toJSON(), timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: t11.query.maxRecordCount, supportsCompactGeometry: t11.query.supportsCompactGeometry, supportsDefaultSpatialReference: t11.query.supportsDefaultSpatialReference, supportsFormatPBF: t11.query.supportsFormatPBF, supportsMaxRecordCountFactor: t11.query.supportsMaxRecordCountFactor, supportsQuantization: t11.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e12, r12) {
    const { definitionExpression: t11, displayFilterInfo: o19 } = this.layer;
    return t8({ definitionExpression: t11, displayFilterInfo: o19, customParameters: null }, e12, r12, null);
  }
  createProcessorSchema(e12, r12, t11) {
    const { fields: s12, renderer: i14, geometryType: a9, labelingInfo: l10, labelsVisible: n16, objectIdField: u18 } = this.layer, c10 = { fields: s12.map((e13) => e13.toJSON()), renderer: i14?.clone(), layerId: this.layer.id, featureReduction: e7(this.layer, r12), geometryType: a9, labelingInfo: l10, labelsVisible: n16, objectIdField: u18, orderBy: "default" };
    return u13(e12, r12, c10, t11);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e7(this.layer, e12), () => d7(this.layer)];
  }
  hasFilters(e12) {
    return d7(this.layer);
  }
  addFilters(o19, s12) {
    if (d7(this.layer)) {
      const s13 = r3(o19?.where, `${E}=1`);
      if (!s13) return o19;
      o19 ??= new d3(), o19.where = s13;
    }
    return o19;
  }
};
function d7(e12) {
  return "link-chart" === e12.parentCompositeLayer.type && "hidden" === e12.parentCompositeLayer.linkChart?.linkChartProperties.nonspatialDataDisplay?.mode;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OGCFeatureLayerAdapter.js
var u15 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const t11 = this.layer, r12 = r8(t11, e12) ?? l8(t11);
    return [{ vvEvaluators: { 0: o10(t11.renderer) }, deconflictionEnabled: r12, labelingInfo: t11.labelingInfo }];
  }
  async createServiceOptions(t11) {
    const o19 = this.layer, { capabilities: a9 } = o19, s12 = o19.fieldsIndex.toJSON(), l10 = e8(o19), i14 = o19.timeInfo?.toJSON(), n16 = o19.spatialReference.toJSON(), u18 = o19.source.getSource(), c10 = this.layer.objectIdField, p12 = a(a9);
    p12.query.maxRecordCount = u18.maxRecordCount;
    const d9 = t11.spatialReference.toJSON();
    return { type: "ogc", source: u18, orderByFields: c10, outSpatialReference: d9, metadata: { fieldsIndex: s12, geometryType: l10, featureIdInfo: { type: "object-id", fieldName: o19.objectIdField }, timeInfo: i14, spatialReference: n16, outSpatialReference: d9, globalIdField: null, subtypeField: null, subtypes: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: p12.query.maxRecordCount, supportsCompactGeometry: p12.query.supportsCompactGeometry, supportsDefaultSpatialReference: p12.query.supportsDefaultSpatialReference, supportsFormatPBF: p12.query.supportsFormatPBF, supportsMaxRecordCountFactor: p12.query.supportsMaxRecordCountFactor, supportsQuantization: p12.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e12, t11) {
    const { customParameters: r12, timeExtent: o19, apiKey: a9 } = this.layer;
    return t8({ customParameters: r12, timeExtent: o19 }, e12, t11, a9);
  }
  createProcessorSchema(e12, r12, o19) {
    const { fields: a9, renderer: s12, geometryType: l10, labelingInfo: n16, labelsVisible: u18, orderBy: c10, objectIdField: p12 } = this.layer, d9 = { fields: a9.map((e13) => e13.toJSON()), renderer: s12?.clone(), layerId: this.layer.id, featureReduction: e7(this.layer, r12), geometryType: l10, labelingInfo: n16, labelsVisible: u18, objectIdField: p12, orderBy: c10 ?? "default" };
    return u13(e12, r12, d9, o19);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => e7(this.layer, e12), () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy, () => this.layer.renderer];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OrientedImageryLayerAdapter.js
var m12 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const r12 = this.layer, t11 = r8(r12, e12) ?? l8(r12);
    return [{ vvEvaluators: { 0: o10(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(t11) {
    const s12 = this.layer, { capabilities: i14, globalIdField: a9, orderBy: n16, refreshInterval: p12 } = s12, u18 = s12.fieldsIndex.toJSON(), d9 = e8(s12), c10 = s12.timeInfo?.toJSON(), m16 = s12.spatialReference.toJSON(), y4 = a(this.layer.parsedUrl);
    let f6 = this.layer.objectIdField;
    if (n16?.length) {
      const e12 = !n16[0].valueExpression && n16[0].field;
      e12 && (f6 = e12);
    }
    const h4 = p12 > 0, I3 = g(y4.path), b4 = t11.spatialReference.toJSON(), F3 = t9(I3, h4, i14, d9, t11.extent, s12.fullExtent);
    return { type: "feature-service", source: y4, isSourceHosted: I3, orderByFields: f6, outSpatialReference: b4, metadata: { globalIdField: a9, fieldsIndex: u18, geometryType: d9, featureIdInfo: { type: "object-id", fieldName: s12.objectIdField }, timeInfo: c10, spatialReference: m16, outSpatialReference: b4, timeReferenceUnknownClient: s12.datesInUnknownTimezone, dateFieldsTimeZone: s12.dateFieldsTimeZone, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: i14.query.maxRecordCount, supportsCompactGeometry: i14.query.supportsCompactGeometry, supportsDefaultSpatialReference: i14.query.supportsDefaultSpatialReference, supportsFormatPBF: i14.query.supportsFormatPBF, supportsMaxRecordCountFactor: i14.query.supportsMaxRecordCountFactor, supportsQuantization: i14.query.supportsQuantization, lastEditDate: null, snapshotInfo: F3 } };
  }
  createSourceSchema(e12, r12) {
    const { definitionExpression: t11, displayFilterInfo: o19, customParameters: s12, timeExtent: i14 } = this.layer;
    return t8({ definitionExpression: t11, displayFilterInfo: o19, customParameters: s12, timeExtent: i14 }, e12, r12, null);
  }
  createProcessorSchema(e12, r12, o19) {
    const { fields: s12, renderer: i14, geometryType: l10, labelingInfo: a9, labelsVisible: n16, orderBy: p12, objectIdField: u18 } = this.layer, c10 = { fields: s12.map((e13) => e13.toJSON()), renderer: i14?.clone(), layerId: this.layer.id, featureReduction: e7(this.layer, r12), geometryType: l10, labelingInfo: a9, labelsVisible: n16, objectIdField: u18, orderBy: p12 ?? "default" };
    return u13(e12, r12, c10, o19);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  addFilters(e12, r12) {
    return r11(this.layer, e12, r12);
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.outFields, () => this.layer.orderBy, () => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e7(this.layer, e12), () => this.layer.customParameters, () => o15(this.layer, e12) ? e12.floors : null];
  }
};

// node_modules/@arcgis/core/layers/support/ParquetEncodingLocation.js
var s9 = class extends l2 {
  constructor(o19) {
    super(o19), this.type = "location", this.latitudeFieldName = null, this.longitudeFieldName = null;
  }
};
r([m({ type: ["location"], readOnly: true, json: { write: true } })], s9.prototype, "type", void 0), r([m({ json: { write: true } })], s9.prototype, "latitudeFieldName", void 0), r([m({ json: { write: true } })], s9.prototype, "longitudeFieldName", void 0), s9 = r([a2("esri.layers.support.ParquetEncodingLocation")], s9);

// node_modules/@arcgis/core/layers/support/ParquetEncodingWkb.js
var s10 = class extends l2 {
  constructor(o19) {
    super(o19), this.type = "wkb", this.primaryFieldName = null;
  }
};
r([m({ type: ["wkb"], readOnly: true, json: { write: true } })], s10.prototype, "type", void 0), r([m({ json: { write: true } })], s10.prototype, "multiscale", void 0), r([m({ json: { write: true } })], s10.prototype, "orientation", void 0), r([m({ json: { write: true } })], s10.prototype, "primaryFieldName", void 0), s10 = r([a2("esri.layers.support.ParquetEncodingWkb")], s10);

// node_modules/@arcgis/core/layers/support/parquetUtils.js
var u16 = new o2({ esriGeometryPoint: "point", esriGeometryPolygon: "polygon", esriGeometryPolyline: "polyline", esriGeometryMultipoint: "multipoint" });
function m14(e12) {
  return u16.toJSON(e12);
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/ParquetLayerAdapter.js
var y3 = class {
  constructor(e12) {
    this.layer = e12;
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return null;
  }
  getLabelingDeconflictionInfo(e12) {
    const r12 = this.layer, l10 = r8(r12, e12) ?? l8(r12), o19 = e7(r12, e12), n16 = [...r12.labelingInfo || [], ...o19?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o10(r12.renderer) }, deconflictionEnabled: l10, labelingInfo: n16 }];
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.outFields, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e7(this.layer, e12), () => this.layer.customParameters, () => this.layer.orderBy, () => this.layer.renderer, () => this.layer.popupTemplate];
  }
  async createServiceOptions(t11) {
    const a9 = e8(this.layer), i14 = t11.spatialReference.toJSON(), s12 = this.layer.encoding;
    if (null == s12) throw new s("parquet-layer:unsupported", "creating a parquet layer view requires an encoding", { layer: this.layer });
    return { type: "parquet", source: { urls: this.layer.urls.items }, outSpatialReference: i14, geometryInfo: { geometryType: m14(this.layer.geometryType), spatialReference: this.layer.spatialReference.toJSON(), encoding: s12.toJSON() }, metadata: { spatialReference: this.layer.spatialReference, outSpatialReference: i14, fieldsIndex: this.layer.fieldsIndex.toJSON(), featureIdInfo: { type: "object-id", fieldName: this.layer.objectIdField }, geometryType: a9, types: null, subtypes: null, timeInfo: null, typeIdField: null, subtypeField: null, globalIdField: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null } };
  }
  createSourceSchema(e12, r12) {
    return { type: "parquet", mutable: { sourceRefreshVersion: r12, availableFields: e12.availableFields.includes("*") ? this.layer.fields.map((e13) => e13.name) : e12.availableFields, dataFilter: { customParameters: this.layer.customParameters ?? null } } };
  }
  createProcessorSchema(e12, r12, l10) {
    const a9 = { fields: this.layer.fields.map((e13) => e13.toJSON()), renderer: this.layer.renderer?.clone(), layerId: this.layer.id, featureReduction: e7(this.layer, r12), geometryType: this.layer.geometryType, labelingInfo: this.layer.labelingInfo, labelsVisible: this.layer.labelsVisible, objectIdField: this.layer.objectIdField, orderBy: this.layer.orderBy };
    return u13(e12, r12, a9, l10);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/StreamLayerAdapter.js
var o17 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(t11) {
    const n16 = this.layer, a9 = r8(n16, t11) ?? l8(n16), o19 = e7(n16, t11), s12 = [...n16.labelingInfo || [], ...o19?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o10(n16.renderer) }, deconflictionEnabled: a9, labelingInfo: s12 }];
  }
  async createServiceOptions(e12) {
    const r12 = this.layer, i14 = e8(r12), l10 = r12.timeInfo?.toJSON() || null, n16 = r12.spatialReference ? r12.spatialReference.toJSON() : null, a9 = e12.spatialReference.toJSON();
    return { type: "stream", source: this.layer.parsedUrl, outSpatialReference: a9, metadata: { fieldsIndex: this.layer.fieldsIndex.toJSON(), geometryType: i14, featureIdInfo: { type: "object-id", fieldName: this.layer.objectIdField }, timeInfo: l10, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, spatialReference: n16, outSpatialReference: a9, subtypeField: null, subtypes: null, globalIdField: null, typeIdField: null, types: null } };
  }
  createSourceSchema(e12, t11) {
    const { definitionExpression: r12, geometryDefinition: i14, customParameters: l10 } = this.layer;
    return { type: "stream", mutable: { sourceRefreshVersion: t11, availableFields: e12.availableFields, dataFilter: { geometryDefinition: i14?.toJSON(), definitionExpression: r12, customParameters: l10 ?? null, maxReconnectionAttempts: this.layer.maxReconnectionAttempts, maxReconnectionInterval: this.layer.maxReconnectionInterval, purgeOptions: this.layer.purgeOptions.toJSON() } } };
  }
  createProcessorSchema(t11, r12, i14) {
    const { fields: l10, renderer: a9, geometryType: o19, labelingInfo: s12, labelsVisible: c10, objectIdField: d9, trackInfo: m16 } = this.layer, f6 = { fields: l10.map((e12) => e12.toJSON()), renderer: a9?.clone(), layerId: this.layer.id, featureReduction: e7(this.layer, r12), geometryType: o19, labelingInfo: s12, labelsVisible: c10, objectIdField: d9, orderBy: "default", trackInfo: m16 };
    return u13(t11, r12, f6, i14);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(t11) {
    return [() => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e7(this.layer, t11), () => this.layer.customParameters, () => this.layer.geometryDefinition, () => this.layer.definitionExpression, () => this.layer.trackInfo];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SubtypeProcessorSchema.js
async function i12(e12, { subtypeField: t11, sublayers: s12 }) {
  const a9 = await Promise.all(s12.map(({ renderer: t12 }) => l9(e12, t12)));
  return { type: "subtype", subtypeField: t11, renderers: s12.reduce((e13, { subtypeCode: r12 }, t12) => ({ ...e13, [r12]: a9[t12] }), {}) };
}
function n13(e12, r12) {
  const s12 = t2();
  return { type: "multi", filters: e12.filters, capabilities: { maxTextureSize: s12.maxTextureSize }, keyField: r12.subtypeField, target: "feature", bindings: r12.sublayers.reduce((e13, { renderer: r13, subtypeCode: s13 }) => {
    const a9 = d4(r13);
    return { ...e13, [s13]: a9 };
  }, {}) };
}
async function o18(r12, { subtypeField: t11, sublayers: a9, layerId: i14 }) {
  const n16 = await Promise.all(a9.map((t12) => {
    const a10 = y(t12.renderer), n17 = { ...t12, geometryType: t12.geometryType ?? null, layerId: i14 };
    return o11(r12, n17, a10);
  }));
  return { type: "subtype", subtypeField: t11, renderers: a9.reduce((e12, { subtypeCode: r13 }, t12) => ({ ...e12, [r13]: n16[t12] }), {}) };
}
async function u17(e12, r12, t11, s12) {
  return { storage: n13(r12, t11), mesh: { properties: { timeZone: r12.timeZone, displayRefreshVersion: s12, returnMeshObjectId: false, sortKey: null, currentUser: r12.currentUser }, strategy: { type: "feature" }, factory: { symbology: await i12(e12, t11), labels: await o18(e12, t11) } }, expressionProperties: { timeExtent: r12.timeExtent?.toJSON() } };
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/SubtypeGroupLayerAdapter.js
var m15 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const t11 = this.layer;
    return [{ vvEvaluators: {}, deconflictionEnabled: t11.sublayers.some((e13) => l8(e13)), labelingInfo: t11.sublayers.toArray().filter((e13) => !!e13.labelingInfo).flatMap((e13) => e13.labelingInfo) }];
  }
  async createServiceOptions(t11) {
    const r12 = this.layer, { capabilities: a9, datesInUnknownTimezone: o19, dateFieldsTimeZone: n16, editingInfo: p12, globalIdField: y4, objectIdField: c10, refreshInterval: m16, subtypeField: d9 } = r12, f6 = r12.fieldsIndex.toJSON(), b4 = e8(r12), h4 = r12.timeInfo?.toJSON(), S3 = r12.spatialReference.toJSON(), g5 = a(this.layer.parsedUrl), F3 = c10, I3 = !(null != p12?.lastEditDate) && m16 > 0, x4 = g(g5.path), R6 = t11.spatialReference.toJSON(), j3 = t9(x4, I3, a9, b4, t11.extent, r12.fullExtent);
    return { type: "feature-service", source: g5, isSourceHosted: x4, orderByFields: F3, outSpatialReference: R6, metadata: { timeReferenceUnknownClient: o19, dateFieldsTimeZone: n16, subtypeField: d9, globalIdField: y4, fieldsIndex: f6, geometryType: b4, featureIdInfo: e9(this.layer), timeInfo: h4, spatialReference: S3, outSpatialReference: R6, subtypes: this.layer.subtypes?.map((e12) => e12.toJSON()), typeIdField: null, types: null }, queryMetadata: { maxRecordCount: a9.query.maxRecordCount, supportsCompactGeometry: a9.query.supportsCompactGeometry, supportsDefaultSpatialReference: a9.query.supportsDefaultSpatialReference, supportsFormatPBF: a9.query.supportsFormatPBF, supportsMaxRecordCountFactor: a9.query.supportsMaxRecordCountFactor, supportsQuantization: a9.query.supportsQuantization, lastEditDate: p12?.lastEditDate?.getTime(), snapshotInfo: j3 } };
  }
  createSourceSchema(e12, t11) {
    const { definitionExpression: r12, customParameters: s12, gdbVersion: a9, historicMoment: i14, subtypeField: l10, timeExtent: o19, apiKey: n16, displayFilterInfo: u18 } = this.layer, p12 = { queryScaleRanges: this.layer.sublayers.items.map((e13) => ({ subtypeCode: e13.subtypeCode, minScale: e13.minScale, maxScale: e13.maxScale })), definitionExpression: r12, displayFilterInfo: u18, customParameters: s12, gdbVersion: a9, historicMoment: i14, subtypeField: l10, timeExtent: o19 };
    return t8(p12, e12, t11, n16);
  }
  createProcessorSchema(e12, t11, r12) {
    const s12 = { layerId: this.layer.id, subtypeField: this.layer.subtypeField, sublayers: Array.from(this.layer.sublayers, (e13) => ({ featureReduction: null, geometryType: this.layer.geometryType, labelingInfo: e13.labelingInfo, labelsVisible: e13.labelsVisible, renderer: e13.renderer, subtypeCode: e13.subtypeCode, orderBy: null })) };
    return u17(e12, t11, s12, r12);
  }
  addFilters(e12, t11) {
    e12 = r11(this.layer, e12, t11);
    const s12 = this.layer.sublayers.filter((e13) => !d8(e13, t11)).map((e13) => e13.subtypeCode);
    if (!s12.length) return e12;
    e12 ??= new d3();
    const i14 = `NOT ${this.layer.subtypeField} IN (${s12.join(",")})`;
    return e12.where = r3(e12.where, i14), e12;
  }
  get hasRequiredSupport() {
    return true;
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => o15(this.layer, e12) ? e12.floors : null, () => this.layer.outFields, () => this.layer.gdbVersion, () => this.layer.historicMoment, () => this.layer.sublayers.map(({ renderer: e13, labelsVisible: t11, labelingInfo: r12, visible: s12, minScale: a9, maxScale: i14 }) => ({ renderer: e13, labelsVisible: t11, labelingInfo: r12, visible: s12, minScale: a9, maxScale: i14 }))];
  }
  setGraphicOrigin(e12) {
    const t11 = this.layer.fieldsIndex.get(this.layer.subtypeField), r12 = e12.attributes[t11.name], s12 = this.layer.sublayers.find((e13) => e13.subtypeCode === r12);
    e12.layer = e12.sourceLayer = s12;
  }
};
function d8(e12, r12) {
  return e12.visible && (0 === e12.minScale || m2(r12.scale, e12.minScale) || r12.scale < e12.minScale) && (0 === e12.maxScale || m2(r12.scale, e12.maxScale) || r12.scale > e12.maxScale);
}

// node_modules/@arcgis/core/views/2d/layers/support/DebouncedFeatureOverride.js
var e10 = class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._historicMoment = null;
  }
  add(e12) {
    switch (e12.type) {
      case "override":
        return this._addOverride(e12);
      case "override-by-id":
        return this._addOverrideById(e12);
    }
  }
  toMessage() {
    const e12 = { historicMoment: this._historicMoment, commands: { updateByIdWeak: [], updateWeak: [], removeWeak: [], update: [], remove: [], release: [] } };
    for (const [s12, r12] of this._commands.entries()) switch (r12.type) {
      case "override-update-by-id":
        e12.commands.updateByIdWeak.push(s12);
        break;
      case "override-update":
        r12.isWeak ? e12.commands.updateWeak.push(r12.feature) : e12.commands.update.push(r12.feature);
        break;
      case "override-remove":
        r12.isWeak ? e12.commands.removeWeak.push(s12) : e12.commands.remove.push(s12);
        break;
      case "override-release":
        e12.commands.release.push(s12);
    }
    return e12;
  }
  _addOverrideById(e12) {
    this._historicMoment = e12.historicMoment;
    for (const s12 of e12.updates) this._commands.set(s12, { type: "override-update-by-id", isWeak: e12.isWeak });
    for (const s12 of e12.removed) this._commands.set(s12, { type: "override-remove", isWeak: e12.isWeak });
  }
  _addOverride(e12) {
    this._historicMoment = e12.historicMoment;
    for (const s12 of e12.updates) this._commands.set(s12.objectId, { type: "override-update", feature: s12, isWeak: e12.isWeak });
    for (const s12 of e12.removed) this._commands.set(s12, { type: "override-remove", isWeak: e12.isWeak });
    for (const s12 of e12.release) this._commands.set(s12, { type: "override-release" });
  }
};

// node_modules/@arcgis/core/views/2d/layers/support/handleNoEngineError.js
async function n14(n16, r12) {
  try {
    return await n16;
  } catch (t11) {
    if ("no-queryEngine" !== t11.name) throw t11;
    return r12;
  }
}

// node_modules/@arcgis/core/views/2d/tiling/FeatureTileSubscriptionManager.js
function e11(s12, e12) {
  const i14 = /* @__PURE__ */ new Set();
  for (const t11 of s12 instanceof Set ? s12.values() : s12.keys()) e12.has(t11) || i14.add(t11);
  return i14;
}
var i13 = class {
  constructor(s12, e12, i14) {
    const t11 = i14 ? s12.getTileCoverage(i14, 0, true, "closest") : null, n16 = s12.getTileCoverage(e12, 0, true, "closest");
    if (this._tileKeys = /* @__PURE__ */ new Map(), t11) for (const o19 of t11.keys()) this._tileKeys.set(o19.id, o19);
    if (n16) for (const o19 of n16.keys()) this._tileKeys.set(o19.id, o19);
  }
  get coverageSet() {
    return new Set(this._tileKeys.keys());
  }
  keys() {
    return this._tileKeys.values();
  }
};
var t10 = class {
  constructor(s12) {
    this.version = s12;
  }
};
var n15 = class {
  constructor(s12) {
    this._subscriptions = /* @__PURE__ */ new Map(), this._visible = /* @__PURE__ */ new Set(), this._paused = /* @__PURE__ */ new Set(), this._version = 0, this._config = s12;
  }
  destroy() {
  }
  get coverageSet() {
    return this._coverage?.coverageSet ?? /* @__PURE__ */ new Set();
  }
  get subscriptions() {
    return new Set(this._subscriptions.keys());
  }
  suspend() {
    this._suspendedOverage = this._coverage, this._coverage = null, this._updateSubscriptions();
  }
  resume() {
    null == this._coverage && (this._coverage = this._suspendedOverage, this._suspendedOverage = null, this._updateSubscriptions());
  }
  update(s12, e12) {
    return this._version = (this._version + 1) % Number.MAX_SAFE_INTEGER, this._updateCoverage(s12, e12), this._updateSubscriptions(), new Set(this._visible);
  }
  updateVisibility() {
    const s12 = this._updateVisibility();
    return this._visible = s12, this._visible;
  }
  _updateCoverage(s12, e12) {
    this._coverage = new i13(this._config.tileInfoView, s12, e12);
  }
  _updateSubscriptions() {
    const s12 = this.coverageSet, i14 = this._updateVisibility(), n16 = e11(i14, s12), o19 = e11(this._subscriptions, i14), r12 = e11(s12, this._subscriptions), a9 = e11(o19, s12), u18 = e11(n16, a9), c10 = e11(u18, this._paused);
    this._visible = i14;
    for (const e12 of r12.values()) this._subscriptions.set(e12, new t10(this._version));
    for (const e12 of c10.values()) this._paused.add(e12);
    for (const e12 of a9.values()) this._subscriptions.delete(e12), this._paused.delete(e12);
    (r12.size || a9.size || c10.size) && this._sendUpdateSubscriptions(r12, a9, c10);
  }
  _sendUpdateSubscriptions(s12, e12, i14) {
    const t11 = Array.from(s12.values()).map((s13) => ({ tileId: s13, version: this._subscriptions.get(s13).version }));
    this._config.updateSubscriptions({ subscribe: t11, unsubscribe: Array.from(e12.values()), pause: Array.from(i14.values()) });
  }
  _updateVisibility() {
    const s12 = /* @__PURE__ */ new Set(), e12 = /* @__PURE__ */ new Set();
    if (!this._coverage) return s12;
    for (const i14 of this._coverage.keys()) {
      if (this._config.isDone(i14)) {
        s12.add(i14.id);
        continue;
      }
      if (this._addVisibleParent(s12, e12, i14)) continue;
      this._addVisibleChildren(s12, i14) || s12.add(i14.id);
    }
    return s12;
  }
  _addVisibleParent(e12, i14, t11) {
    let n16 = false;
    for (const o19 of this._visible.values()) {
      new e3(o19).containsChild(t11) && (e12.add(o19), i14.add(o19), n16 = true);
    }
    return n16;
  }
  _addVisibleChildren(e12, i14) {
    let t11 = false;
    for (const n16 of this._visible.values()) {
      const o19 = new e3(n16);
      i14.containsChild(o19) && (e12.add(n16), t11 = true);
    }
    return t11;
  }
};

// node_modules/@arcgis/core/views/layers/support/WhereClauseVisitor.js
var s11 = class {
  constructor(i14) {
    this._fieldsIndex = i14, this._clauses = [];
  }
  async finish() {
    return { requiresCurrentUser: (await Promise.all(this._clauses)).some((i14) => i14.currentUserRequired) };
  }
  visitClientWhereClause(s12) {
    s12 && this._clauses.push(e2(s12, this._fieldsIndex));
  }
  visitFeatureReduction(i14) {
    if (i14) switch (i14.type) {
      case "binning":
      case "cluster":
        this.visitLabelingInfo(i14.labelsVisible, i14.labelingInfo);
    }
  }
  visitLabelingInfo(i14, s12) {
    if (i14 && null != s12) for (const e12 of s12) this.visitClientWhereClause(e12.where);
  }
  visitDisplayFilter(i14, s12) {
    if (i14) for (const e12 of s12?.filters ?? []) this.visitClientWhereClause(e12.where);
  }
  visitFilter(i14) {
    this.visitClientWhereClause(i14?.where);
  }
  visitTrackInfo(i14) {
    null != i14 && (this.visitLabelingInfo(i14?.latestObservations.labelsVisible, i14?.latestObservations.labelingInfo), this.visitLabelingInfo(i14?.previousObservations.labelsVisible, i14?.previousObservations.labelingInfo), this.visitLabelingInfo(i14?.trackLines.labelsVisible, i14?.trackLines.labelingInfo));
  }
};

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var S2 = (S3) => {
  let N2 = class extends S3 {
    constructor(...e12) {
      super(...e12), this._updatingRequiredPromise = null, this.filter = null, this.layer = null, this.requiresCurrentUser = false, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.addHandles([l3(() => {
        const e12 = this.layer, t11 = this.view;
        return [e12 && "elevationInfo" in e12 ? e12.elevationInfo?.featureExpressionInfo : null, e12 && "displayField" in e12 ? e12.displayField : null, e12 && "timeInfo" in e12 && e12.timeInfo, e12 && "renderer" in e12 && e12.renderer, e12 && "labelingInfo" in e12 && e12.labelingInfo, e12 && "floorInfo" in e12 && e12.floorInfo, t11?.requiredFieldsOptions?.featureTitleFields && e12 && "featureTitleFields" in e12 && e12.featureTitleFields, t11?.requiredFieldsOptions?.utilityNetworkFields && t5(t11, e12), e12.displayFilterInfo, this.displayFilterEnabled, this.filter, this.featureEffect, this.timeExtent, "knowledge-graph-sublayer" === e12?.type && "link-chart" === e12.parentCompositeLayer.type && e12.parentCompositeLayer.linkChart?.linkChartProperties.nonspatialDataDisplay?.mode, "parquet" === e12?.type && e12.popupTemplate];
      }, () => this._handleChange(), w), a3(() => this.view?.floors, "change", () => this._handleChange()), a3(() => this.layer.displayFilterInfo?.filters, "change", () => this._handleChange()), a3(() => this.layer && "sublayers" in this.layer ? this.layer.sublayers : null, "change", () => this._handleChange())]);
    }
    get availableFields() {
      if (!this.layer) return [];
      const { layer: e12, layer: { fieldsIndex: t11 }, requiredFields: r12 } = this;
      return "outFields" in e12 && e12.outFields ? w2(t11, [...h(t11, e12.outFields), ...r12]) : w2(t11, r12);
    }
    get displayFilterEnabled() {
      return (this.view?.displayFilterEnabled ?? true) && (!("displayFilterEnabled" in this.layer) || (this.layer?.displayFilterEnabled ?? true));
    }
    get effectiveDisplayFilter() {
      const e12 = this.layer;
      return this.displayFilterEnabled && e12.displayFilterInfo ? u7(e12.displayFilterInfo, this.view) : null;
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e12) {
      this._override("featureEffect", e12);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e12) {
      i2.getLogger(this).error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    get signedInUser() {
      return this.layer?.url ? J(this.layer.url) : Promise.resolve(null);
    }
    highlight(e12, t11) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e12 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t11 = null != this.filter ? this.filter.createQuery(e12) : new R(e12);
      return "floorInfo" in this.layer && this.layer.floorInfo && (t11.where = r3(t11.where, o5(this))), this.displayFilterEnabled && (t11.where = r3(t11.where, this.effectiveDisplayFilter?.where)), null != this.timeExtent && (t11.timeExtent = null != t11.timeExtent ? t11.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t11;
    }
    createAggregateQuery() {
      const e12 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new R(e12);
    }
    queryFeatures(e12, t11) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e12, t11) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e12, t11) {
      throw new Error("missing implementation");
    }
    queryExtent(e12, t11) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeaturesFromGraphics(e12, t11) {
      const r12 = await this._createPopupQuery(e12.map((e13) => e13.origin?.layer ?? e13.layer), t11);
      return await s4(this.layer, e12, r12, { getPopupTemplate: (e13) => e13 && "popupEnabled" in e13 && e13.popupEnabled ? p2(e13, t11) : null, hasRequiredFields: (e13, t12) => this._popupFeatureHasRequiredFields(e13, t12), ...t11 });
    }
    _handleChange() {
      const e12 = Promise.all([this._updateRequiredFields(), this._updateClientWhereClauseRequirements()]).then(() => {
      });
      return this._set("_updatingRequiredPromise", e12), e12.then(() => {
        this._updatingRequiredPromise === e12 && this._set("_updatingRequiredPromise", null);
      }), e12;
    }
    async _updateClientWhereClauseRequirements() {
      if (!this.layer || !this.view) return;
      const { layer: e12 } = this, r12 = new s11(e12.fieldsIndex);
      if (r12.visitFilter(this.filter), "featureReduction" in e12 && r12.visitFeatureReduction(e12.featureReduction), "labelingInfo" in e12 && r12.visitLabelingInfo(e12.labelsVisible, e12.labelingInfo), "trackInfo" in e12 && r12.visitTrackInfo(e12.trackInfo), "2d" === this.view.type && (r12.visitFilter(this.featureEffect?.filter), r12.visitDisplayFilter(this.displayFilterEnabled, e12.displayFilterInfo), "featureReduction" in e12 && r12.visitFeatureReduction(e12.featureReduction)), "subtype-group" === e12.type) for (const t11 of e12.sublayers) r12.visitLabelingInfo(t11.labelsVisible, t11.labelingInfo);
      try {
        const e13 = await r12.finish();
        this._set("requiresCurrentUser", e13.requiresCurrentUser);
      } catch (i14) {
        i2.getLogger(this).error(i14);
      }
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view) return;
      const e12 = "3d" === this.view.type, { layer: r12, layer: { fieldsIndex: i14 } } = this, l10 = "renderer" in r12 && r12.renderer, s12 = "orderBy" in r12 && r12.orderBy, o19 = "featureReduction" in r12 ? r12.featureReduction : null, n16 = /* @__PURE__ */ new Set(), a9 = [l10 ? l10.collectRequiredFields(n16, i14) : null, Q(n16, r12), e12 && "elevationInfo" in r12 ? L3(n16, r12) : null, null != this.filter ? R3(n16, r12, this.filter) : null, e12 || null == this.featureEffect ? null : R3(n16, r12, this.featureEffect.filter), !e12 && o19 ? D2(n16, r12, o19) : null, !e12 && s12 ? j(n16, r12, s12) : null];
      if ("timeInfo" in r12 && r12.timeInfo && this.timeExtent && T(n16, r12.fieldsIndex, [r12.timeInfo.startField, r12.timeInfo.endField]), "timeInfo" in r12 && r12.timeInfo && "trackInfo" in r12 && r12.trackInfo) {
        const { trackInfo: e13 } = r12;
        T(n16, r12.fieldsIndex, [r12.timeInfo.trackIdField]), "feature" !== r12.type && "startTimeField" !== e13.timeField || T(n16, r12.fieldsIndex, [r12.timeInfo.startField]), "endTimeField" === e13.timeField && T(n16, r12.fieldsIndex, [r12.timeInfo.endField]), await M(n16, r12);
      }
      if ("floorInfo" in r12 && r12.floorInfo && T(n16, r12.fieldsIndex, [r12.floorInfo.floorField]), "featureTitleFields" in r12 && this.view?.requiredFieldsOptions?.featureTitleFields && r12.featureTitleFields && T(n16, r12.fieldsIndex, r12.featureTitleFields), "feature" === r12.type && r12.globalIdField && this.view?.requiredFieldsOptions?.globalIdField && T(n16, r12.fieldsIndex, [r12.globalIdField]), this.displayFilterEnabled && a9.push(P(n16, r12, r12.displayFilterInfo)), "feature" === r12.type && e12 && null != r12.infoFor3D && (null == r12.globalIdField && i2.getLogger(this).error("globalIdField missing on 3DObjectFeatureLayer"), T(n16, r12.fieldsIndex, [r12.globalIdField])), "subtype-group" === r12.type) {
        x(n16, i14, r12.subtypeField);
        const e13 = r12.sublayers.map((e14) => Promise.all([e14.renderer?.collectRequiredFields(n16, i14), Q(n16, e14)]));
        a9.push(Promise.all(e13));
      }
      if ("catalog-footprint" === r12.type && r12.parent) {
        const e13 = r12.parent;
        T(n16, i14, [e13.itemNameField, e13.itemSourceField, e13.itemTypeField, e13.maxScaleField, e13.minScaleField]);
      }
      "knowledge-graph-sublayer" === r12.type && "link-chart" === r12.parentCompositeLayer.type && x(n16, i14, E), "parquet" === r12.type && a9.push(n3(r12, r12.popupTemplate).then((e13) => {
        for (const t11 of e13) n16.add(t11);
      }));
      const p12 = await Promise.allSettled(a9);
      if (e12) x(n16, i14, r12.objectIdField);
      else for (const t11 of e5(e9(r12))) x(n16, i14, t11);
      e12 && "displayField" in r12 && r12.displayField && x(n16, i14, r12.displayField);
      for (const u18 of p12) "rejected" === u18.status && i2.getLogger(this).error(u18.reason);
      const f6 = Array.from(n16).sort();
      this._set("requiredFields", f6);
    }
    _popupFeatureHasRequiredFields(e12, t11) {
      return ke(e12, t11);
    }
    async _createPopupQuery(e12, t11) {
      const i14 = this.layer.createQuery(), l10 = /* @__PURE__ */ new Set();
      let s12 = false;
      const n16 = e12 ?? [this.layer];
      for (const o19 of n16) {
        if (!("popupEnabled" in o19)) continue;
        const e13 = p2(o19, t11);
        if (null == e13) continue;
        const i15 = await r4(e13);
        s2(t11);
        const n17 = i15 && i15.arcadeUtils.hasGeometryOperations(e13);
        s12 = !("point" !== this.layer.geometryType && !n17);
        const a9 = await n3(this.layer, e13);
        s2(t11);
        for (const t12 of a9) l10.add(t12);
      }
      return i14.returnGeometry = s12, i14.returnZ = s12, i14.returnM = s12, i14.outFields = Array.from(l10), i14.outSpatialReference = this.view.spatialReference, "floorInfo" in this.layer && this.layer.floorInfo && (i14.where = r3(i14.where, o5(this))), i14;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
    getTest() {
    }
    get test() {
    }
  };
  return r([m()], N2.prototype, "_updatingRequiredPromise", void 0), r([m({ readOnly: true })], N2.prototype, "availableFields", null), r([m({ readOnly: true })], N2.prototype, "displayFilterEnabled", null), r([m({ readOnly: true })], N2.prototype, "effectiveDisplayFilter", null), r([m({ type: p })], N2.prototype, "featureEffect", null), r([m({ type: d3 })], N2.prototype, "filter", void 0), r([m()], N2.prototype, "layer", void 0), r([m({ type: Number })], N2.prototype, "maximumNumberOfFeatures", null), r([m({ readOnly: true, type: Boolean })], N2.prototype, "maximumNumberOfFeaturesExceeded", null), r([m()], N2.prototype, "requiresCurrentUser", void 0), r([m({ readOnly: true })], N2.prototype, "requiredFields", void 0), r([m({ readOnly: true })], N2.prototype, "signedInUser", null), r([m()], N2.prototype, "suspended", void 0), r([m()], N2.prototype, "view", void 0), N2 = r([a2("esri.views.layers.FeatureLayerView")], N2), N2;
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function ue(e12, t11) {
  const r12 = /* @__PURE__ */ new Set();
  return e12 && e12.forEach((e13) => r12.add(e13)), t11 && t11.forEach((e13) => r12.add(e13)), r12.has("*") ? ["*"] : Array.from(r12);
}
var le = 4294967294;
function he(e12, t11) {
  return t(e12.map((e13) => l3(() => {
    const t12 = e13();
    return t12 && "object" == typeof t12 ? "getTime" in t12 && "function" == typeof t12.getTime ? t12.getTime() : JSON.stringify(t12) : t12;
  }, t11)));
}
var ce = class extends S2(i7(S(u9))) {
  constructor() {
    super(...arguments), this._commandsQueue = new o8({ process: (e12) => {
      switch (e12.type) {
        case "override-batch":
          return this._doOverride(e12);
        case "update":
          return this._doUpdate();
        case "highlight":
          return this._updateHighlights();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._lastAvailableFields = [], this._lastTargetState = null, this.eventLog = new l6(), this._sourceRefreshVersion = 1, this._displayRefreshVersion = 1, this._pipelineUpdating = false, this._editUpdatingHandles = new h2(), this._fields = null, this._sourceUpdating = false, this.featureEffectView = new c3();
  }
  destroy() {
    this._workerProxy?.destroy(), this._workerAttached.reject(u2()), this._commandsQueue.destroy();
  }
  initialize() {
    this._workerAttached = L2(), d(this._workerAttached.promise), this.addResolvingPromise(this._initProxy()), this.featureEffectView.featureEffect = this.featureEffect, this.featureEffectView.endTransition();
  }
  async _initProxy() {
    const e12 = this.layer;
    if ("isTable" in e12 && e12.isTable) throw new s("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e12 });
    if (("feature" === e12.type || "subtype-group" === e12.type) && false === D(e12)?.operations.supportsQuery) throw new s("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e12 });
    this._workerProxy && this._workerProxy.destroy();
    const t11 = this._createClientOptions();
    this._workerProxy = await t6(t11);
  }
  async _attachProxy() {
    const e12 = { service: await this.layerAdapter.createServiceOptions(this.view), tileInfoJSON: this.view?.featuresTilingScheme?.tileInfo?.toJSON() };
    let t11 = [];
    Array.isArray(e12.service.source) && (t11 = e12.service.source);
    try {
      await this._workerProxy.pipeline.onAttach(e12, { transferList: t11 }), this._workerAttached.resolve();
    } catch (r12) {
      this._workerAttached.reject(u2()), f(r12);
    }
  }
  async _detachProxy() {
    return this._workerProxy.pipeline.onDetach();
  }
  async getWorker() {
    return await this._workerAttached.promise, this._workerProxy;
  }
  get dataUpdating() {
    return this._sourceUpdating || this._editUpdatingHandles.updating;
  }
  get effectiveDisplayFilterClause() {
    const e12 = this.effectiveDisplayFilter?.where ?? null;
    return e12 && this.hasHighlight ? u5(e12, l4(this.layer.objectIdField, this.highlightIds)) : e12;
  }
  get hasAllFeatures() {
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && this.eventLog.willQueryAllFeatures;
  }
  get hasAllFeaturesInView() {
    const e12 = this.effectiveDisplayFilter?.where || null, t11 = !this.eventLog.willQueryAllFeatures && null != e12 && "1=1" !== e12;
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && !t11;
  }
  get hasFullGeometries() {
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && this.eventLog.willQueryFullResolutionGeometry;
  }
  get labelingCollisionInfos() {
    const e12 = this.layerAdapter.getLabelingDeconflictionInfo(this.view), t11 = this.layer.geometryType, r12 = !this.suspended;
    return e12.map(({ vvEvaluators: e13, deconflictionEnabled: s12, labelingInfo: i14 }) => ({ labelingInfo: i14, container: this.featureContainer, vvEvaluators: e13, deconflictionEnabled: s12, geometryType: t11, visible: r12 }));
  }
  get layerAdapter() {
    switch (this.layer.type) {
      case "feature":
        return "memory" === this.layer.source.type ? new p10(this.layer) : new m11(this.layer);
      case "geojson":
      case "csv":
      case "wfs":
        return new p10(this.layer);
      case "parquet":
        return new y3(this.layer);
      case "subtype-group":
        return new m15(this.layer);
      case "ogc-feature":
        return new u15(this.layer);
      case "stream":
        return new o17(this.layer);
      case "oriented-imagery":
        return new m12(this.layer);
      case "knowledge-graph-sublayer":
        return new c9(this.layer);
      case "catalog-footprint":
        return new n9(this.layer);
      default:
        n(this.layer);
    }
    return null;
  }
  get timeExtent() {
    return i8(this.layerAdapter.timeOptions, this.view?.timeExtent, this._get("timeExtent"));
  }
  getDisplayStatistics(e12, t11) {
    return this.featureContainer?.getDisplayStatistics(e12, t11);
  }
  async queryHeatmapStatistics(e12) {
    return (await this.getWorker()).pipeline.queryHeatmapStatistics(e12);
  }
  highlight(e12, t11) {
    let s12;
    e12 instanceof d2 ? s12 = [e12.getObjectId()] : "number" == typeof e12 || "string" == typeof e12 ? s12 = [e12] : V.isCollection(e12) && e12.length > 0 ? s12 = e12.map((e13) => e13?.getObjectId()).toArray() : Array.isArray(e12) && e12.length > 0 && (s12 = "number" == typeof e12[0] || "string" == typeof e12[0] ? e12 : e12.map((e13) => e13?.getObjectId()));
    const o19 = s12?.filter(L);
    if (!o19?.length) return e();
    const n16 = t11?.name ?? c2;
    return this._addHighlights(o19, n16), e(() => !this.destroyed && this._removeHighlights(o19, n16));
  }
  async hitTest(e12, i14) {
    const a9 = await this.featureContainer.hitTest(i14);
    if (0 === a9.length) return null;
    const o19 = await this.getWorker(), { features: n16, aggregates: u18, tracks: l10 } = await o19.pipeline.getDisplayFeatures(a9), h4 = this.featureContainer.getSortKeys(a9), c10 = ({ displayId: e13 }, { displayId: t11 }) => h4.has(e13) && h4.has(t11) ? h4.get(e13) - h4.get(t11) : e13 - t11;
    return n16.sort(c10).reverse(), u18.sort(c10).reverse(), [...u18.map((r12) => this._createGraphicHit(e12, s6.fromJSON(r12))), ...l10.map((t11) => this._createGraphicHit(e12, p5.fromJSON(t11))), ...n16.map((t11) => this._createGraphicHit(e12, d2.fromJSON(t11)))];
  }
  async queryStatistics() {
    const e12 = await this.getWorker();
    return n14(e12.pipeline.queryStatistics(), { featureCount: 0, ringCount: 0, vertexCount: 0 });
  }
  async querySummaryStatistics(e12, t11, r12) {
    const s12 = await this.getWorker(), i14 = { ...t11, scale: this.view.scale }, a9 = s12.features.executeQueryForSummaryStatistics(this._cleanUpQuery(e12), i14, r12);
    return n14(a9, {});
  }
  async queryAggregateSummaryStatistics(e12, t11, r12) {
    const s12 = { ...t11, scale: this.view.scale }, i14 = (await this.getWorker()).aggregates.executeQueryForSummaryStatistics(this._cleanUpAggregateQuery(e12), s12, r12);
    return n14(i14, {});
  }
  async queryUniqueValues(e12, t11, r12) {
    const s12 = await this.getWorker(), i14 = { ...t11, scale: this.view.scale }, a9 = s12.features.executeQueryForUniqueValues(this._cleanUpQuery(e12), i14, r12);
    return n14(a9, { uniqueValueInfos: [] });
  }
  async queryAggregateUniqueValues(e12, t11, r12) {
    const s12 = await this.getWorker(), i14 = { ...t11, scale: this.view.scale }, a9 = s12.aggregates.executeQueryForUniqueValues(this._cleanUpAggregateQuery(e12), i14, r12);
    return n14(a9, { uniqueValueInfos: [] });
  }
  async queryClassBreaks(e12, t11, r12) {
    const s12 = await this.getWorker(), i14 = { ...t11, scale: this.view.scale }, a9 = s12.features.executeQueryForClassBreaks(this._cleanUpQuery(e12), i14, r12);
    return n14(a9, { classBreakInfos: [] });
  }
  async queryAggregateClassBreaks(e12, t11, r12) {
    const s12 = await this.getWorker(), i14 = { ...t11, scale: this.view.scale }, a9 = s12.aggregates.executeQueryForClassBreaks(this._cleanUpAggregateQuery(e12), i14, r12);
    return n14(a9, { classBreakInfos: [] });
  }
  async queryHistogram(e12, t11, r12) {
    const s12 = await this.getWorker(), i14 = { ...t11, scale: this.view.scale }, a9 = s12.features.executeQueryForHistogram(this._cleanUpQuery(e12), i14, r12);
    return n14(a9, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  async queryAggregateHistogram(e12, t11, r12) {
    const s12 = await this.getWorker(), i14 = { ...t11, scale: this.view.scale }, a9 = s12.aggregates.executeQueryForHistogram(this._cleanUpAggregateQuery(e12), i14, r12);
    return n14(a9, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  queryFeatures(e12, t11) {
    return this.queryFeaturesJSON(e12, t11).then((e13) => {
      const t12 = g2.fromJSON(e13);
      return t12.features.forEach((e14) => this._setLayersForFeature(e14)), t12;
    });
  }
  async queryVisibleFeatures(e12, t11) {
    const r12 = (await this.getWorker()).pipeline.queryVisibleFeatures(this._cleanUpQuery(e12), t11), s12 = await n14(r12, { features: [] }), i14 = g2.fromJSON(s12);
    return i14.features.forEach((e13) => this._setLayersForFeature(e13)), i14;
  }
  async queryAggregates(e12, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e12), t11), s12 = await n14(r12, { features: [] }), i14 = c4.fromJSON(s12);
    return i14.features.forEach((e13) => this._setLayersForFeature(e13)), i14;
  }
  async queryAggregateIds(e12, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQueryForIds(this._cleanUpAggregateQuery(e12), t11);
    return n14(r12, []);
  }
  async queryAggregateCount(e12, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQueryForCount(this._cleanUpAggregateQuery(e12), t11);
    return n14(r12, 0);
  }
  async queryAggregateJSON(e12, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e12), t11);
    return n14(r12, { features: [] });
  }
  async queryFeaturesJSON(e12, t11) {
    const r12 = (await this.getWorker()).features.executeQuery(this._cleanUpQuery(e12), t11);
    return n14(r12, { features: [] });
  }
  async queryObjectIds(e12, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForIds(this._cleanUpQuery(e12), t11);
    return n14(r12, []);
  }
  async queryFeatureCount(e12, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForCount(this._cleanUpQuery(e12), t11);
    return n14(r12, 0);
  }
  async queryExtent(e12, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForExtent(this._cleanUpQuery(e12), t11), s12 = await n14(r12, { count: 0, extent: null });
    return { count: s12.count, extent: z.fromJSON(s12.extent) };
  }
  async queryAttributeBins(e12, t11) {
    const r12 = (await this.getWorker()).features.executeAttributeBinsQuery(this._cleanUpAttributeBinsQuery(e12), t11), s12 = await n14(r12, { features: [] });
    return i5.fromJSON(s12);
  }
  async getSampleFeatures(e12) {
    return (await this.getWorker()).pipeline.getSampleFeatures(e12);
  }
  setVisibility(e12, t11) {
    t11 ? this._visibilityOverrides.delete(e12) : this._visibilityOverrides.add(e12), this._update();
  }
  update(e12) {
    if (!this.subscriptionManager) return;
    this.view.animation && !this._lastTargetState && (this._lastTargetState = e12.state.clone()), !this.view.animation && this._lastTargetState && (this._lastTargetState = null);
    const t11 = this.subscriptionManager.update(e12.targetState, this._lastTargetState), r12 = this.subscriptionManager.coverageSet;
    for (const s12 of this.featureContainer.tiles || []) s12.isCoverage = r12.has(s12.id), s12.neededForCoverage = t11.has(s12.id) || s12.isCoverage;
    this.featureContainer.setVisibleTiles(t11);
  }
  attach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.attach"), d(this._updatingHandles.addPromise(this._workerAttached.promise)), d(this._attachProxy()), this.featureContainer = new _2(this), this.container.addChild(this.featureContainer), this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this.subscriptionManager = new n15({ tileInfoView: this.view.featuresTilingScheme, updateSubscriptions: (e12) => {
      this.featureContainer.updateSubscriptions(e12), d(this._updatingHandles.addPromise(this.getWorker().then((t11) => t11.pipeline.updateSubscriptions(e12))));
    }, isDone: (e12) => this.featureContainer.isDone(e12) }), this.requestUpdate(), this.addAttachHandles([he([() => this._displayRefreshVersion, () => this.layer.displayFilterInfo, () => this.timeExtent, () => this.clips, () => this.filter, () => this.effectiveDisplayFilterClause, () => this.featureEffect, () => this._sourceRefreshVersion, () => this.view.timeZone, () => this.view.timeExtent, ...this.layerAdapter.getUpdateHashProperties(this.view)], () => this._update()), l3(() => this.updateSuspended, (e12) => {
      e12 || (this.subscriptionManager.resume(), this.view.labelManager.requestUpdate());
    }), l3(() => this.visible, (e12) => {
      this.view.labelManager.requestUpdate();
    })]), this._update(), "stream" !== this.layer.type && "parquet" !== this.layer.type && "catalog-footprint" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", (e12) => this._editUpdatingHandles.addPromise(this._edit(e12))));
  }
  detach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.detach"), this._detachProxy(), this._fields = null, this.featureContainer.destroy(), this.featureContainer = null, this._commandsQueue.clear(), this.container.removeAllChildren(), this.subscriptionManager = u(this.subscriptionManager), this._workerProxy.pipeline.onDetach(), this._workerAttached = L2(), d(this._workerAttached.promise), this._lastAvailableFields = [], this._lastSchema = null;
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  addOverrides(e12) {
    return this._commandsQueue.push({ type: "override", options: { ...e12, release: [] } });
  }
  removeOverrides(e12) {
    for (const r12 of e12) if (null == r12) throw new s("featurelayerview:bad-override", "Tried to remove an override for an invalid objectId", { objectId: r12 });
    const t11 = { added: [], updated: [], removed: [], release: e12, isWeak: false, historicMoment: null };
    return this._commandsQueue.push({ type: "override", options: t11 });
  }
  isUpdating() {
    const e12 = "renderer" in this.layer && null != this.layer.renderer, t11 = this._commandsQueue.updateTracking.updating, r12 = null != this._updatingRequiredPromise, s12 = this.featureContainer.updatingHandles.updating, i14 = this.updateRequested || e12 && (t11 || r12) || s12 || this._pipelineUpdating || this.dataUpdating;
    if (has("esri-2d-log-updating")) {
      console.log(`Updating FLV2D (${this.layer.id}): ${i14}
  -> updateRequested ${this.updateRequested}
  -> hasRenderer ${e12}
  -> updatingRequiredFields ${r12}
  -> hasPendingCommand ${t11}
  -> dataUpdating ${this.dataUpdating}
  -> processing ${this._pipelineUpdating}
  -> updatingContainer ${s12}
`);
      for (const e13 of this.featureContainer.subscriptions()) console.log(`    -> Tile[${e13.id}] Done: ${e13.done}`);
    }
    return i14;
  }
  _createClientOptions() {
    const e12 = this;
    return { get container() {
      return e12.featureContainer;
    }, setUpdating: (e13) => {
      this._set("_pipelineUpdating", e13.pipeline), this._set("_sourceUpdating", e13.source);
    }, emitEvent: (e13) => {
      this.emit(e13.name, e13.event);
    }, get eventLog() {
      return e12.eventLog;
    }, fetch: async (t11) => {
      if (has("esri-2d-stabilize-glyphs")) {
        const r12 = [];
        for (const s12 of t11) r12.push(await e12.view.stage.painter.textureManager.rasterizeItem(s12));
        return r12;
      }
      return Promise.all(t11.map((t12) => e12.view.stage.painter.textureManager.rasterizeItem(t12)));
    }, fetchDictionary: (e13) => Promise.all(e13.map((e14) => this._fetchDictionaryRequest(e14))) };
  }
  async _fetchDictionaryRequest(e12) {
    try {
      if ("subtype-group" === this.layer.type) throw new Error("InternalError: SubtypeGroupLayer does not support dictionary renderer");
      const t11 = this.layer.renderer;
      if (!t11 || "dictionary" !== t11.type) throw new Error("InternalError: Expected layer to have a DictionaryRenderer");
      const r12 = this._lastSchema.processor.mesh.factory.symbology;
      if ("dictionary" !== r12.type) throw new Error("InternalError: Expected schema to be of type 'dictionary'");
      const s12 = { cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, store: this.featureContainer.instanceStore, scaleExpression: r12.scaleExpression };
      this._fields || (this._fields = this.layer.fields.map((e13) => e13.toJSON()));
      const i14 = r12.visualVariableUniforms, a9 = r6(this.layer.geometryType), o19 = await t11.getSymbolForControlString(e12.controlString, a9, false);
      if (!o19 || !o19.data) return { type: "dictionary-response", meshes: [] };
      return { type: "dictionary-response", meshes: await u8({ ...o19.data, hasTextStringTemplates: true }, { uniforms: i14, path: "renderer", schemaOptions: s12 }) };
    } catch (t11) {
      return { type: "dictionary-response", meshes: [] };
    }
  }
  _cleanUpQuery(e12) {
    const t11 = R.from(e12) || this.createQuery();
    return t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference), t11.toJSON();
  }
  _cleanUpAttributeBinsQuery(e12) {
    const t11 = R2.from(e12);
    return t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference), t11.toJSON();
  }
  _cleanUpAggregateQuery(e12) {
    const t11 = R.from(e12) || this.createAggregateQuery();
    t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference);
    const r12 = t11.objectIds ?? [];
    for (const s12 of t11.aggregateIds ?? []) r12.push(s12);
    return t11.objectIds = r12, t11.aggregateIds = [], t11.toJSON();
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  _edit(e12) {
    return this.updateSuspended ? (this.subscriptionManager.suspend(), Promise.resolve()) : this._commandsQueue.push({ type: "edit", event: e12 });
  }
  async doRefresh(e12) {
    this.attached && (this.updateSuspended && e12 || (e12 ? this.incrementSourceRefreshVersion() : this.incrementDisplayRefreshVersion()));
  }
  incrementSourceRefreshVersion() {
    this._sourceRefreshVersion = (this._sourceRefreshVersion + 1) % le + 1;
  }
  incrementDisplayRefreshVersion() {
    this._displayRefreshVersion = (this._displayRefreshVersion + 1) % le + 1;
  }
  async _resolveIdenifiers(e12) {
    const t11 = [], r12 = [];
    for (const a9 of e12) null == a9.objectId || -1 === a9.objectId ? null == a9.globalId ? i2.getLogger(this).warn("mapview-apply-edits", "A feature identifier must contain either a GlobalId or ObjectId. Ignoring", { identifier: a9 }) : r12.push(a9.globalId) : t11.push(a9.objectId);
    const s12 = "globalIdField" in this.layer && this.layer.globalIdField, i14 = s12 && this.availableFields.includes(s12);
    if (r12.length && !i14) return i2.getLogger(this).error(new s("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${s12} to be included the layer's outFields for updates to be reflected on the map`)), t11;
    if (r12.length) {
      const e13 = await this._workerProxy.pipeline.getObjectIdsFromGlobalIds(r12);
      for (const r13 of e13) t11.push(r13);
    }
    return t11;
  }
  _resolveOverrides(e12) {
    const t11 = false, r12 = false, s12 = r6(this.layer.geometryType), i14 = e9(this.layer), a9 = [];
    for (const o19 of e12.added) {
      const e13 = ot(o19, s12, t11, r12, i14);
      if (null == e13.objectId) throw new s("featurelayerview:bad-override", "Feature does not have an objectId", { feature: o19 });
      a9.push(e13);
    }
    for (const o19 of e12.updated) {
      const e13 = ot(o19, s12, t11, r12, i14);
      if (null == e13.objectId) throw new s("featurelayerview:bad-override", "Feature does not have an objectId", { feature: o19 });
      a9.push(e13);
    }
    for (const o19 of e12.removed) if (null == o19) throw new s("featurelayerview:bad-override", "Tried to remove an invalid objectId", { objectId: o19 });
    return { type: "override", updates: a9, removed: e12.removed, release: e12.release, isWeak: e12.isWeak ?? false, historicMoment: e12.historicMoment ?? null };
  }
  async _resolveEdit(e12) {
    const t11 = this.layer, r12 = e12.historicMoment?.getTime() ?? null, s12 = "layerId" in t11 && e12.editedFeatures?.find((e13) => e13.layerId === t11.layerId);
    if (s12 && this._canEditByFeature(s12)) {
      const { adds: e13, deletes: t12, updates: i15 } = s12.editedFeatures, a10 = this.layer.objectIdField, o20 = i15.map((e14) => e14.current), n16 = t12.map((e14) => "attributes" in e14 ? { objectId: a10 ? e14.attributes[a10] : null } : e14), u18 = await this._resolveIdenifiers(n16);
      return this._resolveOverrides({ added: e13, updated: o20, removed: u18, historicMoment: r12, isWeak: true, release: [] });
    }
    const [i14, a9, o19] = await Promise.all([this._resolveIdenifiers(e12.addedFeatures), this._resolveIdenifiers(e12.updatedFeatures), this._resolveIdenifiers(e12.deletedFeatures)]);
    return { type: "override-by-id", updates: [...i14, ...a9], removed: o19, historicMoment: r12, isWeak: true };
  }
  _canEditByFeature(e12) {
    const { adds: t11, updates: r12 } = e12.editedFeatures;
    return t11.every((e13) => this.view.spatialReference.equals(e13.geometry?.spatialReference)) && r12.every((e13) => this.view.spatialReference.equals(e13.current.geometry?.spatialReference));
  }
  async _doUpdate() {
    "featureReduction" in this.layer && this.layer.featureReduction && this.layer.featureReduction !== this._lastFeatureReduction && (this.layer.featureReduction = this.layer.featureReduction?.clone(), this._lastFeatureReduction = this.layer.featureReduction);
    try {
      if (await Promise.allSettled([this._handleChange(), W(this.layer)]), this.destroyed || !this.layerAdapter?.hasRequiredSupport || !this.subscriptionManager) return;
      const e12 = this.featureContainer.instanceStore;
      this.featureContainer.attributeView.lockTextureUploads();
      const t11 = this._lastSchema?.processor.mesh.factory.symbology?.type;
      let r12 = true;
      "subtype-group" !== this.layer.type && "dictionary" === this.layer.renderer?.type && "dictionary" === t11 && (r12 = false), e12.updateStart(r12);
      const s12 = this.featureEffect, i14 = { store: e12, cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, scaleExpression: void 0 }, a9 = await this._createViewSchemaConfig(), o19 = { source: this.layerAdapter.createSourceSchema(a9, this._sourceRefreshVersion), processor: await this.layerAdapter.createProcessorSchema(i14, a9, this._displayRefreshVersion) }, n16 = o19.processor.mesh.factory.labels;
      n16 && this.view.labelManager.setLabelSchemaStyles(n16, this.featureContainer);
      const u18 = i(this._lastSchema?.source.mutable, o19.source.mutable) || i(this._lastSchema?.processor, o19.processor);
      if (!u18) return this.featureContainer.requestRender(), this.featureContainer.attributeView.unlockTextureUploads(), e12.updateEnd(r12), void (this.featureEffectView.featureEffect = s12);
      this._lastSchema = o19, this._fields = null;
      const l10 = Math.round(performance.now());
      has("esri-2d-update-debug") && console.debug(`Id[${this.layer.uid}] Version[${l10}] FeatureLayerView2D._doUpdate`, { changes: u18 });
      const h4 = await this.getWorker();
      await h4.pipeline.updateSchema(o19, l10), e12.updateEnd(r12), this.featureEffectView.featureEffect = s12, this.featureEffectView.endTransition(), this.featureContainer.restartAllAnimations(), this.featureContainer.attributeView.unlockTextureUploads(), this.featureContainer.trySwapRenderState(), this.featureContainer.requestRender(), has("esri-2d-update-debug") && console.debug(`Version[${l10}] FeatureLayerView2D.updateEnd`), this.requestUpdate();
    } catch (e12) {
      has("esri-2d-update-debug") && console.error("Encountered an error during update", e12);
    }
  }
  async _doOverride(e12) {
    const t11 = await this.getWorker();
    try {
      for (const r12 of e12.messages) switch (r12.type) {
        case "edit": {
          const e13 = new e10();
          e13.add(await this._resolveEdit(r12.event)), await t11.pipeline.onOverride(e13.toMessage());
          break;
        }
        case "override": {
          const e13 = new e10();
          e13.add(this._resolveOverrides(r12.options)), await t11.pipeline.onOverride(e13.toMessage());
          break;
        }
      }
    } catch (r12) {
      b(r12), 0;
    }
  }
  _getEffectiveAvailableFields(e12) {
    const t11 = ue(this._lastAvailableFields, e12);
    return this._lastAvailableFields = t11, _(this.layer.fieldsIndex, t11);
  }
  async _createViewSchemaConfig() {
    const e12 = this.requiresCurrentUser ? await this.signedInUser : null, t11 = [pe(this.view, this.layerAdapter, this.timeExtent, this._visibilityOverrides, this.filter, this.effectiveDisplayFilterClause), this.featureEffect?.filter?.toJSON() ?? null];
    return { availableFields: this._getEffectiveAvailableFields(this.availableFields), displayFilterEnabled: this.displayFilterEnabled, filters: t11, scale: this.view.scale, timeZone: this.view.timeZone, timeExtent: this.view.timeExtent, currentUser: e12 };
  }
  _processHighlight() {
    this._commandsQueue.push({ type: "highlight" });
  }
  async _updateHighlights() {
    const e12 = this._getHighlights(), t11 = await this.getWorker();
    if (this.destroyed) return;
    const r12 = t11.pipeline.updateHighlight({ highlights: e12 }).catch((e13) => {
      b(e13) || i2.getLogger(this).error(e13);
    });
    this._updatingHandles.addPromise(r12);
  }
  _setLayersForFeature(e12) {
    e12.layer = e12.sourceLayer = this.layer, this.layerAdapter.setGraphicOrigin && this.layerAdapter.setGraphicOrigin(e12);
  }
  _createGraphicHit(e12, t11) {
    return this._setLayersForFeature(t11), null != t11.geometry && (t11.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t11, layer: this.layer, mapPoint: e12 };
  }
};
function pe(e12, t11, r12, s12, i14, a9) {
  i14 && (i14 = i14.clone());
  const o19 = null != i14 ? i14.timeExtent : null, n16 = null != r12 && null != o19 ? r12.intersection(o19) : r12 || o19;
  n16 && (i14 ??= new d3(), i14.timeExtent = n16), i14 = t11.addFilters?.(i14, e12) ?? i14, a9 && (i14 ??= new d3(), i14.where = r3(i14.where, a9));
  let u18 = i14?.toJSON() ?? null;
  return s12.size && (u18 ??= new d3().toJSON(), u18.hiddenIds = Array.from(s12)), u18;
}
r([m()], ce.prototype, "_commandsQueue", void 0), r([m()], ce.prototype, "_sourceRefreshVersion", void 0), r([m()], ce.prototype, "_displayRefreshVersion", void 0), r([m({ readOnly: true })], ce.prototype, "_pipelineUpdating", void 0), r([m()], ce.prototype, "_sourceUpdating", void 0), r([m({ readOnly: true })], ce.prototype, "dataUpdating", null), r([m({ readOnly: true })], ce.prototype, "effectiveDisplayFilterClause", null), r([m({ readOnly: true })], ce.prototype, "hasAllFeatures", null), r([m({ readOnly: true })], ce.prototype, "hasAllFeaturesInView", null), r([m({ readOnly: true })], ce.prototype, "hasFullGeometries", null), r([m()], ce.prototype, "featureEffectView", void 0), r([m()], ce.prototype, "labelingCollisionInfos", null), r([m()], ce.prototype, "layerAdapter", null), r([m({ readOnly: true })], ce.prototype, "timeExtent", null), r([m()], ce.prototype, "updating", void 0), ce = r([a2("esri.views.2d.layers.FeatureLayerView2D")], ce);

export {
  n14 as n,
  ce
};
//# sourceMappingURL=chunk-XXIGPIQW.js.map
