import {
  $,
  I,
  P,
  d as d2,
  f,
  m,
  p as p2,
  v,
  w
} from "./chunk-OXPRKMBG.js";
import {
  i
} from "./chunk-BMFPNVV7.js";
import {
  l,
  n
} from "./chunk-TNRU7KID.js";
import "./chunk-HCBZZ3ZP.js";
import {
  o
} from "./chunk-ELSQQIKB.js";
import {
  E,
  c,
  l as l2,
  u
} from "./chunk-UGXCZZ7N.js";
import "./chunk-YZLWQJLF.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import {
  x
} from "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-YIV2QKTZ.js";
import "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import "./chunk-N3XLUQJI.js";
import "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  p2 as p
} from "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import "./chunk-GZ2P4SCJ.js";
import {
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  L,
  d,
  h
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/save/featureLayerUtils.js
var I2 = "Feature Service";
var g = "feature-layer-utils";
var P2 = `${g}-save`;
var E2 = `${g}-save-as`;
var O = `${g}-saveall`;
var A = `${g}-saveall-as`;
function x2(e) {
  return { isValid: x(e) && (!("dynamicDataSource" in e) || !e.dynamicDataSource), errorMessage: "Feature layer should be a layer or table in a map or feature service" };
}
function N(e, r) {
  const a = o(e, "portal-item");
  return r?.isTable && (a.layerContainerType = "tables"), a;
}
function $2(e) {
  const r = N(e), a = N(e);
  return a.layerContainerType = "tables", { forLayers: r, forTables: a };
}
function j(e) {
  const r = [], a = [];
  for (const { layer: t, layerJSON: n2 } of e) U(t) ? a.push(n2) : r.push(n2);
  return { layers: r, tables: a };
}
function U(e, r) {
  return e.isTable;
}
function R(e) {
  return j([e]);
}
async function J(e, r) {
  return /\/\d+\/?$/.test(e.url) ? R(r[0]) : C(r, e);
}
async function C(e, r) {
  if (e.reverse(), !r) return j(e);
  const a = await G(r, e);
  for (const t of e) H(t.layer, t.layerJSON, a);
  return D(a, e), a;
}
async function G(e, r) {
  let a = await e.fetchData("json");
  if (F(a)) return a;
  a ||= {}, _(a);
  const { layer: { url: t, customParameters: n2, apiKey: s2 } } = r[0];
  return await k(a, { url: t ?? "", customParameters: n2, apiKey: s2 }, r.map((e2) => e2.layer.layerId)), a;
}
function F(e) {
  return !!(e && Array.isArray(e.layers) && Array.isArray(e.tables));
}
function _(e) {
  e.layers ||= [], e.tables ||= [];
}
function D(e, r) {
  const a = [], t = [];
  for (const { layer: n2 } of r) {
    const { isTable: e2, layerId: r2 } = n2;
    e2 ? t.push(r2) : a.push(r2);
  }
  M(e.layers, a), M(e.tables, t);
}
function M(r, a) {
  if (r.length < 2) return;
  const t = [];
  for (const { id: e } of r) t.push(e);
  h(t.sort(Y), a.slice().sort(Y)) && r.sort((e, r2) => {
    const t2 = a.indexOf(e.id), n2 = a.indexOf(r2.id);
    return t2 < n2 ? -1 : t2 > n2 ? 1 : 0;
  });
}
function Y(e, r) {
  return e < r ? -1 : e > r ? 1 : 0;
}
async function k(e, r, a) {
  const { url: t, customParameters: n2, apiKey: s2 } = r, { serviceJSON: o2, layersJSON: l3 } = await n(t, { customParameters: n2, apiKey: s2 }), i2 = B(e.layers, o2.layers, a), c2 = B(e.tables, o2.tables, a);
  e.layers = i2.itemResources, e.tables = c2.itemResources;
  const u2 = [...i2.added, ...c2.added], y = l3 ? [...l3.layers, ...l3.tables] : [];
  await K(e, u2, t, y);
}
function B(e, a, t) {
  const n2 = d(e, a, (e2, r) => e2.id === r.id);
  e = e.filter((e2) => !n2.removed.some((r) => r.id === e2.id));
  const s2 = n2.added;
  return s2.forEach(({ id: r }) => {
    e.push({ id: r });
  }), { itemResources: e, added: s2.filter(({ id: e2 }) => !t.includes(e2)) };
}
async function K(e, r, a, t) {
  const n2 = await z(r), s2 = r.map(({ id: e2, type: r2 }) => new (n2.get(r2))({ url: a, layerId: e2, sourceJSON: t.find(({ id: r3 }) => r3 === e2) }));
  await Promise.allSettled(s2.map((e2) => e2.load())), s2.forEach((r2) => {
    const { layerId: a2, loaded: t2, defaultPopupTemplate: n3 } = r2;
    if (!t2 || null == n3) return;
    const s3 = { id: a2, popupInfo: n3.toJSON() };
    H(r2, "ArcGISFeatureLayer" === r2.operationalLayerType ? s3 : { ...s3, layerType: r2.operationalLayerType }, e);
  });
}
async function z(e) {
  const r = [];
  e.forEach(({ type: e2 }) => {
    switch (l(e2)) {
      case "CatalogLayer":
        r.push(import("./CatalogLayer-7LBYH2GO.js").then((e3) => e3.default));
        break;
      case "FeatureLayer":
        r.push(import("./FeatureLayer-5JKXWSL3.js").then((e3) => e3.default));
        break;
      case "OrientedImageryLayer":
        r.push(import("./OrientedImageryLayer-57B7W4X3.js").then((e3) => e3.default));
    }
  });
  const a = await Promise.all(r), t = /* @__PURE__ */ new Map();
  return e.forEach(({ type: e2 }, r2) => {
    t.set(e2, a[r2]);
  }), t;
}
function H(e, r, a) {
  e.isTable ? V(a.tables, r) : V(a.layers, r);
}
function V(e, r) {
  const a = e.findIndex(({ id: e2 }) => e2 === r.id);
  -1 === a ? e.push(r) : e[a] = r;
}
function q(e, r) {
  if (!e.length) throw new s(`${r}:missing-parameters`, "'layers' array should contain at least one feature layer");
}
function Q(e, r) {
  const a = e.map((e2) => e2.portalItem.id);
  if (new Set(a).size > 1) throw new s(`${r}:invalid-parameters`, "All layers in the 'layers' array should be loaded from the same portal item");
}
function W(e, r) {
  const a = e.map((e2) => e2.layerId);
  if (new Set(a).size !== a.length) throw new s(`${r}:invalid-parameters`, "'layers' array should contain only one instance each of layer or table in a feature service");
}
async function X(e) {
  q(e, O), await Promise.all(e.map((e2) => e2.load()));
  for (const r of e) p2(r, O, x2), f({ layer: r, itemType: I2, errorNamePrefix: O });
  Q(e, O), W(e, O);
}
function Z(e) {
  if (!("layerType" in e)) return !!e.charts?.length;
  switch (e.layerType) {
    case "OrientedImageryLayer":
      return !!e.charts?.length;
    case "SubtypeGroupLayer":
      return !!e.layers.some((e2) => !!e2.charts?.length);
    case "SubtypeGroupTable":
      return !!e.tables.some((e2) => !!e2.charts?.length);
    case "CatalogLayer":
      return !!e.footprintLayer?.charts?.length;
  }
}
function ee(e, r) {
  let a = 0, t = 0, n2 = 0, s2 = 0;
  for (const o2 of [...r.layers, ...r.tables]) if (Z(o2) && s2++, "layerType" in o2) switch (o2.layerType) {
    case "OrientedImageryLayer":
      a++;
      break;
    case "SubtypeGroupLayer":
      t++;
      break;
    case "SubtypeGroupTable":
      n2++;
  }
  u(e, E.ORIENTED_IMAGERY_LAYER, a > 0), u(e, E.SUBTYPE_GROUP_LAYER, t > 0), u(e, E.SUBTYPE_GROUP_TABLE, n2 > 0), u(e, E.CHARTS, s2 > 0);
}
function re(e, r, a) {
  c(r, E.METADATA), u(r, E.MULTI_LAYER, e.length > 1), u(r, E.SINGLE_LAYER, 1 === e.length), u(r, E.TABLE, a.tables.length > 0 && 0 === a.layers.length), ee(r, a);
}
async function ae(e, r, a) {
  ee(r, a);
}
async function te(e, r, a) {
  const { url: t, layerId: n2, title: s2, fullExtent: o2, isTable: l3 } = e, i2 = p(t);
  r.url = ("FeatureServer" === i2?.serverType ? t : `${t}/${n2}`) ?? null, r.title ||= s2, r.extent = null, l3 || null == o2 || (r.extent = await l2(o2)), re([e], r, a);
}
function ne(e, r) {
  for (const o2 of e) {
    const a2 = o2.parsedUrl.path, n3 = p(a2), s3 = n3?.url.path;
    if (!s3) throw new s(`${r}:invalid-parameters`, m(o2, `has unsupported url pattern: ${a2}`), { layer: o2 });
    const l3 = n3?.serverType;
    if ("FeatureServer" !== l3 && "MapServer" !== l3) throw new s(`${r}:invalid-parameters`, m(o2, `has unsupported server type: ${l3}`), { layer: o2 });
    if ("MapServer" === l3 && e.length > 1) throw new s(`${r}:invalid-parameters`, "Only one layer or table in a map service can be saved");
  }
  const a = p(e[0].parsedUrl.path), n2 = a?.url.path, s2 = e.every((e2) => {
    const r2 = p(e2.parsedUrl.path);
    return r2?.url.path === n2;
  });
  if (!s2) throw new s(`${r}:invalid-parameters`, "'layers' array should only contain layers or tables that belong to the same feature service");
}
async function se(e) {
  q(e, A), await Promise.all(e.map((e2) => e2.load()));
  for (const r of e) p2(r, A, x2);
  ne(e, A), W(e, A);
}
function oe(e, r) {
  ee(e, r), I(e);
}
async function le(e, r, t) {
  let n2 = 0;
  for (const { isTable: a } of e) a || n2++;
  const s2 = e[0].parsedUrl.path, o2 = p(s2);
  if (r.url = "FeatureServer" === o2?.serverType ? o2.url.path : s2, r.title ||= o2.title, r.extent = null, n2 > 0) {
    const t2 = e.map((e2) => e2.fullExtent).filter(L).reduce((e2, r2) => e2.clone().union(r2));
    t2 && (r.extent = await l2(t2));
  }
  re(e, r, t), I(r);
}
async function ie(e, r) {
  return P({ layer: e, itemType: I2, validateLayer: x2, createJSONContext: (r2) => N(r2, e), createItemData: (e2, r2) => J(r2, [e2]), errorNamePrefix: P2, setItemProperties: ae }, r);
}
async function ce(e, r) {
  await X(e);
  const a = e[0].portalItem, t = $2(a), s2 = await Promise.all(e.map((e2) => w(e2, e2.isTable ? t.forTables : t.forLayers, r))), o2 = await J(a, e.map((e2, r2) => ({ layer: e2, layerJSON: s2[r2] })));
  return oe(a, o2), await a.update({ data: o2 }), await Promise.all(e.slice(1).map((e2) => e2.portalItem.reload())), i(t.forLayers), i(t.forTables), a.clone();
}
async function ue(e, r, a) {
  return $({ layer: e, itemType: I2, validateLayer: x2, createJSONContext: (r2) => N(r2, e), createItemData: (e2, r2) => Promise.resolve(R(e2)), errorNamePrefix: E2, newItem: r, setItemProperties: te }, a);
}
async function ye(e, r, a) {
  await se(e);
  const t = d2({ itemType: I2, errorNamePrefix: A, newItem: r }), s2 = $2(t), o2 = await Promise.all(e.map((e2) => w(e2, e2.isTable ? s2.forTables : s2.forLayers, a))), u2 = await C(e.map((e2, r2) => ({ layer: e2, layerJSON: o2[r2] })));
  await le(e, t, u2), await v(t, u2, a);
  for (const n2 of e) n2.portalItem = t.clone();
  return i(s2.forLayers), i(s2.forTables), t;
}
export {
  ie as save,
  ce as saveAll,
  ye as saveAllAs,
  ue as saveAs
};
//# sourceMappingURL=featureLayerUtils-2CNJC43G.js.map
