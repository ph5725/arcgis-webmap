import {
  l
} from "./chunk-NJQ3IQ46.js";
import {
  l as l2
} from "./chunk-4QUGWCAY.js";
import {
  t as t2
} from "./chunk-JHOESKXH.js";
import {
  B,
  E,
  F,
  L as L2,
  N,
  R as R2,
  R2 as R3,
  a as a2,
  a2 as a3,
  b,
  c,
  e as e3,
  j as j2,
  k,
  p,
  q as q2
} from "./chunk-ANGM5VGL.js";
import "./chunk-WEBPFKVW.js";
import {
  p as p2
} from "./chunk-6HTDRV3E.js";
import "./chunk-W32FQSGL.js";
import {
  n
} from "./chunk-NICSGFR4.js";
import {
  O,
  u
} from "./chunk-WNIXFBZS.js";
import {
  D
} from "./chunk-4NNCML5U.js";
import "./chunk-YDAIRKJB.js";
import {
  j
} from "./chunk-XMAXGUBN.js";
import {
  $,
  G,
  K,
  Ke,
  L,
  Ne,
  Se,
  Te,
  X,
  _e,
  ae,
  ie,
  ne,
  pe,
  q,
  re,
  te
} from "./chunk-Q7K6M7G6.js";
import {
  s,
  x
} from "./chunk-EK343S5L.js";
import {
  t
} from "./chunk-4J6GMCJZ.js";
import "./chunk-VZZR2ZMJ.js";
import "./chunk-DKS7UUDR.js";
import "./chunk-KDQWOWXR.js";
import "./chunk-JOVQBCRD.js";
import {
  R
} from "./chunk-F5BDMX7A.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import "./chunk-2LU4NAEM.js";
import "./chunk-EUGUM3DF.js";
import {
  s as s2
} from "./chunk-NEBU5XJO.js";
import {
  Xe
} from "./chunk-KXFCAOWK.js";
import "./chunk-VGXBH5PT.js";
import "./chunk-ZUTXZ2PO.js";
import "./chunk-FSVG2RRX.js";
import "./chunk-L3O6KWVI.js";
import "./chunk-2SK5ARBZ.js";
import "./chunk-RNXMAHSA.js";
import "./chunk-VD4HSDHE.js";
import "./chunk-WBSGKMRV.js";
import "./chunk-SBFMUXL3.js";
import "./chunk-PZV6BOD6.js";
import "./chunk-DD7VYTDF.js";
import "./chunk-H7SHPX7W.js";
import "./chunk-WIICHW3C.js";
import "./chunk-T4BWGCN6.js";
import "./chunk-AC7GOP3F.js";
import "./chunk-XPKVLOAO.js";
import "./chunk-GESOBEYT.js";
import "./chunk-3IU6SQCC.js";
import "./chunk-E7YVYF37.js";
import "./chunk-E76L26GR.js";
import "./chunk-GG4VLKUY.js";
import "./chunk-IL45XPTT.js";
import "./chunk-6MFKAT6L.js";
import "./chunk-NOWX6W7R.js";
import "./chunk-OQ76WPLD.js";
import "./chunk-KSVHYEPS.js";
import "./chunk-YOMN3PFE.js";
import "./chunk-UTU6N7VJ.js";
import "./chunk-RV3SBM2C.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-KQINCOQL.js";
import "./chunk-B6C7UPBZ.js";
import "./chunk-IUQBXXYO.js";
import "./chunk-7WKBQS4R.js";
import "./chunk-SJHAGLIM.js";
import "./chunk-Z6OMEWWC.js";
import "./chunk-MULCOUFY.js";
import "./chunk-VGIEH4HM.js";
import "./chunk-XLF2NMGX.js";
import "./chunk-X5GD6LFD.js";
import "./chunk-G4PMFSAZ.js";
import "./chunk-MX5VW6PC.js";
import "./chunk-JJNHUYXK.js";
import "./chunk-UG6RJXJ2.js";
import "./chunk-OTCYHWWG.js";
import "./chunk-UDSZVLDS.js";
import "./chunk-UGXCZZ7N.js";
import "./chunk-OTSYE6UT.js";
import "./chunk-K5LVZUBF.js";
import "./chunk-J7LSFQNH.js";
import "./chunk-AGDHKBKD.js";
import "./chunk-OC2XWDW2.js";
import "./chunk-C3JHRSMA.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-HUVZEBBO.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-I6IIPG56.js";
import "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import {
  h
} from "./chunk-NY6S6EMV.js";
import {
  a,
  e,
  o,
  r
} from "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-YSCIEMYQ.js";
import "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import "./chunk-5GBXHGKW.js";
import "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import {
  m
} from "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-SYPTUUSZ.js";
import "./chunk-L7EN54WK.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-F4KXGA4J.js";
import "./chunk-KHRHKYU2.js";
import {
  d
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import {
  e as e2,
  o as o2,
  r as r2
} from "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import "./chunk-HCYE6OE4.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import {
  C
} from "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import "./chunk-N3XLUQJI.js";
import "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  S
} from "./chunk-GZ2P4SCJ.js";
import "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function oe(e4) {
  if (1 === e4.length) {
    if (o2(e4[0])) return l("distinct", e4[0], -1);
    if (te(e4[0])) return l("distinct", e4[0].toArray(), -1);
  }
  return l("distinct", e4, -1);
}
function se(e4, t3, n2) {
  const i = e4.getVariables();
  if (i.length > 0) {
    const a4 = {};
    for (const e5 of i) a4[e5] = t3.evaluateIdentifier(n2, { name: e5 });
    e4.parameters = a4;
  }
  return e4;
}
function le(e4, t3, n2 = null) {
  for (const i in e4) if (i.toLowerCase() === t3.toLowerCase()) return e4[i];
  return n2;
}
function fe(e4) {
  if (null === e4) return null;
  const t3 = { type: le(e4, "type", ""), name: le(e4, "name", "") };
  if ("range" === t3.type) t3.range = le(e4, "range", []);
  else {
    t3.codedValues = [];
    for (const n2 of le(e4, "codedValues", [])) t3.codedValues.push({ name: le(n2, "name", ""), code: le(n2, "code", null) });
  }
  return t3;
}
function de(e4) {
  if (null === e4) return null;
  const t3 = {}, n2 = le(e4, "wkt");
  null !== n2 && (t3.wkt = n2);
  const i = le(e4, "wkid");
  return null !== i && (t3.wkid = i), t3;
}
function ue(e4) {
  if (null === e4) return null;
  const t3 = { hasZ: le(e4, "hasz", false), hasM: le(e4, "hasm", false) }, n2 = le(e4, "spatialreference");
  null != n2 && (t3.spatialReference = de(n2));
  const i = le(e4, "x", null);
  if (null !== i) return t3.x = i, t3.y = le(e4, "y", null), t3.hasZ && (t3.z = le(e4, "z", null)), t3.hasM && (t3.m = le(e4, "m", null)), t3;
  const a4 = le(e4, "rings", null);
  if (null !== a4) return t3.rings = a4, t3;
  const r3 = le(e4, "paths", null);
  if (null !== r3) return t3.paths = r3, t3;
  const o3 = le(e4, "points", null);
  if (null !== o3) return t3.points = o3, t3;
  for (const s3 of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n3 = le(e4, s3, null);
    null !== n3 && (t3[s3] = n3);
  }
  return t3;
}
function ce(e4, t3) {
  for (const n2 of t3) if (n2 === e4) return true;
  return false;
}
function me(e4) {
  return !!e4.layerDefinition && (!!e4.featureSet && (false !== ce(e4.layerDefinition.geometryType, ["", null, "esriGeometryNull", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (false !== o2(e4.layerDefinition.fields) && false !== o2(e4.featureSet.features))));
}
function pe2(e4) {
  return "utc" === e4?.toLowerCase() ? "UTC" : "unknown" === e4?.toLowerCase() ? "Unknown" : e4;
}
async function ye(t3, n2, i, a4, r3, l3, f) {
  const d2 = await t3.getFeatureSetInfo();
  if (null === (d2?.layerId ?? null)) return null;
  if (!r3.layerIdLookup.get(d2.layerId)) return null;
  const c2 = t3.serviceUrl().replace(/\/FeatureServer/i, "/UtilityNetworkServer"), m2 = [];
  switch (i) {
    case "connected":
      m2.push("connectivity"), m2.push("junction-edge-from-connectivity"), m2.push("junction-edge-to-connectivity"), m2.push("junction-edge-midspan-connectivity"), m2.push("junction-junction-connectivity");
      break;
    case "container":
    case "content":
      m2.push("containment");
      break;
    case "structure":
    case "attached":
      m2.push("attachment");
      break;
    case "junctionedge":
      m2.push("junction-edge-from-connectivity"), m2.push("junction-edge-to-connectivity");
      break;
    case "midspan":
      m2.push("junction-edge-midspan-connectivity");
      break;
    default:
      throw new a(l3, r.InvalidParameter, f);
  }
  let p3 = null, y = false;
  if (null !== a4 && "" !== a4 && void 0 !== a4) {
    for (const e4 of r3.terminals) e4.terminalName === a4 && (p3 = e4.terminalId);
    null === p3 && (y = true);
  }
  const w = [];
  if (!y) {
    const a5 = new s2({ globalId: n2.field(t3.globalIdField), networkSourceId: r3.layerIdLookup.get(d2.layerId).sourceId, ...p3 ? { terminalId: p3 } : "" }), o3 = await p2(c2, new n({ types: m2, elements: [a5] }));
    let s3 = 0;
    for (const t4 of o3.associations) {
      let n3 = null, o4 = "", l4 = "";
      if (t4.fromNetworkElement?.globalId === a5.globalId ? (n3 = t4.toNetworkElement, l4 = "to") : t4.toNetworkElement?.globalId === a5.globalId && (n3 = t4.fromNetworkElement, l4 = "from"), !n3) continue;
      switch (i) {
        case "attached":
          if ("attachment" !== t4.associationType) continue;
          if ("to" !== l4) continue;
          break;
        case "structure":
          if ("attachment" !== t4.associationType) continue;
          if ("from" !== l4) continue;
          break;
        case "container":
          if ("containment" !== t4.associationType) continue;
          if ("from" !== l4) continue;
          break;
        case "content":
          if ("containment" !== t4.associationType) continue;
          if ("to" !== l4) continue;
          break;
        case "connected":
          break;
        case "junctionedge":
          "junction-edge-to-connectivity" === t4.associationType ? o4 = "to" : "junction-edge-from-connectivity" === t4.associationType && (o4 = "from");
          break;
        case "midspan":
          if ("junction-edge-midspan-connectivity" !== t4.associationType) continue;
      }
      const f2 = r3.sourceIdLookup.get(n3.networkSourceId)?.className ?? "";
      w.push(new d({ geometry: null, attributes: { objectId: s3++, globalId: n3.globalId, percentAlong: t4.percentAlong ?? 0, isContentVisible: t4.isContentVisible ? 0 : 1, className: f2, side: o4 } }));
    }
  }
  const I = new Xe({ source: w, geometryType: null, objectIdField: "objectId", globalIdField: "globalId", fields: [new m({ name: "objectId", alias: "objectId", type: "oid" }), new m({ name: "globalId", alias: "globalId", type: "global-id" }), new m({ name: "percentAlong", alias: "percentAlong", type: "double" }), new m({ name: "side", alias: "side", type: "string" }), new m({ name: "isContentVisible", alias: "isContentVisible", type: "integer" }), new m({ name: "className", alias: "className", type: "string" })] });
  return N(I);
}
function we(e4) {
  if ("async" === e4.mode) {
    e4.functions.timezone = function(n2, a4) {
      return e4.standardFunctionAsync(n2, a4, async (e5, r3, l3) => {
        if (ae(l3, 1, 2, n2, a4), ie(l3[0])) return "Unknown";
        if (re(l3[0])) return "Unknown";
        if (K(l3[0])) {
          if (await l3[0].load(), 1 === l3.length || null === l3[1]) return l3[0].datesInUnknownTimezone ? pe2("unknown") : pe2(l3[0].dateFieldsTimeZone);
          if (!(l3[1] instanceof j) || false === l3[1].hasField("type")) throw new a(n2, r.InvalidParameter, a4);
          const e6 = l3[1].field("type");
          if (false === e2(e6)) throw new a(n2, r.InvalidParameter, a4);
          switch (pe(e6).toLowerCase()) {
            case "preferredtimezone":
              return pe2(l3[0].preferredTimeZone);
            case "editfieldsinfo":
              return pe2(l3[0].editFieldsInfo?.timeZone ?? null);
            case "timeinfo":
              return pe2(l3[0].timeInfo?.timeZone ?? null);
            case "field":
              if (l3[1].hasField("fieldname") && e2(l3[1].field("fieldname"))) return pe2(l3[0].fieldTimeZone(pe(l3[1].field("fieldname"))));
          }
          throw new a(n2, r.InvalidParameter, a4);
        }
        const f = Se(l3[0], Ke(n2));
        if (null === f) return null;
        const d2 = f.timeZone;
        return "system" === d2 ? h.systemTimeZoneCanonicalName : "utc" === d2.toLowerCase() ? "UTC" : "unknown" === d2.toLowerCase() ? "Unknown" : d2;
      });
    }, e4.functions.sqltimestamp = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, i, a4) => {
        ae(a4, 1, 3, t3, n2);
        const r3 = a4[0];
        if (ne(r3)) {
          if (1 === a4.length) return r3.toSQLWithKeyword();
          if (2 === a4.length) return r3.changeTimeZone(pe(a4[1])).toSQLWithKeyword();
          throw new a(t3, r.InvalidParameter, n2);
        }
        if (re(r3)) return r3.toSQLWithKeyword();
        if (K(r3)) {
          if (3 !== a4.length) throw new a(t3, r.InvalidParameter, n2);
          await r3.load();
          const e6 = pe(a4[1]);
          if (re(a4[2])) return a4[2].toSQLWithKeyword();
          if (false === ne(a4[2])) throw new a(t3, r.InvalidParameter, n2);
          const i2 = r3.fieldTimeZone(e6);
          return null == i2 ? a4[2].toSQLWithKeyword() : a4[2].changeTimeZone(i2).toSQLWithKeyword();
        }
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "sqltimestamp", min: 2, max: 4 }), e4.functions.featuresetbyid = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, (e5, i, a4) => {
        if (ae(a4, 2, 4, t3, n2), X(a4[0])) {
          const e6 = pe(a4[1]);
          let i2 = q(a4[2], null);
          const r3 = Te(q(a4[3], true));
          if (null === i2 && (i2 = ["*"]), false === o2(i2)) throw new a(t3, r.InvalidParameter, n2);
          return a4[0].featureSetById(e6, r3, i2);
        }
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "featuresetbyid", min: 2, max: 4 });
    const K2 = new e(["datasource", "parent", "root"]);
    e4.functions.getfeatureset = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, i, a4) => {
        if (ae(a4, 1, 2, t3, n2), $(a4[0])) {
          const e6 = null == a4[1] ? "datasource" : K2.lookup(pe(a4[1]));
          return R3(a4[0].fullSchema(), e6, t3.lrucache, t3.interceptor, t3.spatialReference);
        }
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "getfeatureset", min: 1, max: 2 }), e4.functions.featuresetbyportalitem = function(t3, i) {
      return e4.standardFunctionAsync(t3, i, (e5, a4, r3) => {
        if (ae(r3, 2, 5, t3, i), null === r3[0]) throw new a(t3, r.PortalRequired, i);
        if (r3[0] instanceof t2) {
          const e6 = pe(r3[1]), n2 = pe(r3[2]);
          let a5 = q(r3[3], null);
          const l4 = Te(q(r3[4], true));
          if (null === a5 && (a5 = ["*"]), false === o2(a5)) throw new a(t3, r.InvalidParameter, i);
          let f2;
          return f2 = t3.services?.portal ? t3.services.portal : C.getDefault(), f2 = l2(r3[0], f2), q2(e6, n2, t3.spatialReference, a5, l4, f2, t3.lrucache, t3.interceptor);
        }
        if (false === e2(r3[0])) throw new a(t3, r.PortalRequired, i);
        const l3 = pe(r3[0]), f = pe(r3[1]);
        let u2 = q(r3[2], null);
        const c2 = Te(q(r3[3], true));
        if (null === u2 && (u2 = ["*"]), false === o2(u2)) throw new a(t3, r.InvalidParameter, i);
        return q2(l3, f, t3.spatialReference, u2, c2, t3.services?.portal ?? C.getDefault(), t3.lrucache, t3.interceptor);
      });
    }, e4.signatures.push({ name: "featuresetbyportalitem", min: 2, max: 5 }), e4.functions.featuresetbyname = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, (e5, i, a4) => {
        if (ae(a4, 2, 4, t3, n2), X(a4[0])) {
          const e6 = pe(a4[1]);
          let i2 = q(a4[2], null);
          const r3 = Te(q(a4[3], true));
          if (null === i2 && (i2 = ["*"]), false === o2(i2)) throw new a(t3, r.InvalidParameter, n2);
          return a4[0].featureSetByName(e6, r3, i2);
        }
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "featuresetbyname", min: 2, max: 4 }), e4.functions.featureset = function(t3, n2) {
      return e4.standardFunction(t3, n2, (e5, a4, r3) => {
        ae(r3, 1, 1, t3, n2);
        const l3 = { layerDefinition: { geometryType: "", objectIdField: "", globalIdField: "", typeIdField: "", hasM: false, hasZ: false, fields: [] }, featureSet: { geometryType: "", features: [] } };
        if (e2(r3[0])) {
          const e6 = JSON.parse(r3[0]);
          void 0 !== e6.layerDefinition ? (l3.layerDefinition = e6.layerDefinition, l3.featureSet = e6.featureSet, e6.layerDefinition.spatialReference && (l3.layerDefinition.spatialReference = e6.layerDefinition.spatialReference)) : (l3.featureSet.features = e6.features, l3.featureSet.geometryType = e6.geometryType, l3.layerDefinition.geometryType = l3.featureSet.geometryType, l3.layerDefinition.objectIdField = e6.objectIdFieldName ?? "", l3.layerDefinition.typeIdField = e6.typeIdFieldName, l3.layerDefinition.globalIdField = e6.globalIdFieldName, l3.layerDefinition.fields = e6.fields, e6.spatialReference && (l3.layerDefinition.spatialReference = e6.spatialReference));
        } else {
          if (!(r3[0] instanceof j)) throw new a(t3, r.InvalidParameter, n2);
          {
            const e6 = JSON.parse(r3[0].castToText(true)), i = le(e6, "layerdefinition");
            if (null !== i) {
              l3.layerDefinition.geometryType = le(i, "geometrytype", ""), l3.featureSet.geometryType = l3.layerDefinition.geometryType, l3.layerDefinition.globalIdField = le(i, "globalidfield", ""), l3.layerDefinition.objectIdField = le(i, "objectidfield", ""), l3.layerDefinition.typeIdField = le(i, "typeidfield", ""), l3.layerDefinition.hasZ = true === le(i, "hasz", false), l3.layerDefinition.hasM = true === le(i, "hasm", false);
              const t4 = le(i, "spatialreference");
              t4 && (l3.layerDefinition.spatialReference = de(t4));
              const n3 = [];
              for (const e7 of le(i, "fields", [])) {
                const t5 = { name: le(e7, "name", ""), alias: le(e7, "alias", ""), type: le(e7, "type", ""), nullable: le(e7, "nullable", true), editable: le(e7, "editable", true), length: le(e7, "length", null), domain: fe(le(e7, "domain")) };
                n3.push(t5);
              }
              l3.layerDefinition.fields = n3;
              const a5 = le(e6, "featureset");
              if (a5) {
                const e7 = {};
                for (const t5 of n3) e7[t5.name.toLowerCase()] = t5.name;
                for (const t5 of le(a5, "features", [])) {
                  const n4 = {}, i2 = le(t5, "attributes", {});
                  for (const t6 in i2) n4[e7[t6.toLowerCase()]] = i2[t6];
                  l3.featureSet.features.push({ attributes: n4, geometry: ue(le(t5, "geometry")) });
                }
              }
            } else {
              l3.layerDefinition.hasZ = true === le(e6, "hasz", false), l3.layerDefinition.hasM = true === le(e6, "hasm", false), l3.layerDefinition.geometryType = le(e6, "geometrytype", ""), l3.featureSet.geometryType = l3.layerDefinition.geometryType, l3.layerDefinition.objectIdField = le(e6, "objectidfieldname", ""), l3.layerDefinition.typeIdField = le(e6, "typeidfieldname", "");
              const i2 = le(e6, "spatialreference");
              i2 && (l3.layerDefinition.spatialReference = de(i2));
              const a5 = [], r4 = le(e6, "fields", null);
              if (!o2(r4)) throw new a(t3, r.InvalidParameter, n2);
              for (const e7 of r4) {
                const t4 = { name: le(e7, "name", ""), alias: le(e7, "alias", ""), type: le(e7, "type", ""), nullable: le(e7, "nullable", true), editable: le(e7, "editable", true), length: le(e7, "length", null), domain: fe(le(e7, "domain")) };
                a5.push(t4);
              }
              l3.layerDefinition.fields = a5;
              const f = {};
              for (const e7 of a5) f[e7.name.toLowerCase()] = e7.name;
              let d2 = le(e6, "features", null);
              if (o2(d2)) for (const e7 of d2) {
                const t4 = {}, n3 = le(e7, "attributes", {});
                for (const e8 in n3) t4[f[e8.toLowerCase()]] = n3[e8];
                l3.featureSet.features.push({ attributes: t4, geometry: ue(le(e7, "geometry", null)) });
              }
              else d2 = null, l3.featureSet.features = d2;
            }
          }
        }
        if (false === me(l3)) throw new a(t3, r.InvalidParameter, n2);
        return l3.layerDefinition.geometryType || (l3.layerDefinition.geometryType = "esriGeometryNull"), p.create(l3, t3.spatialReference);
      });
    }, e4.signatures.push({ name: "featureset", min: 1, max: 1 }), e4.functions.filter = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (i, a4, r3) => {
        if (ae(r3, 2, 2, t3, n2), o2(r3[0]) || te(r3[0])) {
          const e5 = [];
          let i2, a5 = r3[0];
          if (a5 instanceof t && (a5 = a5.toArray()), !G(r3[1])) throw new a(t3, r.InvalidParameter, n2);
          i2 = r3[1].createFunction(t3);
          for (const t4 of a5) {
            const n3 = i2(t4);
            S(n3) ? true === await n3 && e5.push(t4) : true === n3 && e5.push(t4);
          }
          return e5;
        }
        if (K(r3[0])) {
          const n3 = await r3[0].load(), i2 = R.create(r3[1], { fieldsIndex: n3.getFieldsIndex(), timeZone: n3.dateFieldsTimeZoneDefaultUTC }), a5 = i2.getVariables();
          if (a5.length > 0) {
            const n4 = {};
            for (const i3 of a5) n4[i3] = e4.evaluateIdentifier(t3, { name: i3 });
            i2.parameters = n4;
          }
          return new c({ parentfeatureset: r3[0], whereclause: i2 });
        }
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "filter", min: 2, max: 2 }), e4.functions.orderby = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, i, a4) => {
        if (ae(a4, 2, 2, t3, n2), K(a4[0])) {
          const e6 = new e3(a4[1]);
          return new a2({ parentfeatureset: a4[0], orderbyclause: e6 });
        }
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "orderby", min: 2, max: 2 }), e4.functions.top = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, i, a4) => {
        if (ae(a4, 2, 2, t3, n2), K(a4[0])) return new a3({ parentfeatureset: a4[0], topnum: a4[1] });
        if (o2(a4[0])) return Ne(a4[1]) >= a4[0].length ? a4[0].slice() : a4[0].slice(0, Ne(a4[1]));
        if (te(a4[0])) return Ne(a4[1]) >= a4[0].length() ? a4[0].slice() : a4[0].slice(0, Ne(a4[1]));
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "top", min: 2, max: 2 }), e4.functions.first = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, i, a4) => {
        if (ae(a4, 1, 1, t3, n2), K(a4[0])) {
          const n3 = await a4[0].first(e5.abortSignal);
          if (null !== n3) {
            const e6 = D.createFromGraphicLikeObject(n3.geometry, n3.attributes, a4[0], t3.timeZone);
            return e6._underlyingGraphic = n3, e6;
          }
          return n3;
        }
        return o2(a4[0]) ? 0 === a4[0].length ? null : a4[0][0] : te(a4[0]) ? 0 === a4[0].length() ? null : a4[0].get(0) : null;
      });
    }, e4.signatures.push({ name: "first", min: 1, max: 1 }), e4.functions.attachments = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, a4, r3) => {
        ae(r3, 1, 2, t3, n2);
        const l3 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
        if (r3.length > 1) {
          if (r3[1] instanceof j) {
            if (r3[1].hasField("minsize") && (l3.minsize = Ne(r3[1].field("minsize"))), r3[1].hasField("metadata") && (l3.returnMetadata = Te(r3[1].field("metadata"))), r3[1].hasField("maxsize") && (l3.maxsize = Ne(r3[1].field("maxsize"))), r3[1].hasField("types")) {
              const e6 = _e(r3[1].field("types"), false);
              e6.length > 0 && (l3.types = e6);
            }
          } else if (null !== r3[1]) throw new a(t3, r.InvalidParameter, n2);
        }
        if ($(r3[0])) {
          const e6 = r3[0]._layer;
          let n3;
          if (K(e6)) n3 = e6;
          else {
            if (null == e6 || !x(e6)) return [];
            n3 = N(e6, t3.spatialReference, ["*"], true, t3.lrucache, t3.interceptor);
          }
          return await n3.load(), n3.queryAttachments(r3[0].field(n3.objectIdField), l3.minsize, l3.maxsize, l3.types, l3.returnMetadata);
        }
        if (null === r3[0]) return [];
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "attachments", min: 1, max: 2 }), e4.functions.featuresetbyrelationshipname = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, i, a4) => {
        ae(a4, 2, 4, t3, n2);
        const r3 = a4[0], l3 = pe(a4[1]);
        let f = q(a4[2], null);
        const d2 = Te(q(a4[3], true));
        if (null === f && (f = ["*"]), false === o2(f)) throw new a(t3, r.InvalidParameter, n2);
        if (null === a4[0]) return null;
        if (!$(a4[0])) throw new a(t3, r.InvalidParameter, n2);
        const p3 = r3._layer;
        let y;
        if (K(p3)) y = p3;
        else {
          if (null == p3 || !x(p3)) return null;
          y = N(p3, t3.spatialReference, ["*"], true, t3.lrucache, t3.interceptor);
        }
        y = await y.load();
        const I = y.relationshipMetaData().filter((e6) => e6.name === l3);
        if (0 === I.length) return null;
        if (void 0 !== I[0].relationshipTableId && null !== I[0].relationshipTableId && I[0].relationshipTableId > -1) return j2(y, I[0], r3.field(y.objectIdField), y.spatialReference, f, d2, t3.lrucache, t3.interceptor);
        let h2 = y.serviceUrl();
        if (!h2) return null;
        h2 = "/" === h2.charAt(h2.length - 1) ? h2 + I[0].relatedTableId.toString() : h2 + "/" + I[0].relatedTableId.toString();
        const b2 = await F(h2, y.spatialReference, f, d2, t3.lrucache, t3.interceptor);
        await b2.load();
        let T = b2.relationshipMetaData();
        if (T = T.filter((e6) => e6.id === I[0].id), false === r3.hasField(I[0].keyField) || null === r3.field(I[0].keyField)) {
          const e6 = await y.getFeatureByObjectId(r3.field(y.objectIdField), [I[0].keyField]);
          if (e6) {
            const t4 = R.create(T[0].keyField + "= @id", { fieldsIndex: b2.getFieldsIndex(), timeZone: b2.dateFieldsTimeZoneDefaultUTC });
            return t4.parameters = { id: e6.attributes[I[0].keyField] }, b2.filter(t4);
          }
          return new u({ parentfeatureset: b2 });
        }
        const D2 = R.create(T[0].keyField + "= @id", { fieldsIndex: b2.getFieldsIndex(), timeZone: b2.dateFieldsTimeZoneDefaultUTC });
        return D2.parameters = { id: r3.field(I[0].keyField) }, b2.filter(D2);
      });
    }, e4.signatures.push({ name: "featuresetbyrelationshipname", min: 2, max: 4 }), e4.functions.featuresetbyassociation = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, i, a4) => {
        ae(a4, 2, 3, t3, n2);
        const l3 = a4[0], f = o(pe(q(a4[1], ""))), d2 = e2(a4[2]) ? pe(a4[2]) : null;
        if (null === a4[0]) return null;
        if (!$(a4[0])) throw new a(t3, r.InvalidParameter, n2);
        let c2 = l3._layer;
        if (c2 instanceof Xe && (c2 = N(c2, t3.spatialReference, ["*"], true, t3.lrucache, t3.interceptor)), null === c2) return null;
        if (false === K(c2)) return null;
        await c2.load();
        const m2 = c2.serviceUrl(), y = await E(m2, t3.spatialReference, true);
        if (y.unVersion >= 8) return await ye(c2, l3, f, d2, y, t3, n2);
        const I = y.associations;
        let h2 = null, b2 = null, T = false;
        if (null !== d2 && "" !== d2 && void 0 !== d2) {
          for (const e6 of y.terminals) e6.terminalName === d2 && (b2 = e6.terminalId);
          null === b2 && (T = true);
        }
        const D2 = I.getFieldsIndex(), x2 = D2.get("TOGLOBALID").name, N2 = D2.get("FROMGLOBALID").name, v = D2.get("TOTERMINALID").name, S2 = D2.get("FROMTERMINALID").name, L3 = D2.get("FROMNETWORKSOURCEID").name, j3 = D2.get("TONETWORKSOURCEID").name, k2 = D2.get("ASSOCIATIONTYPE").name, R4 = D2.get("ISCONTENTVISIBLE").name, O2 = D2.get("OBJECTID").name;
        for (const t4 of c2.fields) if ("global-id" === t4.type) {
          h2 = l3.field(t4.name);
          break;
        }
        let z = null, H = new L2(new m({ name: "percentalong", alias: "percentalong", type: "double" }), R.create("0", { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC })), W = new L2(new m({ name: "side", alias: "side", type: "string" }), R.create("''", { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }));
        const G2 = "globalid", V = "globalId", B2 = {};
        for (const t4 in y.lkp) B2[t4] = y.lkp[t4].sourceId;
        const K3 = new B(new m({ name: "classname", alias: "classname", type: "string" }), null, B2);
        let q3 = "";
        switch (f) {
          case "midspan": {
            q3 = `((${x2}='${h2}') OR ( ${N2}='${h2}')) AND (${k2} IN (5))`, K3.codefield = R.create(`CASE WHEN (${x2}='${h2}') THEN ${L3} ELSE ${j3} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC });
            const e6 = s(R2.findField(I.fields, N2));
            e6.name = G2, e6.alias = G2, z = new L2(e6, R.create(`CASE WHEN (${N2}='${h2}') THEN ${x2} ELSE ${N2} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC })), H = y.unVersion >= 4 ? new k(R2.findField(I.fields, D2.get("PERCENTALONG").name)) : new L2(new m({ name: "percentalong", alias: "percentalong", type: "double" }), R.create("0", { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }));
            break;
          }
          case "junctionedge": {
            q3 = `((${x2}='${h2}') OR ( ${N2}='${h2}')) AND (${k2} IN (4,6))`, K3.codefield = R.create(`CASE WHEN (${x2}='${h2}') THEN ${L3} ELSE ${j3} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC });
            const e6 = s(R2.findField(I.fields, N2));
            e6.name = G2, e6.alias = G2, z = new L2(e6, R.create(`CASE WHEN (${N2}='${h2}') THEN ${x2} ELSE ${N2} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC })), W = new L2(new m({ name: "side", alias: "side", type: "string" }), R.create(`CASE WHEN (${k2}=4) THEN 'from' ELSE 'to' END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }));
            break;
          }
          case "connected": {
            let e6 = `${x2}='@T'`, t4 = `${N2}='@T'`;
            null !== b2 && (e6 += ` AND ${v}=@A`, t4 += ` AND ${S2}=@A`), q3 = "((" + e6 + ") OR (" + t4 + "))", q3 = L(q3, "@T", h2 ?? ""), e6 = L(e6, "@T", h2 ?? ""), null !== b2 && (e6 = L(e6, "@A", b2.toString()), q3 = L(q3, "@A", b2.toString())), K3.codefield = R.create("CASE WHEN " + e6 + ` THEN ${L3} ELSE ${j3} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC });
            const n3 = s(R2.findField(I.fields, N2));
            n3.name = G2, n3.alias = G2, z = new L2(n3, R.create("CASE WHEN " + e6 + ` THEN ${N2} ELSE ${x2} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }));
            break;
          }
          case "container":
            q3 = `${x2}='${h2}' AND ${k2} = 2`, null !== b2 && (q3 += ` AND ${v} = ` + b2.toString()), K3.codefield = L3, q3 = "( " + q3 + " )", z = new b(R2.findField(I.fields, N2), G2, G2);
            break;
          case "content":
            q3 = `(${N2}='${h2}' AND ${k2} = 2)`, null !== b2 && (q3 += ` AND ${S2} = ` + b2.toString()), K3.codefield = j3, q3 = "( " + q3 + " )", z = new b(R2.findField(I.fields, x2), G2, G2);
            break;
          case "structure":
            q3 = `(${x2}='${h2}' AND ${k2} = 3)`, null !== b2 && (q3 += ` AND ${v} = ` + b2.toString()), K3.codefield = L3, q3 = "( " + q3 + " )", z = new b(R2.findField(I.fields, N2), G2, V);
            break;
          case "attached":
            q3 = `(${N2}='${h2}' AND ${k2} = 3)`, null !== b2 && (q3 += ` AND ${S2} = ` + b2.toString()), K3.codefield = j3, q3 = "( " + q3 + " )", z = new b(R2.findField(I.fields, x2), G2, V);
            break;
          default:
            throw new a(t3, r.InvalidParameter, n2);
        }
        T && (q3 = "1 <> 1");
        return new R2({ parentfeatureset: I, adaptedFields: [new k(R2.findField(I.fields, O2)), new k(R2.findField(I.fields, R4)), z, W, K3, H], extraFilter: q3 ? R.create(q3, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }) : null });
      });
    }, e4.signatures.push({ name: "featuresetbyassociation", min: 2, max: 6 }), e4.functions.groupby = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (a4, r3, l3) => {
        if (ae(l3, 3, 3, t3, n2), !K(l3[0])) throw new a(t3, r.InvalidParameter, n2);
        const f = await l3[0].load(), d2 = [], u2 = [];
        let c2 = false, m2 = [];
        if (e2(l3[1])) m2.push(l3[1]);
        else if (l3[1] instanceof j) m2.push(l3[1]);
        else if (o2(l3[1])) m2 = l3[1];
        else {
          if (!te(l3[1])) throw new a(t3, r.InvalidParameter, n2);
          m2 = l3[1].toArray();
        }
        for (const e5 of m2) if (e2(e5)) {
          const t4 = R.create(pe(e5), { fieldsIndex: f.getFieldsIndex(), timeZone: f.dateFieldsTimeZoneDefaultUTC }), n3 = true === O(t4) ? pe(e5) : "%%%%FIELDNAME";
          d2.push({ name: n3, expression: t4 }), "%%%%FIELDNAME" === n3 && (c2 = true);
        } else {
          if (!(e5 instanceof j)) throw new a(t3, r.InvalidParameter, n2);
          {
            const i = e5.hasField("name") ? e5.field("name") : "%%%%FIELDNAME", a5 = e5.hasField("expression") ? e5.field("expression") : "";
            if ("%%%%FIELDNAME" === i && (c2 = true), !i) throw new a(t3, r.InvalidParameter, n2);
            d2.push({ name: i, expression: R.create(a5 || i, { fieldsIndex: f.getFieldsIndex(), timeZone: f.dateFieldsTimeZoneDefaultUTC }) });
          }
        }
        if (m2 = [], e2(l3[2])) m2.push(l3[2]);
        else if (o2(l3[2])) m2 = l3[2];
        else if (te(l3[2])) m2 = l3[2].toArray();
        else {
          if (!(l3[2] instanceof j)) throw new a(t3, r.InvalidParameter, n2);
          m2.push(l3[2]);
        }
        for (const e5 of m2) {
          if (!(e5 instanceof j)) throw new a(t3, r.InvalidParameter, n2);
          {
            const i = e5.hasField("name") ? e5.field("name") : "", a5 = e5.hasField("statistic") ? e5.field("statistic") : "", r4 = e5.hasField("expression") ? e5.field("expression") : "";
            if (!(i && a5 && e2(a5) && r4)) throw new a(t3, r.InvalidParameter, n2);
            u2.push({ name: i, statistic: a5, expression: R.create(r4, { fieldsIndex: f.getFieldsIndex(), timeZone: f.dateFieldsTimeZoneDefaultUTC }) });
          }
        }
        if (c2) {
          const e5 = {};
          for (const n3 of f.fields) e5[n3.name.toLowerCase()] = 1;
          for (const n3 of d2) "%%%%FIELDNAME" !== n3.name && (e5[n3.name.toLowerCase()] = 1);
          for (const n3 of u2) "%%%%FIELDNAME" !== n3.name && (e5[n3.name.toLowerCase()] = 1);
          let t4 = 0;
          for (const n3 of d2) if ("%%%%FIELDNAME" === n3.name) {
            for (; 1 === e5["field_" + t4.toString()]; ) t4++;
            e5["field_" + t4.toString()] = 1, n3.name = "FIELD_" + t4.toString();
          }
        }
        for (const n3 of d2) se(n3.expression, e4, t3);
        for (const n3 of u2) se(n3.expression, e4, t3);
        return l3[0].groupby(d2, u2);
      });
    }, e4.signatures.push({ name: "groupby", min: 3, max: 3 }), e4.functions.distinct = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (a4, r3, l3) => {
        if (K(l3[0])) {
          ae(l3, 2, 2, t3, n2);
          const a5 = await l3[0].load(), r4 = [];
          let f = [];
          if (e2(l3[1])) f.push(l3[1]);
          else if (l3[1] instanceof j) f.push(l3[1]);
          else if (o2(l3[1])) f = l3[1];
          else {
            if (!te(l3[1])) throw new a(t3, r.InvalidParameter, n2);
            f = l3[1].toArray();
          }
          let d2 = false;
          for (const e5 of f) if (e2(e5)) {
            const t4 = R.create(pe(e5), { fieldsIndex: a5.getFieldsIndex(), timeZone: a5.dateFieldsTimeZoneDefaultUTC }), n3 = true === O(t4) ? pe(e5) : "%%%%FIELDNAME";
            r4.push({ name: n3, expression: t4 }), "%%%%FIELDNAME" === n3 && (d2 = true);
          } else {
            if (!(e5 instanceof j)) throw new a(t3, r.InvalidParameter, n2);
            {
              const i = e5.hasField("name") ? e5.field("name") : "%%%%FIELDNAME", l4 = e5.hasField("expression") ? e5.field("expression") : "";
              if ("%%%%FIELDNAME" === i && (d2 = true), !i) throw new a(t3, r.InvalidParameter, n2);
              r4.push({ name: i, expression: R.create(l4 || i, { fieldsIndex: a5.getFieldsIndex(), timeZone: a5.dateFieldsTimeZoneDefaultUTC }) });
            }
          }
          if (d2) {
            const e5 = {};
            for (const n3 of a5.fields) e5[n3.name.toLowerCase()] = 1;
            for (const n3 of r4) "%%%%FIELDNAME" !== n3.name && (e5[n3.name.toLowerCase()] = 1);
            let t4 = 0;
            for (const n3 of r4) if ("%%%%FIELDNAME" === n3.name) {
              for (; 1 === e5["field_" + t4.toString()]; ) t4++;
              e5["field_" + t4.toString()] = 1, n3.name = "FIELD_" + t4.toString();
            }
          }
          for (const n3 of r4) se(n3.expression, e4, t3);
          return l3[0].groupby(r4, []);
        }
        return oe(l3);
      });
    }, e4.functions.getfeaturesetinfo = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, a4, r3) => {
        if (ae(r3, 1, 1, t3, n2), !K(r3[0])) return null;
        const o3 = await r3[0].getFeatureSetInfo();
        return o3 ? j.convertObjectToArcadeDictionary({ layerId: o3.layerId, layerName: o3.layerName, itemId: o3.itemId, serviceLayerUrl: o3.serviceLayerUrl, webMapLayerId: o3.webMapLayerId ?? null, webMapLayerTitle: o3.webMapLayerTitle ?? null, className: null, objectClassId: null }, Ke(t3), false, false) : null;
      });
    }, e4.signatures.push({ name: "getfeaturesetinfo", min: 1, max: 1 }), e4.functions.filterbysubtypecode = function(t3, n2) {
      return e4.standardFunctionAsync(t3, n2, async (e5, i, a4) => {
        if (ae(a4, 2, 2, t3, n2), K(a4[0])) {
          const e6 = await a4[0].load(), i2 = a4[1];
          if (!r2(i2)) throw new a(t3, r.InvalidParameter, n2);
          if (e6.subtypeField) {
            const t4 = R.create(`${e6.subtypeField}= ${a4[1]}`, { fieldsIndex: e6.getFieldsIndex(), timeZone: e6.dateFieldsTimeZoneDefaultUTC });
            return new c({ parentfeatureset: a4[0], whereclause: t4 });
          }
          if (null === e6.typeIdField || "" === e6.typeIdField) throw new a(t3, r.FeatureSetDoesNotHaveSubtypes, n2);
          const r3 = R.create(`${e6.typeIdField}= ${a4[1]}`, { fieldsIndex: e6.getFieldsIndex(), timeZone: e6.dateFieldsTimeZoneDefaultUTC });
          return new c({ parentfeatureset: a4[0], whereclause: r3 });
        }
        throw new a(t3, r.InvalidParameter, n2);
      });
    }, e4.signatures.push({ name: "filterbysubtypecode", min: 2, max: 2 });
  }
}
export {
  we as registerFunctions
};
//# sourceMappingURL=featuresetbase-C75TU3I6.js.map
