import {
  c as c2
} from "./chunk-ER6UH4AN.js";
import {
  t as t9
} from "./chunk-OIYN2A3E.js";
import {
  l as l9,
  t as t14,
  u as u9
} from "./chunk-P377W366.js";
import {
  n as n8,
  o as o6,
  v as v3
} from "./chunk-D7N3R33W.js";
import "./chunk-2H2JCT45.js";
import {
  D as D2,
  E as E6,
  _ as _5,
  e as e11,
  h as h6,
  h2 as h7,
  n as n9,
  p as p3,
  r as r7,
  r2 as r8,
  t as t12,
  y as y2
} from "./chunk-ZHRX45KN.js";
import "./chunk-625W4ZH5.js";
import "./chunk-OOBS22NY.js";
import {
  a as a6,
  c,
  h as h5,
  m as m5,
  u as u8
} from "./chunk-FY4QOUNB.js";
import {
  t as t13
} from "./chunk-ASO56N3T.js";
import "./chunk-KYHAK7RN.js";
import {
  O as O4
} from "./chunk-4PAILKIT.js";
import "./chunk-QYCJPZF2.js";
import {
  k as k2,
  o as o8,
  s as s8,
  t as t7,
  x as x2
} from "./chunk-G3V62EXP.js";
import "./chunk-MGE3DVJJ.js";
import "./chunk-A4YQJHJZ.js";
import {
  t as t10
} from "./chunk-JSDQVIZI.js";
import {
  e as e10,
  i as i7,
  m as m6,
  n as n7,
  t2 as t8
} from "./chunk-GEY3MNEN.js";
import {
  e as e9,
  n as n6
} from "./chunk-QARUBZM2.js";
import {
  n as n5
} from "./chunk-KRZJ7TLV.js";
import {
  R as R3,
  i as i6,
  s as s7
} from "./chunk-YEQJ7SMN.js";
import {
  e as e7,
  e2 as e8
} from "./chunk-F6HYAIOQ.js";
import {
  E as E5,
  o as o5
} from "./chunk-733XT7D4.js";
import "./chunk-O3AUTEBE.js";
import {
  y
} from "./chunk-2VE6IZP4.js";
import {
  l as l8
} from "./chunk-EGNOBZZN.js";
import "./chunk-3JKD2XXM.js";
import {
  r as r6
} from "./chunk-TUPNUSND.js";
import {
  t as t6
} from "./chunk-VZRBHAHT.js";
import "./chunk-73JRZP7E.js";
import {
  e as e4
} from "./chunk-I7SMTGBD.js";
import {
  d as d5,
  f as f6,
  p as p2
} from "./chunk-TAPCW5Z5.js";
import "./chunk-ORKTLG2L.js";
import "./chunk-JOUWZB2W.js";
import "./chunk-ZQPAEH56.js";
import "./chunk-SEPZOYEZ.js";
import "./chunk-L5FOMWCW.js";
import {
  L as L4
} from "./chunk-S4X4QGA7.js";
import "./chunk-CF5GNPLI.js";
import {
  t as t2
} from "./chunk-5WTH3GBK.js";
import "./chunk-N6WKHIKW.js";
import "./chunk-LHJOMFWG.js";
import {
  E as E2,
  d as d4
} from "./chunk-EOP2TXCS.js";
import "./chunk-IWFEA465.js";
import {
  t
} from "./chunk-5DVJFLIL.js";
import "./chunk-56ZY2WLU.js";
import "./chunk-A4KKV2O6.js";
import "./chunk-6EOJZ6DP.js";
import "./chunk-DRLVYVHZ.js";
import "./chunk-DKS7UUDR.js";
import {
  a as a2
} from "./chunk-6DARBDBU.js";
import "./chunk-KDQWOWXR.js";
import "./chunk-JOVQBCRD.js";
import "./chunk-2B6XECE5.js";
import "./chunk-GYAK76KG.js";
import "./chunk-XZOH57EG.js";
import "./chunk-QB5ST4HW.js";
import "./chunk-67CCONUO.js";
import "./chunk-CCHJ3WNU.js";
import {
  _
} from "./chunk-RD652CDC.js";
import "./chunk-P3YYANTX.js";
import {
  i as i5
} from "./chunk-NCLK6YLE.js";
import {
  e as e5,
  i2 as i4,
  n as n4,
  t as t3,
  t2 as t4,
  te
} from "./chunk-WKCCXG3E.js";
import {
  f as f5,
  g,
  l as l7,
  m as m4
} from "./chunk-ZWJOMK2U.js";
import "./chunk-Y2ZAHGIO.js";
import {
  f as f4,
  u as u7
} from "./chunk-ZCE5HP23.js";
import "./chunk-Y2QTREQA.js";
import {
  t as t5
} from "./chunk-OV7XVIQP.js";
import "./chunk-JQSXFLSD.js";
import {
  o as o4
} from "./chunk-H5K53FMS.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import {
  v as v2
} from "./chunk-XGWAEOLO.js";
import {
  i as i3
} from "./chunk-76QJRCNC.js";
import "./chunk-YL4WUSSA.js";
import "./chunk-AAC6XSCN.js";
import {
  c as c4,
  e as e12
} from "./chunk-NSTC2VR7.js";
import "./chunk-LYNZJBHM.js";
import "./chunk-SHYE33QH.js";
import "./chunk-LTMF2W73.js";
import "./chunk-VWMPQK5V.js";
import {
  c2 as c3,
  e as e6,
  o as o7,
  t2 as t11
} from "./chunk-IGBV77N3.js";
import "./chunk-5Y3EUPZN.js";
import "./chunk-55AFRDJF.js";
import "./chunk-F5C72MOD.js";
import "./chunk-YBXGYFQH.js";
import "./chunk-NFDUQVJM.js";
import "./chunk-2W7OT7Z4.js";
import {
  A as A3,
  E as E4
} from "./chunk-3PPDORWL.js";
import {
  h as h4
} from "./chunk-YIXK32VF.js";
import "./chunk-CHTPXQAG.js";
import "./chunk-2NTKYBCL.js";
import "./chunk-4ADC6HZF.js";
import {
  S as S2,
  a as a4,
  a2 as a5
} from "./chunk-H6F6O2KE.js";
import "./chunk-AF3FX2UV.js";
import {
  M as M2,
  b as b3,
  f as f3,
  h as h3,
  l as l5,
  m as m3
} from "./chunk-DRAQJS2F.js";
import {
  A as A2,
  B as B2,
  C,
  D,
  H as H2,
  L as L3,
  M as M3,
  O as O3,
  P as P2,
  R as R2,
  S,
  T as T2,
  V,
  X as X2,
  Y,
  _ as _4,
  e as e3
} from "./chunk-BZYXFNL4.js";
import {
  n as n3,
  r as r5
} from "./chunk-VNTS5E5O.js";
import {
  o as o2
} from "./chunk-TMFB3DKM.js";
import {
  P
} from "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-NO2XQDLB.js";
import {
  r as r4
} from "./chunk-LBC3MAJX.js";
import "./chunk-NMP7ZOVG.js";
import "./chunk-YHYQP7QX.js";
import {
  C as C2,
  Ci,
  E as E3,
  Ei,
  Fi,
  J as J2,
  S as S3,
  U as U3,
  Ui,
  W,
  X as X3,
  Y as Y2,
  ai,
  ei,
  oi,
  ti,
  u as u6,
  ui,
  wi
} from "./chunk-RP7FUW55.js";
import {
  a as a3
} from "./chunk-MPV4X4LZ.js";
import "./chunk-2JRCX6DU.js";
import {
  B,
  I,
  l as l6,
  o as o3
} from "./chunk-TNW4TPNP.js";
import "./chunk-IL45XPTT.js";
import {
  u as u5
} from "./chunk-J7LSFQNH.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-I6IIPG56.js";
import "./chunk-JEYXDNAT.js";
import {
  A,
  E,
  G,
  J,
  L as L2,
  M,
  N,
  O as O2,
  R,
  T,
  U as U2,
  X,
  Z,
  _ as _3,
  b as b2,
  d as d3,
  f as f2,
  h as h2,
  j as j2,
  k,
  o,
  p,
  q,
  v,
  x
} from "./chunk-DJJNSAUR.js";
import {
  n as n2
} from "./chunk-PZBXBPVO.js";
import {
  d as d2,
  i as i2,
  ne,
  s as s6
} from "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-RGFH75DR.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import "./chunk-7ZMGKXLG.js";
import "./chunk-JMXPE5PE.js";
import "./chunk-LL73CCBG.js";
import "./chunk-6TS2ZJL4.js";
import "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import "./chunk-SYPTUUSZ.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import {
  O,
  U
} from "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-VUGQF5TL.js";
import "./chunk-ZAISHGSP.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-FKFXOPPT.js";
import {
  l as l4
} from "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import {
  u as u4
} from "./chunk-7BWCD63N.js";
import {
  e as e2,
  u as u3
} from "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import {
  d
} from "./chunk-HPGYEHVI.js";
import "./chunk-X3R5OB6L.js";
import {
  n
} from "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  h,
  l as l3
} from "./chunk-A3VAC24F.js";
import {
  r as r3,
  s as s4
} from "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-O5TPFXRT.js";
import {
  _ as _2
} from "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import {
  j,
  s as s5
} from "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import {
  r2 as r
} from "./chunk-N3XLUQJI.js";
import "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import {
  F
} from "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H
} from "./chunk-ZWFY3WY5.js";
import {
  Et
} from "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  L,
  b,
  e2 as e,
  f2 as f,
  l2,
  m2,
  r2,
  s as s3,
  u2 as u,
  u3 as u2,
  w
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  l,
  s as s2
} from "./chunk-XWG6QGFK.js";
import {
  a,
  s
} from "./chunk-GWNLQRNM.js";
import {
  has,
  m
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/symbols/cim/animationUtils.js
function f7(t21, e15, n18) {
  return { transform: k3(t21, e15, n18.transform), fromColor: v4(t21, e15, n18.fromColor), toColor: O5(t21, e15, n18.toColor), colorMix: x3(t21, e15, n18.colorMix), toOpacity: D3(t21, e15, n18.toOpacity), opacityMix: L5(t21, e15, n18.opacityMix), shift: R4(t21, e15, n18.shift), hasAnimations: n18.hasAnimations || p4(e15), hasShiftAnimation: n18.hasShiftAnimation || u10(e15), hasMotionAnimations: n18.hasMotionAnimations || S4(e15) };
}
function p4(t21) {
  return !!t21.animations && t21.animations.length > 0;
}
function u10(t21) {
  return !!t21.animations && t21.animations.some((t22) => "CIMSymbolAnimationMoveAlongLine" === t22.type);
}
var y3 = /* @__PURE__ */ new Set(["CIMSymbolAnimationOffset", "CIMSymbolAnimationRotation", "CIMSymbolAnimationSize", "CIMSymbolAnimationScale"]);
function S4(t21) {
  return !!t21.animations && t21.animations.some((t22) => y3.has(t22.type));
}
function d6(t21) {
  return !t7.forceStaticPath && (t7.forceAnimatedPath || t21.hasAnimations);
}
function M4(e15, n18, o15) {
  if ("CIMCharacterMarker" === n18.type) return i.getLogger("animationUtils").error("#handleMarker()", "CIM character markers do not support animations"), o15;
  const i13 = Z(e15, n18, "OffsetX"), r12 = Z(e15, n18, "OffsetY");
  if ("CIMPictureMarker" === n18.type) return { ...o15, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: true, translation: V2([i13, r12]), rotation: V2(0), scale: V2(Z(e15, n18, "Size")), parent: o15.transform } };
  const s13 = n18.frame, m8 = s13.ymax - s13.ymin;
  return { ...o15, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: V2([i13, r12]), rotation: V2(0), scale: V2({ type: "Process", op: "Divide", left: Z(e15, n18, "Size"), right: m8 }), parent: o15.transform } };
}
function A4(t21, e15) {
  let n18 = 0, o15 = 0;
  const i13 = "Absolute" !== t21.anchorPointUnits;
  return t21.anchorPoint && (n18 = -t21.anchorPoint.x, o15 = -t21.anchorPoint.y), { ...e15, transform: { type: "AnimatedTransform", relativeTranslation: i13, absoluteScale: false, translation: V2([n18, o15]), rotation: V2(0), scale: V2(1), parent: e15.transform } };
}
function C3(t21, e15) {
  return "Absolute" === t21.anchorPointUnits ? e15 : A4(t21, e15);
}
function g2(t21, e15) {
  return "Absolute" !== t21.anchorPointUnits ? e15 : A4(t21, e15);
}
function h8(t21, e15, n18) {
  return { ...t21, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: V2([e15, n18]), rotation: V2(0), scale: V2(1), parent: t21.transform } };
}
function P3(t21, e15) {
  const n18 = e15 ? 0.5 * -(e15.xmin + e15.xmax) : 0, o15 = e15 ? 0.5 * -(e15.ymin + e15.ymax) : 0;
  let i13 = 0, a15 = 0;
  if ("x" in t21 && "y" in t21) i13 = t21.x + n18, a15 = t21.y + o15;
  else {
    const e16 = m5(t21);
    if (e16) {
      i13 = (e16[0] + e16[2]) / 2 + n18, a15 = (e16[1] + e16[3]) / 2 + o15;
    }
  }
  return [i13, a15];
}
function b4(t21, e15) {
  switch (e15.type) {
    case "CIMPictureMarker":
    case "CIMVectorMarker":
      return Z(t21, e15, "Rotation");
  }
  return 0;
}
function I2(t21, e15) {
  switch (e15.type) {
    case "CIMPictureMarker":
    case "CIMVectorMarker":
      return Z(t21, e15, "RotateClockwise");
  }
  return 0;
}
function T3(t21, e15) {
  switch (e15.type) {
    case "CIMPointSymbol":
    case "CIMVectorMarker":
      return [1, 1, 1, 1];
    case "CIMSolidStroke":
    case "CIMSolidFill":
      return Z(t21, e15, "Color");
    case "CIMPictureMarker":
    case "CIMPictureStroke":
    case "CIMPictureFill":
      return Z(t21, e15, "TintColor");
  }
  return [1, 1, 1, 1];
}
function k3(t21, e15, n18) {
  return { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: z(t21, e15), rotation: F2(t21, e15), scale: j3(t21, e15), parent: n18 };
}
function v4(t21, e15, n18) {
  return { type: "AnimatedColor", color: V2(T3(t21, e15)), opacity: V2(1), parent: n18 };
}
function O5(t21, e15, n18) {
  const { animations: o15 } = e15;
  let i13 = T3(t21, e15);
  const r12 = o15?.filter((t22) => "CIMSymbolAnimationColor" === t22.type)[0];
  return r12 && (i13 = Z(t21, r12, "ToColor")), { type: "AnimatedColor", color: V2(i13), opacity: V2(1), parent: n18 };
}
function x3(t21, e15, n18) {
  const { animations: o15 } = e15, i13 = o15?.filter((t22) => "CIMSymbolAnimationColor" === t22.type)[0];
  return i13 ? { type: "AnimatedColor", color: V2([1, 1, 1, 1]), opacity: { from: 0, to: 1, timing: w2(t21, i13?.animatedSymbolProperties) }, parent: [1, 1, 1, 1] } : n18;
}
function D3(t21, e15, n18) {
  const { animations: o15 } = e15;
  let i13 = V2(1);
  const r12 = o15?.filter((t22) => "CIMSymbolAnimationTransparency" === t22.type)[0];
  if (r12) {
    i13 = V2({ type: "Process", op: "Transparency", value: Z(t21, r12, "ToTransparency") });
  }
  return { type: "AnimatedColor", color: V2([1, 1, 1, 1]), opacity: i13, parent: n18 };
}
function L5(t21, e15, n18) {
  const { animations: o15 } = e15, i13 = o15?.filter((t22) => "CIMSymbolAnimationTransparency" === t22.type)[0];
  return i13 ? { type: "AnimatedColor", color: V2([1, 1, 1, 1]), opacity: { from: 0, to: 1, timing: w2(t21, i13?.animatedSymbolProperties) }, parent: [1, 1, 1, 1] } : n18;
}
function R4(t21, e15, n18) {
  const { animations: o15 } = e15, i13 = o15?.filter((t22) => "CIMSymbolAnimationMoveAlongLine" === t22.type)[0];
  if (!i13) return n18;
  let r12, m8;
  const l16 = w2(t21, i13.animatedSymbolProperties), c10 = _3(t21, i13, "DistanceAlong"), f12 = _3(t21, i13, "Speed"), p9 = c10 && Z(t21, i13, "DistanceAlong"), u17 = f12 && Z(t21, i13, "Speed"), y4 = true === i13.continuous;
  if (false !== p9) r12 = { type: "Process", op: "Divide", left: p9, right: 100 }, m8 = true;
  else if (false !== u17) r12 = { type: "Process", op: "Multiply", left: u17, right: l16.duration }, m8 = false;
  else {
    if (!y4) throw new Error("Either distanceAlong, speed or continuous must be specified.");
    r12 = 1, m8 = true;
  }
  return { type: "AnimatedShift", multiplyByLineLength: m8, shift: { from: 0, to: r12, timing: l16 }, parent: n18 };
}
function w2(t21, e15) {
  if (!e15) return { duration: 1, startTimeOffset: 0, repeatDelay: 0, timeOriginSelector: t6.Local, repeatType: d2.Loop, easing: s6.Linear, playAnimation: 1, reverseAnimation: 0 };
  const r12 = Z(t21, e15, "Duration");
  let s13;
  if (Z(t21, e15, "RandomizeStartTime")) {
    s13 = { type: "Process", op: "Random", min: 0, max: r12, seed: Z(t21, e15, "RandomizeStartSeed") };
  } else s13 = Z(t21, e15, "StartTimeOffset");
  const m8 = Z(t21, e15, "RepeatDelay"), f12 = Z(t21, e15, "PlayAnimation"), p9 = Z(t21, e15, "ReverseAnimation"), u17 = b2(e15.repeatType, n2.CIMAnimatedSymbolProperties.repeattype);
  return { duration: r12, startTimeOffset: s13, repeatDelay: m8, timeOriginSelector: u17 === d2.None ? t6.Local : t6.Global, repeatType: u17, easing: b2(e15.easing, n2.CIMAnimatedSymbolProperties.easing), playAnimation: f12, reverseAnimation: p9 };
}
function j3(t21, e15) {
  const { animations: n18 } = e15;
  let o15;
  o15 = "CIMPictureMarker" === e15.type || "CIMVectorMarker" === e15.type ? Z(t21, e15, "Size") : "CIMSolidStroke" === e15.type || "CIMPictureStroke" === e15.type ? Z(t21, e15, "Width") : U2(e15) || 10;
  const i13 = n18?.filter((t22) => "CIMSymbolAnimationScale" === t22.type)[0];
  if (!i13) {
    const e16 = n18?.filter((t22) => "CIMSymbolAnimationSize" === t22.type)[0];
    if (!e16) return V2(1);
    return { from: 1, to: { type: "Process", op: "Divide", left: Z(t21, e16, "ToSize"), right: o15 }, timing: w2(t21, e16.animatedSymbolProperties) };
  }
  return { from: 1, to: Z(t21, i13, "ScaleFactor"), timing: w2(t21, i13.animatedSymbolProperties) };
}
function z(t21, e15) {
  const { animations: n18 } = e15, o15 = n18?.filter((t22) => "CIMSymbolAnimationOffset" === t22.type)[0];
  if (!o15) return V2([0, 0]);
  return { from: [0, 0], to: [Z(t21, o15, "OffsetX"), Z(t21, o15, "OffsetY")], timing: w2(t21, o15.animatedSymbolProperties) };
}
function F2(t21, e15) {
  const { animations: n18 } = e15, o15 = I2(t21, e15), i13 = { type: "Process", op: "Divide", left: b4(t21, e15), right: { type: "Process", op: "Cond", condition: o15, ifTrue: -1, ifFalse: 1 } }, r12 = n18?.filter((t22) => "CIMSymbolAnimationRotation" === t22.type)[0];
  if (!r12) return V2(i13);
  const s13 = { type: "Process", op: "Add", left: Z(t21, r12, "ToRotation"), right: { type: "Process", op: "Divide", left: i13, right: -1 } };
  return { from: i13, to: { type: "Process", op: "Add", left: i13, right: { type: "Process", op: "Cond", condition: Z(t21, r12, "RotateClockwise"), ifTrue: { type: "Process", op: "MatchWinding", sign: -1, angle: s13 }, ifFalse: { type: "Process", op: "MatchWinding", sign: 1, angle: s13 } } }, timing: w2(t21, r12.animatedSymbolProperties) };
}
function V2(t21) {
  return { from: t21, to: t21, timing: { duration: 1, startTimeOffset: 0, repeatDelay: 0, timeOriginSelector: t6.Local, repeatType: d2.Loop, easing: s6.Linear, playAnimation: 1, reverseAnimation: 0 } };
}
function U4(t21) {
  if (null == t21) return false;
  if ("object" != typeof t21) return false;
  if (t21.animations && Array.isArray(t21.animations) && t21.animations.length > 0) return true;
  for (const e15 in t21) if (U4(t21[e15])) return true;
  return false;
}

// node_modules/@arcgis/core/symbols/cim/fitVectorMarker.js
var a7 = 0.01;
function t15(t21, f12) {
  if (!t21.frame) return t21;
  const { markerGraphics: n18 } = t21;
  if (!n18 || 0 === n18.length) return t21;
  let o15 = 0, s13 = 0, i13 = 0, c10 = 0;
  for (const m8 of n18) {
    const { geometry: a15, symbol: t22 } = m8;
    if (!a15 || !t22 || !("symbolLayers" in t22)) continue;
    const { symbolLayers: n19 } = t22;
    if (n19) for (const m9 of n19) {
      const { effects: t23 } = m9, n20 = l8.applyEffects(t23, a15, f12), x9 = m5(n20);
      x9 && (o15 = Math.min(o15, x9[0]), s13 = Math.min(s13, x9[1]), i13 = Math.max(i13, x9[2]), c10 = Math.max(c10, x9[3]));
    }
  }
  const { xmin: x8, ymin: y4, xmax: p9, ymax: h15 } = t21.frame, l16 = (p9 - x8) / 2, M6 = (h15 - y4) / 2, u17 = (p9 + x8) / 2, b5 = (h15 + y4) / 2;
  if (l16 <= 0 || M6 <= 0) return t21;
  const g7 = (u17 - o15) / l16, j4 = (i13 - u17) / l16, E8 = (b5 - s13) / M6, F5 = (c10 - b5) / M6, H3 = Math.max(Math.max(g7, j4), Math.max(E8, F5));
  return H3 <= 1 + a7 ? t21 : (t21 = a(t21)).frame ? (t21.frame.xmin = (t21.frame.xmin - u17) * H3 + u17, t21.frame.ymin = (t21.frame.ymin - b5) * H3 + b5, t21.frame.xmax = (t21.frame.xmax - u17) * H3 + u17, t21.frame.ymax = (t21.frame.ymax - b5) * H3 + b5, false !== t21.respectFrame && (t21.size *= H3), t21) : t21;
}

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var q2 = () => i.getLogger("esri.symbols.cim.cimAnalyzer");
function K(e15) {
  const t21 = e15.markerPlacement;
  return t21 && t21.angleToLine ? i2.MAP : i2.SCREEN;
}
var Q = class {
  constructor(e15) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], this._hasTextStringTemplates = false, e15 && (this._resourceManager = e15);
  }
  analyzeSymbolReference(t21, r12, i13) {
    if (this._cimLayers = i13 ?? [], !t21) return this._cimLayers;
    if (this._reset(), this._hasTextStringTemplates = t21.hasTextStringTemplates ?? false, t21.primitiveOverrides) {
      this._primitiveOverrides = t21.primitiveOverrides;
      for (const t22 of this._primitiveOverrides) {
        const r13 = t22.valueExpressionInfo;
        if (r13) this._setPoMap(t22.primitiveName, t22.propertyName, r13);
        else if (null != t22.value) {
          let r14 = t22.value;
          t22.propertyName.includes("Color") && (i3(r14) && (r14 = o(r14)), r14 = M(r14)), this._setPoMap(t22.primitiveName, t22.propertyName, r14);
        }
      }
    }
    return this._analyzeSymbol(t21.symbol, r12), this._cimLayers;
  }
  _reset() {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [];
  }
  _analyzeSymbol(e15, t21) {
    switch (e15?.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e15, t21);
    }
  }
  _analyzeMultiLayerSymbol(e15, t21) {
    const r12 = e15?.symbolLayers;
    if (!r12) return;
    for (let l16 = 0; l16 < r12.length; l16++) {
      const e16 = r12[l16];
      "CIMVectorMarker" === e16.type && (r12[l16] = t15(e16, this._resourceManager.geometryEngine));
    }
    const i13 = e15.effects;
    let o15 = i2.SCREEN;
    const a15 = U2(e15) ?? 0;
    if ("CIMPointSymbol" === e15.type && "Map" === e15.angleAlignment && (o15 = i2.MAP), oe(r12, i13)) return this._analyzeCompositeOutlineFill(r12, i13, a15);
    let s13 = { transform: [0, 0, 0, 1], fromColor: [1, 1, 1, 1], toColor: [1, 1, 1, 1], colorMix: [0, 0, 0, 0], toOpacity: [1, 1, 1, 1], opacityMix: [0, 0, 0, 0], shift: [1, 1, 1, 1], hasAnimations: U4(e15), hasShiftAnimation: false, hasMotionAnimations: false };
    s13 = f7(this._poMap, e15, s13);
    const p9 = "CIMPolygonSymbol" === e15.type;
    let c10 = r12.length;
    for (; c10--; ) {
      const l16 = r12[c10];
      if (!l16 || false === l16.enable) continue;
      let n18;
      i13?.length && (n18 = [...i13]);
      const m8 = l16.effects;
      m8?.length && (i13 ? n18.push(...m8) : n18 = [...m8]);
      let y4 = null;
      if (n18) {
        y4 = [];
        for (const e16 of n18) {
          const t22 = v2.findEffectOverrides(e16, this._primitiveOverrides);
          t22 && y4.push(t22);
        }
      }
      const d10 = [];
      switch (v2.findApplicableOverrides(l16, this._primitiveOverrides, d10), l16.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(l16, y4, s13, x(r12));
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(l16, y4, s13);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(l16, y4);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(l16, y4);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(l16, y4, p9, a15, s13);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(l16, y4, p9, a15, s13);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(l16, y4, p9, a15);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" !== e15.type && "CIMPolygonSymbol" !== e15.type || (o15 = K(l16));
          const r13 = [], i14 = l16.primitiveName;
          i14 && r13.push(i14);
          const n19 = p9 && p(l16.markerPlacement);
          this._analyzeMarker(l16, y4, null, r13, o15, a15, t21, [], s13, false, n19);
          break;
        }
        default:
          q2().error("Cannot analyze CIM layer", l16.type);
      }
    }
  }
  _analyzeSolidFill(e15, t21, r12, i13) {
    const { primitiveName: o15, type: a15 } = e15, s13 = M(e15.color), l16 = f7(this._poMap, e15, r12);
    if (i13 || !t21?.some((e16) => "CIMGeometricEffectTaperedPolygon" === e16.effect.type)) this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e15.colorLocked, color: this._getValueOrOverrideExpression(a15, o15, "Color", s13), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: t21, applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: false, animationParams: se(l16) });
    else {
      const r13 = this._getValueOrOverrideExpression(a15, o15, "Color", s13);
      this._cimLayers.push({ type: "outlineFill", colorLocked: !!e15.colorLocked, color: r13, effects: t21, outlineColor: r13, outlineColorLocked: !!e15.colorLocked, ...l7, outlineEffects: t21 });
    }
  }
  _analyzePictureFill(e15, t21, r12) {
    const { primitiveName: i13, type: o15 } = e15, a15 = k(e15), s13 = h2(e15.height, n2.CIMPictureFill.height);
    let l16 = h2(e15.scaleX, 1);
    if ("width" in e15 && "number" == typeof e15.width) {
      const t22 = e15.width;
      let r13 = 1;
      const i14 = this._resourceManager.getResource(e15.url);
      null != i14 && (r13 = i14.width / i14.height), l16 /= r13 * (s13 / t22);
    }
    const p9 = { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(i13, o15) }, c10 = f7(this._poMap, e15, r12);
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: p9, colorLocked: !!e15.colorLocked, effects: t21, color: this._getValueOrOverrideExpression(o15, i13, "TintColor", a15), height: this._getValueOrOverrideExpression(o15, i13, "Height", s13), scaleX: this._getValueOrOverrideExpression(o15, i13, "ScaleX", l16), angle: this._getValueOrOverrideExpression(o15, i13, "Rotation", h2(e15.rotation)), offsetX: this._getValueOrOverrideExpression(o15, i13, "OffsetX", h2(e15.offsetX)), offsetY: this._getValueOrOverrideExpression(o15, i13, "OffsetY", h2(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false, animationParams: se(c10) });
  }
  _analyzeHatchFill(e15, t21) {
    const { primitiveName: r12, type: i13 } = e15, o15 = this._analyzeMaterialOverrides(r12, ["Rotation", "OffsetX", "OffsetY"]), a15 = X(o15);
    let s13 = [255, 255, 255, 1], l16 = false;
    if (e15.lineSymbol?.symbolLayers) for (const p9 of e15.lineSymbol.symbolLayers) {
      if ("CIMSolidStroke" !== p9.type) continue;
      const e16 = p9.primitiveName ?? r12;
      l16 || !e16 || p9.colorLocked || null == this._poMap[e16]?.Color && null == this._poMap[e16]?.StrokeColor || (s13 = M(p9.color), s13 = this._maybeGetValueOrOverrideExpression(e16, "StrokeColor") ?? this._getValueOrOverrideExpression(i13, e16, "Color", s13), l16 = true);
      const t22 = this._maybeGetValueOrOverrideExpression(e16, "StrokeWidth");
      if (t22) {
        let r13 = null, o16 = null;
        "number" == typeof t22 ? r13 = t22 : o16 = t22.valueExpressionInfo;
        let s14 = a15.find((e17) => "strokeWidth" === e17.propertyName);
        s14 ? s14.propertyName = "width" : (s14 = { type: "CIMPrimitiveOverride", primitiveName: e16, propertyName: "width", valueExpressionInfo: o16, value: r13, defaultValue: q(i13, "width") }, a15.push(s14));
      }
    }
    const n18 = { type: "sprite-rasterization-param", resource: e15, overrides: a15 };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: n18, colorLocked: !!e15.colorLocked, effects: t21, color: s13, height: this._getValueOrOverrideExpression(i13, r12, "Separation", h2(e15.separation, n2.CIMHatchFill.separation)), scaleX: 1, angle: this._getValueOrOverrideExpression(i13, r12, "Rotation", h2(e15.rotation)), offsetX: this._getValueOrOverrideExpression(i13, r12, "OffsetX", h2(e15.offsetX)), offsetY: this._getValueOrOverrideExpression(i13, r12, "OffsetY", h2(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: !l16 });
  }
  _analyzeGradientFill(e15, t21) {
    const { angle: r12, gradientMethod: i13, gradientSize: o15, gradientSizeUnits: a15, gradientType: s13, interval: l16, primitiveName: n18, type: p9 } = e15, c10 = n2.CIMGradientFill, m8 = e15.colorRamp;
    this._cimLayers.push({ type: "gradientFill", spriteRasterizationParam: { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(n18, p9) }, colorLocked: false, effects: t21, color: [255, 255, 255, 1], gradientMethod: this._getValueOrOverrideExpression(p9, n18, "GradientMethod", i13 ?? "Linear"), angle: this._getValueOrOverrideExpression(p9, n18, "Angle", h2(r12, c10.angle)), gradientType: this._getValueOrOverrideExpression(p9, n18, "GradientType", s13 ?? c10.gradientType), interval: this._getValueOrOverrideExpression(p9, n18, "Interval", h2(l16, "CIMFixedColorRamp" === m8.type ? m8.colors.length : c10.interval)), gradientSize: this._getValueOrOverrideExpression(p9, n18, "GradientSize", h2(o15, c10.gradientSize)), gradientSizeUnits: "Absolute" === a15 ? ne.Absolute : "Relative" === a15 ? ne.Relative : c10.gradientSizeUnits });
  }
  _analyzeCompositeOutlineFill(e15, t21, r12) {
    const i13 = e15.find((e16) => "CIMSolidFill" === e16.type), o15 = e15.find((e16) => "CIMSolidStroke" === e16.type);
    if (null == i13 || null == o15) return;
    const a15 = [...t21 ?? [], ...i13.effects ?? []].map((e16) => v2.findEffectOverrides(e16, this._primitiveOverrides)).filter((e16) => null != e16), s13 = [...t21 ?? [], ...o15.effects ?? []].map((e16) => v2.findEffectOverrides(e16, this._primitiveOverrides)).filter((e16) => null != e16), l16 = h2(o15.width, n2.CIMSolidStroke.width), n18 = d3(o15.capStyle, n2.CIMSolidStroke.capstyle), p9 = d3(o15.joinStyle, n2.CIMSolidStroke.joinstyle), c10 = o15.miterLimit;
    this._cimLayers.push({ type: "outlineFill", colorLocked: !!i13.colorLocked, color: this._getValueOrOverrideExpression(i13.type, i13.primitiveName, "Color", M(i13.color)), effects: a15, outlineColorLocked: !!o15.colorLocked, outlineColor: this._getValueOrOverrideExpression(o15.type, o15.primitiveName, "Color", M(o15.color)), outlineWidth: this._getValueOrOverrideExpression(o15.type, o15.primitiveName, "Width", l16), cap: this._getValueOrOverrideExpression(o15.type, o15.primitiveName, "CapStyle", n18), join: this._getValueOrOverrideExpression(o15.type, o15.primitiveName, "JoinStyle", p9), miterLimit: c10 && this._getValueOrOverrideExpression(o15.type, o15.primitiveName, "MiterLimit", c10), referenceWidth: r12, outlineEffects: s13 });
  }
  _analyzeSolidStroke(e15, t21, r12, i13, o15) {
    const { primitiveName: a15, type: s13 } = e15, l16 = M(e15.color), p9 = h2(e15.width, n2.CIMSolidStroke.width), c10 = d3(e15.capStyle, n2.CIMSolidStroke.capstyle), m8 = d3(e15.joinStyle, n2.CIMSolidStroke.joinstyle), y4 = e15.miterLimit;
    let d10, h15, f12, u17, v7 = [];
    if (this._analyzePrimitiveOverrides(a15, t21, null, null) && (v7 = this._getPrimitiveMaterialOverrides(a15, s13)), t21 && Array.isArray(t21) && t21.length > 0) {
      const e16 = t21[t21.length - 1].effect;
      e16 && "CIMGeometricEffectDashes" === e16.type && "NoConstraint" === e16.lineDashEnding && (d10 = e16.dashTemplate, h15 = e16.scaleDash, f12 = e16.offsetAlongLine, u17 = e16.primitiveName, (t21 = [...t21]).pop());
    }
    null != u17 && v7.push(...this._getPrimitiveMaterialOverrides(u17, s13).filter((e16) => "dashTemplate" === e16.propertyName));
    const g7 = void 0 !== d10 ? { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: d10, primitiveName: u17 }, overrides: v7 } : null, _10 = f7(this._poMap, e15, o15);
    this._cimLayers.push({ type: "line", spriteRasterizationParam: g7, isOutline: r12, colorLocked: !!e15.colorLocked, effects: t21, color: this._getValueOrOverrideExpression(s13, a15, "Color", l16), width: this._getValueOrOverrideExpression(s13, a15, "Width", p9), cap: this._getValueOrOverrideExpression(s13, a15, "CapStyle", c10), join: this._getValueOrOverrideExpression(s13, a15, "JoinStyle", m8), miterLimit: y4 && this._getValueOrOverrideExpression(s13, a15, "MiterLimit", y4), referenceWidth: i13, zOrder: $(e15.name), dashTemplate: this._maybeGetValueOrOverrideExpression(u17, "DashTemplate") ?? d10, offsetAlongLine: this._getValueOrOverrideExpression(s13, u17, "OffsetAlongLine", f12 ?? 0), scaleDash: h15, sampleAlphaOnly: true, animationParams: se(_10) });
  }
  _analyzePictureStroke(e15, t21, r12, i13, o15) {
    const { primitiveName: a15, type: s13 } = e15, l16 = k(e15), p9 = h2(e15.width, n2.CIMPictureStroke.width), c10 = d3(e15.capStyle, n2.CIMPictureStroke.capstyle), m8 = d3(e15.joinStyle, n2.CIMPictureStroke.joinstyle), y4 = e15.miterLimit, d10 = { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(a15, s13) }, h15 = f7(this._poMap, e15, o15);
    this._cimLayers.push({ type: "line", spriteRasterizationParam: d10, isOutline: r12, colorLocked: !!e15.colorLocked, effects: t21, color: this._getValueOrOverrideExpression(s13, a15, "TintColor", l16), width: this._getValueOrOverrideExpression(s13, a15, "Width", p9), cap: this._getValueOrOverrideExpression(s13, a15, "CapStyle", c10), join: this._getValueOrOverrideExpression(s13, a15, "JoinStyle", m8), miterLimit: y4 && this._getValueOrOverrideExpression(s13, a15, "MiterLimit", y4), referenceWidth: i13, zOrder: $(e15.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false, animationParams: se(h15) });
  }
  _analyzeGradientStroke(e15, t21, r12, i13) {
    const { gradientMethod: o15, gradientSize: a15, gradientSizeUnits: s13, gradientType: l16, interval: n18, primitiveName: p9, type: c10 } = e15, m8 = n2.CIMGradientStroke, y4 = h2(e15.width, m8.width), d10 = d3(e15.capStyle, m8.capstyle), h15 = d3(e15.joinStyle, m8.joinstyle), f12 = e15.miterLimit, u17 = e15.colorRamp;
    this._cimLayers.push({ type: "gradientStroke", spriteRasterizationParam: { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(p9, c10) }, colorLocked: !!e15.colorLocked, effects: t21, color: [255, 255, 255, 1], width: this._getValueOrOverrideExpression(c10, p9, "Width", y4), cap: this._getValueOrOverrideExpression(c10, p9, "CapStyle", d10), join: this._getValueOrOverrideExpression(c10, p9, "JoinStyle", h15), miterLimit: f12 && this._getValueOrOverrideExpression(c10, p9, "MiterLimit", f12), referenceWidth: i13, isOutline: r12, gradientMethod: this._getValueOrOverrideExpression(c10, p9, "GradientMethod", o15 ?? m8.gradientMethod), gradientType: this._getValueOrOverrideExpression(c10, p9, "GradientType", l16 ?? m8.gradientType), interval: this._getValueOrOverrideExpression(c10, p9, "Interval", h2(n18, "CIMFixedColorRamp" === u17.type ? u17.colors.length : m8.interval)), gradientSize: this._getValueOrOverrideExpression(c10, p9, "GradientSize", h2(a15, m8.gradientSize)), gradientSizeUnits: "Absolute" === s13 ? ne.Absolute : "Relative" === s13 ? ne.Relative : m8.gradientSizeUnits });
  }
  _analyzeMarker(e15, t21, r12, i13, o15, a15, s13, l16, y4, d10 = false, h15 = false) {
    d10 ||= !!e15.colorLocked;
    let f12 = y4;
    if (f12 = g2(e15, f12), f12 = M4(this._poMap, e15, f12), f12 = C3(e15, f12), f12 = f7(this._poMap, e15, f12), this._analyzeMarkerInsidePolygon(e15, t21, d10, f12)) return;
    const u17 = h2(e15.size, n2.CIMVectorMarker.size), v7 = h2(e15.rotation), g7 = h2(e15.offsetX), _10 = h2(e15.offsetY), { primitiveName: S5, type: M6 } = e15, k5 = this._getValueOrOverrideExpression(M6, S5, "Size", u17), C4 = this._getValueOrOverrideExpression(M6, S5, "Rotation", v7), b5 = this._getValueOrOverrideExpression(M6, S5, "OffsetX", g7), x8 = this._getValueOrOverrideExpression(M6, S5, "OffsetY", _10);
    switch (e15.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e15, t21, r12, i13, o15, a15, k5, C4, b5, x8, l16, f12, d10, h15);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e15, t21, r12, i13, o15, a15, k5, C4, b5, x8, l16, f12, s13, d10, h15);
    }
  }
  _analyzeMarkerInsidePolygon(e15, t21, r12, i13) {
    const { markerPlacement: o15, type: s13 } = e15;
    if (!o15 || "CIMMarkerPlacementInsidePolygon" !== o15.type || i13.hasMotionAnimations) return false;
    if ("CIMVectorMarker" === s13 || "CIMPictureMarker" === s13) {
      const r13 = e15.primitiveName;
      if (r13 && this._analyzePrimitiveOverrides([r13], t21, null, null)) return false;
      const i14 = o15.primitiveName;
      if (i14 && this._analyzePrimitiveOverrides([i14], t21, null, null)) return false;
      if ("CIMVectorMarker" === s13) {
        const { markerGraphics: t22 } = e15;
        if (t22) for (const e16 of t22) {
          const { symbol: t23 } = e16;
          if ("CIMPolygonSymbol" === t23?.type && t23.symbolLayers) {
            const { symbolLayers: e17 } = t23;
            for (const t24 of e17) if ("CIMSolidStroke" === t24.type) return false;
          }
        }
      } else {
        const { animatedSymbolProperties: t22 } = e15;
        if (t22) return false;
      }
    }
    const l16 = Math.abs(o15.stepX), n18 = Math.abs(o15.stepY);
    if (0 === l16 || 0 === n18) return true;
    let p9, c10;
    if ("Random" === o15.gridType) {
      const e16 = e2(Fi), t22 = Math.max(Math.floor(e16 / l16), 1);
      p9 = n18 * Math.max(Math.floor(e16 / n18), 1);
      c10 = t22 * l16 / p9;
    } else o15.shiftOddRows ? (p9 = 2 * n18, c10 = l16 / n18 * 0.5) : (p9 = n18, c10 = l16 / n18);
    const m8 = k(e15), y4 = "CIMCharacterMarker" === e15.type ? null : { type: "sprite-rasterization-param", resource: e15, overrides: [] };
    return this._cimLayers.push({ type: "fill", spriteRasterizationParam: y4, colorLocked: r12, effects: t21, color: m8, height: p9, scaleX: c10, angle: o15.gridAngle, offsetX: h2(o15.offsetX), offsetY: h2(o15.offsetY), applyRandomOffset: "Random" === o15.gridType, sampleAlphaOnly: "CIMPictureMarker" !== e15.type, hasUnresolvedReplacementColor: true }), true;
  }
  _analyzePictureMarker(e15, t21, i13, o15, a15, l16, n18, p9, c10, m8, y4, d10, h15, f12) {
    const { animatedSymbolProperties: u17, primitiveName: v7, type: O7 } = e15;
    let g7 = h2(e15.scaleX, 1);
    const _10 = k(e15);
    i13 || (i13 = this._createMarkerPlacementOverrideExpression(e15.markerPlacement));
    const S5 = this._createGIFAnimatedSymbolPropertiesOverrideExpression(u17), M6 = e15.anchorPoint ?? { x: 0, y: 0 };
    if ("width" in e15 && "number" == typeof e15.width) {
      const t22 = e15.width;
      let r12 = 1;
      const i14 = this._resourceManager.getResource(e15.url);
      null != i14 && (r12 = i14.width / i14.height);
      g7 /= r12 * (h2(e15.size) / t22);
    }
    const k5 = [...o15];
    let C4;
    e15.primitiveName && k5.push(e15.primitiveName), u17 || S5 ? C4 = { type: "animated", url: e15.url, urlHash: "H" + l(e15.url), playAnimation: e15.animatedSymbolProperties?.playAnimation, reverseAnimation: e15.animatedSymbolProperties?.reverseAnimation, randomizeStartTime: e15.animatedSymbolProperties?.randomizeStartTime, randomizeStartSeed: e15.animatedSymbolProperties?.randomizeStartSeed, startTimeOffset: e15.animatedSymbolProperties?.startTimeOffset, duration: e15.animatedSymbolProperties?.duration, repeatType: e15.animatedSymbolProperties?.repeatType, repeatDelay: e15.animatedSymbolProperties?.repeatDelay } : (C4 = a(e15), C4.markerPlacement = null);
    const b5 = { type: "sprite-rasterization-param", resource: C4, overrides: this._getMaterialOverrides(k5, O7) };
    S5 && b5.overrides.push(...S5.overrides);
    const x8 = n18;
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: b5, colorLocked: h15, effects: t21, scaleSymbolsProportionally: false, alignment: a15, size: n18, scaleX: this._getValueOrOverrideExpression(O7, v7, "ScaleX", g7), rotation: p9, offsetX: c10, offsetY: m8, transform: { type: "cim-marker-transform-param", params: y4 }, color: this._getValueOrOverrideExpression(O7, v7, "TintColor", _10), anchorPoint: { x: M6.x, y: M6.y }, isAbsoluteAnchorPoint: "Relative" !== e15.anchorPointUnits, outlineColor: [0, 0, 0, 0], outlineWidth: 0, frameHeight: 0, widthRatio: 1, rotateClockwise: !!e15.rotateClockwise, referenceSize: l16, sizeRatio: 1, isOutline: f12, markerPlacement: i13, animationParams: se(d10), baseSize: x8 });
  }
  _analyzeVectorMarker(e15, t21, r12, i13, o15, a15, s13, l16, p9, c10, m8, f12, u17, v7, O7) {
    const g7 = e15.markerGraphics;
    if (!g7) return;
    const _10 = e15.frame;
    let S5 = 0;
    S5 = _10 ? _10.ymax - _10.ymin : a15;
    const M6 = !!e15.scaleSymbolsProportionally;
    if (S5) {
      const t22 = { offsetX: p9, offsetY: c10, rotation: l16, size: s13, frameHeight: S5, rotateClockWise: !!e15.rotateClockwise, absoluteAnchorPoint: false, scaleSymbolsProportionally: M6 };
      m8 = [...m8, t22];
    }
    r12 || (r12 = this._createMarkerPlacementOverrideExpression(e15.markerPlacement));
    for (const k5 of g7) if (k5) {
      const s14 = k5.symbol;
      if (!s14) continue;
      const l17 = k5.primitiveName;
      l17 && i13.push(l17);
      let p10, c11 = f12;
      if (("CIMPointSymbol" === s14.type || "CIMTextSymbol" === s14.type) && _10) {
        let t22 = 0, r13 = 0;
        const i14 = k5.geometry;
        "x" in i14 && "y" in i14 && (t22 += i14.x - 0.5 * (_10.xmin + _10.xmax), r13 += i14.y - 0.5 * (_10.ymin + _10.ymax));
        const o16 = e15.anchorPoint;
        let a16 = false;
        o16 && ("Absolute" === e15.anchorPointUnits ? (t22 -= o16.x, r13 -= o16.y, a16 = true) : _10 && (t22 -= (_10.xmax - _10.xmin) * o16.x, r13 -= (_10.ymax - _10.ymin) * o16.y));
        const s15 = { offsetX: t22, offsetY: r13, rotation: 0, size: 0, frameHeight: 0, rotateClockWise: false, absoluteAnchorPoint: a16, scaleSymbolsProportionally: M6 };
        p10 = [...m8, s15];
      }
      const g8 = k5.geometry, [C4, b5] = P3(g8, _10);
      switch (0 === C4 && 0 === b5 || (c11 = h8(c11, C4, b5)), "CIMPointSymbol" === s14.type && (c11 = f7(this._poMap, s14, c11)), s14.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          u17 || re(s14) ? (c11 = { ...c11, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: true, translation: V2([0, 0]), rotation: V2(0), scale: V2(S5), parent: f12.transform } }, this._analyzeMultiLayerGraphicNonSDF(e15, t21, r12, k5, i13, o15, a15, p10 ?? m8, c11, S5, v7, O7)) : this._analyzeMultiLayerGraphic(e15, t21, r12, k5, i13, o15, a15, p10 ?? m8, c11, S5, v7, O7);
          break;
        case "CIMTextSymbol":
          this._analyzeTextGraphic(t21, r12, k5, i13, o15, a15, p10 ?? m8, v7);
      }
      l17 && i13.pop();
    }
  }
  _analyzeMultiLayerGraphic(e15, t21, r12, i13, o15, a15, s13, l16, n18, p9, c10, m8) {
    const y4 = i13.symbol.symbolLayers;
    y4 && (!te2(y4) || d6(n18) ? ie(y4) ? this._analyzeMultiLayerGraphicNonSDF(e15, t21, r12, i13, o15, a15, s13, l16, n18, p9, !!c10, m8) : this._analyzeMarkerGraphicSymbolLayers(e15, t21, r12, i13, o15, a15, s13, l16, n18, p9, c10, m8) : this._analyzeCompositeMarkerGraphic(e15, t21, r12, i13, y4, a15, s13, l16, p9, c10, m8));
  }
  _analyzeMarkerGraphicSymbolLayers(e15, t21, r12, i13, o15, a15, s13, l16, p9, c10, m8, y4) {
    const d10 = i13.symbol, h15 = d10.symbolLayers;
    if (!h15) return;
    const f12 = this._resourceManager.geometryEngine, u17 = l8.applyEffects(d10.effects, i13.geometry, f12);
    if (!u17) return;
    let v7 = h15.length;
    for (; v7--; ) {
      const d11 = h15[v7];
      if (!d11 || false === d11.enable) continue;
      const g7 = d11.primitiveName;
      switch (g7 && o15.push(g7), d11.type) {
        case "CIMSolidFill":
        case "CIMSolidStroke": {
          const o16 = l8.applyEffects(d11.effects, u17, f12), h16 = m5(o16);
          if (!h16) continue;
          const v8 = "Relative" !== e15.anchorPointUnits, _10 = G(d11) ?? 0, { frameSizeRatio: S5, anchorX: M6, anchorY: x8, widthRatio: z2, sdfPaddingRatio: E8 } = h5(h16, e15.frame, e15.size, e15.anchorPoint, v8, _10, e15.scaleSymbolsProportionally), I3 = "CIMSolidFill" === d11.type, L7 = { type: "sdf", geom: o16, sdfPaddingRatio: E8, asFill: I3 }, { path: N3 } = d11, R5 = I3 ? M(A(d11)) : null == N3 ? M(N(d11)) : [0, 0, 0, 0], A6 = I3 ? [0, 0, 0, 0] : M(N(d11));
          if (!I3 && !_10) break;
          const F5 = i13.primitiveName;
          let X4 = null;
          I3 && !d11.colorLocked && (X4 = this._maybeGetValueOrOverrideExpression(F5, "FillColor"));
          let j4 = null;
          I3 || d11.colorLocked || (j4 = this._maybeGetValueOrOverrideExpression(F5, "StrokeColor"));
          const Y3 = X4 ?? this._getValueOrOverrideExpression(d11.type, g7, "Color", R5), W2 = j4 ?? this._getValueOrOverrideExpression(d11.type, g7, "Color", A6), D4 = this._maybeGetValueOrOverrideExpression(F5, "StrokeWidth") ?? this._getValueOrOverrideExpression(d11.type, g7, "Width", _10), U6 = N3 ? { type: "sprite-rasterization-param", resource: { type: "path", path: N3, asFill: I3 }, overrides: [] } : { type: "sprite-rasterization-param", resource: L7, overrides: [] }, J3 = f7(this._poMap, d11, p9), B4 = h2(e15.size, n2.CIMVectorMarker.size), q4 = this._getValueOrOverrideExpression(e15.type, e15.primitiveName, "Size", B4);
          this._cimLayers.push({ type: "marker", spriteRasterizationParam: U6, colorLocked: !!d11.colorLocked || !!m8, effects: t21, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: a15, anchorPoint: { x: M6, y: x8 }, isAbsoluteAnchorPoint: v8, size: c10, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l16 }, frameHeight: c10, widthRatio: z2, rotateClockwise: false, referenceSize: s13, sizeRatio: S5, color: Y3, outlineColor: W2, outlineWidth: D4, isOutline: y4, markerPlacement: r12, animationParams: se(J3), isStroke: "CIMSolidFill" !== d11.type, baseSize: q4, ...c(o16, E8) });
          break;
        }
        case "CIMPictureMarker":
        case "CIMVectorMarker":
          if (d11.markerPlacement) {
            q2().error("Error analyzing CIM, got unexpected marker placement");
            break;
          }
          this._analyzeMarker(d11, t21, r12, o15, a15, s13, false, l16, p9, m8, y4);
      }
      g7 && o15.pop();
    }
  }
  _analyzeTextGraphic(e15, r12, i13, o15, a15, s13, l16, n18) {
    const p9 = [];
    v2.findApplicableOverrides(i13, this._primitiveOverrides, p9);
    const c10 = i13.geometry;
    if (!("x" in c10) || !("y" in c10)) return;
    const m8 = i13.symbol, y4 = T(m8), d10 = L2(m8.fontStyleName), h15 = u7(m8.fontFamilyName);
    m8.font = { family: h15, decoration: y4, ...d10 };
    const f12 = h2(m8.height, n2.CIMTextSymbol.height), u17 = h2(m8.angle), v7 = h2(m8.offsetX), g7 = h2(m8.offsetY), { haloSymbol: _10 } = m8, S5 = h2(m8.haloSize, 0);
    let k5 = [0, 0, 0, 0];
    if (_10?.symbolLayers?.length) {
      const e16 = _10.symbolLayers;
      for (const t21 of e16) if (t21.color) {
        k5 = this._getValueOrOverrideExpression(m8?.haloSymbol?.type ?? "CIMPolygonSymbol", t21.primitiveName, "Color", M(t21.color));
        break;
      }
    }
    const C4 = i13.primitiveName;
    let b5 = [0, 0, 0, 1], x8 = [0, 0, 0, 0], z2 = 0, E8 = false;
    if (m8.symbol?.symbolLayers) for (const t21 of m8.symbol.symbolLayers) {
      const e16 = t21.primitiveName;
      if ("CIMSolidStroke" === t21.type) x8 = this._getValueOrOverrideExpression("CIMSolidStroke", e16, "Color", M(t21.color)), z2 = this._getValueOrOverrideExpression("CIMSolidStroke", e16, "Width", G(t21) ?? 0);
      else if ("CIMSolidFill" === t21.type) {
        const r13 = M(t21.color);
        E8 = E8 ?? !!t21.colorLocked, b5 = this._getValueOrOverrideExpression("CIMSolidFill", e16 ?? C4, "Color", r13);
      }
    }
    let I3 = null, L7 = null, N3 = null, R5 = null, A6 = null;
    C4 && (I3 = this._maybeGetValueOrOverrideExpression(C4, "TextSize"), L7 = this._maybeGetValueOrOverrideExpression(C4, "TextAngle"), N3 = this._maybeGetValueOrOverrideExpression(C4, "TextOffsetX"), R5 = this._maybeGetValueOrOverrideExpression(C4, "TextOffsetY"), E8 || (A6 = this._maybeGetValueOrOverrideExpression(C4, "FillColor")));
    const G3 = A6 ?? b5;
    let T5 = null, W2 = null, D4 = 0;
    if (m8.callout && "CIMBackgroundCallout" === m8.callout.type) {
      const e16 = m8.callout;
      if (e16.backgroundSymbol) {
        const t21 = e16.backgroundSymbol.symbolLayers;
        if (t21) for (const e17 of t21) "CIMSolidFill" === e17.type ? T5 = M(e17.color) : "CIMSolidStroke" === e17.type && (W2 = M(e17.color), D4 = h2(e17.width, n2.CIMSolidStroke.width));
      }
    }
    const U6 = this._getValueOrOverrideExpression(m8.type, i13.primitiveName, "TextString", i13.textString ?? "");
    if (null == U6) return;
    const { fontStyleName: H3 } = m8, J3 = h15 + (H3 ? "-" + H3.toLowerCase() : "-regular"), B4 = this._getMaterialOverrides(o15, m8.type);
    B4.push(...this._getPrimitiveMaterialOverrides(i13.primitiveName, m8.type)), this._collectDictionaryTemplateOverrides(B4, i13);
    const q4 = { type: "text-rasterization-param", resource: { type: "text", textString: i13.textString ?? "", font: m8.font, symbol: m8, primitiveName: i13.primitiveName }, overrides: B4 };
    this._cimLayers.push({ type: "text", lineWidth: m8.lineWidth, textRasterizationParam: q4, colorLocked: !!n18 || !!E8, effects: e15, alignment: a15, anchorPoint: { x: 0, y: 0 }, isAbsoluteAnchorPoint: false, fontName: J3, decoration: y4, haloSize: S5, haloColor: k5, weight: d10.weight, style: d10.style, size: I3 ?? f12, angle: L7 ?? u17, offsetX: N3 ?? v7, offsetY: R5 ?? g7, transform: { type: "cim-marker-transform-param", params: l16 }, horizontalAlignment: v(m8.horizontalAlignment), verticalAlignment: E(m8.verticalAlignment), text: U6, color: G3, outlineColor: x8, outlineSize: z2, backgroundColor: T5, borderLineColor: W2, borderLineWidth: D4, referenceSize: s13, sizeRatio: 1, markerPlacement: r12 });
  }
  _collectDictionaryTemplateOverrides(e15, t21) {
    if (t21.textString && this._hasTextStringTemplates) {
      const r12 = J(t21.symbol);
      e15.push({ propertyName: "textString", defaultValue: "", valueExpressionInfo: { type: "dictionary-template", textCase: r12, template: t21.textString }, primitiveName: t21.primitiveName });
    }
  }
  _analyzeMultiLayerGraphicNonSDF(e15, t21, r12, i13, a15, s13, l16, n18, p9, c10, m8, y4) {
    const d10 = Z2(e15, i13), h15 = e15.primitiveName, f12 = this._analyzeMaterialOverrides(h15, ["Rotation", "OffsetX", "OffsetY"]), v7 = X(f12), [g7, _10, S5] = te.getTextureAnchor(d10, this._resourceManager, oi), M6 = this._getMaterialOverrides(a15, e15.type);
    M6.push(...v7);
    const k5 = { type: "sprite-rasterization-param", resource: { ...d10, avoidSDFRasterization: true }, overrides: M6 }, C4 = h2(e15.size, n2.CIMVectorMarker.size), b5 = this._getValueOrOverrideExpression(e15.type, h15, "Size", C4);
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: k5, colorLocked: m8, effects: t21, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: s13, anchorPoint: { x: g7, y: _10 }, isAbsoluteAnchorPoint: false, size: c10, rotation: 0, offsetX: 0, offsetY: 0, transform: { type: "cim-marker-transform-param", params: n18 }, color: [255, 255, 255, 1], outlineColor: [0, 0, 0, 0], outlineWidth: 0, scaleX: 1, frameHeight: c10, widthRatio: 1, rotateClockwise: !!e15.rotateClockwise, referenceSize: l16, sizeRatio: S5 / u3(e15.size), isOutline: y4, markerPlacement: r12, animationParams: se(p9), baseSize: b5 });
  }
  _createMarkerPlacementOverrideExpression(e15) {
    if (!e15) return null;
    const t21 = [];
    return v2.findApplicableOverrides(e15, this._primitiveOverrides, t21), { type: "cim-marker-placement-param", placement: e15, overrides: ae(t21) };
  }
  _createGIFAnimatedSymbolPropertiesOverrideExpression(e15) {
    if (!e15) return null;
    const t21 = [];
    return v2.findApplicableOverrides(e15, this._primitiveOverrides, t21), { type: "cim-gif-animation-params", animation: e15, overrides: ae(t21) };
  }
  _analyzeCompositeMarkerGraphic(e15, t21, r12, i13, o15, a15, s13, l16, n18, p9, c10) {
    const m8 = i13.geometry, y4 = o15[0], d10 = o15[1], h15 = m5(m8);
    if (!h15) return;
    const f12 = "Relative" !== e15.anchorPointUnits, u17 = h2(y4.width, n2.CIMSolidStroke.width), { frameSizeRatio: v7, anchorX: g7, anchorY: _10, widthRatio: S5, sdfPaddingRatio: M6 } = h5(h15, e15.frame, e15.size, e15.anchorPoint, f12, u17, e15.scaleSymbolsProportionally), { path: b5 } = d10, x8 = d10.primitiveName, z2 = y4.primitiveName, E8 = i13.primitiveName;
    let I3 = null;
    d10.colorLocked || p9 || (I3 = this._maybeGetValueOrOverrideExpression(E8, "FillColor"));
    const L7 = I3 ?? this._getValueOrOverrideExpression(d10.type, x8, "Color", M(d10.color));
    let N3 = null;
    y4.colorLocked || p9 || (N3 = this._maybeGetValueOrOverrideExpression(E8, "StrokeColor"));
    const R5 = N3 ?? this._getValueOrOverrideExpression(y4.type, z2, "Color", M(y4.color)), A6 = this._maybeGetValueOrOverrideExpression(E8, "StrokeWidth") ?? this._getValueOrOverrideExpression(y4.type, z2, "Width", u17), w4 = { type: "sprite-rasterization-param", resource: b5 ? { type: "path", path: b5, asFill: true } : { type: "sdf", geom: m8, sdfPaddingRatio: M6, asFill: true }, overrides: [] };
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: w4, colorLocked: p9, effects: t21, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: a15, anchorPoint: { x: g7, y: _10 }, isAbsoluteAnchorPoint: f12, size: n18, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l16 }, frameHeight: n18, widthRatio: S5, rotateClockwise: false, referenceSize: s13, sizeRatio: v7, color: L7, outlineColor: R5, outlineWidth: A6, isOutline: c10, markerPlacement: r12 });
  }
  _setPoMap(e15, t21, r12) {
    let i13;
    this._poMap[e15] ? i13 = this._poMap[e15] : (i13 = {}, this._poMap[e15] = i13), i13[t21] = r12;
  }
  _maybeGetValueOrOverrideExpression(e15, t21, r12) {
    return this._getValueOrOverrideExpression("", e15, t21, r12, false);
  }
  _getValueOrOverrideExpression(e15, t21, r12, i13, o15 = true) {
    if (o15 && !j2(i13) && (i13 = q(e15, r12.toLowerCase())), null == t21) return i13;
    const a15 = this._poMap[t21];
    if (null == a15) return i13;
    const s13 = a15[r12];
    return "string" == typeof s13 || "number" == typeof s13 || Array.isArray(s13) ? s13 : s13 ? { valueExpressionInfo: s13, defaultValue: i13 } : i13;
  }
  _analyzePrimitiveOverrides(e15, t21, r12, i13) {
    if (null == e15) return false;
    "string" == typeof e15 && (e15 = [e15]);
    for (const o15 of this._primitiveOverrides) if (e15.includes(o15.primitiveName) && o15.valueExpressionInfo) return true;
    if (null != t21) {
      for (const o15 of t21) if (o15?.overrides.length > 0) return true;
    }
    if (null != r12) {
      for (const o15 of r12) if (o15?.overrides.length > 0) return true;
    }
    if (null != i13) {
      for (const o15 of i13) if (o15?.overrides.length > 0) return true;
    }
    return false;
  }
  _getMaterialOverrides(e15, t21) {
    if (!e15) return [];
    const r12 = [];
    for (const i13 of e15) r12.push(...this._getPrimitiveMaterialOverrides(i13, t21));
    return r12;
  }
  _getPrimitiveMaterialOverrides(e15, t21) {
    if (!e15) return [];
    const r12 = X(this._primitiveOverrides.filter((t22) => t22.primitiveName === e15));
    return r12.forEach((e16) => e16.defaultValue = q(t21, e16.propertyName.toLowerCase())), r12;
  }
  _analyzeMaterialOverrides(e15, t21) {
    return this._primitiveOverrides.filter((r12) => r12.primitiveName !== e15 || !t21.includes(r12.propertyName));
  }
};
function Z2(e15, t21) {
  return { type: e15.type, enable: true, name: e15.name, colorLocked: e15.colorLocked, primitiveName: e15.primitiveName, anchorPoint: e15.anchorPoint, anchorPointUnits: e15.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e15.rotateClockwise, rotation: 0, size: e15.size, billboardMode3D: e15.billboardMode3D, depth3D: e15.depth3D, frame: e15.frame, markerGraphics: [t21], scaleSymbolsProportionally: e15.scaleSymbolsProportionally, respectFrame: e15.respectFrame, clippingPath: e15.clippingPath };
}
function $(e15) {
  if (e15 && 0 === e15.indexOf("Level_")) {
    const t21 = parseInt(e15.slice(6), 10);
    if (!isNaN(t21)) return t21;
  }
  return 0;
}
var te2 = (e15) => e15 && 2 === e15.length && e15[0].enable && e15[1].enable && "CIMSolidStroke" === e15[0].type && "CIMSolidFill" === e15[1].type && null == e15[0].path && null == e15[1].path && !e15[0].effects && !e15[1].effects && !e15[0].animations && !e15[1].animations;
function re(e15) {
  const t21 = e15.symbolLayers;
  if (!t21) return false;
  const r12 = t21.find((e16) => e16.effects?.find((e17) => "CIMGeometricEffectDashes" === e17.type && null != e17.dashTemplate)), i13 = t21.find((e16) => e16.effects?.find((e17) => "CIMGeometricEffectAddControlPoints" === e17.type));
  return !!r12 || !!i13;
}
function ie(e15) {
  return e15.some((e16) => "CIMSolidFill" !== e16.type && "CIMSolidStroke" !== e16.type && ("CIMVectorMarker" !== e16.type && "CIMPictureMarker" !== e16.type || null != e16.markerPlacement));
}
function oe(e15, t21) {
  if (t21?.some((e16) => "CIMGeometricEffectRadial" === e16.type) && t21?.some((e16) => "CIMGeometricEffectTaperedPolygon" === e16.type) && 2 === e15.length) {
    const t22 = e15.find((e16) => "CIMSolidFill" === e16.type), r12 = e15.find((e16) => "CIMSolidStroke" === e16.type), i13 = r12?.effects?.some((e16) => "CIMGeometricEffectDashes" === e16.type);
    if (null != t22 && null != r12 && !i13) return true;
  }
  return false;
}
function ae(e15) {
  return a(e15).map((e16) => ({ ...e16, propertyName: O2(e16.propertyName) }));
}
function se(e15) {
  return d6(e15) ? { type: "animation-params", params: e15 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e13 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o9(e15) {
  let o15 = e13;
  return e15.split("/").forEach((r12) => {
    o15 && (o15 = o15[r12]);
  }), o15;
}
var t16 = new e7(o9);
function n10(r12) {
  return t16.resolveIncludes(r12);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js
var t17 = (e15) => n5({ PATTERN: e15.pattern });
var a8 = { shaders: (r12) => ({ vertexShader: t17(r12) + n10("background/background.vert"), fragmentShader: t17(r12) + n10("background/background.frag") }) };
var d7 = { shaders: (r12) => ({ vertexShader: n10("circle/circle.vert"), fragmentShader: n10("circle/circle.frag") }) };
var n11 = (e15) => n5({ PATTERN: e15.pattern });
var i8 = { shaders: (r12) => ({ vertexShader: n11(r12) + n10("fill/fill.vert"), fragmentShader: n11(r12) + n10("fill/fill.frag") }) };
var l10 = { shaders: (r12) => ({ vertexShader: n10("outline/outline.vert"), fragmentShader: n10("outline/outline.frag") }) };
var s9 = (e15) => n5({ SDF: e15.sdf });
var f8 = { shaders: (r12) => ({ vertexShader: s9(r12) + n10("icon/icon.vert"), fragmentShader: s9(r12) + n10("icon/icon.frag") }) };
var h9 = (e15) => n5({ PATTERN: e15.pattern, SDF: e15.sdf });
var o10 = { shaders: (r12) => ({ vertexShader: h9(r12) + n10("line/line.vert"), fragmentShader: h9(r12) + n10("line/line.frag") }) };
var g3 = { shaders: (r12) => ({ vertexShader: n10("text/text.vert"), fragmentShader: n10("text/text.frag") }) };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js
var p5 = class {
  constructor() {
    this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((e15) => e15.dispose()), this._programByKey.clear();
  }
  getMaterialProgram(e15, r12, t21) {
    const a15 = r12.key << 3 | this._getMaterialOptionsValue(r12.type, t21);
    if (this._programByKey.has(a15)) return this._programByKey.get(a15);
    const s13 = this._getProgramTemplate(r12.type), { shaders: n18 } = s13, { vertexShader: c10, fragmentShader: o15 } = n18(t21), p9 = r12.getShaderHeader(), u17 = r12.getShaderMain(), i13 = c10.replace("#pragma header", p9).replace("#pragma main", u17), g7 = e15.programCache.acquire(i13, o15, r12.getAttributeLocations());
    return this._programByKey.set(a15, g7), g7;
  }
  _getMaterialOptionsValue(r12, t21) {
    switch (r12) {
      case L4.BACKGROUND:
        return (t21.pattern ? 1 : 0) << 1;
      case L4.FILL:
        return (t21.pattern ? 1 : 0) << 1;
      case L4.OUTLINE:
        return 0;
      case L4.LINE: {
        const e15 = t21;
        return (e15.sdf ? 1 : 0) << 2 | (e15.pattern ? 1 : 0) << 1;
      }
      case L4.ICON:
        return (t21.sdf ? 1 : 0) << 1;
      case L4.CIRCLE:
      case L4.TEXT:
      default:
        return 0;
    }
  }
  _getProgramTemplate(p9) {
    switch (p9) {
      case L4.BACKGROUND:
        return a8;
      case L4.CIRCLE:
        return d7;
      case L4.FILL:
        return i8;
      case L4.ICON:
        return f8;
      case L4.LINE:
        return o10;
      case L4.OUTLINE:
        return l10;
      case L4.TEXT:
        return g3;
      default:
        return null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/BitBlitRenderer.js
var _6 = class {
  constructor() {
    this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._vertexArrayObject = r2(this._vertexArrayObject);
  }
  render(r12, t21, e15, i13) {
    r12 && (this._initialized || this._initialize(r12), r12.setBlendFunctionSeparate(A2.ONE, A2.ONE_MINUS_SRC_ALPHA, A2.ONE, A2.ONE_MINUS_SRC_ALPHA), r12.bindVAO(this._vertexArrayObject), r12.useProgram(this._program), t21.setSamplingMode(e15), r12.bindTexture(t21, 0), this._program.setUniform1i("u_tex", 0), this._program.setUniform1f("u_opacity", i13), r12.drawArrays(R2.TRIANGLE_STRIP, 0, 4), r12.bindTexture(null, 0), r12.bindVAO());
  }
  _initialize(r12) {
    if (this._initialized) return true;
    const s13 = e8(r12, e11);
    if (!s13) return false;
    const a15 = new Int8Array(16);
    a15[0] = -1, a15[1] = -1, a15[2] = 0, a15[3] = 0, a15[4] = 1, a15[5] = -1, a15[6] = 1, a15[7] = 0, a15[8] = -1, a15[9] = 1, a15[10] = 0, a15[11] = 1, a15[12] = 1, a15[13] = 1, a15[14] = 1, a15[15] = 1;
    const _10 = e11.attributes, p9 = new o5(r12, _10, t8, /* @__PURE__ */ new Map([["geometry", E5.createVertex(r12, Y.STATIC_DRAW, a15)]]));
    return this._program = s13, this._vertexArrayObject = p9, this._initialized = true, true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js
var e14 = class {
  constructor(r12) {
    this._rctx = r12, this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((r12) => r12.dispose()), this._programByKey.clear();
  }
  getProgram(e15, t21 = []) {
    const a15 = e15.vsPath + "." + e15.fsPath + JSON.stringify(t21);
    if (this._programByKey.has(a15)) return this._programByKey.get(a15);
    const s13 = { ...t21.map((r12) => "string" == typeof r12 ? { name: r12, value: true } : r12).reduce((r12, e16) => ({ ...r12, [e16.name]: e16.value }), {}) }, { vsPath: o15, fsPath: h15, attributes: i13 } = e15, g7 = o6(o15, h15, i13, s13), m8 = this._rctx.programCache.acquire(g7.shaders.vertexShader, g7.shaders.fragmentShader, g7.attributes);
    if (!m8) throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(a15, m8), m8;
  }
};

// node_modules/@arcgis/core/symbols/cim/Rasterizer.js
var f9 = 512;
var d8 = class {
  constructor(e15) {
    this._resourceManager = e15, this._cachedRasterizationCanvas = null;
  }
  dispose() {
    this._cachedRasterizationCanvas = null;
  }
  get _canvas() {
    return this._cachedRasterizationCanvas || (this._cachedRasterizationCanvas = document.createElement("canvas")), this._cachedRasterizationCanvas;
  }
  rasterizeJSONResource(e15) {
    switch (e15.type) {
      case "dash": {
        const r12 = R(e15.dashTemplate), [a15, n18, s13] = m4(r12);
        return { size: [n18, s13], image: new Uint32Array(a15.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 };
      }
      case "fill-style": {
        const [t21, a15, n18, s13] = f5(this._canvas, e15, ai);
        return { size: [a15, n18], image: new Uint32Array(t21.buffer), sdf: false, simplePattern: true, anchorX: 0, anchorY: 0, rasterizationScale: s13 };
      }
      case "sdf":
        return u11(e15);
      case "CIMGradientFill":
      case "CIMGradientStroke":
      case "CIMHatchFill":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        return this._rasterizeCIMJSONResource(e15);
    }
  }
  _rasterizeCIMJSONResource(r12) {
    switch (r12.type) {
      case "CIMGradientFill":
      case "CIMGradientStroke": {
        const [e15, t21, n18] = g(this._canvas, r12);
        return { size: [t21, n18], image: new Uint32Array(e15.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0, samplingMode: "Discrete" === r12.gradientType || "CIMFixedColorRamp" === r12.colorRamp.type ? "Nearest" : "Linear" };
      }
      case "CIMHatchFill": {
        const t21 = te.fromCIMHatchFill(r12, ai);
        return this._rasterizeCIMVectorMarker(t21);
      }
      case "CIMPictureMarker": {
        const t21 = te.fromCIMInsidePolygon(r12);
        return this._rasterizeCIMVectorMarker(t21);
      }
      case "CIMVectorMarker": {
        if ("CIMMarkerPlacementInsidePolygon" === r12.markerPlacement?.type) {
          const t22 = te.fromCIMInsidePolygon(r12);
          return this._rasterizeCIMVectorMarker(t22);
        }
        const t21 = a6(r12);
        return t21 && !r12.avoidSDFRasterization ? u11(t21) : this._rasterizeCIMVectorMarker(r12, false, oi);
      }
    }
  }
  _rasterizeCIMVectorMarker(r12, t21 = true, a15) {
    const s13 = t21 ? t3.fromExtent(r12.frame) : null, [i13, o15, c10, l16, h15] = te.rasterize(this._canvas, r12, s13, this._resourceManager, true, a15);
    return i13 ? { size: [o15, c10], image: new Uint32Array(i13.buffer), sdf: false, simplePattern: false, anchorX: l16, anchorY: h15 } : null;
  }
  rasterizeImageResource(e15, r12, t21, a15) {
    this._canvas.width = e15, this._canvas.height = r12;
    const n18 = this._canvas.getContext("2d", { willReadFrequently: true });
    t21 instanceof ImageData ? n18.putImageData(t21, 0, 0) : (t21.setAttribute("width", `${e15}px`), t21.setAttribute("height", `${r12}px`), n18.drawImage(t21, 0, 0, e15, r12));
    const s13 = n18.getImageData(0, 0, e15, r12), i13 = new Uint8Array(s13.data);
    if (a15) {
      for (const c10 of a15) if (c10 && c10.oldColor && 4 === c10.oldColor.length && c10.newColor && 4 === c10.newColor.length) {
        const [e16, r13, t22, a16] = c10.oldColor, [n19, s14, o16, l17] = c10.newColor;
        if (e16 === n19 && r13 === s14 && t22 === o16 && a16 === l17) continue;
        for (let c11 = 0; c11 < i13.length; c11 += 4) e16 === i13[c11] && r13 === i13[c11 + 1] && t22 === i13[c11 + 2] && a16 === i13[c11 + 3] && (i13[c11] = n19, i13[c11 + 1] = s14, i13[c11 + 2] = o16, i13[c11 + 3] = l17);
      }
    }
    let o15;
    for (let c10 = 0; c10 < i13.length; c10 += 4) o15 = i13[c10 + 3] / 255, i13[c10] = i13[c10] * o15, i13[c10 + 1] = i13[c10 + 1] * o15, i13[c10 + 2] = i13[c10 + 2] * o15;
    let l16 = i13, h15 = e15, d10 = r12;
    const u17 = f9;
    if (h15 >= u17 || d10 >= u17) {
      const t22 = h15 / d10;
      t22 > 1 ? (h15 = u17, d10 = Math.round(u17 / t22)) : (d10 = u17, h15 = Math.round(u17 * t22)), l16 = new Uint8Array(4 * h15 * d10);
      const a16 = new Uint8ClampedArray(l16.buffer);
      f2(i13, e15, r12, a16, h15, d10, false);
    }
    return { size: [h15, d10], image: new Uint32Array(l16.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
};
function u11(e15) {
  if (!e15) return null;
  const { data: r12, width: t21, height: a15, sdfPaddingRatio: n18, sdfDecodeCoeff: s13 } = u8(e15);
  return r12 ? { size: [t21, a15], image: new Uint32Array(r12.buffer), sdf: true, simplePattern: true, sdfPaddingRatio: n18, sdfDecodeCoeff: s13, anchorX: 0, anchorY: 0 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t18 = class {
  constructor(t21, e15) {
    this._width = 0, this._height = 0, this._free = [], this._width = t21, this._height = e15, this._free.push(new t5(0, 0, t21, e15));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t21, e15) {
    if (t21 > this._width || e15 > this._height) return new t5();
    let i13 = null, s13 = -1;
    for (let h15 = 0; h15 < this._free.length; ++h15) {
      const r12 = this._free[h15];
      t21 <= r12.width && e15 <= r12.height && (null === i13 || r12.y <= i13.y && r12.x <= i13.x) && (i13 = r12, s13 = h15);
    }
    return null === i13 ? new t5() : (this._free.splice(s13, 1), i13.width < i13.height ? (i13.width > t21 && this._free.push(new t5(i13.x + t21, i13.y, i13.width - t21, e15)), i13.height > e15 && this._free.push(new t5(i13.x, i13.y + e15, i13.width, i13.height - e15))) : (i13.width > t21 && this._free.push(new t5(i13.x + t21, i13.y, i13.width - t21, i13.height)), i13.height > e15 && this._free.push(new t5(i13.x, i13.y + e15, t21, i13.height - e15))), new t5(i13.x, i13.y, t21, e15));
  }
  release(h15) {
    for (let t21 = 0; t21 < this._free.length; ++t21) {
      const e15 = this._free[t21];
      if (e15.y === h15.y && e15.height === h15.height && e15.x + e15.width === h15.x) e15.width += h15.width;
      else if (e15.x === h15.x && e15.width === h15.width && e15.y + e15.height === h15.y) e15.height += h15.height;
      else if (h15.y === e15.y && h15.height === e15.height && h15.x + h15.width === e15.x) e15.x = h15.x, e15.width += h15.width;
      else {
        if (h15.x !== e15.x || h15.width !== e15.width || h15.y + h15.height !== e15.y) continue;
        e15.y = h15.y, e15.height += h15.height;
      }
      this._free.splice(t21, 1), this.release(h15);
    }
    this._free.push(h15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n12 = 256;
var o11 = (t21) => Math.floor(t21 / 256);
function c5(t21) {
  const e15 = /* @__PURE__ */ new Set();
  for (const i13 of t21) e15.add(o11(i13));
  return e15;
}
function l11(e15, i13, h15) {
  return e15.has(i13) || e15.set(i13, h15().then(() => {
    e15.delete(i13);
  }).catch((h16) => {
    e15.delete(i13), f(h16);
  })), e15.get(i13);
}
var g4 = (t21) => ({ rect: new t5(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t21, sdf: true });
var p6 = class {
  constructor(t21, e15, h15) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t21, this.height = e15, this._glyphSource = h15, this._binPack = new t18(t21 - 4, e15 - 4), this._glyphData.push(new Uint8Array(t21 * e15)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t21 of this._textures) t21 && t21.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t21 = [117, 149, 181, 207, 207, 181, 149, 117], e15 = [], i13 = [];
    for (let r12 = 0; r12 < t21.length; r12++) {
      const h16 = t21[r12];
      for (let t22 = 0; t22 < 11; t22++) {
        const s14 = r12 >= 3 && r12 < 5 && t22 >= 3 && t22 < 8 ? 255 : 0;
        e15.push(h16), i13.push(s14);
      }
    }
    const h15 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e15) }, s13 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i13) };
    this._recordGlyph(h15), this._recordGlyph(s13);
  }
  getTexture(t21, e15) {
    if (!this._textures[e15]) {
      const i13 = new a4();
      i13.pixelFormat = M3.ALPHA, i13.wrapMode = P2.CLAMP_TO_EDGE, i13.width = this.width, i13.height = this.height, this._textures[e15] = new S2(t21, i13, new Uint8Array(this.width * this.height));
    }
    return this._dirties[e15] && (this._textures[e15].setData(this._glyphData[e15]), this._dirties[e15] = false), this._textures[e15];
  }
  async getGlyphItems(t21, e15, i13) {
    const h15 = this._getGlyphCache(t21);
    return await this._fetchRanges(t21, e15, i13), e15.map((e16) => this._getMosaicItem(h15, t21, e16));
  }
  bind(t21, e15, i13, h15) {
    const s13 = this.getTexture(t21, i13);
    s13.setSamplingMode(e15), t21.bindTexture(s13, h15);
  }
  preloadASCIIGlyphCache(t21) {
    const e15 = this._preloadCache[t21];
    if (null != e15) return e15;
    const i13 = this._glyphSource.preloadASCIIRange(t21).then(() => {
      const e16 = this._getGlyphCache(t21);
      for (let i14 = 0; i14 < 256; i14++) this._getMosaicItem(e16, t21, i14);
    });
    return this._preloadCache[t21] = i13, i13;
  }
  _getGlyphCache(t21) {
    return this._glyphCache[t21] || (this._glyphCache[t21] = {}), this._glyphCache[t21];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t21, e15, i13) {
    const h15 = c5(e15), s13 = [];
    h15.forEach((e16) => {
      s13.push(this._fetchRange(t21, e16, i13));
    }), await Promise.all(s13);
  }
  async _fetchRange(t21, e15, i13) {
    if (e15 > n12) return;
    const h15 = t21 + e15;
    return l11(this._rangePromises, h15, () => this._glyphSource.getRange(t21, e15, i13));
  }
  _getMosaicItem(t21, e15, i13) {
    if (!t21[i13]) {
      const h15 = this._glyphSource.getGlyph(e15, i13);
      if (!h15?.metrics) return g4(i13);
      const s13 = this._recordGlyph(h15), r12 = this._currentPage, a15 = h15.metrics;
      t21[i13] = { rect: s13, page: r12, metrics: a15, code: i13, sdf: true }, this._invalidate();
    }
    return t21[i13];
  }
  _recordGlyph(t21) {
    const h15 = t21.metrics;
    let s13;
    if (0 === h15.width) s13 = new t5(0, 0, 0, 0);
    else {
      const e15 = 3, r12 = h15.width + 2 * e15, a15 = h15.height + 2 * e15;
      s13 = this._binPack.allocate(r12, a15), s13.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t18(this.width - 4, this.height - 4), s13 = this._binPack.allocate(r12, a15));
      const n18 = this._glyphData[this._currentPage], o15 = t21.bitmap;
      let c10, l16;
      if (o15) for (let t22 = 0; t22 < a15; t22++) {
        c10 = r12 * t22, l16 = this.width * (s13.y + t22) + s13.x;
        for (let t23 = 0; t23 < r12; t23++) n18[l16 + t23] = o15[c10 + t23];
      }
      has("esri-glyph-debug") && this._showDebugPage(n18);
    }
    return s13;
  }
  _showDebugPage(t21) {
    const e15 = document.createElement("canvas"), i13 = e15.getContext("2d"), h15 = new ImageData(this.width, this.height), s13 = h15.data;
    e15.width = this.width, e15.height = this.height, e15.style.border = "1px solid black";
    for (let r12 = 0; r12 < t21.length; ++r12) s13[4 * r12] = t21[r12], s13[4 * r12 + 1] = 0, s13[4 * r12 + 2] = 0, s13[4 * r12 + 3] = 255;
    i13.putImageData(h15, 0, 0), document.body.appendChild(e15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a9 = class {
  constructor(e15) {
    for (this._metrics = [], this._bitmaps = []; e15.next(); ) switch (e15.tag()) {
      case 1: {
        const t21 = e15.getMessage();
        for (; t21.next(); ) switch (t21.tag()) {
          case 3: {
            const e16 = t21.getMessage();
            let a15, s13, r12, n18, i13, c10, g7;
            for (; e16.next(); ) switch (e16.tag()) {
              case 1:
                a15 = e16.getUInt32();
                break;
              case 2:
                s13 = e16.getBytes();
                break;
              case 3:
                r12 = e16.getUInt32();
                break;
              case 4:
                n18 = e16.getUInt32();
                break;
              case 5:
                i13 = e16.getSInt32();
                break;
              case 6:
                c10 = e16.getSInt32();
                break;
              case 7:
                g7 = e16.getUInt32();
                break;
              default:
                e16.skip();
            }
            e16.release(), a15 && (this._metrics[a15] = { width: r12, height: n18, left: i13, top: c10, advance: g7 }, this._bitmaps[a15] = s13);
            break;
          }
          default:
            t21.skip();
        }
        t21.release();
        break;
      }
      default:
        e15.skip();
    }
  }
  getMetrics(e15) {
    return this._metrics[e15];
  }
  getBitmap(e15) {
    return this._bitmaps[e15];
  }
};
var s10 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e15) {
    return this._ranges[e15];
  }
  addRange(e15, t21) {
    this._ranges[e15] = t21;
  }
};
var r9 = class {
  constructor(e15) {
    this._glyphInfo = {}, this._baseURL = e15;
  }
  getRange(s13, r12, n18) {
    const i13 = this._getFontStack(s13);
    if (i13.getRange(r12)) return Promise.resolve();
    const c10 = 256 * r12, g7 = c10 + 255, o15 = this._baseURL.replace("{fontstack}", s13).replace("{range}", c10 + "-" + g7);
    return H(o15, { responseType: "array-buffer", ...n18 }).then((e15) => {
      i13.addRange(r12, new a9(new a2(new Uint8Array(e15.data), new DataView(e15.data))));
    });
  }
  async preloadASCIIRange(s13) {
    const r12 = this._getFontStack(s13), n18 = 0, i13 = 255, c10 = this._baseURL.replace("{fontstack}", s13).replace("{range}", n18 + "-" + i13), g7 = await H(c10, { responseType: "array-buffer" }), o15 = new a9(new a2(new Uint8Array(g7.data), new DataView(g7.data)));
    for (let e15 = n18; e15 <= i13; e15++) r12.getRange(e15) || r12.addRange(e15, o15);
  }
  getGlyph(e15, t21) {
    const a15 = this._getFontStack(e15);
    if (!a15) return;
    const s13 = Math.floor(t21 / 256), r12 = a15.getRange(s13);
    return r12 ? { metrics: r12.getMetrics(t21), bitmap: r12.getBitmap(t21) } : void 0;
  }
  _getFontStack(e15) {
    let t21 = this._glyphInfo[e15];
    return t21 || (t21 = this._glyphInfo[e15] = new s10()), t21;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var o12 = 1e20;
var a10 = class {
  constructor(t21, e15 = 2) {
    this._textureSize = t21, this._rasterizationScale = e15, this._canvasSize = this._textureSize * this._rasterizationScale, this._svg = null;
    const { _canvasSize: s13 } = this, i13 = document.createElement("canvas");
    i13.width = i13.height = s13, this._context = i13.getContext("2d", { willReadFrequently: false }), this._gridOuter = new Float64Array(s13 * s13), this._gridInner = new Float64Array(s13 * s13), this._f = new Float64Array(s13), this._d = new Float64Array(s13), this._z = new Float64Array(s13 + 1), this._v = new Int16Array(s13);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg = n4(this._svg);
  }
  draw(i13, r12, n18) {
    const { _canvasSize: a15, _textureSize: h15, _rasterizationScale: _10 } = this, l16 = h15 / 4;
    this._initSVG();
    const c10 = this.createSVGString(i13, r12);
    return new Promise((i14, r13) => {
      const d10 = new Image();
      d10.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(c10), d10.onload = () => {
        d10.onload = null, this._context.clearRect(0, 0, a15, a15), this._context.drawImage(d10, 0, 0, a15, a15);
        const e15 = this._context.getImageData(0, 0, a15, a15), s13 = new Uint8Array(h15 * h15 * 4);
        for (let t21 = 0; t21 < a15 * a15; t21++) {
          const s14 = e15.data[4 * t21 + 3] / 255;
          this._gridOuter[t21] = 1 === s14 ? 0 : 0 === s14 ? o12 : Math.max(0, 0.5 - s14) ** 2, this._gridInner[t21] = 1 === s14 ? o12 : 0 === s14 ? 0 : Math.max(0, s14 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, a15, a15), this._edt(this._gridInner, a15, a15);
        for (let i15 = 0; i15 < h15 * h15; i15++) {
          let e16 = 0;
          for (let t21 = 0; t21 < _10; t21++) {
            const s14 = Math.floor(i15 / h15) * _10 + t21;
            for (let t22 = 0; t22 < _10; t22++) {
              const r14 = s14 * a15 + (i15 % h15 * _10 + t22);
              e16 += this._gridOuter[r14] - this._gridInner[r14];
            }
          }
          e16 /= _10 * _10, e16 /= _10;
          o4(0.5 - e16 / (2 * l16), s13, 4 * i15);
        }
        i14(s13);
      };
      const g7 = n18?.signal;
      g7 && m2(g7, () => r13(u2()));
    });
  }
  _initSVG() {
    return this._svg || (this._svg = e5()), this._svg;
  }
  createSVGString(t21, e15) {
    const s13 = this._initSVG(), i13 = t4("path");
    i13.setAttribute("d", t21), s13.appendChild(i13);
    const r12 = i13.getBBox(), o15 = r12.width / r12.height, a15 = this._canvasSize / 2;
    let h15, _10, l16;
    if (o15 > 1) {
      h15 = a15 / r12.width;
      const t22 = a15 * (1 / o15);
      _10 = this._canvasSize / 4, l16 = a15 - t22 / 2;
    } else {
      h15 = a15 / r12.height;
      _10 = a15 - a15 * o15 / 2, l16 = this._canvasSize / 4;
    }
    const c10 = -r12.x * h15 + _10, d10 = -r12.y * h15 + l16;
    i13.setAttribute("style", `transform: matrix(${h15}, 0, 0, ${h15}, ${c10}, ${d10})`), i13.setAttribute("stroke-width", "" + 0.5 / h15);
    const g7 = `<svg style="fill:${e15 ? "red" : "none"}; stroke:${e15 ? "none" : "red"}" height="${this._canvasSize}" width="${this._canvasSize}" xmlns="http://www.w3.org/2000/svg">${s13.innerHTML}</svg>`;
    return s13.removeChild(i13), g7;
  }
  _edt(t21, e15, s13) {
    const i13 = this._f, r12 = this._d, n18 = this._v, o15 = this._z;
    for (let a15 = 0; a15 < e15; a15++) {
      for (let r13 = 0; r13 < s13; r13++) i13[r13] = t21[r13 * e15 + a15];
      this._edt1d(i13, r12, n18, o15, s13);
      for (let i14 = 0; i14 < s13; i14++) t21[i14 * e15 + a15] = r12[i14];
    }
    for (let a15 = 0; a15 < s13; a15++) {
      for (let s14 = 0; s14 < e15; s14++) i13[s14] = t21[a15 * e15 + s14];
      this._edt1d(i13, r12, n18, o15, e15);
      for (let s14 = 0; s14 < e15; s14++) t21[a15 * e15 + s14] = Math.sqrt(r12[s14]);
    }
  }
  _edt1d(t21, e15, s13, i13, r12) {
    s13[0] = 0, i13[0] = -1e20, i13[1] = 1e20;
    for (let n18 = 1, o15 = 0; n18 < r12; n18++) {
      let e16 = (t21[n18] + n18 * n18 - (t21[s13[o15]] + s13[o15] * s13[o15])) / (2 * n18 - 2 * s13[o15]);
      for (; e16 <= i13[o15]; ) o15--, e16 = (t21[n18] + n18 * n18 - (t21[s13[o15]] + s13[o15] * s13[o15])) / (2 * n18 - 2 * s13[o15]);
      o15++, s13[o15] = n18, i13[o15] = e16, i13[o15 + 1] = 1e20;
    }
    for (let n18 = 0, o15 = 0; n18 < r12; n18++) {
      for (; i13[o15 + 1] < n18; ) o15++;
      e15[n18] = (n18 - s13[o15]) * (n18 - s13[o15]) + t21[s13[o15]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c6(t21) {
  return t21 && "static" === t21.type;
}
var n13 = class _n {
  constructor(t21, e15, i13 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, this._pageWidth = t21, this._pageHeight = e15, i13 > 0 && (this._maxItemSize = i13), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t18(this._pageWidth, this._pageHeight);
    const s13 = Math.floor(this._pageWidth), r12 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s13 * r12) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t21) {
    return t21 >= this._mosaicPages.length ? -1 : this._mosaicPages[t21].size[0];
  }
  getHeight(t21) {
    return t21 >= this._mosaicPages.length ? -1 : this._mosaicPages[t21].size[1];
  }
  getPageTexture(t21) {
    return t21 < this._mosaicPages.length ? this._mosaicPages[t21].texture : null;
  }
  has(t21) {
    return this._mosaicRects.has(t21);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t21) {
    return this._mosaicRects.get(t21);
  }
  addSpriteItem(t21, i13, a15, r12, o15, h15, n18 = 1, g7 = "Linear", p9 = 0.5, m8 = 1) {
    if (this._mosaicRects.has(t21)) return this._mosaicRects.get(t21);
    let d10, u17, l16;
    if (c6(a15)) [d10, u17, l16] = this._allocateImage(i13[0], i13[1]);
    else {
      d10 = new t5(0, 0, i13[0], i13[1]), u17 = this._mosaicPages.length;
      const t22 = void 0;
      this._mosaicPages.push({ mosaicsData: a15, size: [i13[0] + 2 * ti, i13[1] + 2 * ti], dirty: true, texture: t22 });
    }
    if (d10.width <= 0 || d10.height <= 0) return null;
    const _10 = { type: "sprite", rect: d10, width: i13[0], height: i13[1], sdf: o15, simplePattern: h15, rasterizationScale: n18, samplingMode: g7, sdfPaddingRatio: p9, sdfDecodeCoeff: m8, page: u17 };
    return this._mosaicRects.set(t21, _10), c6(a15) && (has("esri-mosaic-debug") && this._showDebugSprite(i13, a15.data), this._copy({ rect: d10, spriteSize: i13, spriteData: a15.data, page: u17, pageSize: l16, repeat: r12, sdf: o15 })), _10;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t21 = this._spriteCopyQueue.pop();
    t21 && this._copy(t21);
  }
  getMosaicItemPosition(t21) {
    const i13 = this.getSpriteItem(t21), s13 = i13?.rect;
    if (!s13) return null;
    s13.width = i13.width, s13.height = i13.height;
    const a15 = i13.width, r12 = i13.height, o15 = ti, h15 = this._mosaicPages[i13.page].size;
    return { size: [i13.width, i13.height], tl: [(s13.x + o15) / h15[0], (s13.y + o15) / h15[1]], br: [(s13.x + o15 + a15) / h15[0], (s13.y + o15 + r12) / h15[1]], page: i13.page };
  }
  bind(t21, e15, i13 = 0, s13 = 0) {
    const a15 = this._mosaicPages[i13], r12 = a15.mosaicsData;
    let o15 = a15.texture;
    if (o15 || (o15 = p7(t21, a15.size), a15.texture = o15), o15.setSamplingMode(e15), c6(r12)) t21.bindTexture(o15, s13), a15.dirty && (o15.setData(new Uint8Array(r12.data.buffer)), o15.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i13));
    else {
      r12.data.loadFrame(o15), t21.bindTexture(o15, s13), o15.generateMipmap();
    }
    a15.dirty = false;
  }
  getTexture(t21, e15 = 0) {
    const i13 = this._mosaicPages[e15], s13 = i13.mosaicsData;
    let a15 = i13.texture;
    if (a15 || (a15 = p7(t21, i13.size), i13.texture = a15), c6(s13)) i13.dirty && (a15.setData(new Uint8Array(s13.data.buffer)), a15.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(e15));
    else {
      s13.data.loadFrame(a15), a15.generateMipmap();
    }
    return i13.dirty = false, a15;
  }
  dispose() {
    this._binPack = null;
    for (const t21 of this._mosaicPages) {
      const e15 = t21.texture;
      e15 && e15.dispose();
      const i13 = t21.mosaicsData;
      if (!c6(i13)) {
        i13.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t21, e15, i13, s13, a15, r12, o15, h15, c10, n18, g7) {
    let p9 = s13 * e15 + i13, m8 = h15 * r12 + o15;
    if (g7) {
      m8 -= r12;
      for (let o16 = -1; o16 <= n18; o16++, p9 = ((o16 + n18) % n18 + s13) * e15 + i13, m8 += r12) for (let e16 = -1; e16 <= c10; e16++) a15[m8 + e16] = t21[p9 + (e16 + c10) % c10];
    } else for (let d10 = 0; d10 < n18; d10++) {
      for (let e16 = 0; e16 < c10; e16++) a15[m8 + e16] = t21[p9 + e16];
      p9 += e15, m8 += r12;
    }
  }
  _copy(i13) {
    if (i13.page >= this._mosaicPages.length) return;
    const s13 = this._mosaicPages[i13.page], a15 = s13.mosaicsData;
    if (!c6(s13.mosaicsData)) throw new s2("mapview-invalid-resource", "unsuitable data type!");
    const r12 = i13.spriteData, o15 = a15.data;
    _n._copyBits(r12, i13.spriteSize[0], 0, 0, o15, i13.pageSize[0], i13.rect.x + ti, i13.rect.y + ti, i13.spriteSize[0], i13.spriteSize[1], i13.repeat), s13.dirty = true;
  }
  _allocateImage(t21, r12) {
    t21 += 2 * ti, r12 += 2 * ti;
    const o15 = Math.max(t21, r12);
    if (this._maxItemSize && this._maxItemSize < o15) {
      const e15 = 2 ** Math.ceil(e10(t21)), a15 = 2 ** Math.ceil(e10(r12)), o16 = new t5(0, 0, t21, r12);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e15 * a15) }, size: [e15, a15], dirty: true, texture: void 0 }), [o16, this._mosaicPages.length - 1, [e15, a15]];
    }
    const h15 = this._binPack.allocate(t21, r12);
    if (h15.width <= 0) {
      const e15 = this._mosaicPages[this._currentPage];
      return !e15.dirty && c6(e15.mosaicsData) && (e15.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t18(this._pageWidth, this._pageHeight), this._allocateImage(t21, r12);
    }
    return [h15, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t21, e15], i13) {
    const s13 = document.createElement("canvas");
    s13.width = t21, s13.height = e15, s13.setAttribute("style", `position: absolute; top: ${4 + 204 * g5++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a15 = s13.getContext("2d"), r12 = new ImageData(t21, e15);
    r12.data.set(new Uint8Array(i13.buffer)), a15.putImageData(r12, 0, 0), document.body.appendChild(s13);
  }
  _showDebugPage(t21) {
    const e15 = this._mosaicPages[t21], { size: [i13, s13], mosaicsData: a15 } = e15;
    if (!c6(a15)) return;
    const r12 = `mosaicDebugPage${t21}`, o15 = document.getElementById(r12) ?? document.createElement("canvas");
    o15.id = r12, o15.width = i13, o15.height = s13, o15.setAttribute("style", `position: absolute; top: ${4 + 204 * t21}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h15 = o15.getContext("2d"), n18 = new ImageData(i13, s13);
    n18.data.set(new Uint8Array(a15.data.buffer)), h15.putImageData(n18, 0, 0), document.body.appendChild(o15);
  }
};
var g5 = 0;
function p7(t21, e15) {
  const i13 = new a4();
  return i13.width = e15[0], i13.height = e15[1], i13.wrapMode = P2.CLAMP_TO_EDGE, new S2(t21, i13, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var a11 = class {
  constructor(t21, a15, h15, e15) {
    this._animation = t21, this._frameData = null;
    const n18 = (t22) => {
      this._frameData = t22, a15.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = c2(this._animation, h15, e15, n18);
  }
  destroy() {
    this._playHandle.remove();
  }
  loadFrame(i13) {
    const a15 = this._frameData;
    if (null == a15) return;
    const h15 = "width" in a15 ? a15.width : a15.codedWidth, e15 = "height" in a15 ? a15.height : a15.codedHeight;
    i13.updateData(0, ti, ti, h15, e15, a15), this._frameData = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/animations/store/AnimationStore.js
var h10 = class {
  constructor() {
    this._entries = new l12(), this._nodes = /* @__PURE__ */ new Map(), this._book = new a12();
  }
  add(t21) {
    let e15 = this._entries.get(t21);
    if (!e15) {
      const s13 = this._book.add(t21), r12 = new Object();
      e15 = { location: s13, references: 0, handle: r12 };
      const o15 = this._entries.set(t21, e15);
      this._nodes.set(r12, o15);
    }
    return e15.references++, e15;
  }
  remove(t21) {
    const e15 = this._nodes.get(t21.handle);
    e15 && e15.payload && (e15.payload.references--, 0 === e15.payload.references && (this._book.remove(e15.payload.location), this._entries.delete(e15), this._nodes.delete(t21.handle)));
  }
  getTexture(t21, e15) {
    return this._book.getTexture(t21, e15);
  }
  destroy() {
    this._book.destroy();
  }
};
var u12 = class _u {
  constructor(t21, e15) {
    this.parent = t21, this.key = e15, this.payload = null, this._children = /* @__PURE__ */ new Map();
  }
  get(t21) {
    return this._children.get(t21);
  }
  ensure(t21) {
    let e15 = this._children.get(t21);
    return e15 || (e15 = new _u(this, t21), this._children.set(t21, e15)), e15;
  }
  delete(t21) {
    this._children.delete(t21);
  }
};
var l12 = class {
  constructor() {
    this._root = new u12(null, NaN);
  }
  set(t21, e15) {
    let s13 = this._root;
    for (const r12 of t21) for (const t22 of r12) s13 = s13.ensure(t22);
    return s13.payload = e15, s13;
  }
  delete(t21) {
    t21.parent?.delete(t21.key);
  }
  get(t21) {
    let e15 = this._root;
    for (const s13 of t21) for (const t22 of s13) {
      const s14 = e15.get(t22);
      if (!s14) return;
      e15 = s14;
    }
    return e15.payload || void 0;
  }
};
var a12 = class {
  constructor() {
    this._pages = [];
  }
  add(t21) {
    0 === this._pages.length && this._pages.push(new _7());
    let e15 = this._pages.length - 1, s13 = this._pages[e15].add(t21);
    if (s13 || (this._pages.push(new _7()), e15 = this._pages.length - 1, s13 = this._pages[e15].add(t21)), !s13) throw new Error("Data allocation failed.");
    return { ...s13, page: e15 };
  }
  remove(t21) {
    this._pages[t21.page].remove(t21);
  }
  getTexture(t21, e15) {
    return this._pages[e15].getTexture(t21);
  }
  destroy() {
  }
};
var _7 = class {
  constructor() {
    this._cursor = { row: 0, column: 0 }, this._columns = 1024, this._rows = 1024, this._data = new Float32Array(this._columns * this._rows * 4), this._texture = null, this._textureCursor = { row: 0, column: 0 };
  }
  add(t21) {
    if (t21.length > this._columns) throw new Error(`The maximum allocation size is ${this._columns} texels.`);
    const e15 = { ...this._cursor };
    if (e15.column += t21.length, e15.column >= this._columns && (e15.column = t21.length, e15.row++), e15.row >= this._rows) return null;
    this._cursor = e15;
    const s13 = { ...this._cursor };
    s13.column -= t21.length;
    let r12 = 4 * (s13.row * this._columns + s13.column);
    for (let o15 = 0; o15 < t21.length; o15++) this._data[r12++] = t21[o15][0], this._data[r12++] = t21[o15][1], this._data[r12++] = t21[o15][2], this._data[r12++] = t21[o15][3];
    return s13;
  }
  remove(t21) {
  }
  getTexture(h15) {
    if (!this._texture) {
      const u18 = new a4(this._columns, this._rows);
      u18.pixelFormat = M3.RGBA, u18.dataType = X2.FLOAT, u18.wrapMode = P2.CLAMP_TO_EDGE, u18.samplingMode = L3.NEAREST, u18.hasMipmap = false;
      const l17 = new a5(h15, u18);
      this._texture = new S2(h15, l17);
    }
    if (this._cursor.row === this._textureCursor.row && this._cursor.column === this._textureCursor.column) return this._texture;
    const u17 = this._textureCursor.row, l16 = this._cursor.row - u17 + 1;
    return this._texture.updateData(0, 0, u17, this._columns, l16, this._data, u17), this._textureCursor.row = this._cursor.row, this._textureCursor.column = this._cursor.column, this._texture;
  }
  destroy() {
    this._texture?.dispose();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var $2 = "arial-unicode-ms-regular";
var v5 = () => i.getLogger("esri.views.MapView");
var k4 = (e15, t21, i13) => v5().error(new s2(e15, t21, i13));
var A5 = (e15, t21 = "") => v5().warnOnce(e15, t21);
var F3 = class _F {
  static fromMosaic(e15, t21) {
    return new _F(e15, t21.page, t21.sdf, t21.samplingMode);
  }
  constructor(e15, t21, i13, s13) {
    this.mosaicType = e15, this.page = t21, this.sdf = i13, this.samplingMode = s13;
  }
};
var G2 = class {
  constructor(i13) {
    this._requestRender = i13, this._resourceManager = new i5(), this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new a10(ei), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new _({ concurrency: 10, process: async (e15, i14) => {
      s3(i14);
      try {
        return await H(e15, { responseType: "image", signal: i14 });
      } catch (r12) {
        if (!b(r12)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${e15}`, r12);
        throw r12;
      }
    } }), this.animationStore = new h10(), this._spriteMosaic = new n13(2048, 2048, 500), this._glyphSource = new r9(`${s.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p6(1024, 1024, this._glyphSource), this._rasterizer = new d8(this.resourceManager);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null, this._resourceManager.destroy(), this.animationStore.destroy();
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  get resourceManager() {
    return this._resourceManager;
  }
  async rasterizeItem(e15, t21) {
    if (null == e15) return k4("mapview-null-resource", "Unable to rasterize null resource"), null;
    if ("animation-info" === e15.type) {
      const { resource: t22 } = e15, i14 = this.animationStore.add(t22), { location: s14 } = i14;
      return { rect: new t5(s14.column, s14.row, t22.length, 1), page: s14.page, type: "sprite", width: t22.length, height: 1, rasterizationScale: 1, sdfPaddingRatio: 0.5, samplingMode: "Linear", sdfDecodeCoeff: 1, simplePattern: false };
    }
    if ("cim-rasterization-info" !== e15.type) return k4("mapview-unexpected-resource", "Unable to rasterize resource"), null;
    const { resource: i13 } = e15;
    if ("text" === i13.type) {
      const e16 = await this._rasterizeText(i13, t21);
      for (const t22 of e16.glyphs) this._setTextureBinding(A3.GLYPH, t22);
      return e16;
    }
    const s13 = await this._rasterizeSprite(i13, t21);
    return s13 && this._setTextureBinding(A3.SPRITE, s13), s13;
  }
  getMosaicInfo(e15, t21, i13 = false) {
    const s13 = this._getTextureBindingInfo(e15, t21, i13);
    return s13 ? { size: s13.size, texture: { texture: s13.texture, unit: "sprite" === s13.type ? U3 : u6 } } : (k4("mapview-invalid-resource", `Unable to find resource for ${t21}`), { size: [0, 0], texture: { texture: null, unit: 0 } });
  }
  _getTextureBindingInfo(e15, t21, i13) {
    const s13 = this._bindingInfos[t21 - 1], r12 = s13.page, a15 = "Nearest" === s13.samplingMode ? L3.NEAREST : i13 ? L3.LINEAR_MIPMAP_LINEAR : L3.LINEAR;
    switch (s13.mosaicType) {
      case A3.SPRITE: {
        const t22 = [this.sprites.getWidth(r12), this.sprites.getHeight(r12)], i14 = this._spriteMosaic.getTexture(e15, r12);
        return i14.setSamplingMode(a15), { type: "sprite", texture: i14, size: t22 };
      }
      case A3.GLYPH: {
        const t22 = [this.glyphs.width, this.glyphs.height], i14 = this._glyphMosaic.getTexture(e15, r12);
        return this._glyphMosaic.bind(e15, a15, r12, u6), i14.setSamplingMode(a15), { type: "glyph", texture: i14, size: t22 };
      }
      default:
        return k4("mapview-texture-manager", `Cannot handle unknown type ${s13.mosaicType}`), null;
    }
  }
  _hashMosaic(e15, t21) {
    return 1 | e15 << 1 | (t21.sdf ? 1 : 0) << 2 | ("Nearest" === t21.samplingMode ? 1 : 0) << 3 | t21.page << 4;
  }
  _setTextureBinding(e15, t21) {
    const i13 = this._hashMosaic(e15, t21);
    if (!this._hashToBindingIndex.has(i13)) {
      const s13 = F3.fromMosaic(e15, t21), r12 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i13, r12), this._bindingInfos.push(s13);
    }
    t21.textureBinding = this._hashToBindingIndex.get(i13);
  }
  async _rasterizeText(e15, t21) {
    const { font: s13, textString: a15 } = e15, n18 = f4(s13), o15 = this._invalidFontsMap.has(n18), [c10, h15] = i4(a15), l16 = d5(c10);
    try {
      const e16 = o15 ? $2 : n18;
      has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(e16);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(e16, l16, t21), isRightToLeft: h15 };
    } catch (u17) {
      A5(`Font ${n18} is not available on the web, using "Arial Unicode MS Regular"`), this._invalidFontsMap.set(n18, true);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems($2, l16, t21), isRightToLeft: h15 };
    }
  }
  _hashSpriteResource(e15) {
    switch (e15.type) {
      case "path":
        return `path:${e15.path}.${e15.asFill ? 1 : 0}`;
      case "CIMPictureMarker":
        return `${e15.type}:${e15.url}:${e15.size}:${p2(e15.markerPlacement)}`;
      case "CIMPictureFill":
        return `${e15.type}:${e15.url}:${e15.height}`;
      case "CIMPictureStroke":
        return `${e15.type}:${e15.url}:${e15.width}`;
      case "dash":
        return `dash:${e15.capStyle}.${R(e15.dashTemplate).join("")}`;
      case "sdf":
        return `sdf:${JSON.stringify(e15.geom)}.${e15.asFill ? 1 : 0}`;
      case "fill-style":
        return `fill_style:${e15.style}`;
      case "animated":
        return JSON.stringify(r6(e15));
      case "CIMGradientFill":
      case "CIMGradientStroke":
        return `gradient:${JSON.stringify(e15.colorRamp)}.${e15.gradientType}.${e15.interval}`;
      case "CIMHatchFill":
      case "CIMVectorMarker":
        return JSON.stringify(e15);
    }
  }
  async _rasterizeSprite(e15, t21) {
    if (!e15) return null;
    const i13 = l(this._hashSpriteResource(e15));
    if (this._spriteMosaic.has(i13)) return this._spriteMosaic.getSpriteItem(i13);
    if ("url" in e15 && e15.url || "CIMPictureFill" === e15.type || "CIMPictureStroke" === e15.type || "CIMPictureMarker" === e15.type || "CIMVectorMarker" === e15.type) {
      const t22 = [];
      te.fetchResources({ type: "CIMPointSymbol", symbolLayers: [e15] }, this._resourceManager, t22), t22.length > 0 && await Promise.all(t22);
    }
    switch (e15.type) {
      case "CIMPictureMarker":
        return "CIMMarkerPlacementInsidePolygon" === e15.markerPlacement?.type ? this._rasterizeJSONResource(i13, e15) : this._handleAsyncResource(i13, e15, t21);
      case "animated":
      case "CIMPictureFill":
      case "CIMPictureStroke":
      case "path":
        return this._handleAsyncResource(i13, e15, t21);
      case "CIMGradientFill":
      case "CIMGradientStroke":
      case "CIMHatchFill":
      case "CIMVectorMarker":
      case "dash":
      case "fill-style":
      case "sdf":
        return this._rasterizeJSONResource(i13, e15);
    }
  }
  _rasterizeJSONResource(e15, t21) {
    const i13 = this._rasterizer.rasterizeJSONResource(t21);
    if (i13) {
      const { size: s13, image: r12, sdf: a15, simplePattern: n18, rasterizationScale: o15, samplingMode: c10, sdfPaddingRatio: h15, sdfDecodeCoeff: l16 } = i13;
      return this._addItemToMosaic(e15, s13, { type: "static", data: r12 }, N2(t21), a15, n18, o15, c10, h15, l16);
    }
    return null;
  }
  async _handleAsyncResource(e15, t21, i13) {
    if (this._ongoingRasterizations.has(e15)) return this._ongoingRasterizations.get(e15);
    let s13;
    return s13 = "path" === t21.type ? this._handleSVG(t21, e15, i13) : this._handleImage(t21, e15, i13), this._ongoingRasterizations.set(e15, s13), s13.finally(() => this._ongoingRasterizations.delete(e15)), s13;
  }
  async _handleSVG(e15, t21, i13) {
    const s13 = [ei, ei], { asFill: r12 } = e15, a15 = await this._sdfConverter.draw(e15.path, r12, i13);
    return this._addItemToMosaic(t21, s13, { type: "static", data: new Uint32Array(a15.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(e15, t21, i13) {
    const s13 = e15.url, r12 = this.resourceManager.getResource(s13);
    if (null == r12) return null;
    const { width: a15, height: n18 } = r12;
    if (r12 instanceof HTMLImageElement) {
      if ("animated" === e15.type) return k4("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
      const i14 = "colorSubstitutions" in e15 ? e15.colorSubstitutions : void 0, { size: s14, sdf: o16, image: c11 } = this._rasterizer.rasterizeImageResource(a15, n18, r12, i14);
      return this._addItemToMosaic(t21, s14, { type: "static", data: c11 }, N2(e15), o16, false);
    }
    let o15, c10, h15;
    "animated" === e15.type ? (o15 = false, c10 = { type: "CIMAnimatedSymbolProperties", playAnimation: e15.playAnimation, reverseAnimation: e15.reverseAnimation, randomizeStartTime: e15.randomizeStartTime, randomizeStartSeed: e15.randomizeStartSeed, startTimeOffset: e15.startTimeOffset, duration: e15.duration, repeatType: e15.repeatType, repeatDelay: e15.repeatDelay }, h15 = e15.startGroup || 0) : (o15 = N2(e15), c10 = { type: "CIMAnimatedSymbolProperties" }, h15 = 0);
    const l16 = new a11(r12, this._requestRender, c10, h15);
    return this._addItemToMosaic(t21, [l16.width, l16.height], { type: "animated", data: l16 }, o15, false, false);
  }
  async _handleImage(e15, t21, i13) {
    const r12 = e15.url;
    if (L6(r12) || U5(r12)) return this._handleGIFOrPNG(e15, t21, i13);
    if ("animated" === e15.type) return k4("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
    try {
      let s13;
      const a15 = this.resourceManager.getResource(r12);
      if (null != a15 && a15 instanceof HTMLImageElement) s13 = a15;
      else {
        const { data: e16 } = await this._imageRequestQueue.push(r12, { ...i13 });
        s13 = e16;
      }
      if (f6(r12)) {
        if ("width" in e15 && "height" in e15) s13.width = u3(e15.width), s13.height = u3(e15.height);
        else if ("cim" in e15) {
          const t22 = e15;
          s13.width = u3(t22.width ?? t22.scaleX * t22.size), s13.height = u3(t22.size);
        }
      }
      if (!s13.width || !s13.height) return null;
      const n18 = s13.width, o15 = s13.height, c10 = "colorSubstitutions" in e15 ? e15.colorSubstitutions : void 0, { size: l16, sdf: u17, image: p9 } = this._rasterizer.rasterizeImageResource(n18, o15, s13, c10);
      return this._addItemToMosaic(t21, l16, { type: "static", data: p9 }, N2(e15), u17, false);
    } catch (k5) {
      if (!b(k5)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${r12}. ${k5.message}`);
      throw k5;
    }
  }
  _addItemToMosaic(e15, t21, i13, s13, r12, a15, n18, o15, c10, h15) {
    return this._spriteMosaic.addSpriteItem(e15, t21, i13, s13, r12, a15, n18, o15, c10, h15);
  }
};
function N2(e15) {
  switch (e15.type) {
    case "CIMVectorMarker":
    case "CIMPictureMarker":
      return E7(e15);
    default:
      return true;
  }
}
var B3 = (e15) => null != e15 && e15.startsWith("data:image/gif");
var L6 = (e15) => e15 && (e15.includes(".gif") || B3(e15));
var O6 = (e15) => null != e15 && e15.startsWith("data:image/png");
var U5 = (e15) => e15 && (e15.includes(".png") || O6(e15));
var E7 = (e15) => e15 && "markerPlacement" in e15 && e15.markerPlacement && "CIMMarkerPlacementInsidePolygon" === e15.markerPlacement.type;

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureUploadManager.js
var u13 = class {
  constructor(e15) {
    this._queue = [], this._refreshable = e15;
  }
  destroy() {
    this._queue = [];
  }
  enqueueTextureUpdate(r12, u17) {
    const n18 = L(), h15 = r12, i13 = Ui, a15 = Math.ceil(h15.height / i13);
    s3(u17);
    for (let e15 = 0; e15 < a15; e15++) {
      const t21 = e15 * i13, s13 = e15 === a15 - 1, o15 = s13 ? h15.height - i13 * e15 : i13;
      this._queue.push({ type: "chunk", request: r12, resolver: n18, chunk: e15, chunkOffset: t21, destHeight: o15, chunkIsLast: s13, options: u17 });
    }
    return w(u17, (e15) => n18.reject(e15)), n18.promise;
  }
  upload() {
    const e15 = performance.now();
    let t21 = 0;
    for (; this._queue.length; ) {
      const s13 = this._queue.shift();
      if (s13) {
        if (null != s13.options.signal && s13.options.signal.aborted) continue;
        switch (s13.type) {
          case "chunk":
            this._uploadChunk(s13);
            break;
          case "no-chunk":
            this._uploadNoChunk(s13);
        }
        ++t21;
        const o15 = performance.now() - e15;
        if (o15 + o15 / t21 >= ui) break;
      }
    }
    this._queue.length && this._refreshable.requestRender();
  }
  _uploadChunk(e15) {
    const { request: t21, resolver: s13, chunkOffset: o15, chunkIsLast: r12, destHeight: u17 } = e15, { data: n18, texture: h15, width: i13 } = t21;
    null != n18 && (h15.updateData(0, 0, o15, i13, u17, n18, o15), r12 && s13.resolve());
  }
  _uploadNoChunk(e15) {
    const { request: t21, resolver: s13 } = e15, { data: o15, texture: r12 } = t21;
    r12.setData(o15), s13.resolve();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WorldExtentClipRenderer.js
var g6 = r5(-0.5, -0.5);
var x4 = class {
  constructor() {
    this._centerNdc = n(), this._pxToNdc = n(), this._worldDimensionsPx = n(), this._mat3 = e6(), this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._quad = r2(this._quad);
  }
  render(t21, i13, e15) {
    const { context: r12 } = t21, s13 = this._updateGeometry(t21, e15);
    if (null != i13) {
      const { r: t22, g: e16, b: s14, a: o15 } = i13;
      r12.setClearColor(o15 * t22 / 255, o15 * e16 / 255, o15 * s14 / 255, o15);
    } else r12.setClearColor(0, 0, 0, 0);
    if (r12.setStencilFunction(C.ALWAYS, 0, 255), r12.setStencilWriteMask(255), !s13) return r12.setClearStencil(Ci), void r12.clear(_4.STENCIL | _4.COLOR);
    r12.setClearStencil(Ei), r12.clear(_4.STENCIL | _4.COLOR), this._initialized || this._initialize(r12), r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setColorMask(false, false, false, false), r12.setBlendingEnabled(false), r12.setStencilOp(D.KEEP, D.KEEP, D.REPLACE), r12.setStencilFunction(C.ALWAYS, Ci, 255), r12.setStencilTestEnabled(true), r12.useProgram(this._program), this._program.setUniformMatrix3fv("u_worldExtent", this._mat3), this._quad.bind(), this._quad.draw(), this._quad.unbind();
  }
  _initialize(t21) {
    if (this._initialized) return;
    const i13 = e8(t21, r7);
    i13 && (this._program = i13, this._quad = new n8(t21, [0, 0, 1, 0, 0, 1, 1, 1]), this._initialized = true);
  }
  _updateGeometry(t21, a15) {
    const { state: n18, pixelRatio: l16 } = t21, { size: c10, rotation: h15 } = n18, d10 = Math.round(c10[0] * l16), p9 = Math.round(c10[1] * l16);
    if (!n18.spatialReference.isWrappable) return false;
    const _10 = u4(h15), f12 = Math.abs(Math.cos(_10)), u17 = Math.abs(Math.sin(_10)), b5 = Math.round(d10 * f12 + p9 * u17), x8 = Math.round(l16 * n18.worldScreenWidth);
    if (b5 <= x8) return false;
    const S5 = d10 * u17 + p9 * f12, E8 = (a15.left - a15.right) * l16 / d10, j4 = (a15.bottom - a15.top) * l16 / p9;
    o2(this._worldDimensionsPx, x8, S5, 1), o2(this._pxToNdc, 2 / d10, -2 / p9, 1), o2(this._centerNdc, E8, j4, 1);
    const C4 = this._mat3;
    return l5(C4, this._centerNdc), f3(C4, C4, this._pxToNdc), 0 !== h15 && h3(C4, C4, _10), f3(C4, C4, this._worldDimensionsPx), M2(C4, C4, g6), true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/blend/BlendTechnique.js
var f10 = class extends t10 {
  constructor() {
    super(...arguments), this.type = e4.Blend, this._backBufferTexture = null, this.shaders = { blend: new D2(), opacity: new h6() };
  }
  shutdown() {
    super.shutdown(), null !== this._backBufferTexture && (this._backBufferTexture.dispose(), this._backBufferTexture = null);
  }
  render(t21, r12) {
    const { context: s13, state: i13, pixelRatio: o15, inFadeTransition: n18, painter: a15 } = t21, { size: c10 } = i13, f12 = s13.getBoundFramebufferObject();
    let h15, l16;
    null != f12 ? (h15 = f12.width, l16 = f12.height) : (h15 = Math.round(o15 * c10[0]), l16 = Math.round(o15 * c10[1]));
    const { blendMode: d10 } = r12;
    if ("normal" === d10) {
      const t22 = { shader: this.shaders.opacity, uniforms: { config: { layerTexture: { texture: r12.colorTexture, unit: 0 }, opacity: r12.config.opacity } }, defines: null, optionalAttributes: null, useComputeBuffer: false };
      return a15.setPipelineState(t9), void a15.submitDrawMesh(s13, t22, a15.quadMesh);
    }
    const p9 = this._createOrResizeTexture(t21, h15, l16);
    f12.copyToTexture(0, 0, h15, l16, 0, 0, p9);
    const x8 = { color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: A2.ONE, dstRGB: A2.ZERO, srcAlpha: A2.ONE, dstAlpha: A2.ZERO } }, depth: false, stencil: false };
    a15.setPipelineState(x8);
    const b5 = { backbufferTexture: { texture: p9, unit: 0 }, layerTexture: { texture: r12.colorTexture, unit: 1 }, inFadeOpacity: n18 ? 1 : 0, ...r12.config }, T5 = { shader: this.shaders.blend, uniforms: { config: b5 }, defines: { blendMode: d10 }, optionalAttributes: null, useComputeBuffer: false };
    a15.submitDrawMesh(s13, T5, a15.quadMesh);
  }
  _createOrResizeTexture(e15, t21, r12) {
    const { context: s13 } = e15;
    if (null !== this._backBufferTexture && this._backBufferTexture.descriptor?.width === t21 && this._backBufferTexture.descriptor?.height === r12) return this._backBufferTexture;
    if (null === this._backBufferTexture) {
      const e16 = new a4();
      e16.internalFormat = M3.RGBA, e16.wrapMode = P2.CLAMP_TO_EDGE, e16.width = t21, e16.height = r12, this._backBufferTexture = new S2(s13, e16);
    } else this._backBufferTexture.resize(t21, r12);
    return this._backBufferTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var n14 = class {
  constructor() {
    this._blendTechnique = new f10();
  }
  dispose(e15) {
    this._blendTechnique?.shutdown();
  }
  draw(e15, n18, d10, i13, o15) {
    this._blendTechnique.render(e15, { colorTexture: n18, config: { opacity: o15, samplingMode: d10 }, blendMode: i13 });
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/Effect.js
var t19 = class {
  constructor() {
    this.name = this.constructor.name;
  }
  createOptions(t21, r12) {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/FeatureEffect.js
var r10 = class extends t19 {
  constructor(e15) {
    super(), this.name = this.constructor.name, this.defines = [e15];
  }
  dispose() {
  }
  bind({ context: e15, painter: s13 }) {
    this._prev = e15.getBoundFramebufferObject();
    const r12 = s13.getFbos().effect0;
    e15.bindFramebuffer(r12), e15.setColorMask(true, true, true, true), e15.setClearColor(0, 0, 0, 0), e15.clear(_4.COLOR);
  }
  unbind() {
  }
  draw(e15, t21) {
    const { context: r12, painter: o15 } = e15, n18 = o15.getPostProcessingEffects(t21), c10 = r12.getBoundFramebufferObject();
    for (const { postProcessingEffect: s13, effect: f12 } of n18) s13.draw(e15, c10, f12);
    r12.bindFramebuffer(this._prev), r12.setStencilTestEnabled(false), o15.blitTexture(r12, c10.colorTexture, L3.NEAREST), r12.setStencilTestEnabled(true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightRenderer.js
var c7 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.quadGeometry.dispose(), this._resources.quadVAO.dispose(), this._resources.highlightProgram.dispose(), this._resources.blurProgram.dispose(), this._resources = null);
  }
  preBlur(e15, i13) {
    e15.bindTexture(i13, C2), e15.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [1, 0, 1 / this._width, 0]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", t11), e15.bindVAO(this._resources.quadVAO), e15.drawArrays(R2.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  finalBlur(e15, s13) {
    e15.bindTexture(s13, C2), e15.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [0, 1, 0, 1 / this._height]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", c3), e15.bindVAO(this._resources.quadVAO), e15.drawArrays(R2.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  renderHighlight(e15, s13, i13) {
    e15.bindTexture(s13, C2), e15.useProgram(this._resources.highlightProgram), i13.applyHighlightOptions(e15, this._resources.highlightProgram), e15.bindVAO(this._resources.quadVAO), e15.setBlendingEnabled(true), e15.setBlendFunction(A2.ONE, A2.ONE_MINUS_SRC_ALPHA), e15.drawArrays(R2.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  _initialize(s13, i13, h15) {
    this._width = i13, this._height = h15;
    const m8 = E5.createVertex(s13, Y.STATIC_DRAW, new Int8Array([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]).buffer), c10 = new o5(s13, /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]), /* @__PURE__ */ new Map([["geometry", [new t2("a_position", 2, O3.BYTE, 0, 4), new t2("a_texcoord", 2, O3.UNSIGNED_BYTE, 2, 4)]]]), /* @__PURE__ */ new Map([["geometry", m8]])), f12 = e8(s13, t12), b5 = e8(s13, r8);
    s13.useProgram(f12), f12.setUniform1i("u_texture", C2), f12.setUniform1i("u_shade", E3), f12.setUniform1f("u_sigma", o7), s13.useProgram(b5), b5.setUniform1i("u_texture", C2), b5.setUniform1f("u_sigma", o7), this._resources = { quadGeometry: m8, quadVAO: c10, highlightProgram: f12, blurProgram: b5 };
  }
  setup(r12, e15, s13) {
    this._resources ? (this._width = e15, this._height = s13) : this._initialize(r12, e15, s13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightSurfaces.js
function i9(i13, h15, u17) {
  const l16 = new a4(h15, u17);
  return l16.wrapMode = P2.CLAMP_TO_EDGE, new R3(i13, l16, new i6(V.STENCIL_INDEX8, h15, u17));
}
var h11 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.sharedBlur1Fbo.dispose(), this._resources.sharedBlur2Fbo.dispose(), this._resources = null);
  }
  _initialize(r12, e15, s13) {
    this._width = e15, this._height = s13;
    const t21 = i9(r12, e15, s13), o15 = i9(r12, e15, s13);
    this._resources = { sharedBlur1Fbo: t21, sharedBlur2Fbo: o15 };
  }
  setup(r12, e15, s13) {
    !this._resources || this._width === e15 && this._height === s13 || this.dispose(), this._resources || this._initialize(r12, e15, s13);
  }
  get sharedBlur1Tex() {
    return this._resources.sharedBlur1Fbo.colorTexture;
  }
  get sharedBlur1Fbo() {
    return this._resources.sharedBlur1Fbo;
  }
  get sharedBlur2Tex() {
    return this._resources.sharedBlur2Fbo.colorTexture;
  }
  get sharedBlur2Fbo() {
    return this._resources.sharedBlur2Fbo;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HighlightEffect.js
var d9 = 4;
var l13 = 4 / d9;
var o13 = class extends t19 {
  constructor() {
    super(...arguments), this.defines = ["highlight"], this._hlRenderer = new c7(), this._width = void 0, this._height = void 0, this._boundFBO = null, this._hlSurfaces = new h11(), this._adjustedWidth = void 0, this._adjustedHeight = void 0, this._blitRenderer = new _6();
  }
  dispose() {
    this._hlSurfaces?.dispose(), this._hlRenderer?.dispose(), this._boundFBO = null;
  }
  bind(e15) {
    const { context: t21, painter: s13 } = e15, { width: r12, height: h15 } = t21.getViewport(), d10 = s13.getFbos().effect0;
    this.setup(e15, r12, h15), t21.bindFramebuffer(d10), t21.setColorMask(true, true, true, true), t21.setClearColor(0, 0, 0, 0), t21.clear(_4.COLOR);
  }
  unbind() {
  }
  setup({ context: e15 }, t21, s13) {
    this._width = t21, this._height = s13;
    const r12 = t21 % d9, i13 = s13 % d9;
    t21 += r12 < d9 / 2 ? -r12 : d9 - r12, s13 += i13 < d9 / 2 ? -i13 : d9 - i13, this._adjustedWidth = t21, this._adjustedHeight = s13, this._boundFBO = e15.getBoundFramebufferObject();
    const h15 = Math.round(t21 * l13), o15 = Math.round(s13 * l13);
    this._hlRenderer.setup(e15, h15, o15), this._hlSurfaces.setup(e15, h15, o15);
  }
  draw(e15) {
    const { context: t21, passOptions: s13 } = e15, r12 = s13.activeGradient, d10 = t21.getBoundFramebufferObject();
    t21.setViewport(0, 0, this._adjustedWidth * l13, this._adjustedHeight * l13), t21.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t21.setStencilTestEnabled(false), t21.setClearColor(0, 0, 0, 0), t21.clear(_4.COLOR), this._blitRenderer.render(t21, d10.colorTexture, L3.NEAREST, 1), t21.setStencilTestEnabled(false), t21.setBlendingEnabled(false), t21.setColorMask(false, false, false, true), t21.bindFramebuffer(this._hlSurfaces.sharedBlur2Fbo), t21.setClearColor(0, 0, 0, 0), t21.clear(_4.COLOR), this._hlRenderer.preBlur(t21, this._hlSurfaces.sharedBlur1Tex), t21.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t21.setClearColor(0, 0, 0, 0), t21.clear(_4.COLOR), this._hlRenderer.finalBlur(t21, this._hlSurfaces.sharedBlur2Tex), t21.bindFramebuffer(this._boundFBO), t21.setBlendingEnabled(true), t21.setColorMask(true, true, true, true), t21.setViewport(0, 0, this._width, this._height), this._hlRenderer.renderHighlight(t21, this._hlSurfaces.sharedBlur1Tex, r12), this._boundFBO = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffect.js
var a13 = class extends t19 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["hittest"];
  }
  dispose() {
    null != this._fbo && this._fbo.dispose();
  }
  createOptions({ pixelRatio: e15 }, r12) {
    if (!r12.length) return null;
    const n18 = r12.shift(), l16 = n18.x, c10 = n18.y;
    this._outstanding = n18;
    const a15 = has("esri-mobile");
    return { type: "hittest", distance: (a15 ? S3 : W) * e15, smallSymbolDistance: (a15 ? S3 : X3) * e15, smallSymbolSizeThreshold: Y2, position: [l16, c10] };
  }
  bind(t21) {
    const { context: s13, attributeView: i13 } = t21;
    if (!i13.size) return;
    const o15 = i13.getBlock(J2.GPGPU);
    if (null == o15) return;
    const r12 = o15.getFBO(s13);
    s13.setViewport(0, 0, i13.size, i13.size), s13.bindFramebuffer(r12), s13.setColorMask(true, true, true, true), s13.setClearColor(0, 0, 0, 0), s13.clear(_4.COLOR | _4.DEPTH);
  }
  unbind() {
  }
  draw(t21) {
    if (null == this._outstanding) return;
    const e15 = this._outstanding;
    this._outstanding = null, this._resolve(t21, e15.resolvers);
  }
  async _resolve(t21, s13) {
    const { context: i13, attributeView: o15 } = t21, r12 = o15.getBlock(J2.GPGPU);
    if (null == r12) return void s13.forEach((t22) => t22.resolve([]));
    const n18 = r12.getFBO(i13), a15 = new Uint8Array(n18.width * n18.height * 4);
    try {
      await n18.readPixelsAsync(0, 0, n18.width, n18.height, M3.RGBA, X2.UNSIGNED_BYTE, a15);
    } catch (u17) {
      return void s13.forEach((t22) => t22.resolve([]));
    }
    const h15 = [];
    for (let e15 = 0; e15 < a15.length; e15 += 4) {
      const t22 = e15 / 4;
      a15[e15] && h15.push(t22);
    }
    s13.forEach((t22) => t22.resolve(h15));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Bloom.js
var a14 = 5;
var u14 = [1, 0];
var l14 = [0, 1];
var m7 = [1, 0.8, 0.6, 0.4, 0.2];
var _8 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var h12 = class {
  constructor() {
    this._intensityFBO = null, this._compositeFBO = null, this._mipsFBOs = new Array(a14), this._nMips = a14, this._kernelSizeArray = [3, 5, 7, 9, 11], this._size = [0, 0], this._programDesc = { luminosityHighPass: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/luminosityHighPass", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    if (this._quad = r2(this._quad), this._intensityFBO = r2(this._intensityFBO), this._compositeFBO = r2(this._compositeFBO), this._mipsFBOs) {
      for (let t21 = 0; t21 < this._nMips; t21++) this._mipsFBOs[t21] && (this._mipsFBOs[t21].horizontal.dispose(), this._mipsFBOs[t21].vertical.dispose());
      this._mipsFBOs = null;
    }
  }
  draw(t21, i13, r12) {
    const { width: o15, height: n18 } = i13, { context: h15, painter: p9 } = t21, { materialManager: c10 } = p9, d10 = h15.gl, f12 = this._programDesc, { strength: b5, radius: F5, threshold: O7 } = r12;
    this._quad || (this._quad = new n8(h15, [-1, -1, 1, -1, -1, 1, 1, 1])), this._createOrResizeResources(t21, o15, n18), h15.setStencilTestEnabled(false), h15.setBlendingEnabled(true), h15.setBlendFunction(A2.ONE, A2.ONE_MINUS_SRC_ALPHA), h15.setStencilWriteMask(0);
    const B4 = this._quad;
    B4.bind(), h15.bindFramebuffer(this._intensityFBO);
    const g7 = c10.getProgram(f12.luminosityHighPass);
    h15.useProgram(g7), h15.bindTexture(i13.colorTexture, 0), g7.setUniform1i("u_texture", 0), g7.setUniform3fv("u_defaultColor", [0, 0, 0]), g7.setUniform1f("u_defaultOpacity", 0), g7.setUniform1f("u_luminosityThreshold", O7), g7.setUniform1f("u_smoothWidth", 0.01);
    const T5 = [Math.round(o15 / 2), Math.round(n18 / 2)];
    h15.setViewport(0, 0, T5[0], T5[1]), h15.setClearColor(0, 0, 0, 0), h15.clear(d10.COLOR_BUFFER_BIT), B4.draw(), h15.setBlendingEnabled(false);
    let x8 = this._intensityFBO.colorTexture;
    for (let e15 = 0; e15 < this._nMips; e15++) {
      const t22 = c10.getProgram(f12.gaussianBlur, [{ name: "radius", value: this._kernelSizeArray[e15] }]);
      h15.useProgram(t22), h15.bindTexture(x8, e15 + 1), t22.setUniform1i("u_colorTexture", e15 + 1), t22.setUniform2fv("u_texSize", T5), t22.setUniform2fv("u_direction", u14), h15.setViewport(0, 0, T5[0], T5[1]);
      const s13 = this._mipsFBOs[e15];
      h15.bindFramebuffer(s13.horizontal), B4.draw(), x8 = s13.horizontal.colorTexture, h15.bindFramebuffer(s13.vertical), h15.bindTexture(x8, e15 + 1), t22.setUniform2fv("u_direction", l14), B4.draw(), x8 = s13.vertical.colorTexture, T5[0] = Math.round(T5[0] / 2), T5[1] = Math.round(T5[1] / 2);
    }
    h15.setViewport(0, 0, o15, n18);
    const w4 = c10.getProgram(f12.composite, [{ name: "nummips", value: a14 }]);
    h15.bindFramebuffer(this._compositeFBO), h15.useProgram(w4), w4.setUniform1f("u_bloomStrength", b5), w4.setUniform1f("u_bloomRadius", F5), w4.setUniform1fv("u_bloomFactors", m7), w4.setUniform3fv("u_bloomTintColors", _8), h15.bindTexture(this._mipsFBOs[0].vertical.colorTexture, 1), w4.setUniform1i("u_blurTexture1", 1), h15.bindTexture(this._mipsFBOs[1].vertical.colorTexture, 2), w4.setUniform1i("u_blurTexture2", 2), h15.bindTexture(this._mipsFBOs[2].vertical.colorTexture, 3), w4.setUniform1i("u_blurTexture3", 3), h15.bindTexture(this._mipsFBOs[3].vertical.colorTexture, 4), w4.setUniform1i("u_blurTexture4", 4), h15.bindTexture(this._mipsFBOs[4].vertical.colorTexture, 5), w4.setUniform1i("u_blurTexture5", 5), B4.draw(), h15.bindFramebuffer(i13), h15.setBlendingEnabled(true);
    const M6 = c10.getProgram(f12.blit);
    h15.useProgram(M6), h15.bindTexture(this._compositeFBO.colorTexture, 6), M6.setUniform1i("u_texture", 6), h15.setBlendFunction(A2.ONE, A2.ONE), B4.draw(), B4.unbind(), h15.setBlendFunction(A2.ONE, A2.ONE_MINUS_SRC_ALPHA), h15.setStencilTestEnabled(true);
  }
  _createOrResizeResources(t21, e15, s13) {
    const { context: a15 } = t21;
    if (this._compositeFBO && this._size[0] === e15 && this._size[1] === s13) return;
    this._size[0] = e15, this._size[1] = s13;
    const u17 = [Math.round(e15 / 2), Math.round(s13 / 2)];
    if (this._compositeFBO) this._compositeFBO.resize(e15, s13);
    else {
      const t22 = new a4(e15, s13);
      t22.internalFormat = M3.RGBA, t22.wrapMode = P2.CLAMP_TO_EDGE, this._compositeFBO = new R3(a15, t22);
    }
    if (this._intensityFBO) this._intensityFBO.resize(u17[0], u17[1]);
    else {
      const t22 = new a4(u17[0], u17[1]);
      t22.internalFormat = M3.RGBA, t22.wrapMode = P2.CLAMP_TO_EDGE, this._intensityFBO = new R3(a15, t22);
    }
    for (let l16 = 0; l16 < this._nMips; l16++) {
      if (this._mipsFBOs[l16]) this._mipsFBOs[l16].horizontal.resize(u17[0], u17[1]), this._mipsFBOs[l16].vertical.resize(u17[0], u17[1]);
      else {
        const t22 = new a4(u17[0], u17[1]);
        t22.internalFormat = M3.RGBA, t22.wrapMode = P2.CLAMP_TO_EDGE, this._mipsFBOs[l16] = { horizontal: new R3(a15, t22), vertical: new R3(a15, t22) };
      }
      u17[0] = Math.round(u17[0] / 2), u17[1] = Math.round(u17[1] / 2);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Blur.js
var n15 = [1, 0];
var o14 = [0, 1];
var u15 = class {
  constructor() {
    this._blurFBO = null, this._size = [0, 0], this._programDesc = { gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, radialBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/radial-blur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._blurFBO && (this._blurFBO.dispose(), this._blurFBO = null);
  }
  draw(t21, s13, r12) {
    const { context: i13 } = t21, { type: a15, radius: n18 } = r12;
    if (0 === n18) return;
    this._createOrResizeResources(t21), this._quad || (this._quad = new n8(i13, [-1, -1, 1, -1, -1, 1, 1, 1]));
    const o15 = this._quad;
    o15.bind(), "blur" === a15 ? this._gaussianBlur(t21, s13, n18) : this._radialBlur(t21, s13), o15.unbind();
  }
  _gaussianBlur(e15, s13, r12) {
    const { context: i13, state: a15, painter: u17, pixelRatio: l16 } = e15, { size: d10 } = a15, { materialManager: b5 } = u17, c10 = this._programDesc, _10 = this._quad, p9 = [Math.round(l16 * d10[0]), Math.round(l16 * d10[1])], h15 = this._blurFBO, m8 = b5.getProgram(c10.gaussianBlur, [{ name: "radius", value: Math.ceil(r12) }]);
    i13.useProgram(m8), i13.setBlendingEnabled(false), i13.bindFramebuffer(h15), i13.bindTexture(s13.colorTexture, 4), m8.setUniform1i("u_colorTexture", 4), m8.setUniform2fv("u_texSize", p9), m8.setUniform2fv("u_direction", n15), m8.setUniform1f("u_sigma", r12), _10.draw(), i13.bindFramebuffer(s13), i13.setStencilWriteMask(0), i13.setStencilTestEnabled(false), i13.setDepthWriteEnabled(false), i13.setDepthTestEnabled(false), i13.bindTexture(h15?.colorTexture, 5), m8.setUniform1i("u_colorTexture", 5), m8.setUniform2fv("u_direction", o14), _10.draw(), i13.setBlendingEnabled(true), i13.setBlendFunction(A2.ONE, A2.ONE_MINUS_SRC_ALPHA), i13.setStencilTestEnabled(true);
  }
  _radialBlur(e15, s13) {
    const { context: r12, painter: i13 } = e15, { materialManager: a15 } = i13, n18 = this._programDesc, o15 = this._quad, u17 = this._blurFBO;
    r12.bindFramebuffer(u17);
    const l16 = a15.getProgram(n18.radialBlur);
    r12.useProgram(l16), r12.setBlendingEnabled(false), r12.bindTexture(s13.colorTexture, 4), l16.setUniform1i("u_colorTexture", 4), o15.draw(), r12.bindFramebuffer(s13), r12.setStencilWriteMask(0), r12.setStencilTestEnabled(false), r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setBlendingEnabled(true);
    const d10 = a15.getProgram(n18.blit);
    r12.useProgram(d10), r12.bindTexture(u17?.colorTexture, 5), d10.setUniform1i("u_texture", 5), r12.setBlendFunction(A2.ONE, A2.ONE_MINUS_SRC_ALPHA), o15.draw();
  }
  _createOrResizeResources(e15) {
    const { context: t21, state: n18, pixelRatio: o15 } = e15, { size: u17 } = n18, l16 = Math.round(o15 * u17[0]), d10 = Math.round(o15 * u17[1]);
    if (!this._blurFBO || this._size[0] !== l16 || this._size[1] !== d10) if (this._size[0] = l16, this._size[1] = d10, this._blurFBO) this._blurFBO.resize(l16, d10);
    else {
      const e16 = new a4(l16, d10);
      e16.internalFormat = M3.RGBA, e16.wrapMode = P2.CLAMP_TO_EDGE, this._blurFBO = new R3(t21, e16);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Colorize.js
var n16 = class {
  constructor() {
    this._layerFBOTexture = null, this._size = [0, 0], this._programDesc = { vsPath: "post-processing/pp", fsPath: "post-processing/filterEffect", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  draw(e15, t21, s13) {
    const { width: i13, height: o15 } = t21;
    this._createOrResizeResources(e15, i13, o15);
    const { context: a15, painter: n18 } = e15, { materialManager: c10 } = n18, l16 = this._programDesc, u17 = this._quad, _10 = s13.colorMatrix;
    u17.bind();
    const h15 = this._layerFBOTexture;
    a15.bindFramebuffer(t21), t21.copyToTexture(0, 0, i13, o15, 0, 0, h15), a15.setBlendingEnabled(false), a15.setStencilTestEnabled(false);
    const m8 = c10.getProgram(l16);
    a15.useProgram(m8), a15.bindTexture(h15, 2), m8.setUniformMatrix4fv("u_coefficients", _10), m8.setUniform1i("u_colorTexture", 2), u17.draw(), a15.setBlendingEnabled(true), a15.setBlendFunction(A2.ONE, A2.ONE_MINUS_SRC_ALPHA), a15.setStencilTestEnabled(true), u17.unbind();
  }
  _createOrResizeResources(e15, r12, n18) {
    const { context: c10 } = e15;
    if (!this._layerFBOTexture || this._size[0] !== r12 || this._size[1] !== n18) {
      if (this._size[0] = r12, this._size[1] = n18, this._layerFBOTexture) this._layerFBOTexture.resize(r12, n18);
      else {
        const e16 = new a4();
        e16.internalFormat = M3.RGBA, e16.wrapMode = P2.CLAMP_TO_EDGE, e16.width = r12, e16.height = n18, this._layerFBOTexture = new S2(c10, e16);
      }
      this._quad || (this._quad = new n8(c10, [-1, -1, 1, -1, -1, 1, 1, 1]));
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/DropShadow.js
var u16 = [1, 0];
var h13 = [0, 1];
var _9 = class {
  constructor() {
    this._layerFBOTexture = null, this._horizontalBlurFBO = null, this._verticalBlurFBO = null, this._size = [0, 0], this._quad = null, this._programDesc = { blur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/drop-shadow/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture), this._horizontalBlurFBO = r2(this._horizontalBlurFBO), this._verticalBlurFBO = r2(this._verticalBlurFBO);
  }
  draw(e15, i13, o15) {
    const { context: a15, state: n18, painter: l16 } = e15, { materialManager: _10 } = l16, c10 = this._programDesc, p9 = i13.width, m8 = i13.height, f12 = [Math.round(p9), Math.round(m8)], { blurRadius: B4, offsetX: d10, offsetY: b5, color: O7 } = o15, F5 = [u3(d10), u3(b5)];
    this._createOrResizeResources(e15, p9, m8, f12);
    const w4 = this._horizontalBlurFBO, T5 = this._verticalBlurFBO;
    a15.setStencilWriteMask(0), a15.setStencilTestEnabled(false), a15.setDepthWriteEnabled(false), a15.setDepthTestEnabled(false);
    const x8 = this._layerFBOTexture;
    i13.copyToTexture(0, 0, p9, m8, 0, 0, x8), this._quad || (this._quad = new n8(a15, [-1, -1, 1, -1, -1, 1, 1, 1])), a15.setViewport(0, 0, f12[0], f12[1]);
    const g7 = this._quad;
    g7.bind(), a15.setBlendingEnabled(false);
    const z2 = _10.getProgram(c10.blur, [{ name: "radius", value: Math.ceil(B4) }]);
    a15.useProgram(z2), a15.bindFramebuffer(w4), a15.bindTexture(i13.colorTexture, 4), z2.setUniform1i("u_colorTexture", 4), z2.setUniform2fv("u_texSize", f12), z2.setUniform2fv("u_direction", u16), z2.setUniform1f("u_sigma", B4), g7.draw(), a15.bindFramebuffer(T5), a15.bindTexture(w4?.colorTexture, 5), z2.setUniform1i("u_colorTexture", 5), z2.setUniform2fv("u_direction", h13), g7.draw(), a15.bindFramebuffer(i13), a15.setViewport(0, 0, p9, m8);
    const M6 = _10.getProgram(c10.composite);
    a15.useProgram(M6), a15.bindTexture(T5?.colorTexture, 2), M6.setUniform1i("u_blurTexture", 2), a15.bindTexture(x8, 3), M6.setUniform1i("u_layerFBOTexture", 3), M6.setUniform4fv("u_shadowColor", [O7[3] * (O7[0] / 255), O7[3] * (O7[1] / 255), O7[3] * (O7[2] / 255), O7[3]]), M6.setUniformMatrix3fv("u_displayViewMat3", n18.displayMat3), M6.setUniform2fv("u_shadowOffset", F5), g7.draw(), a15.setBlendingEnabled(true), a15.setStencilTestEnabled(true), a15.setBlendFunction(A2.ONE, A2.ONE_MINUS_SRC_ALPHA), g7.unbind();
  }
  _createOrResizeResources(e15, t21, r12, s13) {
    const { context: u17 } = e15;
    if (!this._horizontalBlurFBO || this._size[0] !== t21 || this._size[1] !== r12) {
      if (this._size[0] = t21, this._size[1] = r12, this._horizontalBlurFBO) this._horizontalBlurFBO.resize(s13[0], s13[1]);
      else {
        const e16 = new a4(s13[0], s13[1]);
        e16.internalFormat = M3.RGBA, e16.wrapMode = P2.CLAMP_TO_EDGE, this._horizontalBlurFBO = new R3(u17, e16);
      }
      if (this._verticalBlurFBO) this._verticalBlurFBO.resize(s13[0], s13[1]);
      else {
        const e16 = new a4(s13[0], s13[1]);
        e16.internalFormat = M3.RGBA, e16.wrapMode = P2.CLAMP_TO_EDGE, this._verticalBlurFBO = new R3(u17, e16);
      }
      if (this._layerFBOTexture) this._layerFBOTexture.resize(t21, r12);
      else {
        const e16 = new a4();
        e16.internalFormat = M3.RGBA, e16.wrapMode = P2.CLAMP_TO_EDGE, e16.width = t21, e16.height = r12, this._layerFBOTexture = new S2(u17, e16);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Opacity.js
var l15 = class {
  constructor() {
    this._size = [0, 0], this._layerFBOTexture = null;
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  draw(e15, r12, s13) {
    const { width: i13, height: o15 } = r12;
    this._createOrResizeResources(e15, i13, o15);
    const { context: l16, painter: a15 } = e15, { amount: n18 } = s13, h15 = l16.gl, u17 = this._layerFBOTexture;
    l16.bindFramebuffer(r12), r12.copyToTexture(0, 0, i13, o15, 0, 0, u17), l16.setBlendingEnabled(true), l16.setStencilTestEnabled(false), l16.setDepthTestEnabled(false), l16.setClearColor(0, 0, 0, 0), l16.clear(h15.COLOR_BUFFER_BIT), a15.blitTexture(l16, u17, L3.NEAREST, n18);
  }
  _createOrResizeResources(e15, l16, a15) {
    const { context: n18 } = e15;
    if (!this._layerFBOTexture || this._size[0] !== l16 || this._size[1] !== a15) if (this._size[0] = l16, this._size[1] = a15, this._layerFBOTexture) this._layerFBOTexture.resize(l16, a15);
    else {
      const e16 = new a4();
      e16.internalFormat = M3.RGBA, e16.wrapMode = P2.CLAMP_TO_EDGE, e16.samplingMode = L3.NEAREST, e16.width = l16, e16.height = a15, this._layerFBOTexture = new S2(n18, e16);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/EffectManager.js
function c8(o15) {
  switch (o15) {
    case "bloom":
    case "blur":
    case "opacity":
    case "drop-shadow":
      return o15;
    default:
      return "colorize";
  }
}
var f11 = { colorize: () => new n16(), blur: () => new u15(), bloom: () => new h12(), opacity: () => new l15(), "drop-shadow": () => new _9() };
var i10 = class {
  constructor() {
    this._effectMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._effectMap.forEach((o15) => o15.dispose()), this._effectMap.clear();
  }
  getPostProcessingEffects(o15) {
    if (!o15 || 0 === o15.length) return [];
    const e15 = [];
    for (const t21 of o15) {
      const o16 = c8(t21.type);
      let s13 = this._effectMap.get(o16);
      s13 || (s13 = f11[o16](), this._effectMap.set(o16, s13)), e15.push({ postProcessingEffect: s13, effect: t21 });
    }
    return e15;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/painter/RenderPass.js
var t20 = class {
  constructor(e15, t21) {
    this.brushes = e15, this.name = t21.name, this.drawPhase = t21.drawPhase || E4.MAP, this._targetFn = t21.target, this.effects = t21.effects || [], this.enableDefaultDraw = t21.enableDefaultDraw ?? (() => true), this.forceDrawByDisplayOrder = !!t21.forceDrawByDisplayOrder;
  }
  render(e15) {
    const { context: r12, profiler: t21 } = e15, s13 = this._targetFn(), a15 = this.drawPhase & e15.drawPhase;
    if (t21.recordPassStart(this.name), a15) {
      this.enableDefaultDraw() && this._doRender(e15, s13), t21.recordPassEnd();
      for (const t22 of this.effects) {
        if (!t22.enable()) continue;
        const a16 = t22.apply, n18 = t22.args?.(), i13 = r12.getViewport(), o15 = r12.getBoundFramebufferObject(), d10 = e15.passOptions;
        this._bindEffect(e15, a16, n18), this._doRender(e15, s13, a16.defines), this._drawAndUnbindEffect(e15, a16, i13, o15, d10, n18);
      }
    }
  }
  _doRender(e15, r12, t21) {
    if (null == r12) return;
    const { profiler: s13, context: a15 } = e15;
    for (const n18 of this.brushes) {
      if (s13.recordBrushStart(n18.name), null != n18.brushEffect) {
        const s14 = a15.getViewport(), i13 = a15.getBoundFramebufferObject(), o15 = e15.passOptions;
        this._bindEffect(e15, n18.brushEffect), this._drawWithBrush(n18, e15, r12, t21), this._drawAndUnbindEffect(e15, n18.brushEffect, s14, i13, o15);
      } else this._drawWithBrush(n18, e15, r12, t21);
      s13.recordBrushEnd();
    }
  }
  _drawWithBrush(r12, t21, s13, a15) {
    m(s13) ? (r12.prepareState(t21, a15), r12.drawMany(t21, s13, a15)) : s13.visible && (r12.prepareState(t21, a15), r12.draw(t21, s13, a15));
  }
  _bindEffect(e15, r12, t21) {
    const { profiler: s13 } = e15;
    s13.recordPassStart(this.name + "." + r12.name), r12.bind(e15, t21);
    const a15 = r12.createOptions(e15, t21);
    e15.passOptions = a15;
  }
  _drawAndUnbindEffect(e15, r12, t21, s13, a15, n18) {
    const { profiler: i13, context: o15 } = e15;
    e15.passOptions = a15, i13.recordBrushStart(r12.name), r12.draw(e15, n18), r12.unbind(e15, n18), o15.bindFramebuffer(s13);
    const { x: d10, y: f12, width: h15, height: c10 } = t21;
    o15.setViewport(d10, f12, h15, c10), i13.recordBrushEnd(), i13.recordPassEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueProgramCache.js
var r11 = class {
  constructor() {
    this._programCache = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const r12 of this._programCache.values()) r12.destroy();
    this._programCache.clear();
  }
  getProgram(r12, e15, t21, a15, o15) {
    const s13 = r12.getShaderKey(e15, t21, a15, o15);
    let c10 = this._programCache.get(s13);
    return c10 || (c10 = r12.getProgram(e15, t21, a15, o15), this._programCache.set(s13, c10)), c10;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/Painter.js
var F4 = class {
  constructor(e15, t21) {
    this.context = e15, this._currentPipelineStateNeedsUpdate = false, this._blitRenderer = new _6(), this._worldExtentRenderer = new x4(), this._brushCache = /* @__PURE__ */ new Map(), this._lastWidth = null, this._lastHeight = null, this._vtlMaterialManager = new p5(), this._blendEffect = new n14(), this._stencilBuf = null, this._prevBeforeLayerFBOStack = [], this._fboPool = [], this.effects = { highlight: new o13(), hittest: new a13(), insideEffect: new r10("inside"), outsideEffect: new r10("outside") }, this._programCache = new r11(), this._shaderState = { shader: null, uniforms: null, defines: null, optionalAttributes: null, useComputeBuffer: false }, this.materialManager = new e14(e15), this.textureManager = new G2(t21), this.textureUploadManager = new u13(t21), this._effectsManager = new i10(), this._quadMesh = s8.fromVertexStream(e15, [0, 0, 1, 0, 0, 1, 1, 1]);
  }
  dispose() {
    if (this._programCache.destroy(), this.materialManager.dispose(), this.textureManager.dispose(), this.textureUploadManager.destroy(), this._blitRenderer = r2(this._blitRenderer), this._worldExtentRenderer = r2(this._worldExtentRenderer), this._quadMesh = u(this._quadMesh), this._brushCache && (this._brushCache.forEach((e15) => e15.dispose()), this._brushCache.clear(), this._brushCache = null), this._fbos) {
      let e15;
      for (e15 in this._fbos) this._fbos[e15] && this._fbos[e15].dispose();
    }
    for (const e15 of this._fboPool) e15.dispose();
    if (this._fboPool.length = 0, this.effects) {
      let e15;
      for (e15 in this.effects) this.effects[e15] && this.effects[e15].dispose();
    }
    this._effectsManager.dispose(), this._blendEffect.dispose(this.context), this._vtlMaterialManager = r2(this._vtlMaterialManager);
  }
  clearShaderCache() {
    this._programCache.destroy(), this._programCache = new r11();
  }
  get blitRenderer() {
    return this._blitRenderer;
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  get quadMesh() {
    return this._quadMesh;
  }
  getFbos() {
    if (!this._fbos) throw new Error("InternalError: Painter FBOs not initialized");
    return this._fbos;
  }
  acquireFbo(e15, t21) {
    let s13;
    if (this._fboPool.length > 0) s13 = this._fboPool.pop();
    else {
      const r12 = new a4(e15, t21);
      r12.samplingMode = L3.NEAREST, r12.wrapMode = P2.CLAMP_TO_EDGE, s13 = new R3(this.context, r12, this._stencilBuf);
    }
    return s13.width === e15 && s13.height === t21 || s13.resize(e15, t21), s13;
  }
  releaseFbo(e15) {
    this._fboPool.push(e15);
  }
  getSharedStencilBuffer() {
    return this._stencilBuf;
  }
  beforeRenderPhases(e15, t21, s13) {
    const { context: r12 } = e15;
    this._worldExtentRenderer.render(e15, t21, s13);
    const { width: i13, height: n18 } = r12.getViewport();
    if (this.updateFBOs(i13, n18), this._prevFBO = r12.getBoundFramebufferObject(), r12.bindFramebuffer(this.getFbos().output), r12.setColorMask(true, true, true, true), null != t21) {
      const { r: e16, g: s14, b: i14, a: n19 } = t21;
      r12.setClearColor(n19 * e16 / 255, n19 * s14 / 255, n19 * i14 / 255, n19);
    } else r12.setClearColor(0, 0, 0, 0);
    r12.setDepthWriteEnabled(true), r12.setClearDepth(1), r12.clear(_4.COLOR | _4.DEPTH), r12.setDepthWriteEnabled(false);
  }
  afterRenderPhases(e15) {
    const { context: t21 } = e15;
    t21.bindFramebuffer(this._prevFBO), t21.setStencilFunction(C.EQUAL, Ci, 255), t21.setStencilTestEnabled(true), t21.setDepthTestEnabled(false), this.blitTexture(t21, this.getFbos().output.colorTexture, L3.NEAREST);
  }
  beforeRenderLayer(e15, t21, s13) {
    const { context: r12, blendMode: i13, effects: n18, drawPhase: a15, requireFBO: o15 } = e15;
    if (r12.setClearColor(0, 0, 0, 0), o15 || x5(a15, i13, n18, s13)) {
      const e16 = r12.getBoundFramebufferObject();
      this._prevBeforeLayerFBOStack.push(e16);
      const { width: t22, height: s14 } = r12.getViewport(), i14 = this.acquireFbo(t22, s14);
      r12.bindFramebuffer(i14), r12.setColorMask(true, true, true, true), r12.setClearColor(0, 0, 0, 0), r12.setDepthWriteEnabled(true), r12.setClearDepth(1), r12.clear(_4.COLOR | _4.DEPTH), r12.setDepthWriteEnabled(false);
    }
    r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setStencilTestEnabled(true), r12.setClearStencil(t21), r12.setStencilWriteMask(255), r12.clear(_4.STENCIL);
  }
  afterRenderLayer(e15, t21) {
    const { context: s13, blendMode: r12, effects: i13, requireFBO: n18, drawPhase: o15 } = e15;
    if (n18 || x5(o15, r12, i13, t21)) {
      const n19 = s13.getBoundFramebufferObject();
      null != i13 && i13.length > 0 && o15 === E4.MAP && (s13.setColorMask(true, true, true, true), this._applyEffects(e15, i13, n19)), s13.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()), s13.setStencilTestEnabled(false), s13.setStencilWriteMask(0), s13.setBlendingEnabled(true), s13.setBlendFunctionSeparate(A2.ONE, A2.ONE_MINUS_SRC_ALPHA, A2.ONE, A2.ONE_MINUS_SRC_ALPHA), s13.setColorMask(true, true, true, true);
      const l16 = null == r12 || o15 === E4.HIGHLIGHT || o15 === E4.LABEL ? "normal" : r12;
      this._blendEffect.draw(e15, n19.colorTexture, L3.NEAREST, l16, t21), this.releaseFbo(n19);
    }
  }
  renderObject(e15, t21, r12, i13) {
    const n18 = m6[r12];
    if (!n18) return;
    let a15 = this._brushCache.get(n18);
    void 0 === a15 && (a15 = new n18(), this._brushCache.set(n18, a15)), a15.prepareState(e15), a15.draw(e15, t21, i13);
  }
  renderObjects(e15, t21, r12, i13) {
    const n18 = m6[r12];
    if (!n18) return;
    let a15 = this._brushCache.get(n18);
    void 0 === a15 && (a15 = new n18(), this._brushCache.set(n18, a15)), a15.drawMany(e15, t21, i13);
  }
  registerRenderPass(e15) {
    const t21 = e15.brushes.map((e16) => (this._brushCache.has(e16) || this._brushCache.set(e16, new e16()), this._brushCache.get(e16)));
    return new t20(t21, e15);
  }
  blitTexture(e15, t21, s13, r12 = 1) {
    e15.setBlendingEnabled(true), e15.setBlendFunctionSeparate(A2.ONE, A2.ONE_MINUS_SRC_ALPHA, A2.ONE, A2.ONE_MINUS_SRC_ALPHA), e15.setColorMask(true, true, true, true), this._blitRenderer.render(e15, t21, s13, r12), this._currentPipelineStateNeedsUpdate = true;
  }
  getPostProcessingEffects(e15) {
    return this._effectsManager.getPostProcessingEffects(e15);
  }
  updateFBOs(e15, t21) {
    if (e15 !== this._lastWidth || t21 !== this._lastHeight) {
      if (this._lastWidth = e15, this._lastHeight = t21, this._fbos) {
        let s14;
        for (s14 in this._fbos) this._fbos[s14].resize(e15, t21);
        return;
      }
      const s13 = new a4(e15, t21);
      s13.samplingMode = L3.NEAREST, s13.wrapMode = P2.CLAMP_TO_EDGE;
      const r12 = new i6(H2.DEPTH24_STENCIL8, e15, t21);
      this._stencilBuf = new s7(this.context, r12), this._fbos = { output: new R3(this.context, s13, this._stencilBuf), effect0: new R3(this.context, s13, this._stencilBuf) };
    }
  }
  _applyEffects(e15, t21, s13) {
    const { context: r12 } = e15, i13 = this._effectsManager.getPostProcessingEffects(t21);
    for (const { postProcessingEffect: n18, effect: a15 } of i13) r12.bindFramebuffer(s13), n18.draw(e15, s13, a15);
    this._currentPipelineStateNeedsUpdate = true;
  }
  setShader(e15) {
    this._shaderState.shader = e15.shader, this._shaderState.uniforms = e15.uniforms, this._shaderState.defines = e15.defines, this._shaderState.optionalAttributes = e15.optionalAttributes, this._shaderState.useComputeBuffer = e15.useComputeBuffer ?? false;
  }
  setPipelineState(e15) {
    e15 !== this._currentPipelineState && (this._currentPipelineState = e15, this._currentPipelineStateNeedsUpdate = true);
  }
  submitDraw(e15, t21) {
    const { shader: s13, uniforms: r12, defines: i13, optionalAttributes: n18 } = this._shaderState, a15 = e15.context, o15 = t21.getAttributePrecisionPackFactors(), l16 = this._programCache.getProgram(s13, o15, r12, i13 ?? {}, n18 ?? {});
    return l16.setUniforms(r12), l16.bind(a15), this.updatePipelineState(a15), this.setStencilRef(a15, t21), t21.draw(e15, s13.locationInfo), l16.cleanupTemporaryTextures(), { vertexShader: l16.vertexShader, fragmentShader: l16.fragmentShader };
  }
  submitDrawMesh(e15, t21, s13, r12) {
    this.submitDrawMeshUntyped(e15, t21, s13, r12);
  }
  submitDrawMeshUntyped(e15, t21, s13, r12) {
    this.setShader(t21);
    const { shader: i13, uniforms: n18, defines: a15, optionalAttributes: o15 } = this._shaderState, l16 = this._programCache.getProgram(i13, {}, n18, a15 ?? {}, o15 ?? {});
    if (l16.setUniforms(n18), l16.bind(e15), this.updatePipelineState(e15), r12) for (const h15 of r12) s13.bind(e15, t21.shader.locationInfo, h15), s13.draw(e15);
    else for (let h15 = 0; h15 < s13.parts.length; h15++) s13.bind(e15, t21.shader.locationInfo, h15), s13.draw(e15);
    s13.unbind(e15), l16.cleanupTemporaryTextures();
  }
  updatePipelineState(e15) {
    this._currentPipelineStateNeedsUpdate && (this._currentPipelineStateNeedsUpdate = false, this._updatePipelineState(e15));
  }
  _updatePipelineState(e15) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { color: t21, depth: s13, stencil: r12 } = this._currentPipelineState;
    if (t21) {
      const { blendMode: s14, write: r13 } = t21;
      switch (e15.setColorMask(...r13), e15.setBlendingEnabled(true), e15.setBlendEquation(T2.ADD), s14) {
        case "composite":
          e15.setBlendFunctionSeparate(A2.ONE, A2.ONE_MINUS_SRC_ALPHA, A2.ONE, A2.ONE_MINUS_SRC_ALPHA);
          break;
        case "additive":
          e15.setBlendFunctionSeparate(A2.ONE, A2.ONE, A2.ONE, A2.ONE);
          break;
        case "custom": {
          const { blendParameters: s15 } = t21, { dstAlpha: r14, dstRGB: i13, srcAlpha: n18, srcRGB: a15 } = s15;
          e15.setBlendFunctionSeparate(a15, i13, n18, r14);
          break;
        }
        case "delete":
          e15.setBlendEquation(T2.REVERSE_SUBTRACT), e15.setBlendFunctionSeparate(A2.ONE, A2.ONE_MINUS_SRC_ALPHA, A2.ONE, A2.ONE_MINUS_SRC_ALPHA);
      }
    } else e15.setColorMask(false, false, false, false);
    if (s13) {
      const { test: t22, write: r13 } = s13;
      r13 ? (e15.setDepthWriteEnabled(true), e15.setDepthRange(r13.zNear, r13.zFar)) : e15.setDepthWriteEnabled(false), t22 ? (e15.setDepthTestEnabled(true), e15.setDepthFunction(t22)) : e15.setDepthTestEnabled(false);
    } else e15.setDepthTestEnabled(false), e15.setDepthWriteEnabled(false);
    if (r12) {
      const { test: t22, write: s14 } = r12;
      if (t22) {
        const { compare: s15, mask: r13, op: i13, ref: n18 } = t22;
        e15.setStencilTestEnabled(true), "function" != typeof n18 && e15.setStencilFunctionSeparate(S.FRONT_AND_BACK, s15, n18, r13), e15.setStencilOpSeparate(S.FRONT_AND_BACK, i13.fail, i13.zFail, i13.zPass);
      } else e15.setStencilTestEnabled(false);
      if (s14) {
        const { mask: t23 } = s14;
        e15.setStencilWriteMask(t23);
      } else e15.setStencilWriteMask(0);
    } else e15.setStencilTestEnabled(false), e15.setStencilWriteMask(0);
  }
  setStencilRef(e15, t21) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { stencil: s13 } = this._currentPipelineState;
    if (s13) {
      const { test: r12 } = s13;
      if (r12) {
        const { compare: s14, mask: i13, ref: n18 } = r12;
        let a15 = null;
        if ("function" == typeof n18 ? a15 = n18(t21) : "number" == typeof n18 && (a15 = n18), null == a15 && (a15 = t21.getStencilReference()), null == a15) throw new Error("InternalError: Stencil reference expected for target but not defined");
        e15.setStencilFunctionSeparate(S.FRONT_AND_BACK, s14, a15, i13);
      }
    }
  }
};
function x5(e15, t21, s13, r12) {
  return e15 !== E4.LABEL_ALPHA && e15 !== E4.LABEL && e15 !== E4.HIGHLIGHT && (1 !== r12 || null != t21 && "normal" !== t21 || null != s13 && s13.length > 0);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TileReshuffleManager.js
var s11 = class {
  constructor() {
    this._candidateTiles = [];
  }
  schedule(s13) {
    this._candidateTiles.includes(s13) || this._candidateTiles.push(s13);
  }
  reshuffle(s13) {
    const e15 = [];
    for (const i13 of this._candidateTiles) s13 > 0 ? (i13.reshuffle(), s13--) : e15.push(i13);
    this._candidateTiles = e15;
  }
};

// node_modules/@arcgis/core/views/2d/engine/Stage.js
var T4 = 2e3;
var v6 = class extends n6 {
  constructor(t21, i13, n18) {
    super(), this.meshWriterRegistry = new y(), this._trash = /* @__PURE__ */ new Set(), this._renderRemainingTime = 0, this._lastFrameRenderTime = 0, this._renderRequested = r4(false), this.stage = this, this._stationary = true, this._reshuffleManager = new s11(), this._managedCanvas = n18, this.context = new v3(this._managedCanvas.gl, i13.contextOptions ?? {}), this.painter = new F4(this.context, this), this._cimAnalyzer = new Q(this.painter.textureManager.resourceManager), has("esri-2d-profiler") && null != t21 && (this._debugOutput = document.createElement("div"), this._debugOutput.setAttribute("style", "margin: 24px 64px; position: absolute; color: red;"), t21.appendChild(this._debugOutput));
    const o15 = () => this.highlightGradient;
    this._renderParameters = { drawPhase: 0, state: this.state, pixelRatio: window.devicePixelRatio, stationary: false, globalOpacity: 1, blendMode: null, deltaTime: -1, time: 0, inFadeTransition: false, effects: null, context: this.context, painter: this.painter, timeline: i13.timeline || new e12(), renderingOptions: i13.renderingOptions, requestRender: () => this.requestRender(), allowDelayedRender: false, requireFBO: false, profiler: new n9(this.context, this._debugOutput), dataUploadCounter: 0, get highlightGradient() {
      return o15();
    }, reshuffleManager: this._reshuffleManager, backgroundColor: i13.backgroundColor };
    let h15 = (e15) => this.renderFrame(e15);
    null != i13.renderFrame && (h15 = i13.renderFrame), this._taskHandle = F({ render: (e15) => h15(e15) }), this._taskHandle.pause(), this._lostWebGLContextHandle = this._managedCanvas.events.on("webgl-context-lost", (t22) => this.emit("webgl-error", { error: new s2("webgl-context-lost", t22.statusMessage) })), this._bufferPool = new i7(), x2();
  }
  destroy() {
    k2(this.context), this.removeAllChildren(), this._emptyTrash(), this._taskHandle = l2(this._taskHandle), this._lostWebGLContextHandle = l2(this._lostWebGLContextHandle), this._managedCanvas.destroy(), this._debugOutput?.parentNode?.removeChild(this._debugOutput), this._bufferPool.destroy(), this.painter.dispose(), this.context.dispose(), this._managedCanvas = null;
  }
  get textureManager() {
    return this.painter.textureManager;
  }
  get backgroundColor() {
    return this._renderParameters.backgroundColor;
  }
  set backgroundColor(e15) {
    this._renderParameters.backgroundColor = e15, this.requestRender();
  }
  get canvas() {
    return this._managedCanvas.canvas;
  }
  get bufferPool() {
    return this._bufferPool;
  }
  get cimAnalyzer() {
    return this._cimAnalyzer;
  }
  get renderingOptions() {
    return this._renderingOptions;
  }
  set renderingOptions(e15) {
    this._renderingOptions = e15, this.requestRender();
  }
  get renderRequested() {
    return this._renderRequested.value;
  }
  get state() {
    return this._state;
  }
  set state(e15) {
    this._state = e15, this.requestRender();
  }
  get stationary() {
    return this._stationary;
  }
  set stationary(e15) {
    this._stationary !== e15 && (this._stationary = e15, this.requestRender());
  }
  trashDisplayObject(e15) {
    this._trash.add(e15), this.requestRender();
  }
  untrashDisplayObject(e15) {
    return this._trash.delete(e15);
  }
  requestRender() {
    this._renderRemainingTime = T4, this.renderRequested || (this._renderRequested.value = true, this._taskHandle.resume());
  }
  renderFrame(e15) {
    const t21 = this._lastFrameRenderTime ? e15.time - this._lastFrameRenderTime : 0;
    this._renderRemainingTime -= t21, this._renderRemainingTime <= 0 && this._taskHandle.pause(), this._lastFrameRenderTime = e15.time, this._renderRequested.value = false, this._renderParameters.state = this._state, this._renderParameters.stationary = this.stationary, this._renderParameters.pixelRatio = window.devicePixelRatio, this._renderParameters.globalOpacity = 1, this._renderParameters.time = e15.time, this._renderParameters.deltaTime = e15.deltaTime, this._renderParameters.effects = null, this.processRender(this._renderParameters), this._emptyTrash();
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  renderChildren(e15) {
    for (const t21 of this.children) t21.beforeRender(e15);
    this._reshuffleManager.reshuffle(wi), this._managedCanvas.render(e15, () => this._renderChildren(this.children, e15));
    for (const t21 of this.children) t21.afterRender(e15);
  }
  _renderChildren(e15, t21) {
    const r12 = this.context;
    this.painter.textureUploadManager.upload(), r12.resetInfo(), t21.profiler.recordStart("drawLayers"), t21.dataUploadCounter = 0, this.painter.beforeRenderPhases(t21, t21.backgroundColor, this.state.padding), t21.drawPhase = E4.MAP;
    for (const s13 of e15) s13.processRender(t21);
    if (this.children.some((e16) => e16.hasHighlight)) {
      t21.drawPhase = E4.HIGHLIGHT;
      for (const r13 of e15) r13.processRender(t21);
    }
    if (this.children.some((e16) => e16.hasLabels)) {
      t21.drawPhase = E4.LABEL;
      for (const r13 of e15) r13.processRender(t21);
    }
    if (has("esri-tiles-debug")) {
      t21.drawPhase = E4.DEBUG;
      for (const r13 of e15) r13.processRender(t21);
    }
    this.painter.afterRenderPhases(t21), t21.profiler.recordEnd("drawLayers"), r12.logInfo();
  }
  doRender(e15) {
    const t21 = this.context, { state: r12, pixelRatio: s13 } = e15;
    this._managedCanvas.resize(e15), t21.setViewport(0, 0, s13 * r12.size[0], s13 * r12.size[1]), t21.setDepthWriteEnabled(true), t21.setStencilWriteMask(255), this.renderChildren(e15);
  }
  async takeScreenshot(e15, t21, r12, s13) {
    const i13 = Math.round(this.state.size[0] * e15.resolutionScale), a15 = Math.round(this.state.size[1] * e15.resolutionScale), n18 = e15.resolutionScale, o15 = this.context, h15 = this._state.clone();
    if (null != s13) {
      const e16 = h15.viewpoint;
      h15.viewpoint.rotation = s13, h15.viewpoint = e16;
    }
    const d10 = { ...this._renderParameters, drawPhase: null, globalOpacity: 1, stationary: true, state: h15, pixelRatio: n18, time: performance.now(), deltaTime: 0, blendMode: null, effects: null, inFadeTransition: false, backgroundColor: r12 }, l16 = new a4(i13, a15);
    l16.wrapMode = P2.CLAMP_TO_EDGE, l16.internalFormat = B2.RGBA8, l16.isImmutable = true;
    const m8 = new R3(o15, l16, new i6(H2.DEPTH24_STENCIL8, i13, a15)), u17 = o15.getBoundFramebufferObject(), c10 = o15.getViewport();
    o15.bindFramebuffer(m8), o15.setViewport(0, 0, i13, a15), this._renderChildren(t21 ?? this.children, d10);
    const p9 = this._readbackScreenshot(m8, { ...e15.cropArea, y: a15 - (e15.cropArea.y + e15.cropArea.height) });
    o15.bindFramebuffer(u17), o15.setViewport(c10.x, c10.y, c10.width, c10.height), this.requestRender();
    const g7 = await p9;
    let f12;
    return 1 === e15.outputScale ? f12 = g7 : (f12 = new ImageData(Math.round(g7.width * e15.outputScale), Math.round(g7.height * e15.outputScale)), (await import("./screenshotUtils-T4QTDZJC.js")).resampleHermite(g7, f12, true)), m8.dispose(), f12;
  }
  async _readbackScreenshot(e15, t21) {
    const r12 = (await import("./screenshotUtils-T4QTDZJC.js")).createEmptyImageData(t21.width, t21.height, document.createElement("canvas"));
    return await e15.readPixelsAsync(t21.x, t21.y, t21.width, t21.height, M3.RGBA, X2.UNSIGNED_BYTE, new Uint8Array(r12.data.buffer)), r12;
  }
  _emptyTrash() {
    for (; this._trash.size > 0; ) {
      const e15 = Array.from(this._trash);
      this._trash.clear();
      for (const t21 of e15) t21.processDetach();
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/videoScreenRenderer/VideoScreenTechnique.js
var h14 = class extends t10 {
  constructor() {
    super(...arguments), this.type = e4.VideoScreen, this._mesh = null, this.shaders = { geometry: new h7() };
  }
  render(e15, t21) {
    const { context: s13, painter: o15 } = e15, { texture: n18, textureCoords: i13 } = t21, m8 = this._getMesh(e15), c10 = t21.ndcRect[2], h15 = t21.ndcRect[3], u17 = t21.ndcRect[0], a15 = t21.ndcRect[1], p9 = new Float32Array(180);
    for (let r12 = 0; r12 < 6; r12++) {
      const e16 = h15 * r12 / 5;
      for (let t22 = 0; t22 < 6; t22++) {
        const s14 = c10 * t22 / 5, { u: o16, v: n19 } = i13[6 * r12 + t22];
        p9[5 * (6 * r12 + t22)] = u17 + s14, p9[5 * (6 * r12 + t22) + 1] = a15 - e16, p9[5 * (6 * r12 + t22) + 2] = o16, p9[5 * (6 * r12 + t22) + 3] = n19, p9[5 * (6 * r12 + t22) + 4] = 1;
      }
    }
    m8.vertexBuffers.get("geometry")?.buffer.setData(p9);
    const d10 = { texture: { texture: n18, unit: 0 }, opacity: t21.opacity }, f12 = { shader: this.shaders.geometry, uniforms: { config: d10 }, defines: {}, optionalAttributes: null, useComputeBuffer: false };
    o15.setPipelineState(t9), o15.submitDrawMeshUntyped(s13, f12, m8);
  }
  shutdown() {
    u(this._mesh);
  }
  _getMesh(e15) {
    const { context: r12 } = e15, s13 = new Uint32Array(150);
    for (let t21 = 0; t21 < 5; t21++) for (let e16 = 0; e16 < 5; e16++) {
      const r13 = 6 * (5 * t21 + e16), o15 = 6 * (t21 + 1) + e16 + 1, n18 = o15 - 1, i13 = o15 - 6, m8 = o15 - 7;
      s13[r13] = o15, s13[r13 + 1] = n18, s13[r13 + 2] = i13, s13[r13 + 3] = n18, s13[r13 + 4] = m8, s13[r13 + 5] = i13;
    }
    return this._mesh || (this._mesh = new o8(r12, { vertex: { geometry: { data: new Float32Array(180), attributes: [new t2("position", 2, O3.FLOAT, 0, 20), new t2("texcoord", 2, O3.FLOAT, 8, 20), new t2("w", 1, O3.FLOAT, 16, 20)] } }, index: { index: { data: s13 } }, groups: [{ primitive: R2.TRIANGLES, index: "index" }], parts: [{ group: 0, start: 0, count: s13.length }] })), this._mesh;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/VideoScreenRenderer.js
var x6 = class extends e9 {
  constructor(e15, t21) {
    super(), this._controlPointsOwner = t21, this.readbackScreenCoords = n7(), this.videoTextureCoords = new Array(36), this.overlayTextureCoords = new Array(36), this._prevFBO = null, this._acquiredFBO = null, this._isBound = false, this._hasCoordinates = false, this._geIsLoaded = false, this._ndcRect = [0, 0, 2, 2], this._technique = new h14(), this.visible = false, this.stage = e15;
    for (let r12 = 0; r12 < 6; r12++) {
      const e16 = r12 / 5;
      for (let t22 = 0; t22 < 6; t22++) {
        const o15 = t22 / 5;
        this.videoTextureCoords[6 * r12 + t22] = { u: o15, v: e16 };
      }
    }
  }
  getMesh(e15) {
    throw new Error("Method not implemented.");
  }
  destroy() {
    r2(this._readbackTexture);
  }
  bind(e15) {
    const { context: t21, pixelRatio: r12, state: o15 } = e15;
    if (this._update(e15), !this.ready || 0 === this.readbackScreenCoords[2] || 0 === this.readbackScreenCoords[3]) return this.requestRender(), false;
    const { size: s13 } = o15, i13 = Math.round(r12 * s13[0]), a15 = Math.round(r12 * s13[1]), n18 = new a4(i13, a15);
    return n18.samplingMode = L3.LINEAR, n18.wrapMode = P2.CLAMP_TO_EDGE, this._acquiredFBO || (this._acquiredFBO = new R3(t21, n18)), this._acquiredFBO.resize(i13, a15), t21.bindFramebuffer(this._acquiredFBO), this._isBound = true, true;
  }
  unbind(e15) {
    if (!this._isBound) return;
    const { context: t21, pixelRatio: r12, state: o15 } = e15, { size: s13 } = o15, i13 = this._acquiredFBO;
    if (!i13.getColorTexture(e3)) throw new Error("Failed to get color texture from FBO.");
    const a15 = this._getReadbackTexture(e15), n18 = this.readbackScreenCoords, c10 = Math.round(r12 * n18[0]), h15 = Math.round(r12 * (s13[1] - n18[1])) - a15.descriptor.height, u17 = c10 + a15.descriptor.width, l16 = h15 + a15.descriptor.height, m8 = Math.max(c10, 0), _10 = Math.max(h15, 0), x8 = Math.min(u17, i13.width) - m8, b5 = Math.min(l16, i13.height) - _10;
    x8 > 0 && b5 > 0 && i13.copyToTexture(m8, _10, x8, b5, m8 - c10, _10 - h15, a15), t21.bindFramebuffer(this._prevFBO);
  }
  _update(e15) {
    const { state: r12 } = e15, a15 = this._controlPointsOwner, n18 = a15.groundControlPoints(), c10 = a15.getSize(), h15 = r12.size, d10 = n18?.length;
    if (!d10) return;
    if (d4().then(() => {
      this._geIsLoaded = true;
    }), !this._geIsLoaded) return void this.requestRender();
    const u17 = c10[0], l16 = c10[1], m8 = h15[0], _10 = l16 / h15[1], x8 = u17 / m8;
    if (_10 > x8) {
      const e16 = x8 / _10 * 2, t21 = (2 - e16) / 2;
      this._ndcRect[0] = -1 + t21, this._ndcRect[1] = 1, this._ndcRect[2] = e16, this._ndcRect[3] = 2;
    } else {
      const e16 = _10 / x8 * 2, t21 = (2 - e16) / 2;
      this._ndcRect[0] = -1, this._ndcRect[1] = 1 - t21, this._ndcRect[2] = 2, this._ndcRect[3] = e16;
    }
    const b5 = new Array(d10), f12 = r12.spatialReference;
    for (let t21 = 0; t21 < d10; t21++) {
      const { lat: e16, lon: r13 } = n18[t21], s13 = new _2(r13, e16);
      b5[t21] = E2(s13, f12);
    }
    const p9 = [];
    let M6 = 1 / 0, g7 = 1 / 0, C4 = -1 / 0, R5 = -1 / 0;
    for (const o15 of b5) {
      const e16 = n3();
      r12.toScreen(e16, o15.x, o15.y), p9.push({ x: e16[0], y: e16[1] }), M6 = Math.min(M6, e16[0]), g7 = Math.min(g7, e16[1]), C4 = Math.max(C4, e16[0]), R5 = Math.max(R5, e16[1]);
    }
    const T5 = [M6, R5], w4 = [C4, g7];
    this.readbackScreenCoords[0] = Math.max(Math.floor(T5[0]), 0), this.readbackScreenCoords[1] = Math.max(Math.floor(w4[1]), 0), this.readbackScreenCoords[2] = Math.ceil(w4[0]), this.readbackScreenCoords[3] = Math.ceil(T5[1]);
    for (let t21 = 0; t21 < p9.length; t21++) {
      const e16 = p9[t21], r13 = (e16.x - M6) / (C4 - M6), o15 = (R5 - e16.y) / (R5 - g7);
      this.overlayTextureCoords[t21] = { u: r13, v: o15 };
    }
    this._hasCoordinates = true;
  }
  _createTransforms() {
    return null;
  }
  doRender(e15) {
    this._readbackTexture && this._hasCoordinates ? this._technique.render(e15, { texture: this._readbackTexture, textureCoords: this.overlayTextureCoords, opacity: 1, ndcRect: this._ndcRect }) : this.requestRender();
  }
  _getReadbackTexture(e15) {
    const { context: t21, pixelRatio: r12 } = e15, o15 = Math.round(r12 * Math.abs(this.readbackScreenCoords[2] - this.readbackScreenCoords[0])), s13 = Math.round(r12 * Math.abs(this.readbackScreenCoords[3] - this.readbackScreenCoords[1]));
    if (this._readbackTexture) this._readbackTexture.resize(o15, s13);
    else {
      const e16 = new a4(o15, s13);
      e16.wrapMode = P2.CLAMP_TO_EDGE, e16.internalFormat = B2.RGBA8, this._readbackTexture = new S2(t21, e16);
    }
    return this._readbackTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/ParentChildStage.js
var n17 = class extends v6 {
  constructor(e15, s13, n18) {
    super(null, s13 = { ...s13, renderFrame: (e16) => {
    } }, new c4(null, { canvas: e15 })), this._requestRender = n18, this.viewIsReady = false, this.videoScreenRenderer = new x6(this, s13), this.videoScreenRenderer.visible = true;
  }
  requestRender() {
    this._requestRender();
  }
  processRender(r12) {
    this.videoScreenRenderer.bind(r12), r12.backgroundColor = l4.fromArray([0, 0, 0, 0]), super.processRender(r12), this.videoScreenRenderer.unbind(r12);
  }
};
var i11 = class extends v6 {
  constructor(e15, r12, s13) {
    super(e15, r12 = { ...r12, renderFrame: (e16) => {
      this.render(e16);
    } }, s13), this._childStage = new n17(s13.canvas, r12, () => this.requestRender());
  }
  get childStage() {
    return this._childStage;
  }
  render(e15) {
    this._childStage.viewIsReady ? (this._childStage.context.enforceState(), this._childStage.renderFrame(e15)) : this.requestRender(), this.context.enforceState(), super.renderFrame(e15);
  }
  processRender(e15) {
    super.processRender(e15), this._childStage.viewIsReady && this._childStage.visible && this._childStage.videoScreenRenderer.processRender(e15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/magnifier/MagnifierTechnique.js
var p8 = class extends t10 {
  constructor() {
    super(...arguments), this.type = e4.Magnifier, this._resourcePixelRatio = 1, this._position = [0, 0, 0, 0], this.shaders = { magnifier: new E6() };
  }
  updateResources(t21, i13, r12, s13) {
    t21.pixelRatio !== this._resourcePixelRatio && this._destroyResources(), this._readbackTexture || this._initializeResources(t21, i13, r12, s13);
    const { context: o15, pixelRatio: a15 } = t21, { factor: n18, offset: u17, position: h15 } = s13, { size: l16 } = t21.state, c10 = s13.size * a15, p9 = 1 / n18, x8 = Math.ceil(p9 * c10);
    this._readbackTexture.resize(x8, x8);
    const m8 = a15 * l16[0], d10 = a15 * l16[1], _10 = 0.5 * x8, T5 = 0.5 * x8, f12 = r3(a15 * h15.x, _10, m8 - _10 - 1), g7 = r3(d10 - a15 * h15.y, T5, d10 - T5 - 1), R5 = f12 - _10, b5 = g7 - T5, w4 = this._readbackTexture;
    o15.bindTexture(w4, 0), o15.gl.copyTexImage2D(w4.descriptor.target, 0, w4.descriptor.pixelFormat, R5, b5, x8, x8, 0);
    const y4 = (f12 + u17.x * a15) / m8 * 2 - 1, k5 = (g7 - u17.y * a15) / d10 * 2 - 1, M6 = c10 / m8 * 2, j4 = c10 / d10 * 2;
    this._position[0] = y4, this._position[1] = k5, this._position[2] = M6, this._position[3] = j4;
  }
  render(e15, t21) {
    const { context: i13, painter: s13 } = e15;
    s13.setPipelineState(t9);
    const o15 = { readbackTexture: { texture: this._readbackTexture, unit: 0 }, maskTexture: { texture: this._maskTexture, unit: 7 }, overlayTexture: { texture: this._overlayTexture, unit: 6 }, drawPos: this._position, ...t21 };
    s13.submitDrawMesh(i13, { shader: this.shaders.magnifier, uniforms: { config: o15 }, defines: null, optionalAttributes: null, useComputeBuffer: false }, s13.quadMesh);
  }
  shutdown() {
    this._destroyResources();
  }
  _initializeResources(e15, t21, r12, s13) {
    const o15 = e15.context;
    this._resourcePixelRatio = e15.pixelRatio;
    const a15 = Math.ceil(s13.size * e15.pixelRatio);
    r12.width = a15, r12.height = a15;
    const p9 = new a4();
    p9.internalFormat = M3.RGBA, p9.wrapMode = P2.CLAMP_TO_EDGE, p9.samplingMode = L3.NEAREST, p9.flipped = true, p9.preMultiplyAlpha = !Et(r12.src) || !e15.context.driverTest.svgPremultipliesAlpha.result, this._overlayTexture = new S2(o15, p9, r12), t21.width = a15, t21.height = a15, p9.pixelFormat = p9.internalFormat = M3.ALPHA, this._maskTexture = new S2(o15, p9, t21);
    const x8 = 1 / s13.factor;
    p9.pixelFormat = p9.internalFormat = M3.RGBA, p9.width = p9.height = Math.ceil(x8 * a15), p9.samplingMode = L3.LINEAR, p9.flipped = false, this._readbackTexture = new S2(o15, p9);
  }
  _destroyResources() {
    r2(this._maskTexture), r2(this._overlayTexture), r2(this._readbackTexture), this._maskTexture = null, this._overlayTexture = null, this._readbackTexture = null;
  }
};

// node_modules/@arcgis/core/views/magnifier/resources.js
async function s12(s13) {
  const r12 = import("./mask-svg-F7IZT53S.js"), i13 = import("./overlay-svg-XJYKUJ4W.js"), o15 = t((await r12).default, { signal: s13 }), e15 = t((await i13).default, { signal: s13 }), m8 = { mask: await o15, overlay: await e15 };
  return s3(s13), m8;
}

// node_modules/@arcgis/core/views/2d/magnifier/MagnifierView2D.js
var c9 = class extends e9 {
  constructor() {
    super(), this._handles = new r(), this._magnifierTechnique = new p8(), this.updatingHandles = new h4(), this.visible = false;
  }
  destroy() {
    this._handles = u(this._handles), this._magnifierTechnique.shutdown(), this._resourcesTask = e(this._resourcesTask);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e15) {
    this._backgroundColor = e15, this.requestRender();
  }
  get magnifier() {
    return this._magnifier;
  }
  set magnifier(e15) {
    this._magnifier = e15, this._handles.removeAll(), this._handles.add([l3(() => e15.version, () => {
      this.visible = e15.visible && null != e15.position && e15.size > 0, this.requestRender();
    }, h), l3(() => [e15.maskUrl, e15.overlayUrl], () => this._reloadResources()), l3(() => e15.size, () => {
      this._magnifierTechnique.shutdown(), this.requestRender();
    })]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  doRender(e15) {
    if (!this._resourcesTask) return void this._reloadResources();
    if (e15.drawPhase !== E4.MAP || !this._canRender()) return;
    const s13 = this._magnifier;
    if (null == s13.position) return;
    this._magnifierTechnique.updateResources(e15, this._mask, this._overlay, s13);
    const r12 = this.backgroundColor, i13 = r12 ? [r12.a * r12.r / 255, r12.a * r12.g / 255, r12.a * r12.b / 255, r12.a] : [1, 1, 1, 1];
    this._magnifierTechnique.render(e15, { background: i13, maskEnabled: s13.maskEnabled ? 1 : 0, overlayEnabled: s13.overlayEnabled ? 1 : 0 });
  }
  _canRender() {
    return this._mask && this._overlay && null != this._magnifier;
  }
  _reloadResources() {
    this._resourcesTask && this._resourcesTask.abort();
    const r12 = null != this._magnifier ? this._magnifier.maskUrl : null, i13 = null != this._magnifier ? this._magnifier.overlayUrl : null;
    this._resourcesTask = d(async (s13) => {
      const n18 = null == r12 || null == i13 ? s12(s13) : null, t21 = null != r12 ? H(r12, { responseType: "image", signal: s13 }).then((e15) => e15.data) : n18.then((e15) => e15.mask), a15 = null != i13 ? H(i13, { responseType: "image", signal: s13 }).then((e15) => e15.data) : n18.then((e15) => e15.overlay), [o15, l16] = await Promise.all([t21, a15]);
      this._mask = o15, this._overlay = l16, this._magnifierTechnique.shutdown(), this.requestRender();
    }), this.updatingHandles.addPromise(this._resourcesTask.promise);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/grid/GridTechnique.js
var i12 = class extends t10 {
  constructor() {
    super(...arguments), this.type = e4.Grid, this.shaders = { grid: new _5() };
  }
  render(s13, r12) {
    const { context: t21, painter: i13 } = s13;
    i13.setPipelineState(t9), i13.submitDrawMesh(t21, { shader: this.shaders.grid, uniforms: r12, defines: null, optionalAttributes: null, useComputeBuffer: false }, i13.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/grid/GridView2D.js
var x7 = n3();
var w3 = class extends e9 {
  constructor() {
    super(), this._handles = new r(), this._projectedCenter = null, this._metersPerSRUnit = null, this._technique = new i12(), this._grid = null, this.visible = true;
  }
  destroy() {
    this._handles = u(this._handles), this._technique.shutdown();
  }
  get grid() {
    return this._grid;
  }
  set grid(e15) {
    this._grid = e15, this._handles.removeAll(), this._handles.add([l3(() => e15?.center, () => {
      this._projectedCenter = null;
    }, h), l3(() => [e15?.center, e15?.dynamicScaling, e15?.majorLineColor, e15?.majorLineInterval, e15?.minorLineColor, e15?.rotateWithMap, e15?.rotation, e15?.spacing, e15?.units], () => this.requestRender(), h)]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  doRender(e15) {
    if (e15.drawPhase !== E4.MAP || null == this.grid || !this.visible) return;
    const { spacing: t21, units: r12, majorLineInterval: i13, dynamicScaling: s13, majorLineColor: o15, minorLineColor: a15 } = this.grid;
    if (0 === t21) return;
    if (this._updateDerivedValues(e15), null == this._projectedCenter || null == this._metersPerSRUnit) return;
    const { scale: l16, spatialReference: m8 } = e15.state, c10 = j(t21, r12, "meters"), h15 = this._metersPerSRUnit * u5(l16, m8), p9 = c10 / h15;
    if (!s13 && p9 < t14) return;
    const d10 = c10 * l9(i13, p9, s13);
    this._updateTransform(e15, h15, d10), this._technique.render(e15, { transform: { dvs: this.transforms.displayViewScreenMat3 }, config: { pxPerCell: d10 / h15, minorLineColor: q3(a15), majorLineColor: q3(o15), majorLineInterval: i13, halfWidth: 0.25, aaWidth: 0.5 } });
  }
  _updateDerivedValues(e15) {
    if (!this.grid) return;
    const { center: t21 } = this.grid, { spatialReference: r12 } = e15.state;
    this._projectedCenter && s5(this._projectedCenter.spatialReference, r12) || (this._metersPerSRUnit = null, s5(t21.spatialReference, r12) ? this._projectedCenter = t21 : U(t21.spatialReference, r12) ? this._projectedCenter = O(t21, r12) : this.requestRender()), null == this._metersPerSRUnit && null != this._projectedCenter && (this._metersPerSRUnit = u9(this._projectedCenter));
  }
  _updateTransform(e15, r12, i13) {
    const { grid: s13 } = this, { center: n18, rotation: c10, size: j4, spatialReference: _10 } = e15.state;
    if (null == s13 || null == this._projectedCenter || null == this._metersPerSRUnit) return;
    const g7 = r12 * (j4[0] / 2), R5 = r12 * (j4[1] / 2), U6 = this._metersPerSRUnit / i13, v7 = this._projectedCenter, y4 = s4(s13.rotation), S5 = s4(c10), b5 = this.transforms.displayViewScreenMat3;
    m3(b5, -y4);
    const L7 = _10.isWrappable ? P(v7.x, n18[0], _10) : v7.x, P4 = o3(x7, L7, v7.y), w4 = B(x7, n18, P4);
    l6(w4, w4, U6), s13.rotateWithMap || I(w4, w4, a3, -S5), I(w4, w4, a3, -y4), l6(w4, w4, 1 / s13.majorLineInterval), M5(w4, w4), l6(w4, w4, s13.majorLineInterval), I(w4, w4, a3, y4), M2(b5, b5, w4), s13.rotateWithMap && h3(b5, b5, S5);
    const q4 = o3(x7, g7 / i13, R5 / i13);
    b3(b5, b5, q4);
  }
};
function M5(e15, t21) {
  return e15[0] = t21[0] - Math.trunc(t21[0]), e15[1] = t21[1] - Math.trunc(t21[1]), e15;
}
function q3(e15) {
  const [t21, r12, i13, s13] = e15.toArray().map((e16) => e16 / 255);
  return [t21 * s13, r12 * s13, i13 * s13, s13];
}
export {
  n17 as ChildStage,
  t13 as GraphicContainer,
  O4 as GraphicsView2D,
  w3 as GridView2D,
  p3 as LabelManager,
  c9 as MagnifierView2D,
  y2 as MapViewNavigation,
  i11 as ParentStage,
  v6 as Stage
};
//# sourceMappingURL=mapViewDeps-ENOR75OZ.js.map
