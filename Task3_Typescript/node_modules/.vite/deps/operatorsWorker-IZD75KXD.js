import {
  f
} from "./chunk-N3A2BVTW.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import "./chunk-N3XLUQJI.js";
import "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import "./chunk-GZ2P4SCJ.js";
import "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/arcade/geometry/operatorsWorker.js
function t(e, t2) {
  let r2;
  return { loaded: false, load: () => r2 ??= t2().then((t3) => {
    o[e] = { loaded: true, execute: t3 };
  }) };
}
function r(e) {
  return null == e ? null : e.toJSON();
}
var o = { disjoint: t("disjoint", () => import("./disjointOperator-B2ISUUTV.js").then((e) => e.execute)), intersects: t("intersects", () => import("./intersectsOperator-PQZJXPZR.js").then((e) => e.execute)), touches: t("touches", () => import("./touchesOperator-HVQNL4ZL.js").then((e) => e.execute)), crosses: t("crosses", () => import("./crossesOperator-ZRYXJXK2.js").then((e) => e.execute)), within: t("within", () => import("./withinOperator-4KHSZJ6T.js").then((e) => e.execute)), contains: t("contains", () => import("./containsOperator-6XTGXXMO.js").then((e) => e.execute)), overlaps: t("overlaps", () => import("./overlapsOperator-XZGFMRK5.js").then((e) => e.execute)), equals: t("equals", async () => {
  const t2 = await import("./equalsOperator-BWHAZPJV.js");
  return (r2, o2) => t2.execute(f(r2), f(o2));
}), relate: t("relate", async () => {
  const t2 = await import("./relateOperator-FT3YIVXY.js");
  return (r2, o2, n2) => t2.execute(f(r2), f(o2), n2);
}), intersection: t("intersection", () => import("./intersectionOperator-BMHKITAJ.js").then((e) => e.execute)), union: t("union", () => import("./unionOperator-JIKKIU2P.js").then((e) => e.executeMany)), difference: t("difference", async () => {
  const t2 = await import("./differenceOperator-XDUYOBIM.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
}), symmetricDifference: t("symmetricDifference", async () => {
  const t2 = await import("./symmetricDifferenceOperator-3MBCYORI.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
}), clip: t("clip", async () => {
  const t2 = await import("./clipOperator-7UH4ZETC.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
}), cut: t("cut", async () => {
  const t2 = await import("./cutOperator-7EOMNZUY.js");
  return (o2, n2) => t2.execute(f(o2), f(n2)).map((e) => r(e));
}), area: t("area", async () => {
  const t2 = await import("./areaOperator-EGQCFOTZ.js"), { convertFromSpatialReferenceUnit: r2, toAreaUnit: o2 } = await import("./unitConversion-BYPQY6BY.js");
  return (n2, a) => {
    const s = t2.execute(f(n2));
    return r2(n2.spatialReference, o2(a), s);
  };
}), geodeticArea: t("geodeticArea", async () => {
  const t2 = await import("./geodeticAreaOperator-PHRXLWWT.js"), { convert: r2, squareMeters: o2, toAreaUnit: n2 } = await import("./unitConversion-BYPQY6BY.js");
  return await t2.load(), (a, s, i) => {
    const c = t2.execute(f(a), { curveType: i });
    return r2(o2, n2(s), c);
  };
}), length: t("length", async () => {
  const e = await import("./lengthOperator-2F2HKWTT.js"), { convertFromSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-BYPQY6BY.js");
  return (o2, n2) => {
    const a = e.execute(o2);
    return t2(o2.spatialReference, r2(n2), a);
  };
}), geodeticLength: t("geodeticLength", async () => {
  const t2 = await import("./geodeticLengthOperator-RRJAPHLM.js"), { convert: r2, meters: o2, toLengthUnit: n2 } = await import("./unitConversion-BYPQY6BY.js");
  return await t2.load(), (a, s, i) => {
    const c = t2.execute(f(a), { curveType: i });
    return r2(o2, n2(s), c);
  };
}), distance: t("distance", async () => {
  const t2 = await import("./distanceOperator-32SAWDIP.js"), { convertFromSpatialReferenceUnit: r2, toLengthUnit: o2 } = await import("./unitConversion-BYPQY6BY.js");
  return (n2, a, s) => {
    const i = t2.execute(f(n2), f(a));
    return r2(n2.spatialReference, o2(s), i);
  };
}), densify: t("densify", async () => {
  const t2 = await import("./densifyOperator-ZEYGQCLV.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-BYPQY6BY.js");
  return (a, s, i) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s)));
}), geodeticDensify: t("geodeticDensify", async () => {
  const t2 = await import("./geodeticDensifyOperator-LKM523YX.js"), { convert: o2, meters: n2, toLengthUnit: a } = await import("./unitConversion-BYPQY6BY.js");
  return await t2.load(), (s, i, c, p) => (i = o2(a(c), n2, i), r(t2.execute(f(s), i, { curveType: p })));
}), generalize: t("generalize", async () => {
  const t2 = await import("./generalizeOperator-4E6GJ26N.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-BYPQY6BY.js");
  return (a, s, i, c) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s, c)));
}), buffer: t("buffer", async () => {
  const e = await import("./bufferOperator-HAJV6HRZ.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-BYPQY6BY.js");
  return (o2, n2, a) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2));
}), geodesicBuffer: t("geodesicBuffer", async () => {
  const e = await import("./geodesicBufferOperator-E7LZ6NMW.js"), { convert: t2, meters: r2, toLengthUnit: o2 } = await import("./unitConversion-BYPQY6BY.js");
  return await e.load(), (n2, a, s, i) => (a = t2(o2(s), r2, a), e.execute(n2, a, { curveType: i }));
}), offset: t("offset", async () => {
  const e = await import("./offsetOperator-62RGJ5PT.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-BYPQY6BY.js");
  return (o2, n2, a, s) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2, s));
}), rotate: t("rotate", async () => {
  const t2 = await import("./affineTransformOperator-GQOOV4AP.js"), { default: o2 } = await import("./Transformation-4TL6HIG4.js");
  return (n2, a, s, i) => {
    const c = new o2().rotate(a, s, i);
    return r(t2.execute(f(n2), c));
  };
}), centroid: t("centroid", async () => {
  const t2 = await import("./centroidOperator-VDRLHRB7.js");
  return (o2) => r(t2.execute(f(o2)));
}), labelPoint: t("labelPoint", async () => {
  const t2 = await import("./labelPointOperator-G5UUXIHF.js");
  return (o2) => r(t2.execute(f(o2)));
}), simplify: t("simplify", () => import("./simplifyOperator-FNTKGP2R.js").then((e) => e.execute)), isSelfIntersecting: t("isSelfIntersecting", async () => {
  const { NonSimpleResult: t2 } = await import("./OperatorDefinitions-JB53ADR5.js"), r2 = await import("./simplifyOGCOperator-IQRIKZW7.js"), o2 = /* @__PURE__ */ new Set([5, 6, 7, 10, 11, 12]);
  return (n2) => {
    const a = new t2();
    return !r2.isSimple(f(n2), a) && o2.has(a.m_reason);
  };
}), isSimple: t("isSimple", () => import("./simplifyOperator-FNTKGP2R.js").then((e) => e.isSimple)), convexHull: t("convexHull", () => import("./convexHullOperator-RTHE62WF.js").then((e) => e.execute)), getNearestCoordinate: t("getNearestCoordinate", async () => {
  const t2 = await import("./proximityOperator-DZ25Z7XA.js");
  return (o2, n2, a) => {
    const s = t2.getNearestCoordinate(f(o2), f(n2), a);
    return { ...s, coordinate: r(s.coordinate) };
  };
}), getNearestVertex: t("getNearestVertex", async () => {
  const t2 = await import("./proximityOperator-DZ25Z7XA.js");
  return (o2, n2) => {
    const a = t2.getNearestVertex(f(o2), f(n2));
    return { ...a, coordinate: r(a.coordinate) };
  };
}) };
function n(e, t2) {
  const r2 = o[e];
  return r2.loaded ? r2.execute.apply(void 0, t2) : r2.load().then(() => n(e, t2));
}
export {
  n as invokeGeometryOp
};
//# sourceMappingURL=operatorsWorker-IZD75KXD.js.map
