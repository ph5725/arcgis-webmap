import {
  l as l2
} from "./chunk-7KOC3Z4A.js";
import {
  d,
  e,
  t
} from "./chunk-QXLW5W5A.js";
import {
  c
} from "./chunk-ZCE5HP23.js";
import {
  f,
  g,
  u as u2,
  y
} from "./chunk-OFHPFWHF.js";
import "./chunk-MZJEBIXX.js";
import {
  L
} from "./chunk-76QJRCNC.js";
import {
  U,
  k
} from "./chunk-AAC6XSCN.js";
import "./chunk-NMP7ZOVG.js";
import "./chunk-YHYQP7QX.js";
import "./chunk-ZSRASSN6.js";
import "./chunk-N5GLJRXG.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-GPMIOMDJ.js";
import "./chunk-RGFH75DR.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-LYSDGL5S.js";
import {
  s as s2
} from "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import {
  l
} from "./chunk-KE3WBZYL.js";
import "./chunk-EOMIFMDH.js";
import "./chunk-45ILJ6ZH.js";
import "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import {
  u
} from "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-HPGYEHVI.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-YIV2QKTZ.js";
import "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import "./chunk-E3KEUGUG.js";
import "./chunk-N3XLUQJI.js";
import "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import "./chunk-GZ2P4SCJ.js";
import {
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/symbols/support/previewSymbol2D.js
var g2 = "picture-fill";
var y2 = "picture-marker";
var w = "simple-fill";
var x = "simple-line";
var b = "simple-marker";
var v = "text";
var M = "Aa";
var S = t.size;
var z = t.maxSize;
var k2 = t.maxOutlineSize;
var L2 = t.lineWidth;
var C = 225;
var $ = document.createElement("canvas");
function j(t2, e2, i) {
  if ("polygon" === t2.type) {
    const o = t2.extent, n = 0 === o.width ? 1 : o.width, l3 = 0 === o.height ? 1 : o.height;
    t2 = U({ originPosition: "upperLeft", scale: [n / e2, l3 / i], translate: [o.xmin, o.ymax] }, {}, t2);
    let s3 = "";
    for (let e3 = 0; e3 < t2.rings.length; e3++) {
      const i2 = t2.rings[e3];
      for (let t3 = 0; t3 < i2.length; t3++) {
        const e4 = i2[t3][0], o2 = i2[t3][1];
        let n2 = "";
        0 === t3 ? (n2 = `M${e4.toString()} ${o2.toString()}`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2) : t3 === i2.length - 1 ? (n2 = `l${e4.toString()} ${o2.toString()} Z`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2) : (n2 = `l${e4.toString()} ${o2.toString()}`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2);
      }
    }
    return s3;
  }
  if ("polyline" === t2.type) {
    const o = t2.extent, n = 0 === o.width ? 1 : o.width, a = 0 === o.height ? 1 : o.height;
    t2 = k({ originPosition: "upperLeft", scale: [n / e2, a / i], translate: [o.xmin, o.ymax] }, {}, t2);
    let s3 = "";
    for (let e3 = 0; e3 < t2.paths.length; e3++) {
      const i2 = t2.paths[e3];
      for (let t3 = 0; t3 < i2.length; t3++) {
        const e4 = i2[t3][0], o2 = i2[t3][1];
        let n2 = "";
        0 === t3 ? (n2 = `M${e4.toString()} ${o2.toString()}`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2) : (n2 = `l${e4.toString()} ${o2.toString()}`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2);
      }
    }
    return s3;
  }
  return "";
}
function B(t2, e2) {
  const i = $.getContext("2d"), o = [];
  e2 && (e2.weight && o.push(e2.weight), e2.size && o.push(e2.size + "px"), e2.family && o.push(e2.family)), i.font = o.join(" ");
  const { width: n, actualBoundingBoxLeft: a, actualBoundingBoxRight: l3, actualBoundingBoxAscent: s3, actualBoundingBoxDescent: r } = i.measureText(t2);
  return { width: Math.ceil(Math.max(n, a + l3)), height: Math.ceil(s3 + r), x: Math.floor(a), y: Math.floor((s3 - r) / 2) };
}
function P(t2) {
  const e2 = t2?.size;
  return { width: null != e2 && "object" == typeof e2 && "width" in e2 ? u(e2.width) : null, height: null != e2 && "object" == typeof e2 && "height" in e2 ? u(e2.height) : null };
}
async function E(t2, e2) {
  const i = e2.fill, o = t2.color;
  if ("pattern" === i?.type && o && t2.type !== g2) {
    const t3 = await f(i.src, o.toCss(true));
    i.src = t3, e2.fill = i;
  }
}
async function U2(t2, e2, i, n) {
  if (!("font" in t2) || !t2.font || "text" !== e2.shape.type) return;
  try {
    await c(t2.font);
  } catch {
  }
  const { width: a, height: l3 } = P(n);
  if (!/[\uE600-\uE6FF]/.test(e2.shape.text)) {
    const { width: o, height: s3, x: r, y: h } = B(e2.shape.text, { weight: e2.font?.weight, size: e2.font?.size, family: e2.font?.family });
    i[0] = a ?? o, i[1] = l3 ?? s3, e2.shape.x = r, e2.shape.y = h;
    let c2 = "angle" in t2 ? t2.angle : null;
    if (null != n?.rotation && (c2 = (c2 ?? 0) + n.rotation), c2) {
      const t3 = c2 * (Math.PI / 180), e3 = Math.abs(Math.sin(t3)), o2 = Math.abs(Math.cos(t3));
      i[1] = i[0] * e3 + i[1] * o2;
    }
  }
}
function A(t2, e2, i, o, a) {
  if (null != t2.haloColor && null != t2.haloSize) {
    a.masking ??= i.map(() => []);
    const l3 = u(t2.haloSize);
    o[0] += l3, o[1] += l3, i.unshift([{ ...e2, fill: null, stroke: { color: t2.haloColor, width: 2 * l3, join: "round", cap: "round" } }]), a.masking.unshift([{ shape: { type: "rect", x: 0, y: 0, width: o[0] + 2 * s2, height: o[1] + 2 * s2 }, fill: [255, 255, 255], stroke: null }, { ...e2, fill: [0, 0, 0, 0], stroke: null }]);
  }
  null == t2.backgroundColor && null == t2.borderLineColor || (o[0] += 2 * s2, o[1] += 2 * s2, i.unshift([{ shape: { type: "rect", x: 0, y: 0, width: o[0], height: o[1] }, fill: t2.backgroundColor, stroke: { color: t2.borderLineColor, width: u(t2.borderLineSize) } }]), a.masking?.unshift([]));
}
function F(t2, e2) {
  return t2 > e2 ? "dark" : "light";
}
function Z(t2, e2) {
  const i = "number" == typeof e2?.size ? e2?.size : null, o = null != i ? u(i) : null, a = null != e2?.maxSize ? u(e2.maxSize) : null;
  let l3 = "angle" in t2 ? t2.angle : null;
  null != e2?.rotation && (l3 = (l3 ?? 0) + e2.rotation);
  const c2 = u2(t2);
  let m = y(t2);
  "dark" !== q(t2, 245) || e2?.ignoreWhiteSymbols || (m = { width: 0.75, ...m, color: "#bdc3c7" });
  let p = null;
  const d2 = { shape: null, fill: c2, stroke: m, offset: [0, 0] };
  m?.width && (m.width = Math.min(m.width, k2));
  const f2 = m?.width || 0;
  let C2 = null != e2?.size && (null == e2?.scale || e2?.scale), $2 = 0, E2 = 0, U3 = false;
  switch (t2.type) {
    case b: {
      const i2 = t2.style, { width: s3, height: r } = P(e2);
      let h = s3 === r && null != s3 ? s3 : null != o ? o : Math.min(u(t2.size), a || z);
      if (true === e2?.useMarkerSymbolSize && null !== s3 && null !== r) {
        const e3 = Math.min(u(t2.size), a || z);
        h = e3 > s3 && e3 > r ? Math.min(s3, r) : e3;
      }
      switch ($2 = h, E2 = h, i2) {
        case "circle":
          d2.shape = { type: "circle", cx: 0, cy: 0, r: 0.5 * h }, C2 || ($2 += f2, E2 += f2);
          break;
        case "cross":
          d2.shape = { type: "path", path: [{ command: "M", values: [0, 0.5 * E2] }, { command: "L", values: [$2, 0.5 * E2] }, { command: "M", values: [0.5 * $2, 0] }, { command: "L", values: [0.5 * $2, E2] }] };
          break;
        case "diamond":
          d2.shape = { type: "path", path: [{ command: "M", values: [0, 0.5 * E2] }, { command: "L", values: [0.5 * $2, 0] }, { command: "L", values: [$2, 0.5 * E2] }, { command: "L", values: [0.5 * $2, E2] }, { command: "Z", values: [] }] }, C2 || ($2 += f2, E2 += f2);
          break;
        case "square":
          d2.shape = { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [$2, 0] }, { command: "L", values: [$2, E2] }, { command: "L", values: [0, E2] }, { command: "Z", values: [] }] }, C2 || ($2 += f2, E2 += f2), l3 && (U3 = true);
          break;
        case "triangle":
          d2.shape = { type: "path", path: [{ command: "M", values: [0.5 * $2, 0] }, { command: "L", values: [$2, E2] }, { command: "L", values: [0, E2] }, { command: "Z", values: [] }] }, C2 || ($2 += f2, E2 += f2), l3 && (U3 = true);
          break;
        case "x":
          d2.shape = { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [$2, E2] }, { command: "M", values: [$2, 0] }, { command: "L", values: [0, E2] }] }, l3 && (U3 = true);
          break;
        case "path":
          d2.shape = { type: "path", path: t2.path || "" }, C2 || ($2 += f2, E2 += f2), l3 && (U3 = true), C2 = true;
      }
      break;
    }
    case x: {
      const { width: t3, height: i2 } = P(e2), n = g(m).reduce((t4, e3) => t4 + e3, 0), a2 = n && Math.ceil(L2 / n), l4 = i2 ?? o ?? f2, s3 = t3 ?? (n * a2 || L2);
      if (C2 = true, "polyline" === e2?.geometry?.type && e2?.geometry?.extent) {
        $2 = s3, E2 = i2 ?? $2;
        const t4 = 1e3, o2 = 0.15 * t4;
        p = [$2, E2], E2 = p[0] > p[1] ? t4 * p[1] / p[0] : t4, $2 = p[0] > p[1] ? t4 : t4 * p[0] / p[1], m?.width && (m.width = m.width * t4 / (p[1] > p[0] ? p[1] : p[0]), m.width > o2 && (m.width = o2)), d2.shape = { type: "path", path: j(e2.geometry, $2, E2) };
      } else $2 = null != e2?.maxSize ? Math.min(s3, e2.maxSize) : s3, E2 = l4, m && (m.width = l4), d2.shape = { type: "path", path: [{ command: "M", values: [l4 / 2, E2 / 2] }, { command: "L", values: [$2 - l4 / 2, E2 / 2] }] };
      break;
    }
    case g2:
    case w: {
      const t3 = "object" == typeof e2?.symbolConfig && !!e2?.symbolConfig?.isSquareFill, { width: i2, height: n } = P(e2);
      $2 = !t3 && i2 !== n || null == i2 ? null != o ? o : S : i2, E2 = !t3 && i2 !== n || null == n ? $2 : n, C2 || ($2 += f2, E2 += f2), C2 = true, e2?.geometry?.extent && "polygon" === e2?.geometry?.type ? (p = [$2, E2], E2 = p[0] > p[1] ? 1e3 * p[1] / p[0] : 1e3, $2 = p[0] > p[1] ? 1e3 : 1e3 * p[0] / p[1], d2.shape = { type: "path", path: j(e2.geometry, $2, E2) }) : d2.shape = t3 ? { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [$2, 0] }, { command: "L", values: [$2, E2] }, { command: "L", values: [0, E2] }, { command: "L", values: [0, 0] }, { command: "Z", values: [] }] } : e.fill[0];
      break;
    }
    case y2: {
      const i2 = Math.min(u(t2.width), a || z), s3 = Math.min(u(t2.height), a || z), { width: r, height: h } = P(e2), c3 = r === h && null != r ? r : null != o ? o : Math.max(i2, s3), m2 = t2.width / t2.height;
      $2 = m2 <= 1 ? Math.ceil(c3 * m2) : c3, E2 = m2 <= 1 ? c3 : Math.ceil(c3 / m2), d2.shape = { type: "image", x: -Math.round($2 / 2), y: -Math.round(E2 / 2), width: $2, height: E2, src: t2.url || "" }, l3 && (U3 = true);
      break;
    }
    case v: {
      const i2 = t2, l4 = e2?.overrideText || i2.text || M, s3 = i2.font, { width: r, height: h } = P(e2), c3 = null != h ? h : null != o ? o : Math.min(u(s3.size), a || z), { width: m2, height: u3 } = B(l4, { weight: s3.weight, size: c3, family: s3.family }), p2 = /[\uE600-\uE6FF]/.test(l4);
      $2 = r ?? (p2 ? c3 : m2), E2 = p2 ? c3 : u3;
      let f3 = 0.5 * (p2 ? c3 : u3);
      p2 && (f3 += 5), d2.shape = { type: "text", text: l4, x: i2.xoffset || 0, y: i2.yoffset || f3, align: "middle", alignBaseline: i2.verticalAlignment, decoration: s3 && s3.decoration, rotated: i2.rotated, kerning: i2.kerning }, d2.font = s3 && { size: c3, style: s3.style, decoration: s3.decoration, weight: s3.weight, family: s3.family };
      break;
    }
  }
  return { shapeDescriptor: d2, size: [$2, E2], outputSize: p, renderOptions: { node: e2?.node, scale: C2, opacity: e2?.opacity, rotations: [l3], useRotationSize: U3, effectView: e2?.effectView, ariaLabel: e2?.ariaLabel, clipBloomEffect: e2?.clipBloomEffect } };
}
async function D(t2, e2) {
  const { shapeDescriptor: o, size: n, renderOptions: a, outputSize: l3 } = Z(t2, e2);
  if (!o.shape) throw new s("symbolPreview: renderPreviewHTML2D", "symbol not supported.");
  await E(t2, o), await U2(t2, o, n, e2);
  const s3 = [[o]];
  if ("object" == typeof e2?.symbolConfig && e2?.symbolConfig?.applyColorModulation) {
    const t3 = 0.6 * n[0];
    s3.unshift([{ ...o, offset: [-t3, 0], fill: d(o.fill, -0.3) }]), s3.push([{ ...o, offset: [t3, 0], fill: d(o.fill, 0.3) }]), n[0] += 2 * t3, a.scale = false;
  }
  "text" === t2.type && A(t2, o, s3, n, a);
  const r = l2(s3, n, a);
  if (l3 && r) {
    const t3 = "img" === r.nodeName.toLowerCase() ? r : r.firstChild;
    "svg" === t3.nodeName.toLowerCase() && t3.setAttribute("viewBox", `0 0 ${n[0].toString()} ${n[1].toString()}`), t3.setAttribute("width", l3[0].toString()), t3.setAttribute("height", l3[1].toString()), l3.length > 2 && (t3.style.setProperty("padding-left", l3[2]?.toString() + "px"), t3.style.setProperty("padding-right", l3[2]?.toString() + "px"), t3.style.setProperty("padding-top", l3[3]?.toString() + "px"), t3.style.setProperty("padding-bottom", l3[3]?.toString() + "px"), t3.style.setProperty("box-sizing", "border-box"));
  }
  return r;
}
function q(i, o = C) {
  const n = u2(i), a = y(i), l3 = !n || "type" in n ? null : new l(n), h = a?.color ? new l(a?.color) : null, c2 = l3 ? F(L(l3), o) : null, m = h ? F(L(h), o) : null;
  return m ? c2 ? c2 === m ? c2 : o >= C ? "light" : "dark" : m : c2;
}
export {
  q as getContrastingBackgroundTheme,
  Z as getRenderSymbolParameters,
  D as previewSymbol2D
};
//# sourceMappingURL=previewSymbol2D-F65MSSP7.js.map
