import {
  c as c2,
  d as d3,
  p as p4,
  v,
  z
} from "./chunk-UF2EZ647.js";
import {
  F,
  M as M2,
  N,
  T as T2,
  U as U2,
  b
} from "./chunk-APGIAJ3M.js";
import {
  $ as $2,
  C as C2,
  P as P2,
  c,
  d as d2,
  j as j3,
  m as m3,
  q
} from "./chunk-NLQ5JBZ3.js";
import {
  a as a4,
  n as n2
} from "./chunk-WQVEQTKW.js";
import {
  n as n3
} from "./chunk-5HHZADOU.js";
import "./chunk-DKS7UUDR.js";
import {
  a as a5
} from "./chunk-YB2E6SEN.js";
import "./chunk-KH55BE33.js";
import "./chunk-WEBPKGFM.js";
import "./chunk-6DARBDBU.js";
import "./chunk-KDQWOWXR.js";
import "./chunk-JOVQBCRD.js";
import {
  R as R3
} from "./chunk-I3A6CJVF.js";
import {
  m as m4,
  m2 as m5,
  m3 as m6,
  n as n4
} from "./chunk-U3MD377S.js";
import "./chunk-2B6XECE5.js";
import "./chunk-ZAIOYQ5Z.js";
import "./chunk-QB5ST4HW.js";
import "./chunk-VNLFNBKT.js";
import "./chunk-KHEIHGIK.js";
import {
  s as s3
} from "./chunk-AAC6XSCN.js";
import {
  $,
  C,
  M,
  U,
  f as f2,
  j as j2
} from "./chunk-Z7VYTTYM.js";
import {
  at
} from "./chunk-55AFRDJF.js";
import "./chunk-F5C72MOD.js";
import "./chunk-VNTS5E5O.js";
import "./chunk-X3UT6DT7.js";
import "./chunk-JD3UVEVP.js";
import "./chunk-YHYQP7QX.js";
import "./chunk-TNW4TPNP.js";
import "./chunk-4GXVCEW4.js";
import "./chunk-KQINCOQL.js";
import {
  g as g2
} from "./chunk-B6C7UPBZ.js";
import {
  a as a3,
  l as l2
} from "./chunk-Z6OMEWWC.js";
import {
  t
} from "./chunk-OTSYE6UT.js";
import "./chunk-AGDHKBKD.js";
import "./chunk-OC2XWDW2.js";
import "./chunk-C3JHRSMA.js";
import "./chunk-M2UZRY7C.js";
import "./chunk-HUVZEBBO.js";
import "./chunk-VLPG2W66.js";
import "./chunk-GH7GZNY6.js";
import "./chunk-G5DA3EEG.js";
import "./chunk-D443BZKU.js";
import "./chunk-7DFHXN7Z.js";
import "./chunk-NX54JGTL.js";
import "./chunk-I6IIPG56.js";
import "./chunk-JEYXDNAT.js";
import "./chunk-DJJNSAUR.js";
import "./chunk-PZBXBPVO.js";
import "./chunk-TMC6HYGQ.js";
import "./chunk-7FAVUXK2.js";
import "./chunk-IVNFIIVI.js";
import "./chunk-T4QXFCFF.js";
import "./chunk-BFUOEOXA.js";
import "./chunk-NOGWEW4X.js";
import "./chunk-ZCZERMS4.js";
import "./chunk-7CUBIFKN.js";
import "./chunk-FEGY3M6U.js";
import "./chunk-RWRC6JKB.js";
import "./chunk-M6AESODI.js";
import "./chunk-NY6S6EMV.js";
import "./chunk-AQGMTI4V.js";
import "./chunk-QG7JWSBW.js";
import {
  p as p5
} from "./chunk-ZXGBNDYM.js";
import "./chunk-GOWWJ2HE.js";
import {
  R as R2,
  a as a2
} from "./chunk-7ZMGKXLG.js";
import {
  p as p3
} from "./chunk-JMXPE5PE.js";
import {
  R
} from "./chunk-LL73CCBG.js";
import {
  i as i2,
  m as m2,
  p
} from "./chunk-6TS2ZJL4.js";
import {
  i as i3
} from "./chunk-IBGTNH54.js";
import "./chunk-ROVRMLYN.js";
import {
  f
} from "./chunk-SYPTUUSZ.js";
import "./chunk-6QTMK7BB.js";
import "./chunk-BNO7HCVD.js";
import "./chunk-7NMH5MM5.js";
import "./chunk-TCIXF7MM.js";
import "./chunk-UGTICYU7.js";
import "./chunk-3MHRDLQO.js";
import "./chunk-VUGQF5TL.js";
import "./chunk-ZAISHGSP.js";
import "./chunk-KHRHKYU2.js";
import {
  d
} from "./chunk-2IMSGFJN.js";
import "./chunk-VHTQ5H2C.js";
import "./chunk-YX2VTIZR.js";
import "./chunk-LYSDGL5S.js";
import "./chunk-SRJX4QLW.js";
import "./chunk-WPTJIN2M.js";
import "./chunk-KUP5BM5G.js";
import "./chunk-HNQNVI5C.js";
import "./chunk-G34OBNLT.js";
import "./chunk-WJUYGRZY.js";
import "./chunk-FKFXOPPT.js";
import "./chunk-KE3WBZYL.js";
import {
  r as r2
} from "./chunk-EOMIFMDH.js";
import "./chunk-QFU5COFB.js";
import "./chunk-45ILJ6ZH.js";
import {
  Fe,
  Ie,
  Te,
  be,
  e2 as e,
  ge,
  we
} from "./chunk-VCRP2PLV.js";
import "./chunk-BDLVUYG2.js";
import "./chunk-6QA2BVC5.js";
import "./chunk-HWKQJUGY.js";
import "./chunk-QVKLS4LH.js";
import "./chunk-2KVNXQA7.js";
import "./chunk-XDCUZFJX.js";
import "./chunk-DNZK6PPI.js";
import "./chunk-7BWCD63N.js";
import "./chunk-65K4DQAH.js";
import "./chunk-MUKDJQWB.js";
import "./chunk-6KFXWKZZ.js";
import "./chunk-YBJ5GVXQ.js";
import "./chunk-X3R5OB6L.js";
import "./chunk-RACDQ3AL.js";
import "./chunk-TEXTBDH7.js";
import "./chunk-N3A2BVTW.js";
import "./chunk-IGYEHOTB.js";
import "./chunk-TVM3SZJR.js";
import "./chunk-52HWRRRQ.js";
import "./chunk-VNTEV3V4.js";
import "./chunk-OGOQOMMV.js";
import "./chunk-7Z3AF3B2.js";
import "./chunk-6GWORUT3.js";
import "./chunk-U57T7EQN.js";
import "./chunk-CMHHL5UO.js";
import "./chunk-XHYOFJ4U.js";
import {
  P
} from "./chunk-KJSBBQ22.js";
import "./chunk-LMEOPAGQ.js";
import "./chunk-YIV2QKTZ.js";
import {
  j
} from "./chunk-A3VAC24F.js";
import "./chunk-FPSA4NFH.js";
import "./chunk-UY6B6IVT.js";
import "./chunk-6PV45IYU.js";
import {
  p as p2
} from "./chunk-SRQCQD63.js";
import "./chunk-FIRNXFAH.js";
import "./chunk-O5TPFXRT.js";
import "./chunk-Q6XRAGMA.js";
import "./chunk-JUAPMINU.js";
import "./chunk-PK2ZR2SJ.js";
import "./chunk-YFPGM5UE.js";
import "./chunk-OXSERRAR.js";
import "./chunk-7HI4VRVW.js";
import "./chunk-ZX46THLM.js";
import "./chunk-Y2ZIOB7Y.js";
import "./chunk-KTUX3OKX.js";
import {
  l
} from "./chunk-E3KEUGUG.js";
import {
  m
} from "./chunk-N3XLUQJI.js";
import {
  a2 as a
} from "./chunk-JUAD7TJ6.js";
import "./chunk-VHLUKPRH.js";
import {
  r
} from "./chunk-5TPMG26T.js";
import "./chunk-3NBBZ43U.js";
import "./chunk-VOLWOTEG.js";
import "./chunk-XTNIDRTB.js";
import "./chunk-FGWIXJQY.js";
import "./chunk-TKYAZCMB.js";
import "./chunk-3TBMFSPB.js";
import "./chunk-PSZLDJJA.js";
import {
  H,
  g2 as g
} from "./chunk-ZWFY3WY5.js";
import "./chunk-LQFTAGIV.js";
import "./chunk-S7IJH524.js";
import {
  T,
  h,
  n,
  s as s2
} from "./chunk-GZ2P4SCJ.js";
import {
  i2 as i,
  s
} from "./chunk-XWG6QGFK.js";
import "./chunk-GWNLQRNM.js";
import {
  A,
  L,
  has
} from "./chunk-FXKORAMT.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/smartMapping/support/binningUtils.js
function i4(e3, i7) {
  if (!e3.view) throw new s(`${i7}:missing-parameters`, "'view' parameter is required for binning");
  if (e3.sqlExpression) throw new s(`${i7}:invalid-parameters`, "'sqlExpression' parameter is not supported for binning");
  if ("3d" === e3.view.type) throw new s(`${i7}:invalid-parameters`, "3d view is not supported for binning");
}

// node_modules/@arcgis/core/smartMapping/statistics/support/WorkerClient.js
var n5 = class _n {
  constructor() {
    this.connection = null;
  }
  async open(t3) {
    this.connection = await p5("statsWorker", { strategy: "distributed", signal: t3 });
  }
  destroy() {
    this.connection?.close();
  }
  static getInstance() {
    return _n.instance || (_n.instance = new _n()), _n.instance;
  }
  async summaryStatistics(e3, n7) {
    if (!this.connection) throw new s("worker-client:summary-statistics", "connection is required");
    return this.connection.invoke("summaryStatistics", { attribute: e3, features: n7 });
  }
  async uniqueValues(e3, n7) {
    if (!this.connection) throw new s("worker-client:unique-values", "connection is required");
    return this.connection.invoke("uniqueValues", { attribute: e3, features: n7 });
  }
  async classBreaks(e3, n7) {
    if (!this.connection) throw new s("worker-client:class-breaks", "connection is required");
    return this.connection.invoke("classBreaks", { attribute: e3, features: n7 });
  }
  async histogram(e3, n7) {
    if (!this.connection) throw new s("worker-client:histogram", "connection is required");
    return this.connection.invoke("histogram", { attribute: e3, features: n7 });
  }
  async heatmapStatistics(e3, n7) {
    if (!this.connection) throw new s("worker-client:heatmap-statistics", "connection is required");
    return this.connection.invoke("heatmapStatistics", { attribute: e3, features: n7 });
  }
};

// node_modules/@arcgis/core/rest/query/executeQuery.js
async function f3(t3, o4, r5, e3, n7) {
  return m7(o4, await c3(t3, o4, r5, e3, n7), r5, e3);
}
async function c3(t3, o4, r5, e3, n7) {
  const i7 = { ...e3 }, u3 = p6(o4, r5), f5 = null != o4.outStatistics?.[0], c5 = has("featurelayer-pbf-statistics"), m9 = !f5 || c5;
  let d6;
  if ("pbf" === r5?.format && m9) try {
    d6 = await n3(t3, u3, i7, n7);
  } catch (y) {
    if ("query:parsing-pbf" !== y.name) throw y;
    r5.format = "json";
  }
  return "json" !== r5?.format && m9 || (d6 = await a5(t3, u3, i7, n7)), l3(r5?.fieldsIndex, d6.fields), d6;
}
function l3(t3, o4) {
  if (null != t3 && null != o4) for (const r5 of o4) {
    const o5 = t3.get(r5.name);
    o5 && Object.assign(r5, o5.toJSON());
  }
}
async function m7(t3, r5, e3, n7) {
  const s6 = e3?.infoFor3D;
  if (!d4(t3, s6) || null == s6 || !r5.assetMaps || !r5.features?.length) return g2.fromJSON(r5);
  const { meshFeatureSetFromJSON: a6 } = await h(import("./meshFeatureSet-2NHMK4TN.js"), n7);
  return a6(t3, s6, r5);
}
function p6(o4, s6) {
  let a6 = R2.from(o4);
  a6.sourceSpatialReference = a6.sourceSpatialReference ?? s6?.sourceSpatialReference ?? null, (s6?.gdbVersion || s6?.dynamicDataSource) && (a6 = a6 === o4 ? a6.clone() : a6, a6.gdbVersion = o4.gdbVersion || s6.gdbVersion, a6.dynamicDataSource = o4.dynamicDataSource ? R.from(o4.dynamicDataSource) : s6.dynamicDataSource);
  const i7 = s6?.infoFor3D;
  if (null != i7 && d4(o4, i7)) {
    a6 = a6 === o4 ? a6.clone() : a6, a6.formatOf3DObjects = null;
    const n7 = a3(i7), s7 = l2(i7);
    for (const t3 of i7.queryFormats) {
      if (t3 === n7) {
        a6.formatOf3DObjects = t3;
        break;
      }
      t3 !== s7 || a6.formatOf3DObjects || (a6.formatOf3DObjects = t3);
    }
    if (!a6.formatOf3DObjects) throw new s("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
    if (null == a6.outFields || !a6.outFields.includes("*")) {
      a6 = a6 === o4 ? a6.clone() : a6, null == a6.outFields && (a6.outFields = []);
      const { originX: t3, originY: r5, originZ: e3, translationX: n8, translationY: s8, translationZ: u3, scaleX: f5, scaleY: c5, scaleZ: l6, rotationX: m9, rotationY: p9, rotationZ: d6, rotationDeg: y } = i7.transformFieldRoles;
      a6.outFields.push(t3, r5, e3, n8, s8, u3, f5, c5, l6, m9, p9, d6, y);
    }
  }
  return a6;
}
function d4(t3, o4) {
  return null != o4 && true === t3.returnGeometry && "xyFootprint" !== t3.multipatchOption && !t3.outStatistics;
}

// node_modules/@arcgis/core/rest/generateRenderer.js
async function l4(t3, i7, a6, s6) {
  const l6 = f(t3), { source: r5, checkValueRange: u3 } = i7, { classificationDefinition: c5 } = a6, f5 = { ...a6.toJSON(), f: "json" };
  let m9 = null;
  if (m9 = "class-breaks-definition" === c5?.type ? c5.classificationField : c5?.attributeField, r5) {
    const e3 = { source: r5?.toJSON() };
    f5.layer = JSON.stringify(e3);
  }
  f5.classificationDef && (f5.classificationDef = JSON.stringify(f5.classificationDef));
  let p9 = { query: f5 };
  s6 && (p9 = { ...s6, ...p9 });
  const y = { url: l6.path, field: m9, checkValueRange: u3 }, d6 = l6.path + "/generateRenderer";
  return H(d6, p9).then((e3) => o(y, e3));
}
function o(e3, t3) {
  const { field: n7, checkValueRange: l6, url: o4 } = e3, u3 = t3?.data;
  if (!u3) return;
  if (!l6) {
    const e4 = r3(u3);
    return Promise.resolve(e4);
  }
  const c5 = new p3({ statisticType: "min", onStatisticField: n7 }), f5 = new p3({ statisticType: "max", onStatisticField: n7 }), m9 = new R2({ outStatistics: [c5, f5] });
  return f3(o4, m9).then((e4) => {
    const t4 = e4.features[0].attributes;
    let n8 = null, i7 = null;
    for (const a6 in t4) 0 === a6.toLowerCase().indexOf("min") ? n8 = t4[a6] : i7 = t4[a6];
    return r3(u3, n8, i7);
  });
}
function r3(e3, n7, i7) {
  if ("classBreaks" === e3.type) {
    const a7 = t(e3);
    return { classBreaks: a7.classBreakInfos.map((e4, t3) => (0 === t3 && null != n7 && (e4.minValue = n7), t3 === a7.classBreakInfos.length - 1 && null != i7 && (e4.maxValue = i7), { minValue: e4.minValue, maxValue: e4.maxValue, label: e4.label })), normalizationTotal: a7.normalizationTotal };
  }
  const { uniqueValueInfos: a6 } = e3;
  return { uniqueValues: a6?.map((e4, t3) => (0 === t3 && null != n7 && (e4.value = n7), t3 === a6.length - 1 && null != i7 && (e4.value = i7), { count: e4.count, value: e4.value, label: e4.label })) ?? [] };
}

// node_modules/@arcgis/core/rest/support/GenerateRendererParameters.js
var t2 = class extends l {
  constructor(r5) {
    super(r5), this.classificationDefinition = null, this.where = null;
  }
};
r([m({ json: { name: "classificationDef", write: true } })], t2.prototype, "classificationDefinition", void 0), r([m({ type: String, json: { write: true } })], t2.prototype, "where", void 0), t2 = r([a("esri.rest.support.GenerateRendererParameters")], t2);

// node_modules/@arcgis/core/rest/support/UniqueValueDefinition.js
var s4 = class extends l {
  constructor(t3) {
    super(t3), this.type = "unique-value-definition", this.attributeField = null, this.attributeField2 = null, this.attributeField3 = null, this.fieldDelimiter = null;
  }
  get uniqueValueFields() {
    const t3 = [];
    return this.attributeField && t3.push(this.attributeField), this.attributeField2 && t3.push(this.attributeField2), this.attributeField3 && t3.push(this.attributeField3), t3;
  }
};
r([r2({ uniqueValueDef: "unique-value-definition" })], s4.prototype, "type", void 0), r([m()], s4.prototype, "attributeField", void 0), r([m()], s4.prototype, "attributeField2", void 0), r([m()], s4.prototype, "attributeField3", void 0), r([m({ json: { write: true } })], s4.prototype, "fieldDelimiter", void 0), r([m({ json: { write: true } })], s4.prototype, "uniqueValueFields", null), s4 = r([a("esri.rest.support.UniqueValueDefinition")], s4);

// node_modules/@arcgis/core/smartMapping/statistics/support/predominanceUtils.js
var e2 = "no_dominant_category";
function u(n7) {
  return { expression: r4(n7, { returnFieldName: true, defaultValue: `'${e2}'` }) };
}
function r4(e3, l6) {
  const { returnFieldName: u3, defaultValue: r5, layer: t3 } = l6, i7 = [];
  if (u3 && r5) {
    const n7 = e3.map((n8) => `${n8} <= 0`).join(" AND ");
    i7.push(`WHEN ${n7} THEN ${r5}`);
  }
  for (const o4 of e3) {
    const l7 = e3.reduce((n7, a6) => (o4 !== a6 && n7.push(`${o4} > ${a6}`), n7), []).join(" AND "), r6 = t3 && j2(t3, o4), s6 = u3 && `'${o4}'` ? `'${o4}'` : r6 ? M(o4) : o4;
    i7.push(`WHEN ${l7} THEN ${s6}`);
  }
  return `CASE ${i7.join(" ")} ELSE ${r5 || "0"} END`;
}
function i5(n7) {
  return n7 && n7.map((n8) => `$feature["${n8}"];`).join("\n") + "\n" || "";
}
function o2(n7, a6 = false) {
  const e3 = n7.map((n8) => `"${n8}"`), l6 = "\n  if(value != null && value >= 0) {\n    if (totalValue == null) { totalValue = 0; }\n    totalValue = totalValue + value;\n  }\n  ";
  return `
  var fieldNames = [ ${e3.join(", ")} ];
  var numFields = ${e3.length};
  var maxValueField = null;
  var maxValue = -Infinity;
  var value, i, totalValue = null;

  for(i = 0; i < numFields; i++) {
    value = $feature[fieldNames[i]];

    if(value > 0) {
      if(value > maxValue) {
        maxValue = value;
        maxValueField = fieldNames[i];
      }
      else if (value == maxValue) {
        maxValueField = null;
      }
    }
    ${a6 ? l6 : ""}
  }
  `;
}
function s5(n7) {
  const a6 = o2(n7);
  return `
  ${i5(n7)}
  ${a6}
  return maxValueField;
  `;
}

// node_modules/@arcgis/core/smartMapping/support/adapters/LayerAdapter.js
var p7 = class extends p2 {
  constructor(o4) {
    super(o4), this.adapterName = "layer-adapter";
  }
};
r([m({ readOnly: true })], p7.prototype, "adapterName", void 0), r([m({ constructOnly: true })], p7.prototype, "layer", void 0), r([m()], p7.prototype, "geometryType", void 0), r([m()], p7.prototype, "objectIdField", void 0), r([m()], p7.prototype, "supportsSQLExpression", void 0), r([m()], p7.prototype, "hasQueryEngine", void 0), r([m()], p7.prototype, "minScale", void 0), r([m()], p7.prototype, "maxScale", void 0), r([m()], p7.prototype, "fullExtent", void 0), p7 = r([a("esri.smartMapping.support.adapters.LayerAdapter")], p7);

// node_modules/@arcgis/core/smartMapping/support/adapters/support/utils.js
var F2 = /_value$/i;
var w = Math.LOG10E;
var E = { SECOND: 1e3, MINUTE: 6e4, HOUR: 36e5 };
var S = 10;
function T3(e3) {
  return e3.map((e4) => e4.toJSON());
}
function V(e3, t3) {
  const n7 = [], l6 = e3.layer, i7 = "featureReduction" in l6 ? l6.featureReduction : null, o4 = "binning" === i7?.type, a6 = null != i7 && "fields" in i7 ? i7.fields?.map((e4) => e4.name?.toLowerCase()).filter(Boolean) : [];
  if (!o4 || !t3) return n7;
  for (const r5 of t3) a6.includes(r5.toLowerCase()) || n7.push(r5);
  return n7;
}
function z2(e3, t3, n7) {
  const l6 = [];
  if (t3) for (const i7 of t3) {
    const t4 = e3.getField(i7);
    t4 && n7 && "availableFields" in n7 && !n7.availableFields?.includes(t4.name) && l6.push(t4.name);
  }
  return l6;
}
function $3(e3, t3) {
  const n7 = e3 && e3.features;
  if (0 === n7?.length) return { avg: null, count: 0, max: null, median: null, min: null, nullcount: 0, stddev: null, sum: null, variance: null };
  const l6 = n7?.[0]?.attributes, i7 = {};
  for (const o4 in l6) i7[o4.replace(F2, "").toLowerCase()] = l6[o4];
  return null != i7.totalcount && i7.totalcount >= i7.count && (i7.nullcount = i7.totalcount - i7.count), delete i7.totalcount, i7.min === i7.max && null != i7.min && null == i7.stddev && (i7.stddev = i7.variance = 0), t3 && (["min", "max", "avg", "stddev", "sum", "variance"].forEach((e4) => {
    null != i7[e4] && (i7[e4] = Math.ceil(i7[e4]));
  }), i7.min === i7.max && null != i7.min && (i7.avg = i7.min, i7.stddev = i7.variance = 0)), i7;
}
function C3(e3) {
  const t3 = [], n7 = e3.classBreaks, l6 = n7[0].minValue, i7 = n7[n7.length - 1].maxValue;
  n7.forEach((e4) => {
    t3.push([e4.minValue, e4.maxValue]);
  });
  const o4 = { field: e3.field, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, layer: e3.layer };
  return { min: l6, max: i7, intervals: t3, sqlExpr: j4(o4), excludeZerosExpr: e3.where, normTotal: e3.normalizationTotal };
}
function j4(e3) {
  const { field: t3, normalizationType: n7, normalizationField: l6, normalizationTotal: i7, layer: o4 } = e3, a6 = j2(o4, t3);
  let r5 = t3;
  return "percent-of-total" === n7 ? r5 = `((${a6 ? M(t3) : t3} / ${i7}) * 100)` : "log" === n7 ? r5 = `(log(${t3}) * ${w})` : "field" === n7 ? r5 = `(${a6 ? M(t3) : t3} / ${l6})` : "natural-log" === n7 ? r5 = `(log(${a6 ? M(t3) : t3}))` : "square-root" === n7 && (r5 = `(power(${a6 ? M(t3) : t3}, 0.5))`), r5;
}
function q2(e3, t3) {
  let n7;
  if (t3 = t3.toLowerCase(), e3) {
    for (const l6 in e3) if (l6.toLowerCase() !== t3) {
      n7 = e3[l6];
      break;
    }
  }
  return n7;
}
function b2(e3, t3) {
  let n7;
  if (t3 = t3.toLowerCase(), e3) {
    for (const l6 in e3) if (l6.toLowerCase() === t3) {
      n7 = e3[l6];
      break;
    }
  }
  return n7;
}
function O(e3, t3, n7, l6, i7) {
  const o4 = {}, a6 = "countOFExpr";
  e3 && e3.features && e3.features.forEach((e4) => {
    const t4 = e4.attributes, n8 = q2(t4, a6), l7 = b2(t4, a6);
    null != n8 && null != l7 && 0 !== n8 && (o4[n8] = l7);
  });
  const r5 = [];
  return j3(t3, n7, l6).forEach((e4, t4) => {
    const n8 = (t4 + 1).toString();
    r5.push({ minValue: e4[0], maxValue: e4[1], count: o4.hasOwnProperty(n8) ? o4[n8] : 0 });
  }), { bins: r5, minValue: t3, maxValue: n7, normalizationTotal: i7 };
}
async function L2(e3, n7) {
  const l6 = e3 && e3.features, { field: i7, field2: o4, field3: a6, fieldDelimiter: r5, layer: s6, view: u3, signal: c5, labels: m9 } = n7, f5 = `countOF${!(!i7 || !o4) ? "Expr" : i7 || "Expr"}`, p9 = {};
  let d6 = false;
  for (const t3 of l6) {
    const e4 = t3.attributes, n8 = b2(e4, f5);
    let l7 = i7 ? b2(e4, i7) : q2(e4, f5), s7 = o4 ? b2(e4, o4) : null, u4 = a6 ? b2(e4, a6) : null;
    null === l7 && 0 === n8 && (d6 = true), (null == l7 || "string" == typeof l7 && "" === l7.trim()) && (l7 = null), o4 && (null == s7 || "string" == typeof s7 && "" === s7.trim()) && (s7 = null), a6 && (null == u4 || "string" == typeof u4 && "" === u4.trim()) && (u4 = null);
    let c6 = l7;
    o4 && (c6 = `${m3(c6)}${r5}${m3(s7)}`, a6 && (c6 = `${c6}${r5}${m3(u4)}`)), null == p9[c6] ? p9[c6] = { count: n8, data: c6 } : p9[c6].count = p9[c6].count + n8;
  }
  if (i7 && d6) {
    const e4 = i7 + " is NULL";
    try {
      const t3 = await s6.queryFeatureCount({ whereClause: e4, view: u3, signal: c5 });
      return p9.null.count = p9.null.count + t3, R4(p9, m9);
    } catch {
      return s2(c5), R4(p9, m9);
    }
  }
  return R4(p9, m9);
}
function R4(e3, t3) {
  if (t3) for (const n7 in e3) e3[n7].label = t3[n7];
  return { count: e3 };
}
async function D(e3, t3, i7) {
  const o4 = e3 ? i7.getField(e3) : null, a6 = o4 ? i7.getFieldDomain(o4.name) : null;
  if (a6) return a6;
  const { uniqueValueInfos: r5 } = await i7.uniqueValues({ field: e3, sqlWhere: t3.sqlWhere, features: t3.features, useFeaturesInView: t3.useFeaturesInView, view: t3.view, signal: t3.signal }), s6 = r5.map((e4) => new p({ code: e4.value }));
  return new i2({ codedValues: s6 });
}
async function I(e3, t3) {
  if (!e3.returnAllCodedValues) return [];
  const { field: n7, field2: l6, field3: i7 } = e3;
  if (n7 && !l6) {
    const e4 = n7 ? t3.getField(n7) : null, l7 = e4 ? t3.getFieldDomain(e4.name) : null;
    return l7 ? [l7] : [];
  }
  const o4 = [];
  return n7 && (o4.push(D(n7, e3, t3)), l6 && (o4.push(D(l6, e3, t3)), i7 && o4.push(D(i7, e3, t3)))), Promise.all(o4);
}
function N2(e3, t3) {
  return C(e3, /* @__PURE__ */ new Date(0), t3, "milliseconds").sqlExpression;
}
function U3(e3, t3) {
  return `EXTRACT(${t3} FROM ${e3}) * ${E[t3]}`;
}
function M3(e3) {
  if (!e3) return null;
  return M(["HOUR", "MINUTE", "SECOND"].map((t3) => `(${U3(e3, t3)})`).join(" + "));
}
function B(e3) {
  return { viewingMode: "2d" === e3.type ? "map" : e3.viewingMode, scale: e3.scale, spatialReference: e3.spatialReference?.toJSON() };
}
function Q(e3, t3) {
  const n7 = new Set(e3.map((e4) => e4.value)), l6 = t3.filter((e4) => !n7.has(e4));
  for (const i7 of l6) e3.push({ value: i7, count: 0 });
  e3.sort((e4, n8) => t3.indexOf(e4.value) - t3.indexOf(n8.value));
  for (const i7 of e3) i7.value === e2 && (i7.value = null);
  return { predominantCategoryInfos: e3 };
}
function P3(t3) {
  const n7 = "featureReduction" in t3 ? t3.featureReduction : null;
  return ((null != n7 && "fields" in n7 ? n7.fields : null) ?? []).map((e3) => {
    const n8 = W(e3, t3.fieldsIndex);
    return n8 ? new m2({ type: n8, name: e3.name, alias: e3.alias }) : null;
  }).filter(L);
}
function W(e3, t3) {
  switch (e3.statisticType) {
    case "avg":
    case "avg_angle":
      return "double";
    case "count":
      return "integer";
    case "min":
    case "max":
    case "sum":
      return e3.onStatisticField ? t3.get(e3.onStatisticField)?.type ?? null : e3.onStatisticExpression ? "string" === e3.onStatisticExpression.returnType ? null : "double" : null;
    case "mode":
      return e3.onStatisticField ? t3.get(e3.onStatisticField)?.type ?? null : e3.onStatisticExpression ? "string" === e3.onStatisticExpression.returnType ? "string" : "double" : null;
    default:
      return null;
  }
}
function _(e3, t3) {
  return $(t3) ? N2(e3, t3?.name) : Te(t3) ? M3(t3?.name) : null;
}
function k(e3, t3, n7, l6 = true) {
  const { field: i7, normalizationType: a6, normalizationField: s6, normalizationTotal: f5, minValue: p9, maxValue: d6, filter: y } = t3, v2 = e3.supportsSQLExpression ? _(e3, n7) || t3.sqlExpression : null, h2 = j4({ field: i7, normalizationType: a6, normalizationField: s6, normalizationTotal: f5, layer: e3 }), F3 = v2 || h2, w2 = F3 ? N(F3, p9, d6) : null, E3 = F({ field: i7, normalizationField: s6, normalizationType: a6 }), S4 = U2(t3.sqlWhere, E3), T5 = U2(S4, w2), V3 = d2({ normalizationField: s6, normalizationType: a6, sqlExpression: v2, supportsSQLExpression: e3.supportsSQLExpression, minValue: p9, maxValue: d6 }), z3 = Fe(e3.getField(i7 ?? void 0)), { include: $5, exclude: C4 } = t3.outStatisticTypes || {}, q4 = c.filter((e4) => (!$5 || $5.includes(e4)) && (!C4 || !C4.includes(e4)) && ("nullcount" === e4 ? V3 : !z3 || "count" === e4) && ("median" !== e4 || l6)), b5 = e3.createQuery();
  return b5.where = U2(b5.where, T5), b5.sqlFormat = v2 ? "standard" : null, b5.outStatistics = q4.map((t4) => {
    const n8 = new p3();
    let l7 = null, i8 = null, o4 = `${t4}_value`;
    if ("variance" === t4) l7 = "var", i8 = F3;
    else if ("nullcount" === t4) {
      const t5 = e3.objectIdField;
      l7 = "count", i8 = t5 && e3.getField(t5) ? t5 : "1", o4 = "totalcount_value";
    } else "median" === t4 ? (l7 = "percentile-continuous", i8 = F3, n8.statisticParameters = { value: 0.5 }) : (l7 = t4, i8 = F3);
    return n8.statisticType = l7, n8.onStatisticField = i8, n8.outStatisticFieldName = o4, n8;
  }), A2(b5, y), b5;
}
function A2(e3, t3) {
  t3 && (e3.geometry = t3.geometry, e3.spatialRelationship = t3.spatialRelationship);
}
function H2(e3, t3) {
  const { field: n7, field2: l6, field3: i7, sqlExpression: o4 } = t3, a6 = !(!n7 || !l6), r5 = e3.createQuery();
  return r5.where = U2(r5.where, t3.sqlWhere), r5.sqlFormat = o4 ? "standard" : null, r5.outStatistics = [J(a6 ? null : n7, a6 ? "1" : o4)].filter(Boolean), r5.groupByFieldsForStatistics = [n7 || o4, l6, i7].filter(Boolean), A2(r5, t3.filter), r5;
}
function J(e3, t3) {
  const n7 = "countOF" + (e3 || "Expr"), l6 = new p3();
  return l6.statisticType = "count", l6.onStatisticField = t3 ? "1" : e3, l6.outStatisticFieldName = n7, l6;
}
function Z(e3, t3, n7, l6 = S, i7, o4, a6) {
  const { min: r5, max: s6, normTotal: u3, excludeZerosExpr: c5 } = t3, m9 = t3.intervals || j3(r5, s6, l6), f5 = t3.sqlExpr || n7;
  return G(e3, m9, f5, c5, i7, o4, a6).then((e4) => ({ bins: e4.map((e5, t4) => ({ minValue: m9[t4][0], maxValue: m9[t4][1], count: "fulfilled" === e5.status ? e5.value : 0 })), minValue: r5, maxValue: s6, normalizationTotal: u3 }));
}
function G(e3, t3, n7, l6, i7, o4, a6) {
  const r5 = [], s6 = t3.length;
  for (let u3 = 0; u3 < s6; u3++) {
    const e4 = U2(l6, U2(n7 + " >= " + t3[u3][0], null !== t3[u3][1] ? n7 + (u3 === s6 - 1 ? " <= " : " < ") + t3[u3][1] : ""));
    r5.push(e4);
  }
  return Promise.allSettled(r5.map((t4) => e3.queryFeatureCount({ whereClause: t4, view: i7, filter: o4, signal: a6 })));
}

// node_modules/@arcgis/core/smartMapping/support/adapters/support/histogramUtils.js
var V2 = "countOFExpr";
var j5 = "lowerBoundary";
var q3 = "upperBoundary";
function I2(i7, e3, t3) {
  const a6 = i7.valueExpression || i7.sqlExpression, r5 = i7.signal;
  if (!a6) {
    const { field: a7, normalizationType: o4, normalizationField: l6 } = i7, s6 = a7 ? e3.getField(a7) : null, u3 = $(s6) || Te(s6), m9 = { field: a7, normalizationType: o4, normalizationField: l6, normalizationTotal: t3, layer: e3 };
    return { sqlExpression: u3 ? _(e3, s6) : j4(m9), sqlWhere: u3 ? null : i7.sqlWhere || F({ field: a7, normalizationType: o4, normalizationField: l6 }), filter: i7.filter, signal: r5 };
  }
  return { valueExpression: i7.valueExpression, sqlExpression: i7.sqlExpression, sqlWhere: i7.sqlWhere, filter: i7.filter, signal: r5 };
}
async function M4(i7, e3, n7) {
  const { field: t3, normalizationType: a6, normalizationField: r5, signal: o4 } = i7, l6 = F({ field: t3, normalizationType: a6, normalizationField: r5 }), s6 = new t2({ classificationDefinition: q({ field: t3, normalizationType: a6, normalizationField: r5, classificationMethod: i7.classificationMethod, standardDeviationInterval: i7.standardDeviationInterval, definedInterval: i7.definedInterval, breakCount: i7.numBins || S }), where: U2(l6, n7) });
  return e3.generateRenderer(s6, o4).then((i8) => {
    const { normalizationTotal: n8, classBreaks: o5 } = i8;
    return C3({ field: t3, normalizationType: a6, normalizationField: r5, normalizationTotal: n8, classBreaks: o5, where: l6, layer: e3 });
  });
}
async function g3(e3, t3, a6, o4, d6) {
  const { field: p9, sqlExpression: f5, normalizationField: c5, classificationMethod: z3, normalizationType: v2 } = e3, w2 = p9 ? t3.getField(p9) : null, h2 = Te(w2), F3 = be(w2) || h2, B2 = e3.numBins || S;
  if (F3) {
    if (v2 || z3) throw new s(`${t3.adapterName}:not-supported`, "NormalizationType and classificationMethod are not supported for date-only and time-only fields");
    const e4 = (o4 - a6) / B2 / 1e3, n7 = e4 / 86400;
    return new m5({ field: p9, expression: f5, interval: { unit: h2 ? "seconds" : "days", value: Math.ceil(h2 ? e4 : n7) }, start: a6, end: o4 });
  }
  if ("defined-interval" === z3) return new m6({ field: p9, expression: f5, normalizationField: c5, normalizationTotal: d6, normalizationType: v2, interval: e3.definedInterval ?? Math.ceil((o4 - a6) / B2), start: v2 ? null : a6, end: v2 ? null : o4, normalizationMinValue: v2 ? a6 : null, normalizationMaxValue: v2 ? o4 : null });
  if ("manual" === z3) throw new s(`${t3.adapterName}:not-supported`, "Layer does not support manual classificationMethod");
  if ("natural-breaks" === z3 || "quantile" === z3 || "standard-deviation" === z3) {
    const n7 = j4({ field: p9, normalizationField: c5, normalizationTotal: d6, normalizationType: v2, layer: t3 }), r5 = null !== e3.minValue && null !== e3.maxValue ? N(n7, e3.minValue, e3.maxValue) : void 0, o5 = await M4(e3, t3, r5);
    if (!o5.intervals) throw new s(`${t3.adapterName}:invalid`, "Invalid intervals returned from generate renderer");
    const l6 = [a6, ...o5.intervals.map((i7) => i7[1])];
    return new n4({ field: v2 ? null : p9, expression: v2 ? n7 : f5, boundaries: l6 });
  }
  return new m4({ field: p9, normalizationField: c5, normalizationTotal: d6, normalizationType: v2, expression: f5, numBins: B2, start: v2 ? null : a6, end: v2 ? null : o4, normalizationMinValue: v2 ? a6 : null, normalizationMaxValue: v2 ? o4 : null });
}
function E2(i7, e3, n7, t3) {
  return null != n7 && null != t3 ? Promise.resolve({ min: n7, max: t3 }) : e3.summaryStatistics({ ...i7, outStatisticTypes: { include: ["min", "max"] } }).then((i8) => ({ min: i8.min, max: i8.max }));
}
async function b3(i7, n7, r5, l6) {
  const { field: s6, minValue: u3, maxValue: m9, filter: d6, view: f5 } = i7, y = s6 ? n7.getField(s6) : null, z3 = Ie(y) || we(y), v2 = I2(i7, n7, r5), { min: x, max: T5 } = await E2(v2, n7, u3, m9);
  if (null == x || null == T5) return { query: null, min: x, max: T5 };
  const h2 = new p3({ statisticType: "count", outStatisticFieldName: V2, onStatisticField: "1" }), F3 = U2(l6, v2.sqlWhere), B2 = "lowerBoundary", j7 = "upperBoundary", q4 = new R3({ binParameters: await g3(i7, n7, x, T5, r5), outStatistics: [h2], binOrder: i7.sortOrder, where: F3, lowerBoundaryAlias: B2, upperBoundaryAlias: j7, outTimeZone: f5?.timeZone && z3 ? P(f5.timeZone) : null });
  return A2(q4, d6), { query: q4, min: x, max: T5 };
}
function D2(i7, e3 = false) {
  if ("string" != typeof i7) return i7;
  return (e3 ? /* @__PURE__ */ new Date(`1970-01-01T${i7}Z`) : new Date(i7)).getTime();
}
function P4(i7, e3, t3) {
  const a6 = Te(e3);
  return { ...t3, bins: i7.features.map((i8) => ({ minValue: D2(i8.attributes[j5], a6), maxValue: D2(i8.attributes[q3], a6), count: i8.attributes[V2] })) };
}
function S2(i7, e3, n7) {
  const { valueExpression: t3, view: a6 } = i7, { featuresJSON: r5, graphics: o4, fieldInfos: l6 } = e3, s6 = { field: i7.field, valueExpression: t3, normalizationType: i7.normalizationType, normalizationField: i7.normalizationField, normalizationTotal: n7, minValue: i7.minValue, maxValue: i7.maxValue, standardDeviationInterval: i7.standardDeviationInterval, classificationMethod: i7.classificationMethod, numBins: i7.numBins };
  return t3 && a6 && (r5 || o4) && (s6.viewInfoParams = B(a6), s6.timeZone = a6.timeZone, s6.fieldInfos = l6), s6;
}

// node_modules/@arcgis/core/smartMapping/support/adapters/InMemoryLayerAdapter.js
var $4 = 5;
var G2 = null;
var R5 = class extends p7 {
  constructor() {
    super(...arguments), this._hasLocalSource = false, this.adapterName = "in-memory-layer-adapter";
  }
  destroy() {
    this.workerClient?.destroy();
  }
  async _waitForLayerViewUpdate(e3) {
    if (!e3) throw new s(`${this.adapterName}:insufficient-data`, "layerView is required to fetch the features");
    const t3 = new AbortController(), i7 = j(() => !e3.updating, t3.signal);
    await T(i7, 5e3, t3).catch((e4) => {
      throw i.getLogger(this).warn("LayerView is taking too long to update. Aborting fetch from layerView."), e4;
    });
  }
  async _fetchFeatureSetFromMemory(e3, t3, a6) {
    const i7 = this.layer;
    if (this._hasLocalSource && "queryFeatures" in i7) return i7.queryFeatures(e3);
    if (!t3) throw new s(`${this.adapterName}:insufficient-data`, "view is required to fetch the features from layerView");
    const s6 = await t3.whenLayerView(this.layer);
    return await this._waitForLayerViewUpdate(s6), s6.queryFeatures(e3, { signal: a6 });
  }
  async _fetchFeaturesFromMemory(e3, t3, a6, i7) {
    const s6 = this.layer, o4 = "json" === i7;
    if (this._hasLocalSource && "queryFeatures" in s6) {
      const e4 = await s6.queryFeatures(t3);
      return o4 ? T3(e4.features) : e4.features;
    }
    if (await this._waitForLayerViewUpdate(e3), o4 && "queryFeaturesJSON" in e3 && e3.queryFeaturesJSON) {
      const { features: r5 } = await e3.queryFeaturesJSON(t3, { signal: a6 });
      return r5;
    }
    if (!("queryFeatures" in e3)) throw new s(`${this.adapterName}:not-supported`, "'queryFeatures' is not supported on the layerView");
    const n7 = await e3.queryFeatures(t3, { signal: a6 });
    return o4 ? T3(n7.features) : n7.features;
  }
  _fetchFeaturesForStats(e3, t3) {
    return U({ field: e3.field, field2: e3.field2, field3: e3.field3, normalizationField: e3.normalizationField, valueExpression: e3.valueExpression }).then((r5) => this.getSampleFeatures({ sampleSize: -1, view: e3.view, returnGeometry: e3.returnGeometry, filter: e3.filter, requiredFields: r5, signal: e3.signal }, t3));
  }
  async _summaryStatsFromClientQuery(e3, t3) {
    const { view: r5, signal: a6 } = e3, i7 = k(this, e3, t3), s6 = await this._fetchFeatureSetFromMemory(i7, r5, a6), o4 = $3(s6, $(t3) || Te(t3));
    return C2(o4, e3.outStatisticTypes);
  }
  async _getNormalizationTotalFromMemory(e3, t3, a6) {
    const { featuresJSON: i7, graphics: s6, layerView: o4, query: n7 } = t3, l6 = { include: ["sum"] }, u3 = (!i7 && !s6 && o4 && "querySummaryStatistics" in o4 ? await o4.querySummaryStatistics(n7, { field: e3 }, { signal: a6 }) : i7 ? await this.workerClient.summaryStatistics({ field: e3, outStatisticTypes: l6 }, i7) : await d3({ attribute: { field: e3, outStatisticTypes: l6 }, features: s6 ?? [] })).sum;
    if (null == u3) throw new s(`${this.adapterName}:invalid`, "invalid normalizationTotal");
    return u3;
  }
  async _summaryStatsFromMemory(e3, t3) {
    const { view: r5, field: a6, valueExpression: i7, normalizationType: s6, signal: o4 } = e3, n7 = { field: a6, valueExpression: i7, normalizationType: s6, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, outStatisticTypes: e3.outStatisticTypes }, { featuresJSON: l6, graphics: u3, layerView: m9, query: y, fieldInfos: c5 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "querySummaryStatistics" });
    return i7 && r5 && (l6 || u3) && (n7.fieldType = t3?.type ? i3.toJSON(t3.type) : null, n7.viewInfoParams = B(r5), n7.timeZone = r5.timeZone, n7.fieldInfos = c5), "percent-of-total" === s6 && null == e3.normalizationTotal && (n7.normalizationTotal = await this._getNormalizationTotalFromMemory(a6, { featuresJSON: l6, graphics: u3, layerView: m9, query: y }, o4)), !l6 && !u3 && m9 && "querySummaryStatistics" in m9 ? m9.querySummaryStatistics(y, n7, { signal: o4 }) : l6 ? this.workerClient.summaryStatistics(n7, l6) : d3({ attribute: n7, features: u3 });
  }
  async _getFilteredFeatures(e3, t3) {
    let r5 = e3;
    const a6 = t3?.geometry;
    if ("intersects" === t3?.spatialRelationship && a6) {
      const t4 = await import("./intersectionOperator-NEDE4Z22.js");
      r5 = e3.filter(({ geometry: e4 }) => !(!e4 || !t4.execute(e4, a6)));
    }
    return e3.length && "declaredClass" in e3[0] && "esri.Graphic" === e3[0].declaredClass ? { graphics: r5 } : { featuresJSON: r5 };
  }
  async _processStatsFromMemoryParams(e3) {
    const { features: t3, filter: r5 } = e3;
    if (t3?.length) return this._getFilteredFeatures(t3, r5);
    const { view: a6, field: i7, field2: s6, field3: o4, normalizationField: n7, valueExpression: l6, layerViewFunc: u3, signal: m9 } = e3;
    let p9 = e3.returnGeometry;
    if (null == p9 && l6) {
      if (!G2) {
        const { arcadeUtils: e5 } = await e();
        G2 = e5;
      }
      const e4 = G2.hasGeometryOperations(l6);
      e4 && await G2.enableGeometryOperations(), p9 = e4;
    }
    let y = null, c5 = null, f5 = null, d6 = null, h2 = null;
    if (a6) try {
      const e4 = "subtype-sublayer" === this.layer.type ? this.layer.parent : this.layer;
      y = await a6.whenLayerView(e4), c5 = null != u3 && u3 in y && "function" == typeof y[u3];
    } catch {
      c5 = false;
    }
    if (c5) try {
      await this._waitForLayerViewUpdate(y);
      const e4 = await U({ field: i7, field2: s6, field3: o4, normalizationField: n7, valueExpression: l6 });
      z2(this, e4, y).length ? c5 = false : (f5 = this.layer.createQuery(), f5.outFields = e4, f5.returnGeometry = false, A2(f5, r5)), y.suspended && (c5 = false);
    } catch {
      c5 = false;
    }
    return c5 || (d6 = await this._fetchFeaturesForStats({ field: i7, field2: s6, field3: o4, valueExpression: l6, normalizationField: n7, returnGeometry: p9, filter: r5, view: a6, signal: m9 }, "json"), h2 = (await U({ valueExpression: l6 })).map((e4) => this.getField(e4)?.toJSON()).filter(Boolean)), { layerView: y, query: f5, featuresJSON: d6, fieldInfos: h2 };
  }
  async _uvFromClientQuery(e3, t3) {
    const { view: r5, signal: a6 } = e3, i7 = H2(this, e3), s6 = await this._fetchFeatureSetFromMemory(i7, r5, a6), o4 = await L2(s6, { layer: this, field: e3.field, field2: e3.field2, field3: e3.field3, fieldDelimiter: f2, view: e3.view, signal: e3.signal });
    return $2(o4, t3, e3.returnAllCodedValues, f2);
  }
  async _uvFromMemory(e3, t3) {
    const { view: r5, field: a6, valueExpression: i7, returnAllCodedValues: s6, signal: o4 } = e3, { featuresJSON: n7, graphics: l6, layerView: u3, query: m9, fieldInfos: p9 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryUniqueValues" }), y = { field: a6, field2: e3.field2, field3: e3.field3, fieldDelimiter: f2, valueExpression: i7, domains: t3, returnAllCodedValues: s6 };
    return i7 && r5 && (n7 || l6) && (y.viewInfoParams = B(r5), y.timeZone = r5.timeZone, y.fieldInfos = p9), !n7 && !l6 && u3 && "queryUniqueValues" in u3 ? u3.queryUniqueValues(m9, y, { signal: o4 }) : n7 ? this.workerClient.uniqueValues(y, n7) : p4({ attribute: y, features: l6 });
  }
  _histogramForField(e3) {
    let t3 = null;
    return t3 = null != e3.minValue && null != e3.maxValue ? Promise.resolve({ min: e3.minValue, max: e3.maxValue }) : this.summaryStatistics({ ...e3, outStatisticTypes: { include: ["min", "max", "count"] } }).then((e4) => {
      if (!e4.count) throw new s(`${this.adapterName}:insufficient-data`, "Either the layer has no features or none of the features have data for the field");
      return { min: e4.min, max: e4.max };
    }), t3.then((t4) => Z(this, { min: t4.min, max: t4.max }, e3.field, e3.numBins ?? void 0, e3.view, e3.filter, e3.signal));
  }
  async _histogramFromQueryAttributeBinsFromMemory(e3) {
    const { field: t3, normalizationType: r5, signal: a6 } = e3, i7 = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAttributeBins" }), { featuresJSON: s6, graphics: o4, layerView: n7, query: l6 } = i7, u3 = "percent-of-total" === r5 ? e3.normalizationTotal ?? await this._getNormalizationTotalFromMemory(t3, i7, a6) : void 0;
    if (!n7 || !("queryAttributeBins" in n7) || s6 || o4) {
      const t4 = S2(e3, i7, u3);
      return s6 ? this.workerClient.histogram(t4, s6) : v({ attribute: t4, features: o4 });
    }
    const { query: m9, min: p9, max: y } = await b3(e3, this, u3, l6?.where);
    if (!m9) return { bins: [], minValue: p9, maxValue: y, normalizationTotal: u3 };
    const c5 = await n7.queryAttributeBins(m9, { signal: a6 });
    return P4(c5, t3 ? this.getField(t3) : null, { minValue: p9, maxValue: y, normalizationTotal: u3 });
  }
  async _histogramFromMemory(e3) {
    const { field: t3, signal: r5 } = e3, a6 = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryHistogram" }), { featuresJSON: i7, graphics: s6, layerView: o4, query: n7 } = a6, l6 = "percent-of-total" === e3.normalizationType ? e3.normalizationTotal ?? await this._getNormalizationTotalFromMemory(t3, a6, r5) : void 0, u3 = S2(e3, a6, l6);
    return !i7 && !s6 && o4 && "queryHistogram" in o4 ? o4.queryHistogram(n7, u3, { signal: r5 }) : i7 ? this.workerClient.histogram(u3, i7) : v({ attribute: u3, features: s6 });
  }
  _classBreaksFromInterpolation(e3) {
    const { minValue: t3, maxValue: r5 } = e3, a6 = e3.numClasses || $4, i7 = [], s6 = (r5 - t3) / a6;
    for (let l6 = 0; l6 < a6; l6++) {
      const e4 = t3 + l6 * s6;
      i7.push({ minValue: e4, maxValue: e4 + s6 });
    }
    i7[a6 - 1].maxValue = r5;
    const o4 = { classBreaks: i7, normalizationTotal: e3.normalizationTotal }, n7 = P2(o4, e3.classificationMethod);
    return Promise.resolve(n7);
  }
  async _classBreaksFromMemory(e3) {
    const { view: t3, field: r5, valueExpression: a6, signal: i7 } = e3, { featuresJSON: s6, graphics: o4, layerView: n7, query: l6, fieldInfos: u3 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryClassBreaks" }), m9 = { field: r5, valueExpression: a6, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numClasses: e3.numClasses };
    return a6 && t3 && (s6 || o4) && (m9.viewInfoParams = B(t3), m9.timeZone = t3.timeZone, m9.fieldInfos = u3), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (m9.normalizationTotal = await this._getNormalizationTotalFromMemory(r5, { featuresJSON: s6, graphics: o4, layerView: n7, query: l6 }, i7)), !s6 && !o4 && n7 && "queryClassBreaks" in n7 ? n7.queryClassBreaks(l6, m9, { signal: i7 }) : s6 ? this.workerClient.classBreaks(m9, s6) : c2({ attribute: m9, features: o4 });
  }
  async _heatmapStatsFromMemory(e3) {
    const { view: t3, field: r5, radius: a6, signal: s6 } = e3;
    n(t3, "InMemoryLayerAdapter: must have a view");
    try {
      const r6 = await t3.whenLayerView(this.layer);
      if ("queryHeatmapStatistics" in r6 && !r6.updating && !e3.filter) return await r6.queryHeatmapStatistics({ field: e3.field, radius: e3.radius });
    } catch {
      s2(s6);
    }
    const { featuresJSON: n7, graphics: l6 } = await this._processStatsFromMemoryParams({ ...e3, returnGeometry: true }), u3 = new a2({ extent: t3.extent, tolerance: "2d" === t3.type ? t3.state.resolution : t3.pixelSizeAt?.(t3.center) }), p9 = { field: r5, radius: a6, transform: s3(u3), spatialReference: t3.spatialReference?.toJSON(), size: t3.size };
    return n7?.length || l6?.length ? n7 ? this.workerClient.heatmapStatistics(p9, n7) : z({ attribute: p9, features: l6 }) : { min: null, max: null };
  }
  getField(e3 = "") {
    return this.layer.getField(e3);
  }
  getFieldUsageInfo(e3) {
    return this.getField(e3) ? { supportsLabelingInfo: true, supportsRenderer: true, supportsPopupTemplate: true, supportsLayerQuery: true, supportsStatistics: true } : null;
  }
  getFieldDomain(e3, t3) {
    return this.layer.getFieldDomain(e3, t3);
  }
  createQuery() {
    return this.layer.createQuery();
  }
  async summaryStatistics(e3) {
    const { field: t3, valueExpression: a6, sqlExpression: i7, features: s6, view: o4 } = e3, n7 = t3 ? this.getField(t3) : null, l6 = !!a6, u3 = "3d" === o4?.type;
    if (!a6 && i7 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return l6 || s6 || u3 ? this._summaryStatsFromMemory(e3, n7) : this._summaryStatsFromClientQuery(e3, n7);
  }
  async uniqueValues(e3) {
    const { valueExpression: t3, sqlExpression: a6, features: i7, view: s6 } = e3, o4 = await I(e3, this), n7 = !!t3, l6 = "3d" === s6?.type;
    if (!t3 && a6 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return n7 || i7 || l6 ? this._uvFromMemory(e3, o4) : this._uvFromClientQuery(e3, o4);
  }
  async histogram(e3) {
    const { features: t3, valueExpression: a6, normalizationType: i7, sqlExpression: s6 } = e3, o4 = t3 || !!a6;
    if (!a6 && s6 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return o4 || i7 ? this._histogramFromMemory(e3) : this._histogramForField(e3);
  }
  async classBreaks(e3) {
    return false !== e3.analyzeData ? this._classBreaksFromMemory(e3) : this._classBreaksFromInterpolation(e3);
  }
  async queryFeatureCount(e3) {
    const { whereClause: t3, view: a6, signal: i7 } = e3;
    if (!a6) throw new s(`${this.adapterName}:insufficient-data`, "view is required to fetch the features from layerView");
    const s6 = this.layer.createQuery();
    s6.where = U2(s6.where, t3);
    const o4 = await a6.whenLayerView(this.layer);
    return await j(() => !o4.updating, i7), o4.queryFeatureCount(s6, { signal: i7 });
  }
  async generateRenderer(e3, t3) {
    throw new s(`${this.adapterName}:not-supported`, "Layer does not support generateRenderer operation");
  }
  async predominantCategories(e3) {
    const { fields: t3, view: r5, signal: a6, filter: i7 } = e3, s6 = s5(t3), o4 = await this._uvFromMemory({ valueExpression: s6, view: r5, signal: a6, filter: i7 });
    return Q(o4.uniqueValueInfos, t3);
  }
  async heatmapStatistics(e3) {
    return this._heatmapStatsFromMemory(e3);
  }
  async getSampleFeatures(e3, a6) {
    const { view: i7, sampleSize: s6, requiredFields: o4, returnGeometry: n7, filter: l6, signal: u3 } = e3, m9 = this.layer.createQuery(), p9 = 1;
    if (m9.outSpatialReference = i7?.spatialReference, m9.returnGeometry = !!n7, m9.outFields = o4, A2(m9, l6), !i7) throw new s(`${this.adapterName}:not-supported`, "view is required to get sample features for Layer");
    const y = await i7.whenLayerView(this.layer);
    if (z2(this, o4, y).length) throw new s(`${this.adapterName}:not-supported`, "Required fields need to be passed in the outFields for Layer");
    const c5 = await this._fetchFeaturesFromMemory(y, m9, u3, a6), f5 = null != s6 && s6 > 0 && s6 <= c5.length ? s6 : c5.length;
    return A(c5, f5, p9);
  }
  load(e3) {
    const t3 = this.layer.load(e3).then(async (t4) => {
      this.geometryType = t4.geometryType, this.objectIdField = t4.objectIdField, this.supportsSQLExpression = "stream" === t4.type || !!t4.capabilities?.query?.supportsSqlExpression, this.minScale = t4.minScale, this.maxScale = t4.maxScale, this.fullExtent = "fullExtent" in t4 ? t4.fullExtent : t4.parent?.fullExtent, this._hasLocalSource = false, this.hasQueryEngine = true, this.workerClient = n5.getInstance(), await this.workerClient.open(e3.signal);
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
r([m({ readOnly: true })], R5.prototype, "adapterName", void 0), r([m({ constructOnly: true })], R5.prototype, "layer", void 0), R5 = r([a("esri.smartMapping.support.adapters.InMemoryLayerAdapter")], R5);

// node_modules/@arcgis/core/smartMapping/support/adapters/FeatureLayerAdapter.js
var J2 = 5;
var W2 = 2e4;
var H3 = 4e5;
var Z2 = class extends R5 {
  constructor() {
    super(...arguments), this.adapterName = "feature-layer-adapter";
  }
  _isStatsSupportedOnService() {
    const e3 = this.layer;
    if (!e3.capabilities?.query?.supportsStatistics || "multipatch" === this.geometryType && !g(e3.url) && e3.version < 10.5) throw new s(`${this.adapterName}:not-supported`, "Layer does not support statistics query");
    return Promise.resolve();
  }
  _fetchFeaturesFromService(e3, t3) {
    return this.layer.queryFeatures(e3, { signal: t3 }).then((e4) => e4.features);
  }
  _fetchFeaturesJSONFromService(e3, t3) {
    return this._fetchFeaturesFromService(e3, t3).then(T3);
  }
  _summaryStatsFromGenRend(e3) {
    const t3 = e3.normalizationType, r5 = e3.normalizationField;
    return this.classBreaks({ field: e3.field, numClasses: J2, classificationMethod: "standard-deviation", standardDeviationInterval: 0.25, normalizationType: t3, normalizationField: "field" === t3 ? r5 : void 0, minValue: e3.minValue, maxValue: e3.maxValue, filter: e3.filter, signal: e3.signal }).then((t4) => {
      let r6, i7, s6;
      if (t4.classBreakInfos?.some((e4) => (e4.hasAvg && (r6 = e4), !!r6)), r6) {
        const e4 = r6.maxValue - r6.minValue;
        i7 = r6.minValue + e4 / 2, s6 = 4 * e4;
      }
      const a6 = { min: t4.minValue, max: t4.maxValue, avg: i7, stddev: s6 };
      return C2(a6, e3.outStatisticTypes);
    });
  }
  async _summaryStatsFromServiceQuery(e3, t3) {
    await this._isStatsSupportedOnService(), "percent-of-total" === e3.normalizationType && (e3.normalizationTotal = await this._getNormalizationTotal(e3.field, e3.normalizationType, e3.filter));
    const r5 = $(t3) || Te(t3), i7 = "capabilities" in this.layer ? this.layer.capabilities : null, s6 = k(this, e3, t3, i7?.query?.supportsPercentileStatistics ?? false), a6 = await this.layer.queryFeatures(s6, { signal: e3.signal }), o4 = $3(a6, r5);
    return C2(o4, e3.outStatisticTypes);
  }
  _uvFromGenRenderer(e3, t3) {
    const r5 = e3.field ?? void 0, i7 = new s4({ attributeField: r5 }), s6 = new t2({ classificationDefinition: i7 });
    return this.generateRenderer(s6, e3.signal).then((e4) => {
      const t4 = {}, i8 = this.getField(r5);
      return e4.uniqueValues.forEach((e5) => {
        let r6 = e5.value;
        null != r6 && "" !== r6 && ("string" != typeof r6 || "" !== r6.trim() && "<null>" !== r6.toLowerCase()) || (r6 = null), null == t4[r6] ? t4[r6] = { count: e5.count, data: ge(i8) && r6 ? Number(r6) : r6 } : t4[r6].count = t4[r6].count + e5.count;
      }), { count: t4 };
    }).then((r6) => $2(r6, [t3], e3.returnAllCodedValues));
  }
  async _uvFromServiceQuery(e3, t3) {
    return this._isStatsSupportedOnService().then(() => this.layer.queryFeatures(H2(this, e3), { signal: e3.signal })).then((t4) => L2(t4, { layer: this, field: e3.field, field2: e3.field2, field3: e3.field3, fieldDelimiter: f2, view: e3.view, signal: e3.signal })).then((r5) => $2(r5, t3, e3.returnAllCodedValues, f2));
  }
  _getNormalizationTotal(e3, t3, r5, i7) {
    return e3 && "percent-of-total" === t3 ? this.summaryStatistics({ field: e3, outStatisticTypes: { include: ["sum"] }, filter: r5, signal: i7 }).then((e4) => e4.sum) : Promise.resolve(null);
  }
  _histogramForExpr(e3) {
    return this._getNormalizationTotal(e3.field, e3.normalizationType, e3.filter, e3.signal).then((t3) => {
      const r5 = I2(e3, this, t3);
      return E2(r5, this, e3.minValue, e3.maxValue).then((i7) => {
        const s6 = i7.min, a6 = i7.max;
        if (null == s6 || null == a6) return { bins: [], minValue: s6, maxValue: a6, normalizationTotal: t3 };
        const o4 = e3.numBins || S, n7 = j3(s6, a6, o4), l6 = K(r5.sqlExpression, n7, null != e3.minValue && null != e3.maxValue), u3 = new p3({ statisticType: "count", outStatisticFieldName: "countOFExpr", onStatisticField: "1" }), m9 = this.layer.createQuery();
        return m9.where = U2(m9.where, r5.sqlWhere), m9.sqlFormat = "standard", m9.outStatistics = [u3], m9.groupByFieldsForStatistics = [l6], m9.orderByFields = [l6], A2(m9, e3.filter), this._isStatsSupportedOnService().then(() => this.layer.queryFeatures(m9, { signal: r5.signal })).then((e4) => O(e4, s6, a6, o4, t3));
      });
    });
  }
  async _histogramFromQueryAttributeBins(e3) {
    const { field: t3, normalizationType: r5, filter: i7, signal: s6 } = e3, a6 = await this._getNormalizationTotal(t3, r5, i7, s6), o4 = this.layer.createQuery(), { query: n7, min: l6, max: u3 } = await b3(e3, this, a6, o4?.where);
    if (!n7) return { bins: [], minValue: l6, maxValue: u3, normalizationTotal: a6 };
    const m9 = await this.layer.queryAttributeBins(n7, { signal: s6 });
    return P4(m9, t3 ? this.getField(t3) : null, { minValue: l6, maxValue: u3, normalizationTotal: a6 });
  }
  _classBreaksFromGenRend(e3) {
    const { field: t3, normalizationType: r5, normalizationField: i7, normalizationTotal: s6, signal: a6 } = e3, o4 = F({ field: t3, normalizationType: r5, normalizationField: i7 }), n7 = j4({ field: t3, normalizationType: r5, normalizationField: i7, normalizationTotal: s6, layer: this }), l6 = N(n7, e3.minValue, e3.maxValue), u3 = q({ field: t3, normalizationType: r5, normalizationField: i7, classificationMethod: e3.classificationMethod, standardDeviationInterval: e3.standardDeviationInterval, breakCount: e3.numClasses || J2 }), m9 = new t2({ classificationDefinition: u3 });
    return m9.where = U2(o4, l6), this.generateRenderer(m9, a6).then((t4) => P2(t4, e3.classificationMethod));
  }
  async summaryStatistics(e3) {
    const { field: t3, normalizationType: r5, valueExpression: a6, sqlExpression: o4, view: n7, features: u3, useFeaturesInView: m9 } = e3, c5 = t3 ? this.getField(t3) : null, p9 = $(c5) || Te(c5), h2 = a6 && !(o4 && this.supportsSQLExpression), d6 = this._hasLocalSource || u3 || m9, y = n7 && "3d" === n7.type;
    if (d6 || h2) return h2 || u3 || m9 || y ? this._summaryStatsFromMemory(e3, c5) : this._summaryStatsFromClientQuery(e3, c5);
    if (!this.supportsSQLExpression && (p9 || o4 || "natural-log" === r5 || "square-root" === r5)) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return (r5 && !this.supportsSQLExpression ? this._summaryStatsFromGenRend(e3) : this._summaryStatsFromServiceQuery(e3, c5)).catch(() => (s2(e3.signal), this._summaryStatsFromMemory(e3, c5)));
  }
  async uniqueValues(e3) {
    const { valueExpression: t3, sqlExpression: r5, features: i7, useFeaturesInView: a6, signal: o4 } = e3, n7 = t3 && !(r5 && this.supportsSQLExpression), l6 = this._hasLocalSource || i7 || a6 || n7, u3 = e3.view, m9 = u3 && "3d" === u3.type, c5 = await I(e3, this);
    return l6 ? n7 || i7 || a6 || m9 ? this._uvFromMemory(e3, c5) : this._uvFromClientQuery(e3, c5) : this._uvFromServiceQuery(e3, c5).catch((t4) => (s2(o4), !e3.field || e3.field2 || e3.field3 || e3.filter ? t4 : this._uvFromGenRenderer(e3, c5[0]))).catch(() => (s2(o4), m9 ? this._uvFromMemory(e3, c5) : this._uvFromClientQuery(e3, c5)));
  }
  async histogram(e3) {
    const { field: t3, normalizationType: r5, normalizationField: a6, classificationMethod: o4, view: n7, filter: u3, signal: m9 } = e3, c5 = t3 ? this.getField(t3) : null, p9 = $(c5) || Te(c5), h2 = e3.valueExpression || e3.sqlExpression, d6 = e3.valueExpression && !(e3.sqlExpression && this.supportsSQLExpression), y = this._hasLocalSource || e3.features || e3.useFeaturesInView || d6, f5 = this.supportsSQLExpression, S4 = !o4 || "equal-interval" === o4, g5 = e3.minValue, v2 = e3.maxValue, x = null != g5 && null != v2, _2 = e3.numBins || S;
    if (y) return this._histogramFromMemory(e3);
    if (this.layer.capabilities?.operations?.supportsQueryBins && e3.useQueryAttributeBins) try {
      return await this._histogramFromQueryAttributeBins(e3);
    } catch {
      return s2(m9), this._histogramFromQueryAttributeBinsFromMemory(e3);
    }
    if ((h2 || f5) && S4) {
      if (!f5 && (h2 || "natural-log" === r5 || "square-root" === r5)) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
      return this._histogramForExpr(e3);
    }
    if (p9 && S4) throw new s(`${this.adapterName}:not-supported`, "Normalization and date field are not allowed when layer does not support standardized SQL expression for queries");
    return r5 || !S4 ? M4(e3, this).then((s6) => {
      if (!x) return Z(this, s6, t3, _2, n7, u3, m9);
      if (g5 > s6.max || v2 < s6.min) throw new s(`${this.adapterName}:insufficient-data`, "Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");
      if (S4) return Z(this, { min: g5, max: v2, sqlExpr: s6.sqlExpr, excludeZerosExpr: s6.excludeZerosExpr }, t3, _2, n7, u3, m9);
      {
        const i7 = { field: t3, normalizationType: r5, normalizationField: a6, normalizationTotal: s6.normTotal, layer: this }, o5 = j4(i7), l6 = N(o5, g5, v2);
        return M4(e3, this, l6).then((e4) => Z(this, e4, t3, _2, n7, u3, m9));
      }
    }) : this._histogramForField(e3);
  }
  async classBreaks(e3) {
    const t3 = false !== e3.analyzeData, r5 = this._hasLocalSource || e3.features || e3.useFeaturesInView || e3.valueExpression || e3.filter;
    if (t3 && r5) return this._classBreaksFromMemory(e3);
    return (t3 ? this._classBreaksFromGenRend(e3) : this._classBreaksFromInterpolation(e3)).catch(() => (s2(e3.signal), this._classBreaksFromMemory(e3)));
  }
  async queryFeatureCount(e3) {
    if (this._hasLocalSource) throw new s(`${this.adapterName}:not-supported`, "Layer does not support count query");
    const t3 = this.layer, r5 = t3.createQuery();
    return r5.where = U2(r5.where, e3.whereClause), A2(r5, e3.filter), t3.queryFeatureCount(r5, { signal: e3.signal });
  }
  async generateRenderer(e3, t3) {
    const r5 = this.layer;
    if (this._hasLocalSource || r5.version < 10.1) throw new s(`${this.adapterName}:not-supported`, "Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)");
    const s6 = r5.createQuery();
    return e3.where = U2(e3.where, s6.where), l4(r5.parsedUrl?.path ?? "", { source: r5.dynamicDataSource ?? void 0, gdbVersion: r5.gdbVersion ?? void 0 }, e3, { signal: t3 });
  }
  async predominantCategories(e3) {
    if (!this._hasLocalSource && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support advanced SQL expressions and standardized queries");
    const { fields: t3, view: r5, signal: s6, filter: a6 } = e3, o4 = s5(t3), n7 = u(t3), l6 = r5 && this._hasLocalSource ? await this._uvFromMemory({ valueExpression: o4, view: r5, signal: s6, filter: a6 }) : await this._uvFromServiceQuery({ sqlExpression: n7.expression, valueExpression: o4, signal: s6, filter: a6 });
    return Q(l6.uniqueValueInfos, t3);
  }
  async getSampleFeatures(e3, i7) {
    const { view: a6, requiredFields: o4, returnGeometry: n7, filter: l6, signal: u3 } = e3, m9 = e3.sampleSize;
    if (null == m9 || 0 === m9) return [];
    const c5 = this.layer.createQuery(), p9 = 1, h2 = "json" === i7;
    c5.outSpatialReference = a6?.spatialReference, c5.returnGeometry = !!n7, c5.outFields = o4, A2(c5, l6);
    let d6 = [], y = false;
    if (a6) try {
      const s6 = await a6.whenLayerView(this.layer);
      if (y = !z2(this, o4, s6).length, y) {
        if (m9 >= 1 && !e3.filter && "getSampleFeatures" in s6) {
          await this._waitForLayerViewUpdate(s6);
          const e4 = await s6.getSampleFeatures({ minFeatureCount: m9, sampleSize: m9 });
          if (null != e4) return h2 ? e4 : e4.map((e5) => d.fromJSON(e5));
        }
        if (d6 = await this._fetchFeaturesFromMemory(s6, c5, u3, i7), d6.length >= m9 && m9 > 0) return A(d6, m9, p9);
      }
    } catch (f5) {
      s2(u3);
    }
    try {
      if (this._hasLocalSource) return y ? d6 : h2 ? await this._fetchFeaturesJSONFromService(c5, u3) : await this._fetchFeaturesFromService(c5, u3);
      const t3 = await this.queryFeatureCount({ view: a6, filter: l6, signal: u3 }), i8 = this.layer.capabilities.query.maxRecordCount;
      let s6 = -1 === m9 ? t3 : m9;
      if (s6 = i8 && s6 > i8 ? i8 : s6, t3 <= d6.length || d6.length >= i8) return d6;
      if (c5.maxAllowableOffset = e3.resolution || (a6 ? a6.extent.width / a6.width / a6.scale : at(this.layer.spatialReference)) * H3, t3 <= s6) return h2 ? await this._fetchFeaturesJSONFromService(c5, u3) : await this._fetchFeaturesFromService(c5, u3);
      if (t3 <= W2) {
        const e4 = this.layer.createQuery();
        A2(e4, l6);
        const t4 = await this.layer.queryObjectIds();
        return c5.objectIds = A(t4, s6, p9), h2 ? await this._fetchFeaturesJSONFromService(c5, u3) : await this._fetchFeaturesFromService(c5, u3);
      }
      return this.layer.capabilities?.query?.supportsPagination && (c5.num = Math.min(s6, W2)), h2 ? await this._fetchFeaturesJSONFromService(c5, u3) : await this._fetchFeaturesFromService(c5, u3);
    } catch (f5) {
      return s2(u3), d6;
    }
  }
  load(e3) {
    const t3 = this.layer.load(e3).then(async (t4) => {
      this.geometryType = t4.geometryType, this.objectIdField = t4.objectIdField, this.supportsSQLExpression = t4.capabilities?.query?.supportsSqlExpression, this._hasLocalSource = !t4.url && !!t4.source, this.hasQueryEngine = this._hasLocalSource, this.minScale = t4.minScale, this.maxScale = t4.maxScale, this.fullExtent = t4.fullExtent, this.workerClient = n5.getInstance(), await this.workerClient.open(e3.signal);
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
function K(e3, t3, r5) {
  const i7 = [], s6 = t3.length;
  return t3.forEach((t4, a6) => {
    const [o4, n7] = t4;
    let l6 = null;
    l6 = 0 !== a6 || r5 ? a6 !== s6 - 1 || r5 ? U2(`${e3} >= ${o4}`, `${e3} ${a6 === s6 - 1 ? " <= " : " < "} ${n7}`) : `${e3} >= ${o4}` : `${e3} < ${n7}`, i7.push("WHEN (" + l6 + ") THEN " + (a6 + 1));
  }), ["CASE", i7.join(" "), "ELSE 0", "END"].join(" ");
}
r([m({ readOnly: true })], Z2.prototype, "adapterName", void 0), r([m({ constructOnly: true })], Z2.prototype, "layer", void 0), Z2 = r([a("esri.smartMapping.support.adapters.FeatureLayerAdapter")], Z2);

// node_modules/@arcgis/core/smartMapping/support/adapters/CSVLayerAdapter.js
var m8 = class extends Z2 {
  constructor() {
    super(...arguments), this.adapterName = "csv-layer-adapter";
  }
  async _createGenerateRendererResult(e3, r5, i7, n7, l6) {
    const p9 = e3?.features, c5 = p9?.length;
    if (!c5) throw new s("csv-layer-adapter:insufficient-data", "No features are available to calculate statistics");
    const m9 = T3(p9);
    let d6 = null;
    if ("percent-of-total" === n7) {
      if (d6 = (await this.workerClient.summaryStatistics({ field: r5 }, m9)).sum, null == d6) throw new s("csv-layer-adapter:invalid", "invalid normalizationTotal");
    }
    if ("class-breaks-definition" === l6?.type) {
      const e4 = (await b({ field: r5, normalizationType: n7, normalizationField: i7, normalizationTotal: d6 }, m9)).filter((e5) => Number.isFinite(e5));
      return a4({ definition: l6, values: e4, normalizationTotal: d6 });
    }
    const f5 = (await b({ field: r5 }, m9)).filter((e4) => null != e4 && "string" == typeof e4 && "" !== e4.trim());
    return n2(f5);
  }
  generateRenderer(e3, t3) {
    const r5 = e3.classificationDefinition;
    let i7 = null, s6 = null, o4 = null;
    "class-breaks-definition" === r5?.type ? (i7 = r5.classificationField, s6 = r5.normalizationField, o4 = r5.normalizationType) : i7 = r5?.attributeField;
    const a6 = this.layer;
    return U({ field: i7, normalizationField: s6 }).then((l6) => {
      const p9 = a6.createQuery();
      return p9.returnGeometry = false, p9.outFields = l6, p9.where = U2(p9.where, e3.where), a6.queryFeatures(p9, { signal: t3 }).then((e4) => this._createGenerateRendererResult(e4, i7, s6, o4, r5));
    });
  }
  load(e3) {
    const t3 = this.layer.load(e3).then(async (t4) => {
      this.geometryType = t4.geometryType, this.objectIdField = t4.objectIdField, this.supportsSQLExpression = true, this._hasLocalSource = false, this.hasQueryEngine = true, this.workerClient = n5.getInstance(), await this.workerClient.open(e3.signal);
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
r([m({ readOnly: true })], m8.prototype, "adapterName", void 0), m8 = r([a("esri.smartMapping.support.adapters.CSVLayerAdapter")], m8);

// node_modules/@arcgis/core/smartMapping/support/adapters/FeatureLayerBinningAdapter.js
var N3 = class extends Z2 {
  constructor() {
    super(...arguments), this.adapterName = "feature-layer-binning-adapter";
  }
  async _getNormalizationTotalFromMemory(e3, t3, r5) {
    const { featuresJSON: i7, graphics: s6, layerView: o4, query: n7 } = t3, l6 = { include: ["sum"] }, m9 = (!i7 && !s6 && o4 && "queryAggregateSummaryStatistics" in o4 ? await o4.queryAggregateSummaryStatistics(n7, { field: e3, outStatisticTypes: l6 }, { signal: r5 }) : i7 ? await this.workerClient.summaryStatistics({ field: e3 }, i7) : await d3({ attribute: { field: e3, outStatisticTypes: l6 }, features: s6 })).sum;
    if (null == m9) throw new s(`${this.adapterName}:invalid`, "invalid normalizationTotal");
    return m9;
  }
  async _processStatsFromMemoryParams(e3) {
    const { features: t3, filter: r5 } = e3;
    if (t3?.length) return this._getFilteredFeatures(t3, r5);
    const { view: i7, field: s6, field2: o4, field3: n7, normalizationField: l6, valueExpression: u3, returnGeometry: m9, layerViewFunc: p9, signal: g5 } = e3;
    let d6 = null, y = null, f5 = null, h2 = null, w2 = null;
    if (i7) try {
      if (d6 = await i7.whenLayerView(this.layer), y = null != p9 && p9 in d6 && "function" == typeof d6[p9], y) {
        await this._waitForLayerViewUpdate(d6);
        const e4 = await U({ field: s6, field2: o4, field3: n7, normalizationField: l6, valueExpression: u3 });
        V(this, e4).length ? y = false : (f5 = "createAggregateQuery" in d6 ? d6.createAggregateQuery() : null, f5 ? (f5.outFields = e4, f5.returnGeometry = false, A2(f5, r5)) : y = false), d6.suspended && (y = false);
      }
    } catch {
      y = false;
    }
    if (!y && (w2 = P3(this.layer).map((e4) => e4.toJSON()), h2 = await this._fetchFeaturesForStats({ field: s6, field2: o4, field3: n7, valueExpression: u3, normalizationField: l6, returnGeometry: m9, filter: r5, view: i7, signal: g5 }, "json"), !h2?.length)) throw new s(`${this.adapterName}:insufficient-data`, "No features are available to calculate statistics");
    return { layerView: d6, query: f5, featuresJSON: h2, fieldInfos: w2 };
  }
  async _summaryStatsFromMemory(e3, t3) {
    const { view: a6, field: r5, valueExpression: i7, normalizationType: s6, signal: n7 } = e3, l6 = { field: r5, valueExpression: i7, normalizationType: s6, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, outStatisticTypes: e3.outStatisticTypes }, { featuresJSON: m9, graphics: p9, layerView: g5, query: d6, fieldInfos: y } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAggregateSummaryStatistics" });
    return i7 && a6 && (m9 || p9) && (l6.fieldType = t3?.type ? i3.toJSON(t3.type) : null, l6.viewInfoParams = B(a6), l6.timeZone = a6.timeZone, l6.fieldInfos = y), "percent-of-total" === s6 && null == e3.normalizationTotal && (l6.normalizationTotal = await this._getNormalizationTotalFromMemory(r5, { featuresJSON: m9, graphics: p9, layerView: g5, query: d6 }, n7)), !m9 && !p9 && g5 && "queryAggregateSummaryStatistics" in g5 ? g5.queryAggregateSummaryStatistics(d6, l6, { signal: n7 }) : m9 ? this.workerClient.summaryStatistics(l6, m9) : d3({ attribute: l6, features: p9 });
  }
  async _uvFromMemory(e3, t3) {
    const { view: a6, field: r5, valueExpression: i7, returnAllCodedValues: s6, signal: o4 } = e3, { featuresJSON: n7, graphics: l6, layerView: u3, query: p9, fieldInfos: g5 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAggregateUniqueValues" }), d6 = { field: r5, field2: e3.field2, field3: e3.field3, fieldDelimiter: f2, valueExpression: i7, domains: t3, returnAllCodedValues: s6 };
    return i7 && a6 && (n7 || l6) && (d6.viewInfoParams = B(a6), d6.timeZone = a6.timeZone, d6.fieldInfos = g5), !n7 && !l6 && u3 && "queryAggregateUniqueValues" in u3 ? u3.queryAggregateUniqueValues(p9, d6, { signal: o4 }) : n7 ? this.workerClient.uniqueValues(d6, n7) : p4({ attribute: d6, features: l6 });
  }
  async _histogramFromMemory(e3) {
    const { view: t3, field: a6, valueExpression: r5, signal: i7 } = e3, { featuresJSON: s6, graphics: o4, layerView: n7, query: l6, fieldInfos: u3 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAggregateHistogram" }), m9 = { field: a6, valueExpression: r5, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numBins: e3.numBins };
    return r5 && t3 && (s6 || o4) && (m9.viewInfoParams = B(t3), m9.timeZone = t3.timeZone, m9.fieldInfos = u3), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (m9.normalizationTotal = await this._getNormalizationTotalFromMemory(a6, { featuresJSON: s6, graphics: o4, layerView: n7, query: l6 }, i7)), !s6 && !o4 && n7 && "queryAggregateHistogram" in n7 ? n7.queryAggregateHistogram(l6, m9, { signal: i7 }) : s6 ? this.workerClient.histogram(m9, s6) : v({ attribute: m9, features: o4 });
  }
  async _classBreaksFromMemory(e3) {
    const { view: t3, field: a6, valueExpression: r5, signal: i7 } = e3, { featuresJSON: s6, graphics: o4, layerView: n7, query: l6, fieldInfos: u3 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAggregateClassBreaks" }), m9 = { field: a6, valueExpression: r5, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numClasses: e3.numClasses };
    return r5 && t3 && (s6 || o4) && (m9.viewInfoParams = B(t3), m9.timeZone = t3.timeZone, m9.fieldInfos = u3), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (m9.normalizationTotal = await this._getNormalizationTotalFromMemory(a6, { featuresJSON: s6, graphics: o4, layerView: n7, query: l6 }, i7)), !s6 && !o4 && n7 && "queryAggregateClassBreaks" in n7 ? n7.queryAggregateClassBreaks(l6, m9, { signal: i7 }) : s6 ? this.workerClient.classBreaks(m9, s6) : c2({ attribute: m9, features: o4 });
  }
  getField(e3 = "") {
    const t3 = P3(this.layer);
    return t3?.find((t4) => t4.name.toLowerCase() === e3?.toLowerCase());
  }
  getFieldUsageInfo(e3) {
    return this.getField(e3) ? { supportsLabelingInfo: true, supportsRenderer: true, supportsPopupTemplate: true, supportsLayerQuery: false, supportsStatistics: true } : null;
  }
  getFieldDomain(e3, t3) {
    return null;
  }
  async summaryStatistics(e3) {
    const { field: t3 } = e3, r5 = t3 ? this.getField(t3) : null, i7 = $(r5) || Te(r5), s6 = e3.sqlExpression && !e3.valueExpression && !t3;
    if (i7 || s6) throw new s(`${this.adapterName}:not-supported`, "Date field and sqlExpression are not supported");
    return this._summaryStatsFromMemory(e3, r5);
  }
  async uniqueValues(e3) {
    const t3 = await I(e3, this);
    return this._uvFromMemory(e3, t3);
  }
  async histogram(e3) {
    const { field: t3 } = e3, r5 = t3 ? this.getField(t3) : null, i7 = $(r5) || Te(r5), s6 = e3.sqlExpression && !e3.valueExpression && !t3;
    if (i7 || s6) throw new s(`${this.adapterName}:not-supported`, "Date field and sqlExpression are not supported");
    return this._histogramFromMemory(e3);
  }
  async classBreaks(e3) {
    return (false !== e3.analyzeData ? this._classBreaksFromMemory(e3) : this._classBreaksFromInterpolation(e3)).catch(() => (s2(e3.signal), this._classBreaksFromMemory(e3)));
  }
  async queryFeatureCount(e3) {
    const t3 = await e3.view?.whenLayerView(this.layer);
    if (!t3 || !("queryAggregateCount" in t3) || !t3.queryAggregateCount) throw new s(`${this.adapterName}:not-supported`, "LayerView is not supported.");
    await this._waitForLayerViewUpdate(t3);
    const r5 = t3.createAggregateQuery();
    return r5.where = U2(r5.where, e3.whereClause), A2(r5, e3.filter), t3.queryAggregateCount(r5, { signal: e3.signal });
  }
  generateRenderer(e3, t3) {
    throw new s(`${this.adapterName}:not-supported`, "'generateRenderer' is not supported.");
  }
  heatmapStatistics(e3) {
    throw new s(`${this.adapterName}:not-supported`, "'heatmapStatistics' is not supported.");
  }
  async predominantCategories(e3) {
    const { fields: t3, view: a6, signal: r5 } = e3, i7 = s5(t3), s6 = await this._uvFromMemory({ valueExpression: i7, view: a6, signal: r5 });
    return Q(s6.uniqueValueInfos, t3);
  }
  async getSampleFeatures(e3, r5) {
    const { view: i7, sampleSize: s6, requiredFields: o4, returnGeometry: n7, filter: l6, signal: u3 } = e3;
    if (!i7) throw new s(`${this.adapterName}:not-supported`, "'view' is required to get sample features for binning.");
    if ("3d" === i7.type) throw new s(`${this.adapterName}:not-supported`, "3d 'view' is not supported to get sample features for binning.");
    const m9 = await i7.whenLayerView(this.layer);
    if (!("queryAggregateJSON" in m9 && m9.queryAggregateJSON && "queryAggregates" in m9 && m9.queryAggregates)) throw new s(`${this.adapterName}:not-supported`, "LayerView is not supported.");
    await this._waitForLayerViewUpdate(m9);
    if (V(this, o4).length) throw new s(`${this.adapterName}:insufficient-data`, "Layer does not have required fields");
    const p9 = 1, g5 = "json" === r5, d6 = m9.createAggregateQuery();
    d6.outSpatialReference = i7?.spatialReference, d6.returnGeometry = !!n7, d6.outFields = o4, A2(d6, l6);
    const { features: y } = g5 ? await m9.queryAggregateJSON(d6, { signal: u3 }) : await m9.queryAggregates(d6, { signal: u3 });
    return y.length && null != s6 && s6 > 0 && s6 <= y.length ? A(y, s6, p9) : y;
  }
  load(e3) {
    const t3 = this.layer.load(e3).then(async (t4) => {
      this.geometryType = "polygon", this.objectIdField = null, this.supportsSQLExpression = false, this._hasLocalSource = false, this.hasQueryEngine = true, this.minScale = t4.minScale, this.maxScale = t4.maxScale, this.fullExtent = t4.fullExtent;
      const r5 = "featureReduction" in t4 ? t4.featureReduction : null;
      if ("binning" !== r5?.type && "cluster" !== r5?.type) throw new s(`${this.adapterName}:invalid-parameters`, `Feature reduction type ${r5?.type} is not supported`);
      this.workerClient = n5.getInstance(), await this.workerClient.open(e3.signal);
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
r([m({ readOnly: true })], N3.prototype, "adapterName", void 0), N3 = r([a("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")], N3);
var T4 = N3;

// node_modules/@arcgis/core/smartMapping/support/adapters/SceneLayerAdapter.js
var A3 = class extends p7 {
  constructor(e3) {
    super(e3), this._featureLayerAdapter = null, this.workerClient = null, this.adapterName = "scene-layer-adapter";
  }
  destroy() {
    this.workerClient?.destroy();
  }
  _hasCachedStatistics(e3) {
    return this.layer.hasCachedStatistics(e3);
  }
  _updateQuery(e3, t3 = [], r5 = []) {
    if (!e3 || !r5.length) return e3;
    const a6 = this.layer.objectIdField, s6 = e3.clone(), i7 = t3.filter((e4) => {
      const t4 = this.layer.getField(e4);
      return !r5.includes(t4.name);
    }), o4 = i7.some((e4) => this.layer.getField(e4).name === a6);
    return s6.outFields = o4 ? i7 : [...i7, a6], s6;
  }
  async _fetchFeaturesFromMemory(e3, t3, r5) {
    if (!e3) throw new s("scene-layer-adapter:insufficient-data", "view is required to fetch the features from layerView");
    const n7 = await e3.whenLayerView(this.layer), l6 = new AbortController(), u3 = l6.signal, p9 = j(() => !n7.updating, u3);
    await T(p9, 5e3, l6);
    const m9 = z2(this, r5, n7);
    s2(u3);
    const c5 = this._updateQuery(t3, r5 ?? [], m9), d6 = await n7.queryFeatures(c5, { signal: u3 });
    s2(u3);
    const h2 = d6.features;
    return m9.length ? n7.whenGraphicAttributes(h2, m9) : h2;
  }
  async _fetchFeaturesJSONFromMemory(e3, t3, r5) {
    return this._fetchFeaturesFromMemory(e3, t3, r5).then(T3);
  }
  _fetchFeaturesForStats(e3, t3) {
    return U({ field: e3.field, normalizationField: e3.normalizationField, valueExpression: e3.valueExpression }).then((r5) => this.getSampleFeatures({ sampleSize: -1, view: e3.view, returnGeometry: e3.returnGeometry, requiredFields: r5, signal: e3.signal }, t3));
  }
  async _processStatsFromMemoryParams(e3) {
    const t3 = e3.features;
    if (t3?.length) {
      return t3.length && "declaredClass" in t3[0] && "esri.Graphic" === t3[0].declaredClass ? { graphics: t3 } : { featuresJSON: t3 };
    }
    const { view: r5, field: s6, normalizationField: i7, valueExpression: o4, signal: n7 } = e3, l6 = await this._fetchFeaturesForStats({ field: s6, valueExpression: o4, normalizationField: i7, view: r5, signal: n7 }, null);
    if (!l6?.length) throw new s("scene-layer-adapter:insufficient-data", "No features are available to calculate statistics");
    return { graphics: l6 };
  }
  _getCachedStatistics(e3, t3) {
    const r5 = this.layer;
    return e3.valueExpression || e3.sqlExpression || e3.sqlWhere || e3.minValue || e3.maxValue ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")) : r5.queryCachedStatistics(t3?.name, { signal: e3.signal }).then((e4) => {
      const t4 = e4.stats, { min: r6, max: a6, totalValuesCount: s6 } = t4;
      let { avg: i7, stddev: o4, sum: n7, variance: l6, count: u3 } = t4;
      return 0 === r6 && 0 === a6 || (i7 = 0 === i7 ? null : i7, n7 = 0 === n7 ? null : n7, o4 = 0 === o4 ? null : o4, l6 = 0 === l6 ? null : l6, u3 = 0 === u3 ? null : u3), null == u3 && (null != n7 && null != i7 ? u3 = Math.round(n7 / i7) : null != s6 && (u3 = s6)), { avg: i7, count: u3, max: a6, min: r6, stddev: o4, sum: n7, variance: l6 };
    });
  }
  async _getNormalizationTotal(e3, t3, r5) {
    const s6 = { include: ["sum"] }, i7 = (t3 ? await this.workerClient.summaryStatistics({ field: e3, outStatisticTypes: s6 }, t3) : await d3({ attribute: { field: e3, outStatisticTypes: s6 }, features: r5 })).sum;
    if (null == i7) throw new s("scene-layer-adapter:invalid", "invalid normalizationTotal");
    return i7;
  }
  async _getSummaryStatisticsFromMemory(e3, t3) {
    const { view: r5, field: a6, normalizationField: s6, valueExpression: i7 } = e3, { featuresJSON: o4, graphics: n7 } = await this._processStatsFromMemoryParams(e3), l6 = { field: a6, valueExpression: i7, normalizationType: e3.normalizationType, normalizationField: s6, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, outStatisticTypes: e3.outStatisticTypes };
    return e3.valueExpression && r5 && o4 && (l6.fieldType = t3?.type ? i3.toJSON(t3.type) : null, l6.viewInfoParams = B(r5), l6.timeZone = r5.timeZone), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (l6.normalizationTotal = await this._getNormalizationTotal(a6, o4, n7)), o4 ? this.workerClient.summaryStatistics(l6, o4) : d3({ attribute: l6, features: n7 });
  }
  _getCachedStatisticsForUniqueValues(e3, r5) {
    const s6 = this.layer, i7 = r5?.name, o4 = r5 && e3.field ? this.getFieldDomain(e3.field) : null;
    return e3.valueExpression || e3.sqlExpression || e3.sqlWhere ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")) : s6.queryCachedStatistics(i7, { signal: e3.signal }).then((a6) => {
      const o5 = a6.stats;
      if (!o5.mostFrequentValues) throw new Error();
      const n7 = a6.labels?.labels, l6 = {}, u3 = [], c5 = "countOF" + i7;
      o5.mostFrequentValues.forEach((e4) => {
        const a7 = new d({ attributes: {} });
        a7.attributes[i7] = r5 && r5.name !== s6.objectIdField && (ge(r5) || $(r5)) ? Number(e4.value) : e4.value, a7.attributes[c5] = e4.count, u3.push(a7);
      }), n7 && n7.forEach((e4) => {
        l6[e4.value] = e4.label;
      });
      const d6 = new g2({ features: u3 });
      return L2(d6, { layer: this, field: e3.field, labels: l6, view: e3.view, signal: e3.signal });
    }).then((t3) => $2(t3, [o4], e3.returnAllCodedValues));
  }
  async _getUniqueValuesFromMemory(e3, t3) {
    const { view: r5, field: a6, field2: s6, field3: i7, valueExpression: o4, returnAllCodedValues: n7 } = e3, l6 = { field: a6, field2: s6, field3: i7, fieldDelimiter: f2, valueExpression: o4, domains: t3, returnAllCodedValues: n7 }, { featuresJSON: u3, graphics: p9 } = await this._processStatsFromMemoryParams(e3);
    return e3.valueExpression && r5 && u3 && (l6.viewInfoParams = B(r5), l6.timeZone = r5.timeZone), u3 ? this.workerClient.uniqueValues(l6, u3) : p4({ attribute: l6, features: p9 });
  }
  _getCachedStatisticsForHistogram(e3, t3) {
    const r5 = this.layer;
    return e3.valueExpression || e3.sqlExpression || e3.sqlWhere || e3.normalizationType ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")) : r5.queryCachedStatistics(t3 && t3.name, { signal: e3.signal }).then((t4) => {
      const r6 = t4.stats, { minValue: a6, maxValue: s6 } = e3, i7 = null != a6 ? a6 : r6.min, o4 = null != s6 ? s6 : r6.max, n7 = e3.numBins || 10, l6 = j6(r6.histogram, i7, o4, n7);
      return O(l6, i7, o4, n7);
    });
  }
  async _getClassBreaksFromMemory(e3) {
    const { view: t3, field: r5, normalizationField: a6, valueExpression: s6 } = e3, { featuresJSON: i7, graphics: o4 } = await this._processStatsFromMemoryParams(e3), n7 = { field: r5, valueExpression: s6, normalizationType: e3.normalizationType, normalizationField: a6, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numClasses: e3.numClasses };
    return e3.valueExpression && t3 && i7 && (n7.viewInfoParams = B(t3), n7.timeZone = t3.timeZone), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (n7.normalizationTotal = await this._getNormalizationTotal(r5, i7, o4)), i7 ? this.workerClient.classBreaks(n7, i7) : c2({ attribute: n7, features: o4 });
  }
  async _getHistogramFromMemory(e3) {
    const { view: t3, field: r5 } = e3, { featuresJSON: a6, graphics: s6 } = await this._processStatsFromMemoryParams(e3), i7 = { field: r5, valueExpression: e3.valueExpression, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numBins: e3.numBins };
    return e3.valueExpression && t3 && a6 && (i7.viewInfoParams = B(t3), i7.timeZone = t3.timeZone), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (i7.normalizationTotal = await this._getNormalizationTotal(r5, a6, s6)), a6 ? this.workerClient.histogram(i7, a6) : v({ attribute: i7, features: s6 });
  }
  getField(e3) {
    return this.layer.getField(e3 ?? "");
  }
  getFieldUsageInfo(e3) {
    const t3 = this.getField(e3);
    if (!t3) return null;
    const r5 = this.layer.getFieldUsageInfo(t3.name);
    return { supportsLabelingInfo: r5.supportsLabelingInfo, supportsPopupTemplate: r5.supportsPopupTemplate, supportsRenderer: r5.supportsRenderer, supportsLayerQuery: r5.supportsLayerQuery, supportsStatistics: true };
  }
  getFieldDomain(e3, t3) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.getFieldDomain(e3, t3) : null;
  }
  createQuery() {
    return this.layer.createQuery();
  }
  summaryStatistics(e3) {
    const t3 = this.getField(e3.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.summaryStatistics(e3);
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return this._hasCachedStatistics(t3?.name) ? this._getCachedStatistics(e3, t3).catch(() => (s2(e3.signal), this._getSummaryStatisticsFromMemory(e3, t3))) : this._getSummaryStatisticsFromMemory(e3, t3);
  }
  async uniqueValues(e3) {
    if (this._featureLayerAdapter) return this._featureLayerAdapter.uniqueValues(e3);
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    const t3 = await I(e3, this), { field: r5, field2: s6 } = e3, o4 = r5 && s6, n7 = this.getField(r5);
    return !o4 && n7 && this._hasCachedStatistics(n7.name) ? this._getCachedStatisticsForUniqueValues(e3, n7).catch(() => (s2(e3.signal), this._getUniqueValuesFromMemory(e3, t3))) : this._getUniqueValuesFromMemory(e3, t3);
  }
  histogram(e3) {
    const t3 = this.getField(e3.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.histogram(e3);
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return t3 && this._hasCachedStatistics(t3.name) ? this._getCachedStatisticsForHistogram(e3, t3).catch(() => (s2(e3.signal), this._getHistogramFromMemory(e3))) : this._getHistogramFromMemory(e3);
  }
  classBreaks(e3) {
    const t3 = this.getField(e3.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.classBreaks(e3);
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return this._hasCachedStatistics(t3?.name) ? Promise.reject(new s("scene-layer-adapter:not-supported", "Cached stats not supported")) : this._getClassBreaksFromMemory(e3);
  }
  queryFeatureCount(e3) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.queryFeatureCount(e3) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support count query"));
  }
  generateRenderer(e3, t3) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.generateRenderer(e3, t3) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support generateRenderer operation"));
  }
  heatmapStatistics(e3) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.heatmapStatistics(e3) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"));
  }
  async predominantCategories(e3) {
    if (this._featureLayerAdapter) return this._featureLayerAdapter.predominantCategories(e3);
    throw new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support predominantCategories");
  }
  async getSampleFeatures(e3, t3) {
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    const { view: s6, sampleSize: o4, requiredFields: n7, returnGeometry: l6, signal: u3 } = e3, p9 = 1, m9 = "json" === t3, c5 = this.createQuery();
    c5.outFields = n7, c5.returnGeometry = !!l6, c5.where = null, c5.num = o4;
    let d6 = [];
    try {
      if (d6 = m9 ? await this._fetchFeaturesJSONFromMemory(s6, c5, n7) : await this._fetchFeaturesFromMemory(s6, c5, n7), d6.length && null != o4 && o4 > 0 && o4 <= d6.length) return A(d6, o4, p9);
    } catch (y) {
      s2(u3);
    }
    let h2 = null;
    if (this._featureLayerAdapter) {
      const r5 = { ...e3 };
      delete r5.view, h2 = await this._featureLayerAdapter.getSampleFeatures(r5, t3);
    }
    return h2?.length ? h2 : A(d6, d6.length, p9);
  }
  load(e3) {
    const t3 = this.layer.load(e3).then(async (t4) => {
      this.workerClient = n5.getInstance(), await this.workerClient.open(e3.signal);
      const r5 = t4.associatedLayer;
      if (this.geometryType = t4.geometryType, null != r5) {
        this._featureLayerAdapter = new Z2({ layer: r5 });
        return this._featureLayerAdapter.load(e3).then(() => {
          this.objectIdField = this._featureLayerAdapter.objectIdField, this.supportsSQLExpression = this._featureLayerAdapter.supportsSQLExpression, this.minScale = this._featureLayerAdapter.minScale, this.maxScale = this._featureLayerAdapter.maxScale, this.fullExtent = this._featureLayerAdapter.fullExtent;
        });
      }
      this.objectIdField = t4.objectIdField, this.supportsSQLExpression = false, this.hasQueryEngine = false, this.fullExtent = t4.fullExtent;
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
function j6(e3, r5 = e3.minimum, a6 = e3.maximum, s6) {
  const i7 = [];
  for (let t3 = 0; t3 < s6; t3++) i7[t3] = 0;
  const o4 = e3.counts.length, n7 = e3.minimum, l6 = e3.maximum;
  for (let t3 = 0; t3 < o4; t3++) {
    const u4 = (t3 + 0.5) / o4, p9 = ((1 - u4) * n7 + u4 * l6 - r5) / (a6 - r5) * s6;
    p9 >= 0 && p9 <= s6 && (i7[p9 === s6 ? s6 - 1 : Math.floor(p9)] += e3.counts[t3]);
  }
  const u3 = [];
  return i7.forEach((e4, r6) => {
    const a7 = new d({ attributes: {} });
    a7.attributes.EXPR_1 = r6 + 1, a7.attributes.countOFExpr = e4, u3.push(a7);
  }), new g2({ features: u3 });
}
r([m({ readOnly: true })], A3.prototype, "adapterName", void 0), r([m({ constructOnly: true })], A3.prototype, "layer", void 0), A3 = r([a("esri.smartMapping.support.adapters.SceneLayerAdapter")], A3);

// node_modules/@arcgis/core/smartMapping/support/adapters/PointCloudLayerAdapter.js
var o3 = class extends A3 {
  constructor(e3) {
    super(e3), this.adapterName = "point-cloud-layer-adapter";
  }
  getField(e3) {
    return this.layer.fieldsIndex.get(e3 ?? "");
  }
  getFieldUsageInfo(e3) {
    const r5 = this.getField(e3);
    if (!r5) return null;
    const t3 = this._hasCachedStatistics(r5.name);
    return { supportsLabelingInfo: t3, supportsPopupTemplate: t3, supportsRenderer: t3, supportsLayerQuery: false, supportsStatistics: t3 };
  }
  getFieldDomain() {
    return null;
  }
  load(e3) {
    const r5 = this.layer.load(e3).then(() => {
      this.geometryType = "point", this.objectIdField = null, this.supportsSQLExpression = false, this.hasQueryEngine = false;
    });
    return this.addResolvingPromise(r5), Promise.resolve(this);
  }
};
r([m({ readOnly: true })], o3.prototype, "adapterName", void 0), o3 = r([a("esri.smartMapping.support.adapters.PointCloudLayerAdapter")], o3);

// node_modules/@arcgis/core/smartMapping/support/adapters/StreamLayerAdapter.js
var c4 = class extends R5 {
  constructor() {
    super(...arguments), this.adapterName = "stream-layer-adapter";
  }
  async _summaryStatsFromClientQuery(t3, r5) {
    const { signal: s6, view: a6 } = t3, c5 = k(this, t3, r5);
    c5.outStatistics = c5.outStatistics?.filter((t4) => "totalcount_value" !== t4.outStatisticFieldName);
    const u3 = await this._fetchFeatureSetFromMemory(c5, a6, s6), l6 = $3(u3, $(r5) || Te(r5));
    return C2(l6, t3.outStatisticTypes);
  }
};
r([m({ readOnly: true })], c4.prototype, "adapterName", void 0), c4 = r([a("esri.smartMapping.support.adapters.StreamLayerAdapter")], c4);

// node_modules/@arcgis/core/smartMapping/support/adapters/support/layerUtils.js
var l5;
!function(e3) {
  e3[e3.CatalogLayer = 0] = "CatalogLayer", e3[e3.CatalogFootprintLayer = 1] = "CatalogFootprintLayer", e3[e3.CSVLayer = 2] = "CSVLayer", e3[e3.FeatureLayer = 3] = "FeatureLayer", e3[e3.GeoJSONLayer = 4] = "GeoJSONLayer", e3[e3.ImageryLayer = 5] = "ImageryLayer", e3[e3.KnowledgeGraphSublayer = 6] = "KnowledgeGraphSublayer", e3[e3.OGCFeatureLayer = 7] = "OGCFeatureLayer", e3[e3.OrientedImageryLayer = 8] = "OrientedImageryLayer", e3[e3.ParquetLayer = 9] = "ParquetLayer", e3[e3.PointCloudLayer = 10] = "PointCloudLayer", e3[e3.SceneLayer = 11] = "SceneLayer", e3[e3.StreamLayer = 12] = "StreamLayer", e3[e3.SubtypeGroupLayer = 13] = "SubtypeGroupLayer", e3[e3.SubtypeSublayer = 14] = "SubtypeSublayer", e3[e3.WFSLayer = 15] = "WFSLayer";
}(l5 || (l5 = {}));
var u2 = { [l5.CatalogLayer]: { adapter: Z2, type: "catalog", label: "CatalogLayer" }, [l5.CatalogFootprintLayer]: { adapter: Z2, type: "catalog-footprint", label: "CatalogFootprintLayer" }, [l5.CSVLayer]: { adapter: m8, type: "csv", label: "CSVLayer" }, [l5.FeatureLayer]: { adapter: Z2, type: "feature", label: "FeatureLayer" }, [l5.ImageryLayer]: { adapter: Z2, type: "imagery", label: "ImageryLayer" }, [l5.GeoJSONLayer]: { adapter: Z2, type: "geojson", label: "GeoJSONLayer" }, [l5.KnowledgeGraphSublayer]: { adapter: Z2, type: "knowledge-graph-sublayer", label: "KnowledgeGraphSublayer" }, [l5.OGCFeatureLayer]: { adapter: R5, type: "ogc-feature", label: "OGCFeatureLayer" }, [l5.OrientedImageryLayer]: { adapter: Z2, type: "oriented-imagery", label: "OrientedImageryLayer" }, [l5.ParquetLayer]: { adapter: Z2, type: "parquet", label: "ParquetLayer" }, [l5.PointCloudLayer]: { adapter: o3, type: "point-cloud", label: "PointCloudLayer" }, [l5.SceneLayer]: { adapter: A3, type: "scene", label: "SceneLayer" }, [l5.StreamLayer]: { adapter: c4, type: "stream", label: "StreamLayer" }, [l5.SubtypeGroupLayer]: { adapter: Z2, type: "subtype-group", label: "SubtypeGroupLayer" }, [l5.SubtypeSublayer]: { adapter: Z2, type: "subtype-sublayer", label: "SubtypeSublayer" }, [l5.WFSLayer]: { adapter: Z2, type: "wfs", label: "WFSLayer" } };
var n6 = [l5.CatalogLayer, l5.CatalogFootprintLayer, l5.CSVLayer, l5.FeatureLayer, l5.GeoJSONLayer, l5.KnowledgeGraphSublayer, l5.OGCFeatureLayer, l5.OrientedImageryLayer, l5.ParquetLayer, l5.PointCloudLayer, l5.SceneLayer, l5.StreamLayer, l5.SubtypeGroupLayer, l5.SubtypeSublayer, l5.WFSLayer];
var S3 = [l5.CatalogFootprintLayer, l5.CSVLayer, l5.FeatureLayer, l5.GeoJSONLayer, l5.KnowledgeGraphSublayer, l5.OGCFeatureLayer, l5.OrientedImageryLayer, l5.ParquetLayer, l5.SceneLayer, l5.StreamLayer, l5.SubtypeGroupLayer, l5.SubtypeSublayer, l5.WFSLayer];
var d5 = [l5.CSVLayer, l5.FeatureLayer, l5.GeoJSONLayer, l5.OGCFeatureLayer, l5.KnowledgeGraphSublayer, l5.OrientedImageryLayer, l5.ParquetLayer, l5.StreamLayer, l5.WFSLayer];
function b4(e3) {
  return e3.map((e4) => u2[e4].label);
}
function i6(e3, a6 = n6, t3) {
  if (e3 instanceof p7) return e3;
  const L3 = g4(e3, a6);
  return L3 ? t3 ? new T4({ layer: e3 }) : new L3({ layer: e3 }) : null;
}
function g4(e3, a6 = n6) {
  let r5 = null;
  return a6.some((a7) => {
    const t3 = e3.type === u2[a7].type;
    return t3 && (r5 = u2[a7].adapter), t3;
  }), r5;
}

// node_modules/@arcgis/core/smartMapping/statistics/uniqueValues.js
async function p8(p9) {
  if (!p9?.layer || !p9.field && !p9.valueExpression) throw new s("unique-values:missing-parameters", "'layer' and 'field' or 'valueExpression' parameters are required");
  const f5 = p9.valueExpression || p9.sqlExpression, m9 = f5 && !p9.sqlExpression;
  if (f5) {
    if (m9) {
      if (!p9.view) throw new s("unique-values:missing-parameters", "View is required when 'valueExpression' is specified");
    } else if (!p9.valueExpression) throw new s("unique-values:missing-parameters", "'valueExpression' parameters are required");
  }
  p9.forBinning && i4(p9, "unique-values");
  const { layer: d6, ...v2 } = p9, w2 = [...n6, l5.ImageryLayer], c5 = p9.forBinning ? d5 : w2, y = i6(d6, c5, p9.forBinning);
  if (!y) throw new s("unique-values:invalid-parameters", "'layer' must be one of these types: " + b4(c5).join(", "));
  const q4 = { layerAdapter: y, ...v2 }, g5 = null != q4.signal ? { signal: q4.signal } : null;
  await y.load(g5);
  const x = await U({ field: q4.field, field2: q4.field2, field3: q4.field3, valueExpression: q4.valueExpression }), E3 = T2(y, x, "unique-values:invalid-parameters");
  if (E3) throw E3;
  q4.filter && !q4.filter.spatialRelationship && (q4.filter.spatialRelationship = "intersects");
  const h2 = M2(q4.filter, "summary-statistics:invalid-parameters");
  if (h2) throw h2;
  return q4;
}
async function f4(e3) {
  const { layerAdapter: i7, ...s6 } = await p8(e3);
  return i7.uniqueValues(s6);
}
export {
  f4 as default
};
//# sourceMappingURL=uniqueValues-SKGVIYWN.js.map
