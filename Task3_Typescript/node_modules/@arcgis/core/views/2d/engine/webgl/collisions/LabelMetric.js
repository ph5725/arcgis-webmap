/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{labelPlacementOffsetPadding as e}from"../definitions.js";import{VVBinding as i}from"../enums.js";import t from"./BoundingBox.js";import{serializeList as s,deserializeList as r}from"../util/serializationUtils.js";const h=2;class n{constructor(e,i,t,s,r,h,n,a,o,l,d=[],c=0,u=0){this.displayId=e,this.labelClassId=i,this.hash=t,this.anchorX=s,this.anchorY=r,this.directionX=h,this.directionY=n,this.maxScale=a,this.minScale=o,this.referenceBounds=l,this.bounds=d,this.recordStart=c,this.recordCount=u,this.priority=0,this._colliders=null,this.uniqueSymbol=null,this.selectedForRendering=!1}get xTile(){return this.anchorX}get yTile(){return this.anchorY}colliders(t){if(!this._colliders){const s=t.attributeView,r=e;let n=this.referenceBounds?.size??0;const a=t.layerView.labelingCollisionInfos[0].vvEvaluators[0];if(null!=a){const e=a(s.getVisualVariableData(this.displayId,i.SIZE));n=isNaN(e)||null==e||e===1/0?n:e}const o=this.minScale?t.layerView.view.featuresTilingScheme.scaleToZoom(this.minScale):0,l=this.maxScale?t.layerView.view.featuresTilingScheme.scaleToZoom(this.maxScale):25,d=this.directionX*(r+n/2),c=this.directionY*(r+n/2);this._colliders=this.bounds.map((e=>({xTile:this.anchorX,yTile:this.anchorY,dxPixels:e.x-e.halfWidth+d,dyPixels:e.y-e.halfHeight+c,hard:!0,partIndex:1,width:e.width+h,height:e.height+h,angle:0,xScreen:0,yScreen:0,dxScreen:0,dyScreen:0,enabled:!0,minLod:o,maxLod:l})))}return this._colliders}get id(){return this.displayId}serialize(e){e.push(this.displayId),e.push(this.labelClassId),e.push(this.hash),e.push(this.recordStart),e.push(this.recordCount),e.writeF32(this.anchorX),e.writeF32(this.anchorY),e.writeF32(this.directionX),e.writeF32(this.directionY),e.writeF32(this.maxScale),e.writeF32(this.minScale),this.referenceBounds?(e.writeF32(this.referenceBounds.size),e.writeF32(this.referenceBounds.offsetX),e.writeF32(this.referenceBounds.offsetY)):(e.writeF32(0),e.writeF32(0),e.writeF32(0)),s(e,this.bounds)}static deserialize(e){const i=e.readInt32(),s=e.readInt32(),h=e.readInt32(),a=e.readInt32(),o=e.readInt32(),l=e.readF32(),d=e.readF32(),c=e.readF32(),u=e.readF32(),f=e.readF32(),m=e.readF32(),F=e.readF32(),w=e.readF32(),S=e.readF32(),p=r(e,t)??[];return new n(i,s,h,l,d,c,u,f,m,{size:F,offsetX:w,offsetY:S},p,a,o)}}export{n as LabelMetric};
