/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../../../core/arrayUtils.js";import e from"../../../../../core/Logger.js";import{assertIsSome as s}from"../../../../../core/maybe.js";import{isLoaded as r,load as i,execute as a}from"../../../../../geometry/operators/gx/operatorGeodeticDensify.js";import{geodeticCurveType as o}from"../../../../../geometry/operators/support/geodeticCurveType.js";import{intersectsWithMargin as n,fromValues as l,intersects as c,empty as d,expandPointInPlace as u}from"../../../../../geometry/support/aaBoundingRect.js";import{getClosestDenormalizedXToReference as h}from"../../../../../geometry/support/normalizeUtils.js";import{normalizeCentralMeridianForDisplay as m}from"../../../../../geometry/support/normalizeUtilsSync.js";import{quantizeOptimizedGeometry as p,convertToGeometry as f,convertFromNestedArray as g}from"../../../../../layers/graphics/featureConversionUtils.js";import{OptimizedFeature as _}from"../../../../../layers/graphics/OptimizedFeature.js";import b from"../../../../../layers/graphics/OptimizedGeometry.js";import{internalTrackPartField as y,TrackPart as I,externalTrackLineOidPrefix as k,internalTimeReceivedField as v}from"../../../../../layers/support/streamLayerUtils.js";import{tileSize as F}from"../../../engine/webgl/definitions.js";import{AccumulatedStatistics as j}from"../aggregation/AccumulatedStatistics.js";import{ComputedAggregateField as O}from"../aggregation/ComputedAggregateField.js";import{AAggregateStrategy as T}from"./AAggregateStrategy.js";import{ASendState as x}from"./AProcessorStrategy.js";import{FeatureTileAppendMessage as S}from"../sources/FeatureSourceMessage.js";import{createArcadeEvaluationOptions as R}from"../support/arcadeUtils.js";import{ComputedAttributeStorage as w}from"../support/ComputedAttributeStorage.js";import D from"../support/FeatureFilterEvaluator.js";import{FeatureMetadata as L}from"../support/FeatureMetadata.js";import{FeatureSetReaderIndirect as A}from"../support/FeatureSetReaderIndirect.js";import{FeatureSetReaderJSON as C}from"../support/FeatureSetReaderJSON.js";let G;const P=()=>e.getLogger("esri.views.2d.layers.features.processor.TrackStrategy"),z=32;class M{constructor(t,e,s,r,i){this.chunkIndex=t,this.featureIndex=e,this.objectId=s,this.displayId=r,this.time=i}}class W{static getOid(t){return k+t}constructor(t,e,s,r,i,a,o,n){this._schema=t,this.trackId=e,this.objectId=s,this.displayId=r,this._fields=i,this._spatialReference=a,this._metadata=o,this._isStream=n,this._maxDisplayDuration=this._schema.maxDisplayDuration>0?this._schema.maxDisplayDuration:1/0,this._maxDisplayObservationsPerTrack=this._schema.maxDisplayObservationsPerTrack>=1?this._schema.maxDisplayObservationsPerTrack:1/0,this._observationRecords=[],this._nextObservationRecords=[],this._trackLinePath=[],this._bounds=[],this._trackLineGeometry=new b}get _trackLineAttributes(){const t={...this._latestObservationFeature?.attributes??{},aggregateId:this.objectId,[y]:I.TrackLine};if(null!=this._statistics)for(const e of this._statistics.values())t[e.field.name]=e.value;return t}get _startTimeField(){return this._metadata.timeInfo?.startTimeField}get length(){return this._observationRecords.length}*observations(){yield*this._observationRecords}*previousObservations(){for(let t=0;t<this._observationRecords.length-1;t++)yield this._observationRecords[t]}stageObservation(t,e){this._nextObservationRecords.push(new M(t,e.getIndex(),e.getObjectId(),e.getDisplayId(),null!=this._startTimeField?e.readAttributeAsTimestamp(this._startTimeField):null))}commitObservations(t,e){const r=new Set(this._nextObservationRecords.map((t=>t.objectId))),i=this._observationRecords.filter((t=>!r.has(t.objectId))).map((t=>t.objectId));let a,o;switch(this._observationRecords=[],this._trackLinePath=[],this._isStream||null==this._startTimeField||this._nextObservationRecords.sort(((t,e)=>{const s=t.time,r=e.time;return null!=s&&null!=r?s-r:0})),this._schema.timeField){case"startTimeField":a=this._metadata.timeInfo?.startTimeField;break;case"endTimeField":a=this._metadata.timeInfo?.endTimeField;break;case"timeReceived":a=this._isStream?v:null}o=this._isStream?e?.end??Date.now():e?.end??-1/0;const n=t.map((t=>t.reader.getCursor()));let l;for(let c=this._nextObservationRecords.length-1;c>=0&&!(this._observationRecords.length>=this._maxDisplayObservationsPerTrack);c--){const t=this._nextObservationRecords[c],e=n[t.chunkIndex];s(e),e.setIndex(t.featureIndex);const r=null!=a?e.readAttributeAsTimestamp(a):null;(null!=r?o-r:0)>=this._maxDisplayDuration||(this._commitObservation(t,e),l??=t)}if(null!=l){const{chunkIndex:t,featureIndex:e,objectId:r,displayId:i}=l,a=n[t];s(a),a.setIndex(e);const o=new _(a.readGeometryWorldSpace(),{...a.readAttributes(),[y]:I.LatestObservation},null,r,i);this._latestObservationFeature=o}else this._latestObservationFeature=null;return this._trackLineGeometry=E(this._trackLineGeometry,this._trackLinePath,this._spatialReference),this._bounds=X(this._trackLineGeometry),this._nextObservationRecords=[],i}updateStatistics(t,e){this._statistics=j.create(this._fields);const r=t.map((t=>t.reader.getCursor()));for(const{chunkIndex:i,featureIndex:a}of this._observationRecords){const t=r[i];s(t),t.setIndex(a),this._statistics.insert(t,e)}}overlapsTile(t){for(const e of this._bounds)if(n(e,t.bounds,z))return!0;return!1}getLatestObservationFeatureForTile(t){if(null==this._latestObservationFeature)return null;const{objectId:e,displayId:s,geometry:r,attributes:i}=this._latestObservationFeature,a=new b;p(a,r,!1,!1,this._metadata.geometryType,t.subscription.tile.transform);const o=l(1/0,1/0,-1/0,-1/0);N(a,((t,e)=>u(o,[t,e])));if(!c(o,l(0,0,F,F)))return null;return new _(a,i,null,e,s)}getTrackLineFeatureForTile(t){const e=new b;p(e,this._trackLineGeometry,!1,!1,"esriGeometryPolyline",t.subscription.tile.transform);return new _(e,this._trackLineAttributes,null,this.objectId,this.displayId)}getTrackLineOptimizedFeature(){return new _(this._trackLineGeometry,this._trackLineAttributes,null,this.objectId,this.displayId)}getTrackLineDisplayFeature(){const{_trackLineGeometry:t,_trackLineAttributes:e,displayId:s}=this;return{geometry:f(t,"esriGeometryPolyline",!1,!1),attributes:e,displayId:s}}_commitObservation(t,e){const s=e.readCentroidWorldSpace();let r=s?.coords[0],i=s?.coords[1];null==s&&(r=e.readXWorldSpace(),i=e.readYWorldSpace()),null!=r&&null!=i&&(this._observationRecords.unshift(t),this._trackLinePath.unshift([r,i]))}}class U extends x{constructor(t){super(t),this.done=!1}}class q extends T{static async create(t,e,s,a,o,n){const l=new w({spatialReference:e}),c=await Promise.all(t.fields.map((async t=>O.create(l,t)))),d=t.featureFilter?await D.create({geometryType:s.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:s.metadata.timeInfo,fieldsIndex:s.metadata.fieldsIndex,spatialReference:e,filterJSON:t.featureFilter}):null;return e.isWrappable||r()||await Promise.all([import("../../../../../geometry/operators/support/apiConverter.js"),import("../../../../../geometry/operators/support/jsonConverter.js"),i()]).then((([t,e,s])=>{G={fromGeometryToGXGeometry:e.fromGeometryToGXGeometry,toGeometry:e.toGeometry,fromSpatialReference:t.fromSpatialReference}})),new q(t,s,a,e,c,d,o,n)}constructor(t,e,s,r,i,a,o,n){super(e,s,r,i,n),this._schema=t,this._featureFilter=a,this._arcadeContextInfo=o,this._tracks=new Map,this._handledChunks=new Set,this._metadata=e.metadata.weakCloneWithAdditionalFields([{name:y,alias:"trackPart",type:"esriFieldTypeSmallInteger"}]),this._trackLineMetadata=L.createFeature({geometryType:"esriGeometryPolyline",featureIdInfo:{type:"object-id",fieldName:"aggregateId"},fieldsIndex:{fields:[...this._source.metadata.fieldsIndex.fields,...this.aggregateFields,{name:y,alias:"trackPart",type:"esriFieldTypeSmallInteger"},{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}],timeZoneByFieldName:null},globalIdField:null,spatialReference:e.metadata.spatialReference,outSpatialReference:e.metadata.outSpatialReference,subtypeField:null,subtypes:null,timeInfo:e.metadata.timeInfo,timeReferenceUnknownClient:null,dateFieldsTimeZone:null,typeIdField:null,types:null})}get _isStream(){return this._source.isStream}get enablePixelBuffering(){return!0}get isAggregate(){return!1}requiresInvalidation(){const t=new Set(this._source.chunks().map((t=>t.chunkId)));for(const e of t)if(!this._handledChunks.has(e))return!0;for(const e of this._handledChunks)if(!t.has(e))return!0;return!1}invalidate(){this._handledChunks.clear(),super.invalidate()}createState(t){return new U(t)}async*applyOverrideUpdate(t){P().error("Applying override to tracks is not supported")}displayMap(t,e,s){const r=new Map(t.map((t=>[e(t),t]))),i=[];for(const a of this._tracks.values()){const t=r.get(a.objectId);if(null==t)for(const e of a.observations()){const t=r.get(e.objectId);if(null!=t){const a=s(e.displayId,t,e.objectId);i.push(a),r.delete(e.objectId)}}else{const e=s(a.displayId,t,a.objectId);i.push(e),r.delete(a.objectId)}}return i}getDisplayFeatures(t){const e=new Set(t),s=[],r=[],i=this._source.chunks().map((t=>t.reader.getCursor()));for(const a of this._tracks.values()){e.has(a.displayId)&&r.push(a.getTrackLineDisplayFeature());for(const{displayId:t,chunkIndex:r,featureIndex:o}of a.observations())if(e.has(t)){const e=i[r];e.setIndex(o),s.push({displayId:t,attributes:{},...e.readLegacyFeatureWorldSpace()})}}return{features:s,aggregates:[],tracks:r}}getFeatureObjectIdsForAggregate(t){for(const e of this._tracks.values())if(e.objectId===t)return Array.from(e.observations(),(t=>t.objectId));return[]}async*updateChunks(){0===this._handledChunks.size&&this._rebuildTracks();for(const t of this._sendStates.values())yield*this._update(t)}forEachAggregateWorldSpace(t){for(const e of this._tracks.values())t(e.getTrackLineOptimizedFeature())}_rebuildTracks(){const t=this._source.chunks();if(!t.length)return;const e=this._metadata.timeInfo?.trackIdField;if(null==e)return;const s=new Set;for(let r=0;r<t.length;r++){const i=t[r];this._handledChunks.add(i.chunkId);const a=i.reader.getCursor();for(;a.next();){const t=a.readAttribute(e),i=a.getObjectId();if(null!=t&&null!=i&&(null===this._featureFilter||this._featureFilter.check(a,this._sqlOptions))){if(a.getDisplayId()||a.setDisplayId(this._attributeStore.createDisplayIdForObjectId(i)),!this._tracks.has(t)){const e=W.getOid(t),s=this._attributeStore.createDisplayIdForObjectId(e),r=new W(this._schema,t,e,s,this.aggregateFields,this.spatialReference,this._source.metadata,this._isStream);this._tracks.set(t,r)}this._tracks.get(t).stageObservation(r,a),s.add(t)}}}for(const r of this._tracks.values())if(s.has(r.trackId)){const e=r.commitObservations(t,this._featureFilter?.timeExtent);for(const t of e)this._attributeStore.releaseDisplayIdForObjectId(t);r.updateStatistics(t,R(1,this._arcadeContextInfo))}else this._removeTrack(r)}_removeTrack(t){this._tracks.delete(t.trackId),this._attributeStore.releaseDisplayIdForObjectId(t.objectId);for(const{objectId:e}of t.observations())this._attributeStore.releaseDisplayIdForObjectId(e)}*_update(e){if(e.done)return;e.done=!this._source.updateTracking.updating;const s=[],r=[];for(const t of this._tracks.values())if(t.length>0){if(this._schema.showLatestObservation){const r=t.getLatestObservationFeatureForTile(e);null!=r&&s.push(r)}this._schema.showTrackLine&&t.overlapsTile(e.subscription.tile)&&r.push(t.getTrackLineFeatureForTile(e))}const i=C.fromOptimizedFeatures(s,this._metadata,e.subscription.tile.transform),a=C.fromOptimizedFeatures(r,this._trackLineMetadata,e.subscription.tile.transform);let o=[];if(this._schema.showPreviousObservations){const s=this._source.chunks().map((()=>[]));for(const t of this._tracks.values())for(const{chunkIndex:e,featureIndex:r}of t.previousObservations())s[e].push(r);o=this._source.chunks().map(((t,r)=>{const i=t.getTileReader(e.subscription.tile);if(null==i)return null;const a=A.from(i,s[r]);return a.setProcessorAttributes({[y]:I.PreviousObservation}),"esriGeometryPoint"!==a.geometryType&&null!=a.getInTransform()||a.setTransformForDisplay(e.subscription.tile.transform),a})).filter(t)}this.events.emit("changed");const n=e.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo),l=a.getCursor();for(;l.next();)this._attributeStore.setAttributeData(l.getDisplayId(),l,n,this._sqlOptions);for(const t of o){const e=t.getCursor();for(;e.next();)this._attributeStore.setAttributeData(e.getDisplayId(),e,n,this._sqlOptions)}const c=i.getCursor();for(;c.next();)this._attributeStore.setAttributeData(c.getDisplayId(),c,n,this._sqlOptions);yield new S(e.subscription,a,!1,!1,{});for(const t of o)yield new S(e.subscription,t,!1,!1,{});yield new S(e.subscription,i,!1,e.done,{})}}function E(t,e,s){if(e.length<2)return g(t,[e],!1,!1);if(s.isWrappable){let r=!1;for(let t=1;t<e.length;t++){const i=e[t][0],a=h(i,e[t-1][0],s);i!==a&&(e[t][0]=a,r=!0)}if(r){const r=m({paths:[e],spatialReference:s});if(null!=r)return g(t,r.paths,!1,!1)}return g(t,[e],!1,!1)}const r=G.fromGeometryToGXGeometry({hasM:!1,hasZ:!1,paths:[e]}),i=G.fromSpatialReference(s);if(null!=i){const e=a(r,1e6,i,o.geodesic);if(null!=e){const s=G.toGeometry(e,i);if(null!=s&&"paths"in s)return g(t,s.paths,!1,!1)}}return g(t,[e],!1,!1)}function N(t,e){const s=2,{coords:r,lengths:i}=t;if(!i.length)return void e(r[0],r[1]);let a=0;for(let o=0;o<i.length;o++){const t=i[o];let n=0,l=0;for(let i=0;i<t;i++)n+=r[s*(i+a)],l+=r[s*(i+a)+1],e(n,l);a+=t}}function X(t){const{lengths:e,coords:s}=t,r=2;if(!e.length)return[d()];const i=[];let a=0;for(let o=0;o<e.length;o++){const t=e[o],n=d();i.push(n);for(let e=0;e<t;e++){const t=s[r*(e+a)],i=s[r*(e+a)+1];u(n,[t,i])}a+=t}return i}export{q as TrackStrategy};
