/* @preserve
* @esri/arcgis-rest-developer-credentials - v2.0.0 - Apache-2.0
* Copyright (c) 2017-2025 Esri, Inc.
* Wed Feb 26 2025 22:10:42 GMT+0000 (Coordinated Universal Time)
*/
import { getPortalUrl, createItem, updateItem, getItem } from '@esri/arcgis-rest-portal';
import { request, appendCustomParams } from '@esri/arcgis-rest-request';

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to retrieve registered app info. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/registered-app-info.htm) for more information.
 *
 * ```js
 * import { getRegisteredAppInfo, IApp } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * getRegisteredAppInfo({
 *   itemId: "xyz_itemId",
 *   authentication: authSession
 * }).then((registeredApp: IApp) => {
 *   // => {client_id: "xyz_id", client_secret: "xyz_secret", ...}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode getRegisteredAppInfo | getRegisteredAppInfo()}, including an itemId of which app to retrieve and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IApp} object representing successfully retrieved app.
 */
async function getRegisteredAppInfo(requestOptions) {
    const userName = await requestOptions.authentication.getUsername();
    const url = getPortalUrl(requestOptions) +
        `/content/users/${userName}/items/${requestOptions.itemId}/registeredAppInfo`;
    requestOptions.httpMethod = "POST";
    const registeredAppResponse = await request(url, Object.assign(Object.assign({}, requestOptions), { params: { f: "json" } }));
    return registeredAppResponseToApp(registeredAppResponse);
}

async function generateApiKeyToken(options) {
    const portal = getPortalUrl(options);
    const url = `${portal}/oauth2/token`;
    const appInfo = await getRegisteredAppInfo({
        itemId: options.itemId,
        authentication: options.authentication
    });
    const params = {
        client_id: appInfo.client_id,
        client_secret: appInfo.client_secret,
        apiToken: options.apiKey,
        regenerateApiToken: true,
        grant_type: "client_credentials"
    };
    // authentication is not being passed to the request because client_secret acts as the auth
    return request(url, {
        params
    });
}

/**
 * @internal
 * Encode special params value (e.g. array type...) in advance in order to make {@linkcode encodeParam} works correctly. Usage is case by case.
 */
const stringifyArrays = (requestOptions) => {
    Object.entries(requestOptions.params).forEach((entry) => {
        const [key, value] = entry;
        if (value.constructor.name === "Array") {
            requestOptions.params[key] = JSON.stringify(value);
        }
    });
};
/**
 * @internal
 * Used to convert {@linkcode IRegisteredAppResponse} to {@linkcode IApp}.
 */
function registeredAppResponseToApp(response) {
    const omittedKeys = [
        "apnsProdCert",
        "apnsSandboxCert",
        "gcmApiKey",
        "isBeta",
        "customAppLoginShowTriage"
    ];
    const dateKeys = ["modified", "registered"];
    return Object.keys(response)
        .filter((key) => !omittedKeys.includes(key))
        .reduce((obj, key) => {
        if (dateKeys.includes(key)) {
            obj[key] = new Date(response[key]);
        }
        else {
            obj[key] = response[key];
        }
        return obj;
    }, {});
}
/**
 * @internal
 * Used to convert {@linkcode IApp} to {@linkcode IApiKeyInfo} only if `appType` is "apikey".
 */
function appToApiKeyProperties(response) {
    delete response.client_secret;
    delete response.redirect_uris;
    delete response.appType;
    delete response.customAppLoginShowTriage;
    delete response.apiKey;
    return response;
}
/**
 * @internal
 * Used to convert {@linkcode IApp} to {@linkcode IOAuthAppInfo}.
 */
function appToOAuthAppProperties(response) {
    delete response.appType;
    delete response.httpReferrers;
    delete response.privileges;
    delete response.apiKey;
    delete response.customAppLoginShowTriage;
    delete response.isPersonalAPIToken;
    delete response.apiToken1Active;
    delete response.apiToken2Active;
    return response;
}
/**
 * @internal
 * Used to extract base request options from a hybrid option and exclude `params` and `authentication`.
 */
function extractBaseRequestOptions(options) {
    const requestOptionsProperties = [
        "credentials",
        "headers",
        "hideToken",
        "httpMethod",
        "maxUrlLength",
        "portal",
        "rawResponse",
        "signal",
        "suppressWarnings"
    ];
    return filterKeys(options, requestOptionsProperties);
}
/**
 * @internal
 * Used to create a new object including only specified keys from another object.
 */
function filterKeys(object, includedKeys) {
    return includedKeys.reduce((obj, ele) => {
        if (ele in object) {
            obj[ele] = object[ele];
        }
        return obj;
    }, {});
}
/**
 * Used to determine if a generated key is in slot 1 or slot 2 key. The full API key should be passed. `undefined` will be returned if the proper slot could not be identified.
 */
function slotForKey(key) {
    const slot = parseInt(key.substring(key.length - 10, key.length - 9));
    if (slot === 1 || slot === 2) {
        return slot;
    }
    return undefined;
}
/**
 * @internal
 * Used to determine which slot to invalidate a key in given a number or a full or patial key.
 */
function slotForInvalidationKey(param) {
    if (param === 1 || param === 2) {
        return param;
    }
    if (typeof param !== "string") {
        return undefined;
    }
    const fullKeySlot = slotForKey(param);
    if (fullKeySlot) {
        return fullKeySlot;
    }
}
/**
 * @internal
 * Used to generate tokens in slot 1 and/or 2 of an API key.
 */
function generateApiKeyTokens(itemId, slots, requestOptions) {
    return Promise.all(slots.map((slot) => {
        return generateApiKeyToken(Object.assign({ itemId, apiKey: slot }, requestOptions));
    })).then((responses) => {
        return responses
            .map((responses) => responses.access_token)
            .reduce((obj, token, index) => {
            obj[`accessToken${slotForKey(token)}`] = token;
            return obj;
        }, {});
    });
}
/**
 * @internal
 * Convert boolean flags to an array of slots for {@linkcode generateApiKeyTokens}.
 */
function generateOptionsToSlots(generateToken1, generateToken2) {
    const slots = [];
    if (generateToken1) {
        slots.push(1);
    }
    if (generateToken2) {
        slots.push(2);
    }
    return slots;
}
/**
 * @internal
 * Build params for updating expiration dates
 */
function buildExpirationDateParams(requestOptions, fillDefaults) {
    const updateparams = {};
    if (requestOptions.apiToken1ExpirationDate) {
        updateparams.apiToken1ExpirationDate =
            requestOptions.apiToken1ExpirationDate;
    }
    if (requestOptions.apiToken2ExpirationDate) {
        updateparams.apiToken2ExpirationDate =
            requestOptions.apiToken2ExpirationDate;
    }
    if (fillDefaults && !updateparams.apiToken1ExpirationDate) {
        updateparams.apiToken1ExpirationDate = -1;
    }
    if (fillDefaults && !updateparams.apiToken2ExpirationDate) {
        updateparams.apiToken2ExpirationDate = -1;
    }
    return updateparams;
}

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to register an app. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/register-app.htm) for more information.
 *
 * Accepted app types:
 * - apikey
 * - multiple
 * - browser
 * - server
 * - native
 *
 * ```js
 * import { registerApp, IApp } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * registerApp({
 *   itemId: "xyz_itemId",
 *   appType: "multiple",
 *   redirect_uris: ["http://localhost:3000/"],
 *   httpReferrers: ["http://localhost:3000/"],
 *   privileges: ["premium:user:geocode:temporary", Privileges.FeatureReport],
 *   authentication: authSession
 * }).then((registeredApp: IApp) => {
 *   // => {client_id: "xyz_id", client_secret: "xyz_secret", ...}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode registerApp | registerApp()}, including necessary params to register an app and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IApp} object representing the newly registered app.
 */
async function registerApp(requestOptions) {
    // build params
    const options = appendCustomParams(requestOptions, [
        "itemId",
        "appType",
        "redirect_uris",
        "httpReferrers",
        "privileges"
    ]);
    // encode special params value (e.g. array type...) in advance in order to make encodeQueryString() works correctly
    stringifyArrays(options);
    const url = getPortalUrl(options) + "/oauth2/registerApp";
    options.httpMethod = "POST";
    options.params.f = "json";
    const registeredAppResponse = await request(url, options);
    return registeredAppResponseToApp(registeredAppResponse);
}

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to register an API key. See the [security and authentication](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/api-keys/) for more information about API key.
 *
 * ```js
 * import { createApiKey, IApiKeyResponse } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * const threeDaysFromToday = new Date();
 * threeDaysFromToday.setDate(threeDaysFromToday.getDate() + 3);
 * threeDaysFromToday.setHours(23, 59, 59, 999);
 *
 * createApiKey({
 *   title: "xyz_title",
 *   description: "xyz_desc",
 *   tags: ["xyz_tag1", "xyz_tag2"],
 *   privileges: ["premium:user:networkanalysis:routing"],
 *   authentication: authSession,
 *   generateToken1: true, // optional,generate a new token
 *   apiToken1ExpirationDate: threeDaysFromToday  // optional, update expiration date
 * }).then((registeredAPIKey: IApiKeyResponse) => {
 *   // => {accessToken1: "xyz_key", item: {tags: ["xyz_tag1", "xyz_tag2"], ...}, ...}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode createApiKey | createApiKey()}, including necessary params to register an API key and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IApiKeyResponse} object representing the newly registered API key.
 */
async function createApiKey(requestOptions) {
    requestOptions.httpMethod = "POST";
    // filter param buckets:
    const baseRequestOptions = extractBaseRequestOptions(requestOptions); // snapshot of basic IRequestOptions before customized params being built into it
    const itemAddProperties = [
        "categories",
        "culture",
        "description",
        "documentation",
        "extent",
        "owner",
        "properties",
        "snippet",
        "spatialReference",
        "tags",
        "title",
        "type",
        "typeKeywords",
        "url"
    ];
    /**
     * step 1: create item
     */
    const createItemOption = Object.assign(Object.assign({ item: Object.assign(Object.assign({}, filterKeys(requestOptions, itemAddProperties)), { type: "Application" }) }, baseRequestOptions), { authentication: requestOptions.authentication, params: {
            f: "json"
        } });
    const createItemResponse = await createItem(createItemOption);
    /**
     * getRegisteredAppInfoRoute
     */
    const registerAppOptions = Object.assign(Object.assign({ itemId: createItemResponse.id, appType: "multiple", redirect_uris: ["urn:ietf:wg:oauth:2.0:oob"], httpReferrers: requestOptions.httpReferrers || [], privileges: requestOptions.privileges }, baseRequestOptions), { authentication: requestOptions.authentication });
    const registeredAppResponse = await registerApp(registerAppOptions);
    /**
     * step 3: update item with desired expiration dates
     * you cannot set the expiration date propierties until you
     * regiester the app so this has to be a seperate step
     */
    await updateItem(Object.assign(Object.assign({}, baseRequestOptions), { item: Object.assign({ id: createItemResponse.id }, buildExpirationDateParams(requestOptions, true)), authentication: requestOptions.authentication }));
    /*
     * step 4: get item info
     */
    const itemInfo = await getItem(registeredAppResponse.itemId, Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication, params: { f: "json" } }));
    /**
     * step 5: generate tokens if requested
     */
    const generatedTokens = await generateApiKeyTokens(itemInfo.id, generateOptionsToSlots(requestOptions.generateToken1, requestOptions.generateToken2), Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication }));
    /**
     * step 6: get registered app info to get updated active key status
     */
    const updatedRegisteredAppResponse = await getRegisteredAppInfo(Object.assign(Object.assign({}, baseRequestOptions), { itemId: itemInfo.id, authentication: requestOptions.authentication }));
    return Object.assign(Object.assign(Object.assign({}, generatedTokens), appToApiKeyProperties(updatedRegisteredAppResponse)), { item: itemInfo });
}

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to update an API key.
 *
 * Notes about `privileges` and `httpReferrers` options:
 * 1. Provided option will override corresponding old option.
 * 2. Unprovided option will not trigger corresponding option updates.
 *
 * ```js
 * import { updateApiKey, IApiKeyResponse } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * const threeDaysFromToday = new Date();
 * threeDaysFromToday.setDate(threeDaysFromToday.getDate() + 3);
 * threeDaysFromToday.setHours(23, 59, 59, 999);
 *
 * updateApiKey({
 *   itemId: "xyz_itemId",
 *   privileges: ["premium:user:geocode:temporary"],
 *   httpReferrers: [], // httpReferrers will be set to be empty
 *   authentication: authSession
 *   generateToken1: true, // optional,generate a new token
 *   apiToken1ExpirationDate: threeDaysFromToday  // optional, update expiration date
 * }).then((updatedAPIKey: IApiKeyResponse) => {
 *   // => {accessToken1: "xyz_key", item: {tags: ["xyz_tag1", "xyz_tag2"], ...}, ...}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode updateApiKey | updateApiKey()}, including `itemId` of which API key to be operated on, optional new `privileges`, optional new `httpReferrers` and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IApiKeyResponse} object representing updated API key.
 */
async function updateApiKey(requestOptions) {
    requestOptions.httpMethod = "POST";
    const baseRequestOptions = extractBaseRequestOptions(requestOptions); // get base requestOptions snapshot
    /**
     * step 1: update expiration dates if provided. Build the object up to avoid overwriting any existing properties.
     */
    if (requestOptions.apiToken1ExpirationDate ||
        requestOptions.apiToken2ExpirationDate) {
        const updateParams = buildExpirationDateParams(requestOptions);
        await updateItem(Object.assign(Object.assign({}, baseRequestOptions), { item: Object.assign({ id: requestOptions.itemId }, updateParams), authentication: requestOptions.authentication }));
    }
    /**
     * step 2: update privileges and httpReferrers if provided. Build the object up to avoid overwriting any existing properties.
     */
    if (requestOptions.privileges || requestOptions.httpReferrers) {
        const getAppOption = Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication, itemId: requestOptions.itemId });
        const appResponse = await getRegisteredAppInfo(getAppOption);
        const clientId = appResponse.client_id;
        const options = appendCustomParams(Object.assign(Object.assign({}, appResponse), requestOptions), // object with the custom params to look in
        ["privileges", "httpReferrers"] // keys you want copied to the params object
        );
        options.params.f = "json";
        // encode special params value (e.g. array type...) in advance in order to make encodeQueryString() works correctly
        stringifyArrays(options);
        const url = getPortalUrl(options) + `/oauth2/apps/${clientId}/update`;
        // Raw response from `/oauth2/apps/${clientId}/update`, apiKey not included because key is same.
        await request(url, Object.assign(Object.assign({}, options), { authentication: requestOptions.authentication }));
    }
    /**
     * step 3: get the updated item info to return to the user.
     */
    const updatedItemInfo = await getItem(requestOptions.itemId, Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication, params: { f: "json" } }));
    /**
     * step 4: generate tokens if requested
     */
    const generatedTokens = await generateApiKeyTokens(requestOptions.itemId, generateOptionsToSlots(requestOptions.generateToken1, requestOptions.generateToken2), Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication }));
    /**
     * step 5: get updated registered app info
     */
    const updatedRegisteredAppResponse = await getRegisteredAppInfo(Object.assign(Object.assign({}, baseRequestOptions), { itemId: requestOptions.itemId, authentication: requestOptions.authentication }));
    return Object.assign(Object.assign(Object.assign({}, generatedTokens), appToApiKeyProperties(updatedRegisteredAppResponse)), { item: updatedItemInfo });
}

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to retrieve the API key with given `itemId`. See the [security and authentication](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/api-keys/) for more information about API key.
 *
 * ```js
 * import { getApiKey, IApiKeyResponse } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * getApiKey({
 *   itemId: "xyz_itemId",
 *   authentication: authSession
 * }).then((retrievedAPIKey: IApiKeyResponse) => {
 *   // => {apiKey: "xyz_key", item: {tags: ["xyz_tag1", "xyz_tag2"], ...}, ...}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode getApiKey | getApiKey()}, including `itemId` of which API key to retrieve and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IApiKeyResponse} object representing successfully retrieved API key.
 */
async function getApiKey(requestOptions) {
    const appResponse = await getRegisteredAppInfo(requestOptions);
    const itemInfo = await getItem(requestOptions.itemId, Object.assign(Object.assign({}, extractBaseRequestOptions(requestOptions)), { authentication: requestOptions.authentication }));
    return Object.assign(Object.assign({}, appToApiKeyProperties(appResponse)), { item: itemInfo });
}

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to invalidate an API key.
 *
 * ```js
 * import { invalidateApiKey } from "@esri/arcgis-rest-developer-credentials";
 *
 * invalidateApiKey({
 *   itemId: ITEM_ID,
 *   authentication,
 *   apiKey: 1, // invalidate the key in slot 1
 * }).then((response) => {
 *   // => {success: true}
 * }).catch(e => {
 *   // => an exception object
 * });
 */
async function invalidateApiKey(requestOptions) {
    const portal = getPortalUrl(requestOptions);
    const url = `${portal}/oauth2/revokeToken`;
    const appInfo = await getRegisteredAppInfo({
        itemId: requestOptions.itemId,
        authentication: requestOptions.authentication
    });
    const params = {
        client_id: appInfo.client_id,
        client_secret: appInfo.client_secret,
        apiToken: slotForInvalidationKey(requestOptions.apiKey),
        regenerateApiToken: true,
        grant_type: "client_credentials"
    };
    // authentication is not being passed to the request because client_secret acts as the auth
    return request(url, {
        params
    });
}

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to retrieve the OAuth2.0 app with given `itemId`. See the [OAuth2.0](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/oauth-2.0/) for more information.
 *
 * ```js
 * import { getOAuthApp, IOAuthApp } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * getOAuthApp({
 *   itemId: "xyz_itemId",
 *   authentication: authSession
 * }).then((retrievedOAuthApp: IOAuthApp) => {
 *   // => {redirect_uris: ["http://localhost:3000/"], item: {tags: ["xyz_tag1", "xyz_tag2"], ...}, ...}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode getOAuthApp | getOAuthApp()}, including `itemId` of which OAuth app to retrieve and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IOAuthApp} object representing successfully retrieved OAuth app.
 */
async function getOAuthApp(requestOptions) {
    const appResponse = await getRegisteredAppInfo(requestOptions);
    const itemInfo = await getItem(requestOptions.itemId, Object.assign(Object.assign({}, extractBaseRequestOptions(requestOptions)), { authentication: requestOptions.authentication }));
    return Object.assign(Object.assign({}, appToOAuthAppProperties(appResponse)), { item: itemInfo });
}

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to update an OAuth2.0 app.
 *
 * Notes about `redirect_uris` options:
 * 1. Provided option will override corresponding old option.
 * 2. Unprovided option will not trigger corresponding option updates.
 *
 * ```js
 * import { updateOAuthApp, IOAuthApp } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * updateOAuthApp({
 *   itemId: "xyz_itemId",
 *   authentication: authSession
 * }).then((updatedOAuthApp: IOAuthApp) => {
 *   // => This OAuth app will be not be updated because its redirect_uris is not provided.
 *   // => {redirect_uris: ["http://localhost:3000/"], item: {tags: ["xyz_tag1", "xyz_tag2"], ...}, ...}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode updateOAuthApp | updateOAuthApp()}, including `itemId` of which OAuth app to be operated on, optional new `redirect_uris` and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IOAuthApp} object representing updated OAuth app.
 */
async function updateOAuthApp(requestOptions) {
    requestOptions.httpMethod = "POST";
    // get app
    const baseRequestOptions = extractBaseRequestOptions(requestOptions); // get base requestOptions snapshot
    const getAppOption = Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication, itemId: requestOptions.itemId });
    const appResponse = await getRegisteredAppInfo(getAppOption);
    if (appResponse.appType === "apikey") {
        throw new Error("Item is not an OAuth 2.0 app.");
    }
    const clientId = appResponse.client_id;
    const options = appendCustomParams(Object.assign(Object.assign({}, appResponse), requestOptions), [
        "redirect_uris"
    ]);
    options.params.f = "json";
    options.params.appType = "multiple";
    // encode special params value (e.g. array type...) in advance in order to make encodeQueryString() works correctly
    stringifyArrays(options);
    const url = getPortalUrl(options) + `/oauth2/apps/${clientId}/update`;
    // Raw response from `/oauth2/apps/${clientId}/update`.
    const updateResponse = await request(url, Object.assign(Object.assign({}, options), { authentication: requestOptions.authentication }));
    const app = registeredAppResponseToApp(updateResponse);
    const itemInfo = await getItem(requestOptions.itemId, Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication, params: { f: "json" } }));
    return Object.assign(Object.assign({}, appToOAuthAppProperties(app)), { item: itemInfo });
}

/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
/**
 * Used to register an OAuth2.0 app. See the [OAuth2.0](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/oauth-2.0/) for more information.
 *
 * ```js
 * import { createOAuthApp, IOAuthApp } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * createOAuthApp({
 *   title: "xyz_title",
 *   description: "xyz_desc",
 *   tags: ["xyz_tag1", "xyz_tag2"],
 *   redirect_uris: ["http://localhost:3000/"],
 *   authentication: authSession
 * }).then((registeredOAuthApp: IOAuthApp) => {
 *   // => {redirect_uris: ["http://localhost:3000/"], item: {tags: ["xyz_tag1", "xyz_tag2"], ...}, ...}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode createOAuthApp | createOAuthApp()}, including necessary params to register an OAuth app and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IOAuthApp} object representing the newly registered OAuth app.
 */
async function createOAuthApp(requestOptions) {
    requestOptions.httpMethod = "POST";
    // filter param buckets:
    const baseRequestOptions = extractBaseRequestOptions(requestOptions);
    const itemAddProperties = [
        "categories",
        "culture",
        "description",
        "documentation",
        "extent",
        "owner",
        "properties",
        "snippet",
        "spatialReference",
        "tags",
        "title",
        "type",
        "typeKeywords",
        "url"
    ];
    // step 1: add item
    const createItemOption = Object.assign(Object.assign({ item: Object.assign(Object.assign({}, filterKeys(requestOptions, itemAddProperties)), { type: "Application" }) }, baseRequestOptions), { authentication: requestOptions.authentication, params: {
            f: "json"
        } });
    const createItemResponse = await createItem(createItemOption);
    // step 2: register app
    const registerAppOption = Object.assign(Object.assign({ itemId: createItemResponse.id, appType: "multiple", redirect_uris: requestOptions.redirect_uris || [], httpReferrers: [], privileges: [] }, baseRequestOptions), { authentication: requestOptions.authentication });
    const registeredAppResponse = await registerApp(registerAppOption);
    const itemInfo = await getItem(registeredAppResponse.itemId, Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication, params: { f: "json" } }));
    return Object.assign(Object.assign({}, appToOAuthAppProperties(registeredAppResponse)), { item: itemInfo });
}

/**
 * Used to unregister the app with given `itemId`. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/unregister-app.htm) for more information.
 *
 * ```js
 * import { unregisterApp, IUnregisterAppResponse } from '@esri/arcgis-rest-developer-credentials';
 * import { ArcGISIdentityManager } from "@esri/arcgis-rest-request";
 *
 * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({
 *   username: "xyz_usrName",
 *   password: "xyz_pw"
 * });
 *
 * unregisterApp({
 *   itemId: "xyz_itemId",
 *   authentication: authSession
 * }).then((unregisteredApp: IUnregisterAppResponse) => {
 *   // => {itemId: "xyz_itemId", success: true}
 * }).catch(e => {
 *   // => an exception object
 * });
 * ```
 *
 * @param requestOptions - Options for {@linkcode unregisterApp | unregisterApp()}, including `itemId` of which app to be un-registered and an {@linkcode ArcGISIdentityManager} authentication session.
 * @returns A Promise that will resolve to an {@linkcode IUnregisterAppResponse} object representing un-registration status.
 */
async function unregisterApp(requestOptions) {
    requestOptions.httpMethod = "POST";
    // get app
    const baseRequestOptions = extractBaseRequestOptions(requestOptions);
    const getAppOption = Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication, itemId: requestOptions.itemId });
    const appResponse = await getRegisteredAppInfo(getAppOption);
    const clientId = appResponse.client_id;
    const url = getPortalUrl(requestOptions) + `/oauth2/apps/${clientId}/unregister`;
    const unregisterAppResponse = await request(url, Object.assign(Object.assign({}, baseRequestOptions), { authentication: requestOptions.authentication, params: { f: "json" } }));
    return unregisterAppResponse;
}

export { appToApiKeyProperties, appToOAuthAppProperties, buildExpirationDateParams, createApiKey, createOAuthApp, extractBaseRequestOptions, filterKeys, generateApiKeyTokens, generateOptionsToSlots, getApiKey, getOAuthApp, getRegisteredAppInfo, invalidateApiKey, registerApp, registeredAppResponseToApp, slotForInvalidationKey, slotForKey, stringifyArrays, unregisterApp, updateApiKey, updateOAuthApp };
//# sourceMappingURL=developer-credentials.esm.js.map
