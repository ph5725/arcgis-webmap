{"version":3,"file":"updateApiKey.js","sourceRoot":"","sources":["../../src/updateApiKey.ts"],"names":[],"mappings":";AAAA;gBACgB;;;AAMhB,8EAAwE;AACxE,oDAQ6B;AAC7B,iEAA6E;AAC7E,mEAAwE;AAOxE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCG;AACI,KAAK,UAAU,YAAY,CAChC,cAAoC;IAEpC,cAAc,CAAC,UAAU,GAAG,MAAM,CAAC;IACnC,MAAM,kBAAkB,GAAG,IAAA,sCAAyB,EAAC,cAAc,CAAC,CAAC,CAAC,mCAAmC;IAEzG;;OAEG;IACH,IACE,cAAc,CAAC,uBAAuB;QACtC,cAAc,CAAC,uBAAuB,EACtC;QACA,MAAM,YAAY,GAAG,IAAA,sCAAyB,EAAC,cAAc,CAAC,CAAC;QAC/D,MAAM,IAAA,+BAAU,kCACX,kBAAkB,KACrB,IAAI,kBACF,EAAE,EAAE,cAAc,CAAC,MAAM,IACtB,YAAY,GAEjB,cAAc,EAAE,cAAc,CAAC,cAAc,IAC7C,CAAC;KACJ;IAED;;OAEG;IACH,IAAI,cAAc,CAAC,UAAU,IAAI,cAAc,CAAC,aAAa,EAAE;QAC7D,MAAM,YAAY,mCACb,kBAAkB,KACrB,cAAc,EAAE,cAAc,CAAC,cAAc,EAC7C,MAAM,EAAE,cAAc,CAAC,MAAM,GAC9B,CAAC;QACF,MAAM,WAAW,GAAG,MAAM,IAAA,8CAAoB,EAAC,YAAY,CAAC,CAAC;QAC7D,MAAM,QAAQ,GAAG,WAAW,CAAC,SAAS,CAAC;QACvC,MAAM,OAAO,GAAG,IAAA,wCAAkB,kCAC3B,WAAW,GAAK,cAAc,GAAI,2CAA2C;QAClF,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC,4CAA4C;SAC7E,CAAC;QACF,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC;QAE1B,mHAAmH;QACnH,IAAA,4BAAe,EAAC,OAAO,CAAC,CAAC;QAEzB,MAAM,GAAG,GAAG,IAAA,iCAAY,EAAC,OAAO,CAAC,GAAG,gBAAgB,QAAQ,SAAS,CAAC;QAEtE,gGAAgG;QAChG,MAAM,cAAc,GAA2B,MAAM,IAAA,6BAAO,EAAC,GAAG,kCAC3D,OAAO,KACV,cAAc,EAAE,cAAc,CAAC,cAAc,IAC7C,CAAC;KACJ;IAED;;OAEG;IACH,MAAM,eAAe,GAAG,MAAM,IAAA,4BAAO,EAAC,cAAc,CAAC,MAAM,kCACtD,kBAAkB,KACrB,cAAc,EAAE,cAAc,CAAC,cAAc,EAC7C,MAAM,EAAE,EAAE,CAAC,EAAE,MAAM,EAAE,IACrB,CAAC;IAEH;;OAEG;IACH,MAAM,eAAe,GAAG,MAAM,IAAA,iCAAoB,EAChD,cAAc,CAAC,MAAM,EACrB,IAAA,mCAAsB,EACpB,cAAc,CAAC,cAAc,EAC7B,cAAc,CAAC,cAAc,CAC9B,kCAEI,kBAAkB,KACrB,cAAc,EAAE,cAAc,CAAC,cAAc,IAEhD,CAAC;IAEF;;OAEG;IACH,MAAM,4BAA4B,GAAG,MAAM,IAAA,8CAAoB,kCAC1D,kBAAkB,KACrB,MAAM,EAAE,cAAc,CAAC,MAAM,EAC7B,cAAc,EAAE,cAAc,CAAC,cAAc,IAC7C,CAAC;IAEH,qDACK,eAAe,GACf,IAAA,kCAAqB,EAAC,4BAA4B,CAAC,KACtD,IAAI,EAAE,eAAe,IACrB;AACJ,CAAC;AA3FD,oCA2FC","sourcesContent":["/* Copyright (c) 2023 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  IApiKeyResponse,\n  IUpdateApiKeyOptions\n} from \"./shared/types/apiKeyType.js\";\nimport { getRegisteredAppInfo } from \"./shared/getRegisteredAppInfo.js\";\nimport {\n  appToApiKeyProperties,\n  extractBaseRequestOptions,\n  stringifyArrays,\n  registeredAppResponseToApp,\n  generateApiKeyTokens,\n  generateOptionsToSlots,\n  buildExpirationDateParams\n} from \"./shared/helpers.js\";\nimport { getItem, getPortalUrl, updateItem } from \"@esri/arcgis-rest-portal\";\nimport { appendCustomParams, request } from \"@esri/arcgis-rest-request\";\nimport {\n  IApp,\n  IGetAppInfoOptions,\n  IRegisteredAppResponse\n} from \"./shared/types/appType.js\";\n\n/**\n * Used to update an API key.\n *\n * Notes about `privileges` and `httpReferrers` options:\n * 1. Provided option will override corresponding old option.\n * 2. Unprovided option will not trigger corresponding option updates.\n *\n * ```js\n * import { updateApiKey, IApiKeyResponse } from '@esri/arcgis-rest-developer-credentials';\n * import { ArcGISIdentityManager } from \"@esri/arcgis-rest-request\";\n *\n * const authSession: ArcGISIdentityManager = await ArcGISIdentityManager.signIn({\n *   username: \"xyz_usrName\",\n *   password: \"xyz_pw\"\n * });\n *\n * const threeDaysFromToday = new Date();\n * threeDaysFromToday.setDate(threeDaysFromToday.getDate() + 3);\n * threeDaysFromToday.setHours(23, 59, 59, 999);\n *\n * updateApiKey({\n *   itemId: \"xyz_itemId\",\n *   privileges: [\"premium:user:geocode:temporary\"],\n *   httpReferrers: [], // httpReferrers will be set to be empty\n *   authentication: authSession\n *   generateToken1: true, // optional,generate a new token\n *   apiToken1ExpirationDate: threeDaysFromToday  // optional, update expiration date\n * }).then((updatedAPIKey: IApiKeyResponse) => {\n *   // => {accessToken1: \"xyz_key\", item: {tags: [\"xyz_tag1\", \"xyz_tag2\"], ...}, ...}\n * }).catch(e => {\n *   // => an exception object\n * });\n * ```\n *\n * @param requestOptions - Options for {@linkcode updateApiKey | updateApiKey()}, including `itemId` of which API key to be operated on, optional new `privileges`, optional new `httpReferrers` and an {@linkcode ArcGISIdentityManager} authentication session.\n * @returns A Promise that will resolve to an {@linkcode IApiKeyResponse} object representing updated API key.\n */\nexport async function updateApiKey(\n  requestOptions: IUpdateApiKeyOptions\n): Promise<IApiKeyResponse> {\n  requestOptions.httpMethod = \"POST\";\n  const baseRequestOptions = extractBaseRequestOptions(requestOptions); // get base requestOptions snapshot\n\n  /**\n   * step 1: update expiration dates if provided. Build the object up to avoid overwriting any existing properties.\n   */\n  if (\n    requestOptions.apiToken1ExpirationDate ||\n    requestOptions.apiToken2ExpirationDate\n  ) {\n    const updateParams = buildExpirationDateParams(requestOptions);\n    await updateItem({\n      ...baseRequestOptions,\n      item: {\n        id: requestOptions.itemId,\n        ...updateParams\n      },\n      authentication: requestOptions.authentication\n    });\n  }\n\n  /**\n   * step 2: update privileges and httpReferrers if provided. Build the object up to avoid overwriting any existing properties.\n   */\n  if (requestOptions.privileges || requestOptions.httpReferrers) {\n    const getAppOption: IGetAppInfoOptions = {\n      ...baseRequestOptions,\n      authentication: requestOptions.authentication,\n      itemId: requestOptions.itemId\n    };\n    const appResponse = await getRegisteredAppInfo(getAppOption);\n    const clientId = appResponse.client_id;\n    const options = appendCustomParams(\n      { ...appResponse, ...requestOptions }, // object with the custom params to look in\n      [\"privileges\", \"httpReferrers\"] // keys you want copied to the params object\n    );\n    options.params.f = \"json\";\n\n    // encode special params value (e.g. array type...) in advance in order to make encodeQueryString() works correctly\n    stringifyArrays(options);\n\n    const url = getPortalUrl(options) + `/oauth2/apps/${clientId}/update`;\n\n    // Raw response from `/oauth2/apps/${clientId}/update`, apiKey not included because key is same.\n    const updateResponse: IRegisteredAppResponse = await request(url, {\n      ...options,\n      authentication: requestOptions.authentication\n    });\n  }\n\n  /**\n   * step 3: get the updated item info to return to the user.\n   */\n  const updatedItemInfo = await getItem(requestOptions.itemId, {\n    ...baseRequestOptions,\n    authentication: requestOptions.authentication,\n    params: { f: \"json\" }\n  });\n\n  /**\n   * step 4: generate tokens if requested\n   */\n  const generatedTokens = await generateApiKeyTokens(\n    requestOptions.itemId,\n    generateOptionsToSlots(\n      requestOptions.generateToken1,\n      requestOptions.generateToken2\n    ),\n    {\n      ...baseRequestOptions,\n      authentication: requestOptions.authentication\n    }\n  );\n\n  /**\n   * step 5: get updated registered app info\n   */\n  const updatedRegisteredAppResponse = await getRegisteredAppInfo({\n    ...baseRequestOptions,\n    itemId: requestOptions.itemId,\n    authentication: requestOptions.authentication\n  });\n\n  return {\n    ...generatedTokens,\n    ...appToApiKeyProperties(updatedRegisteredAppResponse),\n    item: updatedItemInfo\n  };\n}\n"]}