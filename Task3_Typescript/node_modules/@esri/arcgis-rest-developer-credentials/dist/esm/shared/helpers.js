import { generateApiKeyToken } from "./generateApiKeyToken.js";
/**
 * @internal
 * Encode special params value (e.g. array type...) in advance in order to make {@linkcode encodeParam} works correctly. Usage is case by case.
 */
export const stringifyArrays = (requestOptions) => {
    Object.entries(requestOptions.params).forEach((entry) => {
        const [key, value] = entry;
        if (value.constructor.name === "Array") {
            requestOptions.params[key] = JSON.stringify(value);
        }
    });
};
/**
 * @internal
 * Used to convert {@linkcode IRegisteredAppResponse} to {@linkcode IApp}.
 */
export function registeredAppResponseToApp(response) {
    const omittedKeys = [
        "apnsProdCert",
        "apnsSandboxCert",
        "gcmApiKey",
        "isBeta",
        "customAppLoginShowTriage"
    ];
    const dateKeys = ["modified", "registered"];
    return Object.keys(response)
        .filter((key) => !omittedKeys.includes(key))
        .reduce((obj, key) => {
        if (dateKeys.includes(key)) {
            obj[key] = new Date(response[key]);
        }
        else {
            obj[key] = response[key];
        }
        return obj;
    }, {});
}
/**
 * @internal
 * Used to convert {@linkcode IApp} to {@linkcode IApiKeyInfo} only if `appType` is "apikey".
 */
export function appToApiKeyProperties(response) {
    delete response.client_secret;
    delete response.redirect_uris;
    delete response.appType;
    delete response.customAppLoginShowTriage;
    delete response.apiKey;
    return response;
}
/**
 * @internal
 * Used to convert {@linkcode IApp} to {@linkcode IOAuthAppInfo}.
 */
export function appToOAuthAppProperties(response) {
    delete response.appType;
    delete response.httpReferrers;
    delete response.privileges;
    delete response.apiKey;
    delete response.customAppLoginShowTriage;
    delete response.isPersonalAPIToken;
    delete response.apiToken1Active;
    delete response.apiToken2Active;
    return response;
}
/**
 * @internal
 * Used to extract base request options from a hybrid option and exclude `params` and `authentication`.
 */
export function extractBaseRequestOptions(options) {
    const requestOptionsProperties = [
        "credentials",
        "headers",
        "hideToken",
        "httpMethod",
        "maxUrlLength",
        "portal",
        "rawResponse",
        "signal",
        "suppressWarnings"
    ];
    return filterKeys(options, requestOptionsProperties);
}
/**
 * @internal
 * Used to create a new object including only specified keys from another object.
 */
export function filterKeys(object, includedKeys) {
    return includedKeys.reduce((obj, ele) => {
        if (ele in object) {
            obj[ele] = object[ele];
        }
        return obj;
    }, {});
}
/**
 * Used to determine if a generated key is in slot 1 or slot 2 key. The full API key should be passed. `undefined` will be returned if the proper slot could not be identified.
 */
export function slotForKey(key) {
    const slot = parseInt(key.substring(key.length - 10, key.length - 9));
    if (slot === 1 || slot === 2) {
        return slot;
    }
    return undefined;
}
/**
 * @internal
 * Used to determine which slot to invalidate a key in given a number or a full or patial key.
 */
export function slotForInvalidationKey(param) {
    if (param === 1 || param === 2) {
        return param;
    }
    if (typeof param !== "string") {
        return undefined;
    }
    const fullKeySlot = slotForKey(param);
    if (fullKeySlot) {
        return fullKeySlot;
    }
}
/**
 * @internal
 * Used to generate tokens in slot 1 and/or 2 of an API key.
 */
export function generateApiKeyTokens(itemId, slots, requestOptions) {
    return Promise.all(slots.map((slot) => {
        return generateApiKeyToken(Object.assign({ itemId, apiKey: slot }, requestOptions));
    })).then((responses) => {
        return responses
            .map((responses) => responses.access_token)
            .reduce((obj, token, index) => {
            obj[`accessToken${slotForKey(token)}`] = token;
            return obj;
        }, {});
    });
}
/**
 * @internal
 * Convert boolean flags to an array of slots for {@linkcode generateApiKeyTokens}.
 */
export function generateOptionsToSlots(generateToken1, generateToken2) {
    const slots = [];
    if (generateToken1) {
        slots.push(1);
    }
    if (generateToken2) {
        slots.push(2);
    }
    return slots;
}
/**
 * @internal
 * Build params for updating expiration dates
 */
export function buildExpirationDateParams(requestOptions, fillDefaults) {
    const updateparams = {};
    if (requestOptions.apiToken1ExpirationDate) {
        updateparams.apiToken1ExpirationDate =
            requestOptions.apiToken1ExpirationDate;
    }
    if (requestOptions.apiToken2ExpirationDate) {
        updateparams.apiToken2ExpirationDate =
            requestOptions.apiToken2ExpirationDate;
    }
    if (fillDefaults && !updateparams.apiToken1ExpirationDate) {
        updateparams.apiToken1ExpirationDate = -1;
    }
    if (fillDefaults && !updateparams.apiToken2ExpirationDate) {
        updateparams.apiToken2ExpirationDate = -1;
    }
    return updateparams;
}
//# sourceMappingURL=helpers.js.map